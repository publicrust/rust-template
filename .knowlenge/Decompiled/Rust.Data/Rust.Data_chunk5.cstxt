using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppTeamInfo : IDisposable, IPooled, IProto<AppTeamInfo>, IProto
{
	public class Member : IDisposable, IPooled, IProto<Member>, IProto
	{
		[NonSerialized]
		public ulong steamId;

		[NonSerialized]
		public string name;

		[NonSerialized]
		public float x;

		[NonSerialized]
		public float y;

		[NonSerialized]
		public bool isOnline;

		[NonSerialized]
		public uint spawnTime;

		[NonSerialized]
		public bool isAlive;

		[NonSerialized]
		public uint deathTime;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Member instance)
		{
			if (instance.ShouldPool)
			{
				instance.steamId = 0uL;
				instance.name = string.Empty;
				instance.x = 0f;
				instance.y = 0f;
				instance.isOnline = false;
				instance.spawnTime = 0u;
				instance.isAlive = false;
				instance.deathTime = 0u;
				Pool.Free<Member>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Member with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Member instance)
		{
			instance.steamId = steamId;
			instance.name = name;
			instance.x = x;
			instance.y = y;
			instance.isOnline = isOnline;
			instance.spawnTime = spawnTime;
			instance.isAlive = isAlive;
			instance.deathTime = deathTime;
		}

		public Member Copy()
		{
			Member member = Pool.Get<Member>();
			CopyTo(member);
			return member;
		}

		public static Member Deserialize(BufferStream stream)
		{
			Member member = Pool.Get<Member>();
			Deserialize(stream, member, isDelta: false);
			return member;
		}

		public static Member DeserializeLengthDelimited(BufferStream stream)
		{
			Member member = Pool.Get<Member>();
			DeserializeLengthDelimited(stream, member, isDelta: false);
			return member;
		}

		public static Member DeserializeLength(BufferStream stream, int length)
		{
			Member member = Pool.Get<Member>();
			DeserializeLength(stream, length, member, isDelta: false);
			return member;
		}

		public static Member Deserialize(byte[] buffer)
		{
			Member member = Pool.Get<Member>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, member, isDelta: false);
			return member;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Member previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Member Deserialize(BufferStream stream, Member instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.x = 0f;
				instance.y = 0f;
				instance.isOnline = false;
				instance.spawnTime = 0u;
				instance.isAlive = false;
				instance.deathTime = 0u;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 29:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 37:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				case 40:
					instance.isOnline = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.spawnTime = ProtocolParser.ReadUInt32(stream);
					continue;
				case 56:
					instance.isAlive = ProtocolParser.ReadBool(stream);
					continue;
				case 64:
					instance.deathTime = ProtocolParser.ReadUInt32(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Member DeserializeLengthDelimited(BufferStream stream, Member instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.x = 0f;
				instance.y = 0f;
				instance.isOnline = false;
				instance.spawnTime = 0u;
				instance.isAlive = false;
				instance.deathTime = 0u;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 29:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 37:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				case 40:
					instance.isOnline = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.spawnTime = ProtocolParser.ReadUInt32(stream);
					continue;
				case 56:
					instance.isAlive = ProtocolParser.ReadBool(stream);
					continue;
				case 64:
					instance.deathTime = ProtocolParser.ReadUInt32(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Member DeserializeLength(BufferStream stream, int length, Member instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.x = 0f;
				instance.y = 0f;
				instance.isOnline = false;
				instance.spawnTime = 0u;
				instance.isAlive = false;
				instance.deathTime = 0u;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 29:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 37:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				case 40:
					instance.isOnline = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.spawnTime = ProtocolParser.ReadUInt32(stream);
					continue;
				case 56:
					instance.isAlive = ProtocolParser.ReadBool(stream);
					continue;
				case 64:
					instance.deathTime = ProtocolParser.ReadUInt32(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Member instance, Member previous)
		{
			if (instance.steamId != previous.steamId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.name);
			}
			if (instance.x != previous.x)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.x);
			}
			if (instance.y != previous.y)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.y);
			}
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.isOnline);
			if (instance.spawnTime != previous.spawnTime)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt32(stream, instance.spawnTime);
			}
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.isAlive);
			if (instance.deathTime != previous.deathTime)
			{
				stream.WriteByte(64);
				ProtocolParser.WriteUInt32(stream, instance.deathTime);
			}
		}

		public static void Serialize(BufferStream stream, Member instance)
		{
			if (instance.steamId != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.x != 0f)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.x);
			}
			if (instance.y != 0f)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.y);
			}
			if (instance.isOnline)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteBool(stream, instance.isOnline);
			}
			if (instance.spawnTime != 0)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt32(stream, instance.spawnTime);
			}
			if (instance.isAlive)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteBool(stream, instance.isAlive);
			}
			if (instance.deathTime != 0)
			{
				stream.WriteByte(64);
				ProtocolParser.WriteUInt32(stream, instance.deathTime);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class Note : IDisposable, IPooled, IProto<Note>, IProto
	{
		[NonSerialized]
		public int type;

		[NonSerialized]
		public float x;

		[NonSerialized]
		public float y;

		[NonSerialized]
		public int icon;

		[NonSerialized]
		public int colourIndex;

		[NonSerialized]
		public string label;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Note instance)
		{
			if (instance.ShouldPool)
			{
				instance.type = 0;
				instance.x = 0f;
				instance.y = 0f;
				instance.icon = 0;
				instance.colourIndex = 0;
				instance.label = string.Empty;
				Pool.Free<Note>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Note with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Note instance)
		{
			instance.type = type;
			instance.x = x;
			instance.y = y;
			instance.icon = icon;
			instance.colourIndex = colourIndex;
			instance.label = label;
		}

		public Note Copy()
		{
			Note note = Pool.Get<Note>();
			CopyTo(note);
			return note;
		}

		public static Note Deserialize(BufferStream stream)
		{
			Note note = Pool.Get<Note>();
			Deserialize(stream, note, isDelta: false);
			return note;
		}

		public static Note DeserializeLengthDelimited(BufferStream stream)
		{
			Note note = Pool.Get<Note>();
			DeserializeLengthDelimited(stream, note, isDelta: false);
			return note;
		}

		public static Note DeserializeLength(BufferStream stream, int length)
		{
			Note note = Pool.Get<Note>();
			DeserializeLength(stream, length, note, isDelta: false);
			return note;
		}

		public static Note Deserialize(byte[] buffer)
		{
			Note note = Pool.Get<Note>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, note, isDelta: false);
			return note;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Note previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Note Deserialize(BufferStream stream, Note instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.type = 0;
				instance.x = 0f;
				instance.y = 0f;
				instance.icon = 0;
				instance.colourIndex = 0;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 29:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 37:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				case 40:
					instance.icon = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 58:
					instance.label = ProtocolParser.ReadString(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Note DeserializeLengthDelimited(BufferStream stream, Note instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.type = 0;
				instance.x = 0f;
				instance.y = 0f;
				instance.icon = 0;
				instance.colourIndex = 0;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 29:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 37:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				case 40:
					instance.icon = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 58:
					instance.label = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Note DeserializeLength(BufferStream stream, int length, Note instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.type = 0;
				instance.x = 0f;
				instance.y = 0f;
				instance.icon = 0;
				instance.colourIndex = 0;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 29:
					instance.x = ProtocolParser.ReadSingle(stream);
					continue;
				case 37:
					instance.y = ProtocolParser.ReadSingle(stream);
					continue;
				case 40:
					instance.icon = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 58:
					instance.label = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Note instance, Note previous)
		{
			if (instance.type != previous.type)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.x != previous.x)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.x);
			}
			if (instance.y != previous.y)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.y);
			}
			if (instance.icon != previous.icon)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.icon);
			}
			if (instance.colourIndex != previous.colourIndex)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.colourIndex);
			}
			if (instance.label != null && instance.label != previous.label)
			{
				stream.WriteByte(58);
				ProtocolParser.WriteString(stream, instance.label);
			}
		}

		public static void Serialize(BufferStream stream, Note instance)
		{
			if (instance.type != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.x != 0f)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.x);
			}
			if (instance.y != 0f)
			{
				stream.WriteByte(37);
				ProtocolParser.WriteSingle(stream, instance.y);
			}
			if (instance.icon != 0)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.icon);
			}
			if (instance.colourIndex != 0)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.colourIndex);
			}
			if (instance.label != null)
			{
				stream.WriteByte(58);
				ProtocolParser.WriteString(stream, instance.label);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public ulong leaderSteamId;

	[NonSerialized]
	public List<Member> members;

	[NonSerialized]
	public List<Note> mapNotes;

	[NonSerialized]
	public List<Note> leaderMapNotes;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppTeamInfo instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.leaderSteamId = 0uL;
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				if (instance.members[i] != null)
				{
					instance.members[i].ResetToPool();
					instance.members[i] = null;
				}
			}
			List<Member> list = instance.members;
			Pool.Free<Member>(ref list, false);
			instance.members = list;
		}
		if (instance.mapNotes != null)
		{
			for (int j = 0; j < instance.mapNotes.Count; j++)
			{
				if (instance.mapNotes[j] != null)
				{
					instance.mapNotes[j].ResetToPool();
					instance.mapNotes[j] = null;
				}
			}
			List<Note> list2 = instance.mapNotes;
			Pool.Free<Note>(ref list2, false);
			instance.mapNotes = list2;
		}
		if (instance.leaderMapNotes != null)
		{
			for (int k = 0; k < instance.leaderMapNotes.Count; k++)
			{
				if (instance.leaderMapNotes[k] != null)
				{
					instance.leaderMapNotes[k].ResetToPool();
					instance.leaderMapNotes[k] = null;
				}
			}
			List<Note> list3 = instance.leaderMapNotes;
			Pool.Free<Note>(ref list3, false);
			instance.leaderMapNotes = list3;
		}
		Pool.Free<AppTeamInfo>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppTeamInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppTeamInfo instance)
	{
		instance.leaderSteamId = leaderSteamId;
		if (members != null)
		{
			instance.members = Pool.Get<List<Member>>();
			for (int i = 0; i < members.Count; i++)
			{
				Member item = members[i].Copy();
				instance.members.Add(item);
			}
		}
		else
		{
			instance.members = null;
		}
		if (mapNotes != null)
		{
			instance.mapNotes = Pool.Get<List<Note>>();
			for (int j = 0; j < mapNotes.Count; j++)
			{
				Note item2 = mapNotes[j].Copy();
				instance.mapNotes.Add(item2);
			}
		}
		else
		{
			instance.mapNotes = null;
		}
		if (leaderMapNotes != null)
		{
			instance.leaderMapNotes = Pool.Get<List<Note>>();
			for (int k = 0; k < leaderMapNotes.Count; k++)
			{
				Note item3 = leaderMapNotes[k].Copy();
				instance.leaderMapNotes.Add(item3);
			}
		}
		else
		{
			instance.leaderMapNotes = null;
		}
	}

	public AppTeamInfo Copy()
	{
		AppTeamInfo appTeamInfo = Pool.Get<AppTeamInfo>();
		CopyTo(appTeamInfo);
		return appTeamInfo;
	}

	public static AppTeamInfo Deserialize(BufferStream stream)
	{
		AppTeamInfo appTeamInfo = Pool.Get<AppTeamInfo>();
		Deserialize(stream, appTeamInfo, isDelta: false);
		return appTeamInfo;
	}

	public static AppTeamInfo DeserializeLengthDelimited(BufferStream stream)
	{
		AppTeamInfo appTeamInfo = Pool.Get<AppTeamInfo>();
		DeserializeLengthDelimited(stream, appTeamInfo, isDelta: false);
		return appTeamInfo;
	}

	public static AppTeamInfo DeserializeLength(BufferStream stream, int length)
	{
		AppTeamInfo appTeamInfo = Pool.Get<AppTeamInfo>();
		DeserializeLength(stream, length, appTeamInfo, isDelta: false);
		return appTeamInfo;
	}

	public static AppTeamInfo Deserialize(byte[] buffer)
	{
		AppTeamInfo appTeamInfo = Pool.Get<AppTeamInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appTeamInfo, isDelta: false);
		return appTeamInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppTeamInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppTeamInfo Deserialize(BufferStream stream, AppTeamInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.leaderSteamId = 0uL;
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<Member>>();
			}
			if (instance.mapNotes == null)
			{
				instance.mapNotes = Pool.Get<List<Note>>();
			}
			if (instance.leaderMapNotes == null)
			{
				instance.leaderMapNotes = Pool.Get<List<Note>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.leaderSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.members.Add(Member.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.mapNotes.Add(Note.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				instance.leaderMapNotes.Add(Note.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppTeamInfo DeserializeLengthDelimited(BufferStream stream, AppTeamInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.leaderSteamId = 0uL;
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<Member>>();
			}
			if (instance.mapNotes == null)
			{
				instance.mapNotes = Pool.Get<List<Note>>();
			}
			if (instance.leaderMapNotes == null)
			{
				instance.leaderMapNotes = Pool.Get<List<Note>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.leaderSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.members.Add(Member.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.mapNotes.Add(Note.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				instance.leaderMapNotes.Add(Note.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppTeamInfo DeserializeLength(BufferStream stream, int length, AppTeamInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.leaderSteamId = 0uL;
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<Member>>();
			}
			if (instance.mapNotes == null)
			{
				instance.mapNotes = Pool.Get<List<Note>>();
			}
			if (instance.leaderMapNotes == null)
			{
				instance.leaderMapNotes = Pool.Get<List<Note>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.leaderSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.members.Add(Member.DeserializeLengthDelimited(stream));
				continue;
			case 26:
				instance.mapNotes.Add(Note.DeserializeLengthDelimited(stream));
				continue;
			case 34:
				instance.leaderMapNotes.Add(Note.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppTeamInfo instance, AppTeamInfo previous)
	{
		if (instance.leaderSteamId != previous.leaderSteamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.leaderSteamId);
		}
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				Member member = instance.members[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Member.SerializeDelta(stream, member, member);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.mapNotes != null)
		{
			for (int j = 0; j < instance.mapNotes.Count; j++)
			{
				Note note = instance.mapNotes[j];
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				Note.SerializeDelta(stream, note, note);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.leaderMapNotes == null)
		{
			return;
		}
		for (int k = 0; k < instance.leaderMapNotes.Count; k++)
		{
			Note note2 = instance.leaderMapNotes[k];
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			Note.SerializeDelta(stream, note2, note2);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, AppTeamInfo instance)
	{
		if (instance.leaderSteamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.leaderSteamId);
		}
		if (instance.members != null)
		{
			for (int i = 0; i < instance.members.Count; i++)
			{
				Member instance2 = instance.members[i];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Member.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.mapNotes != null)
		{
			for (int j = 0; j < instance.mapNotes.Count; j++)
			{
				Note instance3 = instance.mapNotes[j];
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				Note.Serialize(stream, instance3);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.leaderMapNotes == null)
		{
			return;
		}
		for (int k = 0; k < instance.leaderMapNotes.Count; k++)
		{
			Note instance4 = instance.leaderMapNotes[k];
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(5);
			int position3 = stream.Position;
			Note.Serialize(stream, instance4);
			int val3 = stream.Position - position3;
			Span<byte> span3 = range3.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
			if (num3 < 5)
			{
				span3[num3 - 1] |= 128;
				while (num3 < 4)
				{
					span3[num3++] = 128;
				}
				span3[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (members != null)
		{
			for (int i = 0; i < members.Count; i++)
			{
				members[i]?.InspectUids(action);
			}
		}
		if (mapNotes != null)
		{
			for (int j = 0; j < mapNotes.Count; j++)
			{
				mapNotes[j]?.InspectUids(action);
			}
		}
		if (leaderMapNotes != null)
		{
			for (int k = 0; k < leaderMapNotes.Count; k++)
			{
				leaderMapNotes[k]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppTeamMessage : IDisposable, IPooled, IProto<AppTeamMessage>, IProto
{
	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public string message;

	[NonSerialized]
	public string color;

	[NonSerialized]
	public uint time;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppTeamMessage instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			instance.name = string.Empty;
			instance.message = string.Empty;
			instance.color = string.Empty;
			instance.time = 0u;
			Pool.Free<AppTeamMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppTeamMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppTeamMessage instance)
	{
		instance.steamId = steamId;
		instance.name = name;
		instance.message = message;
		instance.color = color;
		instance.time = time;
	}

	public AppTeamMessage Copy()
	{
		AppTeamMessage appTeamMessage = Pool.Get<AppTeamMessage>();
		CopyTo(appTeamMessage);
		return appTeamMessage;
	}

	public static AppTeamMessage Deserialize(BufferStream stream)
	{
		AppTeamMessage appTeamMessage = Pool.Get<AppTeamMessage>();
		Deserialize(stream, appTeamMessage, isDelta: false);
		return appTeamMessage;
	}

	public static AppTeamMessage DeserializeLengthDelimited(BufferStream stream)
	{
		AppTeamMessage appTeamMessage = Pool.Get<AppTeamMessage>();
		DeserializeLengthDelimited(stream, appTeamMessage, isDelta: false);
		return appTeamMessage;
	}

	public static AppTeamMessage DeserializeLength(BufferStream stream, int length)
	{
		AppTeamMessage appTeamMessage = Pool.Get<AppTeamMessage>();
		DeserializeLength(stream, length, appTeamMessage, isDelta: false);
		return appTeamMessage;
	}

	public static AppTeamMessage Deserialize(byte[] buffer)
	{
		AppTeamMessage appTeamMessage = Pool.Get<AppTeamMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appTeamMessage, isDelta: false);
		return appTeamMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppTeamMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppTeamMessage Deserialize(BufferStream stream, AppTeamMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.time = 0u;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.color = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.time = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppTeamMessage DeserializeLengthDelimited(BufferStream stream, AppTeamMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.time = 0u;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.color = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.time = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppTeamMessage DeserializeLength(BufferStream stream, int length, AppTeamMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.time = 0u;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.color = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.time = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppTeamMessage instance, AppTeamMessage previous)
	{
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.message != previous.message)
		{
			if (instance.message == null)
			{
				throw new ArgumentNullException("message", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.message);
		}
		if (instance.color != previous.color)
		{
			if (instance.color == null)
			{
				throw new ArgumentNullException("color", "Required by proto specification.");
			}
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.color);
		}
		if (instance.time != previous.time)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.time);
		}
	}

	public static void Serialize(BufferStream stream, AppTeamMessage instance)
	{
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.message == null)
		{
			throw new ArgumentNullException("message", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.message);
		if (instance.color == null)
		{
			throw new ArgumentNullException("color", "Required by proto specification.");
		}
		stream.WriteByte(34);
		ProtocolParser.WriteString(stream, instance.color);
		if (instance.time != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt32(stream, instance.time);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppTeamChat : IDisposable, IPooled, IProto<AppTeamChat>, IProto
{
	[NonSerialized]
	public List<AppTeamMessage> messages;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppTeamChat instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.messages != null)
		{
			for (int i = 0; i < instance.messages.Count; i++)
			{
				if (instance.messages[i] != null)
				{
					instance.messages[i].ResetToPool();
					instance.messages[i] = null;
				}
			}
			List<AppTeamMessage> list = instance.messages;
			Pool.Free<AppTeamMessage>(ref list, false);
			instance.messages = list;
		}
		Pool.Free<AppTeamChat>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppTeamChat with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppTeamChat instance)
	{
		if (messages != null)
		{
			instance.messages = Pool.Get<List<AppTeamMessage>>();
			for (int i = 0; i < messages.Count; i++)
			{
				AppTeamMessage item = messages[i].Copy();
				instance.messages.Add(item);
			}
		}
		else
		{
			instance.messages = null;
		}
	}

	public AppTeamChat Copy()
	{
		AppTeamChat appTeamChat = Pool.Get<AppTeamChat>();
		CopyTo(appTeamChat);
		return appTeamChat;
	}

	public static AppTeamChat Deserialize(BufferStream stream)
	{
		AppTeamChat appTeamChat = Pool.Get<AppTeamChat>();
		Deserialize(stream, appTeamChat, isDelta: false);
		return appTeamChat;
	}

	public static AppTeamChat DeserializeLengthDelimited(BufferStream stream)
	{
		AppTeamChat appTeamChat = Pool.Get<AppTeamChat>();
		DeserializeLengthDelimited(stream, appTeamChat, isDelta: false);
		return appTeamChat;
	}

	public static AppTeamChat DeserializeLength(BufferStream stream, int length)
	{
		AppTeamChat appTeamChat = Pool.Get<AppTeamChat>();
		DeserializeLength(stream, length, appTeamChat, isDelta: false);
		return appTeamChat;
	}

	public static AppTeamChat Deserialize(byte[] buffer)
	{
		AppTeamChat appTeamChat = Pool.Get<AppTeamChat>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appTeamChat, isDelta: false);
		return appTeamChat;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppTeamChat previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppTeamChat Deserialize(BufferStream stream, AppTeamChat instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<AppTeamMessage>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.messages.Add(AppTeamMessage.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppTeamChat DeserializeLengthDelimited(BufferStream stream, AppTeamChat instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<AppTeamMessage>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.messages.Add(AppTeamMessage.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppTeamChat DeserializeLength(BufferStream stream, int length, AppTeamChat instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<AppTeamMessage>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.messages.Add(AppTeamMessage.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppTeamChat instance, AppTeamChat previous)
	{
		if (instance.messages == null)
		{
			return;
		}
		for (int i = 0; i < instance.messages.Count; i++)
		{
			AppTeamMessage appTeamMessage = instance.messages[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppTeamMessage.SerializeDelta(stream, appTeamMessage, appTeamMessage);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, AppTeamChat instance)
	{
		if (instance.messages == null)
		{
			return;
		}
		for (int i = 0; i < instance.messages.Count; i++)
		{
			AppTeamMessage instance2 = instance.messages[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppTeamMessage.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (messages != null)
		{
			for (int i = 0; i < messages.Count; i++)
			{
				messages[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class AppMarker : IDisposable, IPooled, IProto<AppMarker>, IProto
{
	public class SellOrder : IDisposable, IPooled, IProto<SellOrder>, IProto
	{
		[NonSerialized]
		public int itemId;

		[NonSerialized]
		public int quantity;

		[NonSerialized]
		public int currencyId;

		[NonSerialized]
		public int costPerItem;

		[NonSerialized]
		public int amountInStock;

		[NonSerialized]
		public bool itemIsBlueprint;

		[NonSerialized]
		public bool currencyIsBlueprint;

		[NonSerialized]
		public float itemCondition;

		[NonSerialized]
		public float itemConditionMax;

		[NonSerialized]
		public float priceMultiplier;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(SellOrder instance)
		{
			if (instance.ShouldPool)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.currencyId = 0;
				instance.costPerItem = 0;
				instance.amountInStock = 0;
				instance.itemIsBlueprint = false;
				instance.currencyIsBlueprint = false;
				instance.itemCondition = 0f;
				instance.itemConditionMax = 0f;
				instance.priceMultiplier = 0f;
				Pool.Free<SellOrder>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose SellOrder with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(SellOrder instance)
		{
			instance.itemId = itemId;
			instance.quantity = quantity;
			instance.currencyId = currencyId;
			instance.costPerItem = costPerItem;
			instance.amountInStock = amountInStock;
			instance.itemIsBlueprint = itemIsBlueprint;
			instance.currencyIsBlueprint = currencyIsBlueprint;
			instance.itemCondition = itemCondition;
			instance.itemConditionMax = itemConditionMax;
			instance.priceMultiplier = priceMultiplier;
		}

		public SellOrder Copy()
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			CopyTo(sellOrder);
			return sellOrder;
		}

		public static SellOrder Deserialize(BufferStream stream)
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			Deserialize(stream, sellOrder, isDelta: false);
			return sellOrder;
		}

		public static SellOrder DeserializeLengthDelimited(BufferStream stream)
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			DeserializeLengthDelimited(stream, sellOrder, isDelta: false);
			return sellOrder;
		}

		public static SellOrder DeserializeLength(BufferStream stream, int length)
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			DeserializeLength(stream, length, sellOrder, isDelta: false);
			return sellOrder;
		}

		public static SellOrder Deserialize(byte[] buffer)
		{
			SellOrder sellOrder = Pool.Get<SellOrder>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, sellOrder, isDelta: false);
			return sellOrder;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, SellOrder previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static SellOrder Deserialize(BufferStream stream, SellOrder instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.currencyId = 0;
				instance.costPerItem = 0;
				instance.amountInStock = 0;
				instance.itemIsBlueprint = false;
				instance.currencyIsBlueprint = false;
				instance.itemCondition = 0f;
				instance.itemConditionMax = 0f;
				instance.priceMultiplier = 0f;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.currencyId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.costPerItem = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.amountInStock = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.currencyIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				case 69:
					instance.itemCondition = ProtocolParser.ReadSingle(stream);
					continue;
				case 77:
					instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
					continue;
				case 85:
					instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static SellOrder DeserializeLengthDelimited(BufferStream stream, SellOrder instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.currencyId = 0;
				instance.costPerItem = 0;
				instance.amountInStock = 0;
				instance.itemIsBlueprint = false;
				instance.currencyIsBlueprint = false;
				instance.itemCondition = 0f;
				instance.itemConditionMax = 0f;
				instance.priceMultiplier = 0f;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.currencyId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.costPerItem = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.amountInStock = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.currencyIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				case 69:
					instance.itemCondition = ProtocolParser.ReadSingle(stream);
					continue;
				case 77:
					instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
					continue;
				case 85:
					instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static SellOrder DeserializeLength(BufferStream stream, int length, SellOrder instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.itemId = 0;
				instance.quantity = 0;
				instance.currencyId = 0;
				instance.costPerItem = 0;
				instance.amountInStock = 0;
				instance.itemIsBlueprint = false;
				instance.currencyIsBlueprint = false;
				instance.itemCondition = 0f;
				instance.itemConditionMax = 0f;
				instance.priceMultiplier = 0f;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.currencyId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.costPerItem = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.amountInStock = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.currencyIsBlueprint = ProtocolParser.ReadBool(stream);
					continue;
				case 69:
					instance.itemCondition = ProtocolParser.ReadSingle(stream);
					continue;
				case 77:
					instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
					continue;
				case 85:
					instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, SellOrder instance, SellOrder previous)
		{
			if (instance.itemId != previous.itemId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.quantity != previous.quantity)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
			}
			if (instance.currencyId != previous.currencyId)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyId);
			}
			if (instance.costPerItem != previous.costPerItem)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.costPerItem);
			}
			if (instance.amountInStock != previous.amountInStock)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.amountInStock);
			}
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.currencyIsBlueprint);
			if (instance.itemCondition != previous.itemCondition)
			{
				stream.WriteByte(69);
				ProtocolParser.WriteSingle(stream, instance.itemCondition);
			}
			if (instance.itemConditionMax != previous.itemConditionMax)
			{
				stream.WriteByte(77);
				ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
			}
			if (instance.priceMultiplier != previous.priceMultiplier)
			{
				stream.WriteByte(85);
				ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
			}
		}

		public static void Serialize(BufferStream stream, SellOrder instance)
		{
			if (instance.itemId != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
			}
			if (instance.quantity != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
			}
			if (instance.currencyId != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyId);
			}
			if (instance.costPerItem != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.costPerItem);
			}
			if (instance.amountInStock != 0)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.amountInStock);
			}
			if (instance.itemIsBlueprint)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
			}
			if (instance.currencyIsBlueprint)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteBool(stream, instance.currencyIsBlueprint);
			}
			if (instance.itemCondition != 0f)
			{
				stream.WriteByte(69);
				ProtocolParser.WriteSingle(stream, instance.itemCondition);
			}
			if (instance.itemConditionMax != 0f)
			{
				stream.WriteByte(77);
				ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
			}
			if (instance.priceMultiplier != 0f)
			{
				stream.WriteByte(85);
				ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public NetworkableId id;

	[NonSerialized]
	public AppMarkerType type;

	[NonSerialized]
	public float x;

	[NonSerialized]
	public float y;

	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public float rotation;

	[NonSerialized]
	public float radius;

	[NonSerialized]
	public Vector4 color1;

	[NonSerialized]
	public Vector4 color2;

	[NonSerialized]
	public float alpha;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public bool outOfStock;

	[NonSerialized]
	public List<SellOrder> sellOrders;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppMarker instance)
	{
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.id = default(NetworkableId);
		instance.type = AppMarkerType.Undefined;
		instance.x = 0f;
		instance.y = 0f;
		instance.steamId = 0uL;
		instance.rotation = 0f;
		instance.radius = 0f;
		instance.color1 = default(Vector4);
		instance.color2 = default(Vector4);
		instance.alpha = 0f;
		instance.name = string.Empty;
		instance.outOfStock = false;
		if (instance.sellOrders != null)
		{
			for (int i = 0; i < instance.sellOrders.Count; i++)
			{
				if (instance.sellOrders[i] != null)
				{
					instance.sellOrders[i].ResetToPool();
					instance.sellOrders[i] = null;
				}
			}
			List<SellOrder> list = instance.sellOrders;
			Pool.Free<SellOrder>(ref list, false);
			instance.sellOrders = list;
		}
		Pool.Free<AppMarker>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppMarker with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppMarker instance)
	{
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		instance.id = id;
		instance.type = type;
		instance.x = x;
		instance.y = y;
		instance.steamId = steamId;
		instance.rotation = rotation;
		instance.radius = radius;
		instance.color1 = color1;
		instance.color2 = color2;
		instance.alpha = alpha;
		instance.name = name;
		instance.outOfStock = outOfStock;
		if (sellOrders != null)
		{
			instance.sellOrders = Pool.Get<List<SellOrder>>();
			for (int i = 0; i < sellOrders.Count; i++)
			{
				SellOrder item = sellOrders[i].Copy();
				instance.sellOrders.Add(item);
			}
		}
		else
		{
			instance.sellOrders = null;
		}
	}

	public AppMarker Copy()
	{
		AppMarker appMarker = Pool.Get<AppMarker>();
		CopyTo(appMarker);
		return appMarker;
	}

	public static AppMarker Deserialize(BufferStream stream)
	{
		AppMarker appMarker = Pool.Get<AppMarker>();
		Deserialize(stream, appMarker, isDelta: false);
		return appMarker;
	}

	public static AppMarker DeserializeLengthDelimited(BufferStream stream)
	{
		AppMarker appMarker = Pool.Get<AppMarker>();
		DeserializeLengthDelimited(stream, appMarker, isDelta: false);
		return appMarker;
	}

	public static AppMarker DeserializeLength(BufferStream stream, int length)
	{
		AppMarker appMarker = Pool.Get<AppMarker>();
		DeserializeLength(stream, length, appMarker, isDelta: false);
		return appMarker;
	}

	public static AppMarker Deserialize(byte[] buffer)
	{
		AppMarker appMarker = Pool.Get<AppMarker>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appMarker, isDelta: false);
		return appMarker;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppMarker previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppMarker Deserialize(BufferStream stream, AppMarker instance, bool isDelta)
	{
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
			instance.steamId = 0uL;
			instance.rotation = 0f;
			instance.radius = 0f;
			instance.alpha = 0f;
			instance.outOfStock = false;
			if (instance.sellOrders == null)
			{
				instance.sellOrders = Pool.Get<List<SellOrder>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.type = (AppMarkerType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.rotation = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.radius = ProtocolParser.ReadSingle(stream);
				continue;
			case 66:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.color1, isDelta);
				continue;
			case 74:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.color2, isDelta);
				continue;
			case 85:
				instance.alpha = ProtocolParser.ReadSingle(stream);
				continue;
			case 90:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 96:
				instance.outOfStock = ProtocolParser.ReadBool(stream);
				continue;
			case 106:
				instance.sellOrders.Add(SellOrder.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppMarker DeserializeLengthDelimited(BufferStream stream, AppMarker instance, bool isDelta)
	{
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
			instance.steamId = 0uL;
			instance.rotation = 0f;
			instance.radius = 0f;
			instance.alpha = 0f;
			instance.outOfStock = false;
			if (instance.sellOrders == null)
			{
				instance.sellOrders = Pool.Get<List<SellOrder>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.type = (AppMarkerType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.rotation = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.radius = ProtocolParser.ReadSingle(stream);
				continue;
			case 66:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.color1, isDelta);
				continue;
			case 74:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.color2, isDelta);
				continue;
			case 85:
				instance.alpha = ProtocolParser.ReadSingle(stream);
				continue;
			case 90:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 96:
				instance.outOfStock = ProtocolParser.ReadBool(stream);
				continue;
			case 106:
				instance.sellOrders.Add(SellOrder.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppMarker DeserializeLength(BufferStream stream, int length, AppMarker instance, bool isDelta)
	{
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
			instance.steamId = 0uL;
			instance.rotation = 0f;
			instance.radius = 0f;
			instance.alpha = 0f;
			instance.outOfStock = false;
			if (instance.sellOrders == null)
			{
				instance.sellOrders = Pool.Get<List<SellOrder>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.type = (AppMarkerType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.rotation = ProtocolParser.ReadSingle(stream);
				continue;
			case 61:
				instance.radius = ProtocolParser.ReadSingle(stream);
				continue;
			case 66:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.color1, isDelta);
				continue;
			case 74:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.color2, isDelta);
				continue;
			case 85:
				instance.alpha = ProtocolParser.ReadSingle(stream);
				continue;
			case 90:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 96:
				instance.outOfStock = ProtocolParser.ReadBool(stream);
				continue;
			case 106:
				instance.sellOrders.Add(SellOrder.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppMarker instance, AppMarker previous)
	{
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.id.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.x != previous.x)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.rotation != previous.rotation)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.rotation);
		}
		if (instance.radius != previous.radius)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.radius);
		}
		if (instance.color1 != previous.color1)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.color1, previous.color1);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color1 (UnityEngine.Vector4)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.color2 != previous.color2)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector4Serialized.SerializeDelta(stream, instance.color2, previous.color2);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color2 (UnityEngine.Vector4)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.alpha != previous.alpha)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.alpha);
		}
		if (instance.name != null && instance.name != previous.name)
		{
			stream.WriteByte(90);
			ProtocolParser.WriteString(stream, instance.name);
		}
		stream.WriteByte(96);
		ProtocolParser.WriteBool(stream, instance.outOfStock);
		if (instance.sellOrders == null)
		{
			return;
		}
		for (int i = 0; i < instance.sellOrders.Count; i++)
		{
			SellOrder sellOrder = instance.sellOrders[i];
			stream.WriteByte(106);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			SellOrder.SerializeDelta(stream, sellOrder, sellOrder);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field sellOrders (ProtoBuf.AppMarker.SellOrder)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public static void Serialize(BufferStream stream, AppMarker instance)
	{
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		if (instance.id != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.id.Value);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.x != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.steamId != 0L)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.rotation != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.rotation);
		}
		if (instance.radius != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.radius);
		}
		if (instance.color1 != default(Vector4))
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector4Serialized.Serialize(stream, instance.color1);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color1 (UnityEngine.Vector4)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.color2 != default(Vector4))
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector4Serialized.Serialize(stream, instance.color2);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color2 (UnityEngine.Vector4)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.alpha != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.alpha);
		}
		if (instance.name != null)
		{
			stream.WriteByte(90);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.outOfStock)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteBool(stream, instance.outOfStock);
		}
		if (instance.sellOrders == null)
		{
			return;
		}
		for (int i = 0; i < instance.sellOrders.Count; i++)
		{
			SellOrder instance2 = instance.sellOrders[i];
			stream.WriteByte(106);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			SellOrder.Serialize(stream, instance2);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field sellOrders (ProtoBuf.AppMarker.SellOrder)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref id.Value);
		if (sellOrders != null)
		{
			for (int i = 0; i < sellOrders.Count; i++)
			{
				sellOrders[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppMapMarkers : IDisposable, IPooled, IProto<AppMapMarkers>, IProto
{
	[NonSerialized]
	public List<AppMarker> markers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppMapMarkers instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.markers != null)
		{
			for (int i = 0; i < instance.markers.Count; i++)
			{
				if (instance.markers[i] != null)
				{
					instance.markers[i].ResetToPool();
					instance.markers[i] = null;
				}
			}
			List<AppMarker> list = instance.markers;
			Pool.Free<AppMarker>(ref list, false);
			instance.markers = list;
		}
		Pool.Free<AppMapMarkers>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppMapMarkers with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppMapMarkers instance)
	{
		if (markers != null)
		{
			instance.markers = Pool.Get<List<AppMarker>>();
			for (int i = 0; i < markers.Count; i++)
			{
				AppMarker item = markers[i].Copy();
				instance.markers.Add(item);
			}
		}
		else
		{
			instance.markers = null;
		}
	}

	public AppMapMarkers Copy()
	{
		AppMapMarkers appMapMarkers = Pool.Get<AppMapMarkers>();
		CopyTo(appMapMarkers);
		return appMapMarkers;
	}

	public static AppMapMarkers Deserialize(BufferStream stream)
	{
		AppMapMarkers appMapMarkers = Pool.Get<AppMapMarkers>();
		Deserialize(stream, appMapMarkers, isDelta: false);
		return appMapMarkers;
	}

	public static AppMapMarkers DeserializeLengthDelimited(BufferStream stream)
	{
		AppMapMarkers appMapMarkers = Pool.Get<AppMapMarkers>();
		DeserializeLengthDelimited(stream, appMapMarkers, isDelta: false);
		return appMapMarkers;
	}

	public static AppMapMarkers DeserializeLength(BufferStream stream, int length)
	{
		AppMapMarkers appMapMarkers = Pool.Get<AppMapMarkers>();
		DeserializeLength(stream, length, appMapMarkers, isDelta: false);
		return appMapMarkers;
	}

	public static AppMapMarkers Deserialize(byte[] buffer)
	{
		AppMapMarkers appMapMarkers = Pool.Get<AppMapMarkers>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appMapMarkers, isDelta: false);
		return appMapMarkers;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppMapMarkers previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppMapMarkers Deserialize(BufferStream stream, AppMapMarkers instance, bool isDelta)
	{
		if (!isDelta && instance.markers == null)
		{
			instance.markers = Pool.Get<List<AppMarker>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.markers.Add(AppMarker.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppMapMarkers DeserializeLengthDelimited(BufferStream stream, AppMapMarkers instance, bool isDelta)
	{
		if (!isDelta && instance.markers == null)
		{
			instance.markers = Pool.Get<List<AppMarker>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.markers.Add(AppMarker.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppMapMarkers DeserializeLength(BufferStream stream, int length, AppMapMarkers instance, bool isDelta)
	{
		if (!isDelta && instance.markers == null)
		{
			instance.markers = Pool.Get<List<AppMarker>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.markers.Add(AppMarker.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppMapMarkers instance, AppMapMarkers previous)
	{
		if (instance.markers == null)
		{
			return;
		}
		for (int i = 0; i < instance.markers.Count; i++)
		{
			AppMarker appMarker = instance.markers[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppMarker.SerializeDelta(stream, appMarker, appMarker);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, AppMapMarkers instance)
	{
		if (instance.markers == null)
		{
			return;
		}
		for (int i = 0; i < instance.markers.Count; i++)
		{
			AppMarker instance2 = instance.markers[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppMarker.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (markers != null)
		{
			for (int i = 0; i < markers.Count; i++)
			{
				markers[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppClanInfo : IDisposable, IPooled, IProto<AppClanInfo>, IProto
{
	[NonSerialized]
	public ClanInfo clanInfo;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppClanInfo instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.clanInfo != null)
			{
				instance.clanInfo.ResetToPool();
				instance.clanInfo = null;
			}
			Pool.Free<AppClanInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppClanInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppClanInfo instance)
	{
		if (clanInfo != null)
		{
			if (instance.clanInfo == null)
			{
				instance.clanInfo = clanInfo.Copy();
			}
			else
			{
				clanInfo.CopyTo(instance.clanInfo);
			}
		}
		else
		{
			instance.clanInfo = null;
		}
	}

	public AppClanInfo Copy()
	{
		AppClanInfo appClanInfo = Pool.Get<AppClanInfo>();
		CopyTo(appClanInfo);
		return appClanInfo;
	}

	public static AppClanInfo Deserialize(BufferStream stream)
	{
		AppClanInfo appClanInfo = Pool.Get<AppClanInfo>();
		Deserialize(stream, appClanInfo, isDelta: false);
		return appClanInfo;
	}

	public static AppClanInfo DeserializeLengthDelimited(BufferStream stream)
	{
		AppClanInfo appClanInfo = Pool.Get<AppClanInfo>();
		DeserializeLengthDelimited(stream, appClanInfo, isDelta: false);
		return appClanInfo;
	}

	public static AppClanInfo DeserializeLength(BufferStream stream, int length)
	{
		AppClanInfo appClanInfo = Pool.Get<AppClanInfo>();
		DeserializeLength(stream, length, appClanInfo, isDelta: false);
		return appClanInfo;
	}

	public static AppClanInfo Deserialize(byte[] buffer)
	{
		AppClanInfo appClanInfo = Pool.Get<AppClanInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appClanInfo, isDelta: false);
		return appClanInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppClanInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppClanInfo Deserialize(BufferStream stream, AppClanInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static AppClanInfo DeserializeLengthDelimited(BufferStream stream, AppClanInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppClanInfo DeserializeLength(BufferStream stream, int length, AppClanInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppClanInfo instance, AppClanInfo previous)
	{
		if (instance.clanInfo == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ClanInfo.SerializeDelta(stream, instance.clanInfo, previous.clanInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppClanInfo instance)
	{
		if (instance.clanInfo == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ClanInfo.Serialize(stream, instance.clanInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		clanInfo?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppClanMessage : IDisposable, IPooled, IProto<AppClanMessage>, IProto
{
	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public string message;

	[NonSerialized]
	public long time;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppClanMessage instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			instance.name = string.Empty;
			instance.message = string.Empty;
			instance.time = 0L;
			Pool.Free<AppClanMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppClanMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppClanMessage instance)
	{
		instance.steamId = steamId;
		instance.name = name;
		instance.message = message;
		instance.time = time;
	}

	public AppClanMessage Copy()
	{
		AppClanMessage appClanMessage = Pool.Get<AppClanMessage>();
		CopyTo(appClanMessage);
		return appClanMessage;
	}

	public static AppClanMessage Deserialize(BufferStream stream)
	{
		AppClanMessage appClanMessage = Pool.Get<AppClanMessage>();
		Deserialize(stream, appClanMessage, isDelta: false);
		return appClanMessage;
	}

	public static AppClanMessage DeserializeLengthDelimited(BufferStream stream)
	{
		AppClanMessage appClanMessage = Pool.Get<AppClanMessage>();
		DeserializeLengthDelimited(stream, appClanMessage, isDelta: false);
		return appClanMessage;
	}

	public static AppClanMessage DeserializeLength(BufferStream stream, int length)
	{
		AppClanMessage appClanMessage = Pool.Get<AppClanMessage>();
		DeserializeLength(stream, length, appClanMessage, isDelta: false);
		return appClanMessage;
	}

	public static AppClanMessage Deserialize(byte[] buffer)
	{
		AppClanMessage appClanMessage = Pool.Get<AppClanMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appClanMessage, isDelta: false);
		return appClanMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppClanMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppClanMessage Deserialize(BufferStream stream, AppClanMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.time = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.time = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppClanMessage DeserializeLengthDelimited(BufferStream stream, AppClanMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.time = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.time = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppClanMessage DeserializeLength(BufferStream stream, int length, AppClanMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.time = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.message = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.time = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppClanMessage instance, AppClanMessage previous)
	{
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.message != previous.message)
		{
			if (instance.message == null)
			{
				throw new ArgumentNullException("message", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.message);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.time);
	}

	public static void Serialize(BufferStream stream, AppClanMessage instance)
	{
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.message == null)
		{
			throw new ArgumentNullException("message", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.message);
		if (instance.time != 0L)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.time);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppClanChat : IDisposable, IPooled, IProto<AppClanChat>, IProto
{
	[NonSerialized]
	public List<AppClanMessage> messages;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppClanChat instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.messages != null)
		{
			for (int i = 0; i < instance.messages.Count; i++)
			{
				if (instance.messages[i] != null)
				{
					instance.messages[i].ResetToPool();
					instance.messages[i] = null;
				}
			}
			List<AppClanMessage> list = instance.messages;
			Pool.Free<AppClanMessage>(ref list, false);
			instance.messages = list;
		}
		Pool.Free<AppClanChat>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppClanChat with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppClanChat instance)
	{
		if (messages != null)
		{
			instance.messages = Pool.Get<List<AppClanMessage>>();
			for (int i = 0; i < messages.Count; i++)
			{
				AppClanMessage item = messages[i].Copy();
				instance.messages.Add(item);
			}
		}
		else
		{
			instance.messages = null;
		}
	}

	public AppClanChat Copy()
	{
		AppClanChat appClanChat = Pool.Get<AppClanChat>();
		CopyTo(appClanChat);
		return appClanChat;
	}

	public static AppClanChat Deserialize(BufferStream stream)
	{
		AppClanChat appClanChat = Pool.Get<AppClanChat>();
		Deserialize(stream, appClanChat, isDelta: false);
		return appClanChat;
	}

	public static AppClanChat DeserializeLengthDelimited(BufferStream stream)
	{
		AppClanChat appClanChat = Pool.Get<AppClanChat>();
		DeserializeLengthDelimited(stream, appClanChat, isDelta: false);
		return appClanChat;
	}

	public static AppClanChat DeserializeLength(BufferStream stream, int length)
	{
		AppClanChat appClanChat = Pool.Get<AppClanChat>();
		DeserializeLength(stream, length, appClanChat, isDelta: false);
		return appClanChat;
	}

	public static AppClanChat Deserialize(byte[] buffer)
	{
		AppClanChat appClanChat = Pool.Get<AppClanChat>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appClanChat, isDelta: false);
		return appClanChat;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppClanChat previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppClanChat Deserialize(BufferStream stream, AppClanChat instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<AppClanMessage>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.messages.Add(AppClanMessage.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppClanChat DeserializeLengthDelimited(BufferStream stream, AppClanChat instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<AppClanMessage>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.messages.Add(AppClanMessage.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppClanChat DeserializeLength(BufferStream stream, int length, AppClanChat instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<AppClanMessage>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.messages.Add(AppClanMessage.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppClanChat instance, AppClanChat previous)
	{
		if (instance.messages == null)
		{
			return;
		}
		for (int i = 0; i < instance.messages.Count; i++)
		{
			AppClanMessage appClanMessage = instance.messages[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppClanMessage.SerializeDelta(stream, appClanMessage, appClanMessage);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, AppClanChat instance)
	{
		if (instance.messages == null)
		{
			return;
		}
		for (int i = 0; i < instance.messages.Count; i++)
		{
			AppClanMessage instance2 = instance.messages[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			AppClanMessage.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (messages != null)
		{
			for (int i = 0; i < messages.Count; i++)
			{
				messages[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppNexusAuth : IDisposable, IPooled, IProto<AppNexusAuth>, IProto
{
	[NonSerialized]
	public string serverId;

	[NonSerialized]
	public int playerToken;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppNexusAuth instance)
	{
		if (instance.ShouldPool)
		{
			instance.serverId = string.Empty;
			instance.playerToken = 0;
			Pool.Free<AppNexusAuth>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppNexusAuth with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppNexusAuth instance)
	{
		instance.serverId = serverId;
		instance.playerToken = playerToken;
	}

	public AppNexusAuth Copy()
	{
		AppNexusAuth appNexusAuth = Pool.Get<AppNexusAuth>();
		CopyTo(appNexusAuth);
		return appNexusAuth;
	}

	public static AppNexusAuth Deserialize(BufferStream stream)
	{
		AppNexusAuth appNexusAuth = Pool.Get<AppNexusAuth>();
		Deserialize(stream, appNexusAuth, isDelta: false);
		return appNexusAuth;
	}

	public static AppNexusAuth DeserializeLengthDelimited(BufferStream stream)
	{
		AppNexusAuth appNexusAuth = Pool.Get<AppNexusAuth>();
		DeserializeLengthDelimited(stream, appNexusAuth, isDelta: false);
		return appNexusAuth;
	}

	public static AppNexusAuth DeserializeLength(BufferStream stream, int length)
	{
		AppNexusAuth appNexusAuth = Pool.Get<AppNexusAuth>();
		DeserializeLength(stream, length, appNexusAuth, isDelta: false);
		return appNexusAuth;
	}

	public static AppNexusAuth Deserialize(byte[] buffer)
	{
		AppNexusAuth appNexusAuth = Pool.Get<AppNexusAuth>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appNexusAuth, isDelta: false);
		return appNexusAuth;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppNexusAuth previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppNexusAuth Deserialize(BufferStream stream, AppNexusAuth instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.playerToken = 0;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.serverId = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.playerToken = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppNexusAuth DeserializeLengthDelimited(BufferStream stream, AppNexusAuth instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.playerToken = 0;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.serverId = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.playerToken = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppNexusAuth DeserializeLength(BufferStream stream, int length, AppNexusAuth instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.playerToken = 0;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.serverId = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.playerToken = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppNexusAuth instance, AppNexusAuth previous)
	{
		if (instance.serverId != previous.serverId)
		{
			if (instance.serverId == null)
			{
				throw new ArgumentNullException("serverId", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.serverId);
		}
		if (instance.playerToken != previous.playerToken)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerToken);
		}
	}

	public static void Serialize(BufferStream stream, AppNexusAuth instance)
	{
		if (instance.serverId == null)
		{
			throw new ArgumentNullException("serverId", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.serverId);
		if (instance.playerToken != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.playerToken);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppCameraInfo : IDisposable, IPooled, IProto<AppCameraInfo>, IProto
{
	[NonSerialized]
	public int width;

	[NonSerialized]
	public int height;

	[NonSerialized]
	public float nearPlane;

	[NonSerialized]
	public float farPlane;

	[NonSerialized]
	public int controlFlags;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppCameraInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.width = 0;
			instance.height = 0;
			instance.nearPlane = 0f;
			instance.farPlane = 0f;
			instance.controlFlags = 0;
			Pool.Free<AppCameraInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppCameraInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppCameraInfo instance)
	{
		instance.width = width;
		instance.height = height;
		instance.nearPlane = nearPlane;
		instance.farPlane = farPlane;
		instance.controlFlags = controlFlags;
	}

	public AppCameraInfo Copy()
	{
		AppCameraInfo appCameraInfo = Pool.Get<AppCameraInfo>();
		CopyTo(appCameraInfo);
		return appCameraInfo;
	}

	public static AppCameraInfo Deserialize(BufferStream stream)
	{
		AppCameraInfo appCameraInfo = Pool.Get<AppCameraInfo>();
		Deserialize(stream, appCameraInfo, isDelta: false);
		return appCameraInfo;
	}

	public static AppCameraInfo DeserializeLengthDelimited(BufferStream stream)
	{
		AppCameraInfo appCameraInfo = Pool.Get<AppCameraInfo>();
		DeserializeLengthDelimited(stream, appCameraInfo, isDelta: false);
		return appCameraInfo;
	}

	public static AppCameraInfo DeserializeLength(BufferStream stream, int length)
	{
		AppCameraInfo appCameraInfo = Pool.Get<AppCameraInfo>();
		DeserializeLength(stream, length, appCameraInfo, isDelta: false);
		return appCameraInfo;
	}

	public static AppCameraInfo Deserialize(byte[] buffer)
	{
		AppCameraInfo appCameraInfo = Pool.Get<AppCameraInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appCameraInfo, isDelta: false);
		return appCameraInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppCameraInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppCameraInfo Deserialize(BufferStream stream, AppCameraInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.width = 0;
			instance.height = 0;
			instance.nearPlane = 0f;
			instance.farPlane = 0f;
			instance.controlFlags = 0;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.width = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.height = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.nearPlane = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.farPlane = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.controlFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppCameraInfo DeserializeLengthDelimited(BufferStream stream, AppCameraInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.width = 0;
			instance.height = 0;
			instance.nearPlane = 0f;
			instance.farPlane = 0f;
			instance.controlFlags = 0;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.width = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.height = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.nearPlane = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.farPlane = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.controlFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppCameraInfo DeserializeLength(BufferStream stream, int length, AppCameraInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.width = 0;
			instance.height = 0;
			instance.nearPlane = 0f;
			instance.farPlane = 0f;
			instance.controlFlags = 0;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.width = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.height = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.nearPlane = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.farPlane = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.controlFlags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppCameraInfo instance, AppCameraInfo previous)
	{
		if (instance.width != previous.width)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.width);
		}
		if (instance.height != previous.height)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.height);
		}
		if (instance.nearPlane != previous.nearPlane)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.nearPlane);
		}
		if (instance.farPlane != previous.farPlane)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.farPlane);
		}
		if (instance.controlFlags != previous.controlFlags)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.controlFlags);
		}
	}

	public static void Serialize(BufferStream stream, AppCameraInfo instance)
	{
		if (instance.width != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.width);
		}
		if (instance.height != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.height);
		}
		if (instance.nearPlane != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.nearPlane);
		}
		if (instance.farPlane != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.farPlane);
		}
		if (instance.controlFlags != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.controlFlags);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppTeamChanged : IDisposable, IPooled, IProto<AppTeamChanged>, IProto
{
	[NonSerialized]
	public ulong playerId;

	[NonSerialized]
	public AppTeamInfo teamInfo;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppTeamChanged instance)
	{
		if (instance.ShouldPool)
		{
			instance.playerId = 0uL;
			if (instance.teamInfo != null)
			{
				instance.teamInfo.ResetToPool();
				instance.teamInfo = null;
			}
			Pool.Free<AppTeamChanged>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppTeamChanged with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppTeamChanged instance)
	{
		instance.playerId = playerId;
		if (teamInfo != null)
		{
			if (instance.teamInfo == null)
			{
				instance.teamInfo = teamInfo.Copy();
			}
			else
			{
				teamInfo.CopyTo(instance.teamInfo);
			}
		}
		else
		{
			instance.teamInfo = null;
		}
	}

	public AppTeamChanged Copy()
	{
		AppTeamChanged appTeamChanged = Pool.Get<AppTeamChanged>();
		CopyTo(appTeamChanged);
		return appTeamChanged;
	}

	public static AppTeamChanged Deserialize(BufferStream stream)
	{
		AppTeamChanged appTeamChanged = Pool.Get<AppTeamChanged>();
		Deserialize(stream, appTeamChanged, isDelta: false);
		return appTeamChanged;
	}

	public static AppTeamChanged DeserializeLengthDelimited(BufferStream stream)
	{
		AppTeamChanged appTeamChanged = Pool.Get<AppTeamChanged>();
		DeserializeLengthDelimited(stream, appTeamChanged, isDelta: false);
		return appTeamChanged;
	}

	public static AppTeamChanged DeserializeLength(BufferStream stream, int length)
	{
		AppTeamChanged appTeamChanged = Pool.Get<AppTeamChanged>();
		DeserializeLength(stream, length, appTeamChanged, isDelta: false);
		return appTeamChanged;
	}

	public static AppTeamChanged Deserialize(byte[] buffer)
	{
		AppTeamChanged appTeamChanged = Pool.Get<AppTeamChanged>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appTeamChanged, isDelta: false);
		return appTeamChanged;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppTeamChanged previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppTeamChanged Deserialize(BufferStream stream, AppTeamChanged instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.playerId = 0uL;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.teamInfo == null)
				{
					instance.teamInfo = AppTeamInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamInfo.DeserializeLengthDelimited(stream, instance.teamInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static AppTeamChanged DeserializeLengthDelimited(BufferStream stream, AppTeamChanged instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.playerId = 0uL;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.teamInfo == null)
				{
					instance.teamInfo = AppTeamInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamInfo.DeserializeLengthDelimited(stream, instance.teamInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppTeamChanged DeserializeLength(BufferStream stream, int length, AppTeamChanged instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.playerId = 0uL;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.teamInfo == null)
				{
					instance.teamInfo = AppTeamInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamInfo.DeserializeLengthDelimited(stream, instance.teamInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppTeamChanged instance, AppTeamChanged previous)
	{
		if (instance.playerId != previous.playerId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
		if (instance.teamInfo == null)
		{
			throw new ArgumentNullException("teamInfo", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		AppTeamInfo.SerializeDelta(stream, instance.teamInfo, previous.teamInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppTeamChanged instance)
	{
		if (instance.playerId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.playerId);
		}
		if (instance.teamInfo == null)
		{
			throw new ArgumentNullException("teamInfo", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		AppTeamInfo.Serialize(stream, instance.teamInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		teamInfo?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppNewTeamMessage : IDisposable, IPooled, IProto<AppNewTeamMessage>, IProto
{
	[NonSerialized]
	public AppTeamMessage message;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppNewTeamMessage instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.message != null)
			{
				instance.message.ResetToPool();
				instance.message = null;
			}
			Pool.Free<AppNewTeamMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppNewTeamMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppNewTeamMessage instance)
	{
		if (message != null)
		{
			if (instance.message == null)
			{
				instance.message = message.Copy();
			}
			else
			{
				message.CopyTo(instance.message);
			}
		}
		else
		{
			instance.message = null;
		}
	}

	public AppNewTeamMessage Copy()
	{
		AppNewTeamMessage appNewTeamMessage = Pool.Get<AppNewTeamMessage>();
		CopyTo(appNewTeamMessage);
		return appNewTeamMessage;
	}

	public static AppNewTeamMessage Deserialize(BufferStream stream)
	{
		AppNewTeamMessage appNewTeamMessage = Pool.Get<AppNewTeamMessage>();
		Deserialize(stream, appNewTeamMessage, isDelta: false);
		return appNewTeamMessage;
	}

	public static AppNewTeamMessage DeserializeLengthDelimited(BufferStream stream)
	{
		AppNewTeamMessage appNewTeamMessage = Pool.Get<AppNewTeamMessage>();
		DeserializeLengthDelimited(stream, appNewTeamMessage, isDelta: false);
		return appNewTeamMessage;
	}

	public static AppNewTeamMessage DeserializeLength(BufferStream stream, int length)
	{
		AppNewTeamMessage appNewTeamMessage = Pool.Get<AppNewTeamMessage>();
		DeserializeLength(stream, length, appNewTeamMessage, isDelta: false);
		return appNewTeamMessage;
	}

	public static AppNewTeamMessage Deserialize(byte[] buffer)
	{
		AppNewTeamMessage appNewTeamMessage = Pool.Get<AppNewTeamMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appNewTeamMessage, isDelta: false);
		return appNewTeamMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppNewTeamMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppNewTeamMessage Deserialize(BufferStream stream, AppNewTeamMessage instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.message == null)
				{
					instance.message = AppTeamMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamMessage.DeserializeLengthDelimited(stream, instance.message, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static AppNewTeamMessage DeserializeLengthDelimited(BufferStream stream, AppNewTeamMessage instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.message == null)
				{
					instance.message = AppTeamMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamMessage.DeserializeLengthDelimited(stream, instance.message, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppNewTeamMessage DeserializeLength(BufferStream stream, int length, AppNewTeamMessage instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.message == null)
				{
					instance.message = AppTeamMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppTeamMessage.DeserializeLengthDelimited(stream, instance.message, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppNewTeamMessage instance, AppNewTeamMessage previous)
	{
		if (instance.message == null)
		{
			throw new ArgumentNullException("message", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		AppTeamMessage.SerializeDelta(stream, instance.message, previous.message);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppNewTeamMessage instance)
	{
		if (instance.message == null)
		{
			throw new ArgumentNullException("message", "Required by proto specification.");
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		AppTeamMessage.Serialize(stream, instance.message);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		message?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppEntityChanged : IDisposable, IPooled, IProto<AppEntityChanged>, IProto
{
	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public AppEntityPayload payload;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppEntityChanged instance)
	{
		if (instance.ShouldPool)
		{
			instance.entityId = default(NetworkableId);
			if (instance.payload != null)
			{
				instance.payload.ResetToPool();
				instance.payload = null;
			}
			Pool.Free<AppEntityChanged>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppEntityChanged with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppEntityChanged instance)
	{
		instance.entityId = entityId;
		if (payload != null)
		{
			if (instance.payload == null)
			{
				instance.payload = payload.Copy();
			}
			else
			{
				payload.CopyTo(instance.payload);
			}
		}
		else
		{
			instance.payload = null;
		}
	}

	public AppEntityChanged Copy()
	{
		AppEntityChanged appEntityChanged = Pool.Get<AppEntityChanged>();
		CopyTo(appEntityChanged);
		return appEntityChanged;
	}

	public static AppEntityChanged Deserialize(BufferStream stream)
	{
		AppEntityChanged appEntityChanged = Pool.Get<AppEntityChanged>();
		Deserialize(stream, appEntityChanged, isDelta: false);
		return appEntityChanged;
	}

	public static AppEntityChanged DeserializeLengthDelimited(BufferStream stream)
	{
		AppEntityChanged appEntityChanged = Pool.Get<AppEntityChanged>();
		DeserializeLengthDelimited(stream, appEntityChanged, isDelta: false);
		return appEntityChanged;
	}

	public static AppEntityChanged DeserializeLength(BufferStream stream, int length)
	{
		AppEntityChanged appEntityChanged = Pool.Get<AppEntityChanged>();
		DeserializeLength(stream, length, appEntityChanged, isDelta: false);
		return appEntityChanged;
	}

	public static AppEntityChanged Deserialize(byte[] buffer)
	{
		AppEntityChanged appEntityChanged = Pool.Get<AppEntityChanged>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appEntityChanged, isDelta: false);
		return appEntityChanged;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppEntityChanged previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppEntityChanged Deserialize(BufferStream stream, AppEntityChanged instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 18:
				if (instance.payload == null)
				{
					instance.payload = AppEntityPayload.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityPayload.DeserializeLengthDelimited(stream, instance.payload, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static AppEntityChanged DeserializeLengthDelimited(BufferStream stream, AppEntityChanged instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 18:
				if (instance.payload == null)
				{
					instance.payload = AppEntityPayload.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityPayload.DeserializeLengthDelimited(stream, instance.payload, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppEntityChanged DeserializeLength(BufferStream stream, int length, AppEntityChanged instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 18:
				if (instance.payload == null)
				{
					instance.payload = AppEntityPayload.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppEntityPayload.DeserializeLengthDelimited(stream, instance.payload, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppEntityChanged instance, AppEntityChanged previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		if (instance.payload == null)
		{
			throw new ArgumentNullException("payload", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		AppEntityPayload.SerializeDelta(stream, instance.payload, previous.payload);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field payload (ProtoBuf.AppEntityPayload)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppEntityChanged instance)
	{
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		if (instance.payload == null)
		{
			throw new ArgumentNullException("payload", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		AppEntityPayload.Serialize(stream, instance.payload);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field payload (ProtoBuf.AppEntityPayload)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
		payload?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppClanChanged : IDisposable, IPooled, IProto<AppClanChanged>, IProto
{
	[NonSerialized]
	public ClanInfo clanInfo;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppClanChanged instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.clanInfo != null)
			{
				instance.clanInfo.ResetToPool();
				instance.clanInfo = null;
			}
			Pool.Free<AppClanChanged>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppClanChanged with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppClanChanged instance)
	{
		if (clanInfo != null)
		{
			if (instance.clanInfo == null)
			{
				instance.clanInfo = clanInfo.Copy();
			}
			else
			{
				clanInfo.CopyTo(instance.clanInfo);
			}
		}
		else
		{
			instance.clanInfo = null;
		}
	}

	public AppClanChanged Copy()
	{
		AppClanChanged appClanChanged = Pool.Get<AppClanChanged>();
		CopyTo(appClanChanged);
		return appClanChanged;
	}

	public static AppClanChanged Deserialize(BufferStream stream)
	{
		AppClanChanged appClanChanged = Pool.Get<AppClanChanged>();
		Deserialize(stream, appClanChanged, isDelta: false);
		return appClanChanged;
	}

	public static AppClanChanged DeserializeLengthDelimited(BufferStream stream)
	{
		AppClanChanged appClanChanged = Pool.Get<AppClanChanged>();
		DeserializeLengthDelimited(stream, appClanChanged, isDelta: false);
		return appClanChanged;
	}

	public static AppClanChanged DeserializeLength(BufferStream stream, int length)
	{
		AppClanChanged appClanChanged = Pool.Get<AppClanChanged>();
		DeserializeLength(stream, length, appClanChanged, isDelta: false);
		return appClanChanged;
	}

	public static AppClanChanged Deserialize(byte[] buffer)
	{
		AppClanChanged appClanChanged = Pool.Get<AppClanChanged>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appClanChanged, isDelta: false);
		return appClanChanged;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppClanChanged previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppClanChanged Deserialize(BufferStream stream, AppClanChanged instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static AppClanChanged DeserializeLengthDelimited(BufferStream stream, AppClanChanged instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppClanChanged DeserializeLength(BufferStream stream, int length, AppClanChanged instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppClanChanged instance, AppClanChanged previous)
	{
		if (instance.clanInfo == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ClanInfo.SerializeDelta(stream, instance.clanInfo, previous.clanInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppClanChanged instance)
	{
		if (instance.clanInfo == null)
		{
			return;
		}
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ClanInfo.Serialize(stream, instance.clanInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		clanInfo?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AppNewClanMessage : IDisposable, IPooled, IProto<AppNewClanMessage>, IProto
{
	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public AppClanMessage message;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppNewClanMessage instance)
	{
		if (instance.ShouldPool)
		{
			instance.clanId = 0L;
			if (instance.message != null)
			{
				instance.message.ResetToPool();
				instance.message = null;
			}
			Pool.Free<AppNewClanMessage>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppNewClanMessage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppNewClanMessage instance)
	{
		instance.clanId = clanId;
		if (message != null)
		{
			if (instance.message == null)
			{
				instance.message = message.Copy();
			}
			else
			{
				message.CopyTo(instance.message);
			}
		}
		else
		{
			instance.message = null;
		}
	}

	public AppNewClanMessage Copy()
	{
		AppNewClanMessage appNewClanMessage = Pool.Get<AppNewClanMessage>();
		CopyTo(appNewClanMessage);
		return appNewClanMessage;
	}

	public static AppNewClanMessage Deserialize(BufferStream stream)
	{
		AppNewClanMessage appNewClanMessage = Pool.Get<AppNewClanMessage>();
		Deserialize(stream, appNewClanMessage, isDelta: false);
		return appNewClanMessage;
	}

	public static AppNewClanMessage DeserializeLengthDelimited(BufferStream stream)
	{
		AppNewClanMessage appNewClanMessage = Pool.Get<AppNewClanMessage>();
		DeserializeLengthDelimited(stream, appNewClanMessage, isDelta: false);
		return appNewClanMessage;
	}

	public static AppNewClanMessage DeserializeLength(BufferStream stream, int length)
	{
		AppNewClanMessage appNewClanMessage = Pool.Get<AppNewClanMessage>();
		DeserializeLength(stream, length, appNewClanMessage, isDelta: false);
		return appNewClanMessage;
	}

	public static AppNewClanMessage Deserialize(byte[] buffer)
	{
		AppNewClanMessage appNewClanMessage = Pool.Get<AppNewClanMessage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appNewClanMessage, isDelta: false);
		return appNewClanMessage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppNewClanMessage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppNewClanMessage Deserialize(BufferStream stream, AppNewClanMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.message == null)
				{
					instance.message = AppClanMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanMessage.DeserializeLengthDelimited(stream, instance.message, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static AppNewClanMessage DeserializeLengthDelimited(BufferStream stream, AppNewClanMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.message == null)
				{
					instance.message = AppClanMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanMessage.DeserializeLengthDelimited(stream, instance.message, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppNewClanMessage DeserializeLength(BufferStream stream, int length, AppNewClanMessage instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.message == null)
				{
					instance.message = AppClanMessage.DeserializeLengthDelimited(stream);
				}
				else
				{
					AppClanMessage.DeserializeLengthDelimited(stream, instance.message, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppNewClanMessage instance, AppNewClanMessage previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.message == null)
		{
			throw new ArgumentNullException("message", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		AppClanMessage.SerializeDelta(stream, instance.message, previous.message);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, AppNewClanMessage instance)
	{
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.message == null)
		{
			throw new ArgumentNullException("message", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		AppClanMessage.Serialize(stream, instance.message);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		message?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class AppCameraRays : IDisposable, IPooled, IProto<AppCameraRays>, IProto
{
	public enum EntityType
	{
		Tree = 1,
		Player
	}

	public class Entity : IDisposable, IPooled, IProto<Entity>, IProto
	{
		[NonSerialized]
		public NetworkableId entityId;

		[NonSerialized]
		public EntityType type;

		[NonSerialized]
		public Vector3 position;

		[NonSerialized]
		public Vector3 rotation;

		[NonSerialized]
		public Vector3 size;

		[NonSerialized]
		public string name;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Entity instance)
		{
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.entityId = default(NetworkableId);
				instance.type = (EntityType)0;
				instance.position = default(Vector3);
				instance.rotation = default(Vector3);
				instance.size = default(Vector3);
				instance.name = string.Empty;
				Pool.Free<Entity>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Entity with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Entity instance)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			instance.entityId = entityId;
			instance.type = type;
			instance.position = position;
			instance.rotation = rotation;
			instance.size = size;
			instance.name = name;
		}

		public Entity Copy()
		{
			Entity entity = Pool.Get<Entity>();
			CopyTo(entity);
			return entity;
		}

		public static Entity Deserialize(BufferStream stream)
		{
			Entity entity = Pool.Get<Entity>();
			Deserialize(stream, entity, isDelta: false);
			return entity;
		}

		public static Entity DeserializeLengthDelimited(BufferStream stream)
		{
			Entity entity = Pool.Get<Entity>();
			DeserializeLengthDelimited(stream, entity, isDelta: false);
			return entity;
		}

		public static Entity DeserializeLength(BufferStream stream, int length)
		{
			Entity entity = Pool.Get<Entity>();
			DeserializeLength(stream, length, entity, isDelta: false);
			return entity;
		}

		public static Entity Deserialize(byte[] buffer)
		{
			Entity entity = Pool.Get<Entity>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, entity, isDelta: false);
			return entity;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Entity previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Entity Deserialize(BufferStream stream, Entity instance, bool isDelta)
		{
			//IL_0070: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 16:
					instance.type = (EntityType)ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 34:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
					continue;
				case 42:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
					continue;
				case 50:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Entity DeserializeLengthDelimited(BufferStream stream, Entity instance, bool isDelta)
		{
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 16:
					instance.type = (EntityType)ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 34:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
					continue;
				case 42:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
					continue;
				case 50:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Entity DeserializeLength(BufferStream stream, int length, Entity instance, bool isDelta)
		{
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
					continue;
				case 16:
					instance.type = (EntityType)ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
					continue;
				case 34:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
					continue;
				case 42:
					Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
					continue;
				case 50:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Entity instance, Entity previous)
		{
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0127: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			if (instance.position != previous.position)
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.position, previous.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			if (instance.rotation != previous.rotation)
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int num3 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.rotation, previous.rotation);
				int num4 = stream.Position - num3;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span2, 0);
			}
			if (instance.size != previous.size)
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int num5 = stream.Position;
				Vector3Serialized.SerializeDelta(stream, instance.size, previous.size);
				int num6 = stream.Position - num5;
				if (num6 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field size (UnityEngine.Vector3)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num6, span3, 0);
			}
			if (instance.name != null && instance.name != previous.name)
			{
				stream.WriteByte(50);
				ProtocolParser.WriteString(stream, instance.name);
			}
		}

		public static void Serialize(BufferStream stream, Entity instance)
		{
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0114: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_013d: Unknown result type (might be due to invalid IL or missing references)
			if (instance.entityId != default(NetworkableId))
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
			}
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			if (instance.position != default(Vector3))
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int num = stream.Position;
				Vector3Serialized.Serialize(stream, instance.position);
				int num2 = stream.Position - num;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector3)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span, 0);
			}
			if (instance.rotation != default(Vector3))
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int num3 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.rotation);
				int num4 = stream.Position - num3;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rotation (UnityEngine.Vector3)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span2, 0);
			}
			if (instance.size != default(Vector3))
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int num5 = stream.Position;
				Vector3Serialized.Serialize(stream, instance.size);
				int num6 = stream.Position - num5;
				if (num6 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field size (UnityEngine.Vector3)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num6, span3, 0);
			}
			if (instance.name != null)
			{
				stream.WriteByte(50);
				ProtocolParser.WriteString(stream, instance.name);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			action(UidType.NetworkableId, ref entityId.Value);
		}
	}

	[NonSerialized]
	public float verticalFov;

	[NonSerialized]
	public int sampleOffset;

	[NonSerialized]
	public ArraySegment<byte> rayData;

	[NonSerialized]
	public float distance;

	[NonSerialized]
	public List<Entity> entities;

	[NonSerialized]
	public float timeOfDay;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AppCameraRays instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.verticalFov = 0f;
		instance.sampleOffset = 0;
		if (instance.rayData.Array != null)
		{
			BufferStream.Shared.ArrayPool.Return(instance.rayData.Array);
		}
		instance.rayData = default(ArraySegment<byte>);
		instance.distance = 0f;
		if (instance.entities != null)
		{
			for (int i = 0; i < instance.entities.Count; i++)
			{
				if (instance.entities[i] != null)
				{
					instance.entities[i].ResetToPool();
					instance.entities[i] = null;
				}
			}
			List<Entity> list = instance.entities;
			Pool.Free<Entity>(ref list, false);
			instance.entities = list;
		}
		instance.timeOfDay = 0f;
		Pool.Free<AppCameraRays>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AppCameraRays with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AppCameraRays instance)
	{
		instance.verticalFov = verticalFov;
		instance.sampleOffset = sampleOffset;
		if (rayData.Array == null)
		{
			instance.rayData = default(ArraySegment<byte>);
		}
		else
		{
			byte[] array = BufferStream.Shared.ArrayPool.Rent(rayData.Count);
			Array.Copy(rayData.Array, 0, array, 0, rayData.Count);
			instance.rayData = new ArraySegment<byte>(array, 0, rayData.Count);
		}
		instance.distance = distance;
		if (entities != null)
		{
			instance.entities = Pool.Get<List<Entity>>();
			for (int i = 0; i < entities.Count; i++)
			{
				Entity item = entities[i].Copy();
				instance.entities.Add(item);
			}
		}
		else
		{
			instance.entities = null;
		}
		instance.timeOfDay = timeOfDay;
	}

	public AppCameraRays Copy()
	{
		AppCameraRays appCameraRays = Pool.Get<AppCameraRays>();
		CopyTo(appCameraRays);
		return appCameraRays;
	}

	public static AppCameraRays Deserialize(BufferStream stream)
	{
		AppCameraRays appCameraRays = Pool.Get<AppCameraRays>();
		Deserialize(stream, appCameraRays, isDelta: false);
		return appCameraRays;
	}

	public static AppCameraRays DeserializeLengthDelimited(BufferStream stream)
	{
		AppCameraRays appCameraRays = Pool.Get<AppCameraRays>();
		DeserializeLengthDelimited(stream, appCameraRays, isDelta: false);
		return appCameraRays;
	}

	public static AppCameraRays DeserializeLength(BufferStream stream, int length)
	{
		AppCameraRays appCameraRays = Pool.Get<AppCameraRays>();
		DeserializeLength(stream, length, appCameraRays, isDelta: false);
		return appCameraRays;
	}

	public static AppCameraRays Deserialize(byte[] buffer)
	{
		AppCameraRays appCameraRays = Pool.Get<AppCameraRays>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, appCameraRays, isDelta: false);
		return appCameraRays;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AppCameraRays previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AppCameraRays Deserialize(BufferStream stream, AppCameraRays instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.verticalFov = 0f;
			instance.sampleOffset = 0;
			instance.distance = 0f;
			if (instance.entities == null)
			{
				instance.entities = Pool.Get<List<Entity>>();
			}
			instance.timeOfDay = 1f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.verticalFov = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.sampleOffset = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.rayData = ProtocolParser.ReadPooledBytes(stream);
				continue;
			case 37:
				instance.distance = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			case 53:
				instance.timeOfDay = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AppCameraRays DeserializeLengthDelimited(BufferStream stream, AppCameraRays instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.verticalFov = 0f;
			instance.sampleOffset = 0;
			instance.distance = 0f;
			if (instance.entities == null)
			{
				instance.entities = Pool.Get<List<Entity>>();
			}
			instance.timeOfDay = 1f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.verticalFov = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.sampleOffset = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.rayData = ProtocolParser.ReadPooledBytes(stream);
				continue;
			case 37:
				instance.distance = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			case 53:
				instance.timeOfDay = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AppCameraRays DeserializeLength(BufferStream stream, int length, AppCameraRays instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.verticalFov = 0f;
			instance.sampleOffset = 0;
			instance.distance = 0f;
			if (instance.entities == null)
			{
				instance.entities = Pool.Get<List<Entity>>();
			}
			instance.timeOfDay = 1f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.verticalFov = ProtocolParser.ReadSingle(stream);
				continue;
			case 16:
				instance.sampleOffset = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.rayData = ProtocolParser.ReadPooledBytes(stream);
				continue;
			case 37:
				instance.distance = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			case 53:
				instance.timeOfDay = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AppCameraRays instance, AppCameraRays previous)
	{
		if (instance.verticalFov != previous.verticalFov)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.verticalFov);
		}
		if (instance.sampleOffset != previous.sampleOffset)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.sampleOffset);
		}
		if (instance.rayData.Array == null)
		{
			throw new ArgumentNullException("rayData", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WritePooledBytes(stream, instance.rayData);
		if (instance.distance != previous.distance)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.distance);
		}
		if (instance.entities != null)
		{
			for (int i = 0; i < instance.entities.Count; i++)
			{
				Entity entity = instance.entities[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Entity.SerializeDelta(stream, entity, entity);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.timeOfDay != previous.timeOfDay)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.timeOfDay);
		}
	}

	public static void Serialize(BufferStream stream, AppCameraRays instance)
	{
		if (instance.verticalFov != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.verticalFov);
		}
		if (instance.sampleOffset != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.sampleOffset);
		}
		if (instance.rayData.Array == null)
		{
			throw new ArgumentNullException("rayData", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WritePooledBytes(stream, instance.rayData);
		if (instance.distance != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.distance);
		}
		if (instance.entities != null)
		{
			for (int i = 0; i < instance.entities.Count; i++)
			{
				Entity instance2 = instance.entities[i];
				stream.WriteByte(42);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Entity.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.timeOfDay != 1f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.timeOfDay);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (entities != null)
		{
			for (int i = 0; i < entities.Count; i++)
			{
				entities[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AIDesign : IDisposable, IPooled, IProto<AIDesign>, IProto
{
	[NonSerialized]
	public List<int> availableStates;

	[NonSerialized]
	public List<AIStateContainer> stateContainers;

	[NonSerialized]
	public int defaultStateContainer;

	[NonSerialized]
	public string description;

	[NonSerialized]
	public int scope;

	[NonSerialized]
	public int intialViewStateID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AIDesign instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.availableStates != null)
		{
			List<int> list = instance.availableStates;
			Pool.FreeUnmanaged<int>(ref list);
			instance.availableStates = list;
		}
		if (instance.stateContainers != null)
		{
			for (int i = 0; i < instance.stateContainers.Count; i++)
			{
				if (instance.stateContainers[i] != null)
				{
					instance.stateContainers[i].ResetToPool();
					instance.stateContainers[i] = null;
				}
			}
			List<AIStateContainer> list2 = instance.stateContainers;
			Pool.Free<AIStateContainer>(ref list2, false);
			instance.stateContainers = list2;
		}
		instance.defaultStateContainer = 0;
		instance.description = string.Empty;
		instance.scope = 0;
		instance.intialViewStateID = 0;
		Pool.Free<AIDesign>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AIDesign with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AIDesign instance)
	{
		if (availableStates != null)
		{
			instance.availableStates = Pool.Get<List<int>>();
			for (int i = 0; i < availableStates.Count; i++)
			{
				int item = availableStates[i];
				instance.availableStates.Add(item);
			}
		}
		else
		{
			instance.availableStates = null;
		}
		if (stateContainers != null)
		{
			instance.stateContainers = Pool.Get<List<AIStateContainer>>();
			for (int j = 0; j < stateContainers.Count; j++)
			{
				AIStateContainer item2 = stateContainers[j].Copy();
				instance.stateContainers.Add(item2);
			}
		}
		else
		{
			instance.stateContainers = null;
		}
		instance.defaultStateContainer = defaultStateContainer;
		instance.description = description;
		instance.scope = scope;
		instance.intialViewStateID = intialViewStateID;
	}

	public AIDesign Copy()
	{
		AIDesign aIDesign = Pool.Get<AIDesign>();
		CopyTo(aIDesign);
		return aIDesign;
	}

	public static AIDesign Deserialize(BufferStream stream)
	{
		AIDesign aIDesign = Pool.Get<AIDesign>();
		Deserialize(stream, aIDesign, isDelta: false);
		return aIDesign;
	}

	public static AIDesign DeserializeLengthDelimited(BufferStream stream)
	{
		AIDesign aIDesign = Pool.Get<AIDesign>();
		DeserializeLengthDelimited(stream, aIDesign, isDelta: false);
		return aIDesign;
	}

	public static AIDesign DeserializeLength(BufferStream stream, int length)
	{
		AIDesign aIDesign = Pool.Get<AIDesign>();
		DeserializeLength(stream, length, aIDesign, isDelta: false);
		return aIDesign;
	}

	public static AIDesign Deserialize(byte[] buffer)
	{
		AIDesign aIDesign = Pool.Get<AIDesign>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, aIDesign, isDelta: false);
		return aIDesign;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AIDesign previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AIDesign Deserialize(BufferStream stream, AIDesign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.availableStates == null)
			{
				instance.availableStates = Pool.Get<List<int>>();
			}
			if (instance.stateContainers == null)
			{
				instance.stateContainers = Pool.Get<List<AIStateContainer>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.availableStates.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.stateContainers.Add(AIStateContainer.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.defaultStateContainer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.description = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.scope = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.intialViewStateID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AIDesign DeserializeLengthDelimited(BufferStream stream, AIDesign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.availableStates == null)
			{
				instance.availableStates = Pool.Get<List<int>>();
			}
			if (instance.stateContainers == null)
			{
				instance.stateContainers = Pool.Get<List<AIStateContainer>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.availableStates.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.stateContainers.Add(AIStateContainer.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.defaultStateContainer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.description = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.scope = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.intialViewStateID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AIDesign DeserializeLength(BufferStream stream, int length, AIDesign instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.availableStates == null)
			{
				instance.availableStates = Pool.Get<List<int>>();
			}
			if (instance.stateContainers == null)
			{
				instance.stateContainers = Pool.Get<List<AIStateContainer>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.availableStates.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.stateContainers.Add(AIStateContainer.DeserializeLengthDelimited(stream));
				continue;
			case 24:
				instance.defaultStateContainer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				instance.description = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.scope = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.intialViewStateID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AIDesign instance, AIDesign previous)
	{
		if (instance.availableStates != null)
		{
			for (int i = 0; i < instance.availableStates.Count; i++)
			{
				int num = instance.availableStates[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.stateContainers != null)
		{
			for (int j = 0; j < instance.stateContainers.Count; j++)
			{
				AIStateContainer aIStateContainer = instance.stateContainers[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				AIStateContainer.SerializeDelta(stream, aIStateContainer, aIStateContainer);
				int num2 = stream.Position - position;
				if (num2 > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field stateContainers (ProtoBuf.AIStateContainer)");
				}
				Span<byte> span = range.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)num2, span, 0);
				if (num3 < 3)
				{
					span[num3 - 1] |= 128;
					while (num3 < 2)
					{
						span[num3++] = 128;
					}
					span[2] = 0;
				}
			}
		}
		if (instance.defaultStateContainer != previous.defaultStateContainer)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.defaultStateContainer);
		}
		if (instance.description != null && instance.description != previous.description)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.description);
		}
		if (instance.scope != previous.scope)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scope);
		}
		if (instance.intialViewStateID != previous.intialViewStateID)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.intialViewStateID);
		}
	}

	public static void Serialize(BufferStream stream, AIDesign instance)
	{
		if (instance.availableStates != null)
		{
			for (int i = 0; i < instance.availableStates.Count; i++)
			{
				int num = instance.availableStates[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.stateContainers != null)
		{
			for (int j = 0; j < instance.stateContainers.Count; j++)
			{
				AIStateContainer instance2 = instance.stateContainers[j];
				stream.WriteByte(18);
				BufferStream.RangeHandle range = stream.GetRange(3);
				int position = stream.Position;
				AIStateContainer.Serialize(stream, instance2);
				int num2 = stream.Position - position;
				if (num2 > 2097151)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field stateContainers (ProtoBuf.AIStateContainer)");
				}
				Span<byte> span = range.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)num2, span, 0);
				if (num3 < 3)
				{
					span[num3 - 1] |= 128;
					while (num3 < 2)
					{
						span[num3++] = 128;
					}
					span[2] = 0;
				}
			}
		}
		if (instance.defaultStateContainer != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.defaultStateContainer);
		}
		if (instance.description != null)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.description);
		}
		if (instance.scope != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scope);
		}
		if (instance.intialViewStateID != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.intialViewStateID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (stateContainers != null)
		{
			for (int i = 0; i < stateContainers.Count; i++)
			{
				stateContainers[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AIStateContainer : IDisposable, IPooled, IProto<AIStateContainer>, IProto
{
	[NonSerialized]
	public int id;

	[NonSerialized]
	public int state;

	[NonSerialized]
	public List<AIEventData> events;

	[NonSerialized]
	public int inputMemorySlot;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AIStateContainer instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.id = 0;
		instance.state = 0;
		if (instance.events != null)
		{
			for (int i = 0; i < instance.events.Count; i++)
			{
				if (instance.events[i] != null)
				{
					instance.events[i].ResetToPool();
					instance.events[i] = null;
				}
			}
			List<AIEventData> list = instance.events;
			Pool.Free<AIEventData>(ref list, false);
			instance.events = list;
		}
		instance.inputMemorySlot = 0;
		Pool.Free<AIStateContainer>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AIStateContainer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AIStateContainer instance)
	{
		instance.id = id;
		instance.state = state;
		if (events != null)
		{
			instance.events = Pool.Get<List<AIEventData>>();
			for (int i = 0; i < events.Count; i++)
			{
				AIEventData item = events[i].Copy();
				instance.events.Add(item);
			}
		}
		else
		{
			instance.events = null;
		}
		instance.inputMemorySlot = inputMemorySlot;
	}

	public AIStateContainer Copy()
	{
		AIStateContainer aIStateContainer = Pool.Get<AIStateContainer>();
		CopyTo(aIStateContainer);
		return aIStateContainer;
	}

	public static AIStateContainer Deserialize(BufferStream stream)
	{
		AIStateContainer aIStateContainer = Pool.Get<AIStateContainer>();
		Deserialize(stream, aIStateContainer, isDelta: false);
		return aIStateContainer;
	}

	public static AIStateContainer DeserializeLengthDelimited(BufferStream stream)
	{
		AIStateContainer aIStateContainer = Pool.Get<AIStateContainer>();
		DeserializeLengthDelimited(stream, aIStateContainer, isDelta: false);
		return aIStateContainer;
	}

	public static AIStateContainer DeserializeLength(BufferStream stream, int length)
	{
		AIStateContainer aIStateContainer = Pool.Get<AIStateContainer>();
		DeserializeLength(stream, length, aIStateContainer, isDelta: false);
		return aIStateContainer;
	}

	public static AIStateContainer Deserialize(byte[] buffer)
	{
		AIStateContainer aIStateContainer = Pool.Get<AIStateContainer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, aIStateContainer, isDelta: false);
		return aIStateContainer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AIStateContainer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AIStateContainer Deserialize(BufferStream stream, AIStateContainer instance, bool isDelta)
	{
		if (!isDelta && instance.events == null)
		{
			instance.events = Pool.Get<List<AIEventData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.id = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.events.Add(AIEventData.DeserializeLengthDelimited(stream));
				continue;
			case 32:
				instance.inputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AIStateContainer DeserializeLengthDelimited(BufferStream stream, AIStateContainer instance, bool isDelta)
	{
		if (!isDelta && instance.events == null)
		{
			instance.events = Pool.Get<List<AIEventData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.id = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.events.Add(AIEventData.DeserializeLengthDelimited(stream));
				continue;
			case 32:
				instance.inputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AIStateContainer DeserializeLength(BufferStream stream, int length, AIStateContainer instance, bool isDelta)
	{
		if (!isDelta && instance.events == null)
		{
			instance.events = Pool.Get<List<AIEventData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.id = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.events.Add(AIEventData.DeserializeLengthDelimited(stream));
				continue;
			case 32:
				instance.inputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AIStateContainer instance, AIStateContainer previous)
	{
		if (instance.id != previous.id)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.id);
		}
		if (instance.state != previous.state)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.events != null)
		{
			for (int i = 0; i < instance.events.Count; i++)
			{
				AIEventData aIEventData = instance.events[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range = stream.GetRange(2);
				int position = stream.Position;
				AIEventData.SerializeDelta(stream, aIEventData, aIEventData);
				int num = stream.Position - position;
				if (num > 16383)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field events (ProtoBuf.AIEventData)");
				}
				Span<byte> span = range.GetSpan();
				if (ProtocolParser.WriteUInt32((uint)num, span, 0) < 2)
				{
					span[0] |= 128;
					span[1] = 0;
				}
			}
		}
		if (instance.inputMemorySlot != previous.inputMemorySlot)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inputMemorySlot);
		}
	}

	public static void Serialize(BufferStream stream, AIStateContainer instance)
	{
		if (instance.id != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.id);
		}
		if (instance.state != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.events != null)
		{
			for (int i = 0; i < instance.events.Count; i++)
			{
				AIEventData instance2 = instance.events[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range = stream.GetRange(2);
				int position = stream.Position;
				AIEventData.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 16383)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field events (ProtoBuf.AIEventData)");
				}
				Span<byte> span = range.GetSpan();
				if (ProtocolParser.WriteUInt32((uint)num, span, 0) < 2)
				{
					span[0] |= 128;
					span[1] = 0;
				}
			}
		}
		if (instance.inputMemorySlot != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inputMemorySlot);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (events != null)
		{
			for (int i = 0; i < events.Count; i++)
			{
				events[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AIEventData : IDisposable, IPooled, IProto<AIEventData>, IProto
{
	[NonSerialized]
	public int eventType;

	[NonSerialized]
	public int triggerStateContainer;

	[NonSerialized]
	public bool inverted;

	[NonSerialized]
	public int inputMemorySlot;

	[NonSerialized]
	public int outputMemorySlot;

	[NonSerialized]
	public int id;

	[NonSerialized]
	public TimerAIEventData timerData;

	[NonSerialized]
	public PlayerDetectedAIEventData playerDetectedData;

	[NonSerialized]
	public HealthBelowAIEventData healthBelowData;

	[NonSerialized]
	public InRangeAIEventData inRangeData;

	[NonSerialized]
	public HungerAboveAIEventData hungerAboveData;

	[NonSerialized]
	public TirednessAboveAIEventData tirednessAboveData;

	[NonSerialized]
	public ThreatDetectedAIEventData threatDetectedData;

	[NonSerialized]
	public TargetDetectedAIEventData targetDetectedData;

	[NonSerialized]
	public AmmoBelowAIEventData ammoBelowData;

	[NonSerialized]
	public ChanceAIEventData chanceData;

	[NonSerialized]
	public TimeSinceThreatAIEventData timeSinceThreatData;

	[NonSerialized]
	public AggressionTimerAIEventData aggressionTimerData;

	[NonSerialized]
	public InRangeOfHomeAIEventData inRangeOfHomeData;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.eventType = 0;
			instance.triggerStateContainer = 0;
			instance.inverted = false;
			instance.inputMemorySlot = 0;
			instance.outputMemorySlot = 0;
			instance.id = 0;
			if (instance.timerData != null)
			{
				instance.timerData.ResetToPool();
				instance.timerData = null;
			}
			if (instance.playerDetectedData != null)
			{
				instance.playerDetectedData.ResetToPool();
				instance.playerDetectedData = null;
			}
			if (instance.healthBelowData != null)
			{
				instance.healthBelowData.ResetToPool();
				instance.healthBelowData = null;
			}
			if (instance.inRangeData != null)
			{
				instance.inRangeData.ResetToPool();
				instance.inRangeData = null;
			}
			if (instance.hungerAboveData != null)
			{
				instance.hungerAboveData.ResetToPool();
				instance.hungerAboveData = null;
			}
			if (instance.tirednessAboveData != null)
			{
				instance.tirednessAboveData.ResetToPool();
				instance.tirednessAboveData = null;
			}
			if (instance.threatDetectedData != null)
			{
				instance.threatDetectedData.ResetToPool();
				instance.threatDetectedData = null;
			}
			if (instance.targetDetectedData != null)
			{
				instance.targetDetectedData.ResetToPool();
				instance.targetDetectedData = null;
			}
			if (instance.ammoBelowData != null)
			{
				instance.ammoBelowData.ResetToPool();
				instance.ammoBelowData = null;
			}
			if (instance.chanceData != null)
			{
				instance.chanceData.ResetToPool();
				instance.chanceData = null;
			}
			if (instance.timeSinceThreatData != null)
			{
				instance.timeSinceThreatData.ResetToPool();
				instance.timeSinceThreatData = null;
			}
			if (instance.aggressionTimerData != null)
			{
				instance.aggressionTimerData.ResetToPool();
				instance.aggressionTimerData = null;
			}
			if (instance.inRangeOfHomeData != null)
			{
				instance.inRangeOfHomeData.ResetToPool();
				instance.inRangeOfHomeData = null;
			}
			Pool.Free<AIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AIEventData instance)
	{
		instance.eventType = eventType;
		instance.triggerStateContainer = triggerStateContainer;
		instance.inverted = inverted;
		instance.inputMemorySlot = inputMemorySlot;
		instance.outputMemorySlot = outputMemorySlot;
		instance.id = id;
		if (timerData != null)
		{
			if (instance.timerData == null)
			{
				instance.timerData = timerData.Copy();
			}
			else
			{
				timerData.CopyTo(instance.timerData);
			}
		}
		else
		{
			instance.timerData = null;
		}
		if (playerDetectedData != null)
		{
			if (instance.playerDetectedData == null)
			{
				instance.playerDetectedData = playerDetectedData.Copy();
			}
			else
			{
				playerDetectedData.CopyTo(instance.playerDetectedData);
			}
		}
		else
		{
			instance.playerDetectedData = null;
		}
		if (healthBelowData != null)
		{
			if (instance.healthBelowData == null)
			{
				instance.healthBelowData = healthBelowData.Copy();
			}
			else
			{
				healthBelowData.CopyTo(instance.healthBelowData);
			}
		}
		else
		{
			instance.healthBelowData = null;
		}
		if (inRangeData != null)
		{
			if (instance.inRangeData == null)
			{
				instance.inRangeData = inRangeData.Copy();
			}
			else
			{
				inRangeData.CopyTo(instance.inRangeData);
			}
		}
		else
		{
			instance.inRangeData = null;
		}
		if (hungerAboveData != null)
		{
			if (instance.hungerAboveData == null)
			{
				instance.hungerAboveData = hungerAboveData.Copy();
			}
			else
			{
				hungerAboveData.CopyTo(instance.hungerAboveData);
			}
		}
		else
		{
			instance.hungerAboveData = null;
		}
		if (tirednessAboveData != null)
		{
			if (instance.tirednessAboveData == null)
			{
				instance.tirednessAboveData = tirednessAboveData.Copy();
			}
			else
			{
				tirednessAboveData.CopyTo(instance.tirednessAboveData);
			}
		}
		else
		{
			instance.tirednessAboveData = null;
		}
		if (threatDetectedData != null)
		{
			if (instance.threatDetectedData == null)
			{
				instance.threatDetectedData = threatDetectedData.Copy();
			}
			else
			{
				threatDetectedData.CopyTo(instance.threatDetectedData);
			}
		}
		else
		{
			instance.threatDetectedData = null;
		}
		if (targetDetectedData != null)
		{
			if (instance.targetDetectedData == null)
			{
				instance.targetDetectedData = targetDetectedData.Copy();
			}
			else
			{
				targetDetectedData.CopyTo(instance.targetDetectedData);
			}
		}
		else
		{
			instance.targetDetectedData = null;
		}
		if (ammoBelowData != null)
		{
			if (instance.ammoBelowData == null)
			{
				instance.ammoBelowData = ammoBelowData.Copy();
			}
			else
			{
				ammoBelowData.CopyTo(instance.ammoBelowData);
			}
		}
		else
		{
			instance.ammoBelowData = null;
		}
		if (chanceData != null)
		{
			if (instance.chanceData == null)
			{
				instance.chanceData = chanceData.Copy();
			}
			else
			{
				chanceData.CopyTo(instance.chanceData);
			}
		}
		else
		{
			instance.chanceData = null;
		}
		if (timeSinceThreatData != null)
		{
			if (instance.timeSinceThreatData == null)
			{
				instance.timeSinceThreatData = timeSinceThreatData.Copy();
			}
			else
			{
				timeSinceThreatData.CopyTo(instance.timeSinceThreatData);
			}
		}
		else
		{
			instance.timeSinceThreatData = null;
		}
		if (aggressionTimerData != null)
		{
			if (instance.aggressionTimerData == null)
			{
				instance.aggressionTimerData = aggressionTimerData.Copy();
			}
			else
			{
				aggressionTimerData.CopyTo(instance.aggressionTimerData);
			}
		}
		else
		{
			instance.aggressionTimerData = null;
		}
		if (inRangeOfHomeData != null)
		{
			if (instance.inRangeOfHomeData == null)
			{
				instance.inRangeOfHomeData = inRangeOfHomeData.Copy();
			}
			else
			{
				inRangeOfHomeData.CopyTo(instance.inRangeOfHomeData);
			}
		}
		else
		{
			instance.inRangeOfHomeData = null;
		}
	}

	public AIEventData Copy()
	{
		AIEventData aIEventData = Pool.Get<AIEventData>();
		CopyTo(aIEventData);
		return aIEventData;
	}

	public static AIEventData Deserialize(BufferStream stream)
	{
		AIEventData aIEventData = Pool.Get<AIEventData>();
		Deserialize(stream, aIEventData, isDelta: false);
		return aIEventData;
	}

	public static AIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		AIEventData aIEventData = Pool.Get<AIEventData>();
		DeserializeLengthDelimited(stream, aIEventData, isDelta: false);
		return aIEventData;
	}

	public static AIEventData DeserializeLength(BufferStream stream, int length)
	{
		AIEventData aIEventData = Pool.Get<AIEventData>();
		DeserializeLength(stream, length, aIEventData, isDelta: false);
		return aIEventData;
	}

	public static AIEventData Deserialize(byte[] buffer)
	{
		AIEventData aIEventData = Pool.Get<AIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, aIEventData, isDelta: false);
		return aIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AIEventData Deserialize(BufferStream stream, AIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.eventType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.triggerStateContainer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.inverted = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.inputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.outputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.id = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			switch (key.Field)
			{
			case 100u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.timerData == null)
					{
						instance.timerData = TimerAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TimerAIEventData.DeserializeLengthDelimited(stream, instance.timerData, isDelta);
					}
				}
				break;
			case 101u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.playerDetectedData == null)
					{
						instance.playerDetectedData = PlayerDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerDetectedAIEventData.DeserializeLengthDelimited(stream, instance.playerDetectedData, isDelta);
					}
				}
				break;
			case 102u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.healthBelowData == null)
					{
						instance.healthBelowData = HealthBelowAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						HealthBelowAIEventData.DeserializeLengthDelimited(stream, instance.healthBelowData, isDelta);
					}
				}
				break;
			case 103u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.inRangeData == null)
					{
						instance.inRangeData = InRangeAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						InRangeAIEventData.DeserializeLengthDelimited(stream, instance.inRangeData, isDelta);
					}
				}
				break;
			case 104u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.hungerAboveData == null)
					{
						instance.hungerAboveData = HungerAboveAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						HungerAboveAIEventData.DeserializeLengthDelimited(stream, instance.hungerAboveData, isDelta);
					}
				}
				break;
			case 105u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.tirednessAboveData == null)
					{
						instance.tirednessAboveData = TirednessAboveAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TirednessAboveAIEventData.DeserializeLengthDelimited(stream, instance.tirednessAboveData, isDelta);
					}
				}
				break;
			case 106u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.threatDetectedData == null)
					{
						instance.threatDetectedData = ThreatDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						ThreatDetectedAIEventData.DeserializeLengthDelimited(stream, instance.threatDetectedData, isDelta);
					}
				}
				break;
			case 107u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.targetDetectedData == null)
					{
						instance.targetDetectedData = TargetDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TargetDetectedAIEventData.DeserializeLengthDelimited(stream, instance.targetDetectedData, isDelta);
					}
				}
				break;
			case 108u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.ammoBelowData == null)
					{
						instance.ammoBelowData = AmmoBelowAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						AmmoBelowAIEventData.DeserializeLengthDelimited(stream, instance.ammoBelowData, isDelta);
					}
				}
				break;
			case 109u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.chanceData == null)
					{
						instance.chanceData = ChanceAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						ChanceAIEventData.DeserializeLengthDelimited(stream, instance.chanceData, isDelta);
					}
				}
				break;
			case 110u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.timeSinceThreatData == null)
					{
						instance.timeSinceThreatData = TimeSinceThreatAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TimeSinceThreatAIEventData.DeserializeLengthDelimited(stream, instance.timeSinceThreatData, isDelta);
					}
				}
				break;
			case 111u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.aggressionTimerData == null)
					{
						instance.aggressionTimerData = AggressionTimerAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						AggressionTimerAIEventData.DeserializeLengthDelimited(stream, instance.aggressionTimerData, isDelta);
					}
				}
				break;
			case 112u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.inRangeOfHomeData == null)
					{
						instance.inRangeOfHomeData = InRangeOfHomeAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						InRangeOfHomeAIEventData.DeserializeLengthDelimited(stream, instance.inRangeOfHomeData, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
	}

	public static AIEventData DeserializeLengthDelimited(BufferStream stream, AIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.eventType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.triggerStateContainer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.inverted = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.inputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.outputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.id = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 100u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.timerData == null)
					{
						instance.timerData = TimerAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TimerAIEventData.DeserializeLengthDelimited(stream, instance.timerData, isDelta);
					}
				}
				break;
			case 101u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.playerDetectedData == null)
					{
						instance.playerDetectedData = PlayerDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerDetectedAIEventData.DeserializeLengthDelimited(stream, instance.playerDetectedData, isDelta);
					}
				}
				break;
			case 102u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.healthBelowData == null)
					{
						instance.healthBelowData = HealthBelowAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						HealthBelowAIEventData.DeserializeLengthDelimited(stream, instance.healthBelowData, isDelta);
					}
				}
				break;
			case 103u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.inRangeData == null)
					{
						instance.inRangeData = InRangeAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						InRangeAIEventData.DeserializeLengthDelimited(stream, instance.inRangeData, isDelta);
					}
				}
				break;
			case 104u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.hungerAboveData == null)
					{
						instance.hungerAboveData = HungerAboveAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						HungerAboveAIEventData.DeserializeLengthDelimited(stream, instance.hungerAboveData, isDelta);
					}
				}
				break;
			case 105u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.tirednessAboveData == null)
					{
						instance.tirednessAboveData = TirednessAboveAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TirednessAboveAIEventData.DeserializeLengthDelimited(stream, instance.tirednessAboveData, isDelta);
					}
				}
				break;
			case 106u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.threatDetectedData == null)
					{
						instance.threatDetectedData = ThreatDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						ThreatDetectedAIEventData.DeserializeLengthDelimited(stream, instance.threatDetectedData, isDelta);
					}
				}
				break;
			case 107u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.targetDetectedData == null)
					{
						instance.targetDetectedData = TargetDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TargetDetectedAIEventData.DeserializeLengthDelimited(stream, instance.targetDetectedData, isDelta);
					}
				}
				break;
			case 108u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.ammoBelowData == null)
					{
						instance.ammoBelowData = AmmoBelowAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						AmmoBelowAIEventData.DeserializeLengthDelimited(stream, instance.ammoBelowData, isDelta);
					}
				}
				break;
			case 109u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.chanceData == null)
					{
						instance.chanceData = ChanceAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						ChanceAIEventData.DeserializeLengthDelimited(stream, instance.chanceData, isDelta);
					}
				}
				break;
			case 110u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.timeSinceThreatData == null)
					{
						instance.timeSinceThreatData = TimeSinceThreatAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TimeSinceThreatAIEventData.DeserializeLengthDelimited(stream, instance.timeSinceThreatData, isDelta);
					}
				}
				break;
			case 111u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.aggressionTimerData == null)
					{
						instance.aggressionTimerData = AggressionTimerAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						AggressionTimerAIEventData.DeserializeLengthDelimited(stream, instance.aggressionTimerData, isDelta);
					}
				}
				break;
			case 112u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.inRangeOfHomeData == null)
					{
						instance.inRangeOfHomeData = InRangeOfHomeAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						InRangeOfHomeAIEventData.DeserializeLengthDelimited(stream, instance.inRangeOfHomeData, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AIEventData DeserializeLength(BufferStream stream, int length, AIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.eventType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.triggerStateContainer = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.inverted = ProtocolParser.ReadBool(stream);
				continue;
			case 32:
				instance.inputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.outputMemorySlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.id = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			switch (key.Field)
			{
			case 100u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.timerData == null)
					{
						instance.timerData = TimerAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TimerAIEventData.DeserializeLengthDelimited(stream, instance.timerData, isDelta);
					}
				}
				break;
			case 101u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.playerDetectedData == null)
					{
						instance.playerDetectedData = PlayerDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						PlayerDetectedAIEventData.DeserializeLengthDelimited(stream, instance.playerDetectedData, isDelta);
					}
				}
				break;
			case 102u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.healthBelowData == null)
					{
						instance.healthBelowData = HealthBelowAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						HealthBelowAIEventData.DeserializeLengthDelimited(stream, instance.healthBelowData, isDelta);
					}
				}
				break;
			case 103u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.inRangeData == null)
					{
						instance.inRangeData = InRangeAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						InRangeAIEventData.DeserializeLengthDelimited(stream, instance.inRangeData, isDelta);
					}
				}
				break;
			case 104u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.hungerAboveData == null)
					{
						instance.hungerAboveData = HungerAboveAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						HungerAboveAIEventData.DeserializeLengthDelimited(stream, instance.hungerAboveData, isDelta);
					}
				}
				break;
			case 105u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.tirednessAboveData == null)
					{
						instance.tirednessAboveData = TirednessAboveAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TirednessAboveAIEventData.DeserializeLengthDelimited(stream, instance.tirednessAboveData, isDelta);
					}
				}
				break;
			case 106u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.threatDetectedData == null)
					{
						instance.threatDetectedData = ThreatDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						ThreatDetectedAIEventData.DeserializeLengthDelimited(stream, instance.threatDetectedData, isDelta);
					}
				}
				break;
			case 107u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.targetDetectedData == null)
					{
						instance.targetDetectedData = TargetDetectedAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TargetDetectedAIEventData.DeserializeLengthDelimited(stream, instance.targetDetectedData, isDelta);
					}
				}
				break;
			case 108u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.ammoBelowData == null)
					{
						instance.ammoBelowData = AmmoBelowAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						AmmoBelowAIEventData.DeserializeLengthDelimited(stream, instance.ammoBelowData, isDelta);
					}
				}
				break;
			case 109u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.chanceData == null)
					{
						instance.chanceData = ChanceAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						ChanceAIEventData.DeserializeLengthDelimited(stream, instance.chanceData, isDelta);
					}
				}
				break;
			case 110u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.timeSinceThreatData == null)
					{
						instance.timeSinceThreatData = TimeSinceThreatAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						TimeSinceThreatAIEventData.DeserializeLengthDelimited(stream, instance.timeSinceThreatData, isDelta);
					}
				}
				break;
			case 111u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.aggressionTimerData == null)
					{
						instance.aggressionTimerData = AggressionTimerAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						AggressionTimerAIEventData.DeserializeLengthDelimited(stream, instance.aggressionTimerData, isDelta);
					}
				}
				break;
			case 112u:
				if (key.WireType == Wire.LengthDelimited)
				{
					if (instance.inRangeOfHomeData == null)
					{
						instance.inRangeOfHomeData = InRangeOfHomeAIEventData.DeserializeLengthDelimited(stream);
					}
					else
					{
						InRangeOfHomeAIEventData.DeserializeLengthDelimited(stream, instance.inRangeOfHomeData, isDelta);
					}
				}
				break;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AIEventData instance, AIEventData previous)
	{
		if (instance.eventType != previous.eventType)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.eventType);
		}
		if (instance.triggerStateContainer != previous.triggerStateContainer)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.triggerStateContainer);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.inverted);
		if (instance.inputMemorySlot != previous.inputMemorySlot)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inputMemorySlot);
		}
		if (instance.outputMemorySlot != previous.outputMemorySlot)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.outputMemorySlot);
		}
		if (instance.id != previous.id)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.id);
		}
		if (instance.timerData != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(6);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			TimerAIEventData.SerializeDelta(stream, instance.timerData, previous.timerData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field timerData (ProtoBuf.TimerAIEventData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.playerDetectedData != null)
		{
			stream.WriteByte(170);
			stream.WriteByte(6);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			PlayerDetectedAIEventData.SerializeDelta(stream, instance.playerDetectedData, previous.playerDetectedData);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerDetectedData (ProtoBuf.PlayerDetectedAIEventData)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.healthBelowData != null)
		{
			stream.WriteByte(178);
			stream.WriteByte(6);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			HealthBelowAIEventData.SerializeDelta(stream, instance.healthBelowData, previous.healthBelowData);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field healthBelowData (ProtoBuf.HealthBelowAIEventData)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.inRangeData != null)
		{
			stream.WriteByte(186);
			stream.WriteByte(6);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			InRangeAIEventData.SerializeDelta(stream, instance.inRangeData, previous.inRangeData);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inRangeData (ProtoBuf.InRangeAIEventData)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.hungerAboveData != null)
		{
			stream.WriteByte(194);
			stream.WriteByte(6);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			HungerAboveAIEventData.SerializeDelta(stream, instance.hungerAboveData, previous.hungerAboveData);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hungerAboveData (ProtoBuf.HungerAboveAIEventData)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.tirednessAboveData != null)
		{
			stream.WriteByte(202);
			stream.WriteByte(6);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			TirednessAboveAIEventData.SerializeDelta(stream, instance.tirednessAboveData, previous.tirednessAboveData);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field tirednessAboveData (ProtoBuf.TirednessAboveAIEventData)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.threatDetectedData != null)
		{
			stream.WriteByte(210);
			stream.WriteByte(6);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			ThreatDetectedAIEventData.SerializeDelta(stream, instance.threatDetectedData, previous.threatDetectedData);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field threatDetectedData (ProtoBuf.ThreatDetectedAIEventData)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.targetDetectedData != null)
		{
			stream.WriteByte(218);
			stream.WriteByte(6);
			BufferStream.RangeHandle range8 = stream.GetRange(1);
			int position8 = stream.Position;
			TargetDetectedAIEventData.SerializeDelta(stream, instance.targetDetectedData, previous.targetDetectedData);
			int num8 = stream.Position - position8;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetDetectedData (ProtoBuf.TargetDetectedAIEventData)");
			}
			Span<byte> span8 = range8.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span8, 0);
		}
		if (instance.ammoBelowData != null)
		{
			stream.WriteByte(226);
			stream.WriteByte(6);
			BufferStream.RangeHandle range9 = stream.GetRange(1);
			int position9 = stream.Position;
			AmmoBelowAIEventData.SerializeDelta(stream, instance.ammoBelowData, previous.ammoBelowData);
			int num9 = stream.Position - position9;
			if (num9 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ammoBelowData (ProtoBuf.AmmoBelowAIEventData)");
			}
			Span<byte> span9 = range9.GetSpan();
			ProtocolParser.WriteUInt32((uint)num9, span9, 0);
		}
		if (instance.chanceData != null)
		{
			stream.WriteByte(234);
			stream.WriteByte(6);
			BufferStream.RangeHandle range10 = stream.GetRange(1);
			int position10 = stream.Position;
			ChanceAIEventData.SerializeDelta(stream, instance.chanceData, previous.chanceData);
			int num10 = stream.Position - position10;
			if (num10 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field chanceData (ProtoBuf.ChanceAIEventData)");
			}
			Span<byte> span10 = range10.GetSpan();
			ProtocolParser.WriteUInt32((uint)num10, span10, 0);
		}
		if (instance.timeSinceThreatData != null)
		{
			stream.WriteByte(242);
			stream.WriteByte(6);
			BufferStream.RangeHandle range11 = stream.GetRange(1);
			int position11 = stream.Position;
			TimeSinceThreatAIEventData.SerializeDelta(stream, instance.timeSinceThreatData, previous.timeSinceThreatData);
			int num11 = stream.Position - position11;
			if (num11 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field timeSinceThreatData (ProtoBuf.TimeSinceThreatAIEventData)");
			}
			Span<byte> span11 = range11.GetSpan();
			ProtocolParser.WriteUInt32((uint)num11, span11, 0);
		}
		if (instance.aggressionTimerData != null)
		{
			stream.WriteByte(250);
			stream.WriteByte(6);
			BufferStream.RangeHandle range12 = stream.GetRange(1);
			int position12 = stream.Position;
			AggressionTimerAIEventData.SerializeDelta(stream, instance.aggressionTimerData, previous.aggressionTimerData);
			int num12 = stream.Position - position12;
			if (num12 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aggressionTimerData (ProtoBuf.AggressionTimerAIEventData)");
			}
			Span<byte> span12 = range12.GetSpan();
			ProtocolParser.WriteUInt32((uint)num12, span12, 0);
		}
		if (instance.inRangeOfHomeData != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(7);
			BufferStream.RangeHandle range13 = stream.GetRange(1);
			int position13 = stream.Position;
			InRangeOfHomeAIEventData.SerializeDelta(stream, instance.inRangeOfHomeData, previous.inRangeOfHomeData);
			int num13 = stream.Position - position13;
			if (num13 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inRangeOfHomeData (ProtoBuf.InRangeOfHomeAIEventData)");
			}
			Span<byte> span13 = range13.GetSpan();
			ProtocolParser.WriteUInt32((uint)num13, span13, 0);
		}
	}

	public static void Serialize(BufferStream stream, AIEventData instance)
	{
		if (instance.eventType != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.eventType);
		}
		if (instance.triggerStateContainer != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.triggerStateContainer);
		}
		if (instance.inverted)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.inverted);
		}
		if (instance.inputMemorySlot != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inputMemorySlot);
		}
		if (instance.outputMemorySlot != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.outputMemorySlot);
		}
		if (instance.id != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.id);
		}
		if (instance.timerData != null)
		{
			stream.WriteByte(162);
			stream.WriteByte(6);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			TimerAIEventData.Serialize(stream, instance.timerData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field timerData (ProtoBuf.TimerAIEventData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.playerDetectedData != null)
		{
			stream.WriteByte(170);
			stream.WriteByte(6);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			PlayerDetectedAIEventData.Serialize(stream, instance.playerDetectedData);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerDetectedData (ProtoBuf.PlayerDetectedAIEventData)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.healthBelowData != null)
		{
			stream.WriteByte(178);
			stream.WriteByte(6);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			HealthBelowAIEventData.Serialize(stream, instance.healthBelowData);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field healthBelowData (ProtoBuf.HealthBelowAIEventData)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.inRangeData != null)
		{
			stream.WriteByte(186);
			stream.WriteByte(6);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			InRangeAIEventData.Serialize(stream, instance.inRangeData);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inRangeData (ProtoBuf.InRangeAIEventData)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.hungerAboveData != null)
		{
			stream.WriteByte(194);
			stream.WriteByte(6);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			HungerAboveAIEventData.Serialize(stream, instance.hungerAboveData);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field hungerAboveData (ProtoBuf.HungerAboveAIEventData)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.tirednessAboveData != null)
		{
			stream.WriteByte(202);
			stream.WriteByte(6);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			TirednessAboveAIEventData.Serialize(stream, instance.tirednessAboveData);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field tirednessAboveData (ProtoBuf.TirednessAboveAIEventData)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.threatDetectedData != null)
		{
			stream.WriteByte(210);
			stream.WriteByte(6);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			ThreatDetectedAIEventData.Serialize(stream, instance.threatDetectedData);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field threatDetectedData (ProtoBuf.ThreatDetectedAIEventData)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.targetDetectedData != null)
		{
			stream.WriteByte(218);
			stream.WriteByte(6);
			BufferStream.RangeHandle range8 = stream.GetRange(1);
			int position8 = stream.Position;
			TargetDetectedAIEventData.Serialize(stream, instance.targetDetectedData);
			int num8 = stream.Position - position8;
			if (num8 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field targetDetectedData (ProtoBuf.TargetDetectedAIEventData)");
			}
			Span<byte> span8 = range8.GetSpan();
			ProtocolParser.WriteUInt32((uint)num8, span8, 0);
		}
		if (instance.ammoBelowData != null)
		{
			stream.WriteByte(226);
			stream.WriteByte(6);
			BufferStream.RangeHandle range9 = stream.GetRange(1);
			int position9 = stream.Position;
			AmmoBelowAIEventData.Serialize(stream, instance.ammoBelowData);
			int num9 = stream.Position - position9;
			if (num9 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ammoBelowData (ProtoBuf.AmmoBelowAIEventData)");
			}
			Span<byte> span9 = range9.GetSpan();
			ProtocolParser.WriteUInt32((uint)num9, span9, 0);
		}
		if (instance.chanceData != null)
		{
			stream.WriteByte(234);
			stream.WriteByte(6);
			BufferStream.RangeHandle range10 = stream.GetRange(1);
			int position10 = stream.Position;
			ChanceAIEventData.Serialize(stream, instance.chanceData);
			int num10 = stream.Position - position10;
			if (num10 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field chanceData (ProtoBuf.ChanceAIEventData)");
			}
			Span<byte> span10 = range10.GetSpan();
			ProtocolParser.WriteUInt32((uint)num10, span10, 0);
		}
		if (instance.timeSinceThreatData != null)
		{
			stream.WriteByte(242);
			stream.WriteByte(6);
			BufferStream.RangeHandle range11 = stream.GetRange(1);
			int position11 = stream.Position;
			TimeSinceThreatAIEventData.Serialize(stream, instance.timeSinceThreatData);
			int num11 = stream.Position - position11;
			if (num11 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field timeSinceThreatData (ProtoBuf.TimeSinceThreatAIEventData)");
			}
			Span<byte> span11 = range11.GetSpan();
			ProtocolParser.WriteUInt32((uint)num11, span11, 0);
		}
		if (instance.aggressionTimerData != null)
		{
			stream.WriteByte(250);
			stream.WriteByte(6);
			BufferStream.RangeHandle range12 = stream.GetRange(1);
			int position12 = stream.Position;
			AggressionTimerAIEventData.Serialize(stream, instance.aggressionTimerData);
			int num12 = stream.Position - position12;
			if (num12 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field aggressionTimerData (ProtoBuf.AggressionTimerAIEventData)");
			}
			Span<byte> span12 = range12.GetSpan();
			ProtocolParser.WriteUInt32((uint)num12, span12, 0);
		}
		if (instance.inRangeOfHomeData != null)
		{
			stream.WriteByte(130);
			stream.WriteByte(7);
			BufferStream.RangeHandle range13 = stream.GetRange(1);
			int position13 = stream.Position;
			InRangeOfHomeAIEventData.Serialize(stream, instance.inRangeOfHomeData);
			int num13 = stream.Position - position13;
			if (num13 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field inRangeOfHomeData (ProtoBuf.InRangeOfHomeAIEventData)");
			}
			Span<byte> span13 = range13.GetSpan();
			ProtocolParser.WriteUInt32((uint)num13, span13, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		timerData?.InspectUids(action);
		playerDetectedData?.InspectUids(action);
		healthBelowData?.InspectUids(action);
		inRangeData?.InspectUids(action);
		hungerAboveData?.InspectUids(action);
		tirednessAboveData?.InspectUids(action);
		threatDetectedData?.InspectUids(action);
		targetDetectedData?.InspectUids(action);
		ammoBelowData?.InspectUids(action);
		chanceData?.InspectUids(action);
		timeSinceThreatData?.InspectUids(action);
		aggressionTimerData?.InspectUids(action);
		inRangeOfHomeData?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TimerAIEventData : IDisposable, IPooled, IProto<TimerAIEventData>, IProto
{
	[NonSerialized]
	public float duration;

	[NonSerialized]
	public float durationMax;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TimerAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.duration = 0f;
			instance.durationMax = 0f;
			Pool.Free<TimerAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TimerAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TimerAIEventData instance)
	{
		instance.duration = duration;
		instance.durationMax = durationMax;
	}

	public TimerAIEventData Copy()
	{
		TimerAIEventData timerAIEventData = Pool.Get<TimerAIEventData>();
		CopyTo(timerAIEventData);
		return timerAIEventData;
	}

	public static TimerAIEventData Deserialize(BufferStream stream)
	{
		TimerAIEventData timerAIEventData = Pool.Get<TimerAIEventData>();
		Deserialize(stream, timerAIEventData, isDelta: false);
		return timerAIEventData;
	}

	public static TimerAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		TimerAIEventData timerAIEventData = Pool.Get<TimerAIEventData>();
		DeserializeLengthDelimited(stream, timerAIEventData, isDelta: false);
		return timerAIEventData;
	}

	public static TimerAIEventData DeserializeLength(BufferStream stream, int length)
	{
		TimerAIEventData timerAIEventData = Pool.Get<TimerAIEventData>();
		DeserializeLength(stream, length, timerAIEventData, isDelta: false);
		return timerAIEventData;
	}

	public static TimerAIEventData Deserialize(byte[] buffer)
	{
		TimerAIEventData timerAIEventData = Pool.Get<TimerAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, timerAIEventData, isDelta: false);
		return timerAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TimerAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TimerAIEventData Deserialize(BufferStream stream, TimerAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.durationMax = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TimerAIEventData DeserializeLengthDelimited(BufferStream stream, TimerAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.durationMax = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TimerAIEventData DeserializeLength(BufferStream stream, int length, TimerAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.duration = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.durationMax = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TimerAIEventData instance, TimerAIEventData previous)
	{
		if (instance.duration != previous.duration)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.duration);
		}
		if (instance.durationMax != previous.durationMax)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.durationMax);
		}
	}

	public static void Serialize(BufferStream stream, TimerAIEventData instance)
	{
		if (instance.duration != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.duration);
		}
		if (instance.durationMax != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.durationMax);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class PlayerDetectedAIEventData : IDisposable, IPooled, IProto<PlayerDetectedAIEventData>, IProto
{
	[NonSerialized]
	public float range;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerDetectedAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.range = 0f;
			Pool.Free<PlayerDetectedAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerDetectedAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerDetectedAIEventData instance)
	{
		instance.range = range;
	}

	public PlayerDetectedAIEventData Copy()
	{
		PlayerDetectedAIEventData playerDetectedAIEventData = Pool.Get<PlayerDetectedAIEventData>();
		CopyTo(playerDetectedAIEventData);
		return playerDetectedAIEventData;
	}

	public static PlayerDetectedAIEventData Deserialize(BufferStream stream)
	{
		PlayerDetectedAIEventData playerDetectedAIEventData = Pool.Get<PlayerDetectedAIEventData>();
		Deserialize(stream, playerDetectedAIEventData, isDelta: false);
		return playerDetectedAIEventData;
	}

	public static PlayerDetectedAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerDetectedAIEventData playerDetectedAIEventData = Pool.Get<PlayerDetectedAIEventData>();
		DeserializeLengthDelimited(stream, playerDetectedAIEventData, isDelta: false);
		return playerDetectedAIEventData;
	}

	public static PlayerDetectedAIEventData DeserializeLength(BufferStream stream, int length)
	{
		PlayerDetectedAIEventData playerDetectedAIEventData = Pool.Get<PlayerDetectedAIEventData>();
		DeserializeLength(stream, length, playerDetectedAIEventData, isDelta: false);
		return playerDetectedAIEventData;
	}

	public static PlayerDetectedAIEventData Deserialize(byte[] buffer)
	{
		PlayerDetectedAIEventData playerDetectedAIEventData = Pool.Get<PlayerDetectedAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerDetectedAIEventData, isDelta: false);
		return playerDetectedAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerDetectedAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerDetectedAIEventData Deserialize(BufferStream stream, PlayerDetectedAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerDetectedAIEventData DeserializeLengthDelimited(BufferStream stream, PlayerDetectedAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerDetectedAIEventData DeserializeLength(BufferStream stream, int length, PlayerDetectedAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerDetectedAIEventData instance, PlayerDetectedAIEventData previous)
	{
		if (instance.range != previous.range)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public static void Serialize(BufferStream stream, PlayerDetectedAIEventData instance)
	{
		if (instance.range != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class HealthBelowAIEventData : IDisposable, IPooled, IProto<HealthBelowAIEventData>, IProto
{
	[NonSerialized]
	public float healthFraction;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(HealthBelowAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.healthFraction = 0f;
			Pool.Free<HealthBelowAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose HealthBelowAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(HealthBelowAIEventData instance)
	{
		instance.healthFraction = healthFraction;
	}

	public HealthBelowAIEventData Copy()
	{
		HealthBelowAIEventData healthBelowAIEventData = Pool.Get<HealthBelowAIEventData>();
		CopyTo(healthBelowAIEventData);
		return healthBelowAIEventData;
	}

	public static HealthBelowAIEventData Deserialize(BufferStream stream)
	{
		HealthBelowAIEventData healthBelowAIEventData = Pool.Get<HealthBelowAIEventData>();
		Deserialize(stream, healthBelowAIEventData, isDelta: false);
		return healthBelowAIEventData;
	}

	public static HealthBelowAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		HealthBelowAIEventData healthBelowAIEventData = Pool.Get<HealthBelowAIEventData>();
		DeserializeLengthDelimited(stream, healthBelowAIEventData, isDelta: false);
		return healthBelowAIEventData;
	}

	public static HealthBelowAIEventData DeserializeLength(BufferStream stream, int length)
	{
		HealthBelowAIEventData healthBelowAIEventData = Pool.Get<HealthBelowAIEventData>();
		DeserializeLength(stream, length, healthBelowAIEventData, isDelta: false);
		return healthBelowAIEventData;
	}

	public static HealthBelowAIEventData Deserialize(byte[] buffer)
	{
		HealthBelowAIEventData healthBelowAIEventData = Pool.Get<HealthBelowAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, healthBelowAIEventData, isDelta: false);
		return healthBelowAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, HealthBelowAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static HealthBelowAIEventData Deserialize(BufferStream stream, HealthBelowAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.healthFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static HealthBelowAIEventData DeserializeLengthDelimited(BufferStream stream, HealthBelowAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.healthFraction = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static HealthBelowAIEventData DeserializeLength(BufferStream stream, int length, HealthBelowAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.healthFraction = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, HealthBelowAIEventData instance, HealthBelowAIEventData previous)
	{
		if (instance.healthFraction != previous.healthFraction)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.healthFraction);
		}
	}

	public static void Serialize(BufferStream stream, HealthBelowAIEventData instance)
	{
		if (instance.healthFraction != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.healthFraction);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class InRangeAIEventData : IDisposable, IPooled, IProto<InRangeAIEventData>, IProto
{
	[NonSerialized]
	public float range;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(InRangeAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.range = 0f;
			Pool.Free<InRangeAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose InRangeAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(InRangeAIEventData instance)
	{
		instance.range = range;
	}

	public InRangeAIEventData Copy()
	{
		InRangeAIEventData inRangeAIEventData = Pool.Get<InRangeAIEventData>();
		CopyTo(inRangeAIEventData);
		return inRangeAIEventData;
	}

	public static InRangeAIEventData Deserialize(BufferStream stream)
	{
		InRangeAIEventData inRangeAIEventData = Pool.Get<InRangeAIEventData>();
		Deserialize(stream, inRangeAIEventData, isDelta: false);
		return inRangeAIEventData;
	}

	public static InRangeAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		InRangeAIEventData inRangeAIEventData = Pool.Get<InRangeAIEventData>();
		DeserializeLengthDelimited(stream, inRangeAIEventData, isDelta: false);
		return inRangeAIEventData;
	}

	public static InRangeAIEventData DeserializeLength(BufferStream stream, int length)
	{
		InRangeAIEventData inRangeAIEventData = Pool.Get<InRangeAIEventData>();
		DeserializeLength(stream, length, inRangeAIEventData, isDelta: false);
		return inRangeAIEventData;
	}

	public static InRangeAIEventData Deserialize(byte[] buffer)
	{
		InRangeAIEventData inRangeAIEventData = Pool.Get<InRangeAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, inRangeAIEventData, isDelta: false);
		return inRangeAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, InRangeAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static InRangeAIEventData Deserialize(BufferStream stream, InRangeAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static InRangeAIEventData DeserializeLengthDelimited(BufferStream stream, InRangeAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static InRangeAIEventData DeserializeLength(BufferStream stream, int length, InRangeAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, InRangeAIEventData instance, InRangeAIEventData previous)
	{
		if (instance.range != previous.range)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public static void Serialize(BufferStream stream, InRangeAIEventData instance)
	{
		if (instance.range != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class HungerAboveAIEventData : IDisposable, IPooled, IProto<HungerAboveAIEventData>, IProto
{
	[NonSerialized]
	public float value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(HungerAboveAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0f;
			Pool.Free<HungerAboveAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose HungerAboveAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(HungerAboveAIEventData instance)
	{
		instance.value = value;
	}

	public HungerAboveAIEventData Copy()
	{
		HungerAboveAIEventData hungerAboveAIEventData = Pool.Get<HungerAboveAIEventData>();
		CopyTo(hungerAboveAIEventData);
		return hungerAboveAIEventData;
	}

	public static HungerAboveAIEventData Deserialize(BufferStream stream)
	{
		HungerAboveAIEventData hungerAboveAIEventData = Pool.Get<HungerAboveAIEventData>();
		Deserialize(stream, hungerAboveAIEventData, isDelta: false);
		return hungerAboveAIEventData;
	}

	public static HungerAboveAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		HungerAboveAIEventData hungerAboveAIEventData = Pool.Get<HungerAboveAIEventData>();
		DeserializeLengthDelimited(stream, hungerAboveAIEventData, isDelta: false);
		return hungerAboveAIEventData;
	}

	public static HungerAboveAIEventData DeserializeLength(BufferStream stream, int length)
	{
		HungerAboveAIEventData hungerAboveAIEventData = Pool.Get<HungerAboveAIEventData>();
		DeserializeLength(stream, length, hungerAboveAIEventData, isDelta: false);
		return hungerAboveAIEventData;
	}

	public static HungerAboveAIEventData Deserialize(byte[] buffer)
	{
		HungerAboveAIEventData hungerAboveAIEventData = Pool.Get<HungerAboveAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, hungerAboveAIEventData, isDelta: false);
		return hungerAboveAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, HungerAboveAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static HungerAboveAIEventData Deserialize(BufferStream stream, HungerAboveAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static HungerAboveAIEventData DeserializeLengthDelimited(BufferStream stream, HungerAboveAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static HungerAboveAIEventData DeserializeLength(BufferStream stream, int length, HungerAboveAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, HungerAboveAIEventData instance, HungerAboveAIEventData previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, HungerAboveAIEventData instance)
	{
		if (instance.value != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TirednessAboveAIEventData : IDisposable, IPooled, IProto<TirednessAboveAIEventData>, IProto
{
	[NonSerialized]
	public float value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TirednessAboveAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0f;
			Pool.Free<TirednessAboveAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TirednessAboveAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TirednessAboveAIEventData instance)
	{
		instance.value = value;
	}

	public TirednessAboveAIEventData Copy()
	{
		TirednessAboveAIEventData tirednessAboveAIEventData = Pool.Get<TirednessAboveAIEventData>();
		CopyTo(tirednessAboveAIEventData);
		return tirednessAboveAIEventData;
	}

	public static TirednessAboveAIEventData Deserialize(BufferStream stream)
	{
		TirednessAboveAIEventData tirednessAboveAIEventData = Pool.Get<TirednessAboveAIEventData>();
		Deserialize(stream, tirednessAboveAIEventData, isDelta: false);
		return tirednessAboveAIEventData;
	}

	public static TirednessAboveAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		TirednessAboveAIEventData tirednessAboveAIEventData = Pool.Get<TirednessAboveAIEventData>();
		DeserializeLengthDelimited(stream, tirednessAboveAIEventData, isDelta: false);
		return tirednessAboveAIEventData;
	}

	public static TirednessAboveAIEventData DeserializeLength(BufferStream stream, int length)
	{
		TirednessAboveAIEventData tirednessAboveAIEventData = Pool.Get<TirednessAboveAIEventData>();
		DeserializeLength(stream, length, tirednessAboveAIEventData, isDelta: false);
		return tirednessAboveAIEventData;
	}

	public static TirednessAboveAIEventData Deserialize(byte[] buffer)
	{
		TirednessAboveAIEventData tirednessAboveAIEventData = Pool.Get<TirednessAboveAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, tirednessAboveAIEventData, isDelta: false);
		return tirednessAboveAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TirednessAboveAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TirednessAboveAIEventData Deserialize(BufferStream stream, TirednessAboveAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TirednessAboveAIEventData DeserializeLengthDelimited(BufferStream stream, TirednessAboveAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TirednessAboveAIEventData DeserializeLength(BufferStream stream, int length, TirednessAboveAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TirednessAboveAIEventData instance, TirednessAboveAIEventData previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, TirednessAboveAIEventData instance)
	{
		if (instance.value != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AmmoBelowAIEventData : IDisposable, IPooled, IProto<AmmoBelowAIEventData>, IProto
{
	[NonSerialized]
	public float value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AmmoBelowAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0f;
			Pool.Free<AmmoBelowAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AmmoBelowAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AmmoBelowAIEventData instance)
	{
		instance.value = value;
	}

	public AmmoBelowAIEventData Copy()
	{
		AmmoBelowAIEventData ammoBelowAIEventData = Pool.Get<AmmoBelowAIEventData>();
		CopyTo(ammoBelowAIEventData);
		return ammoBelowAIEventData;
	}

	public static AmmoBelowAIEventData Deserialize(BufferStream stream)
	{
		AmmoBelowAIEventData ammoBelowAIEventData = Pool.Get<AmmoBelowAIEventData>();
		Deserialize(stream, ammoBelowAIEventData, isDelta: false);
		return ammoBelowAIEventData;
	}

	public static AmmoBelowAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		AmmoBelowAIEventData ammoBelowAIEventData = Pool.Get<AmmoBelowAIEventData>();
		DeserializeLengthDelimited(stream, ammoBelowAIEventData, isDelta: false);
		return ammoBelowAIEventData;
	}

	public static AmmoBelowAIEventData DeserializeLength(BufferStream stream, int length)
	{
		AmmoBelowAIEventData ammoBelowAIEventData = Pool.Get<AmmoBelowAIEventData>();
		DeserializeLength(stream, length, ammoBelowAIEventData, isDelta: false);
		return ammoBelowAIEventData;
	}

	public static AmmoBelowAIEventData Deserialize(byte[] buffer)
	{
		AmmoBelowAIEventData ammoBelowAIEventData = Pool.Get<AmmoBelowAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ammoBelowAIEventData, isDelta: false);
		return ammoBelowAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AmmoBelowAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AmmoBelowAIEventData Deserialize(BufferStream stream, AmmoBelowAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AmmoBelowAIEventData DeserializeLengthDelimited(BufferStream stream, AmmoBelowAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AmmoBelowAIEventData DeserializeLength(BufferStream stream, int length, AmmoBelowAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AmmoBelowAIEventData instance, AmmoBelowAIEventData previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, AmmoBelowAIEventData instance)
	{
		if (instance.value != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ThreatDetectedAIEventData : IDisposable, IPooled, IProto<ThreatDetectedAIEventData>, IProto
{
	[NonSerialized]
	public float range;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ThreatDetectedAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.range = 0f;
			Pool.Free<ThreatDetectedAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ThreatDetectedAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ThreatDetectedAIEventData instance)
	{
		instance.range = range;
	}

	public ThreatDetectedAIEventData Copy()
	{
		ThreatDetectedAIEventData threatDetectedAIEventData = Pool.Get<ThreatDetectedAIEventData>();
		CopyTo(threatDetectedAIEventData);
		return threatDetectedAIEventData;
	}

	public static ThreatDetectedAIEventData Deserialize(BufferStream stream)
	{
		ThreatDetectedAIEventData threatDetectedAIEventData = Pool.Get<ThreatDetectedAIEventData>();
		Deserialize(stream, threatDetectedAIEventData, isDelta: false);
		return threatDetectedAIEventData;
	}

	public static ThreatDetectedAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		ThreatDetectedAIEventData threatDetectedAIEventData = Pool.Get<ThreatDetectedAIEventData>();
		DeserializeLengthDelimited(stream, threatDetectedAIEventData, isDelta: false);
		return threatDetectedAIEventData;
	}

	public static ThreatDetectedAIEventData DeserializeLength(BufferStream stream, int length)
	{
		ThreatDetectedAIEventData threatDetectedAIEventData = Pool.Get<ThreatDetectedAIEventData>();
		DeserializeLength(stream, length, threatDetectedAIEventData, isDelta: false);
		return threatDetectedAIEventData;
	}

	public static ThreatDetectedAIEventData Deserialize(byte[] buffer)
	{
		ThreatDetectedAIEventData threatDetectedAIEventData = Pool.Get<ThreatDetectedAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, threatDetectedAIEventData, isDelta: false);
		return threatDetectedAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ThreatDetectedAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ThreatDetectedAIEventData Deserialize(BufferStream stream, ThreatDetectedAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ThreatDetectedAIEventData DeserializeLengthDelimited(BufferStream stream, ThreatDetectedAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ThreatDetectedAIEventData DeserializeLength(BufferStream stream, int length, ThreatDetectedAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ThreatDetectedAIEventData instance, ThreatDetectedAIEventData previous)
	{
		if (instance.range != previous.range)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public static void Serialize(BufferStream stream, ThreatDetectedAIEventData instance)
	{
		if (instance.range != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TargetDetectedAIEventData : IDisposable, IPooled, IProto<TargetDetectedAIEventData>, IProto
{
	[NonSerialized]
	public float range;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TargetDetectedAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.range = 0f;
			Pool.Free<TargetDetectedAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TargetDetectedAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TargetDetectedAIEventData instance)
	{
		instance.range = range;
	}

	public TargetDetectedAIEventData Copy()
	{
		TargetDetectedAIEventData targetDetectedAIEventData = Pool.Get<TargetDetectedAIEventData>();
		CopyTo(targetDetectedAIEventData);
		return targetDetectedAIEventData;
	}

	public static TargetDetectedAIEventData Deserialize(BufferStream stream)
	{
		TargetDetectedAIEventData targetDetectedAIEventData = Pool.Get<TargetDetectedAIEventData>();
		Deserialize(stream, targetDetectedAIEventData, isDelta: false);
		return targetDetectedAIEventData;
	}

	public static TargetDetectedAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		TargetDetectedAIEventData targetDetectedAIEventData = Pool.Get<TargetDetectedAIEventData>();
		DeserializeLengthDelimited(stream, targetDetectedAIEventData, isDelta: false);
		return targetDetectedAIEventData;
	}

	public static TargetDetectedAIEventData DeserializeLength(BufferStream stream, int length)
	{
		TargetDetectedAIEventData targetDetectedAIEventData = Pool.Get<TargetDetectedAIEventData>();
		DeserializeLength(stream, length, targetDetectedAIEventData, isDelta: false);
		return targetDetectedAIEventData;
	}

	public static TargetDetectedAIEventData Deserialize(byte[] buffer)
	{
		TargetDetectedAIEventData targetDetectedAIEventData = Pool.Get<TargetDetectedAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, targetDetectedAIEventData, isDelta: false);
		return targetDetectedAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TargetDetectedAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TargetDetectedAIEventData Deserialize(BufferStream stream, TargetDetectedAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TargetDetectedAIEventData DeserializeLengthDelimited(BufferStream stream, TargetDetectedAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TargetDetectedAIEventData DeserializeLength(BufferStream stream, int length, TargetDetectedAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TargetDetectedAIEventData instance, TargetDetectedAIEventData previous)
	{
		if (instance.range != previous.range)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public static void Serialize(BufferStream stream, TargetDetectedAIEventData instance)
	{
		if (instance.range != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ChanceAIEventData : IDisposable, IPooled, IProto<ChanceAIEventData>, IProto
{
	[NonSerialized]
	public float value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ChanceAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0f;
			Pool.Free<ChanceAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ChanceAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ChanceAIEventData instance)
	{
		instance.value = value;
	}

	public ChanceAIEventData Copy()
	{
		ChanceAIEventData chanceAIEventData = Pool.Get<ChanceAIEventData>();
		CopyTo(chanceAIEventData);
		return chanceAIEventData;
	}

	public static ChanceAIEventData Deserialize(BufferStream stream)
	{
		ChanceAIEventData chanceAIEventData = Pool.Get<ChanceAIEventData>();
		Deserialize(stream, chanceAIEventData, isDelta: false);
		return chanceAIEventData;
	}

	public static ChanceAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		ChanceAIEventData chanceAIEventData = Pool.Get<ChanceAIEventData>();
		DeserializeLengthDelimited(stream, chanceAIEventData, isDelta: false);
		return chanceAIEventData;
	}

	public static ChanceAIEventData DeserializeLength(BufferStream stream, int length)
	{
		ChanceAIEventData chanceAIEventData = Pool.Get<ChanceAIEventData>();
		DeserializeLength(stream, length, chanceAIEventData, isDelta: false);
		return chanceAIEventData;
	}

	public static ChanceAIEventData Deserialize(byte[] buffer)
	{
		ChanceAIEventData chanceAIEventData = Pool.Get<ChanceAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, chanceAIEventData, isDelta: false);
		return chanceAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ChanceAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ChanceAIEventData Deserialize(BufferStream stream, ChanceAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ChanceAIEventData DeserializeLengthDelimited(BufferStream stream, ChanceAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ChanceAIEventData DeserializeLength(BufferStream stream, int length, ChanceAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ChanceAIEventData instance, ChanceAIEventData previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, ChanceAIEventData instance)
	{
		if (instance.value != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class TimeSinceThreatAIEventData : IDisposable, IPooled, IProto<TimeSinceThreatAIEventData>, IProto
{
	[NonSerialized]
	public float value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TimeSinceThreatAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0f;
			Pool.Free<TimeSinceThreatAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TimeSinceThreatAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TimeSinceThreatAIEventData instance)
	{
		instance.value = value;
	}

	public TimeSinceThreatAIEventData Copy()
	{
		TimeSinceThreatAIEventData timeSinceThreatAIEventData = Pool.Get<TimeSinceThreatAIEventData>();
		CopyTo(timeSinceThreatAIEventData);
		return timeSinceThreatAIEventData;
	}

	public static TimeSinceThreatAIEventData Deserialize(BufferStream stream)
	{
		TimeSinceThreatAIEventData timeSinceThreatAIEventData = Pool.Get<TimeSinceThreatAIEventData>();
		Deserialize(stream, timeSinceThreatAIEventData, isDelta: false);
		return timeSinceThreatAIEventData;
	}

	public static TimeSinceThreatAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		TimeSinceThreatAIEventData timeSinceThreatAIEventData = Pool.Get<TimeSinceThreatAIEventData>();
		DeserializeLengthDelimited(stream, timeSinceThreatAIEventData, isDelta: false);
		return timeSinceThreatAIEventData;
	}

	public static TimeSinceThreatAIEventData DeserializeLength(BufferStream stream, int length)
	{
		TimeSinceThreatAIEventData timeSinceThreatAIEventData = Pool.Get<TimeSinceThreatAIEventData>();
		DeserializeLength(stream, length, timeSinceThreatAIEventData, isDelta: false);
		return timeSinceThreatAIEventData;
	}

	public static TimeSinceThreatAIEventData Deserialize(byte[] buffer)
	{
		TimeSinceThreatAIEventData timeSinceThreatAIEventData = Pool.Get<TimeSinceThreatAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, timeSinceThreatAIEventData, isDelta: false);
		return timeSinceThreatAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TimeSinceThreatAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TimeSinceThreatAIEventData Deserialize(BufferStream stream, TimeSinceThreatAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TimeSinceThreatAIEventData DeserializeLengthDelimited(BufferStream stream, TimeSinceThreatAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TimeSinceThreatAIEventData DeserializeLength(BufferStream stream, int length, TimeSinceThreatAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TimeSinceThreatAIEventData instance, TimeSinceThreatAIEventData previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, TimeSinceThreatAIEventData instance)
	{
		if (instance.value != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class AggressionTimerAIEventData : IDisposable, IPooled, IProto<AggressionTimerAIEventData>, IProto
{
	[NonSerialized]
	public float value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AggressionTimerAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.value = 0f;
			Pool.Free<AggressionTimerAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AggressionTimerAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AggressionTimerAIEventData instance)
	{
		instance.value = value;
	}

	public AggressionTimerAIEventData Copy()
	{
		AggressionTimerAIEventData aggressionTimerAIEventData = Pool.Get<AggressionTimerAIEventData>();
		CopyTo(aggressionTimerAIEventData);
		return aggressionTimerAIEventData;
	}

	public static AggressionTimerAIEventData Deserialize(BufferStream stream)
	{
		AggressionTimerAIEventData aggressionTimerAIEventData = Pool.Get<AggressionTimerAIEventData>();
		Deserialize(stream, aggressionTimerAIEventData, isDelta: false);
		return aggressionTimerAIEventData;
	}

	public static AggressionTimerAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		AggressionTimerAIEventData aggressionTimerAIEventData = Pool.Get<AggressionTimerAIEventData>();
		DeserializeLengthDelimited(stream, aggressionTimerAIEventData, isDelta: false);
		return aggressionTimerAIEventData;
	}

	public static AggressionTimerAIEventData DeserializeLength(BufferStream stream, int length)
	{
		AggressionTimerAIEventData aggressionTimerAIEventData = Pool.Get<AggressionTimerAIEventData>();
		DeserializeLength(stream, length, aggressionTimerAIEventData, isDelta: false);
		return aggressionTimerAIEventData;
	}

	public static AggressionTimerAIEventData Deserialize(byte[] buffer)
	{
		AggressionTimerAIEventData aggressionTimerAIEventData = Pool.Get<AggressionTimerAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, aggressionTimerAIEventData, isDelta: false);
		return aggressionTimerAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, AggressionTimerAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AggressionTimerAIEventData Deserialize(BufferStream stream, AggressionTimerAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AggressionTimerAIEventData DeserializeLengthDelimited(BufferStream stream, AggressionTimerAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AggressionTimerAIEventData DeserializeLength(BufferStream stream, int length, AggressionTimerAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.value = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, AggressionTimerAIEventData instance, AggressionTimerAIEventData previous)
	{
		if (instance.value != previous.value)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public static void Serialize(BufferStream stream, AggressionTimerAIEventData instance)
	{
		if (instance.value != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class MemoryBank : IDisposable, IPooled, IProto<MemoryBank>, IProto
{
	[NonSerialized]
	public int type;

	[NonSerialized]
	public int slotCount;

	[NonSerialized]
	public List<int> slots;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MemoryBank instance)
	{
		if (instance.ShouldPool)
		{
			instance.type = 0;
			instance.slotCount = 0;
			if (instance.slots != null)
			{
				List<int> list = instance.slots;
				Pool.FreeUnmanaged<int>(ref list);
				instance.slots = list;
			}
			Pool.Free<MemoryBank>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MemoryBank with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MemoryBank instance)
	{
		instance.type = type;
		instance.slotCount = slotCount;
		if (slots != null)
		{
			instance.slots = Pool.Get<List<int>>();
			for (int i = 0; i < slots.Count; i++)
			{
				int item = slots[i];
				instance.slots.Add(item);
			}
		}
		else
		{
			instance.slots = null;
		}
	}

	public MemoryBank Copy()
	{
		MemoryBank memoryBank = Pool.Get<MemoryBank>();
		CopyTo(memoryBank);
		return memoryBank;
	}

	public static MemoryBank Deserialize(BufferStream stream)
	{
		MemoryBank memoryBank = Pool.Get<MemoryBank>();
		Deserialize(stream, memoryBank, isDelta: false);
		return memoryBank;
	}

	public static MemoryBank DeserializeLengthDelimited(BufferStream stream)
	{
		MemoryBank memoryBank = Pool.Get<MemoryBank>();
		DeserializeLengthDelimited(stream, memoryBank, isDelta: false);
		return memoryBank;
	}

	public static MemoryBank DeserializeLength(BufferStream stream, int length)
	{
		MemoryBank memoryBank = Pool.Get<MemoryBank>();
		DeserializeLength(stream, length, memoryBank, isDelta: false);
		return memoryBank;
	}

	public static MemoryBank Deserialize(byte[] buffer)
	{
		MemoryBank memoryBank = Pool.Get<MemoryBank>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, memoryBank, isDelta: false);
		return memoryBank;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MemoryBank previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MemoryBank Deserialize(BufferStream stream, MemoryBank instance, bool isDelta)
	{
		if (!isDelta && instance.slots == null)
		{
			instance.slots = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.slotCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.slots.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MemoryBank DeserializeLengthDelimited(BufferStream stream, MemoryBank instance, bool isDelta)
	{
		if (!isDelta && instance.slots == null)
		{
			instance.slots = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.slotCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.slots.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MemoryBank DeserializeLength(BufferStream stream, int length, MemoryBank instance, bool isDelta)
	{
		if (!isDelta && instance.slots == null)
		{
			instance.slots = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.slotCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.slots.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MemoryBank instance, MemoryBank previous)
	{
		if (instance.type != previous.type)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.slotCount != previous.slotCount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slotCount);
		}
		if (instance.slots != null)
		{
			for (int i = 0; i < instance.slots.Count; i++)
			{
				int num = instance.slots[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
	}

	public static void Serialize(BufferStream stream, MemoryBank instance)
	{
		if (instance.type != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.slotCount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slotCount);
		}
		if (instance.slots != null)
		{
			for (int i = 0; i < instance.slots.Count; i++)
			{
				int num = instance.slots[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class InRangeOfHomeAIEventData : IDisposable, IPooled, IProto<InRangeOfHomeAIEventData>, IProto
{
	[NonSerialized]
	public float range;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(InRangeOfHomeAIEventData instance)
	{
		if (instance.ShouldPool)
		{
			instance.range = 0f;
			Pool.Free<InRangeOfHomeAIEventData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose InRangeOfHomeAIEventData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(InRangeOfHomeAIEventData instance)
	{
		instance.range = range;
	}

	public InRangeOfHomeAIEventData Copy()
	{
		InRangeOfHomeAIEventData inRangeOfHomeAIEventData = Pool.Get<InRangeOfHomeAIEventData>();
		CopyTo(inRangeOfHomeAIEventData);
		return inRangeOfHomeAIEventData;
	}

	public static InRangeOfHomeAIEventData Deserialize(BufferStream stream)
	{
		InRangeOfHomeAIEventData inRangeOfHomeAIEventData = Pool.Get<InRangeOfHomeAIEventData>();
		Deserialize(stream, inRangeOfHomeAIEventData, isDelta: false);
		return inRangeOfHomeAIEventData;
	}

	public static InRangeOfHomeAIEventData DeserializeLengthDelimited(BufferStream stream)
	{
		InRangeOfHomeAIEventData inRangeOfHomeAIEventData = Pool.Get<InRangeOfHomeAIEventData>();
		DeserializeLengthDelimited(stream, inRangeOfHomeAIEventData, isDelta: false);
		return inRangeOfHomeAIEventData;
	}

	public static InRangeOfHomeAIEventData DeserializeLength(BufferStream stream, int length)
	{
		InRangeOfHomeAIEventData inRangeOfHomeAIEventData = Pool.Get<InRangeOfHomeAIEventData>();
		DeserializeLength(stream, length, inRangeOfHomeAIEventData, isDelta: false);
		return inRangeOfHomeAIEventData;
	}

	public static InRangeOfHomeAIEventData Deserialize(byte[] buffer)
	{
		InRangeOfHomeAIEventData inRangeOfHomeAIEventData = Pool.Get<InRangeOfHomeAIEventData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, inRangeOfHomeAIEventData, isDelta: false);
		return inRangeOfHomeAIEventData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, InRangeOfHomeAIEventData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static InRangeOfHomeAIEventData Deserialize(BufferStream stream, InRangeOfHomeAIEventData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static InRangeOfHomeAIEventData DeserializeLengthDelimited(BufferStream stream, InRangeOfHomeAIEventData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static InRangeOfHomeAIEventData DeserializeLength(BufferStream stream, int length, InRangeOfHomeAIEventData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.range = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, InRangeOfHomeAIEventData instance, InRangeOfHomeAIEventData previous)
	{
		if (instance.range != previous.range)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public static void Serialize(BufferStream stream, InRangeOfHomeAIEventData instance)
	{
		if (instance.range != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.range);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class GlobalEntityData : IDisposable, IPooled, IProto<GlobalEntityData>, IProto
{
	[NonSerialized]
	public uint prefabId;

	[NonSerialized]
	public NetworkableId uid;

	[NonSerialized]
	public Vector3 pos;

	[NonSerialized]
	public Vector3 rot;

	[NonSerialized]
	public ulong modelState;

	[NonSerialized]
	public int grade;

	[NonSerialized]
	public int flags;

	[NonSerialized]
	public ulong skin;

	[NonSerialized]
	public int customColor;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(GlobalEntityData instance)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.prefabId = 0u;
			instance.uid = default(NetworkableId);
			instance.pos = default(Vector3);
			instance.rot = default(Vector3);
			instance.modelState = 0uL;
			instance.grade = 0;
			instance.flags = 0;
			instance.skin = 0uL;
			instance.customColor = 0;
			Pool.Free<GlobalEntityData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose GlobalEntityData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(GlobalEntityData instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		instance.prefabId = prefabId;
		instance.uid = uid;
		instance.pos = pos;
		instance.rot = rot;
		instance.modelState = modelState;
		instance.grade = grade;
		instance.flags = flags;
		instance.skin = skin;
		instance.customColor = customColor;
	}

	public GlobalEntityData Copy()
	{
		GlobalEntityData globalEntityData = Pool.Get<GlobalEntityData>();
		CopyTo(globalEntityData);
		return globalEntityData;
	}

	public static GlobalEntityData Deserialize(BufferStream stream)
	{
		GlobalEntityData globalEntityData = Pool.Get<GlobalEntityData>();
		Deserialize(stream, globalEntityData, isDelta: false);
		return globalEntityData;
	}

	public static GlobalEntityData DeserializeLengthDelimited(BufferStream stream)
	{
		GlobalEntityData globalEntityData = Pool.Get<GlobalEntityData>();
		DeserializeLengthDelimited(stream, globalEntityData, isDelta: false);
		return globalEntityData;
	}

	public static GlobalEntityData DeserializeLength(BufferStream stream, int length)
	{
		GlobalEntityData globalEntityData = Pool.Get<GlobalEntityData>();
		DeserializeLength(stream, length, globalEntityData, isDelta: false);
		return globalEntityData;
	}

	public static GlobalEntityData Deserialize(byte[] buffer)
	{
		GlobalEntityData globalEntityData = Pool.Get<GlobalEntityData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, globalEntityData, isDelta: false);
		return globalEntityData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, GlobalEntityData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static GlobalEntityData Deserialize(BufferStream stream, GlobalEntityData instance, bool isDelta)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.prefabId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.uid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pos, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rot, isDelta);
				continue;
			case 40:
				instance.modelState = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.grade = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.skin = ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.customColor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static GlobalEntityData DeserializeLengthDelimited(BufferStream stream, GlobalEntityData instance, bool isDelta)
	{
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.prefabId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.uid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pos, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rot, isDelta);
				continue;
			case 40:
				instance.modelState = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.grade = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.skin = ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.customColor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static GlobalEntityData DeserializeLength(BufferStream stream, int length, GlobalEntityData instance, bool isDelta)
	{
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.prefabId = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.uid = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.pos, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rot, isDelta);
				continue;
			case 40:
				instance.modelState = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.grade = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.flags = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.skin = ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.customColor = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, GlobalEntityData instance, GlobalEntityData previous)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		if (instance.prefabId != previous.prefabId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.prefabId);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.uid.Value);
		if (instance.pos != previous.pos)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.pos, previous.pos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.rot != previous.rot)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.rot, previous.rot);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rot (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.modelState != previous.modelState)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.modelState);
		}
		if (instance.grade != previous.grade)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.grade);
		}
		if (instance.flags != previous.flags)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.skin != previous.skin)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.skin);
		}
		if (instance.customColor != previous.customColor)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.customColor);
		}
	}

	public static void Serialize(BufferStream stream, GlobalEntityData instance)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		if (instance.prefabId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.prefabId);
		}
		if (instance.uid != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.uid.Value);
		}
		if (instance.pos != default(Vector3))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.pos);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field pos (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.rot != default(Vector3))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.rot);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field rot (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.modelState != 0L)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.modelState);
		}
		if (instance.grade != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.grade);
		}
		if (instance.flags != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.flags);
		}
		if (instance.skin != 0L)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, instance.skin);
		}
		if (instance.customColor != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.customColor);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref uid.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class GlobalEntityCollection : IDisposable, IPooled, IProto<GlobalEntityCollection>, IProto
{
	[NonSerialized]
	public List<GlobalEntityData> entities;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(GlobalEntityCollection instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.entities != null)
		{
			for (int i = 0; i < instance.entities.Count; i++)
			{
				if (instance.entities[i] != null)
				{
					instance.entities[i].ResetToPool();
					instance.entities[i] = null;
				}
			}
			List<GlobalEntityData> list = instance.entities;
			Pool.Free<GlobalEntityData>(ref list, false);
			instance.entities = list;
		}
		Pool.Free<GlobalEntityCollection>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose GlobalEntityCollection with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(GlobalEntityCollection instance)
	{
		if (entities != null)
		{
			instance.entities = Pool.Get<List<GlobalEntityData>>();
			for (int i = 0; i < entities.Count; i++)
			{
				GlobalEntityData item = entities[i].Copy();
				instance.entities.Add(item);
			}
		}
		else
		{
			instance.entities = null;
		}
	}

	public GlobalEntityCollection Copy()
	{
		GlobalEntityCollection globalEntityCollection = Pool.Get<GlobalEntityCollection>();
		CopyTo(globalEntityCollection);
		return globalEntityCollection;
	}

	public static GlobalEntityCollection Deserialize(BufferStream stream)
	{
		GlobalEntityCollection globalEntityCollection = Pool.Get<GlobalEntityCollection>();
		Deserialize(stream, globalEntityCollection, isDelta: false);
		return globalEntityCollection;
	}

	public static GlobalEntityCollection DeserializeLengthDelimited(BufferStream stream)
	{
		GlobalEntityCollection globalEntityCollection = Pool.Get<GlobalEntityCollection>();
		DeserializeLengthDelimited(stream, globalEntityCollection, isDelta: false);
		return globalEntityCollection;
	}

	public static GlobalEntityCollection DeserializeLength(BufferStream stream, int length)
	{
		GlobalEntityCollection globalEntityCollection = Pool.Get<GlobalEntityCollection>();
		DeserializeLength(stream, length, globalEntityCollection, isDelta: false);
		return globalEntityCollection;
	}

	public static GlobalEntityCollection Deserialize(byte[] buffer)
	{
		GlobalEntityCollection globalEntityCollection = Pool.Get<GlobalEntityCollection>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, globalEntityCollection, isDelta: false);
		return globalEntityCollection;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, GlobalEntityCollection previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static GlobalEntityCollection Deserialize(BufferStream stream, GlobalEntityCollection instance, bool isDelta)
	{
		if (!isDelta && instance.entities == null)
		{
			instance.entities = Pool.Get<List<GlobalEntityData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.entities.Add(GlobalEntityData.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static GlobalEntityCollection DeserializeLengthDelimited(BufferStream stream, GlobalEntityCollection instance, bool isDelta)
	{
		if (!isDelta && instance.entities == null)
		{
			instance.entities = Pool.Get<List<GlobalEntityData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entities.Add(GlobalEntityData.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static GlobalEntityCollection DeserializeLength(BufferStream stream, int length, GlobalEntityCollection instance, bool isDelta)
	{
		if (!isDelta && instance.entities == null)
		{
			instance.entities = Pool.Get<List<GlobalEntityData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entities.Add(GlobalEntityData.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, GlobalEntityCollection instance, GlobalEntityCollection previous)
	{
		if (instance.entities == null)
		{
			return;
		}
		for (int i = 0; i < instance.entities.Count; i++)
		{
			GlobalEntityData globalEntityData = instance.entities[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			GlobalEntityData.SerializeDelta(stream, globalEntityData, globalEntityData);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field entities (ProtoBuf.GlobalEntityData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, GlobalEntityCollection instance)
	{
		if (instance.entities == null)
		{
			return;
		}
		for (int i = 0; i < instance.entities.Count; i++)
		{
			GlobalEntityData instance2 = instance.entities[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			GlobalEntityData.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field entities (ProtoBuf.GlobalEntityData)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (entities != null)
		{
			for (int i = 0; i < entities.Count; i++)
			{
				entities[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClanActionResult : IDisposable, IPooled, IProto<ClanActionResult>, IProto
{
	[NonSerialized]
	public int requestId;

	[NonSerialized]
	public int result;

	[NonSerialized]
	public bool hasClanInfo;

	[NonSerialized]
	public ClanInfo clanInfo;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanActionResult instance)
	{
		if (instance.ShouldPool)
		{
			instance.requestId = 0;
			instance.result = 0;
			instance.hasClanInfo = false;
			if (instance.clanInfo != null)
			{
				instance.clanInfo.ResetToPool();
				instance.clanInfo = null;
			}
			Pool.Free<ClanActionResult>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanActionResult with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanActionResult instance)
	{
		instance.requestId = requestId;
		instance.result = result;
		instance.hasClanInfo = hasClanInfo;
		if (clanInfo != null)
		{
			if (instance.clanInfo == null)
			{
				instance.clanInfo = clanInfo.Copy();
			}
			else
			{
				clanInfo.CopyTo(instance.clanInfo);
			}
		}
		else
		{
			instance.clanInfo = null;
		}
	}

	public ClanActionResult Copy()
	{
		ClanActionResult instance = Pool.Get<ClanActionResult>();
		CopyTo(instance);
		return instance;
	}

	public static ClanActionResult Deserialize(BufferStream stream)
	{
		ClanActionResult instance = Pool.Get<ClanActionResult>();
		Deserialize(stream, instance, isDelta: false);
		return instance;
	}

	public static ClanActionResult DeserializeLengthDelimited(BufferStream stream)
	{
		ClanActionResult instance = Pool.Get<ClanActionResult>();
		DeserializeLengthDelimited(stream, instance, isDelta: false);
		return instance;
	}

	public static ClanActionResult DeserializeLength(BufferStream stream, int length)
	{
		ClanActionResult instance = Pool.Get<ClanActionResult>();
		DeserializeLength(stream, length, instance, isDelta: false);
		return instance;
	}

	public static ClanActionResult Deserialize(byte[] buffer)
	{
		ClanActionResult instance = Pool.Get<ClanActionResult>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, instance, isDelta: false);
		return instance;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanActionResult previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanActionResult Deserialize(BufferStream stream, ClanActionResult instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.requestId = 0;
			instance.result = 0;
			instance.hasClanInfo = false;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.requestId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.result = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.hasClanInfo = ProtocolParser.ReadBool(stream);
				break;
			case 34:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static ClanActionResult DeserializeLengthDelimited(BufferStream stream, ClanActionResult instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.requestId = 0;
			instance.result = 0;
			instance.hasClanInfo = false;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.requestId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.result = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.hasClanInfo = ProtocolParser.ReadBool(stream);
				break;
			case 34:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanActionResult DeserializeLength(BufferStream stream, int length, ClanActionResult instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.requestId = 0;
			instance.result = 0;
			instance.hasClanInfo = false;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.requestId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.result = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 24:
				instance.hasClanInfo = ProtocolParser.ReadBool(stream);
				break;
			case 34:
				if (instance.clanInfo == null)
				{
					instance.clanInfo = ClanInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanInfo.DeserializeLengthDelimited(stream, instance.clanInfo, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanActionResult instance, ClanActionResult previous)
	{
		if (instance.requestId != previous.requestId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.requestId);
		}
		if (instance.result != previous.result)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.result);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.hasClanInfo);
		if (instance.clanInfo == null)
		{
			return;
		}
		stream.WriteByte(34);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ClanInfo.SerializeDelta(stream, instance.clanInfo, previous.clanInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, ClanActionResult instance)
	{
		if (instance.requestId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.requestId);
		}
		if (instance.result != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.result);
		}
		if (instance.hasClanInfo)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.hasClanInfo);
		}
		if (instance.clanInfo == null)
		{
			return;
		}
		stream.WriteByte(34);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ClanInfo.Serialize(stream, instance.clanInfo);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		clanInfo?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClanInfo : IDisposable, IPooled, IProto<ClanInfo>, IProto
{
	public class Role : IDisposable, IPooled, IProto<Role>, IProto
	{
		[NonSerialized]
		public int roleId;

		[NonSerialized]
		public int rank;

		[NonSerialized]
		public string name;

		[NonSerialized]
		public bool canSetMotd;

		[NonSerialized]
		public bool canSetLogo;

		[NonSerialized]
		public bool canInvite;

		[NonSerialized]
		public bool canKick;

		[NonSerialized]
		public bool canPromote;

		[NonSerialized]
		public bool canDemote;

		[NonSerialized]
		public bool canSetPlayerNotes;

		[NonSerialized]
		public bool canAccessLogs;

		[NonSerialized]
		public bool canAccessScoreEvents;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Role instance)
		{
			if (instance.ShouldPool)
			{
				instance.roleId = 0;
				instance.rank = 0;
				instance.name = string.Empty;
				instance.canSetMotd = false;
				instance.canSetLogo = false;
				instance.canInvite = false;
				instance.canKick = false;
				instance.canPromote = false;
				instance.canDemote = false;
				instance.canSetPlayerNotes = false;
				instance.canAccessLogs = false;
				instance.canAccessScoreEvents = false;
				Pool.Free<Role>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Role with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Role instance)
		{
			instance.roleId = roleId;
			instance.rank = rank;
			instance.name = name;
			instance.canSetMotd = canSetMotd;
			instance.canSetLogo = canSetLogo;
			instance.canInvite = canInvite;
			instance.canKick = canKick;
			instance.canPromote = canPromote;
			instance.canDemote = canDemote;
			instance.canSetPlayerNotes = canSetPlayerNotes;
			instance.canAccessLogs = canAccessLogs;
			instance.canAccessScoreEvents = canAccessScoreEvents;
		}

		public Role Copy()
		{
			Role role = Pool.Get<Role>();
			CopyTo(role);
			return role;
		}

		public static Role Deserialize(BufferStream stream)
		{
			Role role = Pool.Get<Role>();
			Deserialize(stream, role, isDelta: false);
			return role;
		}

		public static Role DeserializeLengthDelimited(BufferStream stream)
		{
			Role role = Pool.Get<Role>();
			DeserializeLengthDelimited(stream, role, isDelta: false);
			return role;
		}

		public static Role DeserializeLength(BufferStream stream, int length)
		{
			Role role = Pool.Get<Role>();
			DeserializeLength(stream, length, role, isDelta: false);
			return role;
		}

		public static Role Deserialize(byte[] buffer)
		{
			Role role = Pool.Get<Role>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, role, isDelta: false);
			return role;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Role previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Role Deserialize(BufferStream stream, Role instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.roleId = 0;
				instance.rank = 0;
				instance.canSetMotd = false;
				instance.canSetLogo = false;
				instance.canInvite = false;
				instance.canKick = false;
				instance.canPromote = false;
				instance.canDemote = false;
				instance.canSetPlayerNotes = false;
				instance.canAccessLogs = false;
				instance.canAccessScoreEvents = false;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.rank = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 32:
					instance.canSetMotd = ProtocolParser.ReadBool(stream);
					continue;
				case 40:
					instance.canSetLogo = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.canInvite = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.canKick = ProtocolParser.ReadBool(stream);
					continue;
				case 64:
					instance.canPromote = ProtocolParser.ReadBool(stream);
					continue;
				case 72:
					instance.canDemote = ProtocolParser.ReadBool(stream);
					continue;
				case 80:
					instance.canSetPlayerNotes = ProtocolParser.ReadBool(stream);
					continue;
				case 88:
					instance.canAccessLogs = ProtocolParser.ReadBool(stream);
					continue;
				case 96:
					instance.canAccessScoreEvents = ProtocolParser.ReadBool(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Role DeserializeLengthDelimited(BufferStream stream, Role instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.roleId = 0;
				instance.rank = 0;
				instance.canSetMotd = false;
				instance.canSetLogo = false;
				instance.canInvite = false;
				instance.canKick = false;
				instance.canPromote = false;
				instance.canDemote = false;
				instance.canSetPlayerNotes = false;
				instance.canAccessLogs = false;
				instance.canAccessScoreEvents = false;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.rank = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 32:
					instance.canSetMotd = ProtocolParser.ReadBool(stream);
					continue;
				case 40:
					instance.canSetLogo = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.canInvite = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.canKick = ProtocolParser.ReadBool(stream);
					continue;
				case 64:
					instance.canPromote = ProtocolParser.ReadBool(stream);
					continue;
				case 72:
					instance.canDemote = ProtocolParser.ReadBool(stream);
					continue;
				case 80:
					instance.canSetPlayerNotes = ProtocolParser.ReadBool(stream);
					continue;
				case 88:
					instance.canAccessLogs = ProtocolParser.ReadBool(stream);
					continue;
				case 96:
					instance.canAccessScoreEvents = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Role DeserializeLength(BufferStream stream, int length, Role instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.roleId = 0;
				instance.rank = 0;
				instance.canSetMotd = false;
				instance.canSetLogo = false;
				instance.canInvite = false;
				instance.canKick = false;
				instance.canPromote = false;
				instance.canDemote = false;
				instance.canSetPlayerNotes = false;
				instance.canAccessLogs = false;
				instance.canAccessScoreEvents = false;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.rank = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 32:
					instance.canSetMotd = ProtocolParser.ReadBool(stream);
					continue;
				case 40:
					instance.canSetLogo = ProtocolParser.ReadBool(stream);
					continue;
				case 48:
					instance.canInvite = ProtocolParser.ReadBool(stream);
					continue;
				case 56:
					instance.canKick = ProtocolParser.ReadBool(stream);
					continue;
				case 64:
					instance.canPromote = ProtocolParser.ReadBool(stream);
					continue;
				case 72:
					instance.canDemote = ProtocolParser.ReadBool(stream);
					continue;
				case 80:
					instance.canSetPlayerNotes = ProtocolParser.ReadBool(stream);
					continue;
				case 88:
					instance.canAccessLogs = ProtocolParser.ReadBool(stream);
					continue;
				case 96:
					instance.canAccessScoreEvents = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Role instance, Role previous)
		{
			if (instance.roleId != previous.roleId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
			}
			if (instance.rank != previous.rank)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.rank);
			}
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, instance.name);
			}
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.canSetMotd);
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.canSetLogo);
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.canInvite);
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.canKick);
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.canPromote);
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.canDemote);
			stream.WriteByte(80);
			ProtocolParser.WriteBool(stream, instance.canSetPlayerNotes);
			stream.WriteByte(88);
			ProtocolParser.WriteBool(stream, instance.canAccessLogs);
			stream.WriteByte(96);
			ProtocolParser.WriteBool(stream, instance.canAccessScoreEvents);
		}

		public static void Serialize(BufferStream stream, Role instance)
		{
			if (instance.roleId != 0)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
			}
			if (instance.rank != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.rank);
			}
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.canSetMotd)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteBool(stream, instance.canSetMotd);
			}
			if (instance.canSetLogo)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteBool(stream, instance.canSetLogo);
			}
			if (instance.canInvite)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteBool(stream, instance.canInvite);
			}
			if (instance.canKick)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteBool(stream, instance.canKick);
			}
			if (instance.canPromote)
			{
				stream.WriteByte(64);
				ProtocolParser.WriteBool(stream, instance.canPromote);
			}
			if (instance.canDemote)
			{
				stream.WriteByte(72);
				ProtocolParser.WriteBool(stream, instance.canDemote);
			}
			if (instance.canSetPlayerNotes)
			{
				stream.WriteByte(80);
				ProtocolParser.WriteBool(stream, instance.canSetPlayerNotes);
			}
			if (instance.canAccessLogs)
			{
				stream.WriteByte(88);
				ProtocolParser.WriteBool(stream, instance.canAccessLogs);
			}
			if (instance.canAccessScoreEvents)
			{
				stream.WriteByte(96);
				ProtocolParser.WriteBool(stream, instance.canAccessScoreEvents);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class Member : IDisposable, IPooled, IProto<Member>, IProto
	{
		[NonSerialized]
		public ulong steamId;

		[NonSerialized]
		public int roleId;

		[NonSerialized]
		public long joined;

		[NonSerialized]
		public long lastSeen;

		[NonSerialized]
		public string notes;

		[NonSerialized]
		public bool online;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Member instance)
		{
			if (instance.ShouldPool)
			{
				instance.steamId = 0uL;
				instance.roleId = 0;
				instance.joined = 0L;
				instance.lastSeen = 0L;
				instance.notes = string.Empty;
				instance.online = false;
				Pool.Free<Member>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Member with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Member instance)
		{
			instance.steamId = steamId;
			instance.roleId = roleId;
			instance.joined = joined;
			instance.lastSeen = lastSeen;
			instance.notes = notes;
			instance.online = online;
		}

		public Member Copy()
		{
			Member member = Pool.Get<Member>();
			CopyTo(member);
			return member;
		}

		public static Member Deserialize(BufferStream stream)
		{
			Member member = Pool.Get<Member>();
			Deserialize(stream, member, isDelta: false);
			return member;
		}

		public static Member DeserializeLengthDelimited(BufferStream stream)
		{
			Member member = Pool.Get<Member>();
			DeserializeLengthDelimited(stream, member, isDelta: false);
			return member;
		}

		public static Member DeserializeLength(BufferStream stream, int length)
		{
			Member member = Pool.Get<Member>();
			DeserializeLength(stream, length, member, isDelta: false);
			return member;
		}

		public static Member Deserialize(byte[] buffer)
		{
			Member member = Pool.Get<Member>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, member, isDelta: false);
			return member;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Member previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Member Deserialize(BufferStream stream, Member instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.roleId = 0;
				instance.joined = 0L;
				instance.lastSeen = 0L;
				instance.online = false;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.joined = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.lastSeen = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 42:
					instance.notes = ProtocolParser.ReadString(stream);
					continue;
				case 48:
					instance.online = ProtocolParser.ReadBool(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Member DeserializeLengthDelimited(BufferStream stream, Member instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.roleId = 0;
				instance.joined = 0L;
				instance.lastSeen = 0L;
				instance.online = false;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.joined = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.lastSeen = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 42:
					instance.notes = ProtocolParser.ReadString(stream);
					continue;
				case 48:
					instance.online = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Member DeserializeLength(BufferStream stream, int length, Member instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.roleId = 0;
				instance.joined = 0L;
				instance.lastSeen = 0L;
				instance.online = false;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.joined = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.lastSeen = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 42:
					instance.notes = ProtocolParser.ReadString(stream);
					continue;
				case 48:
					instance.online = ProtocolParser.ReadBool(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Member instance, Member previous)
		{
			if (instance.steamId != previous.steamId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.roleId != previous.roleId)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
			}
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.joined);
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastSeen);
			if (instance.notes != null && instance.notes != previous.notes)
			{
				stream.WriteByte(42);
				ProtocolParser.WriteString(stream, instance.notes);
			}
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.online);
		}

		public static void Serialize(BufferStream stream, Member instance)
		{
			if (instance.steamId != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.roleId != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
			}
			if (instance.joined != 0L)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.joined);
			}
			if (instance.lastSeen != 0L)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.lastSeen);
			}
			if (instance.notes != null)
			{
				stream.WriteByte(42);
				ProtocolParser.WriteString(stream, instance.notes);
			}
			if (instance.online)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteBool(stream, instance.online);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class Invite : IDisposable, IPooled, IProto<Invite>, IProto
	{
		[NonSerialized]
		public ulong steamId;

		[NonSerialized]
		public ulong recruiter;

		[NonSerialized]
		public long timestamp;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Invite instance)
		{
			if (instance.ShouldPool)
			{
				instance.steamId = 0uL;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
				Pool.Free<Invite>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Invite with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Invite instance)
		{
			instance.steamId = steamId;
			instance.recruiter = recruiter;
			instance.timestamp = timestamp;
		}

		public Invite Copy()
		{
			Invite invite = Pool.Get<Invite>();
			CopyTo(invite);
			return invite;
		}

		public static Invite Deserialize(BufferStream stream)
		{
			Invite invite = Pool.Get<Invite>();
			Deserialize(stream, invite, isDelta: false);
			return invite;
		}

		public static Invite DeserializeLengthDelimited(BufferStream stream)
		{
			Invite invite = Pool.Get<Invite>();
			DeserializeLengthDelimited(stream, invite, isDelta: false);
			return invite;
		}

		public static Invite DeserializeLength(BufferStream stream, int length)
		{
			Invite invite = Pool.Get<Invite>();
			DeserializeLength(stream, length, invite, isDelta: false);
			return invite;
		}

		public static Invite Deserialize(byte[] buffer)
		{
			Invite invite = Pool.Get<Invite>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, invite, isDelta: false);
			return invite;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Invite previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Invite Deserialize(BufferStream stream, Invite instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.recruiter = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Invite DeserializeLengthDelimited(BufferStream stream, Invite instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.recruiter = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Invite DeserializeLength(BufferStream stream, int length, Invite instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.steamId = 0uL;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.recruiter = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Invite instance, Invite previous)
		{
			if (instance.steamId != previous.steamId)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.recruiter != previous.recruiter)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.recruiter);
			}
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}

		public static void Serialize(BufferStream stream, Invite instance)
		{
			if (instance.steamId != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.recruiter != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.recruiter);
			}
			if (instance.timestamp != 0L)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public long created;

	[NonSerialized]
	public ulong creator;

	[NonSerialized]
	public string motd;

	[NonSerialized]
	public long motdTimestamp;

	[NonSerialized]
	public ulong motdAuthor;

	[NonSerialized]
	public byte[] logo;

	[NonSerialized]
	public int color;

	[NonSerialized]
	public List<Role> roles;

	[NonSerialized]
	public List<Member> members;

	[NonSerialized]
	public List<Invite> invites;

	[NonSerialized]
	public int maxMemberCount;

	[NonSerialized]
	public long score;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanInfo instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.clanId = 0L;
		instance.name = string.Empty;
		instance.created = 0L;
		instance.creator = 0uL;
		instance.motd = string.Empty;
		instance.motdTimestamp = 0L;
		instance.motdAuthor = 0uL;
		instance.logo = null;
		instance.color = 0;
		if (instance.roles != null)
		{
			for (int i = 0; i < instance.roles.Count; i++)
			{
				if (instance.roles[i] != null)
				{
					instance.roles[i].ResetToPool();
					instance.roles[i] = null;
				}
			}
			List<Role> list = instance.roles;
			Pool.Free<Role>(ref list, false);
			instance.roles = list;
		}
		if (instance.members != null)
		{
			for (int j = 0; j < instance.members.Count; j++)
			{
				if (instance.members[j] != null)
				{
					instance.members[j].ResetToPool();
					instance.members[j] = null;
				}
			}
			List<Member> list2 = instance.members;
			Pool.Free<Member>(ref list2, false);
			instance.members = list2;
		}
		if (instance.invites != null)
		{
			for (int k = 0; k < instance.invites.Count; k++)
			{
				if (instance.invites[k] != null)
				{
					instance.invites[k].ResetToPool();
					instance.invites[k] = null;
				}
			}
			List<Invite> list3 = instance.invites;
			Pool.Free<Invite>(ref list3, false);
			instance.invites = list3;
		}
		instance.maxMemberCount = 0;
		instance.score = 0L;
		Pool.Free<ClanInfo>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanInfo instance)
	{
		instance.clanId = clanId;
		instance.name = name;
		instance.created = created;
		instance.creator = creator;
		instance.motd = motd;
		instance.motdTimestamp = motdTimestamp;
		instance.motdAuthor = motdAuthor;
		if (logo == null)
		{
			instance.logo = null;
		}
		else
		{
			instance.logo = new byte[logo.Length];
			Array.Copy(logo, instance.logo, instance.logo.Length);
		}
		instance.color = color;
		if (roles != null)
		{
			instance.roles = Pool.Get<List<Role>>();
			for (int i = 0; i < roles.Count; i++)
			{
				Role item = roles[i].Copy();
				instance.roles.Add(item);
			}
		}
		else
		{
			instance.roles = null;
		}
		if (members != null)
		{
			instance.members = Pool.Get<List<Member>>();
			for (int j = 0; j < members.Count; j++)
			{
				Member item2 = members[j].Copy();
				instance.members.Add(item2);
			}
		}
		else
		{
			instance.members = null;
		}
		if (invites != null)
		{
			instance.invites = Pool.Get<List<Invite>>();
			for (int k = 0; k < invites.Count; k++)
			{
				Invite item3 = invites[k].Copy();
				instance.invites.Add(item3);
			}
		}
		else
		{
			instance.invites = null;
		}
		instance.maxMemberCount = maxMemberCount;
		instance.score = score;
	}

	public ClanInfo Copy()
	{
		ClanInfo clanInfo = Pool.Get<ClanInfo>();
		CopyTo(clanInfo);
		return clanInfo;
	}

	public static ClanInfo Deserialize(BufferStream stream)
	{
		ClanInfo clanInfo = Pool.Get<ClanInfo>();
		Deserialize(stream, clanInfo, isDelta: false);
		return clanInfo;
	}

	public static ClanInfo DeserializeLengthDelimited(BufferStream stream)
	{
		ClanInfo clanInfo = Pool.Get<ClanInfo>();
		DeserializeLengthDelimited(stream, clanInfo, isDelta: false);
		return clanInfo;
	}

	public static ClanInfo DeserializeLength(BufferStream stream, int length)
	{
		ClanInfo clanInfo = Pool.Get<ClanInfo>();
		DeserializeLength(stream, length, clanInfo, isDelta: false);
		return clanInfo;
	}

	public static ClanInfo Deserialize(byte[] buffer)
	{
		ClanInfo clanInfo = Pool.Get<ClanInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clanInfo, isDelta: false);
		return clanInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanInfo Deserialize(BufferStream stream, ClanInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.created = 0L;
			instance.creator = 0uL;
			instance.motdTimestamp = 0L;
			instance.motdAuthor = 0uL;
			instance.color = 0;
			if (instance.roles == null)
			{
				instance.roles = Pool.Get<List<Role>>();
			}
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<Member>>();
			}
			if (instance.invites == null)
			{
				instance.invites = Pool.Get<List<Invite>>();
			}
			instance.maxMemberCount = 0;
			instance.score = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.created = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.creator = ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.motd = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.motdTimestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.motdAuthor = ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.logo = ProtocolParser.ReadBytes(stream);
				continue;
			case 72:
				instance.color = ProtocolParser.ReadZInt32(stream);
				continue;
			case 82:
				instance.roles.Add(Role.DeserializeLengthDelimited(stream));
				continue;
			case 90:
				instance.members.Add(Member.DeserializeLengthDelimited(stream));
				continue;
			case 98:
				instance.invites.Add(Invite.DeserializeLengthDelimited(stream));
				continue;
			case 104:
				instance.maxMemberCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 112:
				instance.score = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClanInfo DeserializeLengthDelimited(BufferStream stream, ClanInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.created = 0L;
			instance.creator = 0uL;
			instance.motdTimestamp = 0L;
			instance.motdAuthor = 0uL;
			instance.color = 0;
			if (instance.roles == null)
			{
				instance.roles = Pool.Get<List<Role>>();
			}
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<Member>>();
			}
			if (instance.invites == null)
			{
				instance.invites = Pool.Get<List<Invite>>();
			}
			instance.maxMemberCount = 0;
			instance.score = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.created = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.creator = ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.motd = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.motdTimestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.motdAuthor = ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.logo = ProtocolParser.ReadBytes(stream);
				continue;
			case 72:
				instance.color = ProtocolParser.ReadZInt32(stream);
				continue;
			case 82:
				instance.roles.Add(Role.DeserializeLengthDelimited(stream));
				continue;
			case 90:
				instance.members.Add(Member.DeserializeLengthDelimited(stream));
				continue;
			case 98:
				instance.invites.Add(Invite.DeserializeLengthDelimited(stream));
				continue;
			case 104:
				instance.maxMemberCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 112:
				instance.score = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanInfo DeserializeLength(BufferStream stream, int length, ClanInfo instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.created = 0L;
			instance.creator = 0uL;
			instance.motdTimestamp = 0L;
			instance.motdAuthor = 0uL;
			instance.color = 0;
			if (instance.roles == null)
			{
				instance.roles = Pool.Get<List<Role>>();
			}
			if (instance.members == null)
			{
				instance.members = Pool.Get<List<Member>>();
			}
			if (instance.invites == null)
			{
				instance.invites = Pool.Get<List<Invite>>();
			}
			instance.maxMemberCount = 0;
			instance.score = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.created = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.creator = ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.motd = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.motdTimestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.motdAuthor = ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.logo = ProtocolParser.ReadBytes(stream);
				continue;
			case 72:
				instance.color = ProtocolParser.ReadZInt32(stream);
				continue;
			case 82:
				instance.roles.Add(Role.DeserializeLengthDelimited(stream));
				continue;
			case 90:
				instance.members.Add(Member.DeserializeLengthDelimited(stream));
				continue;
			case 98:
				instance.invites.Add(Invite.DeserializeLengthDelimited(stream));
				continue;
			case 104:
				instance.maxMemberCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 112:
				instance.score = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanInfo instance, ClanInfo previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.created);
		if (instance.creator != previous.creator)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.creator);
		}
		if (instance.motd != null && instance.motd != previous.motd)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.motd);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.motdTimestamp);
		if (instance.motdAuthor != previous.motdAuthor)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.motdAuthor);
		}
		if (instance.logo != null)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteBytes(stream, instance.logo);
		}
		stream.WriteByte(72);
		ProtocolParser.WriteZInt32(stream, instance.color);
		if (instance.roles != null)
		{
			for (int i = 0; i < instance.roles.Count; i++)
			{
				Role role = instance.roles[i];
				stream.WriteByte(82);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Role.SerializeDelta(stream, role, role);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.members != null)
		{
			for (int j = 0; j < instance.members.Count; j++)
			{
				Member member = instance.members[j];
				stream.WriteByte(90);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				Member.SerializeDelta(stream, member, member);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.invites != null)
		{
			for (int k = 0; k < instance.invites.Count; k++)
			{
				Invite invite = instance.invites[k];
				stream.WriteByte(98);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				Invite.SerializeDelta(stream, invite, invite);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field invites (ProtoBuf.ClanInfo.Invite)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
		}
		if (instance.maxMemberCount != previous.maxMemberCount)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxMemberCount);
		}
		stream.WriteByte(112);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
	}

	public static void Serialize(BufferStream stream, ClanInfo instance)
	{
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.created != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.created);
		}
		if (instance.creator != 0L)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.creator);
		}
		if (instance.motd != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.motd);
		}
		if (instance.motdTimestamp != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.motdTimestamp);
		}
		if (instance.motdAuthor != 0L)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.motdAuthor);
		}
		if (instance.logo != null)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteBytes(stream, instance.logo);
		}
		if (instance.color != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteZInt32(stream, instance.color);
		}
		if (instance.roles != null)
		{
			for (int i = 0; i < instance.roles.Count; i++)
			{
				Role instance2 = instance.roles[i];
				stream.WriteByte(82);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Role.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.members != null)
		{
			for (int j = 0; j < instance.members.Count; j++)
			{
				Member instance3 = instance.members[j];
				stream.WriteByte(90);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				Member.Serialize(stream, instance3);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.invites != null)
		{
			for (int k = 0; k < instance.invites.Count; k++)
			{
				Invite instance4 = instance.invites[k];
				stream.WriteByte(98);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				Invite.Serialize(stream, instance4);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field invites (ProtoBuf.ClanInfo.Invite)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
		}
		if (instance.maxMemberCount != 0)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxMemberCount);
		}
		if (instance.score != 0L)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (roles != null)
		{
			for (int i = 0; i < roles.Count; i++)
			{
				roles[i]?.InspectUids(action);
			}
		}
		if (members != null)
		{
			for (int j = 0; j < members.Count; j++)
			{
				members[j]?.InspectUids(action);
			}
		}
		if (invites != null)
		{
			for (int k = 0; k < invites.Count; k++)
			{
				invites[k]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClanLog : IDisposable, IPooled, IProto<ClanLog>, IProto
{
	public class Entry : IDisposable, IPooled, IProto<Entry>, IProto
	{
		[NonSerialized]
		public long timestamp;

		[NonSerialized]
		public string eventKey;

		[NonSerialized]
		public string arg1;

		[NonSerialized]
		public string arg2;

		[NonSerialized]
		public string arg3;

		[NonSerialized]
		public string arg4;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Entry instance)
		{
			if (instance.ShouldPool)
			{
				instance.timestamp = 0L;
				instance.eventKey = string.Empty;
				instance.arg1 = string.Empty;
				instance.arg2 = string.Empty;
				instance.arg3 = string.Empty;
				instance.arg4 = string.Empty;
				Pool.Free<Entry>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Entry with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Entry instance)
		{
			instance.timestamp = timestamp;
			instance.eventKey = eventKey;
			instance.arg1 = arg1;
			instance.arg2 = arg2;
			instance.arg3 = arg3;
			instance.arg4 = arg4;
		}

		public Entry Copy()
		{
			Entry entry = Pool.Get<Entry>();
			CopyTo(entry);
			return entry;
		}

		public static Entry Deserialize(BufferStream stream)
		{
			Entry entry = Pool.Get<Entry>();
			Deserialize(stream, entry, isDelta: false);
			return entry;
		}

		public static Entry DeserializeLengthDelimited(BufferStream stream)
		{
			Entry entry = Pool.Get<Entry>();
			DeserializeLengthDelimited(stream, entry, isDelta: false);
			return entry;
		}

		public static Entry DeserializeLength(BufferStream stream, int length)
		{
			Entry entry = Pool.Get<Entry>();
			DeserializeLength(stream, length, entry, isDelta: false);
			return entry;
		}

		public static Entry Deserialize(byte[] buffer)
		{
			Entry entry = Pool.Get<Entry>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, entry, isDelta: false);
			return entry;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Entry previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Entry Deserialize(BufferStream stream, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.timestamp = 0L;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.eventKey = ProtocolParser.ReadString(stream);
					continue;
				case 26:
					instance.arg1 = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.arg2 = ProtocolParser.ReadString(stream);
					continue;
				case 42:
					instance.arg3 = ProtocolParser.ReadString(stream);
					continue;
				case 50:
					instance.arg4 = ProtocolParser.ReadString(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Entry DeserializeLengthDelimited(BufferStream stream, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.timestamp = 0L;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.eventKey = ProtocolParser.ReadString(stream);
					continue;
				case 26:
					instance.arg1 = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.arg2 = ProtocolParser.ReadString(stream);
					continue;
				case 42:
					instance.arg3 = ProtocolParser.ReadString(stream);
					continue;
				case 50:
					instance.arg4 = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Entry DeserializeLength(BufferStream stream, int length, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.timestamp = 0L;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.eventKey = ProtocolParser.ReadString(stream);
					continue;
				case 26:
					instance.arg1 = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.arg2 = ProtocolParser.ReadString(stream);
					continue;
				case 42:
					instance.arg3 = ProtocolParser.ReadString(stream);
					continue;
				case 50:
					instance.arg4 = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Entry instance, Entry previous)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
			if (instance.eventKey != previous.eventKey)
			{
				if (instance.eventKey == null)
				{
					throw new ArgumentNullException("eventKey", "Required by proto specification.");
				}
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.eventKey);
			}
			if (instance.arg1 != null && instance.arg1 != previous.arg1)
			{
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, instance.arg1);
			}
			if (instance.arg2 != null && instance.arg2 != previous.arg2)
			{
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, instance.arg2);
			}
			if (instance.arg3 != null && instance.arg3 != previous.arg3)
			{
				stream.WriteByte(42);
				ProtocolParser.WriteString(stream, instance.arg3);
			}
			if (instance.arg4 != null && instance.arg4 != previous.arg4)
			{
				stream.WriteByte(50);
				ProtocolParser.WriteString(stream, instance.arg4);
			}
		}

		public static void Serialize(BufferStream stream, Entry instance)
		{
			if (instance.timestamp != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
			}
			if (instance.eventKey == null)
			{
				throw new ArgumentNullException("eventKey", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.eventKey);
			if (instance.arg1 != null)
			{
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, instance.arg1);
			}
			if (instance.arg2 != null)
			{
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, instance.arg2);
			}
			if (instance.arg3 != null)
			{
				stream.WriteByte(42);
				ProtocolParser.WriteString(stream, instance.arg3);
			}
			if (instance.arg4 != null)
			{
				stream.WriteByte(50);
				ProtocolParser.WriteString(stream, instance.arg4);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public List<Entry> logEntries;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanLog instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.clanId = 0L;
		if (instance.logEntries != null)
		{
			for (int i = 0; i < instance.logEntries.Count; i++)
			{
				if (instance.logEntries[i] != null)
				{
					instance.logEntries[i].ResetToPool();
					instance.logEntries[i] = null;
				}
			}
			List<Entry> list = instance.logEntries;
			Pool.Free<Entry>(ref list, false);
			instance.logEntries = list;
		}
		Pool.Free<ClanLog>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanLog with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanLog instance)
	{
		instance.clanId = clanId;
		if (logEntries != null)
		{
			instance.logEntries = Pool.Get<List<Entry>>();
			for (int i = 0; i < logEntries.Count; i++)
			{
				Entry item = logEntries[i].Copy();
				instance.logEntries.Add(item);
			}
		}
		else
		{
			instance.logEntries = null;
		}
	}

	public ClanLog Copy()
	{
		ClanLog clanLog = Pool.Get<ClanLog>();
		CopyTo(clanLog);
		return clanLog;
	}

	public static ClanLog Deserialize(BufferStream stream)
	{
		ClanLog clanLog = Pool.Get<ClanLog>();
		Deserialize(stream, clanLog, isDelta: false);
		return clanLog;
	}

	public static ClanLog DeserializeLengthDelimited(BufferStream stream)
	{
		ClanLog clanLog = Pool.Get<ClanLog>();
		DeserializeLengthDelimited(stream, clanLog, isDelta: false);
		return clanLog;
	}

	public static ClanLog DeserializeLength(BufferStream stream, int length)
	{
		ClanLog clanLog = Pool.Get<ClanLog>();
		DeserializeLength(stream, length, clanLog, isDelta: false);
		return clanLog;
	}

	public static ClanLog Deserialize(byte[] buffer)
	{
		ClanLog clanLog = Pool.Get<ClanLog>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clanLog, isDelta: false);
		return clanLog;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanLog previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanLog Deserialize(BufferStream stream, ClanLog instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			if (instance.logEntries == null)
			{
				instance.logEntries = Pool.Get<List<Entry>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.logEntries.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClanLog DeserializeLengthDelimited(BufferStream stream, ClanLog instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			if (instance.logEntries == null)
			{
				instance.logEntries = Pool.Get<List<Entry>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.logEntries.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanLog DeserializeLength(BufferStream stream, int length, ClanLog instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			if (instance.logEntries == null)
			{
				instance.logEntries = Pool.Get<List<Entry>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.logEntries.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanLog instance, ClanLog previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.logEntries == null)
		{
			return;
		}
		for (int i = 0; i < instance.logEntries.Count; i++)
		{
			Entry entry = instance.logEntries[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entry.SerializeDelta(stream, entry, entry);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ClanLog instance)
	{
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.logEntries == null)
		{
			return;
		}
		for (int i = 0; i < instance.logEntries.Count; i++)
		{
			Entry instance2 = instance.logEntries[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entry.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (logEntries != null)
		{
			for (int i = 0; i < logEntries.Count; i++)
			{
				logEntries[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClanScoreEvents : IDisposable, IPooled, IProto<ClanScoreEvents>, IProto
{
	public class Entry : IDisposable, IPooled, IProto<Entry>, IProto
	{
		[NonSerialized]
		public long timestamp;

		[NonSerialized]
		public int type;

		[NonSerialized]
		public int score;

		[NonSerialized]
		public int multiplier;

		[NonSerialized]
		public ulong steamId;

		[NonSerialized]
		public ulong otherSteamId;

		[NonSerialized]
		public long otherClanId;

		[NonSerialized]
		public string arg1;

		[NonSerialized]
		public string arg2;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Entry instance)
		{
			if (instance.ShouldPool)
			{
				instance.timestamp = 0L;
				instance.type = 0;
				instance.score = 0;
				instance.multiplier = 0;
				instance.steamId = 0uL;
				instance.otherSteamId = 0uL;
				instance.otherClanId = 0L;
				instance.arg1 = string.Empty;
				instance.arg2 = string.Empty;
				Pool.Free<Entry>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Entry with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Entry instance)
		{
			instance.timestamp = timestamp;
			instance.type = type;
			instance.score = score;
			instance.multiplier = multiplier;
			instance.steamId = steamId;
			instance.otherSteamId = otherSteamId;
			instance.otherClanId = otherClanId;
			instance.arg1 = arg1;
			instance.arg2 = arg2;
		}

		public Entry Copy()
		{
			Entry entry = Pool.Get<Entry>();
			CopyTo(entry);
			return entry;
		}

		public static Entry Deserialize(BufferStream stream)
		{
			Entry entry = Pool.Get<Entry>();
			Deserialize(stream, entry, isDelta: false);
			return entry;
		}

		public static Entry DeserializeLengthDelimited(BufferStream stream)
		{
			Entry entry = Pool.Get<Entry>();
			DeserializeLengthDelimited(stream, entry, isDelta: false);
			return entry;
		}

		public static Entry DeserializeLength(BufferStream stream, int length)
		{
			Entry entry = Pool.Get<Entry>();
			DeserializeLength(stream, length, entry, isDelta: false);
			return entry;
		}

		public static Entry Deserialize(byte[] buffer)
		{
			Entry entry = Pool.Get<Entry>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, entry, isDelta: false);
			return entry;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Entry previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Entry Deserialize(BufferStream stream, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.timestamp = 0L;
				instance.type = 0;
				instance.score = 0;
				instance.multiplier = 0;
				instance.steamId = 0uL;
				instance.otherSteamId = 0uL;
				instance.otherClanId = 0L;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.otherSteamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.otherClanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 66:
					instance.arg1 = ProtocolParser.ReadString(stream);
					continue;
				case 74:
					instance.arg2 = ProtocolParser.ReadString(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Entry DeserializeLengthDelimited(BufferStream stream, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.timestamp = 0L;
				instance.type = 0;
				instance.score = 0;
				instance.multiplier = 0;
				instance.steamId = 0uL;
				instance.otherSteamId = 0uL;
				instance.otherClanId = 0L;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.otherSteamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.otherClanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 66:
					instance.arg1 = ProtocolParser.ReadString(stream);
					continue;
				case 74:
					instance.arg2 = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Entry DeserializeLength(BufferStream stream, int length, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.timestamp = 0L;
				instance.type = 0;
				instance.score = 0;
				instance.multiplier = 0;
				instance.steamId = 0uL;
				instance.otherSteamId = 0uL;
				instance.otherClanId = 0L;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.type = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.score = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 32:
					instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 40:
					instance.steamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 48:
					instance.otherSteamId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 56:
					instance.otherClanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 66:
					instance.arg1 = ProtocolParser.ReadString(stream);
					continue;
				case 74:
					instance.arg2 = ProtocolParser.ReadString(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Entry instance, Entry previous)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
			if (instance.type != previous.type)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.score != previous.score)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
			}
			if (instance.multiplier != previous.multiplier)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.multiplier);
			}
			if (instance.steamId != previous.steamId)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.otherSteamId != previous.otherSteamId)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, instance.otherSteamId);
			}
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.otherClanId);
			if (instance.arg1 != null && instance.arg1 != previous.arg1)
			{
				stream.WriteByte(66);
				ProtocolParser.WriteString(stream, instance.arg1);
			}
			if (instance.arg2 != null && instance.arg2 != previous.arg2)
			{
				stream.WriteByte(74);
				ProtocolParser.WriteString(stream, instance.arg2);
			}
		}

		public static void Serialize(BufferStream stream, Entry instance)
		{
			if (instance.timestamp != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
			}
			if (instance.type != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
			}
			if (instance.score != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
			}
			if (instance.multiplier != 0)
			{
				stream.WriteByte(32);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.multiplier);
			}
			if (instance.steamId != 0L)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, instance.steamId);
			}
			if (instance.otherSteamId != 0L)
			{
				stream.WriteByte(48);
				ProtocolParser.WriteUInt64(stream, instance.otherSteamId);
			}
			if (instance.otherClanId != 0L)
			{
				stream.WriteByte(56);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.otherClanId);
			}
			if (instance.arg1 != null)
			{
				stream.WriteByte(66);
				ProtocolParser.WriteString(stream, instance.arg1);
			}
			if (instance.arg2 != null)
			{
				stream.WriteByte(74);
				ProtocolParser.WriteString(stream, instance.arg2);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public List<Entry> scoreEvents;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanScoreEvents instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.clanId = 0L;
		if (instance.scoreEvents != null)
		{
			for (int i = 0; i < instance.scoreEvents.Count; i++)
			{
				if (instance.scoreEvents[i] != null)
				{
					instance.scoreEvents[i].ResetToPool();
					instance.scoreEvents[i] = null;
				}
			}
			List<Entry> list = instance.scoreEvents;
			Pool.Free<Entry>(ref list, false);
			instance.scoreEvents = list;
		}
		Pool.Free<ClanScoreEvents>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanScoreEvents with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanScoreEvents instance)
	{
		instance.clanId = clanId;
		if (scoreEvents != null)
		{
			instance.scoreEvents = Pool.Get<List<Entry>>();
			for (int i = 0; i < scoreEvents.Count; i++)
			{
				Entry item = scoreEvents[i].Copy();
				instance.scoreEvents.Add(item);
			}
		}
		else
		{
			instance.scoreEvents = null;
		}
	}

	public ClanScoreEvents Copy()
	{
		ClanScoreEvents clanScoreEvents = Pool.Get<ClanScoreEvents>();
		CopyTo(clanScoreEvents);
		return clanScoreEvents;
	}

	public static ClanScoreEvents Deserialize(BufferStream stream)
	{
		ClanScoreEvents clanScoreEvents = Pool.Get<ClanScoreEvents>();
		Deserialize(stream, clanScoreEvents, isDelta: false);
		return clanScoreEvents;
	}

	public static ClanScoreEvents DeserializeLengthDelimited(BufferStream stream)
	{
		ClanScoreEvents clanScoreEvents = Pool.Get<ClanScoreEvents>();
		DeserializeLengthDelimited(stream, clanScoreEvents, isDelta: false);
		return clanScoreEvents;
	}

	public static ClanScoreEvents DeserializeLength(BufferStream stream, int length)
	{
		ClanScoreEvents clanScoreEvents = Pool.Get<ClanScoreEvents>();
		DeserializeLength(stream, length, clanScoreEvents, isDelta: false);
		return clanScoreEvents;
	}

	public static ClanScoreEvents Deserialize(byte[] buffer)
	{
		ClanScoreEvents clanScoreEvents = Pool.Get<ClanScoreEvents>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clanScoreEvents, isDelta: false);
		return clanScoreEvents;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanScoreEvents previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanScoreEvents Deserialize(BufferStream stream, ClanScoreEvents instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			if (instance.scoreEvents == null)
			{
				instance.scoreEvents = Pool.Get<List<Entry>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.scoreEvents.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClanScoreEvents DeserializeLengthDelimited(BufferStream stream, ClanScoreEvents instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			if (instance.scoreEvents == null)
			{
				instance.scoreEvents = Pool.Get<List<Entry>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.scoreEvents.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanScoreEvents DeserializeLength(BufferStream stream, int length, ClanScoreEvents instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			if (instance.scoreEvents == null)
			{
				instance.scoreEvents = Pool.Get<List<Entry>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.scoreEvents.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanScoreEvents instance, ClanScoreEvents previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.scoreEvents == null)
		{
			return;
		}
		for (int i = 0; i < instance.scoreEvents.Count; i++)
		{
			Entry entry = instance.scoreEvents[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entry.SerializeDelta(stream, entry, entry);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ClanScoreEvents instance)
	{
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.scoreEvents == null)
		{
			return;
		}
		for (int i = 0; i < instance.scoreEvents.Count; i++)
		{
			Entry instance2 = instance.scoreEvents[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entry.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (scoreEvents != null)
		{
			for (int i = 0; i < scoreEvents.Count; i++)
			{
				scoreEvents[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClanInvitations : IDisposable, IPooled, IProto<ClanInvitations>, IProto
{
	public class Invitation : IDisposable, IPooled, IProto<Invitation>, IProto
	{
		[NonSerialized]
		public long clanId;

		[NonSerialized]
		public ulong recruiter;

		[NonSerialized]
		public long timestamp;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Invitation instance)
		{
			if (instance.ShouldPool)
			{
				instance.clanId = 0L;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
				Pool.Free<Invitation>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Invitation with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Invitation instance)
		{
			instance.clanId = clanId;
			instance.recruiter = recruiter;
			instance.timestamp = timestamp;
		}

		public Invitation Copy()
		{
			Invitation invitation = Pool.Get<Invitation>();
			CopyTo(invitation);
			return invitation;
		}

		public static Invitation Deserialize(BufferStream stream)
		{
			Invitation invitation = Pool.Get<Invitation>();
			Deserialize(stream, invitation, isDelta: false);
			return invitation;
		}

		public static Invitation DeserializeLengthDelimited(BufferStream stream)
		{
			Invitation invitation = Pool.Get<Invitation>();
			DeserializeLengthDelimited(stream, invitation, isDelta: false);
			return invitation;
		}

		public static Invitation DeserializeLength(BufferStream stream, int length)
		{
			Invitation invitation = Pool.Get<Invitation>();
			DeserializeLength(stream, length, invitation, isDelta: false);
			return invitation;
		}

		public static Invitation Deserialize(byte[] buffer)
		{
			Invitation invitation = Pool.Get<Invitation>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, invitation, isDelta: false);
			return invitation;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Invitation previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Invitation Deserialize(BufferStream stream, Invitation instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.clanId = 0L;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.recruiter = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Invitation DeserializeLengthDelimited(BufferStream stream, Invitation instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.clanId = 0L;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.recruiter = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Invitation DeserializeLength(BufferStream stream, int length, Invitation instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.clanId = 0L;
				instance.recruiter = 0uL;
				instance.timestamp = 0L;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.recruiter = ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Invitation instance, Invitation previous)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
			if (instance.recruiter != previous.recruiter)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.recruiter);
			}
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}

		public static void Serialize(BufferStream stream, Invitation instance)
		{
			if (instance.clanId != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
			}
			if (instance.recruiter != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.recruiter);
			}
			if (instance.timestamp != 0L)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<Invitation> invitations;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanInvitations instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.invitations != null)
		{
			for (int i = 0; i < instance.invitations.Count; i++)
			{
				if (instance.invitations[i] != null)
				{
					instance.invitations[i].ResetToPool();
					instance.invitations[i] = null;
				}
			}
			List<Invitation> list = instance.invitations;
			Pool.Free<Invitation>(ref list, false);
			instance.invitations = list;
		}
		Pool.Free<ClanInvitations>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanInvitations with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanInvitations instance)
	{
		if (invitations != null)
		{
			instance.invitations = Pool.Get<List<Invitation>>();
			for (int i = 0; i < invitations.Count; i++)
			{
				Invitation item = invitations[i].Copy();
				instance.invitations.Add(item);
			}
		}
		else
		{
			instance.invitations = null;
		}
	}

	public ClanInvitations Copy()
	{
		ClanInvitations clanInvitations = Pool.Get<ClanInvitations>();
		CopyTo(clanInvitations);
		return clanInvitations;
	}

	public static ClanInvitations Deserialize(BufferStream stream)
	{
		ClanInvitations clanInvitations = Pool.Get<ClanInvitations>();
		Deserialize(stream, clanInvitations, isDelta: false);
		return clanInvitations;
	}

	public static ClanInvitations DeserializeLengthDelimited(BufferStream stream)
	{
		ClanInvitations clanInvitations = Pool.Get<ClanInvitations>();
		DeserializeLengthDelimited(stream, clanInvitations, isDelta: false);
		return clanInvitations;
	}

	public static ClanInvitations DeserializeLength(BufferStream stream, int length)
	{
		ClanInvitations clanInvitations = Pool.Get<ClanInvitations>();
		DeserializeLength(stream, length, clanInvitations, isDelta: false);
		return clanInvitations;
	}

	public static ClanInvitations Deserialize(byte[] buffer)
	{
		ClanInvitations clanInvitations = Pool.Get<ClanInvitations>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clanInvitations, isDelta: false);
		return clanInvitations;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanInvitations previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanInvitations Deserialize(BufferStream stream, ClanInvitations instance, bool isDelta)
	{
		if (!isDelta && instance.invitations == null)
		{
			instance.invitations = Pool.Get<List<Invitation>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.invitations.Add(Invitation.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClanInvitations DeserializeLengthDelimited(BufferStream stream, ClanInvitations instance, bool isDelta)
	{
		if (!isDelta && instance.invitations == null)
		{
			instance.invitations = Pool.Get<List<Invitation>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.invitations.Add(Invitation.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanInvitations DeserializeLength(BufferStream stream, int length, ClanInvitations instance, bool isDelta)
	{
		if (!isDelta && instance.invitations == null)
		{
			instance.invitations = Pool.Get<List<Invitation>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.invitations.Add(Invitation.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanInvitations instance, ClanInvitations previous)
	{
		if (instance.invitations == null)
		{
			return;
		}
		for (int i = 0; i < instance.invitations.Count; i++)
		{
			Invitation invitation = instance.invitations[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Invitation.SerializeDelta(stream, invitation, invitation);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field invitations (ProtoBuf.ClanInvitations.Invitation)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public static void Serialize(BufferStream stream, ClanInvitations instance)
	{
		if (instance.invitations == null)
		{
			return;
		}
		for (int i = 0; i < instance.invitations.Count; i++)
		{
			Invitation instance2 = instance.invitations[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Invitation.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field invitations (ProtoBuf.ClanInvitations.Invitation)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (invitations != null)
		{
			for (int i = 0; i < invitations.Count; i++)
			{
				invitations[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class ClanLeaderboard : IDisposable, IPooled, IProto<ClanLeaderboard>, IProto
{
	public class Entry : IDisposable, IPooled, IProto<Entry>, IProto
	{
		[NonSerialized]
		public long clanId;

		[NonSerialized]
		public string name;

		[NonSerialized]
		public long score;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Entry instance)
		{
			if (instance.ShouldPool)
			{
				instance.clanId = 0L;
				instance.name = string.Empty;
				instance.score = 0L;
				Pool.Free<Entry>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Entry with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Entry instance)
		{
			instance.clanId = clanId;
			instance.name = name;
			instance.score = score;
		}

		public Entry Copy()
		{
			Entry entry = Pool.Get<Entry>();
			CopyTo(entry);
			return entry;
		}

		public static Entry Deserialize(BufferStream stream)
		{
			Entry entry = Pool.Get<Entry>();
			Deserialize(stream, entry, isDelta: false);
			return entry;
		}

		public static Entry DeserializeLengthDelimited(BufferStream stream)
		{
			Entry entry = Pool.Get<Entry>();
			DeserializeLengthDelimited(stream, entry, isDelta: false);
			return entry;
		}

		public static Entry DeserializeLength(BufferStream stream, int length)
		{
			Entry entry = Pool.Get<Entry>();
			DeserializeLength(stream, length, entry, isDelta: false);
			return entry;
		}

		public static Entry Deserialize(byte[] buffer)
		{
			Entry entry = Pool.Get<Entry>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, entry, isDelta: false);
			return entry;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Entry previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Entry Deserialize(BufferStream stream, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.clanId = 0L;
				instance.score = 0L;
			}
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.score = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Entry DeserializeLengthDelimited(BufferStream stream, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.clanId = 0L;
				instance.score = 0L;
			}
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.score = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Entry DeserializeLength(BufferStream stream, int length, Entry instance, bool isDelta)
		{
			if (!isDelta)
			{
				instance.clanId = 0L;
				instance.score = 0L;
			}
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 18:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 24:
					instance.score = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Entry instance, Entry previous)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.name);
			}
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}

		public static void Serialize(BufferStream stream, Entry instance)
		{
			if (instance.clanId != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
			}
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.score != 0L)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<Entry> entries;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanLeaderboard instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.entries != null)
		{
			for (int i = 0; i < instance.entries.Count; i++)
			{
				if (instance.entries[i] != null)
				{
					instance.entries[i].ResetToPool();
					instance.entries[i] = null;
				}
			}
			List<Entry> list = instance.entries;
			Pool.Free<Entry>(ref list, false);
			instance.entries = list;
		}
		Pool.Free<ClanLeaderboard>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanLeaderboard with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanLeaderboard instance)
	{
		if (entries != null)
		{
			instance.entries = Pool.Get<List<Entry>>();
			for (int i = 0; i < entries.Count; i++)
			{
				Entry item = entries[i].Copy();
				instance.entries.Add(item);
			}
		}
		else
		{
			instance.entries = null;
		}
	}

	public ClanLeaderboard Copy()
	{
		ClanLeaderboard clanLeaderboard = Pool.Get<ClanLeaderboard>();
		CopyTo(clanLeaderboard);
		return clanLeaderboard;
	}

	public static ClanLeaderboard Deserialize(BufferStream stream)
	{
		ClanLeaderboard clanLeaderboard = Pool.Get<ClanLeaderboard>();
		Deserialize(stream, clanLeaderboard, isDelta: false);
		return clanLeaderboard;
	}

	public static ClanLeaderboard DeserializeLengthDelimited(BufferStream stream)
	{
		ClanLeaderboard clanLeaderboard = Pool.Get<ClanLeaderboard>();
		DeserializeLengthDelimited(stream, clanLeaderboard, isDelta: false);
		return clanLeaderboard;
	}

	public static ClanLeaderboard DeserializeLength(BufferStream stream, int length)
	{
		ClanLeaderboard clanLeaderboard = Pool.Get<ClanLeaderboard>();
		DeserializeLength(stream, length, clanLeaderboard, isDelta: false);
		return clanLeaderboard;
	}

	public static ClanLeaderboard Deserialize(byte[] buffer)
	{
		ClanLeaderboard clanLeaderboard = Pool.Get<ClanLeaderboard>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clanLeaderboard, isDelta: false);
		return clanLeaderboard;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanLeaderboard previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanLeaderboard Deserialize(BufferStream stream, ClanLeaderboard instance, bool isDelta)
	{
		if (!isDelta && instance.entries == null)
		{
			instance.entries = Pool.Get<List<Entry>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.entries.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClanLeaderboard DeserializeLengthDelimited(BufferStream stream, ClanLeaderboard instance, bool isDelta)
	{
		if (!isDelta && instance.entries == null)
		{
			instance.entries = Pool.Get<List<Entry>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entries.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanLeaderboard DeserializeLength(BufferStream stream, int length, ClanLeaderboard instance, bool isDelta)
	{
		if (!isDelta && instance.entries == null)
		{
			instance.entries = Pool.Get<List<Entry>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.entries.Add(Entry.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanLeaderboard instance, ClanLeaderboard previous)
	{
		if (instance.entries == null)
		{
			return;
		}
		for (int i = 0; i < instance.entries.Count; i++)
		{
			Entry entry = instance.entries[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entry.SerializeDelta(stream, entry, entry);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ClanLeaderboard instance)
	{
		if (instance.entries == null)
		{
			return;
		}
		for (int i = 0; i < instance.entries.Count; i++)
		{
			Entry instance2 = instance.entries[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Entry.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (entries != null)
		{
			for (int i = 0; i < entries.Count; i++)
			{
				entries[i]?.InspectUids(action);
			}
		}
	}
}


public enum AppEntityType
{
	Switch = 1,
	Alarm,
	StorageMonitor
}


public enum AppMarkerType
{
	Undefined,
	Player,
	Explosion,
	VendingMachine,
	CH47,
	CargoShip,
	Crate,
	GenericRadius,
	PatrolHelicopter,
	TravellingVendor
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class Packet : IDisposable, IPooled, IProto<Packet>, IProto
{
	[NonSerialized]
	public uint protocol;

	[NonSerialized]
	public int sourceZone;

	[NonSerialized]
	public Request request;

	[NonSerialized]
	public Response response;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Packet instance)
	{
		if (instance.ShouldPool)
		{
			instance.protocol = 0u;
			instance.sourceZone = 0;
			if (instance.request != null)
			{
				instance.request.ResetToPool();
				instance.request = null;
			}
			if (instance.response != null)
			{
				instance.response.ResetToPool();
				instance.response = null;
			}
			Pool.Free<Packet>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Packet with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Packet instance)
	{
		instance.protocol = protocol;
		instance.sourceZone = sourceZone;
		if (request != null)
		{
			if (instance.request == null)
			{
				instance.request = request.Copy();
			}
			else
			{
				request.CopyTo(instance.request);
			}
		}
		else
		{
			instance.request = null;
		}
		if (response != null)
		{
			if (instance.response == null)
			{
				instance.response = response.Copy();
			}
			else
			{
				response.CopyTo(instance.response);
			}
		}
		else
		{
			instance.response = null;
		}
	}

	public Packet Copy()
	{
		Packet packet = Pool.Get<Packet>();
		CopyTo(packet);
		return packet;
	}

	public static Packet Deserialize(BufferStream stream)
	{
		Packet packet = Pool.Get<Packet>();
		Deserialize(stream, packet, isDelta: false);
		return packet;
	}

	public static Packet DeserializeLengthDelimited(BufferStream stream)
	{
		Packet packet = Pool.Get<Packet>();
		DeserializeLengthDelimited(stream, packet, isDelta: false);
		return packet;
	}

	public static Packet DeserializeLength(BufferStream stream, int length)
	{
		Packet packet = Pool.Get<Packet>();
		DeserializeLength(stream, length, packet, isDelta: false);
		return packet;
	}

	public static Packet Deserialize(byte[] buffer)
	{
		Packet packet = Pool.Get<Packet>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, packet, isDelta: false);
		return packet;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Packet previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Packet Deserialize(BufferStream stream, Packet instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.protocol = ProtocolParser.ReadUInt32(stream);
				break;
			case 16:
				instance.sourceZone = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 26:
				if (instance.request == null)
				{
					instance.request = Request.DeserializeLengthDelimited(stream);
				}
				else
				{
					Request.DeserializeLengthDelimited(stream, instance.request, isDelta);
				}
				break;
			case 34:
				if (instance.response == null)
				{
					instance.response = Response.DeserializeLengthDelimited(stream);
				}
				else
				{
					Response.DeserializeLengthDelimited(stream, instance.response, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static Packet DeserializeLengthDelimited(BufferStream stream, Packet instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.protocol = ProtocolParser.ReadUInt32(stream);
				break;
			case 16:
				instance.sourceZone = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 26:
				if (instance.request == null)
				{
					instance.request = Request.DeserializeLengthDelimited(stream);
				}
				else
				{
					Request.DeserializeLengthDelimited(stream, instance.request, isDelta);
				}
				break;
			case 34:
				if (instance.response == null)
				{
					instance.response = Response.DeserializeLengthDelimited(stream);
				}
				else
				{
					Response.DeserializeLengthDelimited(stream, instance.response, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Packet DeserializeLength(BufferStream stream, int length, Packet instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.protocol = ProtocolParser.ReadUInt32(stream);
				break;
			case 16:
				instance.sourceZone = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 26:
				if (instance.request == null)
				{
					instance.request = Request.DeserializeLengthDelimited(stream);
				}
				else
				{
					Request.DeserializeLengthDelimited(stream, instance.request, isDelta);
				}
				break;
			case 34:
				if (instance.response == null)
				{
					instance.response = Response.DeserializeLengthDelimited(stream);
				}
				else
				{
					Response.DeserializeLengthDelimited(stream, instance.response, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Packet instance, Packet previous)
	{
		if (instance.protocol != previous.protocol)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.protocol);
		}
		if (instance.sourceZone != previous.sourceZone)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.sourceZone);
		}
		if (instance.request != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Request.SerializeDelta(stream, instance.request, previous.request);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.response == null)
		{
			return;
		}
		stream.WriteByte(34);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		Response.SerializeDelta(stream, instance.response, previous.response);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, Packet instance)
	{
		if (instance.protocol != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.protocol);
		}
		if (instance.sourceZone != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.sourceZone);
		}
		if (instance.request != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Request.Serialize(stream, instance.request);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.response == null)
		{
			return;
		}
		stream.WriteByte(34);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		Response.Serialize(stream, instance.response);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		request?.InspectUids(action);
		response?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class Request : IDisposable, IPooled, IProto<Request>, IProto
{
	[NonSerialized]
	public bool isFireAndForget;

	[NonSerialized]
	public TransferRequest transfer;

	[NonSerialized]
	public PingRequest ping;

	[NonSerialized]
	public SpawnOptionsRequest spawnOptions;

	[NonSerialized]
	public SleepingBagRespawnRequest respawnAtBag;

	[NonSerialized]
	public SleepingBagDestroyRequest destroyBag;

	[NonSerialized]
	public FerryStatusRequest ferryStatus;

	[NonSerialized]
	public FerryRetireRequest ferryRetire;

	[NonSerialized]
	public FerryUpdateScheduleRequest ferryUpdateSchedule;

	[NonSerialized]
	public ClanChatBatchRequest clanChatBatch;

	[NonSerialized]
	public PlayerManifestRequest playerManifest;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Request instance)
	{
		if (instance.ShouldPool)
		{
			instance.isFireAndForget = false;
			if (instance.transfer != null)
			{
				instance.transfer.ResetToPool();
				instance.transfer = null;
			}
			if (instance.ping != null)
			{
				instance.ping.ResetToPool();
				instance.ping = null;
			}
			if (instance.spawnOptions != null)
			{
				instance.spawnOptions.ResetToPool();
				instance.spawnOptions = null;
			}
			if (instance.respawnAtBag != null)
			{
				instance.respawnAtBag.ResetToPool();
				instance.respawnAtBag = null;
			}
			if (instance.destroyBag != null)
			{
				instance.destroyBag.ResetToPool();
				instance.destroyBag = null;
			}
			if (instance.ferryStatus != null)
			{
				instance.ferryStatus.ResetToPool();
				instance.ferryStatus = null;
			}
			if (instance.ferryRetire != null)
			{
				instance.ferryRetire.ResetToPool();
				instance.ferryRetire = null;
			}
			if (instance.ferryUpdateSchedule != null)
			{
				instance.ferryUpdateSchedule.ResetToPool();
				instance.ferryUpdateSchedule = null;
			}
			if (instance.clanChatBatch != null)
			{
				instance.clanChatBatch.ResetToPool();
				instance.clanChatBatch = null;
			}
			if (instance.playerManifest != null)
			{
				instance.playerManifest.ResetToPool();
				instance.playerManifest = null;
			}
			Pool.Free<Request>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Request with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Request instance)
	{
		instance.isFireAndForget = isFireAndForget;
		if (transfer != null)
		{
			if (instance.transfer == null)
			{
				instance.transfer = transfer.Copy();
			}
			else
			{
				transfer.CopyTo(instance.transfer);
			}
		}
		else
		{
			instance.transfer = null;
		}
		if (ping != null)
		{
			if (instance.ping == null)
			{
				instance.ping = ping.Copy();
			}
			else
			{
				ping.CopyTo(instance.ping);
			}
		}
		else
		{
			instance.ping = null;
		}
		if (spawnOptions != null)
		{
			if (instance.spawnOptions == null)
			{
				instance.spawnOptions = spawnOptions.Copy();
			}
			else
			{
				spawnOptions.CopyTo(instance.spawnOptions);
			}
		}
		else
		{
			instance.spawnOptions = null;
		}
		if (respawnAtBag != null)
		{
			if (instance.respawnAtBag == null)
			{
				instance.respawnAtBag = respawnAtBag.Copy();
			}
			else
			{
				respawnAtBag.CopyTo(instance.respawnAtBag);
			}
		}
		else
		{
			instance.respawnAtBag = null;
		}
		if (destroyBag != null)
		{
			if (instance.destroyBag == null)
			{
				instance.destroyBag = destroyBag.Copy();
			}
			else
			{
				destroyBag.CopyTo(instance.destroyBag);
			}
		}
		else
		{
			instance.destroyBag = null;
		}
		if (ferryStatus != null)
		{
			if (instance.ferryStatus == null)
			{
				instance.ferryStatus = ferryStatus.Copy();
			}
			else
			{
				ferryStatus.CopyTo(instance.ferryStatus);
			}
		}
		else
		{
			instance.ferryStatus = null;
		}
		if (ferryRetire != null)
		{
			if (instance.ferryRetire == null)
			{
				instance.ferryRetire = ferryRetire.Copy();
			}
			else
			{
				ferryRetire.CopyTo(instance.ferryRetire);
			}
		}
		else
		{
			instance.ferryRetire = null;
		}
		if (ferryUpdateSchedule != null)
		{
			if (instance.ferryUpdateSchedule == null)
			{
				instance.ferryUpdateSchedule = ferryUpdateSchedule.Copy();
			}
			else
			{
				ferryUpdateSchedule.CopyTo(instance.ferryUpdateSchedule);
			}
		}
		else
		{
			instance.ferryUpdateSchedule = null;
		}
		if (clanChatBatch != null)
		{
			if (instance.clanChatBatch == null)
			{
				instance.clanChatBatch = clanChatBatch.Copy();
			}
			else
			{
				clanChatBatch.CopyTo(instance.clanChatBatch);
			}
		}
		else
		{
			instance.clanChatBatch = null;
		}
		if (playerManifest != null)
		{
			if (instance.playerManifest == null)
			{
				instance.playerManifest = playerManifest.Copy();
			}
			else
			{
				playerManifest.CopyTo(instance.playerManifest);
			}
		}
		else
		{
			instance.playerManifest = null;
		}
	}

	public Request Copy()
	{
		Request request = Pool.Get<Request>();
		CopyTo(request);
		return request;
	}

	public static Request Deserialize(BufferStream stream)
	{
		Request request = Pool.Get<Request>();
		Deserialize(stream, request, isDelta: false);
		return request;
	}

	public static Request DeserializeLengthDelimited(BufferStream stream)
	{
		Request request = Pool.Get<Request>();
		DeserializeLengthDelimited(stream, request, isDelta: false);
		return request;
	}

	public static Request DeserializeLength(BufferStream stream, int length)
	{
		Request request = Pool.Get<Request>();
		DeserializeLength(stream, length, request, isDelta: false);
		return request;
	}

	public static Request Deserialize(byte[] buffer)
	{
		Request request = Pool.Get<Request>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, request, isDelta: false);
		return request;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Request previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Request Deserialize(BufferStream stream, Request instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.isFireAndForget = ProtocolParser.ReadBool(stream);
				break;
			case 18:
				if (instance.transfer == null)
				{
					instance.transfer = TransferRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					TransferRequest.DeserializeLengthDelimited(stream, instance.transfer, isDelta);
				}
				break;
			case 26:
				if (instance.ping == null)
				{
					instance.ping = PingRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					PingRequest.DeserializeLengthDelimited(stream, instance.ping, isDelta);
				}
				break;
			case 34:
				if (instance.spawnOptions == null)
				{
					instance.spawnOptions = SpawnOptionsRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SpawnOptionsRequest.DeserializeLengthDelimited(stream, instance.spawnOptions, isDelta);
				}
				break;
			case 42:
				if (instance.respawnAtBag == null)
				{
					instance.respawnAtBag = SleepingBagRespawnRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SleepingBagRespawnRequest.DeserializeLengthDelimited(stream, instance.respawnAtBag, isDelta);
				}
				break;
			case 50:
				if (instance.destroyBag == null)
				{
					instance.destroyBag = SleepingBagDestroyRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SleepingBagDestroyRequest.DeserializeLengthDelimited(stream, instance.destroyBag, isDelta);
				}
				break;
			case 58:
				if (instance.ferryStatus == null)
				{
					instance.ferryStatus = FerryStatusRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryStatusRequest.DeserializeLengthDelimited(stream, instance.ferryStatus, isDelta);
				}
				break;
			case 66:
				if (instance.ferryRetire == null)
				{
					instance.ferryRetire = FerryRetireRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryRetireRequest.DeserializeLengthDelimited(stream, instance.ferryRetire, isDelta);
				}
				break;
			case 74:
				if (instance.ferryUpdateSchedule == null)
				{
					instance.ferryUpdateSchedule = FerryUpdateScheduleRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryUpdateScheduleRequest.DeserializeLengthDelimited(stream, instance.ferryUpdateSchedule, isDelta);
				}
				break;
			case 82:
				if (instance.clanChatBatch == null)
				{
					instance.clanChatBatch = ClanChatBatchRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanChatBatchRequest.DeserializeLengthDelimited(stream, instance.clanChatBatch, isDelta);
				}
				break;
			case 90:
				if (instance.playerManifest == null)
				{
					instance.playerManifest = PlayerManifestRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerManifestRequest.DeserializeLengthDelimited(stream, instance.playerManifest, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static Request DeserializeLengthDelimited(BufferStream stream, Request instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.isFireAndForget = ProtocolParser.ReadBool(stream);
				break;
			case 18:
				if (instance.transfer == null)
				{
					instance.transfer = TransferRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					TransferRequest.DeserializeLengthDelimited(stream, instance.transfer, isDelta);
				}
				break;
			case 26:
				if (instance.ping == null)
				{
					instance.ping = PingRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					PingRequest.DeserializeLengthDelimited(stream, instance.ping, isDelta);
				}
				break;
			case 34:
				if (instance.spawnOptions == null)
				{
					instance.spawnOptions = SpawnOptionsRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SpawnOptionsRequest.DeserializeLengthDelimited(stream, instance.spawnOptions, isDelta);
				}
				break;
			case 42:
				if (instance.respawnAtBag == null)
				{
					instance.respawnAtBag = SleepingBagRespawnRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SleepingBagRespawnRequest.DeserializeLengthDelimited(stream, instance.respawnAtBag, isDelta);
				}
				break;
			case 50:
				if (instance.destroyBag == null)
				{
					instance.destroyBag = SleepingBagDestroyRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SleepingBagDestroyRequest.DeserializeLengthDelimited(stream, instance.destroyBag, isDelta);
				}
				break;
			case 58:
				if (instance.ferryStatus == null)
				{
					instance.ferryStatus = FerryStatusRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryStatusRequest.DeserializeLengthDelimited(stream, instance.ferryStatus, isDelta);
				}
				break;
			case 66:
				if (instance.ferryRetire == null)
				{
					instance.ferryRetire = FerryRetireRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryRetireRequest.DeserializeLengthDelimited(stream, instance.ferryRetire, isDelta);
				}
				break;
			case 74:
				if (instance.ferryUpdateSchedule == null)
				{
					instance.ferryUpdateSchedule = FerryUpdateScheduleRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryUpdateScheduleRequest.DeserializeLengthDelimited(stream, instance.ferryUpdateSchedule, isDelta);
				}
				break;
			case 82:
				if (instance.clanChatBatch == null)
				{
					instance.clanChatBatch = ClanChatBatchRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanChatBatchRequest.DeserializeLengthDelimited(stream, instance.clanChatBatch, isDelta);
				}
				break;
			case 90:
				if (instance.playerManifest == null)
				{
					instance.playerManifest = PlayerManifestRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerManifestRequest.DeserializeLengthDelimited(stream, instance.playerManifest, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Request DeserializeLength(BufferStream stream, int length, Request instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.isFireAndForget = ProtocolParser.ReadBool(stream);
				break;
			case 18:
				if (instance.transfer == null)
				{
					instance.transfer = TransferRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					TransferRequest.DeserializeLengthDelimited(stream, instance.transfer, isDelta);
				}
				break;
			case 26:
				if (instance.ping == null)
				{
					instance.ping = PingRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					PingRequest.DeserializeLengthDelimited(stream, instance.ping, isDelta);
				}
				break;
			case 34:
				if (instance.spawnOptions == null)
				{
					instance.spawnOptions = SpawnOptionsRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SpawnOptionsRequest.DeserializeLengthDelimited(stream, instance.spawnOptions, isDelta);
				}
				break;
			case 42:
				if (instance.respawnAtBag == null)
				{
					instance.respawnAtBag = SleepingBagRespawnRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SleepingBagRespawnRequest.DeserializeLengthDelimited(stream, instance.respawnAtBag, isDelta);
				}
				break;
			case 50:
				if (instance.destroyBag == null)
				{
					instance.destroyBag = SleepingBagDestroyRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					SleepingBagDestroyRequest.DeserializeLengthDelimited(stream, instance.destroyBag, isDelta);
				}
				break;
			case 58:
				if (instance.ferryStatus == null)
				{
					instance.ferryStatus = FerryStatusRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryStatusRequest.DeserializeLengthDelimited(stream, instance.ferryStatus, isDelta);
				}
				break;
			case 66:
				if (instance.ferryRetire == null)
				{
					instance.ferryRetire = FerryRetireRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryRetireRequest.DeserializeLengthDelimited(stream, instance.ferryRetire, isDelta);
				}
				break;
			case 74:
				if (instance.ferryUpdateSchedule == null)
				{
					instance.ferryUpdateSchedule = FerryUpdateScheduleRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryUpdateScheduleRequest.DeserializeLengthDelimited(stream, instance.ferryUpdateSchedule, isDelta);
				}
				break;
			case 82:
				if (instance.clanChatBatch == null)
				{
					instance.clanChatBatch = ClanChatBatchRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					ClanChatBatchRequest.DeserializeLengthDelimited(stream, instance.clanChatBatch, isDelta);
				}
				break;
			case 90:
				if (instance.playerManifest == null)
				{
					instance.playerManifest = PlayerManifestRequest.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerManifestRequest.DeserializeLengthDelimited(stream, instance.playerManifest, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Request instance, Request previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.isFireAndForget);
		if (instance.transfer != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			TransferRequest.SerializeDelta(stream, instance.transfer, previous.transfer);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.ping != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			PingRequest.SerializeDelta(stream, instance.ping, previous.ping);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ping (ProtoBuf.Nexus.PingRequest)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.spawnOptions != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			SpawnOptionsRequest.SerializeDelta(stream, instance.spawnOptions, previous.spawnOptions);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field spawnOptions (ProtoBuf.Nexus.SpawnOptionsRequest)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.respawnAtBag != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			SleepingBagRespawnRequest.SerializeDelta(stream, instance.respawnAtBag, previous.respawnAtBag);
			int val2 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
			if (num4 < 5)
			{
				span4[num4 - 1] |= 128;
				while (num4 < 4)
				{
					span4[num4++] = 128;
				}
				span4[4] = 0;
			}
		}
		if (instance.destroyBag != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			SleepingBagDestroyRequest.SerializeDelta(stream, instance.destroyBag, previous.destroyBag);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field destroyBag (ProtoBuf.Nexus.SleepingBagDestroyRequest)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.ferryStatus != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			FerryStatusRequest.SerializeDelta(stream, instance.ferryStatus, previous.ferryStatus);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ferryStatus (ProtoBuf.Nexus.FerryStatusRequest)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.ferryRetire != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			FerryRetireRequest.SerializeDelta(stream, instance.ferryRetire, previous.ferryRetire);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ferryRetire (ProtoBuf.Nexus.FerryRetireRequest)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.ferryUpdateSchedule != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range8 = stream.GetRange(5);
			int position8 = stream.Position;
			FerryUpdateScheduleRequest.SerializeDelta(stream, instance.ferryUpdateSchedule, previous.ferryUpdateSchedule);
			int val3 = stream.Position - position8;
			Span<byte> span8 = range8.GetSpan();
			int num8 = ProtocolParser.WriteUInt32((uint)val3, span8, 0);
			if (num8 < 5)
			{
				span8[num8 - 1] |= 128;
				while (num8 < 4)
				{
					span8[num8++] = 128;
				}
				span8[4] = 0;
			}
		}
		if (instance.clanChatBatch != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range9 = stream.GetRange(5);
			int position9 = stream.Position;
			ClanChatBatchRequest.SerializeDelta(stream, instance.clanChatBatch, previous.clanChatBatch);
			int val4 = stream.Position - position9;
			Span<byte> span9 = range9.GetSpan();
			int num9 = ProtocolParser.WriteUInt32((uint)val4, span9, 0);
			if (num9 < 5)
			{
				span9[num9 - 1] |= 128;
				while (num9 < 4)
				{
					span9[num9++] = 128;
				}
				span9[4] = 0;
			}
		}
		if (instance.playerManifest == null)
		{
			return;
		}
		stream.WriteByte(90);
		BufferStream.RangeHandle range10 = stream.GetRange(3);
		int position10 = stream.Position;
		PlayerManifestRequest.SerializeDelta(stream, instance.playerManifest, previous.playerManifest);
		int num10 = stream.Position - position10;
		if (num10 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerManifest (ProtoBuf.Nexus.PlayerManifestRequest)");
		}
		Span<byte> span10 = range10.GetSpan();
		int num11 = ProtocolParser.WriteUInt32((uint)num10, span10, 0);
		if (num11 < 3)
		{
			span10[num11 - 1] |= 128;
			while (num11 < 2)
			{
				span10[num11++] = 128;
			}
			span10[2] = 0;
		}
	}

	public static void Serialize(BufferStream stream, Request instance)
	{
		if (instance.isFireAndForget)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.isFireAndForget);
		}
		if (instance.transfer != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			TransferRequest.Serialize(stream, instance.transfer);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.ping != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			PingRequest.Serialize(stream, instance.ping);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ping (ProtoBuf.Nexus.PingRequest)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.spawnOptions != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			SpawnOptionsRequest.Serialize(stream, instance.spawnOptions);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field spawnOptions (ProtoBuf.Nexus.SpawnOptionsRequest)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.respawnAtBag != null)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			SleepingBagRespawnRequest.Serialize(stream, instance.respawnAtBag);
			int val2 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
			if (num4 < 5)
			{
				span4[num4 - 1] |= 128;
				while (num4 < 4)
				{
					span4[num4++] = 128;
				}
				span4[4] = 0;
			}
		}
		if (instance.destroyBag != null)
		{
			stream.WriteByte(50);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			SleepingBagDestroyRequest.Serialize(stream, instance.destroyBag);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field destroyBag (ProtoBuf.Nexus.SleepingBagDestroyRequest)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.ferryStatus != null)
		{
			stream.WriteByte(58);
			BufferStream.RangeHandle range6 = stream.GetRange(1);
			int position6 = stream.Position;
			FerryStatusRequest.Serialize(stream, instance.ferryStatus);
			int num6 = stream.Position - position6;
			if (num6 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ferryStatus (ProtoBuf.Nexus.FerryStatusRequest)");
			}
			Span<byte> span6 = range6.GetSpan();
			ProtocolParser.WriteUInt32((uint)num6, span6, 0);
		}
		if (instance.ferryRetire != null)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range7 = stream.GetRange(1);
			int position7 = stream.Position;
			FerryRetireRequest.Serialize(stream, instance.ferryRetire);
			int num7 = stream.Position - position7;
			if (num7 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ferryRetire (ProtoBuf.Nexus.FerryRetireRequest)");
			}
			Span<byte> span7 = range7.GetSpan();
			ProtocolParser.WriteUInt32((uint)num7, span7, 0);
		}
		if (instance.ferryUpdateSchedule != null)
		{
			stream.WriteByte(74);
			BufferStream.RangeHandle range8 = stream.GetRange(5);
			int position8 = stream.Position;
			FerryUpdateScheduleRequest.Serialize(stream, instance.ferryUpdateSchedule);
			int val3 = stream.Position - position8;
			Span<byte> span8 = range8.GetSpan();
			int num8 = ProtocolParser.WriteUInt32((uint)val3, span8, 0);
			if (num8 < 5)
			{
				span8[num8 - 1] |= 128;
				while (num8 < 4)
				{
					span8[num8++] = 128;
				}
				span8[4] = 0;
			}
		}
		if (instance.clanChatBatch != null)
		{
			stream.WriteByte(82);
			BufferStream.RangeHandle range9 = stream.GetRange(5);
			int position9 = stream.Position;
			ClanChatBatchRequest.Serialize(stream, instance.clanChatBatch);
			int val4 = stream.Position - position9;
			Span<byte> span9 = range9.GetSpan();
			int num9 = ProtocolParser.WriteUInt32((uint)val4, span9, 0);
			if (num9 < 5)
			{
				span9[num9 - 1] |= 128;
				while (num9 < 4)
				{
					span9[num9++] = 128;
				}
				span9[4] = 0;
			}
		}
		if (instance.playerManifest == null)
		{
			return;
		}
		stream.WriteByte(90);
		BufferStream.RangeHandle range10 = stream.GetRange(3);
		int position10 = stream.Position;
		PlayerManifestRequest.Serialize(stream, instance.playerManifest);
		int num10 = stream.Position - position10;
		if (num10 > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field playerManifest (ProtoBuf.Nexus.PlayerManifestRequest)");
		}
		Span<byte> span10 = range10.GetSpan();
		int num11 = ProtocolParser.WriteUInt32((uint)num10, span10, 0);
		if (num11 < 3)
		{
			span10[num11 - 1] |= 128;
			while (num11 < 2)
			{
				span10[num11++] = 128;
			}
			span10[2] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		transfer?.InspectUids(action);
		ping?.InspectUids(action);
		spawnOptions?.InspectUids(action);
		respawnAtBag?.InspectUids(action);
		destroyBag?.InspectUids(action);
		ferryStatus?.InspectUids(action);
		ferryRetire?.InspectUids(action);
		ferryUpdateSchedule?.InspectUids(action);
		clanChatBatch?.InspectUids(action);
		playerManifest?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using Facepunch.Nexus;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class Response : IDisposable, IPooled, IProto<Response>, IProto
{
	[NonSerialized]
	public Uuid id;

	[NonSerialized]
	public Status status;

	[NonSerialized]
	public PingResponse ping;

	[NonSerialized]
	public SpawnOptionsResponse spawnOptions;

	[NonSerialized]
	public FerryStatusResponse ferryStatus;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Response instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.id = default(Uuid);
			if (instance.status != null)
			{
				instance.status.ResetToPool();
				instance.status = null;
			}
			if (instance.ping != null)
			{
				instance.ping.ResetToPool();
				instance.ping = null;
			}
			if (instance.spawnOptions != null)
			{
				instance.spawnOptions.ResetToPool();
				instance.spawnOptions = null;
			}
			if (instance.ferryStatus != null)
			{
				instance.ferryStatus.ResetToPool();
				instance.ferryStatus = null;
			}
			Pool.Free<Response>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Response with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Response instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.id = id;
		if (status != null)
		{
			if (instance.status == null)
			{
				instance.status = status.Copy();
			}
			else
			{
				status.CopyTo(instance.status);
			}
		}
		else
		{
			instance.status = null;
		}
		if (ping != null)
		{
			if (instance.ping == null)
			{
				instance.ping = ping.Copy();
			}
			else
			{
				ping.CopyTo(instance.ping);
			}
		}
		else
		{
			instance.ping = null;
		}
		if (spawnOptions != null)
		{
			if (instance.spawnOptions == null)
			{
				instance.spawnOptions = spawnOptions.Copy();
			}
			else
			{
				spawnOptions.CopyTo(instance.spawnOptions);
			}
		}
		else
		{
			instance.spawnOptions = null;
		}
		if (ferryStatus != null)
		{
			if (instance.ferryStatus == null)
			{
				instance.ferryStatus = ferryStatus.Copy();
			}
			else
			{
				ferryStatus.CopyTo(instance.ferryStatus);
			}
		}
		else
		{
			instance.ferryStatus = null;
		}
	}

	public Response Copy()
	{
		Response response = Pool.Get<Response>();
		CopyTo(response);
		return response;
	}

	public static Response Deserialize(BufferStream stream)
	{
		Response response = Pool.Get<Response>();
		Deserialize(stream, response, isDelta: false);
		return response;
	}

	public static Response DeserializeLengthDelimited(BufferStream stream)
	{
		Response response = Pool.Get<Response>();
		DeserializeLengthDelimited(stream, response, isDelta: false);
		return response;
	}

	public static Response DeserializeLength(BufferStream stream, int length)
	{
		Response response = Pool.Get<Response>();
		DeserializeLength(stream, length, response, isDelta: false);
		return response;
	}

	public static Response Deserialize(byte[] buffer)
	{
		Response response = Pool.Get<Response>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, response, isDelta: false);
		return response;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Response previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Response Deserialize(BufferStream stream, Response instance, bool isDelta)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				UuidSerialized.DeserializeLengthDelimited(stream, ref instance.id, isDelta);
				break;
			case 18:
				if (instance.status == null)
				{
					instance.status = Status.DeserializeLengthDelimited(stream);
				}
				else
				{
					Status.DeserializeLengthDelimited(stream, instance.status, isDelta);
				}
				break;
			case 26:
				if (instance.ping == null)
				{
					instance.ping = PingResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					PingResponse.DeserializeLengthDelimited(stream, instance.ping, isDelta);
				}
				break;
			case 34:
				if (instance.spawnOptions == null)
				{
					instance.spawnOptions = SpawnOptionsResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					SpawnOptionsResponse.DeserializeLengthDelimited(stream, instance.spawnOptions, isDelta);
				}
				break;
			case 42:
				if (instance.ferryStatus == null)
				{
					instance.ferryStatus = FerryStatusResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryStatusResponse.DeserializeLengthDelimited(stream, instance.ferryStatus, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static Response DeserializeLengthDelimited(BufferStream stream, Response instance, bool isDelta)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				UuidSerialized.DeserializeLengthDelimited(stream, ref instance.id, isDelta);
				break;
			case 18:
				if (instance.status == null)
				{
					instance.status = Status.DeserializeLengthDelimited(stream);
				}
				else
				{
					Status.DeserializeLengthDelimited(stream, instance.status, isDelta);
				}
				break;
			case 26:
				if (instance.ping == null)
				{
					instance.ping = PingResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					PingResponse.DeserializeLengthDelimited(stream, instance.ping, isDelta);
				}
				break;
			case 34:
				if (instance.spawnOptions == null)
				{
					instance.spawnOptions = SpawnOptionsResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					SpawnOptionsResponse.DeserializeLengthDelimited(stream, instance.spawnOptions, isDelta);
				}
				break;
			case 42:
				if (instance.ferryStatus == null)
				{
					instance.ferryStatus = FerryStatusResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryStatusResponse.DeserializeLengthDelimited(stream, instance.ferryStatus, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Response DeserializeLength(BufferStream stream, int length, Response instance, bool isDelta)
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				UuidSerialized.DeserializeLengthDelimited(stream, ref instance.id, isDelta);
				break;
			case 18:
				if (instance.status == null)
				{
					instance.status = Status.DeserializeLengthDelimited(stream);
				}
				else
				{
					Status.DeserializeLengthDelimited(stream, instance.status, isDelta);
				}
				break;
			case 26:
				if (instance.ping == null)
				{
					instance.ping = PingResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					PingResponse.DeserializeLengthDelimited(stream, instance.ping, isDelta);
				}
				break;
			case 34:
				if (instance.spawnOptions == null)
				{
					instance.spawnOptions = SpawnOptionsResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					SpawnOptionsResponse.DeserializeLengthDelimited(stream, instance.spawnOptions, isDelta);
				}
				break;
			case 42:
				if (instance.ferryStatus == null)
				{
					instance.ferryStatus = FerryStatusResponse.DeserializeLengthDelimited(stream);
				}
				else
				{
					FerryStatusResponse.DeserializeLengthDelimited(stream, instance.ferryStatus, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Response instance, Response previous)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(10);
		BufferStream.RangeHandle range = stream.GetRange(1);
		int position = stream.Position;
		UuidSerialized.SerializeDelta(stream, instance.id, previous.id);
		int num = stream.Position - position;
		if (num > 127)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field id (Facepunch.Nexus.Uuid)");
		}
		Span<byte> span = range.GetSpan();
		ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (instance.status == null)
		{
			throw new ArgumentNullException("status", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		Status.SerializeDelta(stream, instance.status, previous.status);
		int val = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
		if (instance.ping != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			PingResponse.SerializeDelta(stream, instance.ping, previous.ping);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ping (ProtoBuf.Nexus.PingResponse)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.spawnOptions != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			SpawnOptionsResponse.SerializeDelta(stream, instance.spawnOptions, previous.spawnOptions);
			int val2 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
			if (num4 < 5)
			{
				span4[num4 - 1] |= 128;
				while (num4 < 4)
				{
					span4[num4++] = 128;
				}
				span4[4] = 0;
			}
		}
		if (instance.ferryStatus == null)
		{
			return;
		}
		stream.WriteByte(42);
		BufferStream.RangeHandle range5 = stream.GetRange(5);
		int position5 = stream.Position;
		FerryStatusResponse.SerializeDelta(stream, instance.ferryStatus, previous.ferryStatus);
		int val3 = stream.Position - position5;
		Span<byte> span5 = range5.GetSpan();
		int num5 = ProtocolParser.WriteUInt32((uint)val3, span5, 0);
		if (num5 < 5)
		{
			span5[num5 - 1] |= 128;
			while (num5 < 4)
			{
				span5[num5++] = 128;
			}
			span5[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, Response instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (instance.id != default(Uuid))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			UuidSerialized.Serialize(stream, instance.id);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field id (Facepunch.Nexus.Uuid)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.status == null)
		{
			throw new ArgumentNullException("status", "Required by proto specification.");
		}
		stream.WriteByte(18);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		Status.Serialize(stream, instance.status);
		int val = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
		if (instance.ping != null)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			PingResponse.Serialize(stream, instance.ping);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field ping (ProtoBuf.Nexus.PingResponse)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.spawnOptions != null)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(5);
			int position4 = stream.Position;
			SpawnOptionsResponse.Serialize(stream, instance.spawnOptions);
			int val2 = stream.Position - position4;
			Span<byte> span4 = range4.GetSpan();
			int num4 = ProtocolParser.WriteUInt32((uint)val2, span4, 0);
			if (num4 < 5)
			{
				span4[num4 - 1] |= 128;
				while (num4 < 4)
				{
					span4[num4++] = 128;
				}
				span4[4] = 0;
			}
		}
		if (instance.ferryStatus == null)
		{
			return;
		}
		stream.WriteByte(42);
		BufferStream.RangeHandle range5 = stream.GetRange(5);
		int position5 = stream.Position;
		FerryStatusResponse.Serialize(stream, instance.ferryStatus);
		int val3 = stream.Position - position5;
		Span<byte> span5 = range5.GetSpan();
		int num5 = ProtocolParser.WriteUInt32((uint)val3, span5, 0);
		if (num5 < 5)
		{
			span5[num5 - 1] |= 128;
			while (num5 < 4)
			{
				span5[num5++] = 128;
			}
			span5[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		status?.InspectUids(action);
		ping?.InspectUids(action);
		spawnOptions?.InspectUids(action);
		ferryStatus?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class Status : IDisposable, IPooled, IProto<Status>, IProto
{
	[NonSerialized]
	public bool success;

	[NonSerialized]
	public string errorMessage;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Status instance)
	{
		if (instance.ShouldPool)
		{
			instance.success = false;
			instance.errorMessage = string.Empty;
			Pool.Free<Status>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Status with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Status instance)
	{
		instance.success = success;
		instance.errorMessage = errorMessage;
	}

	public Status Copy()
	{
		Status status = Pool.Get<Status>();
		CopyTo(status);
		return status;
	}

	public static Status Deserialize(BufferStream stream)
	{
		Status status = Pool.Get<Status>();
		Deserialize(stream, status, isDelta: false);
		return status;
	}

	public static Status DeserializeLengthDelimited(BufferStream stream)
	{
		Status status = Pool.Get<Status>();
		DeserializeLengthDelimited(stream, status, isDelta: false);
		return status;
	}

	public static Status DeserializeLength(BufferStream stream, int length)
	{
		Status status = Pool.Get<Status>();
		DeserializeLength(stream, length, status, isDelta: false);
		return status;
	}

	public static Status Deserialize(byte[] buffer)
	{
		Status status = Pool.Get<Status>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, status, isDelta: false);
		return status;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Status previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Status Deserialize(BufferStream stream, Status instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.success = ProtocolParser.ReadBool(stream);
				continue;
			case 18:
				instance.errorMessage = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Status DeserializeLengthDelimited(BufferStream stream, Status instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.success = ProtocolParser.ReadBool(stream);
				continue;
			case 18:
				instance.errorMessage = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Status DeserializeLength(BufferStream stream, int length, Status instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.success = ProtocolParser.ReadBool(stream);
				continue;
			case 18:
				instance.errorMessage = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Status instance, Status previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteBool(stream, instance.success);
		if (instance.errorMessage != null && instance.errorMessage != previous.errorMessage)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.errorMessage);
		}
	}

	public static void Serialize(BufferStream stream, Status instance)
	{
		if (instance.success)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteBool(stream, instance.success);
		}
		if (instance.errorMessage != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.errorMessage);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class PingRequest : IDisposable, IPooled, IProto<PingRequest>, IProto
{
	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PingRequest instance)
	{
		if (instance.ShouldPool)
		{
			Pool.Free<PingRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PingRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PingRequest instance)
	{
	}

	public PingRequest Copy()
	{
		PingRequest pingRequest = Pool.Get<PingRequest>();
		CopyTo(pingRequest);
		return pingRequest;
	}

	public static PingRequest Deserialize(BufferStream stream)
	{
		PingRequest pingRequest = Pool.Get<PingRequest>();
		Deserialize(stream, pingRequest, isDelta: false);
		return pingRequest;
	}

	public static PingRequest DeserializeLengthDelimited(BufferStream stream)
	{
		PingRequest pingRequest = Pool.Get<PingRequest>();
		DeserializeLengthDelimited(stream, pingRequest, isDelta: false);
		return pingRequest;
	}

	public static PingRequest DeserializeLength(BufferStream stream, int length)
	{
		PingRequest pingRequest = Pool.Get<PingRequest>();
		DeserializeLength(stream, length, pingRequest, isDelta: false);
		return pingRequest;
	}

	public static PingRequest Deserialize(byte[] buffer)
	{
		PingRequest pingRequest = Pool.Get<PingRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, pingRequest, isDelta: false);
		return pingRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PingRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PingRequest Deserialize(BufferStream stream, PingRequest instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			if (num == -1)
			{
				break;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static PingRequest DeserializeLengthDelimited(BufferStream stream, PingRequest instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static PingRequest DeserializeLength(BufferStream stream, int length, PingRequest instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PingRequest instance, PingRequest previous)
	{
	}

	public static void Serialize(BufferStream stream, PingRequest instance)
	{
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class PingResponse : IDisposable, IPooled, IProto<PingResponse>, IProto
{
	[NonSerialized]
	public int players;

	[NonSerialized]
	public int maxPlayers;

	[NonSerialized]
	public int queuedPlayers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PingResponse instance)
	{
		if (instance.ShouldPool)
		{
			instance.players = 0;
			instance.maxPlayers = 0;
			instance.queuedPlayers = 0;
			Pool.Free<PingResponse>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PingResponse with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PingResponse instance)
	{
		instance.players = players;
		instance.maxPlayers = maxPlayers;
		instance.queuedPlayers = queuedPlayers;
	}

	public PingResponse Copy()
	{
		PingResponse pingResponse = Pool.Get<PingResponse>();
		CopyTo(pingResponse);
		return pingResponse;
	}

	public static PingResponse Deserialize(BufferStream stream)
	{
		PingResponse pingResponse = Pool.Get<PingResponse>();
		Deserialize(stream, pingResponse, isDelta: false);
		return pingResponse;
	}

	public static PingResponse DeserializeLengthDelimited(BufferStream stream)
	{
		PingResponse pingResponse = Pool.Get<PingResponse>();
		DeserializeLengthDelimited(stream, pingResponse, isDelta: false);
		return pingResponse;
	}

	public static PingResponse DeserializeLength(BufferStream stream, int length)
	{
		PingResponse pingResponse = Pool.Get<PingResponse>();
		DeserializeLength(stream, length, pingResponse, isDelta: false);
		return pingResponse;
	}

	public static PingResponse Deserialize(byte[] buffer)
	{
		PingResponse pingResponse = Pool.Get<PingResponse>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, pingResponse, isDelta: false);
		return pingResponse;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PingResponse previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PingResponse Deserialize(BufferStream stream, PingResponse instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.players = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.maxPlayers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.queuedPlayers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PingResponse DeserializeLengthDelimited(BufferStream stream, PingResponse instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.players = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.maxPlayers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.queuedPlayers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PingResponse DeserializeLength(BufferStream stream, int length, PingResponse instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.players = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.maxPlayers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.queuedPlayers = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PingResponse instance, PingResponse previous)
	{
		if (instance.players != previous.players)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.players);
		}
		if (instance.maxPlayers != previous.maxPlayers)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxPlayers);
		}
		if (instance.queuedPlayers != previous.queuedPlayers)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.queuedPlayers);
		}
	}

	public static void Serialize(BufferStream stream, PingResponse instance)
	{
		if (instance.players != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.players);
		}
		if (instance.maxPlayers != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxPlayers);
		}
		if (instance.queuedPlayers != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.queuedPlayers);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class TransferRequest : IDisposable, IPooled, IProto<TransferRequest>, IProto
{
	[NonSerialized]
	public string method;

	[NonSerialized]
	public string from;

	[NonSerialized]
	public string to;

	[NonSerialized]
	public List<Entity> entities;

	[NonSerialized]
	public List<PlayerSecondaryData> secondaryData;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TransferRequest instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.method = string.Empty;
		instance.from = string.Empty;
		instance.to = string.Empty;
		if (instance.entities != null)
		{
			for (int i = 0; i < instance.entities.Count; i++)
			{
				if (instance.entities[i] != null)
				{
					instance.entities[i].ResetToPool();
					instance.entities[i] = null;
				}
			}
			List<Entity> list = instance.entities;
			Pool.Free<Entity>(ref list, false);
			instance.entities = list;
		}
		if (instance.secondaryData != null)
		{
			for (int j = 0; j < instance.secondaryData.Count; j++)
			{
				if (instance.secondaryData[j] != null)
				{
					instance.secondaryData[j].ResetToPool();
					instance.secondaryData[j] = null;
				}
			}
			List<PlayerSecondaryData> list2 = instance.secondaryData;
			Pool.Free<PlayerSecondaryData>(ref list2, false);
			instance.secondaryData = list2;
		}
		Pool.Free<TransferRequest>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TransferRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TransferRequest instance)
	{
		instance.method = method;
		instance.from = from;
		instance.to = to;
		if (entities != null)
		{
			instance.entities = Pool.Get<List<Entity>>();
			for (int i = 0; i < entities.Count; i++)
			{
				Entity item = entities[i].Copy();
				instance.entities.Add(item);
			}
		}
		else
		{
			instance.entities = null;
		}
		if (secondaryData != null)
		{
			instance.secondaryData = Pool.Get<List<PlayerSecondaryData>>();
			for (int j = 0; j < secondaryData.Count; j++)
			{
				PlayerSecondaryData item2 = secondaryData[j].Copy();
				instance.secondaryData.Add(item2);
			}
		}
		else
		{
			instance.secondaryData = null;
		}
	}

	public TransferRequest Copy()
	{
		TransferRequest transferRequest = Pool.Get<TransferRequest>();
		CopyTo(transferRequest);
		return transferRequest;
	}

	public static TransferRequest Deserialize(BufferStream stream)
	{
		TransferRequest transferRequest = Pool.Get<TransferRequest>();
		Deserialize(stream, transferRequest, isDelta: false);
		return transferRequest;
	}

	public static TransferRequest DeserializeLengthDelimited(BufferStream stream)
	{
		TransferRequest transferRequest = Pool.Get<TransferRequest>();
		DeserializeLengthDelimited(stream, transferRequest, isDelta: false);
		return transferRequest;
	}

	public static TransferRequest DeserializeLength(BufferStream stream, int length)
	{
		TransferRequest transferRequest = Pool.Get<TransferRequest>();
		DeserializeLength(stream, length, transferRequest, isDelta: false);
		return transferRequest;
	}

	public static TransferRequest Deserialize(byte[] buffer)
	{
		TransferRequest transferRequest = Pool.Get<TransferRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, transferRequest, isDelta: false);
		return transferRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TransferRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TransferRequest Deserialize(BufferStream stream, TransferRequest instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.entities == null)
			{
				instance.entities = Pool.Get<List<Entity>>();
			}
			if (instance.secondaryData == null)
			{
				instance.secondaryData = Pool.Get<List<PlayerSecondaryData>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.method = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.from = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.to = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			case 42:
				instance.secondaryData.Add(PlayerSecondaryData.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TransferRequest DeserializeLengthDelimited(BufferStream stream, TransferRequest instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.entities == null)
			{
				instance.entities = Pool.Get<List<Entity>>();
			}
			if (instance.secondaryData == null)
			{
				instance.secondaryData = Pool.Get<List<PlayerSecondaryData>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.method = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.from = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.to = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			case 42:
				instance.secondaryData.Add(PlayerSecondaryData.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TransferRequest DeserializeLength(BufferStream stream, int length, TransferRequest instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.entities == null)
			{
				instance.entities = Pool.Get<List<Entity>>();
			}
			if (instance.secondaryData == null)
			{
				instance.secondaryData = Pool.Get<List<PlayerSecondaryData>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.method = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.from = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.to = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.entities.Add(Entity.DeserializeLengthDelimited(stream));
				continue;
			case 42:
				instance.secondaryData.Add(PlayerSecondaryData.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TransferRequest instance, TransferRequest previous)
	{
		if (instance.method != null && instance.method != previous.method)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.method);
		}
		if (instance.from != null && instance.from != previous.from)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.from);
		}
		if (instance.to != null && instance.to != previous.to)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.to);
		}
		if (instance.entities != null)
		{
			for (int i = 0; i < instance.entities.Count; i++)
			{
				Entity entity = instance.entities[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Entity.SerializeDelta(stream, entity, entity);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.secondaryData == null)
		{
			return;
		}
		for (int j = 0; j < instance.secondaryData.Count; j++)
		{
			PlayerSecondaryData playerSecondaryData = instance.secondaryData[j];
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PlayerSecondaryData.SerializeDelta(stream, playerSecondaryData, playerSecondaryData);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, TransferRequest instance)
	{
		if (instance.method != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.method);
		}
		if (instance.from != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.from);
		}
		if (instance.to != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.to);
		}
		if (instance.entities != null)
		{
			for (int i = 0; i < instance.entities.Count; i++)
			{
				Entity instance2 = instance.entities[i];
				stream.WriteByte(34);
				BufferStream.RangeHandle range = stream.GetRange(5);
				int position = stream.Position;
				Entity.Serialize(stream, instance2);
				int val = stream.Position - position;
				Span<byte> span = range.GetSpan();
				int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
				if (num < 5)
				{
					span[num - 1] |= 128;
					while (num < 4)
					{
						span[num++] = 128;
					}
					span[4] = 0;
				}
			}
		}
		if (instance.secondaryData == null)
		{
			return;
		}
		for (int j = 0; j < instance.secondaryData.Count; j++)
		{
			PlayerSecondaryData instance3 = instance.secondaryData[j];
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(5);
			int position2 = stream.Position;
			PlayerSecondaryData.Serialize(stream, instance3);
			int val2 = stream.Position - position2;
			Span<byte> span2 = range2.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
			if (num2 < 5)
			{
				span2[num2 - 1] |= 128;
				while (num2 < 4)
				{
					span2[num2++] = 128;
				}
				span2[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (entities != null)
		{
			for (int i = 0; i < entities.Count; i++)
			{
				entities[i]?.InspectUids(action);
			}
		}
		if (secondaryData != null)
		{
			for (int j = 0; j < secondaryData.Count; j++)
			{
				secondaryData[j]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class PlayerSecondaryData : IDisposable, IPooled, IProto<PlayerSecondaryData>, IProto
{
	public class RelationshipData : IDisposable, IPooled, IProto<RelationshipData>, IProto
	{
		[NonSerialized]
		public RelationshipManager.PlayerRelationshipInfo info;

		[NonSerialized]
		public ArraySegment<byte> mugshotData;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(RelationshipData instance)
		{
			if (instance.ShouldPool)
			{
				if (instance.info != null)
				{
					instance.info.ResetToPool();
					instance.info = null;
				}
				if (instance.mugshotData.Array != null)
				{
					BufferStream.Shared.ArrayPool.Return(instance.mugshotData.Array);
				}
				instance.mugshotData = default(ArraySegment<byte>);
				Pool.Free<RelationshipData>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose RelationshipData with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(RelationshipData instance)
		{
			if (info != null)
			{
				if (instance.info == null)
				{
					instance.info = info.Copy();
				}
				else
				{
					info.CopyTo(instance.info);
				}
			}
			else
			{
				instance.info = null;
			}
			if (mugshotData.Array == null)
			{
				instance.mugshotData = default(ArraySegment<byte>);
				return;
			}
			byte[] array = BufferStream.Shared.ArrayPool.Rent(mugshotData.Count);
			Array.Copy(mugshotData.Array, 0, array, 0, mugshotData.Count);
			instance.mugshotData = new ArraySegment<byte>(array, 0, mugshotData.Count);
		}

		public RelationshipData Copy()
		{
			RelationshipData relationshipData = Pool.Get<RelationshipData>();
			CopyTo(relationshipData);
			return relationshipData;
		}

		public static RelationshipData Deserialize(BufferStream stream)
		{
			RelationshipData relationshipData = Pool.Get<RelationshipData>();
			Deserialize(stream, relationshipData, isDelta: false);
			return relationshipData;
		}

		public static RelationshipData DeserializeLengthDelimited(BufferStream stream)
		{
			RelationshipData relationshipData = Pool.Get<RelationshipData>();
			DeserializeLengthDelimited(stream, relationshipData, isDelta: false);
			return relationshipData;
		}

		public static RelationshipData DeserializeLength(BufferStream stream, int length)
		{
			RelationshipData relationshipData = Pool.Get<RelationshipData>();
			DeserializeLength(stream, length, relationshipData, isDelta: false);
			return relationshipData;
		}

		public static RelationshipData Deserialize(byte[] buffer)
		{
			RelationshipData relationshipData = Pool.Get<RelationshipData>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, relationshipData, isDelta: false);
			return relationshipData;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, RelationshipData previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static RelationshipData Deserialize(BufferStream stream, RelationshipData instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					if (instance.info == null)
					{
						instance.info = RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
					}
					break;
				case 18:
					instance.mugshotData = ProtocolParser.ReadPooledBytes(stream);
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				case -1:
					return instance;
				}
			}
		}

		public static RelationshipData DeserializeLengthDelimited(BufferStream stream, RelationshipData instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					if (instance.info == null)
					{
						instance.info = RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
					}
					break;
				case 18:
					instance.mugshotData = ProtocolParser.ReadPooledBytes(stream);
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static RelationshipData DeserializeLength(BufferStream stream, int length, RelationshipData instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					if (instance.info == null)
					{
						instance.info = RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream);
					}
					else
					{
						RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
					}
					break;
				case 18:
					instance.mugshotData = ProtocolParser.ReadPooledBytes(stream);
					break;
				default:
				{
					Key key = ProtocolParser.ReadKey((byte)num2, stream);
					_ = key.Field;
					ProtocolParser.SkipKey(stream, key);
					break;
				}
				}
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, RelationshipData instance, RelationshipData previous)
		{
			if (instance.info == null)
			{
				throw new ArgumentNullException("info", "Required by proto specification.");
			}
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			RelationshipManager.PlayerRelationshipInfo.SerializeDelta(stream, instance.info, previous.info);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
			if (instance.mugshotData.Array != null)
			{
				stream.WriteByte(18);
				ProtocolParser.WritePooledBytes(stream, instance.mugshotData);
			}
		}

		public static void Serialize(BufferStream stream, RelationshipData instance)
		{
			if (instance.info == null)
			{
				throw new ArgumentNullException("info", "Required by proto specification.");
			}
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			RelationshipManager.PlayerRelationshipInfo.Serialize(stream, instance.info);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
			if (instance.mugshotData.Array != null)
			{
				stream.WriteByte(18);
				ProtocolParser.WritePooledBytes(stream, instance.mugshotData);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
			info?.InspectUids(action);
		}
	}

	[NonSerialized]
	public ulong userId;

	[NonSerialized]
	public PlayerState playerState;

	[NonSerialized]
	public List<RelationshipData> relationships;

	[NonSerialized]
	public ulong teamId;

	[NonSerialized]
	public bool isTeamLeader;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerSecondaryData instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.userId = 0uL;
		if (instance.playerState != null)
		{
			instance.playerState.ResetToPool();
			instance.playerState = null;
		}
		if (instance.relationships != null)
		{
			for (int i = 0; i < instance.relationships.Count; i++)
			{
				if (instance.relationships[i] != null)
				{
					instance.relationships[i].ResetToPool();
					instance.relationships[i] = null;
				}
			}
			List<RelationshipData> list = instance.relationships;
			Pool.Free<RelationshipData>(ref list, false);
			instance.relationships = list;
		}
		instance.teamId = 0uL;
		instance.isTeamLeader = false;
		Pool.Free<PlayerSecondaryData>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerSecondaryData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerSecondaryData instance)
	{
		instance.userId = userId;
		if (playerState != null)
		{
			if (instance.playerState == null)
			{
				instance.playerState = playerState.Copy();
			}
			else
			{
				playerState.CopyTo(instance.playerState);
			}
		}
		else
		{
			instance.playerState = null;
		}
		if (relationships != null)
		{
			instance.relationships = Pool.Get<List<RelationshipData>>();
			for (int i = 0; i < relationships.Count; i++)
			{
				RelationshipData item = relationships[i].Copy();
				instance.relationships.Add(item);
			}
		}
		else
		{
			instance.relationships = null;
		}
		instance.teamId = teamId;
		instance.isTeamLeader = isTeamLeader;
	}

	public PlayerSecondaryData Copy()
	{
		PlayerSecondaryData playerSecondaryData = Pool.Get<PlayerSecondaryData>();
		CopyTo(playerSecondaryData);
		return playerSecondaryData;
	}

	public static PlayerSecondaryData Deserialize(BufferStream stream)
	{
		PlayerSecondaryData playerSecondaryData = Pool.Get<PlayerSecondaryData>();
		Deserialize(stream, playerSecondaryData, isDelta: false);
		return playerSecondaryData;
	}

	public static PlayerSecondaryData DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerSecondaryData playerSecondaryData = Pool.Get<PlayerSecondaryData>();
		DeserializeLengthDelimited(stream, playerSecondaryData, isDelta: false);
		return playerSecondaryData;
	}

	public static PlayerSecondaryData DeserializeLength(BufferStream stream, int length)
	{
		PlayerSecondaryData playerSecondaryData = Pool.Get<PlayerSecondaryData>();
		DeserializeLength(stream, length, playerSecondaryData, isDelta: false);
		return playerSecondaryData;
	}

	public static PlayerSecondaryData Deserialize(byte[] buffer)
	{
		PlayerSecondaryData playerSecondaryData = Pool.Get<PlayerSecondaryData>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerSecondaryData, isDelta: false);
		return playerSecondaryData;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerSecondaryData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerSecondaryData Deserialize(BufferStream stream, PlayerSecondaryData instance, bool isDelta)
	{
		if (!isDelta && instance.relationships == null)
		{
			instance.relationships = Pool.Get<List<RelationshipData>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.playerState == null)
				{
					instance.playerState = PlayerState.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerState.DeserializeLengthDelimited(stream, instance.playerState, isDelta);
				}
				break;
			case 26:
				instance.relationships.Add(RelationshipData.DeserializeLengthDelimited(stream));
				break;
			case 32:
				instance.teamId = ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.isTeamLeader = ProtocolParser.ReadBool(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static PlayerSecondaryData DeserializeLengthDelimited(BufferStream stream, PlayerSecondaryData instance, bool isDelta)
	{
		if (!isDelta && instance.relationships == null)
		{
			instance.relationships = Pool.Get<List<RelationshipData>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.playerState == null)
				{
					instance.playerState = PlayerState.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerState.DeserializeLengthDelimited(stream, instance.playerState, isDelta);
				}
				break;
			case 26:
				instance.relationships.Add(RelationshipData.DeserializeLengthDelimited(stream));
				break;
			case 32:
				instance.teamId = ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.isTeamLeader = ProtocolParser.ReadBool(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerSecondaryData DeserializeLength(BufferStream stream, int length, PlayerSecondaryData instance, bool isDelta)
	{
		if (!isDelta && instance.relationships == null)
		{
			instance.relationships = Pool.Get<List<RelationshipData>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.playerState == null)
				{
					instance.playerState = PlayerState.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerState.DeserializeLengthDelimited(stream, instance.playerState, isDelta);
				}
				break;
			case 26:
				instance.relationships.Add(RelationshipData.DeserializeLengthDelimited(stream));
				break;
			case 32:
				instance.teamId = ProtocolParser.ReadUInt64(stream);
				break;
			case 40:
				instance.isTeamLeader = ProtocolParser.ReadBool(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerSecondaryData instance, PlayerSecondaryData previous)
	{
		if (instance.userId != previous.userId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		if (instance.playerState != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerState.SerializeDelta(stream, instance.playerState, previous.playerState);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.relationships != null)
		{
			for (int i = 0; i < instance.relationships.Count; i++)
			{
				RelationshipData relationshipData = instance.relationships[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				RelationshipData.SerializeDelta(stream, relationshipData, relationshipData);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.teamId != previous.teamId)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.teamId);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.isTeamLeader);
	}

	public static void Serialize(BufferStream stream, PlayerSecondaryData instance)
	{
		if (instance.userId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		if (instance.playerState != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerState.Serialize(stream, instance.playerState);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.relationships != null)
		{
			for (int i = 0; i < instance.relationships.Count; i++)
			{
				RelationshipData instance2 = instance.relationships[i];
				stream.WriteByte(26);
				BufferStream.RangeHandle range2 = stream.GetRange(5);
				int position2 = stream.Position;
				RelationshipData.Serialize(stream, instance2);
				int val2 = stream.Position - position2;
				Span<byte> span2 = range2.GetSpan();
				int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
				if (num2 < 5)
				{
					span2[num2 - 1] |= 128;
					while (num2 < 4)
					{
						span2[num2++] = 128;
					}
					span2[4] = 0;
				}
			}
		}
		if (instance.teamId != 0L)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.teamId);
		}
		if (instance.isTeamLeader)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.isTeamLeader);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		playerState?.InspectUids(action);
		if (relationships != null)
		{
			for (int i = 0; i < relationships.Count; i++)
			{
				relationships[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class SpawnOptionsRequest : IDisposable, IPooled, IProto<SpawnOptionsRequest>, IProto
{
	[NonSerialized]
	public ulong userId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SpawnOptionsRequest instance)
	{
		if (instance.ShouldPool)
		{
			instance.userId = 0uL;
			Pool.Free<SpawnOptionsRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SpawnOptionsRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SpawnOptionsRequest instance)
	{
		instance.userId = userId;
	}

	public SpawnOptionsRequest Copy()
	{
		SpawnOptionsRequest spawnOptionsRequest = Pool.Get<SpawnOptionsRequest>();
		CopyTo(spawnOptionsRequest);
		return spawnOptionsRequest;
	}

	public static SpawnOptionsRequest Deserialize(BufferStream stream)
	{
		SpawnOptionsRequest spawnOptionsRequest = Pool.Get<SpawnOptionsRequest>();
		Deserialize(stream, spawnOptionsRequest, isDelta: false);
		return spawnOptionsRequest;
	}

	public static SpawnOptionsRequest DeserializeLengthDelimited(BufferStream stream)
	{
		SpawnOptionsRequest spawnOptionsRequest = Pool.Get<SpawnOptionsRequest>();
		DeserializeLengthDelimited(stream, spawnOptionsRequest, isDelta: false);
		return spawnOptionsRequest;
	}

	public static SpawnOptionsRequest DeserializeLength(BufferStream stream, int length)
	{
		SpawnOptionsRequest spawnOptionsRequest = Pool.Get<SpawnOptionsRequest>();
		DeserializeLength(stream, length, spawnOptionsRequest, isDelta: false);
		return spawnOptionsRequest;
	}

	public static SpawnOptionsRequest Deserialize(byte[] buffer)
	{
		SpawnOptionsRequest spawnOptionsRequest = Pool.Get<SpawnOptionsRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spawnOptionsRequest, isDelta: false);
		return spawnOptionsRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SpawnOptionsRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SpawnOptionsRequest Deserialize(BufferStream stream, SpawnOptionsRequest instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SpawnOptionsRequest DeserializeLengthDelimited(BufferStream stream, SpawnOptionsRequest instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SpawnOptionsRequest DeserializeLength(BufferStream stream, int length, SpawnOptionsRequest instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SpawnOptionsRequest instance, SpawnOptionsRequest previous)
	{
		if (instance.userId != previous.userId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
	}

	public static void Serialize(BufferStream stream, SpawnOptionsRequest instance)
	{
		if (instance.userId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class SpawnOptionsResponse : IDisposable, IPooled, IProto<SpawnOptionsResponse>, IProto
{
	[NonSerialized]
	public List<RespawnInformation.SpawnOptions> spawnOptions;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SpawnOptionsResponse instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.spawnOptions != null)
		{
			for (int i = 0; i < instance.spawnOptions.Count; i++)
			{
				if (instance.spawnOptions[i] != null)
				{
					instance.spawnOptions[i].ResetToPool();
					instance.spawnOptions[i] = null;
				}
			}
			List<RespawnInformation.SpawnOptions> list = instance.spawnOptions;
			Pool.Free<RespawnInformation.SpawnOptions>(ref list, false);
			instance.spawnOptions = list;
		}
		Pool.Free<SpawnOptionsResponse>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SpawnOptionsResponse with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SpawnOptionsResponse instance)
	{
		if (spawnOptions != null)
		{
			instance.spawnOptions = Pool.Get<List<RespawnInformation.SpawnOptions>>();
			for (int i = 0; i < spawnOptions.Count; i++)
			{
				RespawnInformation.SpawnOptions item = spawnOptions[i].Copy();
				instance.spawnOptions.Add(item);
			}
		}
		else
		{
			instance.spawnOptions = null;
		}
	}

	public SpawnOptionsResponse Copy()
	{
		SpawnOptionsResponse spawnOptionsResponse = Pool.Get<SpawnOptionsResponse>();
		CopyTo(spawnOptionsResponse);
		return spawnOptionsResponse;
	}

	public static SpawnOptionsResponse Deserialize(BufferStream stream)
	{
		SpawnOptionsResponse spawnOptionsResponse = Pool.Get<SpawnOptionsResponse>();
		Deserialize(stream, spawnOptionsResponse, isDelta: false);
		return spawnOptionsResponse;
	}

	public static SpawnOptionsResponse DeserializeLengthDelimited(BufferStream stream)
	{
		SpawnOptionsResponse spawnOptionsResponse = Pool.Get<SpawnOptionsResponse>();
		DeserializeLengthDelimited(stream, spawnOptionsResponse, isDelta: false);
		return spawnOptionsResponse;
	}

	public static SpawnOptionsResponse DeserializeLength(BufferStream stream, int length)
	{
		SpawnOptionsResponse spawnOptionsResponse = Pool.Get<SpawnOptionsResponse>();
		DeserializeLength(stream, length, spawnOptionsResponse, isDelta: false);
		return spawnOptionsResponse;
	}

	public static SpawnOptionsResponse Deserialize(byte[] buffer)
	{
		SpawnOptionsResponse spawnOptionsResponse = Pool.Get<SpawnOptionsResponse>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spawnOptionsResponse, isDelta: false);
		return spawnOptionsResponse;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SpawnOptionsResponse previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SpawnOptionsResponse Deserialize(BufferStream stream, SpawnOptionsResponse instance, bool isDelta)
	{
		if (!isDelta && instance.spawnOptions == null)
		{
			instance.spawnOptions = Pool.Get<List<RespawnInformation.SpawnOptions>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.spawnOptions.Add(RespawnInformation.SpawnOptions.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SpawnOptionsResponse DeserializeLengthDelimited(BufferStream stream, SpawnOptionsResponse instance, bool isDelta)
	{
		if (!isDelta && instance.spawnOptions == null)
		{
			instance.spawnOptions = Pool.Get<List<RespawnInformation.SpawnOptions>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.spawnOptions.Add(RespawnInformation.SpawnOptions.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SpawnOptionsResponse DeserializeLength(BufferStream stream, int length, SpawnOptionsResponse instance, bool isDelta)
	{
		if (!isDelta && instance.spawnOptions == null)
		{
			instance.spawnOptions = Pool.Get<List<RespawnInformation.SpawnOptions>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.spawnOptions.Add(RespawnInformation.SpawnOptions.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SpawnOptionsResponse instance, SpawnOptionsResponse previous)
	{
		if (instance.spawnOptions == null)
		{
			return;
		}
		for (int i = 0; i < instance.spawnOptions.Count; i++)
		{
			RespawnInformation.SpawnOptions spawnOptions = instance.spawnOptions[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			RespawnInformation.SpawnOptions.SerializeDelta(stream, spawnOptions, spawnOptions);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, SpawnOptionsResponse instance)
	{
		if (instance.spawnOptions == null)
		{
			return;
		}
		for (int i = 0; i < instance.spawnOptions.Count; i++)
		{
			RespawnInformation.SpawnOptions instance2 = instance.spawnOptions[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			RespawnInformation.SpawnOptions.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (spawnOptions != null)
		{
			for (int i = 0; i < spawnOptions.Count; i++)
			{
				spawnOptions[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class SleepingBagRespawnRequest : IDisposable, IPooled, IProto<SleepingBagRespawnRequest>, IProto
{
	[NonSerialized]
	public ulong userId;

	[NonSerialized]
	public NetworkableId sleepingBagId;

	[NonSerialized]
	public PlayerSecondaryData secondaryData;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SleepingBagRespawnRequest instance)
	{
		if (instance.ShouldPool)
		{
			instance.userId = 0uL;
			instance.sleepingBagId = default(NetworkableId);
			if (instance.secondaryData != null)
			{
				instance.secondaryData.ResetToPool();
				instance.secondaryData = null;
			}
			Pool.Free<SleepingBagRespawnRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SleepingBagRespawnRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SleepingBagRespawnRequest instance)
	{
		instance.userId = userId;
		instance.sleepingBagId = sleepingBagId;
		if (secondaryData != null)
		{
			if (instance.secondaryData == null)
			{
				instance.secondaryData = secondaryData.Copy();
			}
			else
			{
				secondaryData.CopyTo(instance.secondaryData);
			}
		}
		else
		{
			instance.secondaryData = null;
		}
	}

	public SleepingBagRespawnRequest Copy()
	{
		SleepingBagRespawnRequest sleepingBagRespawnRequest = Pool.Get<SleepingBagRespawnRequest>();
		CopyTo(sleepingBagRespawnRequest);
		return sleepingBagRespawnRequest;
	}

	public static SleepingBagRespawnRequest Deserialize(BufferStream stream)
	{
		SleepingBagRespawnRequest sleepingBagRespawnRequest = Pool.Get<SleepingBagRespawnRequest>();
		Deserialize(stream, sleepingBagRespawnRequest, isDelta: false);
		return sleepingBagRespawnRequest;
	}

	public static SleepingBagRespawnRequest DeserializeLengthDelimited(BufferStream stream)
	{
		SleepingBagRespawnRequest sleepingBagRespawnRequest = Pool.Get<SleepingBagRespawnRequest>();
		DeserializeLengthDelimited(stream, sleepingBagRespawnRequest, isDelta: false);
		return sleepingBagRespawnRequest;
	}

	public static SleepingBagRespawnRequest DeserializeLength(BufferStream stream, int length)
	{
		SleepingBagRespawnRequest sleepingBagRespawnRequest = Pool.Get<SleepingBagRespawnRequest>();
		DeserializeLength(stream, length, sleepingBagRespawnRequest, isDelta: false);
		return sleepingBagRespawnRequest;
	}

	public static SleepingBagRespawnRequest Deserialize(byte[] buffer)
	{
		SleepingBagRespawnRequest sleepingBagRespawnRequest = Pool.Get<SleepingBagRespawnRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sleepingBagRespawnRequest, isDelta: false);
		return sleepingBagRespawnRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SleepingBagRespawnRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SleepingBagRespawnRequest Deserialize(BufferStream stream, SleepingBagRespawnRequest instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.sleepingBagId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 26:
				if (instance.secondaryData == null)
				{
					instance.secondaryData = PlayerSecondaryData.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerSecondaryData.DeserializeLengthDelimited(stream, instance.secondaryData, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static SleepingBagRespawnRequest DeserializeLengthDelimited(BufferStream stream, SleepingBagRespawnRequest instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.sleepingBagId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 26:
				if (instance.secondaryData == null)
				{
					instance.secondaryData = PlayerSecondaryData.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerSecondaryData.DeserializeLengthDelimited(stream, instance.secondaryData, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SleepingBagRespawnRequest DeserializeLength(BufferStream stream, int length, SleepingBagRespawnRequest instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				break;
			case 16:
				instance.sleepingBagId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				break;
			case 26:
				if (instance.secondaryData == null)
				{
					instance.secondaryData = PlayerSecondaryData.DeserializeLengthDelimited(stream);
				}
				else
				{
					PlayerSecondaryData.DeserializeLengthDelimited(stream, instance.secondaryData, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SleepingBagRespawnRequest instance, SleepingBagRespawnRequest previous)
	{
		if (instance.userId != previous.userId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.sleepingBagId.Value);
		if (instance.secondaryData == null)
		{
			throw new ArgumentNullException("secondaryData", "Required by proto specification.");
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		PlayerSecondaryData.SerializeDelta(stream, instance.secondaryData, previous.secondaryData);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public static void Serialize(BufferStream stream, SleepingBagRespawnRequest instance)
	{
		if (instance.userId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		if (instance.sleepingBagId != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.sleepingBagId.Value);
		}
		if (instance.secondaryData == null)
		{
			throw new ArgumentNullException("secondaryData", "Required by proto specification.");
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		PlayerSecondaryData.Serialize(stream, instance.secondaryData);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref sleepingBagId.Value);
		secondaryData?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class SleepingBagDestroyRequest : IDisposable, IPooled, IProto<SleepingBagDestroyRequest>, IProto
{
	[NonSerialized]
	public ulong userId;

	[NonSerialized]
	public NetworkableId sleepingBagId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SleepingBagDestroyRequest instance)
	{
		if (instance.ShouldPool)
		{
			instance.userId = 0uL;
			instance.sleepingBagId = default(NetworkableId);
			Pool.Free<SleepingBagDestroyRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SleepingBagDestroyRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SleepingBagDestroyRequest instance)
	{
		instance.userId = userId;
		instance.sleepingBagId = sleepingBagId;
	}

	public SleepingBagDestroyRequest Copy()
	{
		SleepingBagDestroyRequest sleepingBagDestroyRequest = Pool.Get<SleepingBagDestroyRequest>();
		CopyTo(sleepingBagDestroyRequest);
		return sleepingBagDestroyRequest;
	}

	public static SleepingBagDestroyRequest Deserialize(BufferStream stream)
	{
		SleepingBagDestroyRequest sleepingBagDestroyRequest = Pool.Get<SleepingBagDestroyRequest>();
		Deserialize(stream, sleepingBagDestroyRequest, isDelta: false);
		return sleepingBagDestroyRequest;
	}

	public static SleepingBagDestroyRequest DeserializeLengthDelimited(BufferStream stream)
	{
		SleepingBagDestroyRequest sleepingBagDestroyRequest = Pool.Get<SleepingBagDestroyRequest>();
		DeserializeLengthDelimited(stream, sleepingBagDestroyRequest, isDelta: false);
		return sleepingBagDestroyRequest;
	}

	public static SleepingBagDestroyRequest DeserializeLength(BufferStream stream, int length)
	{
		SleepingBagDestroyRequest sleepingBagDestroyRequest = Pool.Get<SleepingBagDestroyRequest>();
		DeserializeLength(stream, length, sleepingBagDestroyRequest, isDelta: false);
		return sleepingBagDestroyRequest;
	}

	public static SleepingBagDestroyRequest Deserialize(byte[] buffer)
	{
		SleepingBagDestroyRequest sleepingBagDestroyRequest = Pool.Get<SleepingBagDestroyRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sleepingBagDestroyRequest, isDelta: false);
		return sleepingBagDestroyRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SleepingBagDestroyRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SleepingBagDestroyRequest Deserialize(BufferStream stream, SleepingBagDestroyRequest instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.sleepingBagId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SleepingBagDestroyRequest DeserializeLengthDelimited(BufferStream stream, SleepingBagDestroyRequest instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.sleepingBagId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SleepingBagDestroyRequest DeserializeLength(BufferStream stream, int length, SleepingBagDestroyRequest instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.sleepingBagId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SleepingBagDestroyRequest instance, SleepingBagDestroyRequest previous)
	{
		if (instance.userId != previous.userId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.sleepingBagId.Value);
	}

	public static void Serialize(BufferStream stream, SleepingBagDestroyRequest instance)
	{
		if (instance.userId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		if (instance.sleepingBagId != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.sleepingBagId.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref sleepingBagId.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class FerryStatusRequest : IDisposable, IPooled, IProto<FerryStatusRequest>, IProto
{
	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(FerryStatusRequest instance)
	{
		if (instance.ShouldPool)
		{
			Pool.Free<FerryStatusRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose FerryStatusRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(FerryStatusRequest instance)
	{
	}

	public FerryStatusRequest Copy()
	{
		FerryStatusRequest ferryStatusRequest = Pool.Get<FerryStatusRequest>();
		CopyTo(ferryStatusRequest);
		return ferryStatusRequest;
	}

	public static FerryStatusRequest Deserialize(BufferStream stream)
	{
		FerryStatusRequest ferryStatusRequest = Pool.Get<FerryStatusRequest>();
		Deserialize(stream, ferryStatusRequest, isDelta: false);
		return ferryStatusRequest;
	}

	public static FerryStatusRequest DeserializeLengthDelimited(BufferStream stream)
	{
		FerryStatusRequest ferryStatusRequest = Pool.Get<FerryStatusRequest>();
		DeserializeLengthDelimited(stream, ferryStatusRequest, isDelta: false);
		return ferryStatusRequest;
	}

	public static FerryStatusRequest DeserializeLength(BufferStream stream, int length)
	{
		FerryStatusRequest ferryStatusRequest = Pool.Get<FerryStatusRequest>();
		DeserializeLength(stream, length, ferryStatusRequest, isDelta: false);
		return ferryStatusRequest;
	}

	public static FerryStatusRequest Deserialize(byte[] buffer)
	{
		FerryStatusRequest ferryStatusRequest = Pool.Get<FerryStatusRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ferryStatusRequest, isDelta: false);
		return ferryStatusRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, FerryStatusRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static FerryStatusRequest Deserialize(BufferStream stream, FerryStatusRequest instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			if (num == -1)
			{
				break;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static FerryStatusRequest DeserializeLengthDelimited(BufferStream stream, FerryStatusRequest instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static FerryStatusRequest DeserializeLength(BufferStream stream, int length, FerryStatusRequest instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (true)
		{
			if (stream.Position >= num)
			{
				if (stream.Position == num)
				{
					break;
				}
				throw new ProtocolBufferException("Read past max limit");
			}
			int num2 = stream.ReadByte();
			if (num2 == -1)
			{
				throw new EndOfStreamException();
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, FerryStatusRequest instance, FerryStatusRequest previous)
	{
	}

	public static void Serialize(BufferStream stream, FerryStatusRequest instance)
	{
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class FerryStatusResponse : IDisposable, IPooled, IProto<FerryStatusResponse>, IProto
{
	[NonSerialized]
	public List<FerryStatus> statuses;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(FerryStatusResponse instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.statuses != null)
		{
			for (int i = 0; i < instance.statuses.Count; i++)
			{
				if (instance.statuses[i] != null)
				{
					instance.statuses[i].ResetToPool();
					instance.statuses[i] = null;
				}
			}
			List<FerryStatus> list = instance.statuses;
			Pool.Free<FerryStatus>(ref list, false);
			instance.statuses = list;
		}
		Pool.Free<FerryStatusResponse>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose FerryStatusResponse with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(FerryStatusResponse instance)
	{
		if (statuses != null)
		{
			instance.statuses = Pool.Get<List<FerryStatus>>();
			for (int i = 0; i < statuses.Count; i++)
			{
				FerryStatus item = statuses[i].Copy();
				instance.statuses.Add(item);
			}
		}
		else
		{
			instance.statuses = null;
		}
	}

	public FerryStatusResponse Copy()
	{
		FerryStatusResponse ferryStatusResponse = Pool.Get<FerryStatusResponse>();
		CopyTo(ferryStatusResponse);
		return ferryStatusResponse;
	}

	public static FerryStatusResponse Deserialize(BufferStream stream)
	{
		FerryStatusResponse ferryStatusResponse = Pool.Get<FerryStatusResponse>();
		Deserialize(stream, ferryStatusResponse, isDelta: false);
		return ferryStatusResponse;
	}

	public static FerryStatusResponse DeserializeLengthDelimited(BufferStream stream)
	{
		FerryStatusResponse ferryStatusResponse = Pool.Get<FerryStatusResponse>();
		DeserializeLengthDelimited(stream, ferryStatusResponse, isDelta: false);
		return ferryStatusResponse;
	}

	public static FerryStatusResponse DeserializeLength(BufferStream stream, int length)
	{
		FerryStatusResponse ferryStatusResponse = Pool.Get<FerryStatusResponse>();
		DeserializeLength(stream, length, ferryStatusResponse, isDelta: false);
		return ferryStatusResponse;
	}

	public static FerryStatusResponse Deserialize(byte[] buffer)
	{
		FerryStatusResponse ferryStatusResponse = Pool.Get<FerryStatusResponse>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ferryStatusResponse, isDelta: false);
		return ferryStatusResponse;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, FerryStatusResponse previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static FerryStatusResponse Deserialize(BufferStream stream, FerryStatusResponse instance, bool isDelta)
	{
		if (!isDelta && instance.statuses == null)
		{
			instance.statuses = Pool.Get<List<FerryStatus>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.statuses.Add(FerryStatus.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static FerryStatusResponse DeserializeLengthDelimited(BufferStream stream, FerryStatusResponse instance, bool isDelta)
	{
		if (!isDelta && instance.statuses == null)
		{
			instance.statuses = Pool.Get<List<FerryStatus>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.statuses.Add(FerryStatus.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static FerryStatusResponse DeserializeLength(BufferStream stream, int length, FerryStatusResponse instance, bool isDelta)
	{
		if (!isDelta && instance.statuses == null)
		{
			instance.statuses = Pool.Get<List<FerryStatus>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.statuses.Add(FerryStatus.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, FerryStatusResponse instance, FerryStatusResponse previous)
	{
		if (instance.statuses == null)
		{
			return;
		}
		for (int i = 0; i < instance.statuses.Count; i++)
		{
			FerryStatus ferryStatus = instance.statuses[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			FerryStatus.SerializeDelta(stream, ferryStatus, ferryStatus);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, FerryStatusResponse instance)
	{
		if (instance.statuses == null)
		{
			return;
		}
		for (int i = 0; i < instance.statuses.Count; i++)
		{
			FerryStatus instance2 = instance.statuses[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			FerryStatus.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (statuses != null)
		{
			for (int i = 0; i < statuses.Count; i++)
			{
				statuses[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class FerryStatus : IDisposable, IPooled, IProto<FerryStatus>, IProto
{
	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public long timestamp;

	[NonSerialized]
	public string ownerZone;

	[NonSerialized]
	public List<string> schedule;

	[NonSerialized]
	public int scheduleIndex;

	[NonSerialized]
	public int state;

	[NonSerialized]
	public bool isRetiring;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(FerryStatus instance)
	{
		if (instance.ShouldPool)
		{
			instance.entityId = default(NetworkableId);
			instance.timestamp = 0L;
			instance.ownerZone = string.Empty;
			if (instance.schedule != null)
			{
				List<string> list = instance.schedule;
				Pool.FreeUnmanaged<string>(ref list);
				instance.schedule = list;
			}
			instance.scheduleIndex = 0;
			instance.state = 0;
			instance.isRetiring = false;
			Pool.Free<FerryStatus>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose FerryStatus with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(FerryStatus instance)
	{
		instance.entityId = entityId;
		instance.timestamp = timestamp;
		instance.ownerZone = ownerZone;
		if (schedule != null)
		{
			instance.schedule = Pool.Get<List<string>>();
			for (int i = 0; i < schedule.Count; i++)
			{
				string item = schedule[i];
				instance.schedule.Add(item);
			}
		}
		else
		{
			instance.schedule = null;
		}
		instance.scheduleIndex = scheduleIndex;
		instance.state = state;
		instance.isRetiring = isRetiring;
	}

	public FerryStatus Copy()
	{
		FerryStatus ferryStatus = Pool.Get<FerryStatus>();
		CopyTo(ferryStatus);
		return ferryStatus;
	}

	public static FerryStatus Deserialize(BufferStream stream)
	{
		FerryStatus ferryStatus = Pool.Get<FerryStatus>();
		Deserialize(stream, ferryStatus, isDelta: false);
		return ferryStatus;
	}

	public static FerryStatus DeserializeLengthDelimited(BufferStream stream)
	{
		FerryStatus ferryStatus = Pool.Get<FerryStatus>();
		DeserializeLengthDelimited(stream, ferryStatus, isDelta: false);
		return ferryStatus;
	}

	public static FerryStatus DeserializeLength(BufferStream stream, int length)
	{
		FerryStatus ferryStatus = Pool.Get<FerryStatus>();
		DeserializeLength(stream, length, ferryStatus, isDelta: false);
		return ferryStatus;
	}

	public static FerryStatus Deserialize(byte[] buffer)
	{
		FerryStatus ferryStatus = Pool.Get<FerryStatus>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ferryStatus, isDelta: false);
		return ferryStatus;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, FerryStatus previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static FerryStatus Deserialize(BufferStream stream, FerryStatus instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<string>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.ownerZone = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case 40:
				instance.scheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.isRetiring = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static FerryStatus DeserializeLengthDelimited(BufferStream stream, FerryStatus instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<string>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.ownerZone = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case 40:
				instance.scheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.isRetiring = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static FerryStatus DeserializeLength(BufferStream stream, int length, FerryStatus instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<string>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.ownerZone = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case 40:
				instance.scheduleIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.isRetiring = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, FerryStatus instance, FerryStatus previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		if (instance.ownerZone != previous.ownerZone)
		{
			if (instance.ownerZone == null)
			{
				throw new ArgumentNullException("ownerZone", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.ownerZone);
		}
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				string val = instance.schedule[i];
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.scheduleIndex != previous.scheduleIndex)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scheduleIndex);
		}
		if (instance.state != previous.state)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.isRetiring);
	}

	public static void Serialize(BufferStream stream, FerryStatus instance)
	{
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
		if (instance.ownerZone == null)
		{
			throw new ArgumentNullException("ownerZone", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.ownerZone);
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				string val = instance.schedule[i];
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, val);
			}
		}
		if (instance.scheduleIndex != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scheduleIndex);
		}
		if (instance.state != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.isRetiring)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.isRetiring);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class FerryRetireRequest : IDisposable, IPooled, IProto<FerryRetireRequest>, IProto
{
	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public long timestamp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(FerryRetireRequest instance)
	{
		if (instance.ShouldPool)
		{
			instance.entityId = default(NetworkableId);
			instance.timestamp = 0L;
			Pool.Free<FerryRetireRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose FerryRetireRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(FerryRetireRequest instance)
	{
		instance.entityId = entityId;
		instance.timestamp = timestamp;
	}

	public FerryRetireRequest Copy()
	{
		FerryRetireRequest ferryRetireRequest = Pool.Get<FerryRetireRequest>();
		CopyTo(ferryRetireRequest);
		return ferryRetireRequest;
	}

	public static FerryRetireRequest Deserialize(BufferStream stream)
	{
		FerryRetireRequest ferryRetireRequest = Pool.Get<FerryRetireRequest>();
		Deserialize(stream, ferryRetireRequest, isDelta: false);
		return ferryRetireRequest;
	}

	public static FerryRetireRequest DeserializeLengthDelimited(BufferStream stream)
	{
		FerryRetireRequest ferryRetireRequest = Pool.Get<FerryRetireRequest>();
		DeserializeLengthDelimited(stream, ferryRetireRequest, isDelta: false);
		return ferryRetireRequest;
	}

	public static FerryRetireRequest DeserializeLength(BufferStream stream, int length)
	{
		FerryRetireRequest ferryRetireRequest = Pool.Get<FerryRetireRequest>();
		DeserializeLength(stream, length, ferryRetireRequest, isDelta: false);
		return ferryRetireRequest;
	}

	public static FerryRetireRequest Deserialize(byte[] buffer)
	{
		FerryRetireRequest ferryRetireRequest = Pool.Get<FerryRetireRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ferryRetireRequest, isDelta: false);
		return ferryRetireRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, FerryRetireRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static FerryRetireRequest Deserialize(BufferStream stream, FerryRetireRequest instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static FerryRetireRequest DeserializeLengthDelimited(BufferStream stream, FerryRetireRequest instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static FerryRetireRequest DeserializeLength(BufferStream stream, int length, FerryRetireRequest instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, FerryRetireRequest instance, FerryRetireRequest previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
	}

	public static void Serialize(BufferStream stream, FerryRetireRequest instance)
	{
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class FerryUpdateScheduleRequest : IDisposable, IPooled, IProto<FerryUpdateScheduleRequest>, IProto
{
	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public long timestamp;

	[NonSerialized]
	public List<string> schedule;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(FerryUpdateScheduleRequest instance)
	{
		if (instance.ShouldPool)
		{
			instance.entityId = default(NetworkableId);
			instance.timestamp = 0L;
			if (instance.schedule != null)
			{
				List<string> list = instance.schedule;
				Pool.FreeUnmanaged<string>(ref list);
				instance.schedule = list;
			}
			Pool.Free<FerryUpdateScheduleRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose FerryUpdateScheduleRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(FerryUpdateScheduleRequest instance)
	{
		instance.entityId = entityId;
		instance.timestamp = timestamp;
		if (schedule != null)
		{
			instance.schedule = Pool.Get<List<string>>();
			for (int i = 0; i < schedule.Count; i++)
			{
				string item = schedule[i];
				instance.schedule.Add(item);
			}
		}
		else
		{
			instance.schedule = null;
		}
	}

	public FerryUpdateScheduleRequest Copy()
	{
		FerryUpdateScheduleRequest ferryUpdateScheduleRequest = Pool.Get<FerryUpdateScheduleRequest>();
		CopyTo(ferryUpdateScheduleRequest);
		return ferryUpdateScheduleRequest;
	}

	public static FerryUpdateScheduleRequest Deserialize(BufferStream stream)
	{
		FerryUpdateScheduleRequest ferryUpdateScheduleRequest = Pool.Get<FerryUpdateScheduleRequest>();
		Deserialize(stream, ferryUpdateScheduleRequest, isDelta: false);
		return ferryUpdateScheduleRequest;
	}

	public static FerryUpdateScheduleRequest DeserializeLengthDelimited(BufferStream stream)
	{
		FerryUpdateScheduleRequest ferryUpdateScheduleRequest = Pool.Get<FerryUpdateScheduleRequest>();
		DeserializeLengthDelimited(stream, ferryUpdateScheduleRequest, isDelta: false);
		return ferryUpdateScheduleRequest;
	}

	public static FerryUpdateScheduleRequest DeserializeLength(BufferStream stream, int length)
	{
		FerryUpdateScheduleRequest ferryUpdateScheduleRequest = Pool.Get<FerryUpdateScheduleRequest>();
		DeserializeLength(stream, length, ferryUpdateScheduleRequest, isDelta: false);
		return ferryUpdateScheduleRequest;
	}

	public static FerryUpdateScheduleRequest Deserialize(byte[] buffer)
	{
		FerryUpdateScheduleRequest ferryUpdateScheduleRequest = Pool.Get<FerryUpdateScheduleRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, ferryUpdateScheduleRequest, isDelta: false);
		return ferryUpdateScheduleRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, FerryUpdateScheduleRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static FerryUpdateScheduleRequest Deserialize(BufferStream stream, FerryUpdateScheduleRequest instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<string>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static FerryUpdateScheduleRequest DeserializeLengthDelimited(BufferStream stream, FerryUpdateScheduleRequest instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<string>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static FerryUpdateScheduleRequest DeserializeLength(BufferStream stream, int length, FerryUpdateScheduleRequest instance, bool isDelta)
	{
		if (!isDelta && instance.schedule == null)
		{
			instance.schedule = Pool.Get<List<string>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.schedule.Add(ProtocolParser.ReadString(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, FerryUpdateScheduleRequest instance, FerryUpdateScheduleRequest previous)
	{
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				string val = instance.schedule[i];
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, val);
			}
		}
	}

	public static void Serialize(BufferStream stream, FerryUpdateScheduleRequest instance)
	{
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
		if (instance.schedule != null)
		{
			for (int i = 0; i < instance.schedule.Count; i++)
			{
				string val = instance.schedule[i];
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, val);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class ClanChatBatchRequest : IDisposable, IPooled, IProto<ClanChatBatchRequest>, IProto
{
	public class Message : IDisposable, IPooled, IProto<Message>, IProto
	{
		[NonSerialized]
		public long clanId;

		[NonSerialized]
		public ulong userId;

		[NonSerialized]
		public string text;

		[NonSerialized]
		public string name;

		[NonSerialized]
		public long timestamp;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Message instance)
		{
			if (instance.ShouldPool)
			{
				instance.clanId = 0L;
				instance.userId = 0uL;
				instance.text = string.Empty;
				instance.name = string.Empty;
				instance.timestamp = 0L;
				Pool.Free<Message>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Message with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Message instance)
		{
			instance.clanId = clanId;
			instance.userId = userId;
			instance.text = text;
			instance.name = name;
			instance.timestamp = timestamp;
		}

		public Message Copy()
		{
			Message message = Pool.Get<Message>();
			CopyTo(message);
			return message;
		}

		public static Message Deserialize(BufferStream stream)
		{
			Message message = Pool.Get<Message>();
			Deserialize(stream, message, isDelta: false);
			return message;
		}

		public static Message DeserializeLengthDelimited(BufferStream stream)
		{
			Message message = Pool.Get<Message>();
			DeserializeLengthDelimited(stream, message, isDelta: false);
			return message;
		}

		public static Message DeserializeLength(BufferStream stream, int length)
		{
			Message message = Pool.Get<Message>();
			DeserializeLength(stream, length, message, isDelta: false);
			return message;
		}

		public static Message Deserialize(byte[] buffer)
		{
			Message message = Pool.Get<Message>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, message, isDelta: false);
			return message;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Message previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Message Deserialize(BufferStream stream, Message instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.userId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.text = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 40:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Message DeserializeLengthDelimited(BufferStream stream, Message instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.userId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.text = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 40:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Message DeserializeLength(BufferStream stream, int length, Message instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.userId = ProtocolParser.ReadUInt64(stream);
					continue;
				case 26:
					instance.text = ProtocolParser.ReadString(stream);
					continue;
				case 34:
					instance.name = ProtocolParser.ReadString(stream);
					continue;
				case 40:
					instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Message instance, Message previous)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
			if (instance.userId != previous.userId)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.userId);
			}
			if (instance.text != previous.text)
			{
				if (instance.text == null)
				{
					throw new ArgumentNullException("text", "Required by proto specification.");
				}
				stream.WriteByte(26);
				ProtocolParser.WriteString(stream, instance.text);
			}
			if (instance.name != previous.name)
			{
				if (instance.name == null)
				{
					throw new ArgumentNullException("name", "Required by proto specification.");
				}
				stream.WriteByte(34);
				ProtocolParser.WriteString(stream, instance.name);
			}
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}

		public static void Serialize(BufferStream stream, Message instance)
		{
			if (instance.clanId != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
			}
			if (instance.userId != 0L)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, instance.userId);
			}
			if (instance.text == null)
			{
				throw new ArgumentNullException("text", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.text);
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.name);
			if (instance.timestamp != 0L)
			{
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<Message> messages;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClanChatBatchRequest instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.messages != null)
		{
			for (int i = 0; i < instance.messages.Count; i++)
			{
				if (instance.messages[i] != null)
				{
					instance.messages[i].ResetToPool();
					instance.messages[i] = null;
				}
			}
			List<Message> list = instance.messages;
			Pool.Free<Message>(ref list, false);
			instance.messages = list;
		}
		Pool.Free<ClanChatBatchRequest>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClanChatBatchRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClanChatBatchRequest instance)
	{
		if (messages != null)
		{
			instance.messages = Pool.Get<List<Message>>();
			for (int i = 0; i < messages.Count; i++)
			{
				Message item = messages[i].Copy();
				instance.messages.Add(item);
			}
		}
		else
		{
			instance.messages = null;
		}
	}

	public ClanChatBatchRequest Copy()
	{
		ClanChatBatchRequest clanChatBatchRequest = Pool.Get<ClanChatBatchRequest>();
		CopyTo(clanChatBatchRequest);
		return clanChatBatchRequest;
	}

	public static ClanChatBatchRequest Deserialize(BufferStream stream)
	{
		ClanChatBatchRequest clanChatBatchRequest = Pool.Get<ClanChatBatchRequest>();
		Deserialize(stream, clanChatBatchRequest, isDelta: false);
		return clanChatBatchRequest;
	}

	public static ClanChatBatchRequest DeserializeLengthDelimited(BufferStream stream)
	{
		ClanChatBatchRequest clanChatBatchRequest = Pool.Get<ClanChatBatchRequest>();
		DeserializeLengthDelimited(stream, clanChatBatchRequest, isDelta: false);
		return clanChatBatchRequest;
	}

	public static ClanChatBatchRequest DeserializeLength(BufferStream stream, int length)
	{
		ClanChatBatchRequest clanChatBatchRequest = Pool.Get<ClanChatBatchRequest>();
		DeserializeLength(stream, length, clanChatBatchRequest, isDelta: false);
		return clanChatBatchRequest;
	}

	public static ClanChatBatchRequest Deserialize(byte[] buffer)
	{
		ClanChatBatchRequest clanChatBatchRequest = Pool.Get<ClanChatBatchRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, clanChatBatchRequest, isDelta: false);
		return clanChatBatchRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ClanChatBatchRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClanChatBatchRequest Deserialize(BufferStream stream, ClanChatBatchRequest instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<Message>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.messages.Add(Message.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClanChatBatchRequest DeserializeLengthDelimited(BufferStream stream, ClanChatBatchRequest instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<Message>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.messages.Add(Message.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClanChatBatchRequest DeserializeLength(BufferStream stream, int length, ClanChatBatchRequest instance, bool isDelta)
	{
		if (!isDelta && instance.messages == null)
		{
			instance.messages = Pool.Get<List<Message>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.messages.Add(Message.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ClanChatBatchRequest instance, ClanChatBatchRequest previous)
	{
		if (instance.messages == null)
		{
			return;
		}
		for (int i = 0; i < instance.messages.Count; i++)
		{
			Message message = instance.messages[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Message.SerializeDelta(stream, message, message);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, ClanChatBatchRequest instance)
	{
		if (instance.messages == null)
		{
			return;
		}
		for (int i = 0; i < instance.messages.Count; i++)
		{
			Message instance2 = instance.messages[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			Message.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (messages != null)
		{
			for (int i = 0; i < messages.Count; i++)
			{
				messages[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using ProtoBuf.Nexus;
using SilentOrbit.ProtocolBuffers;

public class PlayerManifestRequest : IDisposable, IPooled, IProto<PlayerManifestRequest>, IProto
{
	[NonSerialized]
	public List<ulong> userIds;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerManifestRequest instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.userIds != null)
			{
				List<ulong> list = instance.userIds;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.userIds = list;
			}
			Pool.Free<PlayerManifestRequest>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerManifestRequest with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerManifestRequest instance)
	{
		if (userIds != null)
		{
			instance.userIds = Pool.Get<List<ulong>>();
			for (int i = 0; i < userIds.Count; i++)
			{
				ulong item = userIds[i];
				instance.userIds.Add(item);
			}
		}
		else
		{
			instance.userIds = null;
		}
	}

	public PlayerManifestRequest Copy()
	{
		PlayerManifestRequest playerManifestRequest = Pool.Get<PlayerManifestRequest>();
		CopyTo(playerManifestRequest);
		return playerManifestRequest;
	}

	public static PlayerManifestRequest Deserialize(BufferStream stream)
	{
		PlayerManifestRequest playerManifestRequest = Pool.Get<PlayerManifestRequest>();
		Deserialize(stream, playerManifestRequest, isDelta: false);
		return playerManifestRequest;
	}

	public static PlayerManifestRequest DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerManifestRequest playerManifestRequest = Pool.Get<PlayerManifestRequest>();
		DeserializeLengthDelimited(stream, playerManifestRequest, isDelta: false);
		return playerManifestRequest;
	}

	public static PlayerManifestRequest DeserializeLength(BufferStream stream, int length)
	{
		PlayerManifestRequest playerManifestRequest = Pool.Get<PlayerManifestRequest>();
		DeserializeLength(stream, length, playerManifestRequest, isDelta: false);
		return playerManifestRequest;
	}

	public static PlayerManifestRequest Deserialize(byte[] buffer)
	{
		PlayerManifestRequest playerManifestRequest = Pool.Get<PlayerManifestRequest>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerManifestRequest, isDelta: false);
		return playerManifestRequest;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerManifestRequest previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerManifestRequest Deserialize(BufferStream stream, PlayerManifestRequest instance, bool isDelta)
	{
		if (!isDelta && instance.userIds == null)
		{
			instance.userIds = Pool.Get<List<ulong>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.userIds.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerManifestRequest DeserializeLengthDelimited(BufferStream stream, PlayerManifestRequest instance, bool isDelta)
	{
		if (!isDelta && instance.userIds == null)
		{
			instance.userIds = Pool.Get<List<ulong>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userIds.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerManifestRequest DeserializeLength(BufferStream stream, int length, PlayerManifestRequest instance, bool isDelta)
	{
		if (!isDelta && instance.userIds == null)
		{
			instance.userIds = Pool.Get<List<ulong>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userIds.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerManifestRequest instance, PlayerManifestRequest previous)
	{
		if (instance.userIds != null)
		{
			for (int i = 0; i < instance.userIds.Count; i++)
			{
				ulong val = instance.userIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public static void Serialize(BufferStream stream, PlayerManifestRequest instance)
	{
		if (instance.userIds != null)
		{
			for (int i = 0; i < instance.userIds.Count; i++)
			{
				ulong val = instance.userIds[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


public enum Flag
{
	Ducked = 1,
	Jumped = 2,
	OnGround = 4,
	Sleeping = 8,
	Sprinting = 0x10,
	OnLadder = 0x20,
	Flying = 0x40,
	Aiming = 0x80,
	Prone = 0x100,
	Mounted = 0x200,
	Relaxed = 0x400,
	OnPhone = 0x800,
	Crawling = 0x1000,
	Loading = 0x2000,
	HeadLook = 0x4000,
	HasParachute = 0x8000,
	Blocking = 0x10000,
	Ragdolling = 0x20000,
	Catching = 0x40000
}


using Facepunch;

public static class Shared
{
	public static int StartingCapacity = 64;

	public static int MaximumCapacity = 536870912;

	public static int MaximumPooledSize = 67108864;

	public static readonly ArrayPool<byte> ArrayPool = new ArrayPool<byte>(MaximumPooledSize);
}


using System;
using System.Runtime.CompilerServices;

public readonly ref struct RangeHandle
{
	private readonly BufferStream _stream;

	private readonly int _offset;

	private readonly int _length;

	public RangeHandle(BufferStream stream, int offset, int length)
	{
		if (offset < 0)
		{
			throw new ArgumentOutOfRangeException("offset");
		}
		if (length < 0)
		{
			throw new ArgumentOutOfRangeException("length");
		}
		_stream = stream ?? throw new ArgumentNullException("stream");
		_offset = offset;
		_length = length;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Span<byte> GetSpan()
	{
		return new Span<byte>(_stream._buffer, _offset, _length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ArraySegment<byte> GetSegment()
	{
		return new ArraySegment<byte>(_stream._buffer, _offset, _length);
	}
}


private struct MonoScriptData
{
	public byte[] FilePathsData;

	public byte[] TypesData;

	public int TotalTypes;

	public int TotalFiles;

	public bool IsEditorOnly;
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class StoredBuriedItem : IDisposable, IPooled, IProto<StoredBuriedItem>, IProto
{
	[NonSerialized]
	public int itemId;

	[NonSerialized]
	public ItemOwnershipAmount ownership;

	[NonSerialized]
	public ulong skinId;

	[NonSerialized]
	public long expiryTimeDiff;

	[NonSerialized]
	public Vector2 location;

	[NonSerialized]
	public float condition;

	[NonSerialized]
	public ulong uid;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(StoredBuriedItem instance)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.itemId = 0;
			if (instance.ownership != null)
			{
				instance.ownership.ResetToPool();
				instance.ownership = null;
			}
			instance.skinId = 0uL;
			instance.expiryTimeDiff = 0L;
			instance.location = default(Vector2);
			instance.condition = 0f;
			instance.uid = 0uL;
			Pool.Free<StoredBuriedItem>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose StoredBuriedItem with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(StoredBuriedItem instance)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		instance.itemId = itemId;
		if (ownership != null)
		{
			if (instance.ownership == null)
			{
				instance.ownership = ownership.Copy();
			}
			else
			{
				ownership.CopyTo(instance.ownership);
			}
		}
		else
		{
			instance.ownership = null;
		}
		instance.skinId = skinId;
		instance.expiryTimeDiff = expiryTimeDiff;
		instance.location = location;
		instance.condition = condition;
		instance.uid = uid;
	}

	public StoredBuriedItem Copy()
	{
		StoredBuriedItem storedBuriedItem = Pool.Get<StoredBuriedItem>();
		CopyTo(storedBuriedItem);
		return storedBuriedItem;
	}

	public static StoredBuriedItem Deserialize(BufferStream stream)
	{
		StoredBuriedItem storedBuriedItem = Pool.Get<StoredBuriedItem>();
		Deserialize(stream, storedBuriedItem, isDelta: false);
		return storedBuriedItem;
	}

	public static StoredBuriedItem DeserializeLengthDelimited(BufferStream stream)
	{
		StoredBuriedItem storedBuriedItem = Pool.Get<StoredBuriedItem>();
		DeserializeLengthDelimited(stream, storedBuriedItem, isDelta: false);
		return storedBuriedItem;
	}

	public static StoredBuriedItem DeserializeLength(BufferStream stream, int length)
	{
		StoredBuriedItem storedBuriedItem = Pool.Get<StoredBuriedItem>();
		DeserializeLength(stream, length, storedBuriedItem, isDelta: false);
		return storedBuriedItem;
	}

	public static StoredBuriedItem Deserialize(byte[] buffer)
	{
		StoredBuriedItem storedBuriedItem = Pool.Get<StoredBuriedItem>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, storedBuriedItem, isDelta: false);
		return storedBuriedItem;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, StoredBuriedItem previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static StoredBuriedItem Deserialize(BufferStream stream, StoredBuriedItem instance, bool isDelta)
	{
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.ownership == null)
				{
					instance.ownership = ItemOwnershipAmount.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemOwnershipAmount.DeserializeLengthDelimited(stream, instance.ownership, isDelta);
				}
				break;
			case 24:
				instance.skinId = ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.expiryTimeDiff = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 42:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.location, isDelta);
				break;
			case 53:
				instance.condition = ProtocolParser.ReadSingle(stream);
				break;
			case 56:
				instance.uid = ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static StoredBuriedItem DeserializeLengthDelimited(BufferStream stream, StoredBuriedItem instance, bool isDelta)
	{
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.ownership == null)
				{
					instance.ownership = ItemOwnershipAmount.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemOwnershipAmount.DeserializeLengthDelimited(stream, instance.ownership, isDelta);
				}
				break;
			case 24:
				instance.skinId = ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.expiryTimeDiff = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 42:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.location, isDelta);
				break;
			case 53:
				instance.condition = ProtocolParser.ReadSingle(stream);
				break;
			case 56:
				instance.uid = ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static StoredBuriedItem DeserializeLength(BufferStream stream, int length, StoredBuriedItem instance, bool isDelta)
	{
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				if (instance.ownership == null)
				{
					instance.ownership = ItemOwnershipAmount.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemOwnershipAmount.DeserializeLengthDelimited(stream, instance.ownership, isDelta);
				}
				break;
			case 24:
				instance.skinId = ProtocolParser.ReadUInt64(stream);
				break;
			case 32:
				instance.expiryTimeDiff = (long)ProtocolParser.ReadUInt64(stream);
				break;
			case 42:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.location, isDelta);
				break;
			case 53:
				instance.condition = ProtocolParser.ReadSingle(stream);
				break;
			case 56:
				instance.uid = ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, StoredBuriedItem instance, StoredBuriedItem previous)
	{
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.itemId != previous.itemId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.ownership != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemOwnershipAmount.SerializeDelta(stream, instance.ownership, previous.ownership);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.skinId != previous.skinId)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.skinId);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.expiryTimeDiff);
		if (instance.location != previous.location)
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector2Serialized.SerializeDelta(stream, instance.location, previous.location);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field location (UnityEngine.Vector2)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.condition != previous.condition)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.condition);
		}
		if (instance.uid != previous.uid)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.uid);
		}
	}

	public static void Serialize(BufferStream stream, StoredBuriedItem instance)
	{
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		if (instance.itemId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.ownership != null)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemOwnershipAmount.Serialize(stream, instance.ownership);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
		if (instance.skinId != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.skinId);
		}
		if (instance.expiryTimeDiff != 0L)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.expiryTimeDiff);
		}
		if (instance.location != default(Vector2))
		{
			stream.WriteByte(42);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector2Serialized.Serialize(stream, instance.location);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field location (UnityEngine.Vector2)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.condition != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.condition);
		}
		if (instance.uid != 0L)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.uid);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		ownership?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Private : IDisposable, IPooled, IProto<Private>, IProto
{
	[NonSerialized]
	public List<ItemContainer> container;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Private instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.container != null)
		{
			for (int i = 0; i < instance.container.Count; i++)
			{
				if (instance.container[i] != null)
				{
					instance.container[i].ResetToPool();
					instance.container[i] = null;
				}
			}
			List<ItemContainer> list = instance.container;
			Pool.Free<ItemContainer>(ref list, false);
			instance.container = list;
		}
		Pool.Free<Private>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Private with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Private instance)
	{
		if (container != null)
		{
			instance.container = Pool.Get<List<ItemContainer>>();
			for (int i = 0; i < container.Count; i++)
			{
				ItemContainer item = container[i].Copy();
				instance.container.Add(item);
			}
		}
		else
		{
			instance.container = null;
		}
	}

	public Private Copy()
	{
		Private @private = Pool.Get<Private>();
		CopyTo(@private);
		return @private;
	}

	public static Private Deserialize(BufferStream stream)
	{
		Private @private = Pool.Get<Private>();
		Deserialize(stream, @private, isDelta: false);
		return @private;
	}

	public static Private DeserializeLengthDelimited(BufferStream stream)
	{
		Private @private = Pool.Get<Private>();
		DeserializeLengthDelimited(stream, @private, isDelta: false);
		return @private;
	}

	public static Private DeserializeLength(BufferStream stream, int length)
	{
		Private @private = Pool.Get<Private>();
		DeserializeLength(stream, length, @private, isDelta: false);
		return @private;
	}

	public static Private Deserialize(byte[] buffer)
	{
		Private @private = Pool.Get<Private>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, @private, isDelta: false);
		return @private;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Private previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Private Deserialize(BufferStream stream, Private instance, bool isDelta)
	{
		if (!isDelta && instance.container == null)
		{
			instance.container = Pool.Get<List<ItemContainer>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.container.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Private DeserializeLengthDelimited(BufferStream stream, Private instance, bool isDelta)
	{
		if (!isDelta && instance.container == null)
		{
			instance.container = Pool.Get<List<ItemContainer>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.container.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Private DeserializeLength(BufferStream stream, int length, Private instance, bool isDelta)
	{
		if (!isDelta && instance.container == null)
		{
			instance.container = Pool.Get<List<ItemContainer>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.container.Add(ItemContainer.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Private instance, Private previous)
	{
		if (instance.container == null)
		{
			return;
		}
		for (int i = 0; i < instance.container.Count; i++)
		{
			ItemContainer itemContainer = instance.container[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.SerializeDelta(stream, itemContainer, itemContainer);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, Private instance)
	{
		if (instance.container == null)
		{
			return;
		}
		for (int i = 0; i < instance.container.Count; i++)
		{
			ItemContainer instance2 = instance.container[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			ItemContainer.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (container != null)
		{
			for (int i = 0; i < container.Count; i++)
			{
				container[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Private : IDisposable, IPooled, IProto<Private>, IProto
{
	[NonSerialized]
	public string code;

	[NonSerialized]
	public List<ulong> users;

	[NonSerialized]
	public string guestCode;

	[NonSerialized]
	public List<ulong> guestUsers;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Private instance)
	{
		if (instance.ShouldPool)
		{
			instance.code = string.Empty;
			if (instance.users != null)
			{
				List<ulong> list = instance.users;
				Pool.FreeUnmanaged<ulong>(ref list);
				instance.users = list;
			}
			instance.guestCode = string.Empty;
			if (instance.guestUsers != null)
			{
				List<ulong> list2 = instance.guestUsers;
				Pool.FreeUnmanaged<ulong>(ref list2);
				instance.guestUsers = list2;
			}
			Pool.Free<Private>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Private with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Private instance)
	{
		instance.code = code;
		if (users != null)
		{
			instance.users = Pool.Get<List<ulong>>();
			for (int i = 0; i < users.Count; i++)
			{
				ulong item = users[i];
				instance.users.Add(item);
			}
		}
		else
		{
			instance.users = null;
		}
		instance.guestCode = guestCode;
		if (guestUsers != null)
		{
			instance.guestUsers = Pool.Get<List<ulong>>();
			for (int j = 0; j < guestUsers.Count; j++)
			{
				ulong item2 = guestUsers[j];
				instance.guestUsers.Add(item2);
			}
		}
		else
		{
			instance.guestUsers = null;
		}
	}

	public Private Copy()
	{
		Private @private = Pool.Get<Private>();
		CopyTo(@private);
		return @private;
	}

	public static Private Deserialize(BufferStream stream)
	{
		Private @private = Pool.Get<Private>();
		Deserialize(stream, @private, isDelta: false);
		return @private;
	}

	public static Private DeserializeLengthDelimited(BufferStream stream)
	{
		Private @private = Pool.Get<Private>();
		DeserializeLengthDelimited(stream, @private, isDelta: false);
		return @private;
	}

	public static Private DeserializeLength(BufferStream stream, int length)
	{
		Private @private = Pool.Get<Private>();
		DeserializeLength(stream, length, @private, isDelta: false);
		return @private;
	}

	public static Private Deserialize(byte[] buffer)
	{
		Private @private = Pool.Get<Private>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, @private, isDelta: false);
		return @private;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Private previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Private Deserialize(BufferStream stream, Private instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.users == null)
			{
				instance.users = Pool.Get<List<ulong>>();
			}
			if (instance.guestUsers == null)
			{
				instance.guestUsers = Pool.Get<List<ulong>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.code = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.users.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 34:
				instance.guestCode = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.guestUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Private DeserializeLengthDelimited(BufferStream stream, Private instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.users == null)
			{
				instance.users = Pool.Get<List<ulong>>();
			}
			if (instance.guestUsers == null)
			{
				instance.guestUsers = Pool.Get<List<ulong>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.code = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.users.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 34:
				instance.guestCode = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.guestUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Private DeserializeLength(BufferStream stream, int length, Private instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.users == null)
			{
				instance.users = Pool.Get<List<ulong>>();
			}
			if (instance.guestUsers == null)
			{
				instance.guestUsers = Pool.Get<List<ulong>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.code = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.users.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			case 34:
				instance.guestCode = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.guestUsers.Add(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Private instance, Private previous)
	{
		if (instance.code != null && instance.code != previous.code)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.code);
		}
		if (instance.users != null)
		{
			for (int i = 0; i < instance.users.Count; i++)
			{
				ulong val = instance.users[i];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.guestCode != null && instance.guestCode != previous.guestCode)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.guestCode);
		}
		if (instance.guestUsers != null)
		{
			for (int j = 0; j < instance.guestUsers.Count; j++)
			{
				ulong val2 = instance.guestUsers[j];
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, val2);
			}
		}
	}

	public static void Serialize(BufferStream stream, Private instance)
	{
		if (instance.code != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.code);
		}
		if (instance.users != null)
		{
			for (int i = 0; i < instance.users.Count; i++)
			{
				ulong val = instance.users[i];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, val);
			}
		}
		if (instance.guestCode != null)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.guestCode);
		}
		if (instance.guestUsers != null)
		{
			for (int j = 0; j < instance.guestUsers.Count; j++)
			{
				ulong val2 = instance.guestUsers[j];
				stream.WriteByte(40);
				ProtocolParser.WriteUInt64(stream, val2);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class SpawnedEnt : IDisposable, IPooled, IProto<SpawnedEnt>, IProto
{
	[NonSerialized]
	public uint uid;

	[NonSerialized]
	public uint spawnPointIndex;

	[NonSerialized]
	public bool mobile;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SpawnedEnt instance)
	{
		if (instance.ShouldPool)
		{
			instance.uid = 0u;
			instance.spawnPointIndex = 0u;
			instance.mobile = false;
			Pool.Free<SpawnedEnt>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SpawnedEnt with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SpawnedEnt instance)
	{
		instance.uid = uid;
		instance.spawnPointIndex = spawnPointIndex;
		instance.mobile = mobile;
	}

	public SpawnedEnt Copy()
	{
		SpawnedEnt spawnedEnt = Pool.Get<SpawnedEnt>();
		CopyTo(spawnedEnt);
		return spawnedEnt;
	}

	public static SpawnedEnt Deserialize(BufferStream stream)
	{
		SpawnedEnt spawnedEnt = Pool.Get<SpawnedEnt>();
		Deserialize(stream, spawnedEnt, isDelta: false);
		return spawnedEnt;
	}

	public static SpawnedEnt DeserializeLengthDelimited(BufferStream stream)
	{
		SpawnedEnt spawnedEnt = Pool.Get<SpawnedEnt>();
		DeserializeLengthDelimited(stream, spawnedEnt, isDelta: false);
		return spawnedEnt;
	}

	public static SpawnedEnt DeserializeLength(BufferStream stream, int length)
	{
		SpawnedEnt spawnedEnt = Pool.Get<SpawnedEnt>();
		DeserializeLength(stream, length, spawnedEnt, isDelta: false);
		return spawnedEnt;
	}

	public static SpawnedEnt Deserialize(byte[] buffer)
	{
		SpawnedEnt spawnedEnt = Pool.Get<SpawnedEnt>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, spawnedEnt, isDelta: false);
		return spawnedEnt;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SpawnedEnt previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SpawnedEnt Deserialize(BufferStream stream, SpawnedEnt instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.uid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.spawnPointIndex = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.mobile = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SpawnedEnt DeserializeLengthDelimited(BufferStream stream, SpawnedEnt instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.uid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.spawnPointIndex = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.mobile = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SpawnedEnt DeserializeLength(BufferStream stream, int length, SpawnedEnt instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.uid = ProtocolParser.ReadUInt32(stream);
				continue;
			case 16:
				instance.spawnPointIndex = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.mobile = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SpawnedEnt instance, SpawnedEnt previous)
	{
		if (instance.uid != previous.uid)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.uid);
		}
		if (instance.spawnPointIndex != previous.spawnPointIndex)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.spawnPointIndex);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.mobile);
	}

	public static void Serialize(BufferStream stream, SpawnedEnt instance)
	{
		if (instance.uid != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.uid);
		}
		if (instance.spawnPointIndex != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.spawnPointIndex);
		}
		if (instance.mobile)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.mobile);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class MountPoint : IDisposable, IPooled, IProto<MountPoint>, IProto
{
	[NonSerialized]
	public int index;

	[NonSerialized]
	public NetworkableId mountableId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(MountPoint instance)
	{
		if (instance.ShouldPool)
		{
			instance.index = 0;
			instance.mountableId = default(NetworkableId);
			Pool.Free<MountPoint>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose MountPoint with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(MountPoint instance)
	{
		instance.index = index;
		instance.mountableId = mountableId;
	}

	public MountPoint Copy()
	{
		MountPoint mountPoint = Pool.Get<MountPoint>();
		CopyTo(mountPoint);
		return mountPoint;
	}

	public static MountPoint Deserialize(BufferStream stream)
	{
		MountPoint mountPoint = Pool.Get<MountPoint>();
		Deserialize(stream, mountPoint, isDelta: false);
		return mountPoint;
	}

	public static MountPoint DeserializeLengthDelimited(BufferStream stream)
	{
		MountPoint mountPoint = Pool.Get<MountPoint>();
		DeserializeLengthDelimited(stream, mountPoint, isDelta: false);
		return mountPoint;
	}

	public static MountPoint DeserializeLength(BufferStream stream, int length)
	{
		MountPoint mountPoint = Pool.Get<MountPoint>();
		DeserializeLength(stream, length, mountPoint, isDelta: false);
		return mountPoint;
	}

	public static MountPoint Deserialize(byte[] buffer)
	{
		MountPoint mountPoint = Pool.Get<MountPoint>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, mountPoint, isDelta: false);
		return mountPoint;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, MountPoint previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static MountPoint Deserialize(BufferStream stream, MountPoint instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.index = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.mountableId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static MountPoint DeserializeLengthDelimited(BufferStream stream, MountPoint instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.index = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.mountableId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static MountPoint DeserializeLength(BufferStream stream, int length, MountPoint instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.index = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.mountableId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, MountPoint instance, MountPoint previous)
	{
		if (instance.index != previous.index)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.index);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.mountableId.Value);
	}

	public static void Serialize(BufferStream stream, MountPoint instance)
	{
		if (instance.index != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.index);
		}
		if (instance.mountableId != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.mountableId.Value);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref mountableId.Value);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class SellOrder : IDisposable, IPooled, IProto<SellOrder>, IProto
{
	[NonSerialized]
	public int itemToSellID;

	[NonSerialized]
	public int itemToSellAmount;

	[NonSerialized]
	public int currencyID;

	[NonSerialized]
	public int currencyAmountPerItem;

	[NonSerialized]
	public int inStock;

	[NonSerialized]
	public bool currencyIsBP;

	[NonSerialized]
	public bool itemToSellIsBP;

	[NonSerialized]
	public float itemCondition;

	[NonSerialized]
	public float itemConditionMax;

	[NonSerialized]
	public int instanceData;

	[NonSerialized]
	public List<int> attachmentsList;

	[NonSerialized]
	public int totalAttachmentSlots;

	[NonSerialized]
	public float priceMultiplier;

	[NonSerialized]
	public int ammoType;

	[NonSerialized]
	public int ammoCount;

	[NonSerialized]
	public float receivedQuantityMultiplier;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SellOrder instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemToSellID = 0;
			instance.itemToSellAmount = 0;
			instance.currencyID = 0;
			instance.currencyAmountPerItem = 0;
			instance.inStock = 0;
			instance.currencyIsBP = false;
			instance.itemToSellIsBP = false;
			instance.itemCondition = 0f;
			instance.itemConditionMax = 0f;
			instance.instanceData = 0;
			if (instance.attachmentsList != null)
			{
				List<int> list = instance.attachmentsList;
				Pool.FreeUnmanaged<int>(ref list);
				instance.attachmentsList = list;
			}
			instance.totalAttachmentSlots = 0;
			instance.priceMultiplier = 0f;
			instance.ammoType = 0;
			instance.ammoCount = 0;
			instance.receivedQuantityMultiplier = 0f;
			Pool.Free<SellOrder>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SellOrder with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SellOrder instance)
	{
		instance.itemToSellID = itemToSellID;
		instance.itemToSellAmount = itemToSellAmount;
		instance.currencyID = currencyID;
		instance.currencyAmountPerItem = currencyAmountPerItem;
		instance.inStock = inStock;
		instance.currencyIsBP = currencyIsBP;
		instance.itemToSellIsBP = itemToSellIsBP;
		instance.itemCondition = itemCondition;
		instance.itemConditionMax = itemConditionMax;
		instance.instanceData = instanceData;
		if (attachmentsList != null)
		{
			instance.attachmentsList = Pool.Get<List<int>>();
			for (int i = 0; i < attachmentsList.Count; i++)
			{
				int item = attachmentsList[i];
				instance.attachmentsList.Add(item);
			}
		}
		else
		{
			instance.attachmentsList = null;
		}
		instance.totalAttachmentSlots = totalAttachmentSlots;
		instance.priceMultiplier = priceMultiplier;
		instance.ammoType = ammoType;
		instance.ammoCount = ammoCount;
		instance.receivedQuantityMultiplier = receivedQuantityMultiplier;
	}

	public SellOrder Copy()
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		CopyTo(sellOrder);
		return sellOrder;
	}

	public static SellOrder Deserialize(BufferStream stream)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		Deserialize(stream, sellOrder, isDelta: false);
		return sellOrder;
	}

	public static SellOrder DeserializeLengthDelimited(BufferStream stream)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		DeserializeLengthDelimited(stream, sellOrder, isDelta: false);
		return sellOrder;
	}

	public static SellOrder DeserializeLength(BufferStream stream, int length)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		DeserializeLength(stream, length, sellOrder, isDelta: false);
		return sellOrder;
	}

	public static SellOrder Deserialize(byte[] buffer)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sellOrder, isDelta: false);
		return sellOrder;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SellOrder previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SellOrder Deserialize(BufferStream stream, SellOrder instance, bool isDelta)
	{
		if (!isDelta && instance.attachmentsList == null)
		{
			instance.attachmentsList = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemToSellID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemToSellAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.currencyID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.currencyAmountPerItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.inStock = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.currencyIsBP = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.itemToSellIsBP = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.itemCondition = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.instanceData = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.attachmentsList.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 96:
				instance.totalAttachmentSlots = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 109:
				instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			case 112:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 120:
				instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Fixed32)
				{
					instance.receivedQuantityMultiplier = ProtocolParser.ReadSingle(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
	}

	public static SellOrder DeserializeLengthDelimited(BufferStream stream, SellOrder instance, bool isDelta)
	{
		if (!isDelta && instance.attachmentsList == null)
		{
			instance.attachmentsList = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemToSellID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemToSellAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.currencyID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.currencyAmountPerItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.inStock = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.currencyIsBP = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.itemToSellIsBP = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.itemCondition = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.instanceData = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.attachmentsList.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 96:
				instance.totalAttachmentSlots = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 109:
				instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			case 112:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 120:
				instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Fixed32)
				{
					instance.receivedQuantityMultiplier = ProtocolParser.ReadSingle(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SellOrder DeserializeLength(BufferStream stream, int length, SellOrder instance, bool isDelta)
	{
		if (!isDelta && instance.attachmentsList == null)
		{
			instance.attachmentsList = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemToSellID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemToSellAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.currencyID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.currencyAmountPerItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.inStock = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.currencyIsBP = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.itemToSellIsBP = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.itemCondition = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
				continue;
			case 80:
				instance.instanceData = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.attachmentsList.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 96:
				instance.totalAttachmentSlots = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 109:
				instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			case 112:
				instance.ammoType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 120:
				instance.ammoCount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 16)
			{
				if (key.WireType == Wire.Fixed32)
				{
					instance.receivedQuantityMultiplier = ProtocolParser.ReadSingle(stream);
				}
			}
			else
			{
				ProtocolParser.SkipKey(stream, key);
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SellOrder instance, SellOrder previous)
	{
		if (instance.itemToSellID != previous.itemToSellID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemToSellID);
		}
		if (instance.itemToSellAmount != previous.itemToSellAmount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemToSellAmount);
		}
		if (instance.currencyID != previous.currencyID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyID);
		}
		if (instance.currencyAmountPerItem != previous.currencyAmountPerItem)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyAmountPerItem);
		}
		if (instance.inStock != previous.inStock)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inStock);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.currencyIsBP);
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.itemToSellIsBP);
		if (instance.itemCondition != previous.itemCondition)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.itemCondition);
		}
		if (instance.itemConditionMax != previous.itemConditionMax)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
		}
		if (instance.instanceData != previous.instanceData)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.instanceData);
		}
		if (instance.attachmentsList != null)
		{
			for (int i = 0; i < instance.attachmentsList.Count; i++)
			{
				int num = instance.attachmentsList[i];
				stream.WriteByte(88);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.totalAttachmentSlots != previous.totalAttachmentSlots)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.totalAttachmentSlots);
		}
		if (instance.priceMultiplier != previous.priceMultiplier)
		{
			stream.WriteByte(109);
			ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
		}
		if (instance.ammoType != previous.ammoType)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
		}
		if (instance.ammoCount != previous.ammoCount)
		{
			stream.WriteByte(120);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoCount);
		}
		if (instance.receivedQuantityMultiplier != previous.receivedQuantityMultiplier)
		{
			stream.WriteByte(133);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.receivedQuantityMultiplier);
		}
	}

	public static void Serialize(BufferStream stream, SellOrder instance)
	{
		if (instance.itemToSellID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemToSellID);
		}
		if (instance.itemToSellAmount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemToSellAmount);
		}
		if (instance.currencyID != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyID);
		}
		if (instance.currencyAmountPerItem != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyAmountPerItem);
		}
		if (instance.inStock != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.inStock);
		}
		if (instance.currencyIsBP)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.currencyIsBP);
		}
		if (instance.itemToSellIsBP)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.itemToSellIsBP);
		}
		if (instance.itemCondition != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.itemCondition);
		}
		if (instance.itemConditionMax != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
		}
		if (instance.instanceData != 0)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.instanceData);
		}
		if (instance.attachmentsList != null)
		{
			for (int i = 0; i < instance.attachmentsList.Count; i++)
			{
				int num = instance.attachmentsList[i];
				stream.WriteByte(88);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.totalAttachmentSlots != 0)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.totalAttachmentSlots);
		}
		if (instance.priceMultiplier != 0f)
		{
			stream.WriteByte(109);
			ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
		}
		if (instance.ammoType != 0)
		{
			stream.WriteByte(112);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoType);
		}
		if (instance.ammoCount != 0)
		{
			stream.WriteByte(120);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.ammoCount);
		}
		if (instance.receivedQuantityMultiplier != 0f)
		{
			stream.WriteByte(133);
			stream.WriteByte(1);
			ProtocolParser.WriteSingle(stream, instance.receivedQuantityMultiplier);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class SellOrderContainer : IDisposable, IPooled, IProto<SellOrderContainer>, IProto
{
	[NonSerialized]
	public List<SellOrder> sellOrders;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SellOrderContainer instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.sellOrders != null)
		{
			for (int i = 0; i < instance.sellOrders.Count; i++)
			{
				if (instance.sellOrders[i] != null)
				{
					instance.sellOrders[i].ResetToPool();
					instance.sellOrders[i] = null;
				}
			}
			List<SellOrder> list = instance.sellOrders;
			Pool.Free<SellOrder>(ref list, false);
			instance.sellOrders = list;
		}
		Pool.Free<SellOrderContainer>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SellOrderContainer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SellOrderContainer instance)
	{
		if (sellOrders != null)
		{
			instance.sellOrders = Pool.Get<List<SellOrder>>();
			for (int i = 0; i < sellOrders.Count; i++)
			{
				SellOrder item = sellOrders[i].Copy();
				instance.sellOrders.Add(item);
			}
		}
		else
		{
			instance.sellOrders = null;
		}
	}

	public SellOrderContainer Copy()
	{
		SellOrderContainer sellOrderContainer = Pool.Get<SellOrderContainer>();
		CopyTo(sellOrderContainer);
		return sellOrderContainer;
	}

	public static SellOrderContainer Deserialize(BufferStream stream)
	{
		SellOrderContainer sellOrderContainer = Pool.Get<SellOrderContainer>();
		Deserialize(stream, sellOrderContainer, isDelta: false);
		return sellOrderContainer;
	}

	public static SellOrderContainer DeserializeLengthDelimited(BufferStream stream)
	{
		SellOrderContainer sellOrderContainer = Pool.Get<SellOrderContainer>();
		DeserializeLengthDelimited(stream, sellOrderContainer, isDelta: false);
		return sellOrderContainer;
	}

	public static SellOrderContainer DeserializeLength(BufferStream stream, int length)
	{
		SellOrderContainer sellOrderContainer = Pool.Get<SellOrderContainer>();
		DeserializeLength(stream, length, sellOrderContainer, isDelta: false);
		return sellOrderContainer;
	}

	public static SellOrderContainer Deserialize(byte[] buffer)
	{
		SellOrderContainer sellOrderContainer = Pool.Get<SellOrderContainer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, sellOrderContainer, isDelta: false);
		return sellOrderContainer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SellOrderContainer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SellOrderContainer Deserialize(BufferStream stream, SellOrderContainer instance, bool isDelta)
	{
		if (!isDelta && instance.sellOrders == null)
		{
			instance.sellOrders = Pool.Get<List<SellOrder>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.sellOrders.Add(SellOrder.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SellOrderContainer DeserializeLengthDelimited(BufferStream stream, SellOrderContainer instance, bool isDelta)
	{
		if (!isDelta && instance.sellOrders == null)
		{
			instance.sellOrders = Pool.Get<List<SellOrder>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.sellOrders.Add(SellOrder.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SellOrderContainer DeserializeLength(BufferStream stream, int length, SellOrderContainer instance, bool isDelta)
	{
		if (!isDelta && instance.sellOrders == null)
		{
			instance.sellOrders = Pool.Get<List<SellOrder>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.sellOrders.Add(SellOrder.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SellOrderContainer instance, SellOrderContainer previous)
	{
		if (instance.sellOrders == null)
		{
			return;
		}
		for (int i = 0; i < instance.sellOrders.Count; i++)
		{
			SellOrder sellOrder = instance.sellOrders[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(3);
			int position = stream.Position;
			SellOrder.SerializeDelta(stream, sellOrder, sellOrder);
			int num = stream.Position - position;
			if (num > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field sellOrders (ProtoBuf.VendingMachine.SellOrder)");
			}
			Span<byte> span = range.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 < 3)
			{
				span[num2 - 1] |= 128;
				while (num2 < 2)
				{
					span[num2++] = 128;
				}
				span[2] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, SellOrderContainer instance)
	{
		if (instance.sellOrders == null)
		{
			return;
		}
		for (int i = 0; i < instance.sellOrders.Count; i++)
		{
			SellOrder instance2 = instance.sellOrders[i];
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(3);
			int position = stream.Position;
			SellOrder.Serialize(stream, instance2);
			int num = stream.Position - position;
			if (num > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field sellOrders (ProtoBuf.VendingMachine.SellOrder)");
			}
			Span<byte> span = range.GetSpan();
			int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
			if (num2 < 3)
			{
				span[num2 - 1] |= 128;
				while (num2 < 2)
				{
					span[num2++] = 128;
				}
				span[2] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (sellOrders != null)
		{
			for (int i = 0; i < sellOrders.Count; i++)
			{
				sellOrders[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class IOConnection : IDisposable, IPooled, IProto<IOConnection>, IProto
{
	public class LineVec : IDisposable, IPooled, IProto<LineVec>, IProto
	{
		[NonSerialized]
		public Vector4 vec;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(LineVec instance)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.vec = default(Vector4);
				Pool.Free<LineVec>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose LineVec with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(LineVec instance)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			instance.vec = vec;
		}

		public LineVec Copy()
		{
			LineVec lineVec = Pool.Get<LineVec>();
			CopyTo(lineVec);
			return lineVec;
		}

		public static LineVec Deserialize(BufferStream stream)
		{
			LineVec lineVec = Pool.Get<LineVec>();
			Deserialize(stream, lineVec, isDelta: false);
			return lineVec;
		}

		public static LineVec DeserializeLengthDelimited(BufferStream stream)
		{
			LineVec lineVec = Pool.Get<LineVec>();
			DeserializeLengthDelimited(stream, lineVec, isDelta: false);
			return lineVec;
		}

		public static LineVec DeserializeLength(BufferStream stream, int length)
		{
			LineVec lineVec = Pool.Get<LineVec>();
			DeserializeLength(stream, length, lineVec, isDelta: false);
			return lineVec;
		}

		public static LineVec Deserialize(byte[] buffer)
		{
			LineVec lineVec = Pool.Get<LineVec>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, lineVec, isDelta: false);
			return lineVec;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, LineVec previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static LineVec Deserialize(BufferStream stream, LineVec instance, bool isDelta)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static LineVec DeserializeLengthDelimited(BufferStream stream, LineVec instance, bool isDelta)
		{
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static LineVec DeserializeLength(BufferStream stream, int length, LineVec instance, bool isDelta)
		{
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, LineVec instance, LineVec previous)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			if (instance.vec != previous.vec)
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector4Serialized.SerializeDelta(stream, instance.vec, previous.vec);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field vec (UnityEngine.Vector4)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}

		public static void Serialize(BufferStream stream, LineVec instance)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			if (instance.vec != default(Vector4))
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector4Serialized.Serialize(stream, instance.vec);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field vec (UnityEngine.Vector4)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	public class LinePointList : IDisposable, IPooled, IProto<LinePointList>, IProto
	{
		[NonSerialized]
		public Vector4 a;

		[NonSerialized]
		public Vector4 b;

		[NonSerialized]
		public Vector4 c;

		[NonSerialized]
		public Vector4 d;

		[NonSerialized]
		public Vector4 e;

		[NonSerialized]
		public Vector4 f;

		[NonSerialized]
		public Vector4 g;

		[NonSerialized]
		public Vector4 h;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(LinePointList instance)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			if (instance.ShouldPool)
			{
				instance.a = default(Vector4);
				instance.b = default(Vector4);
				instance.c = default(Vector4);
				instance.d = default(Vector4);
				instance.e = default(Vector4);
				instance.f = default(Vector4);
				instance.g = default(Vector4);
				instance.h = default(Vector4);
				Pool.Free<LinePointList>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose LinePointList with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(LinePointList instance)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			instance.a = a;
			instance.b = b;
			instance.c = c;
			instance.d = d;
			instance.e = e;
			instance.f = f;
			instance.g = g;
			instance.h = h;
		}

		public LinePointList Copy()
		{
			LinePointList linePointList = Pool.Get<LinePointList>();
			CopyTo(linePointList);
			return linePointList;
		}

		public static LinePointList Deserialize(BufferStream stream)
		{
			LinePointList linePointList = Pool.Get<LinePointList>();
			Deserialize(stream, linePointList, isDelta: false);
			return linePointList;
		}

		public static LinePointList DeserializeLengthDelimited(BufferStream stream)
		{
			LinePointList linePointList = Pool.Get<LinePointList>();
			DeserializeLengthDelimited(stream, linePointList, isDelta: false);
			return linePointList;
		}

		public static LinePointList DeserializeLength(BufferStream stream, int length)
		{
			LinePointList linePointList = Pool.Get<LinePointList>();
			DeserializeLength(stream, length, linePointList, isDelta: false);
			return linePointList;
		}

		public static LinePointList Deserialize(byte[] buffer)
		{
			LinePointList linePointList = Pool.Get<LinePointList>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, linePointList, isDelta: false);
			return linePointList;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, LinePointList previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static LinePointList Deserialize(BufferStream stream, LinePointList instance, bool isDelta)
		{
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_0099: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
					continue;
				case 18:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
					continue;
				case 26:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
					continue;
				case 34:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
					continue;
				case 42:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
					continue;
				case 50:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
					continue;
				case 58:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
					continue;
				case 66:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static LinePointList DeserializeLengthDelimited(BufferStream stream, LinePointList instance, bool isDelta)
		{
			//IL_010f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0122: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
					continue;
				case 18:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
					continue;
				case 26:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
					continue;
				case 34:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
					continue;
				case 42:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
					continue;
				case 50:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
					continue;
				case 58:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
					continue;
				case 66:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static LinePointList DeserializeLength(BufferStream stream, int length, LinePointList instance, bool isDelta)
		{
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
					continue;
				case 18:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
					continue;
				case 26:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
					continue;
				case 34:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
					continue;
				case 42:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
					continue;
				case 50:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
					continue;
				case 58:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
					continue;
				case 66:
					Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, LinePointList instance, LinePointList previous)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_0136: Unknown result type (might be due to invalid IL or missing references)
			//IL_013c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_019f: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_0163: Unknown result type (might be due to invalid IL or missing references)
			//IL_0169: Unknown result type (might be due to invalid IL or missing references)
			//IL_0208: Unknown result type (might be due to invalid IL or missing references)
			//IL_020e: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0271: Unknown result type (might be due to invalid IL or missing references)
			//IL_0277: Unknown result type (might be due to invalid IL or missing references)
			//IL_0235: Unknown result type (might be due to invalid IL or missing references)
			//IL_023b: Unknown result type (might be due to invalid IL or missing references)
			//IL_02da: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_029e: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0307: Unknown result type (might be due to invalid IL or missing references)
			//IL_030d: Unknown result type (might be due to invalid IL or missing references)
			if (instance.a != previous.a)
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector4Serialized.SerializeDelta(stream, instance.a, previous.a);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field a (UnityEngine.Vector4)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.b != previous.b)
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector4Serialized.SerializeDelta(stream, instance.b, previous.b);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field b (UnityEngine.Vector4)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.c != previous.c)
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				Vector4Serialized.SerializeDelta(stream, instance.c, previous.c);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field c (UnityEngine.Vector4)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
			if (instance.d != previous.d)
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int position4 = stream.Position;
				Vector4Serialized.SerializeDelta(stream, instance.d, previous.d);
				int num4 = stream.Position - position4;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field d (UnityEngine.Vector4)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			}
			if (instance.e != previous.e)
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range5 = stream.GetRange(1);
				int position5 = stream.Position;
				Vector4Serialized.SerializeDelta(stream, instance.e, previous.e);
				int num5 = stream.Position - position5;
				if (num5 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field e (UnityEngine.Vector4)");
				}
				Span<byte> span5 = range5.GetSpan();
				ProtocolParser.WriteUInt32((uint)num5, span5, 0);
			}
			if (instance.f != previous.f)
			{
				stream.WriteByte(50);
				BufferStream.RangeHandle range6 = stream.GetRange(1);
				int position6 = stream.Position;
				Vector4Serialized.SerializeDelta(stream, instance.f, previous.f);
				int num6 = stream.Position - position6;
				if (num6 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field f (UnityEngine.Vector4)");
				}
				Span<byte> span6 = range6.GetSpan();
				ProtocolParser.WriteUInt32((uint)num6, span6, 0);
			}
			if (instance.g != previous.g)
			{
				stream.WriteByte(58);
				BufferStream.RangeHandle range7 = stream.GetRange(1);
				int position7 = stream.Position;
				Vector4Serialized.SerializeDelta(stream, instance.g, previous.g);
				int num7 = stream.Position - position7;
				if (num7 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field g (UnityEngine.Vector4)");
				}
				Span<byte> span7 = range7.GetSpan();
				ProtocolParser.WriteUInt32((uint)num7, span7, 0);
			}
			if (instance.h != previous.h)
			{
				stream.WriteByte(66);
				BufferStream.RangeHandle range8 = stream.GetRange(1);
				int position8 = stream.Position;
				Vector4Serialized.SerializeDelta(stream, instance.h, previous.h);
				int num8 = stream.Position - position8;
				if (num8 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field h (UnityEngine.Vector4)");
				}
				Span<byte> span8 = range8.GetSpan();
				ProtocolParser.WriteUInt32((uint)num8, span8, 0);
			}
		}

		public static void Serialize(BufferStream stream, LinePointList instance)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_012e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_013b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
			//IL_0194: Unknown result type (might be due to invalid IL or missing references)
			//IL_019b: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_015e: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_0201: Unknown result type (might be due to invalid IL or missing references)
			//IL_0207: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0260: Unknown result type (might be due to invalid IL or missing references)
			//IL_0267: Unknown result type (might be due to invalid IL or missing references)
			//IL_026d: Unknown result type (might be due to invalid IL or missing references)
			//IL_022a: Unknown result type (might be due to invalid IL or missing references)
			//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0290: Unknown result type (might be due to invalid IL or missing references)
			//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
			if (instance.a != default(Vector4))
			{
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Vector4Serialized.Serialize(stream, instance.a);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field a (UnityEngine.Vector4)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
			if (instance.b != default(Vector4))
			{
				stream.WriteByte(18);
				BufferStream.RangeHandle range2 = stream.GetRange(1);
				int position2 = stream.Position;
				Vector4Serialized.Serialize(stream, instance.b);
				int num2 = stream.Position - position2;
				if (num2 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field b (UnityEngine.Vector4)");
				}
				Span<byte> span2 = range2.GetSpan();
				ProtocolParser.WriteUInt32((uint)num2, span2, 0);
			}
			if (instance.c != default(Vector4))
			{
				stream.WriteByte(26);
				BufferStream.RangeHandle range3 = stream.GetRange(1);
				int position3 = stream.Position;
				Vector4Serialized.Serialize(stream, instance.c);
				int num3 = stream.Position - position3;
				if (num3 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field c (UnityEngine.Vector4)");
				}
				Span<byte> span3 = range3.GetSpan();
				ProtocolParser.WriteUInt32((uint)num3, span3, 0);
			}
			if (instance.d != default(Vector4))
			{
				stream.WriteByte(34);
				BufferStream.RangeHandle range4 = stream.GetRange(1);
				int position4 = stream.Position;
				Vector4Serialized.Serialize(stream, instance.d);
				int num4 = stream.Position - position4;
				if (num4 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field d (UnityEngine.Vector4)");
				}
				Span<byte> span4 = range4.GetSpan();
				ProtocolParser.WriteUInt32((uint)num4, span4, 0);
			}
			if (instance.e != default(Vector4))
			{
				stream.WriteByte(42);
				BufferStream.RangeHandle range5 = stream.GetRange(1);
				int position5 = stream.Position;
				Vector4Serialized.Serialize(stream, instance.e);
				int num5 = stream.Position - position5;
				if (num5 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field e (UnityEngine.Vector4)");
				}
				Span<byte> span5 = range5.GetSpan();
				ProtocolParser.WriteUInt32((uint)num5, span5, 0);
			}
			if (instance.f != default(Vector4))
			{
				stream.WriteByte(50);
				BufferStream.RangeHandle range6 = stream.GetRange(1);
				int position6 = stream.Position;
				Vector4Serialized.Serialize(stream, instance.f);
				int num6 = stream.Position - position6;
				if (num6 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field f (UnityEngine.Vector4)");
				}
				Span<byte> span6 = range6.GetSpan();
				ProtocolParser.WriteUInt32((uint)num6, span6, 0);
			}
			if (instance.g != default(Vector4))
			{
				stream.WriteByte(58);
				BufferStream.RangeHandle range7 = stream.GetRange(1);
				int position7 = stream.Position;
				Vector4Serialized.Serialize(stream, instance.g);
				int num7 = stream.Position - position7;
				if (num7 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field g (UnityEngine.Vector4)");
				}
				Span<byte> span7 = range7.GetSpan();
				ProtocolParser.WriteUInt32((uint)num7, span7, 0);
			}
			if (instance.h != default(Vector4))
			{
				stream.WriteByte(66);
				BufferStream.RangeHandle range8 = stream.GetRange(1);
				int position8 = stream.Position;
				Vector4Serialized.Serialize(stream, instance.h);
				int num8 = stream.Position - position8;
				if (num8 > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field h (UnityEngine.Vector4)");
				}
				Span<byte> span8 = range8.GetSpan();
				ProtocolParser.WriteUInt32((uint)num8, span8, 0);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public string niceName;

	[NonSerialized]
	public int type;

	[NonSerialized]
	public NetworkableId connectedID;

	[NonSerialized]
	public int connectedToSlot;

	[NonSerialized]
	public bool inUse;

	[NonSerialized]
	public List<LineVec> linePointList;

	[NonSerialized]
	public int colour;

	[NonSerialized]
	public Vector3 worldSpaceRotation;

	[NonSerialized]
	public float lineThickness;

	[NonSerialized]
	public List<WireLineAnchorInfo> lineAnchorList;

	[NonSerialized]
	public Vector3 originPosition;

	[NonSerialized]
	public Vector3 originRotation;

	[NonSerialized]
	public List<float> slackLevels;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(IOConnection instance)
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.niceName = string.Empty;
		instance.type = 0;
		instance.connectedID = default(NetworkableId);
		instance.connectedToSlot = 0;
		instance.inUse = false;
		if (instance.linePointList != null)
		{
			for (int i = 0; i < instance.linePointList.Count; i++)
			{
				if (instance.linePointList[i] != null)
				{
					instance.linePointList[i].ResetToPool();
					instance.linePointList[i] = null;
				}
			}
			List<LineVec> list = instance.linePointList;
			Pool.Free<LineVec>(ref list, false);
			instance.linePointList = list;
		}
		instance.colour = 0;
		instance.worldSpaceRotation = default(Vector3);
		instance.lineThickness = 0f;
		if (instance.lineAnchorList != null)
		{
			for (int j = 0; j < instance.lineAnchorList.Count; j++)
			{
				if (instance.lineAnchorList[j] != null)
				{
					instance.lineAnchorList[j].ResetToPool();
					instance.lineAnchorList[j] = null;
				}
			}
			List<WireLineAnchorInfo> list2 = instance.lineAnchorList;
			Pool.Free<WireLineAnchorInfo>(ref list2, false);
			instance.lineAnchorList = list2;
		}
		instance.originPosition = default(Vector3);
		instance.originRotation = default(Vector3);
		if (instance.slackLevels != null)
		{
			List<float> list3 = instance.slackLevels;
			Pool.FreeUnmanaged<float>(ref list3);
			instance.slackLevels = list3;
		}
		Pool.Free<IOConnection>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose IOConnection with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(IOConnection instance)
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		instance.niceName = niceName;
		instance.type = type;
		instance.connectedID = connectedID;
		instance.connectedToSlot = connectedToSlot;
		instance.inUse = inUse;
		if (linePointList != null)
		{
			instance.linePointList = Pool.Get<List<LineVec>>();
			for (int i = 0; i < linePointList.Count; i++)
			{
				LineVec item = linePointList[i].Copy();
				instance.linePointList.Add(item);
			}
		}
		else
		{
			instance.linePointList = null;
		}
		instance.colour = colour;
		instance.worldSpaceRotation = worldSpaceRotation;
		instance.lineThickness = lineThickness;
		if (lineAnchorList != null)
		{
			instance.lineAnchorList = Pool.Get<List<WireLineAnchorInfo>>();
			for (int j = 0; j < lineAnchorList.Count; j++)
			{
				WireLineAnchorInfo item2 = lineAnchorList[j].Copy();
				instance.lineAnchorList.Add(item2);
			}
		}
		else
		{
			instance.lineAnchorList = null;
		}
		instance.originPosition = originPosition;
		instance.originRotation = originRotation;
		if (slackLevels != null)
		{
			instance.slackLevels = Pool.Get<List<float>>();
			for (int k = 0; k < slackLevels.Count; k++)
			{
				float item3 = slackLevels[k];
				instance.slackLevels.Add(item3);
			}
		}
		else
		{
			instance.slackLevels = null;
		}
	}

	public IOConnection Copy()
	{
		IOConnection iOConnection = Pool.Get<IOConnection>();
		CopyTo(iOConnection);
		return iOConnection;
	}

	public static IOConnection Deserialize(BufferStream stream)
	{
		IOConnection iOConnection = Pool.Get<IOConnection>();
		Deserialize(stream, iOConnection, isDelta: false);
		return iOConnection;
	}

	public static IOConnection DeserializeLengthDelimited(BufferStream stream)
	{
		IOConnection iOConnection = Pool.Get<IOConnection>();
		DeserializeLengthDelimited(stream, iOConnection, isDelta: false);
		return iOConnection;
	}

	public static IOConnection DeserializeLength(BufferStream stream, int length)
	{
		IOConnection iOConnection = Pool.Get<IOConnection>();
		DeserializeLength(stream, length, iOConnection, isDelta: false);
		return iOConnection;
	}

	public static IOConnection Deserialize(byte[] buffer)
	{
		IOConnection iOConnection = Pool.Get<IOConnection>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, iOConnection, isDelta: false);
		return iOConnection;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, IOConnection previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static IOConnection Deserialize(BufferStream stream, IOConnection instance, bool isDelta)
	{
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePointList == null)
			{
				instance.linePointList = Pool.Get<List<LineVec>>();
			}
			if (instance.lineAnchorList == null)
			{
				instance.lineAnchorList = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.niceName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.connectedID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.connectedToSlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.inUse = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				instance.linePointList.Add(LineVec.DeserializeLengthDelimited(stream));
				continue;
			case 56:
				instance.colour = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldSpaceRotation, isDelta);
				continue;
			case 77:
				instance.lineThickness = ProtocolParser.ReadSingle(stream);
				continue;
			case 82:
				instance.lineAnchorList.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				continue;
			case 90:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originPosition, isDelta);
				continue;
			case 98:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originRotation, isDelta);
				continue;
			case 109:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static IOConnection DeserializeLengthDelimited(BufferStream stream, IOConnection instance, bool isDelta)
	{
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePointList == null)
			{
				instance.linePointList = Pool.Get<List<LineVec>>();
			}
			if (instance.lineAnchorList == null)
			{
				instance.lineAnchorList = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.niceName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.connectedID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.connectedToSlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.inUse = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				instance.linePointList.Add(LineVec.DeserializeLengthDelimited(stream));
				continue;
			case 56:
				instance.colour = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldSpaceRotation, isDelta);
				continue;
			case 77:
				instance.lineThickness = ProtocolParser.ReadSingle(stream);
				continue;
			case 82:
				instance.lineAnchorList.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				continue;
			case 90:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originPosition, isDelta);
				continue;
			case 98:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originRotation, isDelta);
				continue;
			case 109:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static IOConnection DeserializeLength(BufferStream stream, int length, IOConnection instance, bool isDelta)
	{
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			if (instance.linePointList == null)
			{
				instance.linePointList = Pool.Get<List<LineVec>>();
			}
			if (instance.lineAnchorList == null)
			{
				instance.lineAnchorList = Pool.Get<List<WireLineAnchorInfo>>();
			}
			if (instance.slackLevels == null)
			{
				instance.slackLevels = Pool.Get<List<float>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.niceName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.connectedID = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.connectedToSlot = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.inUse = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				instance.linePointList.Add(LineVec.DeserializeLengthDelimited(stream));
				continue;
			case 56:
				instance.colour = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldSpaceRotation, isDelta);
				continue;
			case 77:
				instance.lineThickness = ProtocolParser.ReadSingle(stream);
				continue;
			case 82:
				instance.lineAnchorList.Add(WireLineAnchorInfo.DeserializeLengthDelimited(stream));
				continue;
			case 90:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originPosition, isDelta);
				continue;
			case 98:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.originRotation, isDelta);
				continue;
			case 109:
				instance.slackLevels.Add(ProtocolParser.ReadSingle(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, IOConnection instance, IOConnection previous)
	{
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_02aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		if (instance.niceName != null && instance.niceName != previous.niceName)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.niceName);
		}
		if (instance.type != previous.type)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.connectedID.Value);
		if (instance.connectedToSlot != previous.connectedToSlot)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.connectedToSlot);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.inUse);
		if (instance.linePointList != null)
		{
			for (int i = 0; i < instance.linePointList.Count; i++)
			{
				LineVec lineVec = instance.linePointList[i];
				stream.WriteByte(50);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				LineVec.SerializeDelta(stream, lineVec, lineVec);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePointList (ProtoBuf.IOEntity.IOConnection.LineVec)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.colour != previous.colour)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colour);
		}
		if (instance.worldSpaceRotation != previous.worldSpaceRotation)
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.worldSpaceRotation, previous.worldSpaceRotation);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldSpaceRotation (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.lineThickness != previous.lineThickness)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.lineThickness);
		}
		if (instance.lineAnchorList != null)
		{
			for (int j = 0; j < instance.lineAnchorList.Count; j++)
			{
				WireLineAnchorInfo wireLineAnchorInfo = instance.lineAnchorList[j];
				stream.WriteByte(82);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				WireLineAnchorInfo.SerializeDelta(stream, wireLineAnchorInfo, wireLineAnchorInfo);
				int val = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.originPosition != previous.originPosition)
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.originPosition, previous.originPosition);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originPosition (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.originRotation != previous.originRotation)
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.originRotation, previous.originRotation);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originRotation (UnityEngine.Vector3)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.slackLevels != null)
		{
			for (int k = 0; k < instance.slackLevels.Count; k++)
			{
				float f = instance.slackLevels[k];
				stream.WriteByte(109);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public static void Serialize(BufferStream stream, IOConnection instance)
	{
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_030a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.niceName != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.niceName);
		}
		if (instance.type != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.connectedID != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.connectedID.Value);
		}
		if (instance.connectedToSlot != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.connectedToSlot);
		}
		if (instance.inUse)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.inUse);
		}
		if (instance.linePointList != null)
		{
			for (int i = 0; i < instance.linePointList.Count; i++)
			{
				LineVec instance2 = instance.linePointList[i];
				stream.WriteByte(50);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				LineVec.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field linePointList (ProtoBuf.IOEntity.IOConnection.LineVec)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.colour != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colour);
		}
		if (instance.worldSpaceRotation != default(Vector3))
		{
			stream.WriteByte(66);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.worldSpaceRotation);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field worldSpaceRotation (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.lineThickness != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.lineThickness);
		}
		if (instance.lineAnchorList != null)
		{
			for (int j = 0; j < instance.lineAnchorList.Count; j++)
			{
				WireLineAnchorInfo instance3 = instance.lineAnchorList[j];
				stream.WriteByte(82);
				BufferStream.RangeHandle range3 = stream.GetRange(5);
				int position3 = stream.Position;
				WireLineAnchorInfo.Serialize(stream, instance3);
				int val = stream.Position - position3;
				Span<byte> span3 = range3.GetSpan();
				int num3 = ProtocolParser.WriteUInt32((uint)val, span3, 0);
				if (num3 < 5)
				{
					span3[num3 - 1] |= 128;
					while (num3 < 4)
					{
						span3[num3++] = 128;
					}
					span3[4] = 0;
				}
			}
		}
		if (instance.originPosition != default(Vector3))
		{
			stream.WriteByte(90);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.originPosition);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originPosition (UnityEngine.Vector3)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
		if (instance.originRotation != default(Vector3))
		{
			stream.WriteByte(98);
			BufferStream.RangeHandle range5 = stream.GetRange(1);
			int position5 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.originRotation);
			int num5 = stream.Position - position5;
			if (num5 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field originRotation (UnityEngine.Vector3)");
			}
			Span<byte> span5 = range5.GetSpan();
			ProtocolParser.WriteUInt32((uint)num5, span5, 0);
		}
		if (instance.slackLevels != null)
		{
			for (int k = 0; k < instance.slackLevels.Count; k++)
			{
				float f = instance.slackLevels[k];
				stream.WriteByte(109);
				ProtocolParser.WriteSingle(stream, f);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref connectedID.Value);
		if (linePointList != null)
		{
			for (int i = 0; i < linePointList.Count; i++)
			{
				linePointList[i]?.InspectUids(action);
			}
		}
		if (lineAnchorList != null)
		{
			for (int j = 0; j < lineAnchorList.Count; j++)
			{
				lineAnchorList[j]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class PlayerRelationshipInfo : IDisposable, IPooled, IProto<PlayerRelationshipInfo>, IProto
{
	[NonSerialized]
	public ulong playerID;

	[NonSerialized]
	public int type;

	[NonSerialized]
	public int weight;

	[NonSerialized]
	public uint mugshotCrc;

	[NonSerialized]
	public string displayName;

	[NonSerialized]
	public string notes;

	[NonSerialized]
	public float timeSinceSeen;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerRelationshipInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.playerID = 0uL;
			instance.type = 0;
			instance.weight = 0;
			instance.mugshotCrc = 0u;
			instance.displayName = string.Empty;
			instance.notes = string.Empty;
			instance.timeSinceSeen = 0f;
			Pool.Free<PlayerRelationshipInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerRelationshipInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerRelationshipInfo instance)
	{
		instance.playerID = playerID;
		instance.type = type;
		instance.weight = weight;
		instance.mugshotCrc = mugshotCrc;
		instance.displayName = displayName;
		instance.notes = notes;
		instance.timeSinceSeen = timeSinceSeen;
	}

	public PlayerRelationshipInfo Copy()
	{
		PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
		CopyTo(playerRelationshipInfo);
		return playerRelationshipInfo;
	}

	public static PlayerRelationshipInfo Deserialize(BufferStream stream)
	{
		PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
		Deserialize(stream, playerRelationshipInfo, isDelta: false);
		return playerRelationshipInfo;
	}

	public static PlayerRelationshipInfo DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
		DeserializeLengthDelimited(stream, playerRelationshipInfo, isDelta: false);
		return playerRelationshipInfo;
	}

	public static PlayerRelationshipInfo DeserializeLength(BufferStream stream, int length)
	{
		PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
		DeserializeLength(stream, length, playerRelationshipInfo, isDelta: false);
		return playerRelationshipInfo;
	}

	public static PlayerRelationshipInfo Deserialize(byte[] buffer)
	{
		PlayerRelationshipInfo playerRelationshipInfo = Pool.Get<PlayerRelationshipInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerRelationshipInfo, isDelta: false);
		return playerRelationshipInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerRelationshipInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerRelationshipInfo Deserialize(BufferStream stream, PlayerRelationshipInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.weight = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.mugshotCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.notes = ProtocolParser.ReadString(stream);
				continue;
			case 61:
				instance.timeSinceSeen = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerRelationshipInfo DeserializeLengthDelimited(BufferStream stream, PlayerRelationshipInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.weight = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.mugshotCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.notes = ProtocolParser.ReadString(stream);
				continue;
			case 61:
				instance.timeSinceSeen = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerRelationshipInfo DeserializeLength(BufferStream stream, int length, PlayerRelationshipInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.weight = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.mugshotCrc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 42:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.notes = ProtocolParser.ReadString(stream);
				continue;
			case 61:
				instance.timeSinceSeen = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerRelationshipInfo instance, PlayerRelationshipInfo previous)
	{
		if (instance.playerID != previous.playerID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.playerID);
		}
		if (instance.type != previous.type)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.weight != previous.weight)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.weight);
		}
		if (instance.mugshotCrc != previous.mugshotCrc)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.mugshotCrc);
		}
		if (instance.displayName != null && instance.displayName != previous.displayName)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.displayName);
		}
		if (instance.notes != null && instance.notes != previous.notes)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.notes);
		}
		if (instance.timeSinceSeen != previous.timeSinceSeen)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.timeSinceSeen);
		}
	}

	public static void Serialize(BufferStream stream, PlayerRelationshipInfo instance)
	{
		if (instance.playerID != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.playerID);
		}
		if (instance.type != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.weight != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.weight);
		}
		if (instance.mugshotCrc != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.mugshotCrc);
		}
		if (instance.displayName != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.displayName);
		}
		if (instance.notes != null)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.notes);
		}
		if (instance.timeSinceSeen != 0f)
		{
			stream.WriteByte(61);
			ProtocolParser.WriteSingle(stream, instance.timeSinceSeen);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class PlayerRelationships : IDisposable, IPooled, IProto<PlayerRelationships>, IProto
{
	[NonSerialized]
	public ulong playerID;

	[NonSerialized]
	public List<PlayerRelationshipInfo> relations;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerRelationships instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.playerID = 0uL;
		if (instance.relations != null)
		{
			for (int i = 0; i < instance.relations.Count; i++)
			{
				if (instance.relations[i] != null)
				{
					instance.relations[i].ResetToPool();
					instance.relations[i] = null;
				}
			}
			List<PlayerRelationshipInfo> list = instance.relations;
			Pool.Free<PlayerRelationshipInfo>(ref list, false);
			instance.relations = list;
		}
		Pool.Free<PlayerRelationships>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerRelationships with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerRelationships instance)
	{
		instance.playerID = playerID;
		if (relations != null)
		{
			instance.relations = Pool.Get<List<PlayerRelationshipInfo>>();
			for (int i = 0; i < relations.Count; i++)
			{
				PlayerRelationshipInfo item = relations[i].Copy();
				instance.relations.Add(item);
			}
		}
		else
		{
			instance.relations = null;
		}
	}

	public PlayerRelationships Copy()
	{
		PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
		CopyTo(playerRelationships);
		return playerRelationships;
	}

	public static PlayerRelationships Deserialize(BufferStream stream)
	{
		PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
		Deserialize(stream, playerRelationships, isDelta: false);
		return playerRelationships;
	}

	public static PlayerRelationships DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
		DeserializeLengthDelimited(stream, playerRelationships, isDelta: false);
		return playerRelationships;
	}

	public static PlayerRelationships DeserializeLength(BufferStream stream, int length)
	{
		PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
		DeserializeLength(stream, length, playerRelationships, isDelta: false);
		return playerRelationships;
	}

	public static PlayerRelationships Deserialize(byte[] buffer)
	{
		PlayerRelationships playerRelationships = Pool.Get<PlayerRelationships>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerRelationships, isDelta: false);
		return playerRelationships;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerRelationships previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerRelationships Deserialize(BufferStream stream, PlayerRelationships instance, bool isDelta)
	{
		if (!isDelta && instance.relations == null)
		{
			instance.relations = Pool.Get<List<PlayerRelationshipInfo>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.relations.Add(PlayerRelationshipInfo.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerRelationships DeserializeLengthDelimited(BufferStream stream, PlayerRelationships instance, bool isDelta)
	{
		if (!isDelta && instance.relations == null)
		{
			instance.relations = Pool.Get<List<PlayerRelationshipInfo>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.relations.Add(PlayerRelationshipInfo.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerRelationships DeserializeLength(BufferStream stream, int length, PlayerRelationships instance, bool isDelta)
	{
		if (!isDelta && instance.relations == null)
		{
			instance.relations = Pool.Get<List<PlayerRelationshipInfo>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.relations.Add(PlayerRelationshipInfo.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerRelationships instance, PlayerRelationships previous)
	{
		if (instance.playerID != previous.playerID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.playerID);
		}
		if (instance.relations == null)
		{
			return;
		}
		for (int i = 0; i < instance.relations.Count; i++)
		{
			PlayerRelationshipInfo playerRelationshipInfo = instance.relations[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerRelationshipInfo.SerializeDelta(stream, playerRelationshipInfo, playerRelationshipInfo);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, PlayerRelationships instance)
	{
		if (instance.playerID != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.playerID);
		}
		if (instance.relations == null)
		{
			return;
		}
		for (int i = 0; i < instance.relations.Count; i++)
		{
			PlayerRelationshipInfo instance2 = instance.relations[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerRelationshipInfo.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (relations != null)
		{
			for (int i = 0; i < relations.Count; i++)
			{
				relations[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class EggHunter : IDisposable, IPooled, IProto<EggHunter>, IProto
{
	[NonSerialized]
	public string displayName;

	[NonSerialized]
	public int numEggs;

	[NonSerialized]
	public ulong playerID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(EggHunter instance)
	{
		if (instance.ShouldPool)
		{
			instance.displayName = string.Empty;
			instance.numEggs = 0;
			instance.playerID = 0uL;
			Pool.Free<EggHunter>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose EggHunter with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(EggHunter instance)
	{
		instance.displayName = displayName;
		instance.numEggs = numEggs;
		instance.playerID = playerID;
	}

	public EggHunter Copy()
	{
		EggHunter eggHunter = Pool.Get<EggHunter>();
		CopyTo(eggHunter);
		return eggHunter;
	}

	public static EggHunter Deserialize(BufferStream stream)
	{
		EggHunter eggHunter = Pool.Get<EggHunter>();
		Deserialize(stream, eggHunter, isDelta: false);
		return eggHunter;
	}

	public static EggHunter DeserializeLengthDelimited(BufferStream stream)
	{
		EggHunter eggHunter = Pool.Get<EggHunter>();
		DeserializeLengthDelimited(stream, eggHunter, isDelta: false);
		return eggHunter;
	}

	public static EggHunter DeserializeLength(BufferStream stream, int length)
	{
		EggHunter eggHunter = Pool.Get<EggHunter>();
		DeserializeLength(stream, length, eggHunter, isDelta: false);
		return eggHunter;
	}

	public static EggHunter Deserialize(byte[] buffer)
	{
		EggHunter eggHunter = Pool.Get<EggHunter>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, eggHunter, isDelta: false);
		return eggHunter;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, EggHunter previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static EggHunter Deserialize(BufferStream stream, EggHunter instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.numEggs = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static EggHunter DeserializeLengthDelimited(BufferStream stream, EggHunter instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.numEggs = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static EggHunter DeserializeLength(BufferStream stream, int length, EggHunter instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.numEggs = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, EggHunter instance, EggHunter previous)
	{
		if (instance.displayName != null && instance.displayName != previous.displayName)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.displayName);
		}
		if (instance.numEggs != previous.numEggs)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numEggs);
		}
		if (instance.playerID != previous.playerID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.playerID);
		}
	}

	public static void Serialize(BufferStream stream, EggHunter instance)
	{
		if (instance.displayName != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.displayName);
		}
		if (instance.numEggs != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numEggs);
		}
		if (instance.playerID != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.playerID);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ScoreEntry : IDisposable, IPooled, IProto<ScoreEntry>, IProto
{
	[NonSerialized]
	public ulong playerID;

	[NonSerialized]
	public string displayName;

	[NonSerialized]
	public int score;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ScoreEntry instance)
	{
		if (instance.ShouldPool)
		{
			instance.playerID = 0uL;
			instance.displayName = string.Empty;
			instance.score = 0;
			Pool.Free<ScoreEntry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ScoreEntry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ScoreEntry instance)
	{
		instance.playerID = playerID;
		instance.displayName = displayName;
		instance.score = score;
	}

	public ScoreEntry Copy()
	{
		ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
		CopyTo(scoreEntry);
		return scoreEntry;
	}

	public static ScoreEntry Deserialize(BufferStream stream)
	{
		ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
		Deserialize(stream, scoreEntry, isDelta: false);
		return scoreEntry;
	}

	public static ScoreEntry DeserializeLengthDelimited(BufferStream stream)
	{
		ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
		DeserializeLengthDelimited(stream, scoreEntry, isDelta: false);
		return scoreEntry;
	}

	public static ScoreEntry DeserializeLength(BufferStream stream, int length)
	{
		ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
		DeserializeLength(stream, length, scoreEntry, isDelta: false);
		return scoreEntry;
	}

	public static ScoreEntry Deserialize(byte[] buffer)
	{
		ScoreEntry scoreEntry = Pool.Get<ScoreEntry>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, scoreEntry, isDelta: false);
		return scoreEntry;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ScoreEntry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ScoreEntry Deserialize(BufferStream stream, ScoreEntry instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ScoreEntry DeserializeLengthDelimited(BufferStream stream, ScoreEntry instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ScoreEntry DeserializeLength(BufferStream stream, int length, ScoreEntry instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.playerID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ScoreEntry instance, ScoreEntry previous)
	{
		if (instance.playerID != previous.playerID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.playerID);
		}
		if (instance.displayName != null && instance.displayName != previous.displayName)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.displayName);
		}
		if (instance.score != previous.score)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
	}

	public static void Serialize(BufferStream stream, ScoreEntry instance)
	{
		if (instance.playerID != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.playerID);
		}
		if (instance.displayName != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.displayName);
		}
		if (instance.score != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class StringPoint : IDisposable, IPooled, IProto<StringPoint>, IProto
{
	[NonSerialized]
	public Vector3 point;

	[NonSerialized]
	public Vector3 normal;

	[NonSerialized]
	public float slack;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(StringPoint instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.point = default(Vector3);
			instance.normal = default(Vector3);
			instance.slack = 0f;
			Pool.Free<StringPoint>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose StringPoint with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(StringPoint instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.point = point;
		instance.normal = normal;
		instance.slack = slack;
	}

	public StringPoint Copy()
	{
		StringPoint stringPoint = Pool.Get<StringPoint>();
		CopyTo(stringPoint);
		return stringPoint;
	}

	public static StringPoint Deserialize(BufferStream stream)
	{
		StringPoint stringPoint = Pool.Get<StringPoint>();
		Deserialize(stream, stringPoint, isDelta: false);
		return stringPoint;
	}

	public static StringPoint DeserializeLengthDelimited(BufferStream stream)
	{
		StringPoint stringPoint = Pool.Get<StringPoint>();
		DeserializeLengthDelimited(stream, stringPoint, isDelta: false);
		return stringPoint;
	}

	public static StringPoint DeserializeLength(BufferStream stream, int length)
	{
		StringPoint stringPoint = Pool.Get<StringPoint>();
		DeserializeLength(stream, length, stringPoint, isDelta: false);
		return stringPoint;
	}

	public static StringPoint Deserialize(byte[] buffer)
	{
		StringPoint stringPoint = Pool.Get<StringPoint>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, stringPoint, isDelta: false);
		return stringPoint;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, StringPoint previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static StringPoint Deserialize(BufferStream stream, StringPoint instance, bool isDelta)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.point, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 29:
				instance.slack = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static StringPoint DeserializeLengthDelimited(BufferStream stream, StringPoint instance, bool isDelta)
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.point, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 29:
				instance.slack = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static StringPoint DeserializeLength(BufferStream stream, int length, StringPoint instance, bool isDelta)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.point, isDelta);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.normal, isDelta);
				continue;
			case 29:
				instance.slack = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, StringPoint instance, StringPoint previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (instance.point != previous.point)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.point, previous.point);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field point (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.normal != previous.normal)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.SerializeDelta(stream, instance.normal, previous.normal);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.slack != previous.slack)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.slack);
		}
	}

	public static void Serialize(BufferStream stream, StringPoint instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		if (instance.point != default(Vector3))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			Vector3Serialized.Serialize(stream, instance.point);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field point (UnityEngine.Vector3)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.normal != default(Vector3))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			Vector3Serialized.Serialize(stream, instance.normal);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field normal (UnityEngine.Vector3)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.slack != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.slack);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class PlayerStorage : IDisposable, IPooled, IProto<PlayerStorage>, IProto
{
	public class PlayerStoredVehicle : IDisposable, IPooled, IProto<PlayerStoredVehicle>, IProto
	{
		[NonSerialized]
		public string shortname;

		[NonSerialized]
		public string resourcePath;

		[NonSerialized]
		public float health;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(PlayerStoredVehicle instance)
		{
			if (instance.ShouldPool)
			{
				instance.shortname = string.Empty;
				instance.resourcePath = string.Empty;
				instance.health = 0f;
				Pool.Free<PlayerStoredVehicle>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose PlayerStoredVehicle with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(PlayerStoredVehicle instance)
		{
			instance.shortname = shortname;
			instance.resourcePath = resourcePath;
			instance.health = health;
		}

		public PlayerStoredVehicle Copy()
		{
			PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
			CopyTo(playerStoredVehicle);
			return playerStoredVehicle;
		}

		public static PlayerStoredVehicle Deserialize(BufferStream stream)
		{
			PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
			Deserialize(stream, playerStoredVehicle, isDelta: false);
			return playerStoredVehicle;
		}

		public static PlayerStoredVehicle DeserializeLengthDelimited(BufferStream stream)
		{
			PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
			DeserializeLengthDelimited(stream, playerStoredVehicle, isDelta: false);
			return playerStoredVehicle;
		}

		public static PlayerStoredVehicle DeserializeLength(BufferStream stream, int length)
		{
			PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
			DeserializeLength(stream, length, playerStoredVehicle, isDelta: false);
			return playerStoredVehicle;
		}

		public static PlayerStoredVehicle Deserialize(byte[] buffer)
		{
			PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, playerStoredVehicle, isDelta: false);
			return playerStoredVehicle;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, PlayerStoredVehicle previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static PlayerStoredVehicle Deserialize(BufferStream stream, PlayerStoredVehicle instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 10:
					instance.shortname = ProtocolParser.ReadString(stream);
					continue;
				case 18:
					instance.resourcePath = ProtocolParser.ReadString(stream);
					continue;
				case 29:
					instance.health = ProtocolParser.ReadSingle(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static PlayerStoredVehicle DeserializeLengthDelimited(BufferStream stream, PlayerStoredVehicle instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.shortname = ProtocolParser.ReadString(stream);
					continue;
				case 18:
					instance.resourcePath = ProtocolParser.ReadString(stream);
					continue;
				case 29:
					instance.health = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static PlayerStoredVehicle DeserializeLength(BufferStream stream, int length, PlayerStoredVehicle instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 10:
					instance.shortname = ProtocolParser.ReadString(stream);
					continue;
				case 18:
					instance.resourcePath = ProtocolParser.ReadString(stream);
					continue;
				case 29:
					instance.health = ProtocolParser.ReadSingle(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, PlayerStoredVehicle instance, PlayerStoredVehicle previous)
		{
			if (instance.shortname != null && instance.shortname != previous.shortname)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.shortname);
			}
			if (instance.resourcePath != null && instance.resourcePath != previous.resourcePath)
			{
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.resourcePath);
			}
			if (instance.health != previous.health)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.health);
			}
		}

		public static void Serialize(BufferStream stream, PlayerStoredVehicle instance)
		{
			if (instance.shortname != null)
			{
				stream.WriteByte(10);
				ProtocolParser.WriteString(stream, instance.shortname);
			}
			if (instance.resourcePath != null)
			{
				stream.WriteByte(18);
				ProtocolParser.WriteString(stream, instance.resourcePath);
			}
			if (instance.health != 0f)
			{
				stream.WriteByte(29);
				ProtocolParser.WriteSingle(stream, instance.health);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public ulong userid;

	[NonSerialized]
	public List<PlayerStoredVehicle> storedVehicles;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerStorage instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.userid = 0uL;
		if (instance.storedVehicles != null)
		{
			for (int i = 0; i < instance.storedVehicles.Count; i++)
			{
				if (instance.storedVehicles[i] != null)
				{
					instance.storedVehicles[i].ResetToPool();
					instance.storedVehicles[i] = null;
				}
			}
			List<PlayerStoredVehicle> list = instance.storedVehicles;
			Pool.Free<PlayerStoredVehicle>(ref list, false);
			instance.storedVehicles = list;
		}
		Pool.Free<PlayerStorage>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerStorage with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerStorage instance)
	{
		instance.userid = userid;
		if (storedVehicles != null)
		{
			instance.storedVehicles = Pool.Get<List<PlayerStoredVehicle>>();
			for (int i = 0; i < storedVehicles.Count; i++)
			{
				PlayerStoredVehicle item = storedVehicles[i].Copy();
				instance.storedVehicles.Add(item);
			}
		}
		else
		{
			instance.storedVehicles = null;
		}
	}

	public PlayerStorage Copy()
	{
		PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
		CopyTo(playerStorage);
		return playerStorage;
	}

	public static PlayerStorage Deserialize(BufferStream stream)
	{
		PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
		Deserialize(stream, playerStorage, isDelta: false);
		return playerStorage;
	}

	public static PlayerStorage DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
		DeserializeLengthDelimited(stream, playerStorage, isDelta: false);
		return playerStorage;
	}

	public static PlayerStorage DeserializeLength(BufferStream stream, int length)
	{
		PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
		DeserializeLength(stream, length, playerStorage, isDelta: false);
		return playerStorage;
	}

	public static PlayerStorage Deserialize(byte[] buffer)
	{
		PlayerStorage playerStorage = Pool.Get<PlayerStorage>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerStorage, isDelta: false);
		return playerStorage;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerStorage previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerStorage Deserialize(BufferStream stream, PlayerStorage instance, bool isDelta)
	{
		if (!isDelta && instance.storedVehicles == null)
		{
			instance.storedVehicles = Pool.Get<List<PlayerStoredVehicle>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.storedVehicles.Add(PlayerStoredVehicle.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerStorage DeserializeLengthDelimited(BufferStream stream, PlayerStorage instance, bool isDelta)
	{
		if (!isDelta && instance.storedVehicles == null)
		{
			instance.storedVehicles = Pool.Get<List<PlayerStoredVehicle>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.storedVehicles.Add(PlayerStoredVehicle.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerStorage DeserializeLength(BufferStream stream, int length, PlayerStorage instance, bool isDelta)
	{
		if (!isDelta && instance.storedVehicles == null)
		{
			instance.storedVehicles = Pool.Get<List<PlayerStoredVehicle>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.storedVehicles.Add(PlayerStoredVehicle.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerStorage instance, PlayerStorage previous)
	{
		if (instance.userid != previous.userid)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
		if (instance.storedVehicles == null)
		{
			return;
		}
		for (int i = 0; i < instance.storedVehicles.Count; i++)
		{
			PlayerStoredVehicle playerStoredVehicle = instance.storedVehicles[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerStoredVehicle.SerializeDelta(stream, playerStoredVehicle, playerStoredVehicle);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, PlayerStorage instance)
	{
		if (instance.userid != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
		if (instance.storedVehicles == null)
		{
			return;
		}
		for (int i = 0; i < instance.storedVehicles.Count; i++)
		{
			PlayerStoredVehicle instance2 = instance.storedVehicles[i];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(5);
			int position = stream.Position;
			PlayerStoredVehicle.Serialize(stream, instance2);
			int val = stream.Position - position;
			Span<byte> span = range.GetSpan();
			int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
			if (num < 5)
			{
				span[num - 1] |= 128;
				while (num < 4)
				{
					span[num++] = 128;
				}
				span[4] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (storedVehicles != null)
		{
			for (int i = 0; i < storedVehicles.Count; i++)
			{
				storedVehicles[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Lights : IDisposable, IPooled, IProto<Lights>, IProto
{
	[NonSerialized]
	public Color topLeft;

	[NonSerialized]
	public Color topRight;

	[NonSerialized]
	public Color bottomLeft;

	[NonSerialized]
	public Color bottomRight;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Lights instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.topLeft = default(Color);
			instance.topRight = default(Color);
			instance.bottomLeft = default(Color);
			instance.bottomRight = default(Color);
			Pool.Free<Lights>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Lights with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Lights instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		instance.topLeft = topLeft;
		instance.topRight = topRight;
		instance.bottomLeft = bottomLeft;
		instance.bottomRight = bottomRight;
	}

	public Lights Copy()
	{
		Lights lights = Pool.Get<Lights>();
		CopyTo(lights);
		return lights;
	}

	public static Lights Deserialize(BufferStream stream)
	{
		Lights lights = Pool.Get<Lights>();
		Deserialize(stream, lights, isDelta: false);
		return lights;
	}

	public static Lights DeserializeLengthDelimited(BufferStream stream)
	{
		Lights lights = Pool.Get<Lights>();
		DeserializeLengthDelimited(stream, lights, isDelta: false);
		return lights;
	}

	public static Lights DeserializeLength(BufferStream stream, int length)
	{
		Lights lights = Pool.Get<Lights>();
		DeserializeLength(stream, length, lights, isDelta: false);
		return lights;
	}

	public static Lights Deserialize(byte[] buffer)
	{
		Lights lights = Pool.Get<Lights>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, lights, isDelta: false);
		return lights;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Lights previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Lights Deserialize(BufferStream stream, Lights instance, bool isDelta)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topLeft, isDelta);
				continue;
			case 18:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topRight, isDelta);
				continue;
			case 26:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomLeft, isDelta);
				continue;
			case 34:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomRight, isDelta);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Lights DeserializeLengthDelimited(BufferStream stream, Lights instance, bool isDelta)
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topLeft, isDelta);
				continue;
			case 18:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topRight, isDelta);
				continue;
			case 26:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomLeft, isDelta);
				continue;
			case 34:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomRight, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Lights DeserializeLength(BufferStream stream, int length, Lights instance, bool isDelta)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topLeft, isDelta);
				continue;
			case 18:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.topRight, isDelta);
				continue;
			case 26:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomLeft, isDelta);
				continue;
			case 34:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.bottomRight, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Lights instance, Lights previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		if (instance.topLeft != previous.topLeft)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ColorSerialized.SerializeDelta(stream, instance.topLeft, previous.topLeft);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topLeft (UnityEngine.Color)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.topRight != previous.topRight)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			ColorSerialized.SerializeDelta(stream, instance.topRight, previous.topRight);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topRight (UnityEngine.Color)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.bottomLeft != previous.bottomLeft)
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			ColorSerialized.SerializeDelta(stream, instance.bottomLeft, previous.bottomLeft);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bottomLeft (UnityEngine.Color)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.bottomRight != previous.bottomRight)
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			ColorSerialized.SerializeDelta(stream, instance.bottomRight, previous.bottomRight);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bottomRight (UnityEngine.Color)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
	}

	public static void Serialize(BufferStream stream, Lights instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		if (instance.topLeft != default(Color))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int position = stream.Position;
			ColorSerialized.Serialize(stream, instance.topLeft);
			int num = stream.Position - position;
			if (num > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topLeft (UnityEngine.Color)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num, span, 0);
		}
		if (instance.topRight != default(Color))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int position2 = stream.Position;
			ColorSerialized.Serialize(stream, instance.topRight);
			int num2 = stream.Position - position2;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field topRight (UnityEngine.Color)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span2, 0);
		}
		if (instance.bottomLeft != default(Color))
		{
			stream.WriteByte(26);
			BufferStream.RangeHandle range3 = stream.GetRange(1);
			int position3 = stream.Position;
			ColorSerialized.Serialize(stream, instance.bottomLeft);
			int num3 = stream.Position - position3;
			if (num3 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bottomLeft (UnityEngine.Color)");
			}
			Span<byte> span3 = range3.GetSpan();
			ProtocolParser.WriteUInt32((uint)num3, span3, 0);
		}
		if (instance.bottomRight != default(Color))
		{
			stream.WriteByte(34);
			BufferStream.RangeHandle range4 = stream.GetRange(1);
			int position4 = stream.Position;
			ColorSerialized.Serialize(stream, instance.bottomRight);
			int num4 = stream.Position - position4;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field bottomRight (UnityEngine.Color)");
			}
			Span<byte> span4 = range4.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span4, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class PendingOrder : IDisposable, IPooled, IProto<PendingOrder>, IProto
{
	[NonSerialized]
	public NetworkableId vendingMachineId;

	[NonSerialized]
	public NetworkableId droneId;

	[NonSerialized]
	public TimeUntil timeUntilExpiry;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PendingOrder instance)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.vendingMachineId = default(NetworkableId);
			instance.droneId = default(NetworkableId);
			instance.timeUntilExpiry = TimeUntil.op_Implicit(0f);
			Pool.Free<PendingOrder>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PendingOrder with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PendingOrder instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.vendingMachineId = vendingMachineId;
		instance.droneId = droneId;
		instance.timeUntilExpiry = timeUntilExpiry;
	}

	public PendingOrder Copy()
	{
		PendingOrder pendingOrder = Pool.Get<PendingOrder>();
		CopyTo(pendingOrder);
		return pendingOrder;
	}

	public static PendingOrder Deserialize(BufferStream stream)
	{
		PendingOrder pendingOrder = Pool.Get<PendingOrder>();
		Deserialize(stream, pendingOrder, isDelta: false);
		return pendingOrder;
	}

	public static PendingOrder DeserializeLengthDelimited(BufferStream stream)
	{
		PendingOrder pendingOrder = Pool.Get<PendingOrder>();
		DeserializeLengthDelimited(stream, pendingOrder, isDelta: false);
		return pendingOrder;
	}

	public static PendingOrder DeserializeLength(BufferStream stream, int length)
	{
		PendingOrder pendingOrder = Pool.Get<PendingOrder>();
		DeserializeLength(stream, length, pendingOrder, isDelta: false);
		return pendingOrder;
	}

	public static PendingOrder Deserialize(byte[] buffer)
	{
		PendingOrder pendingOrder = Pool.Get<PendingOrder>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, pendingOrder, isDelta: false);
		return pendingOrder;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PendingOrder previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PendingOrder Deserialize(BufferStream stream, PendingOrder instance, bool isDelta)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.droneId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 37:
				instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PendingOrder DeserializeLengthDelimited(BufferStream stream, PendingOrder instance, bool isDelta)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.droneId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 37:
				instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PendingOrder DeserializeLength(BufferStream stream, int length, PendingOrder instance, bool isDelta)
	{
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.vendingMachineId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.droneId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 37:
				instance.timeUntilExpiry = TimeUntil.op_Implicit(ProtocolParser.ReadSingle(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PendingOrder instance, PendingOrder previous)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.vendingMachineId.Value);
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, instance.droneId.Value);
		if (TimeUntil.op_Implicit(instance.timeUntilExpiry) != TimeUntil.op_Implicit(previous.timeUntilExpiry))
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, TimeUntil.op_Implicit(instance.timeUntilExpiry));
		}
	}

	public static void Serialize(BufferStream stream, PendingOrder instance)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		if (instance.vendingMachineId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.vendingMachineId.Value);
		}
		if (instance.droneId != default(NetworkableId))
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.droneId.Value);
		}
		if (TimeUntil.op_Implicit(instance.timeUntilExpiry) != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, TimeUntil.op_Implicit(instance.timeUntilExpiry));
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref vendingMachineId.Value);
		action(UidType.NetworkableId, ref droneId.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class TeamInfo : IDisposable, IPooled, IProto<TeamInfo>, IProto
{
	[NonSerialized]
	public int score;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TeamInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.score = 0;
			Pool.Free<TeamInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TeamInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TeamInfo instance)
	{
		instance.score = score;
	}

	public TeamInfo Copy()
	{
		TeamInfo teamInfo = Pool.Get<TeamInfo>();
		CopyTo(teamInfo);
		return teamInfo;
	}

	public static TeamInfo Deserialize(BufferStream stream)
	{
		TeamInfo teamInfo = Pool.Get<TeamInfo>();
		Deserialize(stream, teamInfo, isDelta: false);
		return teamInfo;
	}

	public static TeamInfo DeserializeLengthDelimited(BufferStream stream)
	{
		TeamInfo teamInfo = Pool.Get<TeamInfo>();
		DeserializeLengthDelimited(stream, teamInfo, isDelta: false);
		return teamInfo;
	}

	public static TeamInfo DeserializeLength(BufferStream stream, int length)
	{
		TeamInfo teamInfo = Pool.Get<TeamInfo>();
		DeserializeLength(stream, length, teamInfo, isDelta: false);
		return teamInfo;
	}

	public static TeamInfo Deserialize(byte[] buffer)
	{
		TeamInfo teamInfo = Pool.Get<TeamInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, teamInfo, isDelta: false);
		return teamInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TeamInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TeamInfo Deserialize(BufferStream stream, TeamInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TeamInfo DeserializeLengthDelimited(BufferStream stream, TeamInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TeamInfo DeserializeLength(BufferStream stream, int length, TeamInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TeamInfo instance, TeamInfo previous)
	{
		if (instance.score != previous.score)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
	}

	public static void Serialize(BufferStream stream, TeamInfo instance)
	{
		if (instance.score != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ScoreColumn : IDisposable, IPooled, IProto<ScoreColumn>, IProto
{
	[NonSerialized]
	public string name;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ScoreColumn instance)
	{
		if (instance.ShouldPool)
		{
			instance.name = string.Empty;
			Pool.Free<ScoreColumn>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ScoreColumn with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ScoreColumn instance)
	{
		instance.name = name;
	}

	public ScoreColumn Copy()
	{
		ScoreColumn scoreColumn = Pool.Get<ScoreColumn>();
		CopyTo(scoreColumn);
		return scoreColumn;
	}

	public static ScoreColumn Deserialize(BufferStream stream)
	{
		ScoreColumn scoreColumn = Pool.Get<ScoreColumn>();
		Deserialize(stream, scoreColumn, isDelta: false);
		return scoreColumn;
	}

	public static ScoreColumn DeserializeLengthDelimited(BufferStream stream)
	{
		ScoreColumn scoreColumn = Pool.Get<ScoreColumn>();
		DeserializeLengthDelimited(stream, scoreColumn, isDelta: false);
		return scoreColumn;
	}

	public static ScoreColumn DeserializeLength(BufferStream stream, int length)
	{
		ScoreColumn scoreColumn = Pool.Get<ScoreColumn>();
		DeserializeLength(stream, length, scoreColumn, isDelta: false);
		return scoreColumn;
	}

	public static ScoreColumn Deserialize(byte[] buffer)
	{
		ScoreColumn scoreColumn = Pool.Get<ScoreColumn>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, scoreColumn, isDelta: false);
		return scoreColumn;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ScoreColumn previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ScoreColumn Deserialize(BufferStream stream, ScoreColumn instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ScoreColumn DeserializeLengthDelimited(BufferStream stream, ScoreColumn instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ScoreColumn DeserializeLength(BufferStream stream, int length, ScoreColumn instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ScoreColumn instance, ScoreColumn previous)
	{
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
	}

	public static void Serialize(BufferStream stream, ScoreColumn instance)
	{
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.name);
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class PlayerScore : IDisposable, IPooled, IProto<PlayerScore>, IProto
{
	[NonSerialized]
	public string playerName;

	[NonSerialized]
	public ulong userid;

	[NonSerialized]
	public List<int> scores;

	[NonSerialized]
	public int team;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerScore instance)
	{
		if (instance.ShouldPool)
		{
			instance.playerName = string.Empty;
			instance.userid = 0uL;
			if (instance.scores != null)
			{
				List<int> list = instance.scores;
				Pool.FreeUnmanaged<int>(ref list);
				instance.scores = list;
			}
			instance.team = 0;
			Pool.Free<PlayerScore>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerScore with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerScore instance)
	{
		instance.playerName = playerName;
		instance.userid = userid;
		if (scores != null)
		{
			instance.scores = Pool.Get<List<int>>();
			for (int i = 0; i < scores.Count; i++)
			{
				int item = scores[i];
				instance.scores.Add(item);
			}
		}
		else
		{
			instance.scores = null;
		}
		instance.team = team;
	}

	public PlayerScore Copy()
	{
		PlayerScore playerScore = Pool.Get<PlayerScore>();
		CopyTo(playerScore);
		return playerScore;
	}

	public static PlayerScore Deserialize(BufferStream stream)
	{
		PlayerScore playerScore = Pool.Get<PlayerScore>();
		Deserialize(stream, playerScore, isDelta: false);
		return playerScore;
	}

	public static PlayerScore DeserializeLengthDelimited(BufferStream stream)
	{
		PlayerScore playerScore = Pool.Get<PlayerScore>();
		DeserializeLengthDelimited(stream, playerScore, isDelta: false);
		return playerScore;
	}

	public static PlayerScore DeserializeLength(BufferStream stream, int length)
	{
		PlayerScore playerScore = Pool.Get<PlayerScore>();
		DeserializeLength(stream, length, playerScore, isDelta: false);
		return playerScore;
	}

	public static PlayerScore Deserialize(byte[] buffer)
	{
		PlayerScore playerScore = Pool.Get<PlayerScore>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, playerScore, isDelta: false);
		return playerScore;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, PlayerScore previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerScore Deserialize(BufferStream stream, PlayerScore instance, bool isDelta)
	{
		if (!isDelta && instance.scores == null)
		{
			instance.scores = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.scores.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.team = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerScore DeserializeLengthDelimited(BufferStream stream, PlayerScore instance, bool isDelta)
	{
		if (!isDelta && instance.scores == null)
		{
			instance.scores = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.scores.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.team = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerScore DeserializeLength(BufferStream stream, int length, PlayerScore instance, bool isDelta)
	{
		if (!isDelta && instance.scores == null)
		{
			instance.scores = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.playerName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.scores.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 32:
				instance.team = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, PlayerScore instance, PlayerScore previous)
	{
		if (instance.playerName != previous.playerName)
		{
			if (instance.playerName == null)
			{
				throw new ArgumentNullException("playerName", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.playerName);
		}
		if (instance.userid != previous.userid)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
		if (instance.scores != null)
		{
			for (int i = 0; i < instance.scores.Count; i++)
			{
				int num = instance.scores[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.team != previous.team)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.team);
		}
	}

	public static void Serialize(BufferStream stream, PlayerScore instance)
	{
		if (instance.playerName == null)
		{
			throw new ArgumentNullException("playerName", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.playerName);
		if (instance.userid != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
		if (instance.scores != null)
		{
			for (int i = 0; i < instance.scores.Count; i++)
			{
				int num = instance.scores[i];
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.team != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.team);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ReclaimInfo : IDisposable, IPooled, IProto<ReclaimInfo>, IProto
{
	[NonSerialized]
	public ulong victimID;

	[NonSerialized]
	public ItemContainer mainInventory;

	[NonSerialized]
	public ItemContainer wearInventory;

	[NonSerialized]
	public ItemContainer beltInventory;

	[NonSerialized]
	public ItemContainer backpackInventory;

	[NonSerialized]
	public int reclaimId;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ReclaimInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.victimID = 0uL;
			if (instance.mainInventory != null)
			{
				instance.mainInventory.ResetToPool();
				instance.mainInventory = null;
			}
			if (instance.wearInventory != null)
			{
				instance.wearInventory.ResetToPool();
				instance.wearInventory = null;
			}
			if (instance.beltInventory != null)
			{
				instance.beltInventory.ResetToPool();
				instance.beltInventory = null;
			}
			if (instance.backpackInventory != null)
			{
				instance.backpackInventory.ResetToPool();
				instance.backpackInventory = null;
			}
			instance.reclaimId = 0;
			Pool.Free<ReclaimInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ReclaimInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ReclaimInfo instance)
	{
		instance.victimID = victimID;
		if (mainInventory != null)
		{
			if (instance.mainInventory == null)
			{
				instance.mainInventory = mainInventory.Copy();
			}
			else
			{
				mainInventory.CopyTo(instance.mainInventory);
			}
		}
		else
		{
			instance.mainInventory = null;
		}
		if (wearInventory != null)
		{
			if (instance.wearInventory == null)
			{
				instance.wearInventory = wearInventory.Copy();
			}
			else
			{
				wearInventory.CopyTo(instance.wearInventory);
			}
		}
		else
		{
			instance.wearInventory = null;
		}
		if (beltInventory != null)
		{
			if (instance.beltInventory == null)
			{
				instance.beltInventory = beltInventory.Copy();
			}
			else
			{
				beltInventory.CopyTo(instance.beltInventory);
			}
		}
		else
		{
			instance.beltInventory = null;
		}
		if (backpackInventory != null)
		{
			if (instance.backpackInventory == null)
			{
				instance.backpackInventory = backpackInventory.Copy();
			}
			else
			{
				backpackInventory.CopyTo(instance.backpackInventory);
			}
		}
		else
		{
			instance.backpackInventory = null;
		}
		instance.reclaimId = reclaimId;
	}

	public ReclaimInfo Copy()
	{
		ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
		CopyTo(reclaimInfo);
		return reclaimInfo;
	}

	public static ReclaimInfo Deserialize(BufferStream stream)
	{
		ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
		Deserialize(stream, reclaimInfo, isDelta: false);
		return reclaimInfo;
	}

	public static ReclaimInfo DeserializeLengthDelimited(BufferStream stream)
	{
		ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
		DeserializeLengthDelimited(stream, reclaimInfo, isDelta: false);
		return reclaimInfo;
	}

	public static ReclaimInfo DeserializeLength(BufferStream stream, int length)
	{
		ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
		DeserializeLength(stream, length, reclaimInfo, isDelta: false);
		return reclaimInfo;
	}

	public static ReclaimInfo Deserialize(byte[] buffer)
	{
		ReclaimInfo reclaimInfo = Pool.Get<ReclaimInfo>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, reclaimInfo, isDelta: false);
		return reclaimInfo;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, ReclaimInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ReclaimInfo Deserialize(BufferStream stream, ReclaimInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.victimID = ProtocolParser.ReadUInt64(stream);
				break;
			case 34:
				if (instance.mainInventory == null)
				{
					instance.mainInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.mainInventory, isDelta);
				}
				break;
			case 42:
				if (instance.wearInventory == null)
				{
					instance.wearInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.wearInventory, isDelta);
				}
				break;
			case 50:
				if (instance.beltInventory == null)
				{
					instance.beltInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.beltInventory, isDelta);
				}
				break;
			case 58:
				if (instance.backpackInventory == null)
				{
					instance.backpackInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.backpackInventory, isDelta);
				}
				break;
			case 64:
				instance.reclaimId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static ReclaimInfo DeserializeLengthDelimited(BufferStream stream, ReclaimInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.victimID = ProtocolParser.ReadUInt64(stream);
				break;
			case 34:
				if (instance.mainInventory == null)
				{
					instance.mainInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.mainInventory, isDelta);
				}
				break;
			case 42:
				if (instance.wearInventory == null)
				{
					instance.wearInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.wearInventory, isDelta);
				}
				break;
			case 50:
				if (instance.beltInventory == null)
				{
					instance.beltInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.beltInventory, isDelta);
				}
				break;
			case 58:
				if (instance.backpackInventory == null)
				{
					instance.backpackInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.backpackInventory, isDelta);
				}
				break;
			case 64:
				instance.reclaimId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ReclaimInfo DeserializeLength(BufferStream stream, int length, ReclaimInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.victimID = ProtocolParser.ReadUInt64(stream);
				break;
			case 34:
				if (instance.mainInventory == null)
				{
					instance.mainInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.mainInventory, isDelta);
				}
				break;
			case 42:
				if (instance.wearInventory == null)
				{
					instance.wearInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.wearInventory, isDelta);
				}
				break;
			case 50:
				if (instance.beltInventory == null)
				{
					instance.beltInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.beltInventory, isDelta);
				}
				break;
			case 58:
				if (instance.backpackInventory == null)
				{
					instance.backpackInventory = ItemContainer.DeserializeLengthDelimited(stream);
				}
				else
				{
					ItemContainer.DeserializeLengthDelimited(stream, instance.backpackInventory, isDelta);
				}
				break;
			case 64:
				instance.reclaimId = (int)ProtocolParser.ReadUInt64(stream);
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, ReclaimInfo instance, ReclaimInfo previous)
	{
		if (instance.victimID != previous.victimID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.victimID);
		}
		if (instance.mainInventory == null)
		{
			throw new ArgumentNullException("mainInventory", "Required by proto specification.");
		}
		stream.WriteByte(34);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ItemContainer.SerializeDelta(stream, instance.mainInventory, previous.mainInventory);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
		if (instance.wearInventory == null)
		{
			throw new ArgumentNullException("wearInventory", "Required by proto specification.");
		}
		stream.WriteByte(42);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		ItemContainer.SerializeDelta(stream, instance.wearInventory, previous.wearInventory);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
		if (instance.beltInventory == null)
		{
			throw new ArgumentNullException("beltInventory", "Required by proto specification.");
		}
		stream.WriteByte(50);
		BufferStream.RangeHandle range3 = stream.GetRange(5);
		int position3 = stream.Position;
		ItemContainer.SerializeDelta(stream, instance.beltInventory, previous.beltInventory);
		int val3 = stream.Position - position3;
		Span<byte> span3 = range3.GetSpan();
		int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
		if (num3 < 5)
		{
			span3[num3 - 1] |= 128;
			while (num3 < 4)
			{
				span3[num3++] = 128;
			}
			span3[4] = 0;
		}
		if (instance.backpackInventory == null)
		{
			throw new ArgumentNullException("backpackInventory", "Required by proto specification.");
		}
		stream.WriteByte(58);
		BufferStream.RangeHandle range4 = stream.GetRange(5);
		int position4 = stream.Position;
		ItemContainer.SerializeDelta(stream, instance.backpackInventory, previous.backpackInventory);
		int val4 = stream.Position - position4;
		Span<byte> span4 = range4.GetSpan();
		int num4 = ProtocolParser.WriteUInt32((uint)val4, span4, 0);
		if (num4 < 5)
		{
			span4[num4 - 1] |= 128;
			while (num4 < 4)
			{
				span4[num4++] = 128;
			}
			span4[4] = 0;
		}
		if (instance.reclaimId != previous.reclaimId)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.reclaimId);
		}
	}

	public static void Serialize(BufferStream stream, ReclaimInfo instance)
	{
		if (instance.victimID != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.victimID);
		}
		if (instance.mainInventory == null)
		{
			throw new ArgumentNullException("mainInventory", "Required by proto specification.");
		}
		stream.WriteByte(34);
		BufferStream.RangeHandle range = stream.GetRange(5);
		int position = stream.Position;
		ItemContainer.Serialize(stream, instance.mainInventory);
		int val = stream.Position - position;
		Span<byte> span = range.GetSpan();
		int num = ProtocolParser.WriteUInt32((uint)val, span, 0);
		if (num < 5)
		{
			span[num - 1] |= 128;
			while (num < 4)
			{
				span[num++] = 128;
			}
			span[4] = 0;
		}
		if (instance.wearInventory == null)
		{
			throw new ArgumentNullException("wearInventory", "Required by proto specification.");
		}
		stream.WriteByte(42);
		BufferStream.RangeHandle range2 = stream.GetRange(5);
		int position2 = stream.Position;
		ItemContainer.Serialize(stream, instance.wearInventory);
		int val2 = stream.Position - position2;
		Span<byte> span2 = range2.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)val2, span2, 0);
		if (num2 < 5)
		{
			span2[num2 - 1] |= 128;
			while (num2 < 4)
			{
				span2[num2++] = 128;
			}
			span2[4] = 0;
		}
		if (instance.beltInventory == null)
		{
			throw new ArgumentNullException("beltInventory", "Required by proto specification.");
		}
		stream.WriteByte(50);
		BufferStream.RangeHandle range3 = stream.GetRange(5);
		int position3 = stream.Position;
		ItemContainer.Serialize(stream, instance.beltInventory);
		int val3 = stream.Position - position3;
		Span<byte> span3 = range3.GetSpan();
		int num3 = ProtocolParser.WriteUInt32((uint)val3, span3, 0);
		if (num3 < 5)
		{
			span3[num3 - 1] |= 128;
			while (num3 < 4)
			{
				span3[num3++] = 128;
			}
			span3[4] = 0;
		}
		if (instance.backpackInventory == null)
		{
			throw new ArgumentNullException("backpackInventory", "Required by proto specification.");
		}
		stream.WriteByte(58);
		BufferStream.RangeHandle range4 = stream.GetRange(5);
		int position4 = stream.Position;
		ItemContainer.Serialize(stream, instance.backpackInventory);
		int val4 = stream.Position - position4;
		Span<byte> span4 = range4.GetSpan();
		int num4 = ProtocolParser.WriteUInt32((uint)val4, span4, 0);
		if (num4 < 5)
		{
			span4[num4 - 1] |= 128;
			while (num4 < 4)
			{
				span4[num4++] = 128;
			}
			span4[4] = 0;
		}
		if (instance.reclaimId != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.reclaimId);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		mainInventory?.InspectUids(action);
		wearInventory?.InspectUids(action);
		beltInventory?.InspectUids(action);
		backpackInventory?.InspectUids(action);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class CardPlayer : IDisposable, IPooled, IProto<CardPlayer>, IProto
{
	[NonSerialized]
	public ulong userid;

	[NonSerialized]
	public List<int> cards;

	[NonSerialized]
	public int scrap;

	[NonSerialized]
	public int state;

	[NonSerialized]
	public int availableInputs;

	[NonSerialized]
	public int betThisRound;

	[NonSerialized]
	public int betThisTurn;

	[NonSerialized]
	public bool leftRoundEarly;

	[NonSerialized]
	public bool sendCardDetails;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CardPlayer instance)
	{
		if (instance.ShouldPool)
		{
			instance.userid = 0uL;
			if (instance.cards != null)
			{
				List<int> list = instance.cards;
				Pool.FreeUnmanaged<int>(ref list);
				instance.cards = list;
			}
			instance.scrap = 0;
			instance.state = 0;
			instance.availableInputs = 0;
			instance.betThisRound = 0;
			instance.betThisTurn = 0;
			instance.leftRoundEarly = false;
			instance.sendCardDetails = false;
			Pool.Free<CardPlayer>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CardPlayer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CardPlayer instance)
	{
		instance.userid = userid;
		if (cards != null)
		{
			instance.cards = Pool.Get<List<int>>();
			for (int i = 0; i < cards.Count; i++)
			{
				int item = cards[i];
				instance.cards.Add(item);
			}
		}
		else
		{
			instance.cards = null;
		}
		instance.scrap = scrap;
		instance.state = state;
		instance.availableInputs = availableInputs;
		instance.betThisRound = betThisRound;
		instance.betThisTurn = betThisTurn;
		instance.leftRoundEarly = leftRoundEarly;
		instance.sendCardDetails = sendCardDetails;
	}

	public CardPlayer Copy()
	{
		CardPlayer cardPlayer = Pool.Get<CardPlayer>();
		CopyTo(cardPlayer);
		return cardPlayer;
	}

	public static CardPlayer Deserialize(BufferStream stream)
	{
		CardPlayer cardPlayer = Pool.Get<CardPlayer>();
		Deserialize(stream, cardPlayer, isDelta: false);
		return cardPlayer;
	}

	public static CardPlayer DeserializeLengthDelimited(BufferStream stream)
	{
		CardPlayer cardPlayer = Pool.Get<CardPlayer>();
		DeserializeLengthDelimited(stream, cardPlayer, isDelta: false);
		return cardPlayer;
	}

	public static CardPlayer DeserializeLength(BufferStream stream, int length)
	{
		CardPlayer cardPlayer = Pool.Get<CardPlayer>();
		DeserializeLength(stream, length, cardPlayer, isDelta: false);
		return cardPlayer;
	}

	public static CardPlayer Deserialize(byte[] buffer)
	{
		CardPlayer cardPlayer = Pool.Get<CardPlayer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cardPlayer, isDelta: false);
		return cardPlayer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CardPlayer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CardPlayer Deserialize(BufferStream stream, CardPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.cards == null)
		{
			instance.cards = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.scrap = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.availableInputs = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.betThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.betThisTurn = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.leftRoundEarly = ProtocolParser.ReadBool(stream);
				continue;
			case 72:
				instance.sendCardDetails = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CardPlayer DeserializeLengthDelimited(BufferStream stream, CardPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.cards == null)
		{
			instance.cards = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.scrap = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.availableInputs = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.betThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.betThisTurn = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.leftRoundEarly = ProtocolParser.ReadBool(stream);
				continue;
			case 72:
				instance.sendCardDetails = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CardPlayer DeserializeLength(BufferStream stream, int length, CardPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.cards == null)
		{
			instance.cards = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.userid = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.scrap = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.state = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.availableInputs = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.betThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.betThisTurn = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.leftRoundEarly = ProtocolParser.ReadBool(stream);
				continue;
			case 72:
				instance.sendCardDetails = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CardPlayer instance, CardPlayer previous)
	{
		if (instance.userid != previous.userid)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
		if (instance.cards != null)
		{
			for (int i = 0; i < instance.cards.Count; i++)
			{
				int num = instance.cards[i];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.scrap != previous.scrap)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scrap);
		}
		if (instance.state != previous.state)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.availableInputs != previous.availableInputs)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.availableInputs);
		}
		if (instance.betThisRound != previous.betThisRound)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.betThisRound);
		}
		if (instance.betThisTurn != previous.betThisTurn)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.betThisTurn);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteBool(stream, instance.leftRoundEarly);
		stream.WriteByte(72);
		ProtocolParser.WriteBool(stream, instance.sendCardDetails);
	}

	public static void Serialize(BufferStream stream, CardPlayer instance)
	{
		if (instance.userid != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.userid);
		}
		if (instance.cards != null)
		{
			for (int i = 0; i < instance.cards.Count; i++)
			{
				int num = instance.cards[i];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.scrap != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.scrap);
		}
		if (instance.state != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.state);
		}
		if (instance.availableInputs != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.availableInputs);
		}
		if (instance.betThisRound != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.betThisRound);
		}
		if (instance.betThisTurn != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.betThisTurn);
		}
		if (instance.leftRoundEarly)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.leftRoundEarly);
		}
		if (instance.sendCardDetails)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.sendCardDetails);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class TexasHoldEm : IDisposable, IPooled, IProto<TexasHoldEm>, IProto
{
	[NonSerialized]
	public int dealerIndex;

	[NonSerialized]
	public List<int> communityCards;

	[NonSerialized]
	public int biggestRaiseThisTurn;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TexasHoldEm instance)
	{
		if (instance.ShouldPool)
		{
			instance.dealerIndex = 0;
			if (instance.communityCards != null)
			{
				List<int> list = instance.communityCards;
				Pool.FreeUnmanaged<int>(ref list);
				instance.communityCards = list;
			}
			instance.biggestRaiseThisTurn = 0;
			Pool.Free<TexasHoldEm>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TexasHoldEm with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TexasHoldEm instance)
	{
		instance.dealerIndex = dealerIndex;
		if (communityCards != null)
		{
			instance.communityCards = Pool.Get<List<int>>();
			for (int i = 0; i < communityCards.Count; i++)
			{
				int item = communityCards[i];
				instance.communityCards.Add(item);
			}
		}
		else
		{
			instance.communityCards = null;
		}
		instance.biggestRaiseThisTurn = biggestRaiseThisTurn;
	}

	public TexasHoldEm Copy()
	{
		TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
		CopyTo(texasHoldEm);
		return texasHoldEm;
	}

	public static TexasHoldEm Deserialize(BufferStream stream)
	{
		TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
		Deserialize(stream, texasHoldEm, isDelta: false);
		return texasHoldEm;
	}

	public static TexasHoldEm DeserializeLengthDelimited(BufferStream stream)
	{
		TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
		DeserializeLengthDelimited(stream, texasHoldEm, isDelta: false);
		return texasHoldEm;
	}

	public static TexasHoldEm DeserializeLength(BufferStream stream, int length)
	{
		TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
		DeserializeLength(stream, length, texasHoldEm, isDelta: false);
		return texasHoldEm;
	}

	public static TexasHoldEm Deserialize(byte[] buffer)
	{
		TexasHoldEm texasHoldEm = Pool.Get<TexasHoldEm>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, texasHoldEm, isDelta: false);
		return texasHoldEm;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, TexasHoldEm previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TexasHoldEm Deserialize(BufferStream stream, TexasHoldEm instance, bool isDelta)
	{
		if (!isDelta && instance.communityCards == null)
		{
			instance.communityCards = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.dealerIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.communityCards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.biggestRaiseThisTurn = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TexasHoldEm DeserializeLengthDelimited(BufferStream stream, TexasHoldEm instance, bool isDelta)
	{
		if (!isDelta && instance.communityCards == null)
		{
			instance.communityCards = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.dealerIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.communityCards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.biggestRaiseThisTurn = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TexasHoldEm DeserializeLength(BufferStream stream, int length, TexasHoldEm instance, bool isDelta)
	{
		if (!isDelta && instance.communityCards == null)
		{
			instance.communityCards = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.dealerIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.communityCards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 24:
				instance.biggestRaiseThisTurn = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, TexasHoldEm instance, TexasHoldEm previous)
	{
		if (instance.dealerIndex != previous.dealerIndex)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dealerIndex);
		}
		if (instance.communityCards != null)
		{
			for (int i = 0; i < instance.communityCards.Count; i++)
			{
				int num = instance.communityCards[i];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.biggestRaiseThisTurn != previous.biggestRaiseThisTurn)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.biggestRaiseThisTurn);
		}
	}

	public static void Serialize(BufferStream stream, TexasHoldEm instance)
	{
		if (instance.dealerIndex != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dealerIndex);
		}
		if (instance.communityCards != null)
		{
			for (int i = 0; i < instance.communityCards.Count; i++)
			{
				int num = instance.communityCards[i];
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.biggestRaiseThisTurn != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.biggestRaiseThisTurn);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class RoundResults : IDisposable, IPooled, IProto<RoundResults>, IProto
{
	public class Result : IDisposable, IPooled, IProto<Result>, IProto
	{
		[NonSerialized]
		public ulong ID;

		[NonSerialized]
		public int winnings;

		[NonSerialized]
		public int resultCode;

		public bool ShouldPool = true;

		private bool _disposed;

		public static void ResetToPool(Result instance)
		{
			if (instance.ShouldPool)
			{
				instance.ID = 0uL;
				instance.winnings = 0;
				instance.resultCode = 0;
				Pool.Free<Result>(ref instance);
			}
		}

		public void ResetToPool()
		{
			ResetToPool(this);
		}

		public virtual void Dispose()
		{
			if (!ShouldPool)
			{
				throw new Exception("Trying to dispose Result with ShouldPool set to false!");
			}
			if (!_disposed)
			{
				ResetToPool();
				_disposed = true;
			}
		}

		public virtual void EnterPool()
		{
			_disposed = true;
		}

		public virtual void LeavePool()
		{
			_disposed = false;
		}

		public void CopyTo(Result instance)
		{
			instance.ID = ID;
			instance.winnings = winnings;
			instance.resultCode = resultCode;
		}

		public Result Copy()
		{
			Result result = Pool.Get<Result>();
			CopyTo(result);
			return result;
		}

		public static Result Deserialize(BufferStream stream)
		{
			Result result = Pool.Get<Result>();
			Deserialize(stream, result, isDelta: false);
			return result;
		}

		public static Result DeserializeLengthDelimited(BufferStream stream)
		{
			Result result = Pool.Get<Result>();
			DeserializeLengthDelimited(stream, result, isDelta: false);
			return result;
		}

		public static Result DeserializeLength(BufferStream stream, int length)
		{
			Result result = Pool.Get<Result>();
			DeserializeLength(stream, length, result, isDelta: false);
			return result;
		}

		public static Result Deserialize(byte[] buffer)
		{
			Result result = Pool.Get<Result>();
			using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
			Deserialize(stream, result, isDelta: false);
			return result;
		}

		public void FromProto(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void WriteToStream(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public virtual void WriteToStreamDelta(BufferStream stream, Result previous)
		{
			if (previous == null)
			{
				Serialize(stream, this);
			}
			else
			{
				SerializeDelta(stream, this, previous);
			}
		}

		public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
		{
			Deserialize(stream, this, isDelta);
		}

		public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
		{
			DeserializeLength(stream, size, this, isDelta);
		}

		public static Result Deserialize(BufferStream stream, Result instance, bool isDelta)
		{
			while (true)
			{
				int num = stream.ReadByte();
				switch (num)
				{
				case 8:
					instance.ID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case -1:
					return instance;
				}
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
		}

		public static Result DeserializeLengthDelimited(BufferStream stream, Result instance, bool isDelta)
		{
			long num = ProtocolParser.ReadUInt32(stream);
			num += stream.Position;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.ID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static Result DeserializeLength(BufferStream stream, int length, Result instance, bool isDelta)
		{
			long num = stream.Position + length;
			while (stream.Position < num)
			{
				int num2 = stream.ReadByte();
				switch (num2)
				{
				case -1:
					throw new EndOfStreamException();
				case 8:
					instance.ID = ProtocolParser.ReadUInt64(stream);
					continue;
				case 16:
					instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				case 24:
					instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
					continue;
				}
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
			}
			if (stream.Position != num)
			{
				throw new ProtocolBufferException("Read past max limit");
			}
			return instance;
		}

		public static void SerializeDelta(BufferStream stream, Result instance, Result previous)
		{
			if (instance.ID != previous.ID)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.ID);
			}
			if (instance.winnings != previous.winnings)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.winnings);
			}
			if (instance.resultCode != previous.resultCode)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.resultCode);
			}
		}

		public static void Serialize(BufferStream stream, Result instance)
		{
			if (instance.ID != 0L)
			{
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, instance.ID);
			}
			if (instance.winnings != 0)
			{
				stream.WriteByte(16);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.winnings);
			}
			if (instance.resultCode != 0)
			{
				stream.WriteByte(24);
				ProtocolParser.WriteUInt64(stream, (ulong)instance.resultCode);
			}
		}

		public void ToProto(BufferStream stream)
		{
			Serialize(stream, this);
		}

		public void InspectUids(UidInspector<ulong> action)
		{
		}
	}

	[NonSerialized]
	public List<Result> results;

	[NonSerialized]
	public int winningScore;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(RoundResults instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.results != null)
		{
			for (int i = 0; i < instance.results.Count; i++)
			{
				if (instance.results[i] != null)
				{
					instance.results[i].ResetToPool();
					instance.results[i] = null;
				}
			}
			List<Result> list = instance.results;
			Pool.Free<Result>(ref list, false);
			instance.results = list;
		}
		instance.winningScore = 0;
		Pool.Free<RoundResults>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose RoundResults with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(RoundResults instance)
	{
		if (results != null)
		{
			instance.results = Pool.Get<List<Result>>();
			for (int i = 0; i < results.Count; i++)
			{
				Result item = results[i].Copy();
				instance.results.Add(item);
			}
		}
		else
		{
			instance.results = null;
		}
		instance.winningScore = winningScore;
	}

	public RoundResults Copy()
	{
		RoundResults roundResults = Pool.Get<RoundResults>();
		CopyTo(roundResults);
		return roundResults;
	}

	public static RoundResults Deserialize(BufferStream stream)
	{
		RoundResults roundResults = Pool.Get<RoundResults>();
		Deserialize(stream, roundResults, isDelta: false);
		return roundResults;
	}

	public static RoundResults DeserializeLengthDelimited(BufferStream stream)
	{
		RoundResults roundResults = Pool.Get<RoundResults>();
		DeserializeLengthDelimited(stream, roundResults, isDelta: false);
		return roundResults;
	}

	public static RoundResults DeserializeLength(BufferStream stream, int length)
	{
		RoundResults roundResults = Pool.Get<RoundResults>();
		DeserializeLength(stream, length, roundResults, isDelta: false);
		return roundResults;
	}

	public static RoundResults Deserialize(byte[] buffer)
	{
		RoundResults roundResults = Pool.Get<RoundResults>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, roundResults, isDelta: false);
		return roundResults;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, RoundResults previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static RoundResults Deserialize(BufferStream stream, RoundResults instance, bool isDelta)
	{
		if (!isDelta && instance.results == null)
		{
			instance.results = Pool.Get<List<Result>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.results.Add(Result.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.winningScore = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static RoundResults DeserializeLengthDelimited(BufferStream stream, RoundResults instance, bool isDelta)
	{
		if (!isDelta && instance.results == null)
		{
			instance.results = Pool.Get<List<Result>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.results.Add(Result.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.winningScore = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static RoundResults DeserializeLength(BufferStream stream, int length, RoundResults instance, bool isDelta)
	{
		if (!isDelta && instance.results == null)
		{
			instance.results = Pool.Get<List<Result>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.results.Add(Result.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.winningScore = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, RoundResults instance, RoundResults previous)
	{
		if (instance.results != null)
		{
			for (int i = 0; i < instance.results.Count; i++)
			{
				Result result = instance.results[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Result.SerializeDelta(stream, result, result);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field results (ProtoBuf.CardGame.RoundResults.Result)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.winningScore != previous.winningScore)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.winningScore);
		}
	}

	public static void Serialize(BufferStream stream, RoundResults instance)
	{
		if (instance.results != null)
		{
			for (int i = 0; i < instance.results.Count; i++)
			{
				Result instance2 = instance.results[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Result.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field results (ProtoBuf.CardGame.RoundResults.Result)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.winningScore != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.winningScore);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (results != null)
		{
			for (int i = 0; i < results.Count; i++)
			{
				results[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Blackjack : IDisposable, IPooled, IProto<Blackjack>, IProto
{
	[NonSerialized]
	public List<int> dealerCards;

	[NonSerialized]
	public List<BlackjackCardPlayer> players;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Blackjack instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.dealerCards != null)
		{
			List<int> list = instance.dealerCards;
			Pool.FreeUnmanaged<int>(ref list);
			instance.dealerCards = list;
		}
		if (instance.players != null)
		{
			for (int i = 0; i < instance.players.Count; i++)
			{
				if (instance.players[i] != null)
				{
					instance.players[i].ResetToPool();
					instance.players[i] = null;
				}
			}
			List<BlackjackCardPlayer> list2 = instance.players;
			Pool.Free<BlackjackCardPlayer>(ref list2, false);
			instance.players = list2;
		}
		Pool.Free<Blackjack>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Blackjack with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Blackjack instance)
	{
		if (dealerCards != null)
		{
			instance.dealerCards = Pool.Get<List<int>>();
			for (int i = 0; i < dealerCards.Count; i++)
			{
				int item = dealerCards[i];
				instance.dealerCards.Add(item);
			}
		}
		else
		{
			instance.dealerCards = null;
		}
		if (players != null)
		{
			instance.players = Pool.Get<List<BlackjackCardPlayer>>();
			for (int j = 0; j < players.Count; j++)
			{
				BlackjackCardPlayer item2 = players[j].Copy();
				instance.players.Add(item2);
			}
		}
		else
		{
			instance.players = null;
		}
	}

	public Blackjack Copy()
	{
		Blackjack blackjack = Pool.Get<Blackjack>();
		CopyTo(blackjack);
		return blackjack;
	}

	public static Blackjack Deserialize(BufferStream stream)
	{
		Blackjack blackjack = Pool.Get<Blackjack>();
		Deserialize(stream, blackjack, isDelta: false);
		return blackjack;
	}

	public static Blackjack DeserializeLengthDelimited(BufferStream stream)
	{
		Blackjack blackjack = Pool.Get<Blackjack>();
		DeserializeLengthDelimited(stream, blackjack, isDelta: false);
		return blackjack;
	}

	public static Blackjack DeserializeLength(BufferStream stream, int length)
	{
		Blackjack blackjack = Pool.Get<Blackjack>();
		DeserializeLength(stream, length, blackjack, isDelta: false);
		return blackjack;
	}

	public static Blackjack Deserialize(byte[] buffer)
	{
		Blackjack blackjack = Pool.Get<Blackjack>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, blackjack, isDelta: false);
		return blackjack;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Blackjack previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Blackjack Deserialize(BufferStream stream, Blackjack instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.dealerCards == null)
			{
				instance.dealerCards = Pool.Get<List<int>>();
			}
			if (instance.players == null)
			{
				instance.players = Pool.Get<List<BlackjackCardPlayer>>();
			}
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.dealerCards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.players.Add(BlackjackCardPlayer.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Blackjack DeserializeLengthDelimited(BufferStream stream, Blackjack instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.dealerCards == null)
			{
				instance.dealerCards = Pool.Get<List<int>>();
			}
			if (instance.players == null)
			{
				instance.players = Pool.Get<List<BlackjackCardPlayer>>();
			}
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.dealerCards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.players.Add(BlackjackCardPlayer.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Blackjack DeserializeLength(BufferStream stream, int length, Blackjack instance, bool isDelta)
	{
		if (!isDelta)
		{
			if (instance.dealerCards == null)
			{
				instance.dealerCards = Pool.Get<List<int>>();
			}
			if (instance.players == null)
			{
				instance.players = Pool.Get<List<BlackjackCardPlayer>>();
			}
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.dealerCards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				instance.players.Add(BlackjackCardPlayer.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Blackjack instance, Blackjack previous)
	{
		if (instance.dealerCards != null)
		{
			for (int i = 0; i < instance.dealerCards.Count; i++)
			{
				int num = instance.dealerCards[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.players == null)
		{
			return;
		}
		for (int j = 0; j < instance.players.Count; j++)
		{
			BlackjackCardPlayer blackjackCardPlayer = instance.players[j];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(3);
			int position = stream.Position;
			BlackjackCardPlayer.SerializeDelta(stream, blackjackCardPlayer, blackjackCardPlayer);
			int num2 = stream.Position - position;
			if (num2 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field players (ProtoBuf.CardGame.BlackjackCardPlayer)");
			}
			Span<byte> span = range.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)num2, span, 0);
			if (num3 < 3)
			{
				span[num3 - 1] |= 128;
				while (num3 < 2)
				{
					span[num3++] = 128;
				}
				span[2] = 0;
			}
		}
	}

	public static void Serialize(BufferStream stream, Blackjack instance)
	{
		if (instance.dealerCards != null)
		{
			for (int i = 0; i < instance.dealerCards.Count; i++)
			{
				int num = instance.dealerCards[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.players == null)
		{
			return;
		}
		for (int j = 0; j < instance.players.Count; j++)
		{
			BlackjackCardPlayer instance2 = instance.players[j];
			stream.WriteByte(18);
			BufferStream.RangeHandle range = stream.GetRange(3);
			int position = stream.Position;
			BlackjackCardPlayer.Serialize(stream, instance2);
			int num2 = stream.Position - position;
			if (num2 > 2097151)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field players (ProtoBuf.CardGame.BlackjackCardPlayer)");
			}
			Span<byte> span = range.GetSpan();
			int num3 = ProtocolParser.WriteUInt32((uint)num2, span, 0);
			if (num3 < 3)
			{
				span[num3 - 1] |= 128;
				while (num3 < 2)
				{
					span[num3++] = 128;
				}
				span[2] = 0;
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (players != null)
		{
			for (int i = 0; i < players.Count; i++)
			{
				players[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class BlackjackCardPlayer : IDisposable, IPooled, IProto<BlackjackCardPlayer>, IProto
{
	[NonSerialized]
	public List<int> splitCards;

	[NonSerialized]
	public int splitBetThisRound;

	[NonSerialized]
	public int insuranceBetThisRound;

	[NonSerialized]
	public bool playingSplitCards;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BlackjackCardPlayer instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.splitCards != null)
			{
				List<int> list = instance.splitCards;
				Pool.FreeUnmanaged<int>(ref list);
				instance.splitCards = list;
			}
			instance.splitBetThisRound = 0;
			instance.insuranceBetThisRound = 0;
			instance.playingSplitCards = false;
			Pool.Free<BlackjackCardPlayer>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BlackjackCardPlayer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BlackjackCardPlayer instance)
	{
		if (splitCards != null)
		{
			instance.splitCards = Pool.Get<List<int>>();
			for (int i = 0; i < splitCards.Count; i++)
			{
				int item = splitCards[i];
				instance.splitCards.Add(item);
			}
		}
		else
		{
			instance.splitCards = null;
		}
		instance.splitBetThisRound = splitBetThisRound;
		instance.insuranceBetThisRound = insuranceBetThisRound;
		instance.playingSplitCards = playingSplitCards;
	}

	public BlackjackCardPlayer Copy()
	{
		BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
		CopyTo(blackjackCardPlayer);
		return blackjackCardPlayer;
	}

	public static BlackjackCardPlayer Deserialize(BufferStream stream)
	{
		BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
		Deserialize(stream, blackjackCardPlayer, isDelta: false);
		return blackjackCardPlayer;
	}

	public static BlackjackCardPlayer DeserializeLengthDelimited(BufferStream stream)
	{
		BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
		DeserializeLengthDelimited(stream, blackjackCardPlayer, isDelta: false);
		return blackjackCardPlayer;
	}

	public static BlackjackCardPlayer DeserializeLength(BufferStream stream, int length)
	{
		BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
		DeserializeLength(stream, length, blackjackCardPlayer, isDelta: false);
		return blackjackCardPlayer;
	}

	public static BlackjackCardPlayer Deserialize(byte[] buffer)
	{
		BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, blackjackCardPlayer, isDelta: false);
		return blackjackCardPlayer;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, BlackjackCardPlayer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BlackjackCardPlayer Deserialize(BufferStream stream, BlackjackCardPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.splitCards == null)
		{
			instance.splitCards = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.splitCards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.splitBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.insuranceBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.playingSplitCards = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BlackjackCardPlayer DeserializeLengthDelimited(BufferStream stream, BlackjackCardPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.splitCards == null)
		{
			instance.splitCards = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.splitCards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.splitBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.insuranceBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.playingSplitCards = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BlackjackCardPlayer DeserializeLength(BufferStream stream, int length, BlackjackCardPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.splitCards == null)
		{
			instance.splitCards = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.splitCards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.splitBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.insuranceBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.playingSplitCards = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, BlackjackCardPlayer instance, BlackjackCardPlayer previous)
	{
		if (instance.splitCards != null)
		{
			for (int i = 0; i < instance.splitCards.Count; i++)
			{
				int num = instance.splitCards[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.splitBetThisRound != previous.splitBetThisRound)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.splitBetThisRound);
		}
		if (instance.insuranceBetThisRound != previous.insuranceBetThisRound)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.insuranceBetThisRound);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.playingSplitCards);
	}

	public static void Serialize(BufferStream stream, BlackjackCardPlayer instance)
	{
		if (instance.splitCards != null)
		{
			for (int i = 0; i < instance.splitCards.Count; i++)
			{
				int num = instance.splitCards[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.splitBetThisRound != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.splitBetThisRound);
		}
		if (instance.insuranceBetThisRound != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.insuranceBetThisRound);
		}
		if (instance.playingSplitCards)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.playingSplitCards);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class CardList : IDisposable, IPooled, IProto<CardList>, IProto
{
	[NonSerialized]
	public List<int> cards;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CardList instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.cards != null)
			{
				List<int> list = instance.cards;
				Pool.FreeUnmanaged<int>(ref list);
				instance.cards = list;
			}
			Pool.Free<CardList>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CardList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CardList instance)
	{
		if (cards != null)
		{
			instance.cards = Pool.Get<List<int>>();
			for (int i = 0; i < cards.Count; i++)
			{
				int item = cards[i];
				instance.cards.Add(item);
			}
		}
		else
		{
			instance.cards = null;
		}
	}

	public CardList Copy()
	{
		CardList cardList = Pool.Get<CardList>();
		CopyTo(cardList);
		return cardList;
	}

	public static CardList Deserialize(BufferStream stream)
	{
		CardList cardList = Pool.Get<CardList>();
		Deserialize(stream, cardList, isDelta: false);
		return cardList;
	}

	public static CardList DeserializeLengthDelimited(BufferStream stream)
	{
		CardList cardList = Pool.Get<CardList>();
		DeserializeLengthDelimited(stream, cardList, isDelta: false);
		return cardList;
	}

	public static CardList DeserializeLength(BufferStream stream, int length)
	{
		CardList cardList = Pool.Get<CardList>();
		DeserializeLength(stream, length, cardList, isDelta: false);
		return cardList;
	}

	public static CardList Deserialize(byte[] buffer)
	{
		CardList cardList = Pool.Get<CardList>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cardList, isDelta: false);
		return cardList;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CardList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CardList Deserialize(BufferStream stream, CardList instance, bool isDelta)
	{
		if (!isDelta && instance.cards == null)
		{
			instance.cards = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CardList DeserializeLengthDelimited(BufferStream stream, CardList instance, bool isDelta)
	{
		if (!isDelta && instance.cards == null)
		{
			instance.cards = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CardList DeserializeLength(BufferStream stream, int length, CardList instance, bool isDelta)
	{
		if (!isDelta && instance.cards == null)
		{
			instance.cards = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CardList instance, CardList previous)
	{
		if (instance.cards != null)
		{
			for (int i = 0; i < instance.cards.Count; i++)
			{
				int num = instance.cards[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
	}

	public static void Serialize(BufferStream stream, CardList instance)
	{
		if (instance.cards != null)
		{
			for (int i = 0; i < instance.cards.Count; i++)
			{
				int num = instance.cards[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Design : IDisposable, IPooled, IProto<Design>, IProto
{
	[NonSerialized]
	public List<Star> stars;

	[NonSerialized]
	public ulong editedBy;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Design instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.stars != null)
		{
			for (int i = 0; i < instance.stars.Count; i++)
			{
				if (instance.stars[i] != null)
				{
					instance.stars[i].ResetToPool();
					instance.stars[i] = null;
				}
			}
			List<Star> list = instance.stars;
			Pool.Free<Star>(ref list, false);
			instance.stars = list;
		}
		instance.editedBy = 0uL;
		Pool.Free<Design>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Design with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Design instance)
	{
		if (stars != null)
		{
			instance.stars = Pool.Get<List<Star>>();
			for (int i = 0; i < stars.Count; i++)
			{
				Star item = stars[i].Copy();
				instance.stars.Add(item);
			}
		}
		else
		{
			instance.stars = null;
		}
		instance.editedBy = editedBy;
	}

	public Design Copy()
	{
		Design design = Pool.Get<Design>();
		CopyTo(design);
		return design;
	}

	public static Design Deserialize(BufferStream stream)
	{
		Design design = Pool.Get<Design>();
		Deserialize(stream, design, isDelta: false);
		return design;
	}

	public static Design DeserializeLengthDelimited(BufferStream stream)
	{
		Design design = Pool.Get<Design>();
		DeserializeLengthDelimited(stream, design, isDelta: false);
		return design;
	}

	public static Design DeserializeLength(BufferStream stream, int length)
	{
		Design design = Pool.Get<Design>();
		DeserializeLength(stream, length, design, isDelta: false);
		return design;
	}

	public static Design Deserialize(byte[] buffer)
	{
		Design design = Pool.Get<Design>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, design, isDelta: false);
		return design;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Design previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Design Deserialize(BufferStream stream, Design instance, bool isDelta)
	{
		if (!isDelta && instance.stars == null)
		{
			instance.stars = Pool.Get<List<Star>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.stars.Add(Star.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.editedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Design DeserializeLengthDelimited(BufferStream stream, Design instance, bool isDelta)
	{
		if (!isDelta && instance.stars == null)
		{
			instance.stars = Pool.Get<List<Star>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.stars.Add(Star.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.editedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Design DeserializeLength(BufferStream stream, int length, Design instance, bool isDelta)
	{
		if (!isDelta && instance.stars == null)
		{
			instance.stars = Pool.Get<List<Star>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.stars.Add(Star.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.editedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Design instance, Design previous)
	{
		if (instance.stars != null)
		{
			for (int i = 0; i < instance.stars.Count; i++)
			{
				Star star = instance.stars[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Star.SerializeDelta(stream, star, star);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field stars (ProtoBuf.PatternFirework.Star)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.editedBy != previous.editedBy)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.editedBy);
		}
	}

	public static void Serialize(BufferStream stream, Design instance)
	{
		if (instance.stars != null)
		{
			for (int i = 0; i < instance.stars.Count; i++)
			{
				Star instance2 = instance.stars[i];
				stream.WriteByte(10);
				BufferStream.RangeHandle range = stream.GetRange(1);
				int position = stream.Position;
				Star.Serialize(stream, instance2);
				int num = stream.Position - position;
				if (num > 127)
				{
					throw new InvalidOperationException("Not enough space was reserved for the length prefix of field stars (ProtoBuf.PatternFirework.Star)");
				}
				Span<byte> span = range.GetSpan();
				ProtocolParser.WriteUInt32((uint)num, span, 0);
			}
		}
		if (instance.editedBy != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.editedBy);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (stars != null)
		{
			for (int i = 0; i < stars.Count; i++)
			{
				stars[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Star : IDisposable, IPooled, IProto<Star>, IProto
{
	[NonSerialized]
	public Vector2 position;

	[NonSerialized]
	public Color color;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Star instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.position = default(Vector2);
			instance.color = default(Color);
			Pool.Free<Star>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Star with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Star instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.position = position;
		instance.color = color;
	}

	public Star Copy()
	{
		Star star = Pool.Get<Star>();
		CopyTo(star);
		return star;
	}

	public static Star Deserialize(BufferStream stream)
	{
		Star star = Pool.Get<Star>();
		Deserialize(stream, star, isDelta: false);
		return star;
	}

	public static Star DeserializeLengthDelimited(BufferStream stream)
	{
		Star star = Pool.Get<Star>();
		DeserializeLengthDelimited(stream, star, isDelta: false);
		return star;
	}

	public static Star DeserializeLength(BufferStream stream, int length)
	{
		Star star = Pool.Get<Star>();
		DeserializeLength(stream, length, star, isDelta: false);
		return star;
	}

	public static Star Deserialize(byte[] buffer)
	{
		Star star = Pool.Get<Star>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, star, isDelta: false);
		return star;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, Star previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Star Deserialize(BufferStream stream, Star instance, bool isDelta)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 18:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Star DeserializeLengthDelimited(BufferStream stream, Star instance, bool isDelta)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 18:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Star DeserializeLength(BufferStream stream, int length, Star instance, bool isDelta)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 18:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, Star instance, Star previous)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (instance.position != previous.position)
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector2Serialized.SerializeDelta(stream, instance.position, previous.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector2)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.color != previous.color)
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			ColorSerialized.SerializeDelta(stream, instance.color, previous.color);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color (UnityEngine.Color)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
	}

	public static void Serialize(BufferStream stream, Star instance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		if (instance.position != default(Vector2))
		{
			stream.WriteByte(10);
			BufferStream.RangeHandle range = stream.GetRange(1);
			int num = stream.Position;
			Vector2Serialized.Serialize(stream, instance.position);
			int num2 = stream.Position - num;
			if (num2 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field position (UnityEngine.Vector2)");
			}
			Span<byte> span = range.GetSpan();
			ProtocolParser.WriteUInt32((uint)num2, span, 0);
		}
		if (instance.color != default(Color))
		{
			stream.WriteByte(18);
			BufferStream.RangeHandle range2 = stream.GetRange(1);
			int num3 = stream.Position;
			ColorSerialized.Serialize(stream, instance.color);
			int num4 = stream.Position - num3;
			if (num4 > 127)
			{
				throw new InvalidOperationException("Not enough space was reserved for the length prefix of field color (UnityEngine.Color)");
			}
			Span<byte> span2 = range2.GetSpan();
			ProtocolParser.WriteUInt32((uint)num4, span2, 0);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class SavedDesign : IDisposable, IPooled, IProto<SavedDesign>, IProto
{
	[NonSerialized]
	public int version;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public Design design;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SavedDesign instance)
	{
		if (instance.ShouldPool)
		{
			instance.version = 0;
			instance.name = string.Empty;
			if (instance.design != null)
			{
				instance.design.ResetToPool();
				instance.design = null;
			}
			Pool.Free<SavedDesign>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SavedDesign with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SavedDesign instance)
	{
		instance.version = version;
		instance.name = name;
		if (design != null)
		{
			if (instance.design == null)
			{
				instance.design = design.Copy();
			}
			else
			{
				design.CopyTo(instance.design);
			}
		}
		else
		{
			instance.design = null;
		}
	}

	public SavedDesign Copy()
	{
		SavedDesign savedDesign = Pool.Get<SavedDesign>();
		CopyTo(savedDesign);
		return savedDesign;
	}

	public static SavedDesign Deserialize(BufferStream stream)
	{
		SavedDesign savedDesign = Pool.Get<SavedDesign>();
		Deserialize(stream, savedDesign, isDelta: false);
		return savedDesign;
	}

	public static SavedDesign DeserializeLengthDelimited(BufferStream stream)
	{
		SavedDesign savedDesign = Pool.Get<SavedDesign>();
		DeserializeLengthDelimited(stream, savedDesign, isDelta: false);
		return savedDesign;
	}

	public static SavedDesign DeserializeLength(BufferStream stream, int length)
	{
		SavedDesign savedDesign = Pool.Get<SavedDesign>();
		DeserializeLength(stream, length, savedDesign, isDelta: false);
		return savedDesign;
	}

	public static SavedDesign Deserialize(byte[] buffer)
	{
		SavedDesign savedDesign = Pool.Get<SavedDesign>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, savedDesign, isDelta: false);
		return savedDesign;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, SavedDesign previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SavedDesign Deserialize(BufferStream stream, SavedDesign instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.version = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				break;
			case 26:
				if (instance.design == null)
				{
					instance.design = Design.DeserializeLengthDelimited(stream);
				}
				else
				{
					Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			case -1:
				return instance;
			}
		}
	}

	public static SavedDesign DeserializeLengthDelimited(BufferStream stream, SavedDesign instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.version = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				break;
			case 26:
				if (instance.design == null)
				{
					instance.design = Design.DeserializeLengthDelimited(stream);
				}
				else
				{
					Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SavedDesign DeserializeLength(BufferStream stream, int length, SavedDesign instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.version = (int)ProtocolParser.ReadUInt64(stream);
				break;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				break;
			case 26:
				if (instance.design == null)
				{
					instance.design = Design.DeserializeLengthDelimited(stream);
				}
				else
				{
					Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
				}
				break;
			default:
			{
				Key key = ProtocolParser.ReadKey((byte)num2, stream);
				_ = key.Field;
				ProtocolParser.SkipKey(stream, key);
				break;
			}
			}
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, SavedDesign instance, SavedDesign previous)
	{
		if (instance.version != previous.version)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.version);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.design == null)
		{
			throw new ArgumentNullException("design", "Required by proto specification.");
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		Design.SerializeDelta(stream, instance.design, previous.design);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field design (ProtoBuf.PatternFirework.Design)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
	}

	public static void Serialize(BufferStream stream, SavedDesign instance)
	{
		if (instance.version != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.version);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.design == null)
		{
			throw new ArgumentNullException("design", "Required by proto specification.");
		}
		stream.WriteByte(26);
		BufferStream.RangeHandle range = stream.GetRange(3);
		int position = stream.Position;
		Design.Serialize(stream, instance.design);
		int num = stream.Position - position;
		if (num > 2097151)
		{
			throw new InvalidOperationException("Not enough space was reserved for the length prefix of field design (ProtoBuf.PatternFirework.Design)");
		}
		Span<byte> span = range.GetSpan();
		int num2 = ProtocolParser.WriteUInt32((uint)num, span, 0);
		if (num2 < 3)
		{
			span[num2 - 1] |= 128;
			while (num2 < 2)
			{
				span[num2++] = 128;
			}
			span[2] = 0;
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		design?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class CookingItem : IDisposable, IPooled, IProto<CookingItem>, IProto
{
	[NonSerialized]
	public int itemID;

	[NonSerialized]
	public int slotIndex;

	[NonSerialized]
	public int initialStackSize;

	[NonSerialized]
	public float cookingProgress;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CookingItem instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemID = 0;
			instance.slotIndex = 0;
			instance.initialStackSize = 0;
			instance.cookingProgress = 0f;
			Pool.Free<CookingItem>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CookingItem with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CookingItem instance)
	{
		instance.itemID = itemID;
		instance.slotIndex = slotIndex;
		instance.initialStackSize = initialStackSize;
		instance.cookingProgress = cookingProgress;
	}

	public CookingItem Copy()
	{
		CookingItem cookingItem = Pool.Get<CookingItem>();
		CopyTo(cookingItem);
		return cookingItem;
	}

	public static CookingItem Deserialize(BufferStream stream)
	{
		CookingItem cookingItem = Pool.Get<CookingItem>();
		Deserialize(stream, cookingItem, isDelta: false);
		return cookingItem;
	}

	public static CookingItem DeserializeLengthDelimited(BufferStream stream)
	{
		CookingItem cookingItem = Pool.Get<CookingItem>();
		DeserializeLengthDelimited(stream, cookingItem, isDelta: false);
		return cookingItem;
	}

	public static CookingItem DeserializeLength(BufferStream stream, int length)
	{
		CookingItem cookingItem = Pool.Get<CookingItem>();
		DeserializeLength(stream, length, cookingItem, isDelta: false);
		return cookingItem;
	}

	public static CookingItem Deserialize(byte[] buffer)
	{
		CookingItem cookingItem = Pool.Get<CookingItem>();
		using BufferStream stream = Pool.Get<BufferStream>().Initialize(buffer);
		Deserialize(stream, cookingItem, isDelta: false);
		return cookingItem;
	}

	public void FromProto(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(BufferStream stream, CookingItem previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(BufferStream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void ReadFromStream(BufferStream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CookingItem Deserialize(BufferStream stream, CookingItem instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.initialStackSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.cookingProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CookingItem DeserializeLengthDelimited(BufferStream stream, CookingItem instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.initialStackSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.cookingProgress = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CookingItem DeserializeLength(BufferStream stream, int length, CookingItem instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.initialStackSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.cookingProgress = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			_ = key.Field;
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(BufferStream stream, CookingItem instance, CookingItem previous)
	{
		if (instance.itemID != previous.itemID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.slotIndex != previous.slotIndex)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slotIndex);
		}
		if (instance.initialStackSize != previous.initialStackSize)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.initialStackSize);
		}
		if (instance.cookingProgress != previous.cookingProgress)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.cookingProgress);
		}
	}

	public static void Serialize(BufferStream stream, CookingItem instance)
	{
		if (instance.itemID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.slotIndex != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slotIndex);
		}
		if (instance.initialStackSize != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.initialStackSize);
		}
		if (instance.cookingProgress != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.cookingProgress);
		}
	}

	public void ToProto(BufferStream stream)
	{
		Serialize(stream, this);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


