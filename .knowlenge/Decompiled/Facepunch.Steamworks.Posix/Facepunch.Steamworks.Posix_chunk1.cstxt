using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal struct CallResult<T> : INotifyCompletion where T : struct, ICallbackData
{
	private SteamAPICall_t call;

	private ISteamUtils utils;

	private bool server;

	public bool IsCompleted
	{
		get
		{
			bool pbFailed = false;
			if (utils.IsAPICallCompleted(call, ref pbFailed) || pbFailed)
			{
				return true;
			}
			return false;
		}
	}

	public CallResult(SteamAPICall_t call, bool server)
	{
		this.call = call;
		this.server = server;
		utils = (server ? SteamSharedClass<SteamUtils>.InterfaceServer : SteamSharedClass<SteamUtils>.InterfaceClient) as ISteamUtils;
		if (utils == null)
		{
			utils = SteamSharedClass<SteamUtils>.Interface as ISteamUtils;
		}
	}

	public void OnCompleted(Action continuation)
	{
		if (IsCompleted)
		{
			continuation();
		}
		else
		{
			Dispatch.OnCallComplete<T>(call, continuation, server);
		}
	}

	public T? GetResult()
	{
		bool pbFailed = false;
		if (!utils.IsAPICallCompleted(call, ref pbFailed) || pbFailed)
		{
			return null;
		}
		T val = default(T);
		int dataSize = val.DataSize;
		IntPtr intPtr = Marshal.AllocHGlobal(dataSize);
		try
		{
			if (!utils.GetAPICallResult(call, intPtr, dataSize, (int)val.CallbackType, ref pbFailed) || pbFailed)
			{
				Dispatch.OnDebugCallback?.Invoke(val.CallbackType, "!GetAPICallResult or failed", server);
				return null;
			}
			Dispatch.OnDebugCallback?.Invoke(val.CallbackType, Dispatch.CallbackToString(val.CallbackType, intPtr, dataSize), server);
			return (T)Marshal.PtrToStructure(intPtr, typeof(T));
		}
		finally
		{
			Marshal.FreeHGlobal(intPtr);
		}
	}

	internal CallResult<T> GetAwaiter()
	{
		return this;
	}
}


using Steamworks;

internal interface ICallbackData
{
	CallbackType CallbackType { get; }

	int DataSize { get; }
}


using System;
using Steamworks;

public class AuthTicket : IDisposable
{
	public byte[] Data;

	public uint Handle;

	public void Cancel()
	{
		if (Handle != 0)
		{
			SteamUser.Internal.CancelAuthTicket(Handle);
		}
		Handle = 0u;
		Data = null;
	}

	public void Dispose()
	{
		Cancel();
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;

public static class Dispatch
{
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	internal struct CallbackMsg_t
	{
		public HSteamUser m_hSteamUser;

		public CallbackType Type;

		public IntPtr Data;

		public int DataSize;
	}

	private struct ResultCallback
	{
		public Action continuation;

		public bool server;
	}

	private struct Callback
	{
		public Action<IntPtr> action;

		public bool server;
	}

	public static Action<CallbackType, string, bool> OnDebugCallback;

	public static Action<Exception> OnException;

	private static bool runningFrame = false;

	private static List<Action<IntPtr>> actionsToCall = new List<Action<IntPtr>>();

	private static Dictionary<ulong, ResultCallback> ResultCallbacks = new Dictionary<ulong, ResultCallback>();

	private static Dictionary<CallbackType, List<Callback>> Callbacks = new Dictionary<CallbackType, List<Callback>>();

	internal static HSteamPipe ClientPipe { get; set; }

	internal static HSteamPipe ServerPipe { get; set; }

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void SteamAPI_ManualDispatch_Init();

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void SteamAPI_ManualDispatch_RunFrame(HSteamPipe pipe);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	[return: MarshalAs(UnmanagedType.I1)]
	internal static extern bool SteamAPI_ManualDispatch_GetNextCallback(HSteamPipe pipe, [In][Out] ref CallbackMsg_t msg);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	[return: MarshalAs(UnmanagedType.I1)]
	internal static extern bool SteamAPI_ManualDispatch_FreeLastCallback(HSteamPipe pipe);

	internal static void Init()
	{
		SteamAPI_ManualDispatch_Init();
	}

	internal static void Frame(HSteamPipe pipe)
	{
		if (runningFrame)
		{
			return;
		}
		try
		{
			runningFrame = true;
			SteamAPI_ManualDispatch_RunFrame(pipe);
			SteamNetworkingUtils.OutputDebugMessages();
			CallbackMsg_t msg = default(CallbackMsg_t);
			while (SteamAPI_ManualDispatch_GetNextCallback(pipe, ref msg))
			{
				try
				{
					ProcessCallback(msg, pipe == ServerPipe);
				}
				finally
				{
					SteamAPI_ManualDispatch_FreeLastCallback(pipe);
				}
			}
		}
		catch (Exception obj)
		{
			OnException?.Invoke(obj);
		}
		finally
		{
			runningFrame = false;
		}
	}

	private static void ProcessCallback(CallbackMsg_t msg, bool isServer)
	{
		OnDebugCallback?.Invoke(msg.Type, CallbackToString(msg.Type, msg.Data, msg.DataSize), isServer);
		if (msg.Type == CallbackType.SteamAPICallCompleted)
		{
			ProcessResult(msg);
		}
		else
		{
			if (!Callbacks.TryGetValue(msg.Type, out var value))
			{
				return;
			}
			actionsToCall.Clear();
			foreach (Callback item in value)
			{
				if (item.server == isServer)
				{
					actionsToCall.Add(item.action);
				}
			}
			foreach (Action<IntPtr> item2 in actionsToCall)
			{
				item2(msg.Data);
			}
			actionsToCall.Clear();
		}
	}

	internal static string CallbackToString(CallbackType type, IntPtr data, int expectedsize)
	{
		if (!CallbackTypeFactory.All.TryGetValue(type, out var value))
		{
			return $"[{type} not in sdk]";
		}
		object obj = data.ToType(value);
		if (obj == null)
		{
			return "[null]";
		}
		string text = "";
		FieldInfo[] fields = value.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
		if (fields.Length == 0)
		{
			return "[no fields]";
		}
		int num = fields.Max((FieldInfo x) => x.Name.Length) + 1;
		if (num < 10)
		{
			num = 10;
		}
		FieldInfo[] array = fields;
		foreach (FieldInfo fieldInfo in array)
		{
			int num2 = num - fieldInfo.Name.Length;
			if (num2 < 0)
			{
				num2 = 0;
			}
			text += $"{new string(' ', num2)}{fieldInfo.Name}: {fieldInfo.GetValue(obj)}\n";
		}
		return text.Trim(new char[1] { '\n' });
	}

	private static void ProcessResult(CallbackMsg_t msg)
	{
		SteamAPICallCompleted_t steamAPICallCompleted_t = msg.Data.ToType<SteamAPICallCompleted_t>();
		if (!ResultCallbacks.TryGetValue(steamAPICallCompleted_t.AsyncCall, out var value))
		{
			OnDebugCallback?.Invoke((CallbackType)steamAPICallCompleted_t.Callback, "[no callback waiting/required]", arg3: false);
			return;
		}
		ResultCallbacks.Remove(steamAPICallCompleted_t.AsyncCall);
		value.continuation();
	}

	internal static async void LoopClientAsync()
	{
		while (ClientPipe != 0)
		{
			Frame(ClientPipe);
			await Task.Delay(16);
		}
	}

	internal static async void LoopServerAsync()
	{
		while (ServerPipe != 0)
		{
			Frame(ServerPipe);
			await Task.Delay(32);
		}
	}

	internal static void OnCallComplete<T>(SteamAPICall_t call, Action continuation, bool server) where T : struct, ICallbackData
	{
		ResultCallbacks[call.Value] = new ResultCallback
		{
			continuation = continuation,
			server = server
		};
	}

	internal static void Install<T>(Action<T> p, bool server = false) where T : ICallbackData
	{
		CallbackType callbackType = default(T).CallbackType;
		if (!Callbacks.TryGetValue(callbackType, out var value))
		{
			value = new List<Callback>();
			Callbacks[callbackType] = value;
		}
		value.Add(new Callback
		{
			action = delegate(IntPtr x)
			{
				p(x.ToType<T>());
			},
			server = server
		});
	}

	internal static void ShutdownServer()
	{
		ServerPipe = 0;
		foreach (KeyValuePair<CallbackType, List<Callback>> callback in Callbacks)
		{
			Callbacks[callback.Key].RemoveAll((Callback x) => x.server);
		}
		ResultCallbacks = ResultCallbacks.Where((KeyValuePair<ulong, ResultCallback> x) => !x.Value.server).ToDictionary((KeyValuePair<ulong, ResultCallback> x) => x.Key, (KeyValuePair<ulong, ResultCallback> x) => x.Value);
	}

	internal static void ShutdownClient()
	{
		ClientPipe = 0;
		foreach (KeyValuePair<CallbackType, List<Callback>> callback in Callbacks)
		{
			Callbacks[callback.Key].RemoveAll((Callback x) => !x.server);
		}
		ResultCallbacks = ResultCallbacks.Where((KeyValuePair<ulong, ResultCallback> x) => x.Value.server).ToDictionary((KeyValuePair<ulong, ResultCallback> x) => x.Key, (KeyValuePair<ulong, ResultCallback> x) => x.Value);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal static class SteamAPI
{
	internal static class Native
	{
		[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
		public static extern SteamAPIInitResult SteamInternal_SteamAPI_Init(IntPtr pszInternalCheckInterfaceVersions, IntPtr pOutErrMsg);

		[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
		public static extern void SteamAPI_Shutdown();

		[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
		public static extern HSteamPipe SteamAPI_GetHSteamPipe();

		[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
		[return: MarshalAs(UnmanagedType.I1)]
		public static extern bool SteamAPI_RestartAppIfNecessary(uint unOwnAppID);
	}

	internal static SteamAPIInitResult Init(string pszInternalCheckInterfaceVersions, out string pOutErrMsg)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszInternalCheckInterfaceVersions);
		using Helpers.Memory memory = Helpers.Memory.Take();
		SteamAPIInitResult result = Native.SteamInternal_SteamAPI_Init(utf8StringToNative.Pointer, memory.Ptr);
		pOutErrMsg = Helpers.MemoryToString(memory.Ptr);
		return result;
	}

	internal static void Shutdown()
	{
		Native.SteamAPI_Shutdown();
	}

	internal static HSteamPipe GetHSteamPipe()
	{
		return Native.SteamAPI_GetHSteamPipe();
	}

	internal static bool RestartAppIfNecessary(uint unOwnAppID)
	{
		return Native.SteamAPI_RestartAppIfNecessary(unOwnAppID);
	}
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal static class SteamGameServer
{
	internal static class Native
	{
		[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
		public static extern void SteamGameServer_RunCallbacks();

		[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
		public static extern void SteamGameServer_Shutdown();

		[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
		public static extern HSteamPipe SteamGameServer_GetHSteamPipe();
	}

	internal static void RunCallbacks()
	{
		Native.SteamGameServer_RunCallbacks();
	}

	internal static void Shutdown()
	{
		Native.SteamGameServer_Shutdown();
	}

	internal static HSteamPipe GetHSteamPipe()
	{
		return Native.SteamGameServer_GetHSteamPipe();
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;

internal static class SteamInternal
{
	internal static class Native
	{
		[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
		public static extern SteamAPIInitResult SteamInternal_GameServer_Init_V2(uint unIP, ushort usGamePort, ushort usQueryPort, int eServerMode, IntPtr pchVersionString, IntPtr pszInternalCheckInterfaceVersions, IntPtr pOutErrMsg);
	}

	internal static SteamAPIInitResult GameServer_Init(uint unIP, ushort usGamePort, ushort usQueryPort, int eServerMode, string pchVersionString, string pszInternalCheckInterfaceVersions, out string pOutErrMsg)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersionString);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pszInternalCheckInterfaceVersions);
		using Helpers.Memory memory = Helpers.Memory.Take();
		SteamAPIInitResult result = Native.SteamInternal_GameServer_Init_V2(unIP, usGamePort, usQueryPort, eServerMode, utf8StringToNative.Pointer, utf8StringToNative2.Pointer, memory.Ptr);
		pOutErrMsg = Helpers.MemoryToString(memory.Ptr);
		return result;
	}
}


public enum CallbackType
{
	SteamServersConnected = 101,
	SteamServerConnectFailure = 102,
	SteamServersDisconnected = 103,
	ClientGameServerDeny = 113,
	GSPolicyResponse = 115,
	IPCFailure = 117,
	LicensesUpdated = 125,
	ValidateAuthTicketResponse = 143,
	MicroTxnAuthorizationResponse = 152,
	EncryptedAppTicketResponse = 154,
	GetAuthSessionTicketResponse = 163,
	GameWebCallback = 164,
	StoreAuthURLResponse = 165,
	MarketEligibilityResponse = 166,
	DurationControl = 167,
	GetTicketForWebApiResponse = 168,
	GSClientApprove = 201,
	GSClientDeny = 202,
	GSClientKick = 203,
	GSClientAchievementStatus = 206,
	GSGameplayStats = 207,
	GSClientGroupStatus = 208,
	GSReputation = 209,
	AssociateWithClanResult = 210,
	ComputeNewPlayerCompatibilityResult = 211,
	PersonaStateChange = 304,
	GameOverlayActivated = 331,
	GameServerChangeRequested = 332,
	GameLobbyJoinRequested = 333,
	AvatarImageLoaded = 334,
	ClanOfficerListResponse = 335,
	FriendRichPresenceUpdate = 336,
	GameRichPresenceJoinRequested = 337,
	GameConnectedClanChatMsg = 338,
	GameConnectedChatJoin = 339,
	GameConnectedChatLeave = 340,
	DownloadClanActivityCountsResult = 341,
	JoinClanChatRoomCompletionResult = 342,
	GameConnectedFriendChatMsg = 343,
	FriendsGetFollowerCount = 344,
	FriendsIsFollowing = 345,
	FriendsEnumerateFollowingList = 346,
	SetPersonaNameResponse = 347,
	UnreadChatMessagesChanged = 348,
	OverlayBrowserProtocolNavigation = 349,
	EquippedProfileItemsChanged = 350,
	EquippedProfileItems = 351,
	FavoritesListChanged = 502,
	LobbyInvite = 503,
	LobbyEnter = 504,
	LobbyDataUpdate = 505,
	LobbyChatUpdate = 506,
	LobbyChatMsg = 507,
	LobbyGameCreated = 509,
	LobbyMatchList = 510,
	LobbyKicked = 512,
	LobbyCreated = 513,
	PSNGameBootInviteResult = 515,
	FavoritesListAccountsUpdated = 516,
	IPCountry = 701,
	LowBatteryPower = 702,
	SteamAPICallCompleted = 703,
	SteamShutdown = 704,
	CheckFileSignature = 705,
	GamepadTextInputDismissed = 714,
	AppResumingFromSuspend = 736,
	FloatingGamepadTextInputDismissed = 738,
	FilterTextDictionaryChanged = 739,
	DlcInstalled = 1005,
	NewUrlLaunchParameters = 1014,
	AppProofOfPurchaseKeyResponse = 1021,
	FileDetailsResult = 1023,
	TimedTrialStatus = 1030,
	UserStatsReceived = 1101,
	UserStatsStored = 1102,
	UserAchievementStored = 1103,
	LeaderboardFindResult = 1104,
	LeaderboardScoresDownloaded = 1105,
	LeaderboardScoreUploaded = 1106,
	NumberOfCurrentPlayers = 1107,
	UserStatsUnloaded = 1108,
	GSStatsUnloaded = 1108,
	UserAchievementIconFetched = 1109,
	GlobalAchievementPercentagesReady = 1110,
	LeaderboardUGCSet = 1111,
	GlobalStatsReceived = 1112,
	P2PSessionRequest = 1202,
	P2PSessionConnectFail = 1203,
	SteamNetConnectionStatusChangedCallback = 1221,
	SteamNetAuthenticationStatus = 1222,
	SteamNetworkingFakeIPResult = 1223,
	SteamNetworkingMessagesSessionRequest = 1251,
	SteamNetworkingMessagesSessionFailed = 1252,
	SteamRelayNetworkStatus = 1281,
	RemoteStorageFileShareResult = 1307,
	RemoteStoragePublishFileResult = 1309,
	RemoteStorageDeletePublishedFileResult = 1311,
	RemoteStorageEnumerateUserPublishedFilesResult = 1312,
	RemoteStorageSubscribePublishedFileResult = 1313,
	RemoteStorageEnumerateUserSubscribedFilesResult = 1314,
	RemoteStorageUnsubscribePublishedFileResult = 1315,
	RemoteStorageUpdatePublishedFileResult = 1316,
	RemoteStorageDownloadUGCResult = 1317,
	RemoteStorageGetPublishedFileDetailsResult = 1318,
	RemoteStorageEnumerateWorkshopFilesResult = 1319,
	RemoteStorageGetPublishedItemVoteDetailsResult = 1320,
	RemoteStoragePublishedFileSubscribed = 1321,
	RemoteStoragePublishedFileUnsubscribed = 1322,
	RemoteStoragePublishedFileDeleted = 1323,
	RemoteStorageUpdateUserPublishedItemVoteResult = 1324,
	RemoteStorageUserVoteDetails = 1325,
	RemoteStorageEnumerateUserSharedWorkshopFilesResult = 1326,
	RemoteStorageSetUserPublishedFileActionResult = 1327,
	RemoteStorageEnumeratePublishedFilesByUserActionResult = 1328,
	RemoteStoragePublishFileProgress = 1329,
	RemoteStoragePublishedFileUpdated = 1330,
	RemoteStorageFileWriteAsyncComplete = 1331,
	RemoteStorageFileReadAsyncComplete = 1332,
	RemoteStorageLocalFileChange = 1333,
	GSStatsReceived = 1800,
	GSStatsStored = 1801,
	HTTPRequestCompleted = 2101,
	HTTPRequestHeadersReceived = 2102,
	HTTPRequestDataReceived = 2103,
	ScreenshotReady = 2301,
	ScreenshotRequested = 2302,
	SteamInputDeviceConnected = 2801,
	SteamInputDeviceDisconnected = 2802,
	SteamInputConfigurationLoaded = 2803,
	SteamInputGamepadSlotChange = 2804,
	SteamUGCQueryCompleted = 3401,
	SteamUGCRequestUGCDetailsResult = 3402,
	CreateItemResult = 3403,
	SubmitItemUpdateResult = 3404,
	ItemInstalled = 3405,
	DownloadItemResult = 3406,
	UserFavoriteItemsListChanged = 3407,
	SetUserItemVoteResult = 3408,
	GetUserItemVoteResult = 3409,
	StartPlaytimeTrackingResult = 3410,
	StopPlaytimeTrackingResult = 3411,
	AddUGCDependencyResult = 3412,
	RemoveUGCDependencyResult = 3413,
	AddAppDependencyResult = 3414,
	RemoveAppDependencyResult = 3415,
	GetAppDependenciesResult = 3416,
	DeleteItemResult = 3417,
	UserSubscribedItemsListChanged = 3418,
	WorkshopEULAStatus = 3420,
	PlaybackStatusHasChanged = 4001,
	VolumeHasChanged = 4002,
	MusicPlayerWantsVolume = 4011,
	MusicPlayerSelectsQueueEntry = 4012,
	MusicPlayerSelectsPlaylistEntry = 4013,
	MusicPlayerRemoteWillActivate = 4101,
	MusicPlayerRemoteWillDeactivate = 4102,
	MusicPlayerRemoteToFront = 4103,
	MusicPlayerWillQuit = 4104,
	MusicPlayerWantsPlay = 4105,
	MusicPlayerWantsPause = 4106,
	MusicPlayerWantsPlayPrevious = 4107,
	MusicPlayerWantsPlayNext = 4108,
	MusicPlayerWantsShuffled = 4109,
	MusicPlayerWantsLooped = 4110,
	MusicPlayerWantsPlayingRepeatStatus = 4114,
	HTML_BrowserReady = 4501,
	HTML_NeedsPaint = 4502,
	HTML_StartRequest = 4503,
	HTML_CloseBrowser = 4504,
	HTML_URLChanged = 4505,
	HTML_FinishedRequest = 4506,
	HTML_OpenLinkInNewTab = 4507,
	HTML_ChangedTitle = 4508,
	HTML_SearchResults = 4509,
	HTML_CanGoBackAndForward = 4510,
	HTML_HorizontalScroll = 4511,
	HTML_VerticalScroll = 4512,
	HTML_LinkAtPosition = 4513,
	HTML_JSAlert = 4514,
	HTML_JSConfirm = 4515,
	HTML_FileOpenDialog = 4516,
	HTML_NewWindow = 4521,
	HTML_SetCursor = 4522,
	HTML_StatusText = 4523,
	HTML_ShowToolTip = 4524,
	HTML_UpdateToolTip = 4525,
	HTML_HideToolTip = 4526,
	HTML_BrowserRestarted = 4527,
	BroadcastUploadStart = 4604,
	BroadcastUploadStop = 4605,
	GetVideoURLResult = 4611,
	GetOPFSettingsResult = 4624,
	SteamInventoryResultReady = 4700,
	SteamInventoryFullUpdate = 4701,
	SteamInventoryDefinitionUpdate = 4702,
	SteamInventoryEligiblePromoItemDefIDs = 4703,
	SteamInventoryStartPurchaseResult = 4704,
	SteamInventoryRequestPricesResult = 4705,
	SteamParentalSettingsChanged = 5001,
	SearchForGameProgressCallback = 5201,
	SearchForGameResultCallback = 5202,
	RequestPlayersForGameProgressCallback = 5211,
	RequestPlayersForGameResultCallback = 5212,
	RequestPlayersForGameFinalResultCallback = 5213,
	SubmitPlayerResultResultCallback = 5214,
	EndGameResultCallback = 5215,
	JoinPartyCallback = 5301,
	CreateBeaconCallback = 5302,
	ReservationNotificationCallback = 5303,
	ChangeNumOpenSlotsCallback = 5304,
	AvailableBeaconLocationsUpdated = 5305,
	ActiveBeaconsUpdated = 5306,
	SteamRemotePlaySessionConnected = 5701,
	SteamRemotePlaySessionDisconnected = 5702,
	SteamRemotePlayTogetherGuestInvite = 5703,
	SteamTimelineGamePhaseRecordingExists = 6001,
	SteamTimelineEventRecordingExists = 6002
}


using System;
using System.Collections.Generic;
using Steamworks;
using Steamworks.Data;

internal static class CallbackTypeFactory
{
	internal static Dictionary<CallbackType, Type> All = new Dictionary<CallbackType, Type>
	{
		{
			CallbackType.SteamServersConnected,
			typeof(SteamServersConnected_t)
		},
		{
			CallbackType.SteamServerConnectFailure,
			typeof(SteamServerConnectFailure_t)
		},
		{
			CallbackType.SteamServersDisconnected,
			typeof(SteamServersDisconnected_t)
		},
		{
			CallbackType.ClientGameServerDeny,
			typeof(ClientGameServerDeny_t)
		},
		{
			CallbackType.GSPolicyResponse,
			typeof(GSPolicyResponse_t)
		},
		{
			CallbackType.IPCFailure,
			typeof(IPCFailure_t)
		},
		{
			CallbackType.LicensesUpdated,
			typeof(LicensesUpdated_t)
		},
		{
			CallbackType.ValidateAuthTicketResponse,
			typeof(ValidateAuthTicketResponse_t)
		},
		{
			CallbackType.MicroTxnAuthorizationResponse,
			typeof(MicroTxnAuthorizationResponse_t)
		},
		{
			CallbackType.EncryptedAppTicketResponse,
			typeof(EncryptedAppTicketResponse_t)
		},
		{
			CallbackType.GetAuthSessionTicketResponse,
			typeof(GetAuthSessionTicketResponse_t)
		},
		{
			CallbackType.GameWebCallback,
			typeof(GameWebCallback_t)
		},
		{
			CallbackType.StoreAuthURLResponse,
			typeof(StoreAuthURLResponse_t)
		},
		{
			CallbackType.MarketEligibilityResponse,
			typeof(MarketEligibilityResponse_t)
		},
		{
			CallbackType.DurationControl,
			typeof(DurationControl_t)
		},
		{
			CallbackType.GetTicketForWebApiResponse,
			typeof(GetTicketForWebApiResponse_t)
		},
		{
			CallbackType.GSClientApprove,
			typeof(GSClientApprove_t)
		},
		{
			CallbackType.GSClientDeny,
			typeof(GSClientDeny_t)
		},
		{
			CallbackType.GSClientKick,
			typeof(GSClientKick_t)
		},
		{
			CallbackType.GSClientAchievementStatus,
			typeof(GSClientAchievementStatus_t)
		},
		{
			CallbackType.GSGameplayStats,
			typeof(GSGameplayStats_t)
		},
		{
			CallbackType.GSClientGroupStatus,
			typeof(GSClientGroupStatus_t)
		},
		{
			CallbackType.GSReputation,
			typeof(GSReputation_t)
		},
		{
			CallbackType.AssociateWithClanResult,
			typeof(AssociateWithClanResult_t)
		},
		{
			CallbackType.ComputeNewPlayerCompatibilityResult,
			typeof(ComputeNewPlayerCompatibilityResult_t)
		},
		{
			CallbackType.PersonaStateChange,
			typeof(PersonaStateChange_t)
		},
		{
			CallbackType.GameOverlayActivated,
			typeof(GameOverlayActivated_t)
		},
		{
			CallbackType.GameServerChangeRequested,
			typeof(GameServerChangeRequested_t)
		},
		{
			CallbackType.GameLobbyJoinRequested,
			typeof(GameLobbyJoinRequested_t)
		},
		{
			CallbackType.AvatarImageLoaded,
			typeof(AvatarImageLoaded_t)
		},
		{
			CallbackType.ClanOfficerListResponse,
			typeof(ClanOfficerListResponse_t)
		},
		{
			CallbackType.FriendRichPresenceUpdate,
			typeof(FriendRichPresenceUpdate_t)
		},
		{
			CallbackType.GameRichPresenceJoinRequested,
			typeof(GameRichPresenceJoinRequested_t)
		},
		{
			CallbackType.GameConnectedClanChatMsg,
			typeof(GameConnectedClanChatMsg_t)
		},
		{
			CallbackType.GameConnectedChatJoin,
			typeof(GameConnectedChatJoin_t)
		},
		{
			CallbackType.GameConnectedChatLeave,
			typeof(GameConnectedChatLeave_t)
		},
		{
			CallbackType.DownloadClanActivityCountsResult,
			typeof(DownloadClanActivityCountsResult_t)
		},
		{
			CallbackType.JoinClanChatRoomCompletionResult,
			typeof(JoinClanChatRoomCompletionResult_t)
		},
		{
			CallbackType.GameConnectedFriendChatMsg,
			typeof(GameConnectedFriendChatMsg_t)
		},
		{
			CallbackType.FriendsGetFollowerCount,
			typeof(FriendsGetFollowerCount_t)
		},
		{
			CallbackType.FriendsIsFollowing,
			typeof(FriendsIsFollowing_t)
		},
		{
			CallbackType.FriendsEnumerateFollowingList,
			typeof(FriendsEnumerateFollowingList_t)
		},
		{
			CallbackType.SetPersonaNameResponse,
			typeof(SetPersonaNameResponse_t)
		},
		{
			CallbackType.UnreadChatMessagesChanged,
			typeof(UnreadChatMessagesChanged_t)
		},
		{
			CallbackType.OverlayBrowserProtocolNavigation,
			typeof(OverlayBrowserProtocolNavigation_t)
		},
		{
			CallbackType.EquippedProfileItemsChanged,
			typeof(EquippedProfileItemsChanged_t)
		},
		{
			CallbackType.EquippedProfileItems,
			typeof(EquippedProfileItems_t)
		},
		{
			CallbackType.FavoritesListChanged,
			typeof(FavoritesListChanged_t)
		},
		{
			CallbackType.LobbyInvite,
			typeof(LobbyInvite_t)
		},
		{
			CallbackType.LobbyEnter,
			typeof(LobbyEnter_t)
		},
		{
			CallbackType.LobbyDataUpdate,
			typeof(LobbyDataUpdate_t)
		},
		{
			CallbackType.LobbyChatUpdate,
			typeof(LobbyChatUpdate_t)
		},
		{
			CallbackType.LobbyChatMsg,
			typeof(LobbyChatMsg_t)
		},
		{
			CallbackType.LobbyGameCreated,
			typeof(LobbyGameCreated_t)
		},
		{
			CallbackType.LobbyMatchList,
			typeof(LobbyMatchList_t)
		},
		{
			CallbackType.LobbyKicked,
			typeof(LobbyKicked_t)
		},
		{
			CallbackType.LobbyCreated,
			typeof(LobbyCreated_t)
		},
		{
			CallbackType.PSNGameBootInviteResult,
			typeof(PSNGameBootInviteResult_t)
		},
		{
			CallbackType.FavoritesListAccountsUpdated,
			typeof(FavoritesListAccountsUpdated_t)
		},
		{
			CallbackType.IPCountry,
			typeof(IPCountry_t)
		},
		{
			CallbackType.LowBatteryPower,
			typeof(LowBatteryPower_t)
		},
		{
			CallbackType.SteamAPICallCompleted,
			typeof(SteamAPICallCompleted_t)
		},
		{
			CallbackType.SteamShutdown,
			typeof(SteamShutdown_t)
		},
		{
			CallbackType.CheckFileSignature,
			typeof(CheckFileSignature_t)
		},
		{
			CallbackType.GamepadTextInputDismissed,
			typeof(GamepadTextInputDismissed_t)
		},
		{
			CallbackType.AppResumingFromSuspend,
			typeof(AppResumingFromSuspend_t)
		},
		{
			CallbackType.FloatingGamepadTextInputDismissed,
			typeof(FloatingGamepadTextInputDismissed_t)
		},
		{
			CallbackType.FilterTextDictionaryChanged,
			typeof(FilterTextDictionaryChanged_t)
		},
		{
			CallbackType.DlcInstalled,
			typeof(DlcInstalled_t)
		},
		{
			CallbackType.NewUrlLaunchParameters,
			typeof(NewUrlLaunchParameters_t)
		},
		{
			CallbackType.AppProofOfPurchaseKeyResponse,
			typeof(AppProofOfPurchaseKeyResponse_t)
		},
		{
			CallbackType.FileDetailsResult,
			typeof(FileDetailsResult_t)
		},
		{
			CallbackType.TimedTrialStatus,
			typeof(TimedTrialStatus_t)
		},
		{
			CallbackType.UserStatsReceived,
			typeof(UserStatsReceived_t)
		},
		{
			CallbackType.UserStatsStored,
			typeof(UserStatsStored_t)
		},
		{
			CallbackType.UserAchievementStored,
			typeof(UserAchievementStored_t)
		},
		{
			CallbackType.LeaderboardFindResult,
			typeof(LeaderboardFindResult_t)
		},
		{
			CallbackType.LeaderboardScoresDownloaded,
			typeof(LeaderboardScoresDownloaded_t)
		},
		{
			CallbackType.LeaderboardScoreUploaded,
			typeof(LeaderboardScoreUploaded_t)
		},
		{
			CallbackType.NumberOfCurrentPlayers,
			typeof(NumberOfCurrentPlayers_t)
		},
		{
			CallbackType.UserStatsUnloaded,
			typeof(UserStatsUnloaded_t)
		},
		{
			CallbackType.UserAchievementIconFetched,
			typeof(UserAchievementIconFetched_t)
		},
		{
			CallbackType.GlobalAchievementPercentagesReady,
			typeof(GlobalAchievementPercentagesReady_t)
		},
		{
			CallbackType.LeaderboardUGCSet,
			typeof(LeaderboardUGCSet_t)
		},
		{
			CallbackType.GlobalStatsReceived,
			typeof(GlobalStatsReceived_t)
		},
		{
			CallbackType.P2PSessionRequest,
			typeof(P2PSessionRequest_t)
		},
		{
			CallbackType.P2PSessionConnectFail,
			typeof(P2PSessionConnectFail_t)
		},
		{
			CallbackType.SteamNetConnectionStatusChangedCallback,
			typeof(SteamNetConnectionStatusChangedCallback_t)
		},
		{
			CallbackType.SteamNetAuthenticationStatus,
			typeof(SteamNetAuthenticationStatus_t)
		},
		{
			CallbackType.SteamNetworkingFakeIPResult,
			typeof(SteamNetworkingFakeIPResult_t)
		},
		{
			CallbackType.SteamNetworkingMessagesSessionRequest,
			typeof(SteamNetworkingMessagesSessionRequest_t)
		},
		{
			CallbackType.SteamNetworkingMessagesSessionFailed,
			typeof(SteamNetworkingMessagesSessionFailed_t)
		},
		{
			CallbackType.SteamRelayNetworkStatus,
			typeof(SteamRelayNetworkStatus_t)
		},
		{
			CallbackType.RemoteStorageFileShareResult,
			typeof(RemoteStorageFileShareResult_t)
		},
		{
			CallbackType.RemoteStoragePublishFileResult,
			typeof(RemoteStoragePublishFileResult_t)
		},
		{
			CallbackType.RemoteStorageDeletePublishedFileResult,
			typeof(RemoteStorageDeletePublishedFileResult_t)
		},
		{
			CallbackType.RemoteStorageEnumerateUserPublishedFilesResult,
			typeof(RemoteStorageEnumerateUserPublishedFilesResult_t)
		},
		{
			CallbackType.RemoteStorageSubscribePublishedFileResult,
			typeof(RemoteStorageSubscribePublishedFileResult_t)
		},
		{
			CallbackType.RemoteStorageEnumerateUserSubscribedFilesResult,
			typeof(RemoteStorageEnumerateUserSubscribedFilesResult_t)
		},
		{
			CallbackType.RemoteStorageUnsubscribePublishedFileResult,
			typeof(RemoteStorageUnsubscribePublishedFileResult_t)
		},
		{
			CallbackType.RemoteStorageUpdatePublishedFileResult,
			typeof(RemoteStorageUpdatePublishedFileResult_t)
		},
		{
			CallbackType.RemoteStorageDownloadUGCResult,
			typeof(RemoteStorageDownloadUGCResult_t)
		},
		{
			CallbackType.RemoteStorageGetPublishedFileDetailsResult,
			typeof(RemoteStorageGetPublishedFileDetailsResult_t)
		},
		{
			CallbackType.RemoteStorageEnumerateWorkshopFilesResult,
			typeof(RemoteStorageEnumerateWorkshopFilesResult_t)
		},
		{
			CallbackType.RemoteStorageGetPublishedItemVoteDetailsResult,
			typeof(RemoteStorageGetPublishedItemVoteDetailsResult_t)
		},
		{
			CallbackType.RemoteStoragePublishedFileSubscribed,
			typeof(RemoteStoragePublishedFileSubscribed_t)
		},
		{
			CallbackType.RemoteStoragePublishedFileUnsubscribed,
			typeof(RemoteStoragePublishedFileUnsubscribed_t)
		},
		{
			CallbackType.RemoteStoragePublishedFileDeleted,
			typeof(RemoteStoragePublishedFileDeleted_t)
		},
		{
			CallbackType.RemoteStorageUpdateUserPublishedItemVoteResult,
			typeof(RemoteStorageUpdateUserPublishedItemVoteResult_t)
		},
		{
			CallbackType.RemoteStorageUserVoteDetails,
			typeof(RemoteStorageUserVoteDetails_t)
		},
		{
			CallbackType.RemoteStorageEnumerateUserSharedWorkshopFilesResult,
			typeof(RemoteStorageEnumerateUserSharedWorkshopFilesResult_t)
		},
		{
			CallbackType.RemoteStorageSetUserPublishedFileActionResult,
			typeof(RemoteStorageSetUserPublishedFileActionResult_t)
		},
		{
			CallbackType.RemoteStorageEnumeratePublishedFilesByUserActionResult,
			typeof(RemoteStorageEnumeratePublishedFilesByUserActionResult_t)
		},
		{
			CallbackType.RemoteStoragePublishFileProgress,
			typeof(RemoteStoragePublishFileProgress_t)
		},
		{
			CallbackType.RemoteStoragePublishedFileUpdated,
			typeof(RemoteStoragePublishedFileUpdated_t)
		},
		{
			CallbackType.RemoteStorageFileWriteAsyncComplete,
			typeof(RemoteStorageFileWriteAsyncComplete_t)
		},
		{
			CallbackType.RemoteStorageFileReadAsyncComplete,
			typeof(RemoteStorageFileReadAsyncComplete_t)
		},
		{
			CallbackType.RemoteStorageLocalFileChange,
			typeof(RemoteStorageLocalFileChange_t)
		},
		{
			CallbackType.GSStatsReceived,
			typeof(GSStatsReceived_t)
		},
		{
			CallbackType.GSStatsStored,
			typeof(GSStatsStored_t)
		},
		{
			CallbackType.HTTPRequestCompleted,
			typeof(HTTPRequestCompleted_t)
		},
		{
			CallbackType.HTTPRequestHeadersReceived,
			typeof(HTTPRequestHeadersReceived_t)
		},
		{
			CallbackType.HTTPRequestDataReceived,
			typeof(HTTPRequestDataReceived_t)
		},
		{
			CallbackType.ScreenshotReady,
			typeof(ScreenshotReady_t)
		},
		{
			CallbackType.ScreenshotRequested,
			typeof(ScreenshotRequested_t)
		},
		{
			CallbackType.SteamInputDeviceConnected,
			typeof(SteamInputDeviceConnected_t)
		},
		{
			CallbackType.SteamInputDeviceDisconnected,
			typeof(SteamInputDeviceDisconnected_t)
		},
		{
			CallbackType.SteamInputConfigurationLoaded,
			typeof(SteamInputConfigurationLoaded_t)
		},
		{
			CallbackType.SteamInputGamepadSlotChange,
			typeof(SteamInputGamepadSlotChange_t)
		},
		{
			CallbackType.SteamUGCQueryCompleted,
			typeof(SteamUGCQueryCompleted_t)
		},
		{
			CallbackType.SteamUGCRequestUGCDetailsResult,
			typeof(SteamUGCRequestUGCDetailsResult_t)
		},
		{
			CallbackType.CreateItemResult,
			typeof(CreateItemResult_t)
		},
		{
			CallbackType.SubmitItemUpdateResult,
			typeof(SubmitItemUpdateResult_t)
		},
		{
			CallbackType.ItemInstalled,
			typeof(ItemInstalled_t)
		},
		{
			CallbackType.DownloadItemResult,
			typeof(DownloadItemResult_t)
		},
		{
			CallbackType.UserFavoriteItemsListChanged,
			typeof(UserFavoriteItemsListChanged_t)
		},
		{
			CallbackType.SetUserItemVoteResult,
			typeof(SetUserItemVoteResult_t)
		},
		{
			CallbackType.GetUserItemVoteResult,
			typeof(GetUserItemVoteResult_t)
		},
		{
			CallbackType.StartPlaytimeTrackingResult,
			typeof(StartPlaytimeTrackingResult_t)
		},
		{
			CallbackType.StopPlaytimeTrackingResult,
			typeof(StopPlaytimeTrackingResult_t)
		},
		{
			CallbackType.AddUGCDependencyResult,
			typeof(AddUGCDependencyResult_t)
		},
		{
			CallbackType.RemoveUGCDependencyResult,
			typeof(RemoveUGCDependencyResult_t)
		},
		{
			CallbackType.AddAppDependencyResult,
			typeof(AddAppDependencyResult_t)
		},
		{
			CallbackType.RemoveAppDependencyResult,
			typeof(RemoveAppDependencyResult_t)
		},
		{
			CallbackType.GetAppDependenciesResult,
			typeof(GetAppDependenciesResult_t)
		},
		{
			CallbackType.DeleteItemResult,
			typeof(DeleteItemResult_t)
		},
		{
			CallbackType.UserSubscribedItemsListChanged,
			typeof(UserSubscribedItemsListChanged_t)
		},
		{
			CallbackType.WorkshopEULAStatus,
			typeof(WorkshopEULAStatus_t)
		},
		{
			CallbackType.PlaybackStatusHasChanged,
			typeof(PlaybackStatusHasChanged_t)
		},
		{
			CallbackType.VolumeHasChanged,
			typeof(VolumeHasChanged_t)
		},
		{
			CallbackType.MusicPlayerWantsVolume,
			typeof(MusicPlayerWantsVolume_t)
		},
		{
			CallbackType.MusicPlayerSelectsQueueEntry,
			typeof(MusicPlayerSelectsQueueEntry_t)
		},
		{
			CallbackType.MusicPlayerSelectsPlaylistEntry,
			typeof(MusicPlayerSelectsPlaylistEntry_t)
		},
		{
			CallbackType.MusicPlayerRemoteWillActivate,
			typeof(MusicPlayerRemoteWillActivate_t)
		},
		{
			CallbackType.MusicPlayerRemoteWillDeactivate,
			typeof(MusicPlayerRemoteWillDeactivate_t)
		},
		{
			CallbackType.MusicPlayerRemoteToFront,
			typeof(MusicPlayerRemoteToFront_t)
		},
		{
			CallbackType.MusicPlayerWillQuit,
			typeof(MusicPlayerWillQuit_t)
		},
		{
			CallbackType.MusicPlayerWantsPlay,
			typeof(MusicPlayerWantsPlay_t)
		},
		{
			CallbackType.MusicPlayerWantsPause,
			typeof(MusicPlayerWantsPause_t)
		},
		{
			CallbackType.MusicPlayerWantsPlayPrevious,
			typeof(MusicPlayerWantsPlayPrevious_t)
		},
		{
			CallbackType.MusicPlayerWantsPlayNext,
			typeof(MusicPlayerWantsPlayNext_t)
		},
		{
			CallbackType.MusicPlayerWantsShuffled,
			typeof(MusicPlayerWantsShuffled_t)
		},
		{
			CallbackType.MusicPlayerWantsLooped,
			typeof(MusicPlayerWantsLooped_t)
		},
		{
			CallbackType.MusicPlayerWantsPlayingRepeatStatus,
			typeof(MusicPlayerWantsPlayingRepeatStatus_t)
		},
		{
			CallbackType.HTML_BrowserReady,
			typeof(HTML_BrowserReady_t)
		},
		{
			CallbackType.HTML_NeedsPaint,
			typeof(HTML_NeedsPaint_t)
		},
		{
			CallbackType.HTML_StartRequest,
			typeof(HTML_StartRequest_t)
		},
		{
			CallbackType.HTML_CloseBrowser,
			typeof(HTML_CloseBrowser_t)
		},
		{
			CallbackType.HTML_URLChanged,
			typeof(HTML_URLChanged_t)
		},
		{
			CallbackType.HTML_FinishedRequest,
			typeof(HTML_FinishedRequest_t)
		},
		{
			CallbackType.HTML_OpenLinkInNewTab,
			typeof(HTML_OpenLinkInNewTab_t)
		},
		{
			CallbackType.HTML_ChangedTitle,
			typeof(HTML_ChangedTitle_t)
		},
		{
			CallbackType.HTML_SearchResults,
			typeof(HTML_SearchResults_t)
		},
		{
			CallbackType.HTML_CanGoBackAndForward,
			typeof(HTML_CanGoBackAndForward_t)
		},
		{
			CallbackType.HTML_HorizontalScroll,
			typeof(HTML_HorizontalScroll_t)
		},
		{
			CallbackType.HTML_VerticalScroll,
			typeof(HTML_VerticalScroll_t)
		},
		{
			CallbackType.HTML_LinkAtPosition,
			typeof(HTML_LinkAtPosition_t)
		},
		{
			CallbackType.HTML_JSAlert,
			typeof(HTML_JSAlert_t)
		},
		{
			CallbackType.HTML_JSConfirm,
			typeof(HTML_JSConfirm_t)
		},
		{
			CallbackType.HTML_FileOpenDialog,
			typeof(HTML_FileOpenDialog_t)
		},
		{
			CallbackType.HTML_NewWindow,
			typeof(HTML_NewWindow_t)
		},
		{
			CallbackType.HTML_SetCursor,
			typeof(HTML_SetCursor_t)
		},
		{
			CallbackType.HTML_StatusText,
			typeof(HTML_StatusText_t)
		},
		{
			CallbackType.HTML_ShowToolTip,
			typeof(HTML_ShowToolTip_t)
		},
		{
			CallbackType.HTML_UpdateToolTip,
			typeof(HTML_UpdateToolTip_t)
		},
		{
			CallbackType.HTML_HideToolTip,
			typeof(HTML_HideToolTip_t)
		},
		{
			CallbackType.HTML_BrowserRestarted,
			typeof(HTML_BrowserRestarted_t)
		},
		{
			CallbackType.BroadcastUploadStart,
			typeof(BroadcastUploadStart_t)
		},
		{
			CallbackType.BroadcastUploadStop,
			typeof(BroadcastUploadStop_t)
		},
		{
			CallbackType.GetVideoURLResult,
			typeof(GetVideoURLResult_t)
		},
		{
			CallbackType.GetOPFSettingsResult,
			typeof(GetOPFSettingsResult_t)
		},
		{
			CallbackType.SteamInventoryResultReady,
			typeof(SteamInventoryResultReady_t)
		},
		{
			CallbackType.SteamInventoryFullUpdate,
			typeof(SteamInventoryFullUpdate_t)
		},
		{
			CallbackType.SteamInventoryDefinitionUpdate,
			typeof(SteamInventoryDefinitionUpdate_t)
		},
		{
			CallbackType.SteamInventoryEligiblePromoItemDefIDs,
			typeof(SteamInventoryEligiblePromoItemDefIDs_t)
		},
		{
			CallbackType.SteamInventoryStartPurchaseResult,
			typeof(SteamInventoryStartPurchaseResult_t)
		},
		{
			CallbackType.SteamInventoryRequestPricesResult,
			typeof(SteamInventoryRequestPricesResult_t)
		},
		{
			CallbackType.SteamParentalSettingsChanged,
			typeof(SteamParentalSettingsChanged_t)
		},
		{
			CallbackType.SearchForGameProgressCallback,
			typeof(SearchForGameProgressCallback_t)
		},
		{
			CallbackType.SearchForGameResultCallback,
			typeof(SearchForGameResultCallback_t)
		},
		{
			CallbackType.RequestPlayersForGameProgressCallback,
			typeof(RequestPlayersForGameProgressCallback_t)
		},
		{
			CallbackType.RequestPlayersForGameResultCallback,
			typeof(RequestPlayersForGameResultCallback_t)
		},
		{
			CallbackType.RequestPlayersForGameFinalResultCallback,
			typeof(RequestPlayersForGameFinalResultCallback_t)
		},
		{
			CallbackType.SubmitPlayerResultResultCallback,
			typeof(SubmitPlayerResultResultCallback_t)
		},
		{
			CallbackType.EndGameResultCallback,
			typeof(EndGameResultCallback_t)
		},
		{
			CallbackType.JoinPartyCallback,
			typeof(JoinPartyCallback_t)
		},
		{
			CallbackType.CreateBeaconCallback,
			typeof(CreateBeaconCallback_t)
		},
		{
			CallbackType.ReservationNotificationCallback,
			typeof(ReservationNotificationCallback_t)
		},
		{
			CallbackType.ChangeNumOpenSlotsCallback,
			typeof(ChangeNumOpenSlotsCallback_t)
		},
		{
			CallbackType.AvailableBeaconLocationsUpdated,
			typeof(AvailableBeaconLocationsUpdated_t)
		},
		{
			CallbackType.ActiveBeaconsUpdated,
			typeof(ActiveBeaconsUpdated_t)
		},
		{
			CallbackType.SteamRemotePlaySessionConnected,
			typeof(SteamRemotePlaySessionConnected_t)
		},
		{
			CallbackType.SteamRemotePlaySessionDisconnected,
			typeof(SteamRemotePlaySessionDisconnected_t)
		},
		{
			CallbackType.SteamRemotePlayTogetherGuestInvite,
			typeof(SteamRemotePlayTogetherGuestInvite_t)
		},
		{
			CallbackType.SteamTimelineGamePhaseRecordingExists,
			typeof(SteamTimelineGamePhaseRecordingExists_t)
		},
		{
			CallbackType.SteamTimelineEventRecordingExists,
			typeof(SteamTimelineEventRecordingExists_t)
		}
	};
}


using System;
using System.Runtime.InteropServices;
using Steamworks;

internal class ISteamAppList : SteamInterface
{
	internal ISteamAppList(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamAppList_v001();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamAppList_v001();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamAppList_GetNumInstalledApps")]
	private static extern uint _GetNumInstalledApps(IntPtr self);

	internal uint GetNumInstalledApps()
	{
		return _GetNumInstalledApps(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamAppList_GetInstalledApps")]
	private static extern uint _GetInstalledApps(IntPtr self, [In][Out] AppId[] pvecAppID, uint unMaxAppIDs);

	internal uint GetInstalledApps([In][Out] AppId[] pvecAppID, uint unMaxAppIDs)
	{
		return _GetInstalledApps(Self, pvecAppID, unMaxAppIDs);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamAppList_GetAppName")]
	private static extern int _GetAppName(IntPtr self, AppId nAppID, IntPtr pchName, int cchNameMax);

	internal int GetAppName(AppId nAppID, out string pchName)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			int result = _GetAppName(Self, nAppID, m, 32768);
			pchName = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamAppList_GetAppInstallDir")]
	private static extern int _GetAppInstallDir(IntPtr self, AppId nAppID, IntPtr pchDirectory, int cchNameMax);

	internal int GetAppInstallDir(AppId nAppID, out string pchDirectory)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			int result = _GetAppInstallDir(Self, nAppID, m, 32768);
			pchDirectory = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamAppList_GetAppBuildId")]
	private static extern int _GetAppBuildId(IntPtr self, AppId nAppID);

	internal int GetAppBuildId(AppId nAppID)
	{
		return _GetAppBuildId(Self, nAppID);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamApps : SteamInterface
{
	public const string Version = "STEAMAPPS_INTERFACE_VERSION008";

	internal ISteamApps(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamApps_v008();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamApps_v008();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_BIsSubscribed")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsSubscribed(IntPtr self);

	internal bool BIsSubscribed()
	{
		return _BIsSubscribed(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_BIsLowViolence")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsLowViolence(IntPtr self);

	internal bool BIsLowViolence()
	{
		return _BIsLowViolence(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_BIsCybercafe")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsCybercafe(IntPtr self);

	internal bool BIsCybercafe()
	{
		return _BIsCybercafe(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_BIsVACBanned")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsVACBanned(IntPtr self);

	internal bool BIsVACBanned()
	{
		return _BIsVACBanned(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_GetCurrentGameLanguage")]
	private static extern Utf8StringPointer _GetCurrentGameLanguage(IntPtr self);

	internal string GetCurrentGameLanguage()
	{
		return _GetCurrentGameLanguage(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_GetAvailableGameLanguages")]
	private static extern Utf8StringPointer _GetAvailableGameLanguages(IntPtr self);

	internal string GetAvailableGameLanguages()
	{
		return _GetAvailableGameLanguages(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_BIsSubscribedApp")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsSubscribedApp(IntPtr self, AppId appID);

	internal bool BIsSubscribedApp(AppId appID)
	{
		return _BIsSubscribedApp(Self, appID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_BIsDlcInstalled")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsDlcInstalled(IntPtr self, AppId appID);

	internal bool BIsDlcInstalled(AppId appID)
	{
		return _BIsDlcInstalled(Self, appID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_GetEarliestPurchaseUnixTime")]
	private static extern uint _GetEarliestPurchaseUnixTime(IntPtr self, AppId nAppID);

	internal uint GetEarliestPurchaseUnixTime(AppId nAppID)
	{
		return _GetEarliestPurchaseUnixTime(Self, nAppID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_BIsSubscribedFromFreeWeekend")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsSubscribedFromFreeWeekend(IntPtr self);

	internal bool BIsSubscribedFromFreeWeekend()
	{
		return _BIsSubscribedFromFreeWeekend(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_GetDLCCount")]
	private static extern int _GetDLCCount(IntPtr self);

	internal int GetDLCCount()
	{
		return _GetDLCCount(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_BGetDLCDataByIndex")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BGetDLCDataByIndex(IntPtr self, int iDLC, ref AppId pAppID, [MarshalAs(UnmanagedType.U1)] ref bool pbAvailable, IntPtr pchName, int cchNameBufferSize);

	internal bool BGetDLCDataByIndex(int iDLC, ref AppId pAppID, [MarshalAs(UnmanagedType.U1)] ref bool pbAvailable, out string pchName)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			bool result = _BGetDLCDataByIndex(Self, iDLC, ref pAppID, ref pbAvailable, m, 32768);
			pchName = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_InstallDLC")]
	private static extern void _InstallDLC(IntPtr self, AppId nAppID);

	internal void InstallDLC(AppId nAppID)
	{
		_InstallDLC(Self, nAppID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_UninstallDLC")]
	private static extern void _UninstallDLC(IntPtr self, AppId nAppID);

	internal void UninstallDLC(AppId nAppID)
	{
		_UninstallDLC(Self, nAppID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_RequestAppProofOfPurchaseKey")]
	private static extern void _RequestAppProofOfPurchaseKey(IntPtr self, AppId nAppID);

	internal void RequestAppProofOfPurchaseKey(AppId nAppID)
	{
		_RequestAppProofOfPurchaseKey(Self, nAppID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_GetCurrentBetaName")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetCurrentBetaName(IntPtr self, IntPtr pchName, int cchNameBufferSize);

	internal bool GetCurrentBetaName(out string pchName)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			bool result = _GetCurrentBetaName(Self, m, 32768);
			pchName = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_MarkContentCorrupt")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _MarkContentCorrupt(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bMissingFilesOnly);

	internal bool MarkContentCorrupt([MarshalAs(UnmanagedType.U1)] bool bMissingFilesOnly)
	{
		return _MarkContentCorrupt(Self, bMissingFilesOnly);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_GetInstalledDepots")]
	private static extern uint _GetInstalledDepots(IntPtr self, AppId appID, [In][Out] DepotId_t[] pvecDepots, uint cMaxDepots);

	internal uint GetInstalledDepots(AppId appID, [In][Out] DepotId_t[] pvecDepots, uint cMaxDepots)
	{
		return _GetInstalledDepots(Self, appID, pvecDepots, cMaxDepots);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_GetAppInstallDir")]
	private static extern uint _GetAppInstallDir(IntPtr self, AppId appID, IntPtr pchFolder, uint cchFolderBufferSize);

	internal uint GetAppInstallDir(AppId appID, out string pchFolder)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			uint result = _GetAppInstallDir(Self, appID, m, 32768u);
			pchFolder = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_BIsAppInstalled")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsAppInstalled(IntPtr self, AppId appID);

	internal bool BIsAppInstalled(AppId appID)
	{
		return _BIsAppInstalled(Self, appID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_GetAppOwner")]
	private static extern SteamId _GetAppOwner(IntPtr self);

	internal SteamId GetAppOwner()
	{
		return _GetAppOwner(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_GetLaunchQueryParam")]
	private static extern Utf8StringPointer _GetLaunchQueryParam(IntPtr self, IntPtr pchKey);

	internal string GetLaunchQueryParam(string pchKey)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchKey);
		return _GetLaunchQueryParam(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_GetDlcDownloadProgress")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetDlcDownloadProgress(IntPtr self, AppId nAppID, ref ulong punBytesDownloaded, ref ulong punBytesTotal);

	internal bool GetDlcDownloadProgress(AppId nAppID, ref ulong punBytesDownloaded, ref ulong punBytesTotal)
	{
		return _GetDlcDownloadProgress(Self, nAppID, ref punBytesDownloaded, ref punBytesTotal);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_GetAppBuildId")]
	private static extern int _GetAppBuildId(IntPtr self);

	internal int GetAppBuildId()
	{
		return _GetAppBuildId(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_RequestAllProofOfPurchaseKeys")]
	private static extern void _RequestAllProofOfPurchaseKeys(IntPtr self);

	internal void RequestAllProofOfPurchaseKeys()
	{
		_RequestAllProofOfPurchaseKeys(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_GetFileDetails")]
	private static extern SteamAPICall_t _GetFileDetails(IntPtr self, IntPtr pszFileName);

	internal CallResult<FileDetailsResult_t> GetFileDetails(string pszFileName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszFileName);
		return new CallResult<FileDetailsResult_t>(_GetFileDetails(Self, utf8StringToNative.Pointer), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_GetLaunchCommandLine")]
	private static extern int _GetLaunchCommandLine(IntPtr self, IntPtr pszCommandLine, int cubCommandLine);

	internal int GetLaunchCommandLine(out string pszCommandLine)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			int result = _GetLaunchCommandLine(Self, m, 32768);
			pszCommandLine = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_BIsSubscribedFromFamilySharing")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsSubscribedFromFamilySharing(IntPtr self);

	internal bool BIsSubscribedFromFamilySharing()
	{
		return _BIsSubscribedFromFamilySharing(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_BIsTimedTrial")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsTimedTrial(IntPtr self, ref uint punSecondsAllowed, ref uint punSecondsPlayed);

	internal bool BIsTimedTrial(ref uint punSecondsAllowed, ref uint punSecondsPlayed)
	{
		return _BIsTimedTrial(Self, ref punSecondsAllowed, ref punSecondsPlayed);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_SetDlcContext")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetDlcContext(IntPtr self, AppId nAppID);

	internal bool SetDlcContext(AppId nAppID)
	{
		return _SetDlcContext(Self, nAppID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_GetNumBetas")]
	private static extern int _GetNumBetas(IntPtr self, ref int pnAvailable, ref int pnPrivate);

	internal int GetNumBetas(ref int pnAvailable, ref int pnPrivate)
	{
		return _GetNumBetas(Self, ref pnAvailable, ref pnPrivate);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_GetBetaInfo")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetBetaInfo(IntPtr self, int iBetaIndex, ref uint punFlags, ref uint punBuildID, IntPtr pchBetaName, int cchBetaName, IntPtr pchDescription, int cchDescription);

	internal bool GetBetaInfo(int iBetaIndex, ref uint punFlags, ref uint punBuildID, out string pchBetaName, out string pchDescription)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			Helpers.Memory m2 = Helpers.TakeMemory();
			try
			{
				bool result = _GetBetaInfo(Self, iBetaIndex, ref punFlags, ref punBuildID, m, 32768, m2, 32768);
				pchBetaName = Helpers.MemoryToString(m);
				pchDescription = Helpers.MemoryToString(m2);
				return result;
			}
			finally
			{
				((IDisposable)m2/*cast due to .constrained prefix*/).Dispose();
			}
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamApps_SetActiveBeta")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetActiveBeta(IntPtr self, IntPtr pchBetaName);

	internal bool SetActiveBeta(string pchBetaName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchBetaName);
		return _SetActiveBeta(Self, utf8StringToNative.Pointer);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamClient : SteamInterface
{
	internal ISteamClient(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_CreateSteamPipe")]
	private static extern HSteamPipe _CreateSteamPipe(IntPtr self);

	internal HSteamPipe CreateSteamPipe()
	{
		return _CreateSteamPipe(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_BReleaseSteamPipe")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BReleaseSteamPipe(IntPtr self, HSteamPipe hSteamPipe);

	internal bool BReleaseSteamPipe(HSteamPipe hSteamPipe)
	{
		return _BReleaseSteamPipe(Self, hSteamPipe);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_ConnectToGlobalUser")]
	private static extern HSteamUser _ConnectToGlobalUser(IntPtr self, HSteamPipe hSteamPipe);

	internal HSteamUser ConnectToGlobalUser(HSteamPipe hSteamPipe)
	{
		return _ConnectToGlobalUser(Self, hSteamPipe);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_CreateLocalUser")]
	private static extern HSteamUser _CreateLocalUser(IntPtr self, ref HSteamPipe phSteamPipe, AccountType eAccountType);

	internal HSteamUser CreateLocalUser(ref HSteamPipe phSteamPipe, AccountType eAccountType)
	{
		return _CreateLocalUser(Self, ref phSteamPipe, eAccountType);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_ReleaseUser")]
	private static extern void _ReleaseUser(IntPtr self, HSteamPipe hSteamPipe, HSteamUser hUser);

	internal void ReleaseUser(HSteamPipe hSteamPipe, HSteamUser hUser)
	{
		_ReleaseUser(Self, hSteamPipe, hUser);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamUser")]
	private static extern IntPtr _GetISteamUser(IntPtr self, HSteamUser hSteamUser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamUser(HSteamUser hSteamUser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamUser(Self, hSteamUser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamGameServer")]
	private static extern IntPtr _GetISteamGameServer(IntPtr self, HSteamUser hSteamUser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamGameServer(HSteamUser hSteamUser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamGameServer(Self, hSteamUser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_SetLocalIPBinding")]
	private static extern void _SetLocalIPBinding(IntPtr self, ref SteamIPAddress unIP, ushort usPort);

	internal void SetLocalIPBinding(ref SteamIPAddress unIP, ushort usPort)
	{
		_SetLocalIPBinding(Self, ref unIP, usPort);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamFriends")]
	private static extern IntPtr _GetISteamFriends(IntPtr self, HSteamUser hSteamUser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamFriends(HSteamUser hSteamUser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamFriends(Self, hSteamUser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamUtils")]
	private static extern IntPtr _GetISteamUtils(IntPtr self, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamUtils(HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamUtils(Self, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamMatchmaking")]
	private static extern IntPtr _GetISteamMatchmaking(IntPtr self, HSteamUser hSteamUser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamMatchmaking(HSteamUser hSteamUser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamMatchmaking(Self, hSteamUser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamMatchmakingServers")]
	private static extern IntPtr _GetISteamMatchmakingServers(IntPtr self, HSteamUser hSteamUser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamMatchmakingServers(HSteamUser hSteamUser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamMatchmakingServers(Self, hSteamUser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamGenericInterface")]
	private static extern IntPtr _GetISteamGenericInterface(IntPtr self, HSteamUser hSteamUser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamGenericInterface(HSteamUser hSteamUser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamGenericInterface(Self, hSteamUser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamUserStats")]
	private static extern IntPtr _GetISteamUserStats(IntPtr self, HSteamUser hSteamUser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamUserStats(HSteamUser hSteamUser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamUserStats(Self, hSteamUser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamGameServerStats")]
	private static extern IntPtr _GetISteamGameServerStats(IntPtr self, HSteamUser hSteamuser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamGameServerStats(HSteamUser hSteamuser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamGameServerStats(Self, hSteamuser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamApps")]
	private static extern IntPtr _GetISteamApps(IntPtr self, HSteamUser hSteamUser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamApps(HSteamUser hSteamUser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamApps(Self, hSteamUser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamNetworking")]
	private static extern IntPtr _GetISteamNetworking(IntPtr self, HSteamUser hSteamUser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamNetworking(HSteamUser hSteamUser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamNetworking(Self, hSteamUser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamRemoteStorage")]
	private static extern IntPtr _GetISteamRemoteStorage(IntPtr self, HSteamUser hSteamuser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamRemoteStorage(HSteamUser hSteamuser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamRemoteStorage(Self, hSteamuser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamScreenshots")]
	private static extern IntPtr _GetISteamScreenshots(IntPtr self, HSteamUser hSteamuser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamScreenshots(HSteamUser hSteamuser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamScreenshots(Self, hSteamuser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamGameSearch")]
	private static extern IntPtr _GetISteamGameSearch(IntPtr self, HSteamUser hSteamuser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamGameSearch(HSteamUser hSteamuser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamGameSearch(Self, hSteamuser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetIPCCallCount")]
	private static extern uint _GetIPCCallCount(IntPtr self);

	internal uint GetIPCCallCount()
	{
		return _GetIPCCallCount(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_SetWarningMessageHook")]
	private static extern void _SetWarningMessageHook(IntPtr self, IntPtr pFunction);

	internal void SetWarningMessageHook(IntPtr pFunction)
	{
		_SetWarningMessageHook(Self, pFunction);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_BShutdownIfAllPipesClosed")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BShutdownIfAllPipesClosed(IntPtr self);

	internal bool BShutdownIfAllPipesClosed()
	{
		return _BShutdownIfAllPipesClosed(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamHTTP")]
	private static extern IntPtr _GetISteamHTTP(IntPtr self, HSteamUser hSteamuser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamHTTP(HSteamUser hSteamuser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamHTTP(Self, hSteamuser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamController")]
	private static extern IntPtr _GetISteamController(IntPtr self, HSteamUser hSteamUser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamController(HSteamUser hSteamUser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamController(Self, hSteamUser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamUGC")]
	private static extern IntPtr _GetISteamUGC(IntPtr self, HSteamUser hSteamUser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamUGC(HSteamUser hSteamUser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamUGC(Self, hSteamUser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamMusic")]
	private static extern IntPtr _GetISteamMusic(IntPtr self, HSteamUser hSteamuser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamMusic(HSteamUser hSteamuser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamMusic(Self, hSteamuser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamMusicRemote")]
	private static extern IntPtr _GetISteamMusicRemote(IntPtr self, HSteamUser hSteamuser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamMusicRemote(HSteamUser hSteamuser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamMusicRemote(Self, hSteamuser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamHTMLSurface")]
	private static extern IntPtr _GetISteamHTMLSurface(IntPtr self, HSteamUser hSteamuser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamHTMLSurface(HSteamUser hSteamuser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamHTMLSurface(Self, hSteamuser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamInventory")]
	private static extern IntPtr _GetISteamInventory(IntPtr self, HSteamUser hSteamuser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamInventory(HSteamUser hSteamuser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamInventory(Self, hSteamuser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamVideo")]
	private static extern IntPtr _GetISteamVideo(IntPtr self, HSteamUser hSteamuser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamVideo(HSteamUser hSteamuser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamVideo(Self, hSteamuser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamParentalSettings")]
	private static extern IntPtr _GetISteamParentalSettings(IntPtr self, HSteamUser hSteamuser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamParentalSettings(HSteamUser hSteamuser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamParentalSettings(Self, hSteamuser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamInput")]
	private static extern IntPtr _GetISteamInput(IntPtr self, HSteamUser hSteamUser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamInput(HSteamUser hSteamUser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamInput(Self, hSteamUser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamParties")]
	private static extern IntPtr _GetISteamParties(IntPtr self, HSteamUser hSteamUser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamParties(HSteamUser hSteamUser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamParties(Self, hSteamUser, hSteamPipe, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamClient_GetISteamRemotePlay")]
	private static extern IntPtr _GetISteamRemotePlay(IntPtr self, HSteamUser hSteamUser, HSteamPipe hSteamPipe, IntPtr pchVersion);

	internal IntPtr GetISteamRemotePlay(HSteamUser hSteamUser, HSteamPipe hSteamPipe, string pchVersion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchVersion);
		return _GetISteamRemotePlay(Self, hSteamUser, hSteamPipe, utf8StringToNative.Pointer);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamController : SteamInterface
{
	public const string Version = "SteamController008";

	internal ISteamController(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamController_v008();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamController_v008();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_Init")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _Init(IntPtr self);

	internal bool Init()
	{
		return _Init(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_Shutdown")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _Shutdown(IntPtr self);

	internal bool Shutdown()
	{
		return _Shutdown(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_RunFrame")]
	private static extern void _RunFrame(IntPtr self);

	internal void RunFrame()
	{
		_RunFrame(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_GetConnectedControllers")]
	private static extern int _GetConnectedControllers(IntPtr self, [In][Out] ControllerHandle_t[] handlesOut);

	internal int GetConnectedControllers([In][Out] ControllerHandle_t[] handlesOut)
	{
		return _GetConnectedControllers(Self, handlesOut);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_GetActionSetHandle")]
	private static extern ControllerActionSetHandle_t _GetActionSetHandle(IntPtr self, IntPtr pszActionSetName);

	internal ControllerActionSetHandle_t GetActionSetHandle(string pszActionSetName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszActionSetName);
		return _GetActionSetHandle(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_ActivateActionSet")]
	private static extern void _ActivateActionSet(IntPtr self, ControllerHandle_t controllerHandle, ControllerActionSetHandle_t actionSetHandle);

	internal void ActivateActionSet(ControllerHandle_t controllerHandle, ControllerActionSetHandle_t actionSetHandle)
	{
		_ActivateActionSet(Self, controllerHandle, actionSetHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_GetCurrentActionSet")]
	private static extern ControllerActionSetHandle_t _GetCurrentActionSet(IntPtr self, ControllerHandle_t controllerHandle);

	internal ControllerActionSetHandle_t GetCurrentActionSet(ControllerHandle_t controllerHandle)
	{
		return _GetCurrentActionSet(Self, controllerHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_ActivateActionSetLayer")]
	private static extern void _ActivateActionSetLayer(IntPtr self, ControllerHandle_t controllerHandle, ControllerActionSetHandle_t actionSetLayerHandle);

	internal void ActivateActionSetLayer(ControllerHandle_t controllerHandle, ControllerActionSetHandle_t actionSetLayerHandle)
	{
		_ActivateActionSetLayer(Self, controllerHandle, actionSetLayerHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_DeactivateActionSetLayer")]
	private static extern void _DeactivateActionSetLayer(IntPtr self, ControllerHandle_t controllerHandle, ControllerActionSetHandle_t actionSetLayerHandle);

	internal void DeactivateActionSetLayer(ControllerHandle_t controllerHandle, ControllerActionSetHandle_t actionSetLayerHandle)
	{
		_DeactivateActionSetLayer(Self, controllerHandle, actionSetLayerHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_DeactivateAllActionSetLayers")]
	private static extern void _DeactivateAllActionSetLayers(IntPtr self, ControllerHandle_t controllerHandle);

	internal void DeactivateAllActionSetLayers(ControllerHandle_t controllerHandle)
	{
		_DeactivateAllActionSetLayers(Self, controllerHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_GetActiveActionSetLayers")]
	private static extern int _GetActiveActionSetLayers(IntPtr self, ControllerHandle_t controllerHandle, [In][Out] ControllerActionSetHandle_t[] handlesOut);

	internal int GetActiveActionSetLayers(ControllerHandle_t controllerHandle, [In][Out] ControllerActionSetHandle_t[] handlesOut)
	{
		return _GetActiveActionSetLayers(Self, controllerHandle, handlesOut);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_GetDigitalActionHandle")]
	private static extern ControllerDigitalActionHandle_t _GetDigitalActionHandle(IntPtr self, IntPtr pszActionName);

	internal ControllerDigitalActionHandle_t GetDigitalActionHandle(string pszActionName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszActionName);
		return _GetDigitalActionHandle(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_GetDigitalActionData")]
	private static extern DigitalState _GetDigitalActionData(IntPtr self, ControllerHandle_t controllerHandle, ControllerDigitalActionHandle_t digitalActionHandle);

	internal DigitalState GetDigitalActionData(ControllerHandle_t controllerHandle, ControllerDigitalActionHandle_t digitalActionHandle)
	{
		return _GetDigitalActionData(Self, controllerHandle, digitalActionHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_GetDigitalActionOrigins")]
	private static extern int _GetDigitalActionOrigins(IntPtr self, ControllerHandle_t controllerHandle, ControllerActionSetHandle_t actionSetHandle, ControllerDigitalActionHandle_t digitalActionHandle, ref ControllerActionOrigin originsOut);

	internal int GetDigitalActionOrigins(ControllerHandle_t controllerHandle, ControllerActionSetHandle_t actionSetHandle, ControllerDigitalActionHandle_t digitalActionHandle, ref ControllerActionOrigin originsOut)
	{
		return _GetDigitalActionOrigins(Self, controllerHandle, actionSetHandle, digitalActionHandle, ref originsOut);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_GetAnalogActionHandle")]
	private static extern ControllerAnalogActionHandle_t _GetAnalogActionHandle(IntPtr self, IntPtr pszActionName);

	internal ControllerAnalogActionHandle_t GetAnalogActionHandle(string pszActionName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszActionName);
		return _GetAnalogActionHandle(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_GetAnalogActionData")]
	private static extern AnalogState _GetAnalogActionData(IntPtr self, ControllerHandle_t controllerHandle, ControllerAnalogActionHandle_t analogActionHandle);

	internal AnalogState GetAnalogActionData(ControllerHandle_t controllerHandle, ControllerAnalogActionHandle_t analogActionHandle)
	{
		return _GetAnalogActionData(Self, controllerHandle, analogActionHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_GetAnalogActionOrigins")]
	private static extern int _GetAnalogActionOrigins(IntPtr self, ControllerHandle_t controllerHandle, ControllerActionSetHandle_t actionSetHandle, ControllerAnalogActionHandle_t analogActionHandle, ref ControllerActionOrigin originsOut);

	internal int GetAnalogActionOrigins(ControllerHandle_t controllerHandle, ControllerActionSetHandle_t actionSetHandle, ControllerAnalogActionHandle_t analogActionHandle, ref ControllerActionOrigin originsOut)
	{
		return _GetAnalogActionOrigins(Self, controllerHandle, actionSetHandle, analogActionHandle, ref originsOut);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_GetGlyphForActionOrigin")]
	private static extern Utf8StringPointer _GetGlyphForActionOrigin(IntPtr self, ControllerActionOrigin eOrigin);

	internal string GetGlyphForActionOrigin(ControllerActionOrigin eOrigin)
	{
		return _GetGlyphForActionOrigin(Self, eOrigin);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_GetStringForActionOrigin")]
	private static extern Utf8StringPointer _GetStringForActionOrigin(IntPtr self, ControllerActionOrigin eOrigin);

	internal string GetStringForActionOrigin(ControllerActionOrigin eOrigin)
	{
		return _GetStringForActionOrigin(Self, eOrigin);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_StopAnalogActionMomentum")]
	private static extern void _StopAnalogActionMomentum(IntPtr self, ControllerHandle_t controllerHandle, ControllerAnalogActionHandle_t eAction);

	internal void StopAnalogActionMomentum(ControllerHandle_t controllerHandle, ControllerAnalogActionHandle_t eAction)
	{
		_StopAnalogActionMomentum(Self, controllerHandle, eAction);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_GetMotionData")]
	private static extern MotionState _GetMotionData(IntPtr self, ControllerHandle_t controllerHandle);

	internal MotionState GetMotionData(ControllerHandle_t controllerHandle)
	{
		return _GetMotionData(Self, controllerHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_TriggerHapticPulse")]
	private static extern void _TriggerHapticPulse(IntPtr self, ControllerHandle_t controllerHandle, SteamControllerPad eTargetPad, ushort usDurationMicroSec);

	internal void TriggerHapticPulse(ControllerHandle_t controllerHandle, SteamControllerPad eTargetPad, ushort usDurationMicroSec)
	{
		_TriggerHapticPulse(Self, controllerHandle, eTargetPad, usDurationMicroSec);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_TriggerRepeatedHapticPulse")]
	private static extern void _TriggerRepeatedHapticPulse(IntPtr self, ControllerHandle_t controllerHandle, SteamControllerPad eTargetPad, ushort usDurationMicroSec, ushort usOffMicroSec, ushort unRepeat, uint nFlags);

	internal void TriggerRepeatedHapticPulse(ControllerHandle_t controllerHandle, SteamControllerPad eTargetPad, ushort usDurationMicroSec, ushort usOffMicroSec, ushort unRepeat, uint nFlags)
	{
		_TriggerRepeatedHapticPulse(Self, controllerHandle, eTargetPad, usDurationMicroSec, usOffMicroSec, unRepeat, nFlags);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_TriggerVibration")]
	private static extern void _TriggerVibration(IntPtr self, ControllerHandle_t controllerHandle, ushort usLeftSpeed, ushort usRightSpeed);

	internal void TriggerVibration(ControllerHandle_t controllerHandle, ushort usLeftSpeed, ushort usRightSpeed)
	{
		_TriggerVibration(Self, controllerHandle, usLeftSpeed, usRightSpeed);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_SetLEDColor")]
	private static extern void _SetLEDColor(IntPtr self, ControllerHandle_t controllerHandle, byte nColorR, byte nColorG, byte nColorB, uint nFlags);

	internal void SetLEDColor(ControllerHandle_t controllerHandle, byte nColorR, byte nColorG, byte nColorB, uint nFlags)
	{
		_SetLEDColor(Self, controllerHandle, nColorR, nColorG, nColorB, nFlags);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_ShowBindingPanel")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _ShowBindingPanel(IntPtr self, ControllerHandle_t controllerHandle);

	internal bool ShowBindingPanel(ControllerHandle_t controllerHandle)
	{
		return _ShowBindingPanel(Self, controllerHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_GetInputTypeForHandle")]
	private static extern InputType _GetInputTypeForHandle(IntPtr self, ControllerHandle_t controllerHandle);

	internal InputType GetInputTypeForHandle(ControllerHandle_t controllerHandle)
	{
		return _GetInputTypeForHandle(Self, controllerHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_GetControllerForGamepadIndex")]
	private static extern ControllerHandle_t _GetControllerForGamepadIndex(IntPtr self, int nIndex);

	internal ControllerHandle_t GetControllerForGamepadIndex(int nIndex)
	{
		return _GetControllerForGamepadIndex(Self, nIndex);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_GetGamepadIndexForController")]
	private static extern int _GetGamepadIndexForController(IntPtr self, ControllerHandle_t ulControllerHandle);

	internal int GetGamepadIndexForController(ControllerHandle_t ulControllerHandle)
	{
		return _GetGamepadIndexForController(Self, ulControllerHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_GetStringForXboxOrigin")]
	private static extern Utf8StringPointer _GetStringForXboxOrigin(IntPtr self, XboxOrigin eOrigin);

	internal string GetStringForXboxOrigin(XboxOrigin eOrigin)
	{
		return _GetStringForXboxOrigin(Self, eOrigin);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_GetGlyphForXboxOrigin")]
	private static extern Utf8StringPointer _GetGlyphForXboxOrigin(IntPtr self, XboxOrigin eOrigin);

	internal string GetGlyphForXboxOrigin(XboxOrigin eOrigin)
	{
		return _GetGlyphForXboxOrigin(Self, eOrigin);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_GetActionOriginFromXboxOrigin")]
	private static extern ControllerActionOrigin _GetActionOriginFromXboxOrigin(IntPtr self, ControllerHandle_t controllerHandle, XboxOrigin eOrigin);

	internal ControllerActionOrigin GetActionOriginFromXboxOrigin(ControllerHandle_t controllerHandle, XboxOrigin eOrigin)
	{
		return _GetActionOriginFromXboxOrigin(Self, controllerHandle, eOrigin);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_TranslateActionOrigin")]
	private static extern ControllerActionOrigin _TranslateActionOrigin(IntPtr self, InputType eDestinationInputType, ControllerActionOrigin eSourceOrigin);

	internal ControllerActionOrigin TranslateActionOrigin(InputType eDestinationInputType, ControllerActionOrigin eSourceOrigin)
	{
		return _TranslateActionOrigin(Self, eDestinationInputType, eSourceOrigin);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamController_GetControllerBindingRevision")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetControllerBindingRevision(IntPtr self, ControllerHandle_t controllerHandle, ref int pMajor, ref int pMinor);

	internal bool GetControllerBindingRevision(ControllerHandle_t controllerHandle, ref int pMajor, ref int pMinor)
	{
		return _GetControllerBindingRevision(Self, controllerHandle, ref pMajor, ref pMinor);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamFriends : SteamInterface
{
	public const string Version = "SteamFriends017";

	internal ISteamFriends(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamFriends_v017();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamFriends_v017();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetPersonaName")]
	private static extern Utf8StringPointer _GetPersonaName(IntPtr self);

	internal string GetPersonaName()
	{
		return _GetPersonaName(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_SetPersonaName")]
	private static extern SteamAPICall_t _SetPersonaName(IntPtr self, IntPtr pchPersonaName);

	internal CallResult<SetPersonaNameResponse_t> SetPersonaName(string pchPersonaName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchPersonaName);
		return new CallResult<SetPersonaNameResponse_t>(_SetPersonaName(Self, utf8StringToNative.Pointer), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetPersonaState")]
	private static extern FriendState _GetPersonaState(IntPtr self);

	internal FriendState GetPersonaState()
	{
		return _GetPersonaState(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFriendCount")]
	private static extern int _GetFriendCount(IntPtr self, int iFriendFlags);

	internal int GetFriendCount(int iFriendFlags)
	{
		return _GetFriendCount(Self, iFriendFlags);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFriendByIndex")]
	private static extern SteamId _GetFriendByIndex(IntPtr self, int iFriend, int iFriendFlags);

	internal SteamId GetFriendByIndex(int iFriend, int iFriendFlags)
	{
		return _GetFriendByIndex(Self, iFriend, iFriendFlags);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFriendRelationship")]
	private static extern Relationship _GetFriendRelationship(IntPtr self, SteamId steamIDFriend);

	internal Relationship GetFriendRelationship(SteamId steamIDFriend)
	{
		return _GetFriendRelationship(Self, steamIDFriend);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFriendPersonaState")]
	private static extern FriendState _GetFriendPersonaState(IntPtr self, SteamId steamIDFriend);

	internal FriendState GetFriendPersonaState(SteamId steamIDFriend)
	{
		return _GetFriendPersonaState(Self, steamIDFriend);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFriendPersonaName")]
	private static extern Utf8StringPointer _GetFriendPersonaName(IntPtr self, SteamId steamIDFriend);

	internal string GetFriendPersonaName(SteamId steamIDFriend)
	{
		return _GetFriendPersonaName(Self, steamIDFriend);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFriendGamePlayed")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetFriendGamePlayed(IntPtr self, SteamId steamIDFriend, ref FriendGameInfo_t pFriendGameInfo);

	internal bool GetFriendGamePlayed(SteamId steamIDFriend, ref FriendGameInfo_t pFriendGameInfo)
	{
		return _GetFriendGamePlayed(Self, steamIDFriend, ref pFriendGameInfo);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFriendPersonaNameHistory")]
	private static extern Utf8StringPointer _GetFriendPersonaNameHistory(IntPtr self, SteamId steamIDFriend, int iPersonaName);

	internal string GetFriendPersonaNameHistory(SteamId steamIDFriend, int iPersonaName)
	{
		return _GetFriendPersonaNameHistory(Self, steamIDFriend, iPersonaName);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFriendSteamLevel")]
	private static extern int _GetFriendSteamLevel(IntPtr self, SteamId steamIDFriend);

	internal int GetFriendSteamLevel(SteamId steamIDFriend)
	{
		return _GetFriendSteamLevel(Self, steamIDFriend);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetPlayerNickname")]
	private static extern Utf8StringPointer _GetPlayerNickname(IntPtr self, SteamId steamIDPlayer);

	internal string GetPlayerNickname(SteamId steamIDPlayer)
	{
		return _GetPlayerNickname(Self, steamIDPlayer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFriendsGroupCount")]
	private static extern int _GetFriendsGroupCount(IntPtr self);

	internal int GetFriendsGroupCount()
	{
		return _GetFriendsGroupCount(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFriendsGroupIDByIndex")]
	private static extern FriendsGroupID_t _GetFriendsGroupIDByIndex(IntPtr self, int iFG);

	internal FriendsGroupID_t GetFriendsGroupIDByIndex(int iFG)
	{
		return _GetFriendsGroupIDByIndex(Self, iFG);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFriendsGroupName")]
	private static extern Utf8StringPointer _GetFriendsGroupName(IntPtr self, FriendsGroupID_t friendsGroupID);

	internal string GetFriendsGroupName(FriendsGroupID_t friendsGroupID)
	{
		return _GetFriendsGroupName(Self, friendsGroupID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFriendsGroupMembersCount")]
	private static extern int _GetFriendsGroupMembersCount(IntPtr self, FriendsGroupID_t friendsGroupID);

	internal int GetFriendsGroupMembersCount(FriendsGroupID_t friendsGroupID)
	{
		return _GetFriendsGroupMembersCount(Self, friendsGroupID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFriendsGroupMembersList")]
	private static extern void _GetFriendsGroupMembersList(IntPtr self, FriendsGroupID_t friendsGroupID, [In][Out] SteamId[] pOutSteamIDMembers, int nMembersCount);

	internal void GetFriendsGroupMembersList(FriendsGroupID_t friendsGroupID, [In][Out] SteamId[] pOutSteamIDMembers, int nMembersCount)
	{
		_GetFriendsGroupMembersList(Self, friendsGroupID, pOutSteamIDMembers, nMembersCount);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_HasFriend")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _HasFriend(IntPtr self, SteamId steamIDFriend, int iFriendFlags);

	internal bool HasFriend(SteamId steamIDFriend, int iFriendFlags)
	{
		return _HasFriend(Self, steamIDFriend, iFriendFlags);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetClanCount")]
	private static extern int _GetClanCount(IntPtr self);

	internal int GetClanCount()
	{
		return _GetClanCount(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetClanByIndex")]
	private static extern SteamId _GetClanByIndex(IntPtr self, int iClan);

	internal SteamId GetClanByIndex(int iClan)
	{
		return _GetClanByIndex(Self, iClan);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetClanName")]
	private static extern Utf8StringPointer _GetClanName(IntPtr self, SteamId steamIDClan);

	internal string GetClanName(SteamId steamIDClan)
	{
		return _GetClanName(Self, steamIDClan);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetClanTag")]
	private static extern Utf8StringPointer _GetClanTag(IntPtr self, SteamId steamIDClan);

	internal string GetClanTag(SteamId steamIDClan)
	{
		return _GetClanTag(Self, steamIDClan);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetClanActivityCounts")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetClanActivityCounts(IntPtr self, SteamId steamIDClan, ref int pnOnline, ref int pnInGame, ref int pnChatting);

	internal bool GetClanActivityCounts(SteamId steamIDClan, ref int pnOnline, ref int pnInGame, ref int pnChatting)
	{
		return _GetClanActivityCounts(Self, steamIDClan, ref pnOnline, ref pnInGame, ref pnChatting);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_DownloadClanActivityCounts")]
	private static extern SteamAPICall_t _DownloadClanActivityCounts(IntPtr self, [In][Out] SteamId[] psteamIDClans, int cClansToRequest);

	internal CallResult<DownloadClanActivityCountsResult_t> DownloadClanActivityCounts([In][Out] SteamId[] psteamIDClans, int cClansToRequest)
	{
		return new CallResult<DownloadClanActivityCountsResult_t>(_DownloadClanActivityCounts(Self, psteamIDClans, cClansToRequest), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFriendCountFromSource")]
	private static extern int _GetFriendCountFromSource(IntPtr self, SteamId steamIDSource);

	internal int GetFriendCountFromSource(SteamId steamIDSource)
	{
		return _GetFriendCountFromSource(Self, steamIDSource);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFriendFromSourceByIndex")]
	private static extern SteamId _GetFriendFromSourceByIndex(IntPtr self, SteamId steamIDSource, int iFriend);

	internal SteamId GetFriendFromSourceByIndex(SteamId steamIDSource, int iFriend)
	{
		return _GetFriendFromSourceByIndex(Self, steamIDSource, iFriend);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_IsUserInSource")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _IsUserInSource(IntPtr self, SteamId steamIDUser, SteamId steamIDSource);

	internal bool IsUserInSource(SteamId steamIDUser, SteamId steamIDSource)
	{
		return _IsUserInSource(Self, steamIDUser, steamIDSource);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_SetInGameVoiceSpeaking")]
	private static extern void _SetInGameVoiceSpeaking(IntPtr self, SteamId steamIDUser, [MarshalAs(UnmanagedType.U1)] bool bSpeaking);

	internal void SetInGameVoiceSpeaking(SteamId steamIDUser, [MarshalAs(UnmanagedType.U1)] bool bSpeaking)
	{
		_SetInGameVoiceSpeaking(Self, steamIDUser, bSpeaking);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_ActivateGameOverlay")]
	private static extern void _ActivateGameOverlay(IntPtr self, IntPtr pchDialog);

	internal void ActivateGameOverlay(string pchDialog)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchDialog);
		_ActivateGameOverlay(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_ActivateGameOverlayToUser")]
	private static extern void _ActivateGameOverlayToUser(IntPtr self, IntPtr pchDialog, SteamId steamID);

	internal void ActivateGameOverlayToUser(string pchDialog, SteamId steamID)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchDialog);
		_ActivateGameOverlayToUser(Self, utf8StringToNative.Pointer, steamID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_ActivateGameOverlayToWebPage")]
	private static extern void _ActivateGameOverlayToWebPage(IntPtr self, IntPtr pchURL, ActivateGameOverlayToWebPageMode eMode);

	internal void ActivateGameOverlayToWebPage(string pchURL, ActivateGameOverlayToWebPageMode eMode)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchURL);
		_ActivateGameOverlayToWebPage(Self, utf8StringToNative.Pointer, eMode);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_ActivateGameOverlayToStore")]
	private static extern void _ActivateGameOverlayToStore(IntPtr self, AppId nAppID, OverlayToStoreFlag eFlag);

	internal void ActivateGameOverlayToStore(AppId nAppID, OverlayToStoreFlag eFlag)
	{
		_ActivateGameOverlayToStore(Self, nAppID, eFlag);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_SetPlayedWith")]
	private static extern void _SetPlayedWith(IntPtr self, SteamId steamIDUserPlayedWith);

	internal void SetPlayedWith(SteamId steamIDUserPlayedWith)
	{
		_SetPlayedWith(Self, steamIDUserPlayedWith);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialog")]
	private static extern void _ActivateGameOverlayInviteDialog(IntPtr self, SteamId steamIDLobby);

	internal void ActivateGameOverlayInviteDialog(SteamId steamIDLobby)
	{
		_ActivateGameOverlayInviteDialog(Self, steamIDLobby);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetSmallFriendAvatar")]
	private static extern int _GetSmallFriendAvatar(IntPtr self, SteamId steamIDFriend);

	internal int GetSmallFriendAvatar(SteamId steamIDFriend)
	{
		return _GetSmallFriendAvatar(Self, steamIDFriend);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetMediumFriendAvatar")]
	private static extern int _GetMediumFriendAvatar(IntPtr self, SteamId steamIDFriend);

	internal int GetMediumFriendAvatar(SteamId steamIDFriend)
	{
		return _GetMediumFriendAvatar(Self, steamIDFriend);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetLargeFriendAvatar")]
	private static extern int _GetLargeFriendAvatar(IntPtr self, SteamId steamIDFriend);

	internal int GetLargeFriendAvatar(SteamId steamIDFriend)
	{
		return _GetLargeFriendAvatar(Self, steamIDFriend);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_RequestUserInformation")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _RequestUserInformation(IntPtr self, SteamId steamIDUser, [MarshalAs(UnmanagedType.U1)] bool bRequireNameOnly);

	internal bool RequestUserInformation(SteamId steamIDUser, [MarshalAs(UnmanagedType.U1)] bool bRequireNameOnly)
	{
		return _RequestUserInformation(Self, steamIDUser, bRequireNameOnly);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_RequestClanOfficerList")]
	private static extern SteamAPICall_t _RequestClanOfficerList(IntPtr self, SteamId steamIDClan);

	internal CallResult<ClanOfficerListResponse_t> RequestClanOfficerList(SteamId steamIDClan)
	{
		return new CallResult<ClanOfficerListResponse_t>(_RequestClanOfficerList(Self, steamIDClan), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetClanOwner")]
	private static extern SteamId _GetClanOwner(IntPtr self, SteamId steamIDClan);

	internal SteamId GetClanOwner(SteamId steamIDClan)
	{
		return _GetClanOwner(Self, steamIDClan);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetClanOfficerCount")]
	private static extern int _GetClanOfficerCount(IntPtr self, SteamId steamIDClan);

	internal int GetClanOfficerCount(SteamId steamIDClan)
	{
		return _GetClanOfficerCount(Self, steamIDClan);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetClanOfficerByIndex")]
	private static extern SteamId _GetClanOfficerByIndex(IntPtr self, SteamId steamIDClan, int iOfficer);

	internal SteamId GetClanOfficerByIndex(SteamId steamIDClan, int iOfficer)
	{
		return _GetClanOfficerByIndex(Self, steamIDClan, iOfficer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetUserRestrictions")]
	private static extern uint _GetUserRestrictions(IntPtr self);

	internal uint GetUserRestrictions()
	{
		return _GetUserRestrictions(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_SetRichPresence")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetRichPresence(IntPtr self, IntPtr pchKey, IntPtr pchValue);

	internal bool SetRichPresence(string pchKey, string pchValue)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchKey);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchValue);
		return _SetRichPresence(Self, utf8StringToNative.Pointer, utf8StringToNative2.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_ClearRichPresence")]
	private static extern void _ClearRichPresence(IntPtr self);

	internal void ClearRichPresence()
	{
		_ClearRichPresence(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFriendRichPresence")]
	private static extern Utf8StringPointer _GetFriendRichPresence(IntPtr self, SteamId steamIDFriend, IntPtr pchKey);

	internal string GetFriendRichPresence(SteamId steamIDFriend, string pchKey)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchKey);
		return _GetFriendRichPresence(Self, steamIDFriend, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFriendRichPresenceKeyCount")]
	private static extern int _GetFriendRichPresenceKeyCount(IntPtr self, SteamId steamIDFriend);

	internal int GetFriendRichPresenceKeyCount(SteamId steamIDFriend)
	{
		return _GetFriendRichPresenceKeyCount(Self, steamIDFriend);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFriendRichPresenceKeyByIndex")]
	private static extern Utf8StringPointer _GetFriendRichPresenceKeyByIndex(IntPtr self, SteamId steamIDFriend, int iKey);

	internal string GetFriendRichPresenceKeyByIndex(SteamId steamIDFriend, int iKey)
	{
		return _GetFriendRichPresenceKeyByIndex(Self, steamIDFriend, iKey);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_RequestFriendRichPresence")]
	private static extern void _RequestFriendRichPresence(IntPtr self, SteamId steamIDFriend);

	internal void RequestFriendRichPresence(SteamId steamIDFriend)
	{
		_RequestFriendRichPresence(Self, steamIDFriend);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_InviteUserToGame")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _InviteUserToGame(IntPtr self, SteamId steamIDFriend, IntPtr pchConnectString);

	internal bool InviteUserToGame(SteamId steamIDFriend, string pchConnectString)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchConnectString);
		return _InviteUserToGame(Self, steamIDFriend, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetCoplayFriendCount")]
	private static extern int _GetCoplayFriendCount(IntPtr self);

	internal int GetCoplayFriendCount()
	{
		return _GetCoplayFriendCount(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetCoplayFriend")]
	private static extern SteamId _GetCoplayFriend(IntPtr self, int iCoplayFriend);

	internal SteamId GetCoplayFriend(int iCoplayFriend)
	{
		return _GetCoplayFriend(Self, iCoplayFriend);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFriendCoplayTime")]
	private static extern int _GetFriendCoplayTime(IntPtr self, SteamId steamIDFriend);

	internal int GetFriendCoplayTime(SteamId steamIDFriend)
	{
		return _GetFriendCoplayTime(Self, steamIDFriend);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFriendCoplayGame")]
	private static extern AppId _GetFriendCoplayGame(IntPtr self, SteamId steamIDFriend);

	internal AppId GetFriendCoplayGame(SteamId steamIDFriend)
	{
		return _GetFriendCoplayGame(Self, steamIDFriend);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_JoinClanChatRoom")]
	private static extern SteamAPICall_t _JoinClanChatRoom(IntPtr self, SteamId steamIDClan);

	internal CallResult<JoinClanChatRoomCompletionResult_t> JoinClanChatRoom(SteamId steamIDClan)
	{
		return new CallResult<JoinClanChatRoomCompletionResult_t>(_JoinClanChatRoom(Self, steamIDClan), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_LeaveClanChatRoom")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _LeaveClanChatRoom(IntPtr self, SteamId steamIDClan);

	internal bool LeaveClanChatRoom(SteamId steamIDClan)
	{
		return _LeaveClanChatRoom(Self, steamIDClan);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetClanChatMemberCount")]
	private static extern int _GetClanChatMemberCount(IntPtr self, SteamId steamIDClan);

	internal int GetClanChatMemberCount(SteamId steamIDClan)
	{
		return _GetClanChatMemberCount(Self, steamIDClan);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetChatMemberByIndex")]
	private static extern SteamId _GetChatMemberByIndex(IntPtr self, SteamId steamIDClan, int iUser);

	internal SteamId GetChatMemberByIndex(SteamId steamIDClan, int iUser)
	{
		return _GetChatMemberByIndex(Self, steamIDClan, iUser);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_SendClanChatMessage")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SendClanChatMessage(IntPtr self, SteamId steamIDClanChat, IntPtr pchText);

	internal bool SendClanChatMessage(SteamId steamIDClanChat, string pchText)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchText);
		return _SendClanChatMessage(Self, steamIDClanChat, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetClanChatMessage")]
	private static extern int _GetClanChatMessage(IntPtr self, SteamId steamIDClanChat, int iMessage, IntPtr prgchText, int cchTextMax, ref ChatEntryType peChatEntryType, ref SteamId psteamidChatter);

	internal int GetClanChatMessage(SteamId steamIDClanChat, int iMessage, IntPtr prgchText, int cchTextMax, ref ChatEntryType peChatEntryType, ref SteamId psteamidChatter)
	{
		return _GetClanChatMessage(Self, steamIDClanChat, iMessage, prgchText, cchTextMax, ref peChatEntryType, ref psteamidChatter);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_IsClanChatAdmin")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _IsClanChatAdmin(IntPtr self, SteamId steamIDClanChat, SteamId steamIDUser);

	internal bool IsClanChatAdmin(SteamId steamIDClanChat, SteamId steamIDUser)
	{
		return _IsClanChatAdmin(Self, steamIDClanChat, steamIDUser);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_IsClanChatWindowOpenInSteam")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _IsClanChatWindowOpenInSteam(IntPtr self, SteamId steamIDClanChat);

	internal bool IsClanChatWindowOpenInSteam(SteamId steamIDClanChat)
	{
		return _IsClanChatWindowOpenInSteam(Self, steamIDClanChat);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_OpenClanChatWindowInSteam")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _OpenClanChatWindowInSteam(IntPtr self, SteamId steamIDClanChat);

	internal bool OpenClanChatWindowInSteam(SteamId steamIDClanChat)
	{
		return _OpenClanChatWindowInSteam(Self, steamIDClanChat);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_CloseClanChatWindowInSteam")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _CloseClanChatWindowInSteam(IntPtr self, SteamId steamIDClanChat);

	internal bool CloseClanChatWindowInSteam(SteamId steamIDClanChat)
	{
		return _CloseClanChatWindowInSteam(Self, steamIDClanChat);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_SetListenForFriendsMessages")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetListenForFriendsMessages(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bInterceptEnabled);

	internal bool SetListenForFriendsMessages([MarshalAs(UnmanagedType.U1)] bool bInterceptEnabled)
	{
		return _SetListenForFriendsMessages(Self, bInterceptEnabled);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_ReplyToFriendMessage")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _ReplyToFriendMessage(IntPtr self, SteamId steamIDFriend, IntPtr pchMsgToSend);

	internal bool ReplyToFriendMessage(SteamId steamIDFriend, string pchMsgToSend)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchMsgToSend);
		return _ReplyToFriendMessage(Self, steamIDFriend, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFriendMessage")]
	private static extern int _GetFriendMessage(IntPtr self, SteamId steamIDFriend, int iMessageID, IntPtr pvData, int cubData, ref ChatEntryType peChatEntryType);

	internal int GetFriendMessage(SteamId steamIDFriend, int iMessageID, IntPtr pvData, int cubData, ref ChatEntryType peChatEntryType)
	{
		return _GetFriendMessage(Self, steamIDFriend, iMessageID, pvData, cubData, ref peChatEntryType);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetFollowerCount")]
	private static extern SteamAPICall_t _GetFollowerCount(IntPtr self, SteamId steamID);

	internal CallResult<FriendsGetFollowerCount_t> GetFollowerCount(SteamId steamID)
	{
		return new CallResult<FriendsGetFollowerCount_t>(_GetFollowerCount(Self, steamID), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_IsFollowing")]
	private static extern SteamAPICall_t _IsFollowing(IntPtr self, SteamId steamID);

	internal CallResult<FriendsIsFollowing_t> IsFollowing(SteamId steamID)
	{
		return new CallResult<FriendsIsFollowing_t>(_IsFollowing(Self, steamID), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_EnumerateFollowingList")]
	private static extern SteamAPICall_t _EnumerateFollowingList(IntPtr self, uint unStartIndex);

	internal CallResult<FriendsEnumerateFollowingList_t> EnumerateFollowingList(uint unStartIndex)
	{
		return new CallResult<FriendsEnumerateFollowingList_t>(_EnumerateFollowingList(Self, unStartIndex), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_IsClanPublic")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _IsClanPublic(IntPtr self, SteamId steamIDClan);

	internal bool IsClanPublic(SteamId steamIDClan)
	{
		return _IsClanPublic(Self, steamIDClan);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_IsClanOfficialGameGroup")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _IsClanOfficialGameGroup(IntPtr self, SteamId steamIDClan);

	internal bool IsClanOfficialGameGroup(SteamId steamIDClan)
	{
		return _IsClanOfficialGameGroup(Self, steamIDClan);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetNumChatsWithUnreadPriorityMessages")]
	private static extern int _GetNumChatsWithUnreadPriorityMessages(IntPtr self);

	internal int GetNumChatsWithUnreadPriorityMessages()
	{
		return _GetNumChatsWithUnreadPriorityMessages(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_ActivateGameOverlayRemotePlayTogetherInviteDialog")]
	private static extern void _ActivateGameOverlayRemotePlayTogetherInviteDialog(IntPtr self, SteamId steamIDLobby);

	internal void ActivateGameOverlayRemotePlayTogetherInviteDialog(SteamId steamIDLobby)
	{
		_ActivateGameOverlayRemotePlayTogetherInviteDialog(Self, steamIDLobby);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_RegisterProtocolInOverlayBrowser")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _RegisterProtocolInOverlayBrowser(IntPtr self, IntPtr pchProtocol);

	internal bool RegisterProtocolInOverlayBrowser(string pchProtocol)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchProtocol);
		return _RegisterProtocolInOverlayBrowser(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialogConnectString")]
	private static extern void _ActivateGameOverlayInviteDialogConnectString(IntPtr self, IntPtr pchConnectString);

	internal void ActivateGameOverlayInviteDialogConnectString(string pchConnectString)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchConnectString);
		_ActivateGameOverlayInviteDialogConnectString(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_RequestEquippedProfileItems")]
	private static extern SteamAPICall_t _RequestEquippedProfileItems(IntPtr self, SteamId steamID);

	internal CallResult<EquippedProfileItems_t> RequestEquippedProfileItems(SteamId steamID)
	{
		return new CallResult<EquippedProfileItems_t>(_RequestEquippedProfileItems(Self, steamID), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_BHasEquippedProfileItem")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BHasEquippedProfileItem(IntPtr self, SteamId steamID, CommunityProfileItemType itemType);

	internal bool BHasEquippedProfileItem(SteamId steamID, CommunityProfileItemType itemType)
	{
		return _BHasEquippedProfileItem(Self, steamID, itemType);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetProfileItemPropertyString")]
	private static extern Utf8StringPointer _GetProfileItemPropertyString(IntPtr self, SteamId steamID, CommunityProfileItemType itemType, CommunityProfileItemProperty prop);

	internal string GetProfileItemPropertyString(SteamId steamID, CommunityProfileItemType itemType, CommunityProfileItemProperty prop)
	{
		return _GetProfileItemPropertyString(Self, steamID, itemType, prop);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamFriends_GetProfileItemPropertyUint")]
	private static extern uint _GetProfileItemPropertyUint(IntPtr self, SteamId steamID, CommunityProfileItemType itemType, CommunityProfileItemProperty prop);

	internal uint GetProfileItemPropertyUint(SteamId steamID, CommunityProfileItemType itemType, CommunityProfileItemProperty prop)
	{
		return _GetProfileItemPropertyUint(Self, steamID, itemType, prop);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;

internal class ISteamGameSearch : SteamInterface
{
	public const string Version = "SteamMatchGameSearch001";

	internal ISteamGameSearch(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamGameSearch_v001();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamGameSearch_v001();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameSearch_AddGameSearchParams")]
	private static extern GameSearchErrorCode_t _AddGameSearchParams(IntPtr self, IntPtr pchKeyToFind, IntPtr pchValuesToFind);

	internal GameSearchErrorCode_t AddGameSearchParams(string pchKeyToFind, string pchValuesToFind)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchKeyToFind);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchValuesToFind);
		return _AddGameSearchParams(Self, utf8StringToNative.Pointer, utf8StringToNative2.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameSearch_SearchForGameWithLobby")]
	private static extern GameSearchErrorCode_t _SearchForGameWithLobby(IntPtr self, SteamId steamIDLobby, int nPlayerMin, int nPlayerMax);

	internal GameSearchErrorCode_t SearchForGameWithLobby(SteamId steamIDLobby, int nPlayerMin, int nPlayerMax)
	{
		return _SearchForGameWithLobby(Self, steamIDLobby, nPlayerMin, nPlayerMax);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameSearch_SearchForGameSolo")]
	private static extern GameSearchErrorCode_t _SearchForGameSolo(IntPtr self, int nPlayerMin, int nPlayerMax);

	internal GameSearchErrorCode_t SearchForGameSolo(int nPlayerMin, int nPlayerMax)
	{
		return _SearchForGameSolo(Self, nPlayerMin, nPlayerMax);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameSearch_AcceptGame")]
	private static extern GameSearchErrorCode_t _AcceptGame(IntPtr self);

	internal GameSearchErrorCode_t AcceptGame()
	{
		return _AcceptGame(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameSearch_DeclineGame")]
	private static extern GameSearchErrorCode_t _DeclineGame(IntPtr self);

	internal GameSearchErrorCode_t DeclineGame()
	{
		return _DeclineGame(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameSearch_RetrieveConnectionDetails")]
	private static extern GameSearchErrorCode_t _RetrieveConnectionDetails(IntPtr self, SteamId steamIDHost, IntPtr pchConnectionDetails, int cubConnectionDetails);

	internal GameSearchErrorCode_t RetrieveConnectionDetails(SteamId steamIDHost, out string pchConnectionDetails)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			GameSearchErrorCode_t result = _RetrieveConnectionDetails(Self, steamIDHost, m, 32768);
			pchConnectionDetails = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameSearch_EndGameSearch")]
	private static extern GameSearchErrorCode_t _EndGameSearch(IntPtr self);

	internal GameSearchErrorCode_t EndGameSearch()
	{
		return _EndGameSearch(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameSearch_SetGameHostParams")]
	private static extern GameSearchErrorCode_t _SetGameHostParams(IntPtr self, IntPtr pchKey, IntPtr pchValue);

	internal GameSearchErrorCode_t SetGameHostParams(string pchKey, string pchValue)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchKey);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchValue);
		return _SetGameHostParams(Self, utf8StringToNative.Pointer, utf8StringToNative2.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameSearch_SetConnectionDetails")]
	private static extern GameSearchErrorCode_t _SetConnectionDetails(IntPtr self, IntPtr pchConnectionDetails, int cubConnectionDetails);

	internal GameSearchErrorCode_t SetConnectionDetails(string pchConnectionDetails, int cubConnectionDetails)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchConnectionDetails);
		return _SetConnectionDetails(Self, utf8StringToNative.Pointer, cubConnectionDetails);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameSearch_RequestPlayersForGame")]
	private static extern GameSearchErrorCode_t _RequestPlayersForGame(IntPtr self, int nPlayerMin, int nPlayerMax, int nMaxTeamSize);

	internal GameSearchErrorCode_t RequestPlayersForGame(int nPlayerMin, int nPlayerMax, int nMaxTeamSize)
	{
		return _RequestPlayersForGame(Self, nPlayerMin, nPlayerMax, nMaxTeamSize);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameSearch_HostConfirmGameStart")]
	private static extern GameSearchErrorCode_t _HostConfirmGameStart(IntPtr self, ulong ullUniqueGameID);

	internal GameSearchErrorCode_t HostConfirmGameStart(ulong ullUniqueGameID)
	{
		return _HostConfirmGameStart(Self, ullUniqueGameID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameSearch_CancelRequestPlayersForGame")]
	private static extern GameSearchErrorCode_t _CancelRequestPlayersForGame(IntPtr self);

	internal GameSearchErrorCode_t CancelRequestPlayersForGame()
	{
		return _CancelRequestPlayersForGame(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameSearch_SubmitPlayerResult")]
	private static extern GameSearchErrorCode_t _SubmitPlayerResult(IntPtr self, ulong ullUniqueGameID, SteamId steamIDPlayer, PlayerResult_t EPlayerResult);

	internal GameSearchErrorCode_t SubmitPlayerResult(ulong ullUniqueGameID, SteamId steamIDPlayer, PlayerResult_t EPlayerResult)
	{
		return _SubmitPlayerResult(Self, ullUniqueGameID, steamIDPlayer, EPlayerResult);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameSearch_EndGame")]
	private static extern GameSearchErrorCode_t _EndGame(IntPtr self, ulong ullUniqueGameID);

	internal GameSearchErrorCode_t EndGame(ulong ullUniqueGameID)
	{
		return _EndGame(Self, ullUniqueGameID);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamGameServer : SteamInterface
{
	public const string Version = "SteamGameServer015";

	internal ISteamGameServer(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamGameServer_v015();

	public override IntPtr GetServerInterfacePointer()
	{
		return SteamAPI_SteamGameServer_v015();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_SetProduct")]
	private static extern void _SetProduct(IntPtr self, IntPtr pszProduct);

	internal void SetProduct(string pszProduct)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszProduct);
		_SetProduct(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_SetGameDescription")]
	private static extern void _SetGameDescription(IntPtr self, IntPtr pszGameDescription);

	internal void SetGameDescription(string pszGameDescription)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszGameDescription);
		_SetGameDescription(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_SetModDir")]
	private static extern void _SetModDir(IntPtr self, IntPtr pszModDir);

	internal void SetModDir(string pszModDir)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszModDir);
		_SetModDir(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_SetDedicatedServer")]
	private static extern void _SetDedicatedServer(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bDedicated);

	internal void SetDedicatedServer([MarshalAs(UnmanagedType.U1)] bool bDedicated)
	{
		_SetDedicatedServer(Self, bDedicated);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_LogOn")]
	private static extern void _LogOn(IntPtr self, IntPtr pszToken);

	internal void LogOn(string pszToken)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszToken);
		_LogOn(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_LogOnAnonymous")]
	private static extern void _LogOnAnonymous(IntPtr self);

	internal void LogOnAnonymous()
	{
		_LogOnAnonymous(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_LogOff")]
	private static extern void _LogOff(IntPtr self);

	internal void LogOff()
	{
		_LogOff(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_BLoggedOn")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BLoggedOn(IntPtr self);

	internal bool BLoggedOn()
	{
		return _BLoggedOn(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_BSecure")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BSecure(IntPtr self);

	internal bool BSecure()
	{
		return _BSecure(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_GetSteamID")]
	private static extern SteamId _GetSteamID(IntPtr self);

	internal SteamId GetSteamID()
	{
		return _GetSteamID(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_WasRestartRequested")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _WasRestartRequested(IntPtr self);

	internal bool WasRestartRequested()
	{
		return _WasRestartRequested(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_SetMaxPlayerCount")]
	private static extern void _SetMaxPlayerCount(IntPtr self, int cPlayersMax);

	internal void SetMaxPlayerCount(int cPlayersMax)
	{
		_SetMaxPlayerCount(Self, cPlayersMax);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_SetBotPlayerCount")]
	private static extern void _SetBotPlayerCount(IntPtr self, int cBotplayers);

	internal void SetBotPlayerCount(int cBotplayers)
	{
		_SetBotPlayerCount(Self, cBotplayers);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_SetServerName")]
	private static extern void _SetServerName(IntPtr self, IntPtr pszServerName);

	internal void SetServerName(string pszServerName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszServerName);
		_SetServerName(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_SetMapName")]
	private static extern void _SetMapName(IntPtr self, IntPtr pszMapName);

	internal void SetMapName(string pszMapName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszMapName);
		_SetMapName(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_SetPasswordProtected")]
	private static extern void _SetPasswordProtected(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bPasswordProtected);

	internal void SetPasswordProtected([MarshalAs(UnmanagedType.U1)] bool bPasswordProtected)
	{
		_SetPasswordProtected(Self, bPasswordProtected);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_SetSpectatorPort")]
	private static extern void _SetSpectatorPort(IntPtr self, ushort unSpectatorPort);

	internal void SetSpectatorPort(ushort unSpectatorPort)
	{
		_SetSpectatorPort(Self, unSpectatorPort);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_SetSpectatorServerName")]
	private static extern void _SetSpectatorServerName(IntPtr self, IntPtr pszSpectatorServerName);

	internal void SetSpectatorServerName(string pszSpectatorServerName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszSpectatorServerName);
		_SetSpectatorServerName(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_ClearAllKeyValues")]
	private static extern void _ClearAllKeyValues(IntPtr self);

	internal void ClearAllKeyValues()
	{
		_ClearAllKeyValues(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_SetKeyValue")]
	private static extern void _SetKeyValue(IntPtr self, IntPtr pKey, IntPtr pValue);

	internal void SetKeyValue(string pKey, string pValue)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pKey);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pValue);
		_SetKeyValue(Self, utf8StringToNative.Pointer, utf8StringToNative2.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_SetGameTags")]
	private static extern void _SetGameTags(IntPtr self, IntPtr pchGameTags);

	internal void SetGameTags(string pchGameTags)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchGameTags);
		_SetGameTags(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_SetGameData")]
	private static extern void _SetGameData(IntPtr self, IntPtr pchGameData);

	internal void SetGameData(string pchGameData)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchGameData);
		_SetGameData(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_SetRegion")]
	private static extern void _SetRegion(IntPtr self, IntPtr pszRegion);

	internal void SetRegion(string pszRegion)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszRegion);
		_SetRegion(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_SetAdvertiseServerActive")]
	private static extern void _SetAdvertiseServerActive(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bActive);

	internal void SetAdvertiseServerActive([MarshalAs(UnmanagedType.U1)] bool bActive)
	{
		_SetAdvertiseServerActive(Self, bActive);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_GetAuthSessionTicket")]
	private static extern HAuthTicket _GetAuthSessionTicket(IntPtr self, IntPtr pTicket, int cbMaxTicket, ref uint pcbTicket, ref NetIdentity pSnid);

	internal HAuthTicket GetAuthSessionTicket(IntPtr pTicket, int cbMaxTicket, ref uint pcbTicket, ref NetIdentity pSnid)
	{
		return _GetAuthSessionTicket(Self, pTicket, cbMaxTicket, ref pcbTicket, ref pSnid);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_BeginAuthSession")]
	private static extern BeginAuthResult _BeginAuthSession(IntPtr self, IntPtr pAuthTicket, int cbAuthTicket, SteamId steamID);

	internal BeginAuthResult BeginAuthSession(IntPtr pAuthTicket, int cbAuthTicket, SteamId steamID)
	{
		return _BeginAuthSession(Self, pAuthTicket, cbAuthTicket, steamID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_EndAuthSession")]
	private static extern void _EndAuthSession(IntPtr self, SteamId steamID);

	internal void EndAuthSession(SteamId steamID)
	{
		_EndAuthSession(Self, steamID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_CancelAuthTicket")]
	private static extern void _CancelAuthTicket(IntPtr self, HAuthTicket hAuthTicket);

	internal void CancelAuthTicket(HAuthTicket hAuthTicket)
	{
		_CancelAuthTicket(Self, hAuthTicket);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_UserHasLicenseForApp")]
	private static extern UserHasLicenseForAppResult _UserHasLicenseForApp(IntPtr self, SteamId steamID, AppId appID);

	internal UserHasLicenseForAppResult UserHasLicenseForApp(SteamId steamID, AppId appID)
	{
		return _UserHasLicenseForApp(Self, steamID, appID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_RequestUserGroupStatus")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _RequestUserGroupStatus(IntPtr self, SteamId steamIDUser, SteamId steamIDGroup);

	internal bool RequestUserGroupStatus(SteamId steamIDUser, SteamId steamIDGroup)
	{
		return _RequestUserGroupStatus(Self, steamIDUser, steamIDGroup);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_GetGameplayStats")]
	private static extern void _GetGameplayStats(IntPtr self);

	internal void GetGameplayStats()
	{
		_GetGameplayStats(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_GetServerReputation")]
	private static extern SteamAPICall_t _GetServerReputation(IntPtr self);

	internal CallResult<GSReputation_t> GetServerReputation()
	{
		return new CallResult<GSReputation_t>(_GetServerReputation(Self), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_GetPublicIP")]
	private static extern SteamIPAddress _GetPublicIP(IntPtr self);

	internal SteamIPAddress GetPublicIP()
	{
		return _GetPublicIP(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_HandleIncomingPacket")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _HandleIncomingPacket(IntPtr self, IntPtr pData, int cbData, uint srcIP, ushort srcPort);

	internal bool HandleIncomingPacket(IntPtr pData, int cbData, uint srcIP, ushort srcPort)
	{
		return _HandleIncomingPacket(Self, pData, cbData, srcIP, srcPort);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_GetNextOutgoingPacket")]
	private static extern int _GetNextOutgoingPacket(IntPtr self, IntPtr pOut, int cbMaxOut, ref uint pNetAdr, ref ushort pPort);

	internal int GetNextOutgoingPacket(IntPtr pOut, int cbMaxOut, ref uint pNetAdr, ref ushort pPort)
	{
		return _GetNextOutgoingPacket(Self, pOut, cbMaxOut, ref pNetAdr, ref pPort);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_AssociateWithClan")]
	private static extern SteamAPICall_t _AssociateWithClan(IntPtr self, SteamId steamIDClan);

	internal CallResult<AssociateWithClanResult_t> AssociateWithClan(SteamId steamIDClan)
	{
		return new CallResult<AssociateWithClanResult_t>(_AssociateWithClan(Self, steamIDClan), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_ComputeNewPlayerCompatibility")]
	private static extern SteamAPICall_t _ComputeNewPlayerCompatibility(IntPtr self, SteamId steamIDNewPlayer);

	internal CallResult<ComputeNewPlayerCompatibilityResult_t> ComputeNewPlayerCompatibility(SteamId steamIDNewPlayer)
	{
		return new CallResult<ComputeNewPlayerCompatibilityResult_t>(_ComputeNewPlayerCompatibility(Self, steamIDNewPlayer), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_SendUserConnectAndAuthenticate_DEPRECATED")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SendUserConnectAndAuthenticate_DEPRECATED(IntPtr self, uint unIPClient, IntPtr pvAuthBlob, uint cubAuthBlobSize, ref SteamId pSteamIDUser);

	internal bool SendUserConnectAndAuthenticate_DEPRECATED(uint unIPClient, IntPtr pvAuthBlob, uint cubAuthBlobSize, ref SteamId pSteamIDUser)
	{
		return _SendUserConnectAndAuthenticate_DEPRECATED(Self, unIPClient, pvAuthBlob, cubAuthBlobSize, ref pSteamIDUser);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_CreateUnauthenticatedUserConnection")]
	private static extern SteamId _CreateUnauthenticatedUserConnection(IntPtr self);

	internal SteamId CreateUnauthenticatedUserConnection()
	{
		return _CreateUnauthenticatedUserConnection(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_SendUserDisconnect_DEPRECATED")]
	private static extern void _SendUserDisconnect_DEPRECATED(IntPtr self, SteamId steamIDUser);

	internal void SendUserDisconnect_DEPRECATED(SteamId steamIDUser)
	{
		_SendUserDisconnect_DEPRECATED(Self, steamIDUser);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServer_BUpdateUserData")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BUpdateUserData(IntPtr self, SteamId steamIDUser, IntPtr pchPlayerName, uint uScore);

	internal bool BUpdateUserData(SteamId steamIDUser, string pchPlayerName, uint uScore)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchPlayerName);
		return _BUpdateUserData(Self, steamIDUser, utf8StringToNative.Pointer, uScore);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamGameServerStats : SteamInterface
{
	public const string Version = "SteamGameServerStats001";

	internal ISteamGameServerStats(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamGameServerStats_v001();

	public override IntPtr GetServerInterfacePointer()
	{
		return SteamAPI_SteamGameServerStats_v001();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServerStats_RequestUserStats")]
	private static extern SteamAPICall_t _RequestUserStats(IntPtr self, SteamId steamIDUser);

	internal CallResult<GSStatsReceived_t> RequestUserStats(SteamId steamIDUser)
	{
		return new CallResult<GSStatsReceived_t>(_RequestUserStats(Self, steamIDUser), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServerStats_GetUserStatInt32")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetUserStat(IntPtr self, SteamId steamIDUser, IntPtr pchName, ref int pData);

	internal bool GetUserStat(SteamId steamIDUser, string pchName, ref int pData)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _GetUserStat(Self, steamIDUser, utf8StringToNative.Pointer, ref pData);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServerStats_GetUserStatFloat")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetUserStat(IntPtr self, SteamId steamIDUser, IntPtr pchName, ref float pData);

	internal bool GetUserStat(SteamId steamIDUser, string pchName, ref float pData)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _GetUserStat(Self, steamIDUser, utf8StringToNative.Pointer, ref pData);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServerStats_GetUserAchievement")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetUserAchievement(IntPtr self, SteamId steamIDUser, IntPtr pchName, [MarshalAs(UnmanagedType.U1)] ref bool pbAchieved);

	internal bool GetUserAchievement(SteamId steamIDUser, string pchName, [MarshalAs(UnmanagedType.U1)] ref bool pbAchieved)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _GetUserAchievement(Self, steamIDUser, utf8StringToNative.Pointer, ref pbAchieved);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServerStats_SetUserStatInt32")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetUserStat(IntPtr self, SteamId steamIDUser, IntPtr pchName, int nData);

	internal bool SetUserStat(SteamId steamIDUser, string pchName, int nData)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _SetUserStat(Self, steamIDUser, utf8StringToNative.Pointer, nData);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServerStats_SetUserStatFloat")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetUserStat(IntPtr self, SteamId steamIDUser, IntPtr pchName, float fData);

	internal bool SetUserStat(SteamId steamIDUser, string pchName, float fData)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _SetUserStat(Self, steamIDUser, utf8StringToNative.Pointer, fData);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServerStats_UpdateUserAvgRateStat")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _UpdateUserAvgRateStat(IntPtr self, SteamId steamIDUser, IntPtr pchName, float flCountThisSession, double dSessionLength);

	internal bool UpdateUserAvgRateStat(SteamId steamIDUser, string pchName, float flCountThisSession, double dSessionLength)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _UpdateUserAvgRateStat(Self, steamIDUser, utf8StringToNative.Pointer, flCountThisSession, dSessionLength);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServerStats_SetUserAchievement")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetUserAchievement(IntPtr self, SteamId steamIDUser, IntPtr pchName);

	internal bool SetUserAchievement(SteamId steamIDUser, string pchName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _SetUserAchievement(Self, steamIDUser, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServerStats_ClearUserAchievement")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _ClearUserAchievement(IntPtr self, SteamId steamIDUser, IntPtr pchName);

	internal bool ClearUserAchievement(SteamId steamIDUser, string pchName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _ClearUserAchievement(Self, steamIDUser, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamGameServerStats_StoreUserStats")]
	private static extern SteamAPICall_t _StoreUserStats(IntPtr self, SteamId steamIDUser);

	internal CallResult<GSStatsStored_t> StoreUserStats(SteamId steamIDUser)
	{
		return new CallResult<GSStatsStored_t>(_StoreUserStats(Self, steamIDUser), base.IsServer);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamHTMLSurface : SteamInterface
{
	public const string Version = "STEAMHTMLSURFACE_INTERFACE_VERSION_005";

	internal ISteamHTMLSurface(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamHTMLSurface_v005();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamHTMLSurface_v005();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_Init")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _Init(IntPtr self);

	internal bool Init()
	{
		return _Init(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_Shutdown")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _Shutdown(IntPtr self);

	internal bool Shutdown()
	{
		return _Shutdown(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_CreateBrowser")]
	private static extern SteamAPICall_t _CreateBrowser(IntPtr self, IntPtr pchUserAgent, IntPtr pchUserCSS);

	internal CallResult<HTML_BrowserReady_t> CreateBrowser(string pchUserAgent, string pchUserCSS)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchUserAgent);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchUserCSS);
		return new CallResult<HTML_BrowserReady_t>(_CreateBrowser(Self, utf8StringToNative.Pointer, utf8StringToNative2.Pointer), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_RemoveBrowser")]
	private static extern void _RemoveBrowser(IntPtr self, HHTMLBrowser unBrowserHandle);

	internal void RemoveBrowser(HHTMLBrowser unBrowserHandle)
	{
		_RemoveBrowser(Self, unBrowserHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_LoadURL")]
	private static extern void _LoadURL(IntPtr self, HHTMLBrowser unBrowserHandle, IntPtr pchURL, IntPtr pchPostData);

	internal void LoadURL(HHTMLBrowser unBrowserHandle, string pchURL, string pchPostData)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchURL);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchPostData);
		_LoadURL(Self, unBrowserHandle, utf8StringToNative.Pointer, utf8StringToNative2.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_SetSize")]
	private static extern void _SetSize(IntPtr self, HHTMLBrowser unBrowserHandle, uint unWidth, uint unHeight);

	internal void SetSize(HHTMLBrowser unBrowserHandle, uint unWidth, uint unHeight)
	{
		_SetSize(Self, unBrowserHandle, unWidth, unHeight);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_StopLoad")]
	private static extern void _StopLoad(IntPtr self, HHTMLBrowser unBrowserHandle);

	internal void StopLoad(HHTMLBrowser unBrowserHandle)
	{
		_StopLoad(Self, unBrowserHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_Reload")]
	private static extern void _Reload(IntPtr self, HHTMLBrowser unBrowserHandle);

	internal void Reload(HHTMLBrowser unBrowserHandle)
	{
		_Reload(Self, unBrowserHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_GoBack")]
	private static extern void _GoBack(IntPtr self, HHTMLBrowser unBrowserHandle);

	internal void GoBack(HHTMLBrowser unBrowserHandle)
	{
		_GoBack(Self, unBrowserHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_GoForward")]
	private static extern void _GoForward(IntPtr self, HHTMLBrowser unBrowserHandle);

	internal void GoForward(HHTMLBrowser unBrowserHandle)
	{
		_GoForward(Self, unBrowserHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_AddHeader")]
	private static extern void _AddHeader(IntPtr self, HHTMLBrowser unBrowserHandle, IntPtr pchKey, IntPtr pchValue);

	internal void AddHeader(HHTMLBrowser unBrowserHandle, string pchKey, string pchValue)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchKey);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchValue);
		_AddHeader(Self, unBrowserHandle, utf8StringToNative.Pointer, utf8StringToNative2.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_ExecuteJavascript")]
	private static extern void _ExecuteJavascript(IntPtr self, HHTMLBrowser unBrowserHandle, IntPtr pchScript);

	internal void ExecuteJavascript(HHTMLBrowser unBrowserHandle, string pchScript)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchScript);
		_ExecuteJavascript(Self, unBrowserHandle, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_MouseUp")]
	private static extern void _MouseUp(IntPtr self, HHTMLBrowser unBrowserHandle, IntPtr eMouseButton);

	internal void MouseUp(HHTMLBrowser unBrowserHandle, IntPtr eMouseButton)
	{
		_MouseUp(Self, unBrowserHandle, eMouseButton);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_MouseDown")]
	private static extern void _MouseDown(IntPtr self, HHTMLBrowser unBrowserHandle, IntPtr eMouseButton);

	internal void MouseDown(HHTMLBrowser unBrowserHandle, IntPtr eMouseButton)
	{
		_MouseDown(Self, unBrowserHandle, eMouseButton);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_MouseDoubleClick")]
	private static extern void _MouseDoubleClick(IntPtr self, HHTMLBrowser unBrowserHandle, IntPtr eMouseButton);

	internal void MouseDoubleClick(HHTMLBrowser unBrowserHandle, IntPtr eMouseButton)
	{
		_MouseDoubleClick(Self, unBrowserHandle, eMouseButton);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_MouseMove")]
	private static extern void _MouseMove(IntPtr self, HHTMLBrowser unBrowserHandle, int x, int y);

	internal void MouseMove(HHTMLBrowser unBrowserHandle, int x, int y)
	{
		_MouseMove(Self, unBrowserHandle, x, y);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_MouseWheel")]
	private static extern void _MouseWheel(IntPtr self, HHTMLBrowser unBrowserHandle, int nDelta);

	internal void MouseWheel(HHTMLBrowser unBrowserHandle, int nDelta)
	{
		_MouseWheel(Self, unBrowserHandle, nDelta);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_KeyDown")]
	private static extern void _KeyDown(IntPtr self, HHTMLBrowser unBrowserHandle, uint nNativeKeyCode, IntPtr eHTMLKeyModifiers, [MarshalAs(UnmanagedType.U1)] bool bIsSystemKey);

	internal void KeyDown(HHTMLBrowser unBrowserHandle, uint nNativeKeyCode, IntPtr eHTMLKeyModifiers, [MarshalAs(UnmanagedType.U1)] bool bIsSystemKey)
	{
		_KeyDown(Self, unBrowserHandle, nNativeKeyCode, eHTMLKeyModifiers, bIsSystemKey);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_KeyUp")]
	private static extern void _KeyUp(IntPtr self, HHTMLBrowser unBrowserHandle, uint nNativeKeyCode, IntPtr eHTMLKeyModifiers);

	internal void KeyUp(HHTMLBrowser unBrowserHandle, uint nNativeKeyCode, IntPtr eHTMLKeyModifiers)
	{
		_KeyUp(Self, unBrowserHandle, nNativeKeyCode, eHTMLKeyModifiers);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_KeyChar")]
	private static extern void _KeyChar(IntPtr self, HHTMLBrowser unBrowserHandle, uint cUnicodeChar, IntPtr eHTMLKeyModifiers);

	internal void KeyChar(HHTMLBrowser unBrowserHandle, uint cUnicodeChar, IntPtr eHTMLKeyModifiers)
	{
		_KeyChar(Self, unBrowserHandle, cUnicodeChar, eHTMLKeyModifiers);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_SetHorizontalScroll")]
	private static extern void _SetHorizontalScroll(IntPtr self, HHTMLBrowser unBrowserHandle, uint nAbsolutePixelScroll);

	internal void SetHorizontalScroll(HHTMLBrowser unBrowserHandle, uint nAbsolutePixelScroll)
	{
		_SetHorizontalScroll(Self, unBrowserHandle, nAbsolutePixelScroll);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_SetVerticalScroll")]
	private static extern void _SetVerticalScroll(IntPtr self, HHTMLBrowser unBrowserHandle, uint nAbsolutePixelScroll);

	internal void SetVerticalScroll(HHTMLBrowser unBrowserHandle, uint nAbsolutePixelScroll)
	{
		_SetVerticalScroll(Self, unBrowserHandle, nAbsolutePixelScroll);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_SetKeyFocus")]
	private static extern void _SetKeyFocus(IntPtr self, HHTMLBrowser unBrowserHandle, [MarshalAs(UnmanagedType.U1)] bool bHasKeyFocus);

	internal void SetKeyFocus(HHTMLBrowser unBrowserHandle, [MarshalAs(UnmanagedType.U1)] bool bHasKeyFocus)
	{
		_SetKeyFocus(Self, unBrowserHandle, bHasKeyFocus);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_ViewSource")]
	private static extern void _ViewSource(IntPtr self, HHTMLBrowser unBrowserHandle);

	internal void ViewSource(HHTMLBrowser unBrowserHandle)
	{
		_ViewSource(Self, unBrowserHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_CopyToClipboard")]
	private static extern void _CopyToClipboard(IntPtr self, HHTMLBrowser unBrowserHandle);

	internal void CopyToClipboard(HHTMLBrowser unBrowserHandle)
	{
		_CopyToClipboard(Self, unBrowserHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_PasteFromClipboard")]
	private static extern void _PasteFromClipboard(IntPtr self, HHTMLBrowser unBrowserHandle);

	internal void PasteFromClipboard(HHTMLBrowser unBrowserHandle)
	{
		_PasteFromClipboard(Self, unBrowserHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_Find")]
	private static extern void _Find(IntPtr self, HHTMLBrowser unBrowserHandle, IntPtr pchSearchStr, [MarshalAs(UnmanagedType.U1)] bool bCurrentlyInFind, [MarshalAs(UnmanagedType.U1)] bool bReverse);

	internal void Find(HHTMLBrowser unBrowserHandle, string pchSearchStr, [MarshalAs(UnmanagedType.U1)] bool bCurrentlyInFind, [MarshalAs(UnmanagedType.U1)] bool bReverse)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchSearchStr);
		_Find(Self, unBrowserHandle, utf8StringToNative.Pointer, bCurrentlyInFind, bReverse);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_StopFind")]
	private static extern void _StopFind(IntPtr self, HHTMLBrowser unBrowserHandle);

	internal void StopFind(HHTMLBrowser unBrowserHandle)
	{
		_StopFind(Self, unBrowserHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_GetLinkAtPosition")]
	private static extern void _GetLinkAtPosition(IntPtr self, HHTMLBrowser unBrowserHandle, int x, int y);

	internal void GetLinkAtPosition(HHTMLBrowser unBrowserHandle, int x, int y)
	{
		_GetLinkAtPosition(Self, unBrowserHandle, x, y);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_SetCookie")]
	private static extern void _SetCookie(IntPtr self, IntPtr pchHostname, IntPtr pchKey, IntPtr pchValue, IntPtr pchPath, RTime32 nExpires, [MarshalAs(UnmanagedType.U1)] bool bSecure, [MarshalAs(UnmanagedType.U1)] bool bHTTPOnly);

	internal void SetCookie(string pchHostname, string pchKey, string pchValue, string pchPath, RTime32 nExpires, [MarshalAs(UnmanagedType.U1)] bool bSecure, [MarshalAs(UnmanagedType.U1)] bool bHTTPOnly)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchHostname);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchKey);
		using Utf8StringToNative utf8StringToNative3 = new Utf8StringToNative(pchValue);
		using Utf8StringToNative utf8StringToNative4 = new Utf8StringToNative(pchPath);
		_SetCookie(Self, utf8StringToNative.Pointer, utf8StringToNative2.Pointer, utf8StringToNative3.Pointer, utf8StringToNative4.Pointer, nExpires, bSecure, bHTTPOnly);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_SetPageScaleFactor")]
	private static extern void _SetPageScaleFactor(IntPtr self, HHTMLBrowser unBrowserHandle, float flZoom, int nPointX, int nPointY);

	internal void SetPageScaleFactor(HHTMLBrowser unBrowserHandle, float flZoom, int nPointX, int nPointY)
	{
		_SetPageScaleFactor(Self, unBrowserHandle, flZoom, nPointX, nPointY);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_SetBackgroundMode")]
	private static extern void _SetBackgroundMode(IntPtr self, HHTMLBrowser unBrowserHandle, [MarshalAs(UnmanagedType.U1)] bool bBackgroundMode);

	internal void SetBackgroundMode(HHTMLBrowser unBrowserHandle, [MarshalAs(UnmanagedType.U1)] bool bBackgroundMode)
	{
		_SetBackgroundMode(Self, unBrowserHandle, bBackgroundMode);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_SetDPIScalingFactor")]
	private static extern void _SetDPIScalingFactor(IntPtr self, HHTMLBrowser unBrowserHandle, float flDPIScaling);

	internal void SetDPIScalingFactor(HHTMLBrowser unBrowserHandle, float flDPIScaling)
	{
		_SetDPIScalingFactor(Self, unBrowserHandle, flDPIScaling);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_OpenDeveloperTools")]
	private static extern void _OpenDeveloperTools(IntPtr self, HHTMLBrowser unBrowserHandle);

	internal void OpenDeveloperTools(HHTMLBrowser unBrowserHandle)
	{
		_OpenDeveloperTools(Self, unBrowserHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_AllowStartRequest")]
	private static extern void _AllowStartRequest(IntPtr self, HHTMLBrowser unBrowserHandle, [MarshalAs(UnmanagedType.U1)] bool bAllowed);

	internal void AllowStartRequest(HHTMLBrowser unBrowserHandle, [MarshalAs(UnmanagedType.U1)] bool bAllowed)
	{
		_AllowStartRequest(Self, unBrowserHandle, bAllowed);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_JSDialogResponse")]
	private static extern void _JSDialogResponse(IntPtr self, HHTMLBrowser unBrowserHandle, [MarshalAs(UnmanagedType.U1)] bool bResult);

	internal void JSDialogResponse(HHTMLBrowser unBrowserHandle, [MarshalAs(UnmanagedType.U1)] bool bResult)
	{
		_JSDialogResponse(Self, unBrowserHandle, bResult);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTMLSurface_FileLoadDialogResponse")]
	private static extern void _FileLoadDialogResponse(IntPtr self, HHTMLBrowser unBrowserHandle, IntPtr pchSelectedFiles);

	internal void FileLoadDialogResponse(HHTMLBrowser unBrowserHandle, string pchSelectedFiles)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchSelectedFiles);
		_FileLoadDialogResponse(Self, unBrowserHandle, utf8StringToNative.Pointer);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamHTTP : SteamInterface
{
	public const string Version = "STEAMHTTP_INTERFACE_VERSION003";

	internal ISteamHTTP(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamHTTP_v003();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamHTTP_v003();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamGameServerHTTP_v003();

	public override IntPtr GetServerInterfacePointer()
	{
		return SteamAPI_SteamGameServerHTTP_v003();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_CreateHTTPRequest")]
	private static extern HTTPRequestHandle _CreateHTTPRequest(IntPtr self, HTTPMethod eHTTPRequestMethod, IntPtr pchAbsoluteURL);

	internal HTTPRequestHandle CreateHTTPRequest(HTTPMethod eHTTPRequestMethod, string pchAbsoluteURL)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchAbsoluteURL);
		return _CreateHTTPRequest(Self, eHTTPRequestMethod, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_SetHTTPRequestContextValue")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetHTTPRequestContextValue(IntPtr self, HTTPRequestHandle hRequest, ulong ulContextValue);

	internal bool SetHTTPRequestContextValue(HTTPRequestHandle hRequest, ulong ulContextValue)
	{
		return _SetHTTPRequestContextValue(Self, hRequest, ulContextValue);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_SetHTTPRequestNetworkActivityTimeout")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetHTTPRequestNetworkActivityTimeout(IntPtr self, HTTPRequestHandle hRequest, uint unTimeoutSeconds);

	internal bool SetHTTPRequestNetworkActivityTimeout(HTTPRequestHandle hRequest, uint unTimeoutSeconds)
	{
		return _SetHTTPRequestNetworkActivityTimeout(Self, hRequest, unTimeoutSeconds);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_SetHTTPRequestHeaderValue")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetHTTPRequestHeaderValue(IntPtr self, HTTPRequestHandle hRequest, IntPtr pchHeaderName, IntPtr pchHeaderValue);

	internal bool SetHTTPRequestHeaderValue(HTTPRequestHandle hRequest, string pchHeaderName, string pchHeaderValue)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchHeaderName);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchHeaderValue);
		return _SetHTTPRequestHeaderValue(Self, hRequest, utf8StringToNative.Pointer, utf8StringToNative2.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_SetHTTPRequestGetOrPostParameter")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetHTTPRequestGetOrPostParameter(IntPtr self, HTTPRequestHandle hRequest, IntPtr pchParamName, IntPtr pchParamValue);

	internal bool SetHTTPRequestGetOrPostParameter(HTTPRequestHandle hRequest, string pchParamName, string pchParamValue)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchParamName);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchParamValue);
		return _SetHTTPRequestGetOrPostParameter(Self, hRequest, utf8StringToNative.Pointer, utf8StringToNative2.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_SendHTTPRequest")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SendHTTPRequest(IntPtr self, HTTPRequestHandle hRequest, ref SteamAPICall_t pCallHandle);

	internal bool SendHTTPRequest(HTTPRequestHandle hRequest, ref SteamAPICall_t pCallHandle)
	{
		return _SendHTTPRequest(Self, hRequest, ref pCallHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_SendHTTPRequestAndStreamResponse")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SendHTTPRequestAndStreamResponse(IntPtr self, HTTPRequestHandle hRequest, ref SteamAPICall_t pCallHandle);

	internal bool SendHTTPRequestAndStreamResponse(HTTPRequestHandle hRequest, ref SteamAPICall_t pCallHandle)
	{
		return _SendHTTPRequestAndStreamResponse(Self, hRequest, ref pCallHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_DeferHTTPRequest")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _DeferHTTPRequest(IntPtr self, HTTPRequestHandle hRequest);

	internal bool DeferHTTPRequest(HTTPRequestHandle hRequest)
	{
		return _DeferHTTPRequest(Self, hRequest);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_PrioritizeHTTPRequest")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _PrioritizeHTTPRequest(IntPtr self, HTTPRequestHandle hRequest);

	internal bool PrioritizeHTTPRequest(HTTPRequestHandle hRequest)
	{
		return _PrioritizeHTTPRequest(Self, hRequest);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_GetHTTPResponseHeaderSize")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetHTTPResponseHeaderSize(IntPtr self, HTTPRequestHandle hRequest, IntPtr pchHeaderName, ref uint unResponseHeaderSize);

	internal bool GetHTTPResponseHeaderSize(HTTPRequestHandle hRequest, string pchHeaderName, ref uint unResponseHeaderSize)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchHeaderName);
		return _GetHTTPResponseHeaderSize(Self, hRequest, utf8StringToNative.Pointer, ref unResponseHeaderSize);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_GetHTTPResponseHeaderValue")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetHTTPResponseHeaderValue(IntPtr self, HTTPRequestHandle hRequest, IntPtr pchHeaderName, ref byte pHeaderValueBuffer, uint unBufferSize);

	internal bool GetHTTPResponseHeaderValue(HTTPRequestHandle hRequest, string pchHeaderName, ref byte pHeaderValueBuffer, uint unBufferSize)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchHeaderName);
		return _GetHTTPResponseHeaderValue(Self, hRequest, utf8StringToNative.Pointer, ref pHeaderValueBuffer, unBufferSize);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_GetHTTPResponseBodySize")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetHTTPResponseBodySize(IntPtr self, HTTPRequestHandle hRequest, ref uint unBodySize);

	internal bool GetHTTPResponseBodySize(HTTPRequestHandle hRequest, ref uint unBodySize)
	{
		return _GetHTTPResponseBodySize(Self, hRequest, ref unBodySize);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_GetHTTPResponseBodyData")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetHTTPResponseBodyData(IntPtr self, HTTPRequestHandle hRequest, ref byte pBodyDataBuffer, uint unBufferSize);

	internal bool GetHTTPResponseBodyData(HTTPRequestHandle hRequest, ref byte pBodyDataBuffer, uint unBufferSize)
	{
		return _GetHTTPResponseBodyData(Self, hRequest, ref pBodyDataBuffer, unBufferSize);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_GetHTTPStreamingResponseBodyData")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetHTTPStreamingResponseBodyData(IntPtr self, HTTPRequestHandle hRequest, uint cOffset, ref byte pBodyDataBuffer, uint unBufferSize);

	internal bool GetHTTPStreamingResponseBodyData(HTTPRequestHandle hRequest, uint cOffset, ref byte pBodyDataBuffer, uint unBufferSize)
	{
		return _GetHTTPStreamingResponseBodyData(Self, hRequest, cOffset, ref pBodyDataBuffer, unBufferSize);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_ReleaseHTTPRequest")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _ReleaseHTTPRequest(IntPtr self, HTTPRequestHandle hRequest);

	internal bool ReleaseHTTPRequest(HTTPRequestHandle hRequest)
	{
		return _ReleaseHTTPRequest(Self, hRequest);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_GetHTTPDownloadProgressPct")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetHTTPDownloadProgressPct(IntPtr self, HTTPRequestHandle hRequest, ref float pflPercentOut);

	internal bool GetHTTPDownloadProgressPct(HTTPRequestHandle hRequest, ref float pflPercentOut)
	{
		return _GetHTTPDownloadProgressPct(Self, hRequest, ref pflPercentOut);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_SetHTTPRequestRawPostBody")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetHTTPRequestRawPostBody(IntPtr self, HTTPRequestHandle hRequest, IntPtr pchContentType, [In][Out] byte[] pubBody, uint unBodyLen);

	internal bool SetHTTPRequestRawPostBody(HTTPRequestHandle hRequest, string pchContentType, [In][Out] byte[] pubBody, uint unBodyLen)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchContentType);
		return _SetHTTPRequestRawPostBody(Self, hRequest, utf8StringToNative.Pointer, pubBody, unBodyLen);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_CreateCookieContainer")]
	private static extern HTTPCookieContainerHandle _CreateCookieContainer(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bAllowResponsesToModify);

	internal HTTPCookieContainerHandle CreateCookieContainer([MarshalAs(UnmanagedType.U1)] bool bAllowResponsesToModify)
	{
		return _CreateCookieContainer(Self, bAllowResponsesToModify);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_ReleaseCookieContainer")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _ReleaseCookieContainer(IntPtr self, HTTPCookieContainerHandle hCookieContainer);

	internal bool ReleaseCookieContainer(HTTPCookieContainerHandle hCookieContainer)
	{
		return _ReleaseCookieContainer(Self, hCookieContainer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_SetCookie")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetCookie(IntPtr self, HTTPCookieContainerHandle hCookieContainer, IntPtr pchHost, IntPtr pchUrl, IntPtr pchCookie);

	internal bool SetCookie(HTTPCookieContainerHandle hCookieContainer, string pchHost, string pchUrl, string pchCookie)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchHost);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchUrl);
		using Utf8StringToNative utf8StringToNative3 = new Utf8StringToNative(pchCookie);
		return _SetCookie(Self, hCookieContainer, utf8StringToNative.Pointer, utf8StringToNative2.Pointer, utf8StringToNative3.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_SetHTTPRequestCookieContainer")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetHTTPRequestCookieContainer(IntPtr self, HTTPRequestHandle hRequest, HTTPCookieContainerHandle hCookieContainer);

	internal bool SetHTTPRequestCookieContainer(HTTPRequestHandle hRequest, HTTPCookieContainerHandle hCookieContainer)
	{
		return _SetHTTPRequestCookieContainer(Self, hRequest, hCookieContainer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_SetHTTPRequestUserAgentInfo")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetHTTPRequestUserAgentInfo(IntPtr self, HTTPRequestHandle hRequest, IntPtr pchUserAgentInfo);

	internal bool SetHTTPRequestUserAgentInfo(HTTPRequestHandle hRequest, string pchUserAgentInfo)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchUserAgentInfo);
		return _SetHTTPRequestUserAgentInfo(Self, hRequest, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_SetHTTPRequestRequiresVerifiedCertificate")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetHTTPRequestRequiresVerifiedCertificate(IntPtr self, HTTPRequestHandle hRequest, [MarshalAs(UnmanagedType.U1)] bool bRequireVerifiedCertificate);

	internal bool SetHTTPRequestRequiresVerifiedCertificate(HTTPRequestHandle hRequest, [MarshalAs(UnmanagedType.U1)] bool bRequireVerifiedCertificate)
	{
		return _SetHTTPRequestRequiresVerifiedCertificate(Self, hRequest, bRequireVerifiedCertificate);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_SetHTTPRequestAbsoluteTimeoutMS")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetHTTPRequestAbsoluteTimeoutMS(IntPtr self, HTTPRequestHandle hRequest, uint unMilliseconds);

	internal bool SetHTTPRequestAbsoluteTimeoutMS(HTTPRequestHandle hRequest, uint unMilliseconds)
	{
		return _SetHTTPRequestAbsoluteTimeoutMS(Self, hRequest, unMilliseconds);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamHTTP_GetHTTPRequestWasTimedOut")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetHTTPRequestWasTimedOut(IntPtr self, HTTPRequestHandle hRequest, [MarshalAs(UnmanagedType.U1)] ref bool pbWasTimedOut);

	internal bool GetHTTPRequestWasTimedOut(HTTPRequestHandle hRequest, [MarshalAs(UnmanagedType.U1)] ref bool pbWasTimedOut)
	{
		return _GetHTTPRequestWasTimedOut(Self, hRequest, ref pbWasTimedOut);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamInput : SteamInterface
{
	public const string Version = "SteamInput006";

	internal ISteamInput(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamInput_v006();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamInput_v006();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_Init")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _Init(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bExplicitlyCallRunFrame);

	internal bool Init([MarshalAs(UnmanagedType.U1)] bool bExplicitlyCallRunFrame)
	{
		return _Init(Self, bExplicitlyCallRunFrame);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_Shutdown")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _Shutdown(IntPtr self);

	internal bool Shutdown()
	{
		return _Shutdown(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_SetInputActionManifestFilePath")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetInputActionManifestFilePath(IntPtr self, IntPtr pchInputActionManifestAbsolutePath);

	internal bool SetInputActionManifestFilePath(string pchInputActionManifestAbsolutePath)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchInputActionManifestAbsolutePath);
		return _SetInputActionManifestFilePath(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_RunFrame")]
	private static extern void _RunFrame(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bReservedValue);

	internal void RunFrame([MarshalAs(UnmanagedType.U1)] bool bReservedValue)
	{
		_RunFrame(Self, bReservedValue);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_BWaitForData")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BWaitForData(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bWaitForever, uint unTimeout);

	internal bool BWaitForData([MarshalAs(UnmanagedType.U1)] bool bWaitForever, uint unTimeout)
	{
		return _BWaitForData(Self, bWaitForever, unTimeout);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_BNewDataAvailable")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BNewDataAvailable(IntPtr self);

	internal bool BNewDataAvailable()
	{
		return _BNewDataAvailable(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetConnectedControllers")]
	private static extern int _GetConnectedControllers(IntPtr self, [In][Out] InputHandle_t[] handlesOut);

	internal int GetConnectedControllers([In][Out] InputHandle_t[] handlesOut)
	{
		return _GetConnectedControllers(Self, handlesOut);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_EnableDeviceCallbacks")]
	private static extern void _EnableDeviceCallbacks(IntPtr self);

	internal void EnableDeviceCallbacks()
	{
		_EnableDeviceCallbacks(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetActionSetHandle")]
	private static extern InputActionSetHandle_t _GetActionSetHandle(IntPtr self, IntPtr pszActionSetName);

	internal InputActionSetHandle_t GetActionSetHandle(string pszActionSetName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszActionSetName);
		return _GetActionSetHandle(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_ActivateActionSet")]
	private static extern void _ActivateActionSet(IntPtr self, InputHandle_t inputHandle, InputActionSetHandle_t actionSetHandle);

	internal void ActivateActionSet(InputHandle_t inputHandle, InputActionSetHandle_t actionSetHandle)
	{
		_ActivateActionSet(Self, inputHandle, actionSetHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetCurrentActionSet")]
	private static extern InputActionSetHandle_t _GetCurrentActionSet(IntPtr self, InputHandle_t inputHandle);

	internal InputActionSetHandle_t GetCurrentActionSet(InputHandle_t inputHandle)
	{
		return _GetCurrentActionSet(Self, inputHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_ActivateActionSetLayer")]
	private static extern void _ActivateActionSetLayer(IntPtr self, InputHandle_t inputHandle, InputActionSetHandle_t actionSetLayerHandle);

	internal void ActivateActionSetLayer(InputHandle_t inputHandle, InputActionSetHandle_t actionSetLayerHandle)
	{
		_ActivateActionSetLayer(Self, inputHandle, actionSetLayerHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_DeactivateActionSetLayer")]
	private static extern void _DeactivateActionSetLayer(IntPtr self, InputHandle_t inputHandle, InputActionSetHandle_t actionSetLayerHandle);

	internal void DeactivateActionSetLayer(InputHandle_t inputHandle, InputActionSetHandle_t actionSetLayerHandle)
	{
		_DeactivateActionSetLayer(Self, inputHandle, actionSetLayerHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_DeactivateAllActionSetLayers")]
	private static extern void _DeactivateAllActionSetLayers(IntPtr self, InputHandle_t inputHandle);

	internal void DeactivateAllActionSetLayers(InputHandle_t inputHandle)
	{
		_DeactivateAllActionSetLayers(Self, inputHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetActiveActionSetLayers")]
	private static extern int _GetActiveActionSetLayers(IntPtr self, InputHandle_t inputHandle, [In][Out] InputActionSetHandle_t[] handlesOut);

	internal int GetActiveActionSetLayers(InputHandle_t inputHandle, [In][Out] InputActionSetHandle_t[] handlesOut)
	{
		return _GetActiveActionSetLayers(Self, inputHandle, handlesOut);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetDigitalActionHandle")]
	private static extern InputDigitalActionHandle_t _GetDigitalActionHandle(IntPtr self, IntPtr pszActionName);

	internal InputDigitalActionHandle_t GetDigitalActionHandle(string pszActionName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszActionName);
		return _GetDigitalActionHandle(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetDigitalActionData")]
	private static extern DigitalState _GetDigitalActionData(IntPtr self, InputHandle_t inputHandle, InputDigitalActionHandle_t digitalActionHandle);

	internal DigitalState GetDigitalActionData(InputHandle_t inputHandle, InputDigitalActionHandle_t digitalActionHandle)
	{
		return _GetDigitalActionData(Self, inputHandle, digitalActionHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetDigitalActionOrigins")]
	private static extern int _GetDigitalActionOrigins(IntPtr self, InputHandle_t inputHandle, InputActionSetHandle_t actionSetHandle, InputDigitalActionHandle_t digitalActionHandle, ref InputActionOrigin originsOut);

	internal int GetDigitalActionOrigins(InputHandle_t inputHandle, InputActionSetHandle_t actionSetHandle, InputDigitalActionHandle_t digitalActionHandle, ref InputActionOrigin originsOut)
	{
		return _GetDigitalActionOrigins(Self, inputHandle, actionSetHandle, digitalActionHandle, ref originsOut);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetStringForDigitalActionName")]
	private static extern Utf8StringPointer _GetStringForDigitalActionName(IntPtr self, InputDigitalActionHandle_t eActionHandle);

	internal string GetStringForDigitalActionName(InputDigitalActionHandle_t eActionHandle)
	{
		return _GetStringForDigitalActionName(Self, eActionHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetAnalogActionHandle")]
	private static extern InputAnalogActionHandle_t _GetAnalogActionHandle(IntPtr self, IntPtr pszActionName);

	internal InputAnalogActionHandle_t GetAnalogActionHandle(string pszActionName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszActionName);
		return _GetAnalogActionHandle(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetAnalogActionData")]
	private static extern AnalogState _GetAnalogActionData(IntPtr self, InputHandle_t inputHandle, InputAnalogActionHandle_t analogActionHandle);

	internal AnalogState GetAnalogActionData(InputHandle_t inputHandle, InputAnalogActionHandle_t analogActionHandle)
	{
		return _GetAnalogActionData(Self, inputHandle, analogActionHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetAnalogActionOrigins")]
	private static extern int _GetAnalogActionOrigins(IntPtr self, InputHandle_t inputHandle, InputActionSetHandle_t actionSetHandle, InputAnalogActionHandle_t analogActionHandle, ref InputActionOrigin originsOut);

	internal int GetAnalogActionOrigins(InputHandle_t inputHandle, InputActionSetHandle_t actionSetHandle, InputAnalogActionHandle_t analogActionHandle, ref InputActionOrigin originsOut)
	{
		return _GetAnalogActionOrigins(Self, inputHandle, actionSetHandle, analogActionHandle, ref originsOut);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetGlyphPNGForActionOrigin")]
	private static extern Utf8StringPointer _GetGlyphPNGForActionOrigin(IntPtr self, InputActionOrigin eOrigin, GlyphSize eSize, uint unFlags);

	internal string GetGlyphPNGForActionOrigin(InputActionOrigin eOrigin, GlyphSize eSize, uint unFlags)
	{
		return _GetGlyphPNGForActionOrigin(Self, eOrigin, eSize, unFlags);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetGlyphSVGForActionOrigin")]
	private static extern Utf8StringPointer _GetGlyphSVGForActionOrigin(IntPtr self, InputActionOrigin eOrigin, uint unFlags);

	internal string GetGlyphSVGForActionOrigin(InputActionOrigin eOrigin, uint unFlags)
	{
		return _GetGlyphSVGForActionOrigin(Self, eOrigin, unFlags);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetGlyphForActionOrigin_Legacy")]
	private static extern Utf8StringPointer _GetGlyphForActionOrigin_Legacy(IntPtr self, InputActionOrigin eOrigin);

	internal string GetGlyphForActionOrigin_Legacy(InputActionOrigin eOrigin)
	{
		return _GetGlyphForActionOrigin_Legacy(Self, eOrigin);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetStringForActionOrigin")]
	private static extern Utf8StringPointer _GetStringForActionOrigin(IntPtr self, InputActionOrigin eOrigin);

	internal string GetStringForActionOrigin(InputActionOrigin eOrigin)
	{
		return _GetStringForActionOrigin(Self, eOrigin);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetStringForAnalogActionName")]
	private static extern Utf8StringPointer _GetStringForAnalogActionName(IntPtr self, InputAnalogActionHandle_t eActionHandle);

	internal string GetStringForAnalogActionName(InputAnalogActionHandle_t eActionHandle)
	{
		return _GetStringForAnalogActionName(Self, eActionHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_StopAnalogActionMomentum")]
	private static extern void _StopAnalogActionMomentum(IntPtr self, InputHandle_t inputHandle, InputAnalogActionHandle_t eAction);

	internal void StopAnalogActionMomentum(InputHandle_t inputHandle, InputAnalogActionHandle_t eAction)
	{
		_StopAnalogActionMomentum(Self, inputHandle, eAction);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetMotionData")]
	private static extern MotionState _GetMotionData(IntPtr self, InputHandle_t inputHandle);

	internal MotionState GetMotionData(InputHandle_t inputHandle)
	{
		return _GetMotionData(Self, inputHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_TriggerVibration")]
	private static extern void _TriggerVibration(IntPtr self, InputHandle_t inputHandle, ushort usLeftSpeed, ushort usRightSpeed);

	internal void TriggerVibration(InputHandle_t inputHandle, ushort usLeftSpeed, ushort usRightSpeed)
	{
		_TriggerVibration(Self, inputHandle, usLeftSpeed, usRightSpeed);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_TriggerVibrationExtended")]
	private static extern void _TriggerVibrationExtended(IntPtr self, InputHandle_t inputHandle, ushort usLeftSpeed, ushort usRightSpeed, ushort usLeftTriggerSpeed, ushort usRightTriggerSpeed);

	internal void TriggerVibrationExtended(InputHandle_t inputHandle, ushort usLeftSpeed, ushort usRightSpeed, ushort usLeftTriggerSpeed, ushort usRightTriggerSpeed)
	{
		_TriggerVibrationExtended(Self, inputHandle, usLeftSpeed, usRightSpeed, usLeftTriggerSpeed, usRightTriggerSpeed);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_TriggerSimpleHapticEvent")]
	private static extern void _TriggerSimpleHapticEvent(IntPtr self, InputHandle_t inputHandle, ControllerHapticLocation eHapticLocation, byte nIntensity, char nGainDB, byte nOtherIntensity, char nOtherGainDB);

	internal void TriggerSimpleHapticEvent(InputHandle_t inputHandle, ControllerHapticLocation eHapticLocation, byte nIntensity, char nGainDB, byte nOtherIntensity, char nOtherGainDB)
	{
		_TriggerSimpleHapticEvent(Self, inputHandle, eHapticLocation, nIntensity, nGainDB, nOtherIntensity, nOtherGainDB);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_SetLEDColor")]
	private static extern void _SetLEDColor(IntPtr self, InputHandle_t inputHandle, byte nColorR, byte nColorG, byte nColorB, uint nFlags);

	internal void SetLEDColor(InputHandle_t inputHandle, byte nColorR, byte nColorG, byte nColorB, uint nFlags)
	{
		_SetLEDColor(Self, inputHandle, nColorR, nColorG, nColorB, nFlags);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_Legacy_TriggerHapticPulse")]
	private static extern void _Legacy_TriggerHapticPulse(IntPtr self, InputHandle_t inputHandle, SteamControllerPad eTargetPad, ushort usDurationMicroSec);

	internal void Legacy_TriggerHapticPulse(InputHandle_t inputHandle, SteamControllerPad eTargetPad, ushort usDurationMicroSec)
	{
		_Legacy_TriggerHapticPulse(Self, inputHandle, eTargetPad, usDurationMicroSec);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_Legacy_TriggerRepeatedHapticPulse")]
	private static extern void _Legacy_TriggerRepeatedHapticPulse(IntPtr self, InputHandle_t inputHandle, SteamControllerPad eTargetPad, ushort usDurationMicroSec, ushort usOffMicroSec, ushort unRepeat, uint nFlags);

	internal void Legacy_TriggerRepeatedHapticPulse(InputHandle_t inputHandle, SteamControllerPad eTargetPad, ushort usDurationMicroSec, ushort usOffMicroSec, ushort unRepeat, uint nFlags)
	{
		_Legacy_TriggerRepeatedHapticPulse(Self, inputHandle, eTargetPad, usDurationMicroSec, usOffMicroSec, unRepeat, nFlags);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_ShowBindingPanel")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _ShowBindingPanel(IntPtr self, InputHandle_t inputHandle);

	internal bool ShowBindingPanel(InputHandle_t inputHandle)
	{
		return _ShowBindingPanel(Self, inputHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetInputTypeForHandle")]
	private static extern InputType _GetInputTypeForHandle(IntPtr self, InputHandle_t inputHandle);

	internal InputType GetInputTypeForHandle(InputHandle_t inputHandle)
	{
		return _GetInputTypeForHandle(Self, inputHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetControllerForGamepadIndex")]
	private static extern InputHandle_t _GetControllerForGamepadIndex(IntPtr self, int nIndex);

	internal InputHandle_t GetControllerForGamepadIndex(int nIndex)
	{
		return _GetControllerForGamepadIndex(Self, nIndex);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetGamepadIndexForController")]
	private static extern int _GetGamepadIndexForController(IntPtr self, InputHandle_t ulinputHandle);

	internal int GetGamepadIndexForController(InputHandle_t ulinputHandle)
	{
		return _GetGamepadIndexForController(Self, ulinputHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetStringForXboxOrigin")]
	private static extern Utf8StringPointer _GetStringForXboxOrigin(IntPtr self, XboxOrigin eOrigin);

	internal string GetStringForXboxOrigin(XboxOrigin eOrigin)
	{
		return _GetStringForXboxOrigin(Self, eOrigin);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetGlyphForXboxOrigin")]
	private static extern Utf8StringPointer _GetGlyphForXboxOrigin(IntPtr self, XboxOrigin eOrigin);

	internal string GetGlyphForXboxOrigin(XboxOrigin eOrigin)
	{
		return _GetGlyphForXboxOrigin(Self, eOrigin);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetActionOriginFromXboxOrigin")]
	private static extern InputActionOrigin _GetActionOriginFromXboxOrigin(IntPtr self, InputHandle_t inputHandle, XboxOrigin eOrigin);

	internal InputActionOrigin GetActionOriginFromXboxOrigin(InputHandle_t inputHandle, XboxOrigin eOrigin)
	{
		return _GetActionOriginFromXboxOrigin(Self, inputHandle, eOrigin);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_TranslateActionOrigin")]
	private static extern InputActionOrigin _TranslateActionOrigin(IntPtr self, InputType eDestinationInputType, InputActionOrigin eSourceOrigin);

	internal InputActionOrigin TranslateActionOrigin(InputType eDestinationInputType, InputActionOrigin eSourceOrigin)
	{
		return _TranslateActionOrigin(Self, eDestinationInputType, eSourceOrigin);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetDeviceBindingRevision")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetDeviceBindingRevision(IntPtr self, InputHandle_t inputHandle, ref int pMajor, ref int pMinor);

	internal bool GetDeviceBindingRevision(InputHandle_t inputHandle, ref int pMajor, ref int pMinor)
	{
		return _GetDeviceBindingRevision(Self, inputHandle, ref pMajor, ref pMinor);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetRemotePlaySessionID")]
	private static extern uint _GetRemotePlaySessionID(IntPtr self, InputHandle_t inputHandle);

	internal uint GetRemotePlaySessionID(InputHandle_t inputHandle)
	{
		return _GetRemotePlaySessionID(Self, inputHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInput_GetSessionInputConfigurationSettings")]
	private static extern ushort _GetSessionInputConfigurationSettings(IntPtr self);

	internal ushort GetSessionInputConfigurationSettings()
	{
		return _GetSessionInputConfigurationSettings(Self);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamInventory : SteamInterface
{
	public const string Version = "STEAMINVENTORY_INTERFACE_V003";

	internal ISteamInventory(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamInventory_v003();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamInventory_v003();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamGameServerInventory_v003();

	public override IntPtr GetServerInterfacePointer()
	{
		return SteamAPI_SteamGameServerInventory_v003();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_GetResultStatus")]
	private static extern Result _GetResultStatus(IntPtr self, SteamInventoryResult_t resultHandle);

	internal Result GetResultStatus(SteamInventoryResult_t resultHandle)
	{
		return _GetResultStatus(Self, resultHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_GetResultItems")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetResultItems(IntPtr self, SteamInventoryResult_t resultHandle, [In][Out] SteamItemDetails_t[] pOutItemsArray, ref uint punOutItemsArraySize);

	internal bool GetResultItems(SteamInventoryResult_t resultHandle, [In][Out] SteamItemDetails_t[] pOutItemsArray, ref uint punOutItemsArraySize)
	{
		return _GetResultItems(Self, resultHandle, pOutItemsArray, ref punOutItemsArraySize);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_GetResultItemProperty")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetResultItemProperty(IntPtr self, SteamInventoryResult_t resultHandle, uint unItemIndex, IntPtr pchPropertyName, IntPtr pchValueBuffer, ref uint punValueBufferSizeOut);

	internal bool GetResultItemProperty(SteamInventoryResult_t resultHandle, uint unItemIndex, string pchPropertyName, out string pchValueBuffer)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchPropertyName);
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			uint punValueBufferSizeOut = 32768u;
			bool result = _GetResultItemProperty(Self, resultHandle, unItemIndex, utf8StringToNative.Pointer, m, ref punValueBufferSizeOut);
			pchValueBuffer = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_GetResultTimestamp")]
	private static extern uint _GetResultTimestamp(IntPtr self, SteamInventoryResult_t resultHandle);

	internal uint GetResultTimestamp(SteamInventoryResult_t resultHandle)
	{
		return _GetResultTimestamp(Self, resultHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_CheckResultSteamID")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _CheckResultSteamID(IntPtr self, SteamInventoryResult_t resultHandle, SteamId steamIDExpected);

	internal bool CheckResultSteamID(SteamInventoryResult_t resultHandle, SteamId steamIDExpected)
	{
		return _CheckResultSteamID(Self, resultHandle, steamIDExpected);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_DestroyResult")]
	private static extern void _DestroyResult(IntPtr self, SteamInventoryResult_t resultHandle);

	internal void DestroyResult(SteamInventoryResult_t resultHandle)
	{
		_DestroyResult(Self, resultHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_GetAllItems")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetAllItems(IntPtr self, ref SteamInventoryResult_t pResultHandle);

	internal bool GetAllItems(ref SteamInventoryResult_t pResultHandle)
	{
		return _GetAllItems(Self, ref pResultHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_GetItemsByID")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetItemsByID(IntPtr self, ref SteamInventoryResult_t pResultHandle, ref InventoryItemId pInstanceIDs, uint unCountInstanceIDs);

	internal bool GetItemsByID(ref SteamInventoryResult_t pResultHandle, ref InventoryItemId pInstanceIDs, uint unCountInstanceIDs)
	{
		return _GetItemsByID(Self, ref pResultHandle, ref pInstanceIDs, unCountInstanceIDs);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_SerializeResult")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SerializeResult(IntPtr self, SteamInventoryResult_t resultHandle, IntPtr pOutBuffer, ref uint punOutBufferSize);

	internal bool SerializeResult(SteamInventoryResult_t resultHandle, IntPtr pOutBuffer, ref uint punOutBufferSize)
	{
		return _SerializeResult(Self, resultHandle, pOutBuffer, ref punOutBufferSize);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_DeserializeResult")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _DeserializeResult(IntPtr self, ref SteamInventoryResult_t pOutResultHandle, IntPtr pBuffer, uint unBufferSize, [MarshalAs(UnmanagedType.U1)] bool bRESERVED_MUST_BE_FALSE);

	internal bool DeserializeResult(ref SteamInventoryResult_t pOutResultHandle, IntPtr pBuffer, uint unBufferSize, [MarshalAs(UnmanagedType.U1)] bool bRESERVED_MUST_BE_FALSE)
	{
		return _DeserializeResult(Self, ref pOutResultHandle, pBuffer, unBufferSize, bRESERVED_MUST_BE_FALSE);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_GenerateItems")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GenerateItems(IntPtr self, ref SteamInventoryResult_t pResultHandle, [In][Out] InventoryDefId[] pArrayItemDefs, [In][Out] uint[] punArrayQuantity, uint unArrayLength);

	internal bool GenerateItems(ref SteamInventoryResult_t pResultHandle, [In][Out] InventoryDefId[] pArrayItemDefs, [In][Out] uint[] punArrayQuantity, uint unArrayLength)
	{
		return _GenerateItems(Self, ref pResultHandle, pArrayItemDefs, punArrayQuantity, unArrayLength);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_GrantPromoItems")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GrantPromoItems(IntPtr self, ref SteamInventoryResult_t pResultHandle);

	internal bool GrantPromoItems(ref SteamInventoryResult_t pResultHandle)
	{
		return _GrantPromoItems(Self, ref pResultHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_AddPromoItem")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _AddPromoItem(IntPtr self, ref SteamInventoryResult_t pResultHandle, InventoryDefId itemDef);

	internal bool AddPromoItem(ref SteamInventoryResult_t pResultHandle, InventoryDefId itemDef)
	{
		return _AddPromoItem(Self, ref pResultHandle, itemDef);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_AddPromoItems")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _AddPromoItems(IntPtr self, ref SteamInventoryResult_t pResultHandle, [In][Out] InventoryDefId[] pArrayItemDefs, uint unArrayLength);

	internal bool AddPromoItems(ref SteamInventoryResult_t pResultHandle, [In][Out] InventoryDefId[] pArrayItemDefs, uint unArrayLength)
	{
		return _AddPromoItems(Self, ref pResultHandle, pArrayItemDefs, unArrayLength);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_ConsumeItem")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _ConsumeItem(IntPtr self, ref SteamInventoryResult_t pResultHandle, InventoryItemId itemConsume, uint unQuantity);

	internal bool ConsumeItem(ref SteamInventoryResult_t pResultHandle, InventoryItemId itemConsume, uint unQuantity)
	{
		return _ConsumeItem(Self, ref pResultHandle, itemConsume, unQuantity);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_ExchangeItems")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _ExchangeItems(IntPtr self, ref SteamInventoryResult_t pResultHandle, [In][Out] InventoryDefId[] pArrayGenerate, [In][Out] uint[] punArrayGenerateQuantity, uint unArrayGenerateLength, [In][Out] InventoryItemId[] pArrayDestroy, [In][Out] uint[] punArrayDestroyQuantity, uint unArrayDestroyLength);

	internal bool ExchangeItems(ref SteamInventoryResult_t pResultHandle, [In][Out] InventoryDefId[] pArrayGenerate, [In][Out] uint[] punArrayGenerateQuantity, uint unArrayGenerateLength, [In][Out] InventoryItemId[] pArrayDestroy, [In][Out] uint[] punArrayDestroyQuantity, uint unArrayDestroyLength)
	{
		return _ExchangeItems(Self, ref pResultHandle, pArrayGenerate, punArrayGenerateQuantity, unArrayGenerateLength, pArrayDestroy, punArrayDestroyQuantity, unArrayDestroyLength);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_TransferItemQuantity")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _TransferItemQuantity(IntPtr self, ref SteamInventoryResult_t pResultHandle, InventoryItemId itemIdSource, uint unQuantity, InventoryItemId itemIdDest);

	internal bool TransferItemQuantity(ref SteamInventoryResult_t pResultHandle, InventoryItemId itemIdSource, uint unQuantity, InventoryItemId itemIdDest)
	{
		return _TransferItemQuantity(Self, ref pResultHandle, itemIdSource, unQuantity, itemIdDest);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_SendItemDropHeartbeat")]
	private static extern void _SendItemDropHeartbeat(IntPtr self);

	internal void SendItemDropHeartbeat()
	{
		_SendItemDropHeartbeat(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_TriggerItemDrop")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _TriggerItemDrop(IntPtr self, ref SteamInventoryResult_t pResultHandle, InventoryDefId dropListDefinition);

	internal bool TriggerItemDrop(ref SteamInventoryResult_t pResultHandle, InventoryDefId dropListDefinition)
	{
		return _TriggerItemDrop(Self, ref pResultHandle, dropListDefinition);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_TradeItems")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _TradeItems(IntPtr self, ref SteamInventoryResult_t pResultHandle, SteamId steamIDTradePartner, [In][Out] InventoryItemId[] pArrayGive, [In][Out] uint[] pArrayGiveQuantity, uint nArrayGiveLength, [In][Out] InventoryItemId[] pArrayGet, [In][Out] uint[] pArrayGetQuantity, uint nArrayGetLength);

	internal bool TradeItems(ref SteamInventoryResult_t pResultHandle, SteamId steamIDTradePartner, [In][Out] InventoryItemId[] pArrayGive, [In][Out] uint[] pArrayGiveQuantity, uint nArrayGiveLength, [In][Out] InventoryItemId[] pArrayGet, [In][Out] uint[] pArrayGetQuantity, uint nArrayGetLength)
	{
		return _TradeItems(Self, ref pResultHandle, steamIDTradePartner, pArrayGive, pArrayGiveQuantity, nArrayGiveLength, pArrayGet, pArrayGetQuantity, nArrayGetLength);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_LoadItemDefinitions")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _LoadItemDefinitions(IntPtr self);

	internal bool LoadItemDefinitions()
	{
		return _LoadItemDefinitions(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_GetItemDefinitionIDs")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetItemDefinitionIDs(IntPtr self, [In][Out] InventoryDefId[] pItemDefIDs, ref uint punItemDefIDsArraySize);

	internal bool GetItemDefinitionIDs([In][Out] InventoryDefId[] pItemDefIDs, ref uint punItemDefIDsArraySize)
	{
		return _GetItemDefinitionIDs(Self, pItemDefIDs, ref punItemDefIDsArraySize);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_GetItemDefinitionProperty")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetItemDefinitionProperty(IntPtr self, InventoryDefId iDefinition, IntPtr pchPropertyName, IntPtr pchValueBuffer, ref uint punValueBufferSizeOut);

	internal bool GetItemDefinitionProperty(InventoryDefId iDefinition, string pchPropertyName, out string pchValueBuffer)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchPropertyName);
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			uint punValueBufferSizeOut = 32768u;
			bool result = _GetItemDefinitionProperty(Self, iDefinition, utf8StringToNative.Pointer, m, ref punValueBufferSizeOut);
			pchValueBuffer = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_RequestEligiblePromoItemDefinitionsIDs")]
	private static extern SteamAPICall_t _RequestEligiblePromoItemDefinitionsIDs(IntPtr self, SteamId steamID);

	internal CallResult<SteamInventoryEligiblePromoItemDefIDs_t> RequestEligiblePromoItemDefinitionsIDs(SteamId steamID)
	{
		return new CallResult<SteamInventoryEligiblePromoItemDefIDs_t>(_RequestEligiblePromoItemDefinitionsIDs(Self, steamID), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_GetEligiblePromoItemDefinitionIDs")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetEligiblePromoItemDefinitionIDs(IntPtr self, SteamId steamID, [In][Out] InventoryDefId[] pItemDefIDs, ref uint punItemDefIDsArraySize);

	internal bool GetEligiblePromoItemDefinitionIDs(SteamId steamID, [In][Out] InventoryDefId[] pItemDefIDs, ref uint punItemDefIDsArraySize)
	{
		return _GetEligiblePromoItemDefinitionIDs(Self, steamID, pItemDefIDs, ref punItemDefIDsArraySize);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_StartPurchase")]
	private static extern SteamAPICall_t _StartPurchase(IntPtr self, [In][Out] InventoryDefId[] pArrayItemDefs, [In][Out] uint[] punArrayQuantity, uint unArrayLength);

	internal CallResult<SteamInventoryStartPurchaseResult_t> StartPurchase([In][Out] InventoryDefId[] pArrayItemDefs, [In][Out] uint[] punArrayQuantity, uint unArrayLength)
	{
		return new CallResult<SteamInventoryStartPurchaseResult_t>(_StartPurchase(Self, pArrayItemDefs, punArrayQuantity, unArrayLength), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_RequestPrices")]
	private static extern SteamAPICall_t _RequestPrices(IntPtr self);

	internal CallResult<SteamInventoryRequestPricesResult_t> RequestPrices()
	{
		return new CallResult<SteamInventoryRequestPricesResult_t>(_RequestPrices(Self), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_GetNumItemsWithPrices")]
	private static extern uint _GetNumItemsWithPrices(IntPtr self);

	internal uint GetNumItemsWithPrices()
	{
		return _GetNumItemsWithPrices(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_GetItemsWithPrices")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetItemsWithPrices(IntPtr self, [In][Out] InventoryDefId[] pArrayItemDefs, [In][Out] ulong[] pCurrentPrices, [In][Out] ulong[] pBasePrices, uint unArrayLength);

	internal bool GetItemsWithPrices([In][Out] InventoryDefId[] pArrayItemDefs, [In][Out] ulong[] pCurrentPrices, [In][Out] ulong[] pBasePrices, uint unArrayLength)
	{
		return _GetItemsWithPrices(Self, pArrayItemDefs, pCurrentPrices, pBasePrices, unArrayLength);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_GetItemPrice")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetItemPrice(IntPtr self, InventoryDefId iDefinition, ref ulong pCurrentPrice, ref ulong pBasePrice);

	internal bool GetItemPrice(InventoryDefId iDefinition, ref ulong pCurrentPrice, ref ulong pBasePrice)
	{
		return _GetItemPrice(Self, iDefinition, ref pCurrentPrice, ref pBasePrice);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_StartUpdateProperties")]
	private static extern SteamInventoryUpdateHandle_t _StartUpdateProperties(IntPtr self);

	internal SteamInventoryUpdateHandle_t StartUpdateProperties()
	{
		return _StartUpdateProperties(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_RemoveProperty")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _RemoveProperty(IntPtr self, SteamInventoryUpdateHandle_t handle, InventoryItemId nItemID, IntPtr pchPropertyName);

	internal bool RemoveProperty(SteamInventoryUpdateHandle_t handle, InventoryItemId nItemID, string pchPropertyName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchPropertyName);
		return _RemoveProperty(Self, handle, nItemID, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_SetPropertyString")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetProperty(IntPtr self, SteamInventoryUpdateHandle_t handle, InventoryItemId nItemID, IntPtr pchPropertyName, IntPtr pchPropertyValue);

	internal bool SetProperty(SteamInventoryUpdateHandle_t handle, InventoryItemId nItemID, string pchPropertyName, string pchPropertyValue)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchPropertyName);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchPropertyValue);
		return _SetProperty(Self, handle, nItemID, utf8StringToNative.Pointer, utf8StringToNative2.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_SetPropertyBool")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetProperty(IntPtr self, SteamInventoryUpdateHandle_t handle, InventoryItemId nItemID, IntPtr pchPropertyName, [MarshalAs(UnmanagedType.U1)] bool bValue);

	internal bool SetProperty(SteamInventoryUpdateHandle_t handle, InventoryItemId nItemID, string pchPropertyName, [MarshalAs(UnmanagedType.U1)] bool bValue)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchPropertyName);
		return _SetProperty(Self, handle, nItemID, utf8StringToNative.Pointer, bValue);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_SetPropertyInt64")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetProperty(IntPtr self, SteamInventoryUpdateHandle_t handle, InventoryItemId nItemID, IntPtr pchPropertyName, long nValue);

	internal bool SetProperty(SteamInventoryUpdateHandle_t handle, InventoryItemId nItemID, string pchPropertyName, long nValue)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchPropertyName);
		return _SetProperty(Self, handle, nItemID, utf8StringToNative.Pointer, nValue);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_SetPropertyFloat")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetProperty(IntPtr self, SteamInventoryUpdateHandle_t handle, InventoryItemId nItemID, IntPtr pchPropertyName, float flValue);

	internal bool SetProperty(SteamInventoryUpdateHandle_t handle, InventoryItemId nItemID, string pchPropertyName, float flValue)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchPropertyName);
		return _SetProperty(Self, handle, nItemID, utf8StringToNative.Pointer, flValue);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_SubmitUpdateProperties")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SubmitUpdateProperties(IntPtr self, SteamInventoryUpdateHandle_t handle, ref SteamInventoryResult_t pResultHandle);

	internal bool SubmitUpdateProperties(SteamInventoryUpdateHandle_t handle, ref SteamInventoryResult_t pResultHandle)
	{
		return _SubmitUpdateProperties(Self, handle, ref pResultHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamInventory_InspectItem")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _InspectItem(IntPtr self, ref SteamInventoryResult_t pResultHandle, IntPtr pchItemToken);

	internal bool InspectItem(ref SteamInventoryResult_t pResultHandle, string pchItemToken)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchItemToken);
		return _InspectItem(Self, ref pResultHandle, utf8StringToNative.Pointer);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamMatchmaking : SteamInterface
{
	public const string Version = "SteamMatchMaking009";

	internal ISteamMatchmaking(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamMatchmaking_v009();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamMatchmaking_v009();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_GetFavoriteGameCount")]
	private static extern int _GetFavoriteGameCount(IntPtr self);

	internal int GetFavoriteGameCount()
	{
		return _GetFavoriteGameCount(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_GetFavoriteGame")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetFavoriteGame(IntPtr self, int iGame, ref AppId pnAppID, ref uint pnIP, ref ushort pnConnPort, ref ushort pnQueryPort, ref uint punFlags, ref uint pRTime32LastPlayedOnServer);

	internal bool GetFavoriteGame(int iGame, ref AppId pnAppID, ref uint pnIP, ref ushort pnConnPort, ref ushort pnQueryPort, ref uint punFlags, ref uint pRTime32LastPlayedOnServer)
	{
		return _GetFavoriteGame(Self, iGame, ref pnAppID, ref pnIP, ref pnConnPort, ref pnQueryPort, ref punFlags, ref pRTime32LastPlayedOnServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_AddFavoriteGame")]
	private static extern int _AddFavoriteGame(IntPtr self, AppId nAppID, uint nIP, ushort nConnPort, ushort nQueryPort, uint unFlags, uint rTime32LastPlayedOnServer);

	internal int AddFavoriteGame(AppId nAppID, uint nIP, ushort nConnPort, ushort nQueryPort, uint unFlags, uint rTime32LastPlayedOnServer)
	{
		return _AddFavoriteGame(Self, nAppID, nIP, nConnPort, nQueryPort, unFlags, rTime32LastPlayedOnServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_RemoveFavoriteGame")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _RemoveFavoriteGame(IntPtr self, AppId nAppID, uint nIP, ushort nConnPort, ushort nQueryPort, uint unFlags);

	internal bool RemoveFavoriteGame(AppId nAppID, uint nIP, ushort nConnPort, ushort nQueryPort, uint unFlags)
	{
		return _RemoveFavoriteGame(Self, nAppID, nIP, nConnPort, nQueryPort, unFlags);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_RequestLobbyList")]
	private static extern SteamAPICall_t _RequestLobbyList(IntPtr self);

	internal CallResult<LobbyMatchList_t> RequestLobbyList()
	{
		return new CallResult<LobbyMatchList_t>(_RequestLobbyList(Self), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_AddRequestLobbyListStringFilter")]
	private static extern void _AddRequestLobbyListStringFilter(IntPtr self, IntPtr pchKeyToMatch, IntPtr pchValueToMatch, LobbyComparison eComparisonType);

	internal void AddRequestLobbyListStringFilter(string pchKeyToMatch, string pchValueToMatch, LobbyComparison eComparisonType)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchKeyToMatch);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchValueToMatch);
		_AddRequestLobbyListStringFilter(Self, utf8StringToNative.Pointer, utf8StringToNative2.Pointer, eComparisonType);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_AddRequestLobbyListNumericalFilter")]
	private static extern void _AddRequestLobbyListNumericalFilter(IntPtr self, IntPtr pchKeyToMatch, int nValueToMatch, LobbyComparison eComparisonType);

	internal void AddRequestLobbyListNumericalFilter(string pchKeyToMatch, int nValueToMatch, LobbyComparison eComparisonType)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchKeyToMatch);
		_AddRequestLobbyListNumericalFilter(Self, utf8StringToNative.Pointer, nValueToMatch, eComparisonType);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_AddRequestLobbyListNearValueFilter")]
	private static extern void _AddRequestLobbyListNearValueFilter(IntPtr self, IntPtr pchKeyToMatch, int nValueToBeCloseTo);

	internal void AddRequestLobbyListNearValueFilter(string pchKeyToMatch, int nValueToBeCloseTo)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchKeyToMatch);
		_AddRequestLobbyListNearValueFilter(Self, utf8StringToNative.Pointer, nValueToBeCloseTo);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_AddRequestLobbyListFilterSlotsAvailable")]
	private static extern void _AddRequestLobbyListFilterSlotsAvailable(IntPtr self, int nSlotsAvailable);

	internal void AddRequestLobbyListFilterSlotsAvailable(int nSlotsAvailable)
	{
		_AddRequestLobbyListFilterSlotsAvailable(Self, nSlotsAvailable);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_AddRequestLobbyListDistanceFilter")]
	private static extern void _AddRequestLobbyListDistanceFilter(IntPtr self, LobbyDistanceFilter eLobbyDistanceFilter);

	internal void AddRequestLobbyListDistanceFilter(LobbyDistanceFilter eLobbyDistanceFilter)
	{
		_AddRequestLobbyListDistanceFilter(Self, eLobbyDistanceFilter);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_AddRequestLobbyListResultCountFilter")]
	private static extern void _AddRequestLobbyListResultCountFilter(IntPtr self, int cMaxResults);

	internal void AddRequestLobbyListResultCountFilter(int cMaxResults)
	{
		_AddRequestLobbyListResultCountFilter(Self, cMaxResults);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_AddRequestLobbyListCompatibleMembersFilter")]
	private static extern void _AddRequestLobbyListCompatibleMembersFilter(IntPtr self, SteamId steamIDLobby);

	internal void AddRequestLobbyListCompatibleMembersFilter(SteamId steamIDLobby)
	{
		_AddRequestLobbyListCompatibleMembersFilter(Self, steamIDLobby);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_GetLobbyByIndex")]
	private static extern SteamId _GetLobbyByIndex(IntPtr self, int iLobby);

	internal SteamId GetLobbyByIndex(int iLobby)
	{
		return _GetLobbyByIndex(Self, iLobby);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_CreateLobby")]
	private static extern SteamAPICall_t _CreateLobby(IntPtr self, LobbyType eLobbyType, int cMaxMembers);

	internal CallResult<LobbyCreated_t> CreateLobby(LobbyType eLobbyType, int cMaxMembers)
	{
		return new CallResult<LobbyCreated_t>(_CreateLobby(Self, eLobbyType, cMaxMembers), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_JoinLobby")]
	private static extern SteamAPICall_t _JoinLobby(IntPtr self, SteamId steamIDLobby);

	internal CallResult<LobbyEnter_t> JoinLobby(SteamId steamIDLobby)
	{
		return new CallResult<LobbyEnter_t>(_JoinLobby(Self, steamIDLobby), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_LeaveLobby")]
	private static extern void _LeaveLobby(IntPtr self, SteamId steamIDLobby);

	internal void LeaveLobby(SteamId steamIDLobby)
	{
		_LeaveLobby(Self, steamIDLobby);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_InviteUserToLobby")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _InviteUserToLobby(IntPtr self, SteamId steamIDLobby, SteamId steamIDInvitee);

	internal bool InviteUserToLobby(SteamId steamIDLobby, SteamId steamIDInvitee)
	{
		return _InviteUserToLobby(Self, steamIDLobby, steamIDInvitee);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_GetNumLobbyMembers")]
	private static extern int _GetNumLobbyMembers(IntPtr self, SteamId steamIDLobby);

	internal int GetNumLobbyMembers(SteamId steamIDLobby)
	{
		return _GetNumLobbyMembers(Self, steamIDLobby);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_GetLobbyMemberByIndex")]
	private static extern SteamId _GetLobbyMemberByIndex(IntPtr self, SteamId steamIDLobby, int iMember);

	internal SteamId GetLobbyMemberByIndex(SteamId steamIDLobby, int iMember)
	{
		return _GetLobbyMemberByIndex(Self, steamIDLobby, iMember);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_GetLobbyData")]
	private static extern Utf8StringPointer _GetLobbyData(IntPtr self, SteamId steamIDLobby, IntPtr pchKey);

	internal string GetLobbyData(SteamId steamIDLobby, string pchKey)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchKey);
		return _GetLobbyData(Self, steamIDLobby, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_SetLobbyData")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetLobbyData(IntPtr self, SteamId steamIDLobby, IntPtr pchKey, IntPtr pchValue);

	internal bool SetLobbyData(SteamId steamIDLobby, string pchKey, string pchValue)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchKey);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchValue);
		return _SetLobbyData(Self, steamIDLobby, utf8StringToNative.Pointer, utf8StringToNative2.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_GetLobbyDataCount")]
	private static extern int _GetLobbyDataCount(IntPtr self, SteamId steamIDLobby);

	internal int GetLobbyDataCount(SteamId steamIDLobby)
	{
		return _GetLobbyDataCount(Self, steamIDLobby);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_GetLobbyDataByIndex")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetLobbyDataByIndex(IntPtr self, SteamId steamIDLobby, int iLobbyData, IntPtr pchKey, int cchKeyBufferSize, IntPtr pchValue, int cchValueBufferSize);

	internal bool GetLobbyDataByIndex(SteamId steamIDLobby, int iLobbyData, out string pchKey, out string pchValue)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			Helpers.Memory m2 = Helpers.TakeMemory();
			try
			{
				bool result = _GetLobbyDataByIndex(Self, steamIDLobby, iLobbyData, m, 32768, m2, 32768);
				pchKey = Helpers.MemoryToString(m);
				pchValue = Helpers.MemoryToString(m2);
				return result;
			}
			finally
			{
				((IDisposable)m2/*cast due to .constrained prefix*/).Dispose();
			}
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_DeleteLobbyData")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _DeleteLobbyData(IntPtr self, SteamId steamIDLobby, IntPtr pchKey);

	internal bool DeleteLobbyData(SteamId steamIDLobby, string pchKey)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchKey);
		return _DeleteLobbyData(Self, steamIDLobby, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_GetLobbyMemberData")]
	private static extern Utf8StringPointer _GetLobbyMemberData(IntPtr self, SteamId steamIDLobby, SteamId steamIDUser, IntPtr pchKey);

	internal string GetLobbyMemberData(SteamId steamIDLobby, SteamId steamIDUser, string pchKey)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchKey);
		return _GetLobbyMemberData(Self, steamIDLobby, steamIDUser, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_SetLobbyMemberData")]
	private static extern void _SetLobbyMemberData(IntPtr self, SteamId steamIDLobby, IntPtr pchKey, IntPtr pchValue);

	internal void SetLobbyMemberData(SteamId steamIDLobby, string pchKey, string pchValue)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchKey);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchValue);
		_SetLobbyMemberData(Self, steamIDLobby, utf8StringToNative.Pointer, utf8StringToNative2.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_SendLobbyChatMsg")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SendLobbyChatMsg(IntPtr self, SteamId steamIDLobby, IntPtr pvMsgBody, int cubMsgBody);

	internal bool SendLobbyChatMsg(SteamId steamIDLobby, IntPtr pvMsgBody, int cubMsgBody)
	{
		return _SendLobbyChatMsg(Self, steamIDLobby, pvMsgBody, cubMsgBody);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_GetLobbyChatEntry")]
	private static extern int _GetLobbyChatEntry(IntPtr self, SteamId steamIDLobby, int iChatID, ref SteamId pSteamIDUser, IntPtr pvData, int cubData, ref ChatEntryType peChatEntryType);

	internal int GetLobbyChatEntry(SteamId steamIDLobby, int iChatID, ref SteamId pSteamIDUser, IntPtr pvData, int cubData, ref ChatEntryType peChatEntryType)
	{
		return _GetLobbyChatEntry(Self, steamIDLobby, iChatID, ref pSteamIDUser, pvData, cubData, ref peChatEntryType);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_RequestLobbyData")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _RequestLobbyData(IntPtr self, SteamId steamIDLobby);

	internal bool RequestLobbyData(SteamId steamIDLobby)
	{
		return _RequestLobbyData(Self, steamIDLobby);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_SetLobbyGameServer")]
	private static extern void _SetLobbyGameServer(IntPtr self, SteamId steamIDLobby, uint unGameServerIP, ushort unGameServerPort, SteamId steamIDGameServer);

	internal void SetLobbyGameServer(SteamId steamIDLobby, uint unGameServerIP, ushort unGameServerPort, SteamId steamIDGameServer)
	{
		_SetLobbyGameServer(Self, steamIDLobby, unGameServerIP, unGameServerPort, steamIDGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_GetLobbyGameServer")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetLobbyGameServer(IntPtr self, SteamId steamIDLobby, ref uint punGameServerIP, ref ushort punGameServerPort, ref SteamId psteamIDGameServer);

	internal bool GetLobbyGameServer(SteamId steamIDLobby, ref uint punGameServerIP, ref ushort punGameServerPort, ref SteamId psteamIDGameServer)
	{
		return _GetLobbyGameServer(Self, steamIDLobby, ref punGameServerIP, ref punGameServerPort, ref psteamIDGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_SetLobbyMemberLimit")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetLobbyMemberLimit(IntPtr self, SteamId steamIDLobby, int cMaxMembers);

	internal bool SetLobbyMemberLimit(SteamId steamIDLobby, int cMaxMembers)
	{
		return _SetLobbyMemberLimit(Self, steamIDLobby, cMaxMembers);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_GetLobbyMemberLimit")]
	private static extern int _GetLobbyMemberLimit(IntPtr self, SteamId steamIDLobby);

	internal int GetLobbyMemberLimit(SteamId steamIDLobby)
	{
		return _GetLobbyMemberLimit(Self, steamIDLobby);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_SetLobbyType")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetLobbyType(IntPtr self, SteamId steamIDLobby, LobbyType eLobbyType);

	internal bool SetLobbyType(SteamId steamIDLobby, LobbyType eLobbyType)
	{
		return _SetLobbyType(Self, steamIDLobby, eLobbyType);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_SetLobbyJoinable")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetLobbyJoinable(IntPtr self, SteamId steamIDLobby, [MarshalAs(UnmanagedType.U1)] bool bLobbyJoinable);

	internal bool SetLobbyJoinable(SteamId steamIDLobby, [MarshalAs(UnmanagedType.U1)] bool bLobbyJoinable)
	{
		return _SetLobbyJoinable(Self, steamIDLobby, bLobbyJoinable);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_GetLobbyOwner")]
	private static extern SteamId _GetLobbyOwner(IntPtr self, SteamId steamIDLobby);

	internal SteamId GetLobbyOwner(SteamId steamIDLobby)
	{
		return _GetLobbyOwner(Self, steamIDLobby);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_SetLobbyOwner")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetLobbyOwner(IntPtr self, SteamId steamIDLobby, SteamId steamIDNewOwner);

	internal bool SetLobbyOwner(SteamId steamIDLobby, SteamId steamIDNewOwner)
	{
		return _SetLobbyOwner(Self, steamIDLobby, steamIDNewOwner);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmaking_SetLinkedLobby")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetLinkedLobby(IntPtr self, SteamId steamIDLobby, SteamId steamIDLobbyDependent);

	internal bool SetLinkedLobby(SteamId steamIDLobby, SteamId steamIDLobbyDependent)
	{
		return _SetLinkedLobby(Self, steamIDLobby, steamIDLobbyDependent);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamMatchmakingPingResponse : SteamInterface
{
	internal ISteamMatchmakingPingResponse(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingPingResponse_ServerResponded")]
	private static extern void _ServerResponded(IntPtr self, ref gameserveritem_t server);

	internal void ServerResponded(ref gameserveritem_t server)
	{
		_ServerResponded(Self, ref server);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingPingResponse_ServerFailedToRespond")]
	private static extern void _ServerFailedToRespond(IntPtr self);

	internal void ServerFailedToRespond()
	{
		_ServerFailedToRespond(Self);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;

internal class ISteamMatchmakingPlayersResponse : SteamInterface
{
	internal ISteamMatchmakingPlayersResponse(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingPlayersResponse_AddPlayerToList")]
	private static extern void _AddPlayerToList(IntPtr self, IntPtr pchName, int nScore, float flTimePlayed);

	internal void AddPlayerToList(string pchName, int nScore, float flTimePlayed)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		_AddPlayerToList(Self, utf8StringToNative.Pointer, nScore, flTimePlayed);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingPlayersResponse_PlayersFailedToRespond")]
	private static extern void _PlayersFailedToRespond(IntPtr self);

	internal void PlayersFailedToRespond()
	{
		_PlayersFailedToRespond(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingPlayersResponse_PlayersRefreshComplete")]
	private static extern void _PlayersRefreshComplete(IntPtr self);

	internal void PlayersRefreshComplete()
	{
		_PlayersRefreshComplete(Self);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;

internal class ISteamMatchmakingRulesResponse : SteamInterface
{
	internal ISteamMatchmakingRulesResponse(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingRulesResponse_RulesResponded")]
	private static extern void _RulesResponded(IntPtr self, IntPtr pchRule, IntPtr pchValue);

	internal void RulesResponded(string pchRule, string pchValue)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchRule);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchValue);
		_RulesResponded(Self, utf8StringToNative.Pointer, utf8StringToNative2.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingRulesResponse_RulesFailedToRespond")]
	private static extern void _RulesFailedToRespond(IntPtr self);

	internal void RulesFailedToRespond()
	{
		_RulesFailedToRespond(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingRulesResponse_RulesRefreshComplete")]
	private static extern void _RulesRefreshComplete(IntPtr self);

	internal void RulesRefreshComplete()
	{
		_RulesRefreshComplete(Self);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamMatchmakingServerListResponse : SteamInterface
{
	internal ISteamMatchmakingServerListResponse(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingServerListResponse_ServerResponded")]
	private static extern void _ServerResponded(IntPtr self, HServerListRequest hRequest, int iServer);

	internal void ServerResponded(HServerListRequest hRequest, int iServer)
	{
		_ServerResponded(Self, hRequest, iServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingServerListResponse_ServerFailedToRespond")]
	private static extern void _ServerFailedToRespond(IntPtr self, HServerListRequest hRequest, int iServer);

	internal void ServerFailedToRespond(HServerListRequest hRequest, int iServer)
	{
		_ServerFailedToRespond(Self, hRequest, iServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingServerListResponse_RefreshComplete")]
	private static extern void _RefreshComplete(IntPtr self, HServerListRequest hRequest, MatchMakingServerResponse response);

	internal void RefreshComplete(HServerListRequest hRequest, MatchMakingServerResponse response)
	{
		_RefreshComplete(Self, hRequest, response);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamMatchmakingServers : SteamInterface
{
	public const string Version = "SteamMatchMakingServers002";

	private static int hasSuccessfulResponseOffset;

	internal ISteamMatchmakingServers(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamMatchmakingServers_v002();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamMatchmakingServers_v002();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingServers_RequestInternetServerList")]
	private static extern HServerListRequest _RequestInternetServerList(IntPtr self, AppId iApp, IntPtr ppchFilters, uint nFilters, IntPtr pRequestServersResponse);

	internal HServerListRequest RequestInternetServerList(AppId iApp, IntPtr ppchFilters, uint nFilters, IntPtr pRequestServersResponse)
	{
		return _RequestInternetServerList(Self, iApp, ppchFilters, nFilters, pRequestServersResponse);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingServers_RequestLANServerList")]
	private static extern HServerListRequest _RequestLANServerList(IntPtr self, AppId iApp, IntPtr pRequestServersResponse);

	internal HServerListRequest RequestLANServerList(AppId iApp, IntPtr pRequestServersResponse)
	{
		return _RequestLANServerList(Self, iApp, pRequestServersResponse);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingServers_RequestFriendsServerList")]
	private static extern HServerListRequest _RequestFriendsServerList(IntPtr self, AppId iApp, IntPtr ppchFilters, uint nFilters, IntPtr pRequestServersResponse);

	internal HServerListRequest RequestFriendsServerList(AppId iApp, IntPtr ppchFilters, uint nFilters, IntPtr pRequestServersResponse)
	{
		return _RequestFriendsServerList(Self, iApp, ppchFilters, nFilters, pRequestServersResponse);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingServers_RequestFavoritesServerList")]
	private static extern HServerListRequest _RequestFavoritesServerList(IntPtr self, AppId iApp, IntPtr ppchFilters, uint nFilters, IntPtr pRequestServersResponse);

	internal HServerListRequest RequestFavoritesServerList(AppId iApp, IntPtr ppchFilters, uint nFilters, IntPtr pRequestServersResponse)
	{
		return _RequestFavoritesServerList(Self, iApp, ppchFilters, nFilters, pRequestServersResponse);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingServers_RequestHistoryServerList")]
	private static extern HServerListRequest _RequestHistoryServerList(IntPtr self, AppId iApp, IntPtr ppchFilters, uint nFilters, IntPtr pRequestServersResponse);

	internal HServerListRequest RequestHistoryServerList(AppId iApp, IntPtr ppchFilters, uint nFilters, IntPtr pRequestServersResponse)
	{
		return _RequestHistoryServerList(Self, iApp, ppchFilters, nFilters, pRequestServersResponse);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingServers_RequestSpectatorServerList")]
	private static extern HServerListRequest _RequestSpectatorServerList(IntPtr self, AppId iApp, IntPtr ppchFilters, uint nFilters, IntPtr pRequestServersResponse);

	internal HServerListRequest RequestSpectatorServerList(AppId iApp, IntPtr ppchFilters, uint nFilters, IntPtr pRequestServersResponse)
	{
		return _RequestSpectatorServerList(Self, iApp, ppchFilters, nFilters, pRequestServersResponse);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingServers_ReleaseRequest")]
	private static extern void _ReleaseRequest(IntPtr self, HServerListRequest hServerListRequest);

	internal void ReleaseRequest(HServerListRequest hServerListRequest)
	{
		_ReleaseRequest(Self, hServerListRequest);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingServers_GetServerDetails")]
	private static extern IntPtr _GetServerDetails(IntPtr self, HServerListRequest hRequest, int iServer);

	internal gameserveritem_t GetServerDetails(HServerListRequest hRequest, int iServer)
	{
		return _GetServerDetails(Self, hRequest, iServer).ToType<gameserveritem_t>();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingServers_CancelQuery")]
	private static extern void _CancelQuery(IntPtr self, HServerListRequest hRequest);

	internal void CancelQuery(HServerListRequest hRequest)
	{
		_CancelQuery(Self, hRequest);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingServers_RefreshQuery")]
	private static extern void _RefreshQuery(IntPtr self, HServerListRequest hRequest);

	internal void RefreshQuery(HServerListRequest hRequest)
	{
		_RefreshQuery(Self, hRequest);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingServers_IsRefreshing")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _IsRefreshing(IntPtr self, HServerListRequest hRequest);

	internal bool IsRefreshing(HServerListRequest hRequest)
	{
		return _IsRefreshing(Self, hRequest);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingServers_GetServerCount")]
	private static extern int _GetServerCount(IntPtr self, HServerListRequest hRequest);

	internal int GetServerCount(HServerListRequest hRequest)
	{
		return _GetServerCount(Self, hRequest);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingServers_RefreshServer")]
	private static extern void _RefreshServer(IntPtr self, HServerListRequest hRequest, int iServer);

	internal void RefreshServer(HServerListRequest hRequest, int iServer)
	{
		_RefreshServer(Self, hRequest, iServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingServers_PingServer")]
	private static extern HServerQuery _PingServer(IntPtr self, uint unIP, ushort usPort, IntPtr pRequestServersResponse);

	internal HServerQuery PingServer(uint unIP, ushort usPort, IntPtr pRequestServersResponse)
	{
		return _PingServer(Self, unIP, usPort, pRequestServersResponse);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingServers_PlayerDetails")]
	private static extern HServerQuery _PlayerDetails(IntPtr self, uint unIP, ushort usPort, IntPtr pRequestServersResponse);

	internal HServerQuery PlayerDetails(uint unIP, ushort usPort, IntPtr pRequestServersResponse)
	{
		return _PlayerDetails(Self, unIP, usPort, pRequestServersResponse);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingServers_ServerRules")]
	private static extern HServerQuery _ServerRules(IntPtr self, uint unIP, ushort usPort, IntPtr pRequestServersResponse);

	internal HServerQuery ServerRules(uint unIP, ushort usPort, IntPtr pRequestServersResponse)
	{
		return _ServerRules(Self, unIP, usPort, pRequestServersResponse);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMatchmakingServers_CancelServerQuery")]
	private static extern void _CancelServerQuery(IntPtr self, HServerQuery hServerQuery);

	internal void CancelServerQuery(HServerQuery hServerQuery)
	{
		_CancelServerQuery(Self, hServerQuery);
	}

	internal bool HasServerResponded(HServerListRequest hRequest, int iServer)
	{
		IntPtr intPtr = _GetServerDetails(Self, hRequest, iServer);
		if (intPtr == IntPtr.Zero)
		{
			return false;
		}
		if (hasSuccessfulResponseOffset == 0)
		{
			hasSuccessfulResponseOffset = Marshal.OffsetOf<gameserveritem_t>("HadSuccessfulResponse").ToInt32();
			if (hasSuccessfulResponseOffset == 0)
			{
				throw new Exception("Failed to get offset of gameserveritem_t.HadSuccessfulResponse");
			}
		}
		return Marshal.ReadByte(IntPtr.Add(intPtr, hasSuccessfulResponseOffset)) == 1;
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;

internal class ISteamMusic : SteamInterface
{
	public const string Version = "STEAMMUSIC_INTERFACE_VERSION001";

	internal ISteamMusic(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamMusic_v001();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamMusic_v001();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusic_BIsEnabled")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsEnabled(IntPtr self);

	internal bool BIsEnabled()
	{
		return _BIsEnabled(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusic_BIsPlaying")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsPlaying(IntPtr self);

	internal bool BIsPlaying()
	{
		return _BIsPlaying(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusic_GetPlaybackStatus")]
	private static extern MusicStatus _GetPlaybackStatus(IntPtr self);

	internal MusicStatus GetPlaybackStatus()
	{
		return _GetPlaybackStatus(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusic_Play")]
	private static extern void _Play(IntPtr self);

	internal void Play()
	{
		_Play(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusic_Pause")]
	private static extern void _Pause(IntPtr self);

	internal void Pause()
	{
		_Pause(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusic_PlayPrevious")]
	private static extern void _PlayPrevious(IntPtr self);

	internal void PlayPrevious()
	{
		_PlayPrevious(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusic_PlayNext")]
	private static extern void _PlayNext(IntPtr self);

	internal void PlayNext()
	{
		_PlayNext(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusic_SetVolume")]
	private static extern void _SetVolume(IntPtr self, float flVolume);

	internal void SetVolume(float flVolume)
	{
		_SetVolume(Self, flVolume);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusic_GetVolume")]
	private static extern float _GetVolume(IntPtr self);

	internal float GetVolume()
	{
		return _GetVolume(Self);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;

internal class ISteamMusicRemote : SteamInterface
{
	public const string Version = "STEAMMUSICREMOTE_INTERFACE_VERSION001";

	internal ISteamMusicRemote(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamMusicRemote_v001();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamMusicRemote_v001();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_RegisterSteamMusicRemote")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _RegisterSteamMusicRemote(IntPtr self, IntPtr pchName);

	internal bool RegisterSteamMusicRemote(string pchName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _RegisterSteamMusicRemote(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_DeregisterSteamMusicRemote")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _DeregisterSteamMusicRemote(IntPtr self);

	internal bool DeregisterSteamMusicRemote()
	{
		return _DeregisterSteamMusicRemote(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_BIsCurrentMusicRemote")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsCurrentMusicRemote(IntPtr self);

	internal bool BIsCurrentMusicRemote()
	{
		return _BIsCurrentMusicRemote(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_BActivationSuccess")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BActivationSuccess(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bValue);

	internal bool BActivationSuccess([MarshalAs(UnmanagedType.U1)] bool bValue)
	{
		return _BActivationSuccess(Self, bValue);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_SetDisplayName")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetDisplayName(IntPtr self, IntPtr pchDisplayName);

	internal bool SetDisplayName(string pchDisplayName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchDisplayName);
		return _SetDisplayName(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_SetPNGIcon_64x64")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetPNGIcon_64x64(IntPtr self, IntPtr pvBuffer, uint cbBufferLength);

	internal bool SetPNGIcon_64x64(IntPtr pvBuffer, uint cbBufferLength)
	{
		return _SetPNGIcon_64x64(Self, pvBuffer, cbBufferLength);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_EnablePlayPrevious")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _EnablePlayPrevious(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bValue);

	internal bool EnablePlayPrevious([MarshalAs(UnmanagedType.U1)] bool bValue)
	{
		return _EnablePlayPrevious(Self, bValue);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_EnablePlayNext")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _EnablePlayNext(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bValue);

	internal bool EnablePlayNext([MarshalAs(UnmanagedType.U1)] bool bValue)
	{
		return _EnablePlayNext(Self, bValue);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_EnableShuffled")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _EnableShuffled(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bValue);

	internal bool EnableShuffled([MarshalAs(UnmanagedType.U1)] bool bValue)
	{
		return _EnableShuffled(Self, bValue);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_EnableLooped")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _EnableLooped(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bValue);

	internal bool EnableLooped([MarshalAs(UnmanagedType.U1)] bool bValue)
	{
		return _EnableLooped(Self, bValue);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_EnableQueue")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _EnableQueue(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bValue);

	internal bool EnableQueue([MarshalAs(UnmanagedType.U1)] bool bValue)
	{
		return _EnableQueue(Self, bValue);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_EnablePlaylists")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _EnablePlaylists(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bValue);

	internal bool EnablePlaylists([MarshalAs(UnmanagedType.U1)] bool bValue)
	{
		return _EnablePlaylists(Self, bValue);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_UpdatePlaybackStatus")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _UpdatePlaybackStatus(IntPtr self, MusicStatus nStatus);

	internal bool UpdatePlaybackStatus(MusicStatus nStatus)
	{
		return _UpdatePlaybackStatus(Self, nStatus);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_UpdateShuffled")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _UpdateShuffled(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bValue);

	internal bool UpdateShuffled([MarshalAs(UnmanagedType.U1)] bool bValue)
	{
		return _UpdateShuffled(Self, bValue);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_UpdateLooped")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _UpdateLooped(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bValue);

	internal bool UpdateLooped([MarshalAs(UnmanagedType.U1)] bool bValue)
	{
		return _UpdateLooped(Self, bValue);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_UpdateVolume")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _UpdateVolume(IntPtr self, float flValue);

	internal bool UpdateVolume(float flValue)
	{
		return _UpdateVolume(Self, flValue);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_CurrentEntryWillChange")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _CurrentEntryWillChange(IntPtr self);

	internal bool CurrentEntryWillChange()
	{
		return _CurrentEntryWillChange(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_CurrentEntryIsAvailable")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _CurrentEntryIsAvailable(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bAvailable);

	internal bool CurrentEntryIsAvailable([MarshalAs(UnmanagedType.U1)] bool bAvailable)
	{
		return _CurrentEntryIsAvailable(Self, bAvailable);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_UpdateCurrentEntryText")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _UpdateCurrentEntryText(IntPtr self, IntPtr pchText);

	internal bool UpdateCurrentEntryText(string pchText)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchText);
		return _UpdateCurrentEntryText(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_UpdateCurrentEntryElapsedSeconds")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _UpdateCurrentEntryElapsedSeconds(IntPtr self, int nValue);

	internal bool UpdateCurrentEntryElapsedSeconds(int nValue)
	{
		return _UpdateCurrentEntryElapsedSeconds(Self, nValue);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_UpdateCurrentEntryCoverArt")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _UpdateCurrentEntryCoverArt(IntPtr self, IntPtr pvBuffer, uint cbBufferLength);

	internal bool UpdateCurrentEntryCoverArt(IntPtr pvBuffer, uint cbBufferLength)
	{
		return _UpdateCurrentEntryCoverArt(Self, pvBuffer, cbBufferLength);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_CurrentEntryDidChange")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _CurrentEntryDidChange(IntPtr self);

	internal bool CurrentEntryDidChange()
	{
		return _CurrentEntryDidChange(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_QueueWillChange")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _QueueWillChange(IntPtr self);

	internal bool QueueWillChange()
	{
		return _QueueWillChange(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_ResetQueueEntries")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _ResetQueueEntries(IntPtr self);

	internal bool ResetQueueEntries()
	{
		return _ResetQueueEntries(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_SetQueueEntry")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetQueueEntry(IntPtr self, int nID, int nPosition, IntPtr pchEntryText);

	internal bool SetQueueEntry(int nID, int nPosition, string pchEntryText)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchEntryText);
		return _SetQueueEntry(Self, nID, nPosition, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_SetCurrentQueueEntry")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetCurrentQueueEntry(IntPtr self, int nID);

	internal bool SetCurrentQueueEntry(int nID)
	{
		return _SetCurrentQueueEntry(Self, nID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_QueueDidChange")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _QueueDidChange(IntPtr self);

	internal bool QueueDidChange()
	{
		return _QueueDidChange(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_PlaylistWillChange")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _PlaylistWillChange(IntPtr self);

	internal bool PlaylistWillChange()
	{
		return _PlaylistWillChange(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_ResetPlaylistEntries")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _ResetPlaylistEntries(IntPtr self);

	internal bool ResetPlaylistEntries()
	{
		return _ResetPlaylistEntries(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_SetPlaylistEntry")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetPlaylistEntry(IntPtr self, int nID, int nPosition, IntPtr pchEntryText);

	internal bool SetPlaylistEntry(int nID, int nPosition, string pchEntryText)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchEntryText);
		return _SetPlaylistEntry(Self, nID, nPosition, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_SetCurrentPlaylistEntry")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetCurrentPlaylistEntry(IntPtr self, int nID);

	internal bool SetCurrentPlaylistEntry(int nID)
	{
		return _SetCurrentPlaylistEntry(Self, nID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamMusicRemote_PlaylistDidChange")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _PlaylistDidChange(IntPtr self);

	internal bool PlaylistDidChange()
	{
		return _PlaylistDidChange(Self);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamNetworking : SteamInterface
{
	public const string Version = "SteamNetworking006";

	internal ISteamNetworking(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamNetworking_v006();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamNetworking_v006();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamGameServerNetworking_v006();

	public override IntPtr GetServerInterfacePointer()
	{
		return SteamAPI_SteamGameServerNetworking_v006();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworking_SendP2PPacket")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SendP2PPacket(IntPtr self, SteamId steamIDRemote, IntPtr pubData, uint cubData, P2PSend eP2PSendType, int nChannel);

	internal bool SendP2PPacket(SteamId steamIDRemote, IntPtr pubData, uint cubData, P2PSend eP2PSendType, int nChannel)
	{
		return _SendP2PPacket(Self, steamIDRemote, pubData, cubData, eP2PSendType, nChannel);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworking_IsP2PPacketAvailable")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _IsP2PPacketAvailable(IntPtr self, ref uint pcubMsgSize, int nChannel);

	internal bool IsP2PPacketAvailable(ref uint pcubMsgSize, int nChannel)
	{
		return _IsP2PPacketAvailable(Self, ref pcubMsgSize, nChannel);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworking_ReadP2PPacket")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _ReadP2PPacket(IntPtr self, IntPtr pubDest, uint cubDest, ref uint pcubMsgSize, ref SteamId psteamIDRemote, int nChannel);

	internal bool ReadP2PPacket(IntPtr pubDest, uint cubDest, ref uint pcubMsgSize, ref SteamId psteamIDRemote, int nChannel)
	{
		return _ReadP2PPacket(Self, pubDest, cubDest, ref pcubMsgSize, ref psteamIDRemote, nChannel);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworking_AcceptP2PSessionWithUser")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _AcceptP2PSessionWithUser(IntPtr self, SteamId steamIDRemote);

	internal bool AcceptP2PSessionWithUser(SteamId steamIDRemote)
	{
		return _AcceptP2PSessionWithUser(Self, steamIDRemote);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworking_CloseP2PSessionWithUser")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _CloseP2PSessionWithUser(IntPtr self, SteamId steamIDRemote);

	internal bool CloseP2PSessionWithUser(SteamId steamIDRemote)
	{
		return _CloseP2PSessionWithUser(Self, steamIDRemote);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworking_CloseP2PChannelWithUser")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _CloseP2PChannelWithUser(IntPtr self, SteamId steamIDRemote, int nChannel);

	internal bool CloseP2PChannelWithUser(SteamId steamIDRemote, int nChannel)
	{
		return _CloseP2PChannelWithUser(Self, steamIDRemote, nChannel);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworking_GetP2PSessionState")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetP2PSessionState(IntPtr self, SteamId steamIDRemote, ref P2PSessionState_t pConnectionState);

	internal bool GetP2PSessionState(SteamId steamIDRemote, ref P2PSessionState_t pConnectionState)
	{
		return _GetP2PSessionState(Self, steamIDRemote, ref pConnectionState);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworking_AllowP2PPacketRelay")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _AllowP2PPacketRelay(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bAllow);

	internal bool AllowP2PPacketRelay([MarshalAs(UnmanagedType.U1)] bool bAllow)
	{
		return _AllowP2PPacketRelay(Self, bAllow);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworking_CreateP2PConnectionSocket")]
	private static extern SNetSocket_t _CreateP2PConnectionSocket(IntPtr self, SteamId steamIDTarget, int nVirtualPort, int nTimeoutSec, [MarshalAs(UnmanagedType.U1)] bool bAllowUseOfPacketRelay);

	internal SNetSocket_t CreateP2PConnectionSocket(SteamId steamIDTarget, int nVirtualPort, int nTimeoutSec, [MarshalAs(UnmanagedType.U1)] bool bAllowUseOfPacketRelay)
	{
		return _CreateP2PConnectionSocket(Self, steamIDTarget, nVirtualPort, nTimeoutSec, bAllowUseOfPacketRelay);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamNetworkingFakeUDPPort : SteamInterface
{
	internal ISteamNetworkingFakeUDPPort(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingFakeUDPPort_DestroyFakeUDPPort")]
	private static extern void _DestroyFakeUDPPort(IntPtr self);

	internal void DestroyFakeUDPPort()
	{
		_DestroyFakeUDPPort(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingFakeUDPPort_SendMessageToFakeIP")]
	private static extern Result _SendMessageToFakeIP(IntPtr self, ref NetAddress remoteAddress, IntPtr pData, uint cbData, int nSendFlags);

	internal Result SendMessageToFakeIP(ref NetAddress remoteAddress, IntPtr pData, uint cbData, int nSendFlags)
	{
		return _SendMessageToFakeIP(Self, ref remoteAddress, pData, cbData, nSendFlags);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingFakeUDPPort_ReceiveMessages")]
	private static extern int _ReceiveMessages(IntPtr self, IntPtr ppOutMessages, int nMaxMessages);

	internal int ReceiveMessages(IntPtr ppOutMessages, int nMaxMessages)
	{
		return _ReceiveMessages(Self, ppOutMessages, nMaxMessages);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingFakeUDPPort_ScheduleCleanup")]
	private static extern void _ScheduleCleanup(IntPtr self, ref NetAddress remoteAddress);

	internal void ScheduleCleanup(ref NetAddress remoteAddress)
	{
		_ScheduleCleanup(Self, ref remoteAddress);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamNetworkingMessages : SteamInterface
{
	public const string Version = "SteamNetworkingMessages002";

	internal ISteamNetworkingMessages(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamNetworkingMessages_SteamAPI_v002();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamNetworkingMessages_SteamAPI_v002();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamGameServerNetworkingMessages_SteamAPI_v002();

	public override IntPtr GetServerInterfacePointer()
	{
		return SteamAPI_SteamGameServerNetworkingMessages_SteamAPI_v002();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingMessages_SendMessageToUser")]
	private static extern Result _SendMessageToUser(IntPtr self, ref NetIdentity identityRemote, [In][Out] IntPtr[] pubData, uint cubData, int nSendFlags, int nRemoteChannel);

	internal Result SendMessageToUser(ref NetIdentity identityRemote, [In][Out] IntPtr[] pubData, uint cubData, int nSendFlags, int nRemoteChannel)
	{
		return _SendMessageToUser(Self, ref identityRemote, pubData, cubData, nSendFlags, nRemoteChannel);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingMessages_ReceiveMessagesOnChannel")]
	private static extern int _ReceiveMessagesOnChannel(IntPtr self, int nLocalChannel, IntPtr ppOutMessages, int nMaxMessages);

	internal int ReceiveMessagesOnChannel(int nLocalChannel, IntPtr ppOutMessages, int nMaxMessages)
	{
		return _ReceiveMessagesOnChannel(Self, nLocalChannel, ppOutMessages, nMaxMessages);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingMessages_AcceptSessionWithUser")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _AcceptSessionWithUser(IntPtr self, ref NetIdentity identityRemote);

	internal bool AcceptSessionWithUser(ref NetIdentity identityRemote)
	{
		return _AcceptSessionWithUser(Self, ref identityRemote);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingMessages_CloseSessionWithUser")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _CloseSessionWithUser(IntPtr self, ref NetIdentity identityRemote);

	internal bool CloseSessionWithUser(ref NetIdentity identityRemote)
	{
		return _CloseSessionWithUser(Self, ref identityRemote);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingMessages_CloseChannelWithUser")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _CloseChannelWithUser(IntPtr self, ref NetIdentity identityRemote, int nLocalChannel);

	internal bool CloseChannelWithUser(ref NetIdentity identityRemote, int nLocalChannel)
	{
		return _CloseChannelWithUser(Self, ref identityRemote, nLocalChannel);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingMessages_GetSessionConnectionInfo")]
	private static extern ConnectionState _GetSessionConnectionInfo(IntPtr self, ref NetIdentity identityRemote, ref ConnectionInfo pConnectionInfo, ref ConnectionStatus pQuickStatus);

	internal ConnectionState GetSessionConnectionInfo(ref NetIdentity identityRemote, ref ConnectionInfo pConnectionInfo, ref ConnectionStatus pQuickStatus)
	{
		return _GetSessionConnectionInfo(Self, ref identityRemote, ref pConnectionInfo, ref pQuickStatus);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamNetworkingSockets : SteamInterface
{
	public const string Version = "SteamNetworkingSockets012";

	internal ISteamNetworkingSockets(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamNetworkingSockets_SteamAPI_v012();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamNetworkingSockets_SteamAPI_v012();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v012();

	public override IntPtr GetServerInterfacePointer()
	{
		return SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v012();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_CreateListenSocketIP")]
	private static extern Socket _CreateListenSocketIP(IntPtr self, ref NetAddress localAddress, int nOptions, [In][Out] NetKeyValue[] pOptions);

	internal Socket CreateListenSocketIP(ref NetAddress localAddress, int nOptions, [In][Out] NetKeyValue[] pOptions)
	{
		return _CreateListenSocketIP(Self, ref localAddress, nOptions, pOptions);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_ConnectByIPAddress")]
	private static extern Connection _ConnectByIPAddress(IntPtr self, ref NetAddress address, int nOptions, [In][Out] NetKeyValue[] pOptions);

	internal Connection ConnectByIPAddress(ref NetAddress address, int nOptions, [In][Out] NetKeyValue[] pOptions)
	{
		return _ConnectByIPAddress(Self, ref address, nOptions, pOptions);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2P")]
	private static extern Socket _CreateListenSocketP2P(IntPtr self, int nLocalVirtualPort, int nOptions, [In][Out] NetKeyValue[] pOptions);

	internal Socket CreateListenSocketP2P(int nLocalVirtualPort, int nOptions, [In][Out] NetKeyValue[] pOptions)
	{
		return _CreateListenSocketP2P(Self, nLocalVirtualPort, nOptions, pOptions);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_ConnectP2P")]
	private static extern Connection _ConnectP2P(IntPtr self, ref NetIdentity identityRemote, int nRemoteVirtualPort, int nOptions, [In][Out] NetKeyValue[] pOptions);

	internal Connection ConnectP2P(ref NetIdentity identityRemote, int nRemoteVirtualPort, int nOptions, [In][Out] NetKeyValue[] pOptions)
	{
		return _ConnectP2P(Self, ref identityRemote, nRemoteVirtualPort, nOptions, pOptions);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_AcceptConnection")]
	private static extern Result _AcceptConnection(IntPtr self, Connection hConn);

	internal Result AcceptConnection(Connection hConn)
	{
		return _AcceptConnection(Self, hConn);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_CloseConnection")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _CloseConnection(IntPtr self, Connection hPeer, int nReason, IntPtr pszDebug, [MarshalAs(UnmanagedType.U1)] bool bEnableLinger);

	internal bool CloseConnection(Connection hPeer, int nReason, string pszDebug, [MarshalAs(UnmanagedType.U1)] bool bEnableLinger)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszDebug);
		return _CloseConnection(Self, hPeer, nReason, utf8StringToNative.Pointer, bEnableLinger);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_CloseListenSocket")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _CloseListenSocket(IntPtr self, Socket hSocket);

	internal bool CloseListenSocket(Socket hSocket)
	{
		return _CloseListenSocket(Self, hSocket);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_SetConnectionUserData")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetConnectionUserData(IntPtr self, Connection hPeer, long nUserData);

	internal bool SetConnectionUserData(Connection hPeer, long nUserData)
	{
		return _SetConnectionUserData(Self, hPeer, nUserData);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_GetConnectionUserData")]
	private static extern long _GetConnectionUserData(IntPtr self, Connection hPeer);

	internal long GetConnectionUserData(Connection hPeer)
	{
		return _GetConnectionUserData(Self, hPeer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_SetConnectionName")]
	private static extern void _SetConnectionName(IntPtr self, Connection hPeer, IntPtr pszName);

	internal void SetConnectionName(Connection hPeer, string pszName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszName);
		_SetConnectionName(Self, hPeer, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_GetConnectionName")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetConnectionName(IntPtr self, Connection hPeer, IntPtr pszName, int nMaxLen);

	internal bool GetConnectionName(Connection hPeer, out string pszName)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			bool result = _GetConnectionName(Self, hPeer, m, 32768);
			pszName = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_SendMessageToConnection")]
	private static extern Result _SendMessageToConnection(IntPtr self, Connection hConn, IntPtr pData, uint cbData, int nSendFlags, ref long pOutMessageNumber);

	internal Result SendMessageToConnection(Connection hConn, IntPtr pData, uint cbData, int nSendFlags, ref long pOutMessageNumber)
	{
		return _SendMessageToConnection(Self, hConn, pData, cbData, nSendFlags, ref pOutMessageNumber);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_SendMessages")]
	private unsafe static extern void _SendMessages(IntPtr self, int nMessages, NetMsg** pMessages, long* pOutMessageNumberOrResult);

	internal unsafe void SendMessages(int nMessages, NetMsg** pMessages, long* pOutMessageNumberOrResult)
	{
		_SendMessages(Self, nMessages, pMessages, pOutMessageNumberOrResult);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_FlushMessagesOnConnection")]
	private static extern Result _FlushMessagesOnConnection(IntPtr self, Connection hConn);

	internal Result FlushMessagesOnConnection(Connection hConn)
	{
		return _FlushMessagesOnConnection(Self, hConn);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnConnection")]
	private static extern int _ReceiveMessagesOnConnection(IntPtr self, Connection hConn, IntPtr ppOutMessages, int nMaxMessages);

	internal int ReceiveMessagesOnConnection(Connection hConn, IntPtr ppOutMessages, int nMaxMessages)
	{
		return _ReceiveMessagesOnConnection(Self, hConn, ppOutMessages, nMaxMessages);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_GetConnectionInfo")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetConnectionInfo(IntPtr self, Connection hConn, ref ConnectionInfo pInfo);

	internal bool GetConnectionInfo(Connection hConn, ref ConnectionInfo pInfo)
	{
		return _GetConnectionInfo(Self, hConn, ref pInfo);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_GetConnectionRealTimeStatus")]
	private static extern Result _GetConnectionRealTimeStatus(IntPtr self, Connection hConn, ref ConnectionStatus pStatus, int nLanes, [In][Out] ConnectionLaneStatus[] pLanes);

	internal Result GetConnectionRealTimeStatus(Connection hConn, ref ConnectionStatus pStatus, int nLanes, [In][Out] ConnectionLaneStatus[] pLanes)
	{
		return _GetConnectionRealTimeStatus(Self, hConn, ref pStatus, nLanes, pLanes);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_GetDetailedConnectionStatus")]
	private static extern int _GetDetailedConnectionStatus(IntPtr self, Connection hConn, IntPtr pszBuf, int cbBuf);

	internal int GetDetailedConnectionStatus(Connection hConn, out string pszBuf)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			int result = _GetDetailedConnectionStatus(Self, hConn, m, 32768);
			pszBuf = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_GetListenSocketAddress")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetListenSocketAddress(IntPtr self, Socket hSocket, ref NetAddress address);

	internal bool GetListenSocketAddress(Socket hSocket, ref NetAddress address)
	{
		return _GetListenSocketAddress(Self, hSocket, ref address);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_CreateSocketPair")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _CreateSocketPair(IntPtr self, [In][Out] Connection[] pOutConnection1, [In][Out] Connection[] pOutConnection2, [MarshalAs(UnmanagedType.U1)] bool bUseNetworkLoopback, ref NetIdentity pIdentity1, ref NetIdentity pIdentity2);

	internal bool CreateSocketPair([In][Out] Connection[] pOutConnection1, [In][Out] Connection[] pOutConnection2, [MarshalAs(UnmanagedType.U1)] bool bUseNetworkLoopback, ref NetIdentity pIdentity1, ref NetIdentity pIdentity2)
	{
		return _CreateSocketPair(Self, pOutConnection1, pOutConnection2, bUseNetworkLoopback, ref pIdentity1, ref pIdentity2);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_ConfigureConnectionLanes")]
	private static extern Result _ConfigureConnectionLanes(IntPtr self, Connection hConn, int nNumLanes, [In][Out] int[] pLanePriorities, [In][Out] ushort[] pLaneWeights);

	internal Result ConfigureConnectionLanes(Connection hConn, int nNumLanes, [In][Out] int[] pLanePriorities, [In][Out] ushort[] pLaneWeights)
	{
		return _ConfigureConnectionLanes(Self, hConn, nNumLanes, pLanePriorities, pLaneWeights);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_GetIdentity")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetIdentity(IntPtr self, ref NetIdentity pIdentity);

	internal bool GetIdentity(ref NetIdentity pIdentity)
	{
		return _GetIdentity(Self, ref pIdentity);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_InitAuthentication")]
	private static extern SteamNetworkingAvailability _InitAuthentication(IntPtr self);

	internal SteamNetworkingAvailability InitAuthentication()
	{
		return _InitAuthentication(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_GetAuthenticationStatus")]
	private static extern SteamNetworkingAvailability _GetAuthenticationStatus(IntPtr self, ref SteamNetAuthenticationStatus_t pDetails);

	internal SteamNetworkingAvailability GetAuthenticationStatus(ref SteamNetAuthenticationStatus_t pDetails)
	{
		return _GetAuthenticationStatus(Self, ref pDetails);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_CreatePollGroup")]
	private static extern HSteamNetPollGroup _CreatePollGroup(IntPtr self);

	internal HSteamNetPollGroup CreatePollGroup()
	{
		return _CreatePollGroup(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_DestroyPollGroup")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _DestroyPollGroup(IntPtr self, HSteamNetPollGroup hPollGroup);

	internal bool DestroyPollGroup(HSteamNetPollGroup hPollGroup)
	{
		return _DestroyPollGroup(Self, hPollGroup);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_SetConnectionPollGroup")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetConnectionPollGroup(IntPtr self, Connection hConn, HSteamNetPollGroup hPollGroup);

	internal bool SetConnectionPollGroup(Connection hConn, HSteamNetPollGroup hPollGroup)
	{
		return _SetConnectionPollGroup(Self, hConn, hPollGroup);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnPollGroup")]
	private static extern int _ReceiveMessagesOnPollGroup(IntPtr self, HSteamNetPollGroup hPollGroup, IntPtr ppOutMessages, int nMaxMessages);

	internal int ReceiveMessagesOnPollGroup(HSteamNetPollGroup hPollGroup, IntPtr ppOutMessages, int nMaxMessages)
	{
		return _ReceiveMessagesOnPollGroup(Self, hPollGroup, ppOutMessages, nMaxMessages);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_ReceivedRelayAuthTicket")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _ReceivedRelayAuthTicket(IntPtr self, IntPtr pvTicket, int cbTicket, [In][Out] SteamDatagramRelayAuthTicket[] pOutParsedTicket);

	internal bool ReceivedRelayAuthTicket(IntPtr pvTicket, int cbTicket, [In][Out] SteamDatagramRelayAuthTicket[] pOutParsedTicket)
	{
		return _ReceivedRelayAuthTicket(Self, pvTicket, cbTicket, pOutParsedTicket);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_FindRelayAuthTicketForServer")]
	private static extern int _FindRelayAuthTicketForServer(IntPtr self, ref NetIdentity identityGameServer, int nRemoteVirtualPort, [In][Out] SteamDatagramRelayAuthTicket[] pOutParsedTicket);

	internal int FindRelayAuthTicketForServer(ref NetIdentity identityGameServer, int nRemoteVirtualPort, [In][Out] SteamDatagramRelayAuthTicket[] pOutParsedTicket)
	{
		return _FindRelayAuthTicketForServer(Self, ref identityGameServer, nRemoteVirtualPort, pOutParsedTicket);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_ConnectToHostedDedicatedServer")]
	private static extern Connection _ConnectToHostedDedicatedServer(IntPtr self, ref NetIdentity identityTarget, int nRemoteVirtualPort, int nOptions, [In][Out] NetKeyValue[] pOptions);

	internal Connection ConnectToHostedDedicatedServer(ref NetIdentity identityTarget, int nRemoteVirtualPort, int nOptions, [In][Out] NetKeyValue[] pOptions)
	{
		return _ConnectToHostedDedicatedServer(Self, ref identityTarget, nRemoteVirtualPort, nOptions, pOptions);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPort")]
	private static extern ushort _GetHostedDedicatedServerPort(IntPtr self);

	internal ushort GetHostedDedicatedServerPort()
	{
		return _GetHostedDedicatedServerPort(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPOPID")]
	private static extern SteamNetworkingPOPID _GetHostedDedicatedServerPOPID(IntPtr self);

	internal SteamNetworkingPOPID GetHostedDedicatedServerPOPID()
	{
		return _GetHostedDedicatedServerPOPID(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerAddress")]
	private static extern Result _GetHostedDedicatedServerAddress(IntPtr self, ref SteamDatagramHostedAddress pRouting);

	internal Result GetHostedDedicatedServerAddress(ref SteamDatagramHostedAddress pRouting)
	{
		return _GetHostedDedicatedServerAddress(Self, ref pRouting);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_CreateHostedDedicatedServerListenSocket")]
	private static extern Socket _CreateHostedDedicatedServerListenSocket(IntPtr self, int nLocalVirtualPort, int nOptions, [In][Out] NetKeyValue[] pOptions);

	internal Socket CreateHostedDedicatedServerListenSocket(int nLocalVirtualPort, int nOptions, [In][Out] NetKeyValue[] pOptions)
	{
		return _CreateHostedDedicatedServerListenSocket(Self, nLocalVirtualPort, nOptions, pOptions);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_GetGameCoordinatorServerLogin")]
	private static extern Result _GetGameCoordinatorServerLogin(IntPtr self, ref SteamDatagramGameCoordinatorServerLogin pLoginInfo, ref int pcbSignedBlob, IntPtr pBlob);

	internal Result GetGameCoordinatorServerLogin(ref SteamDatagramGameCoordinatorServerLogin pLoginInfo, ref int pcbSignedBlob, IntPtr pBlob)
	{
		return _GetGameCoordinatorServerLogin(Self, ref pLoginInfo, ref pcbSignedBlob, pBlob);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_ConnectP2PCustomSignaling")]
	private static extern Connection _ConnectP2PCustomSignaling(IntPtr self, IntPtr pSignaling, ref NetIdentity pPeerIdentity, int nRemoteVirtualPort, int nOptions, [In][Out] NetKeyValue[] pOptions);

	internal Connection ConnectP2PCustomSignaling(IntPtr pSignaling, ref NetIdentity pPeerIdentity, int nRemoteVirtualPort, int nOptions, [In][Out] NetKeyValue[] pOptions)
	{
		return _ConnectP2PCustomSignaling(Self, pSignaling, ref pPeerIdentity, nRemoteVirtualPort, nOptions, pOptions);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_ReceivedP2PCustomSignal")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _ReceivedP2PCustomSignal(IntPtr self, IntPtr pMsg, int cbMsg, IntPtr pContext);

	internal bool ReceivedP2PCustomSignal(IntPtr pMsg, int cbMsg, IntPtr pContext)
	{
		return _ReceivedP2PCustomSignal(Self, pMsg, cbMsg, pContext);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_GetCertificateRequest")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetCertificateRequest(IntPtr self, ref int pcbBlob, IntPtr pBlob, ref NetErrorMessage errMsg);

	internal bool GetCertificateRequest(ref int pcbBlob, IntPtr pBlob, ref NetErrorMessage errMsg)
	{
		return _GetCertificateRequest(Self, ref pcbBlob, pBlob, ref errMsg);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_SetCertificate")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetCertificate(IntPtr self, IntPtr pCertificate, int cbCertificate, ref NetErrorMessage errMsg);

	internal bool SetCertificate(IntPtr pCertificate, int cbCertificate, ref NetErrorMessage errMsg)
	{
		return _SetCertificate(Self, pCertificate, cbCertificate, ref errMsg);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_ResetIdentity")]
	private static extern void _ResetIdentity(IntPtr self, ref NetIdentity pIdentity);

	internal void ResetIdentity(ref NetIdentity pIdentity)
	{
		_ResetIdentity(Self, ref pIdentity);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_RunCallbacks")]
	private static extern void _RunCallbacks(IntPtr self);

	internal void RunCallbacks()
	{
		_RunCallbacks(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_BeginAsyncRequestFakeIP")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BeginAsyncRequestFakeIP(IntPtr self, int nNumPorts);

	internal bool BeginAsyncRequestFakeIP(int nNumPorts)
	{
		return _BeginAsyncRequestFakeIP(Self, nNumPorts);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_GetFakeIP")]
	private static extern void _GetFakeIP(IntPtr self, int idxFirstPort, ref SteamNetworkingFakeIPResult_t pInfo);

	internal void GetFakeIP(int idxFirstPort, ref SteamNetworkingFakeIPResult_t pInfo)
	{
		_GetFakeIP(Self, idxFirstPort, ref pInfo);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2PFakeIP")]
	private static extern Socket _CreateListenSocketP2PFakeIP(IntPtr self, int idxFakePort, int nOptions, [In][Out] NetKeyValue[] pOptions);

	internal Socket CreateListenSocketP2PFakeIP(int idxFakePort, int nOptions, [In][Out] NetKeyValue[] pOptions)
	{
		return _CreateListenSocketP2PFakeIP(Self, idxFakePort, nOptions, pOptions);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_GetRemoteFakeIPForConnection")]
	private static extern Result _GetRemoteFakeIPForConnection(IntPtr self, Connection hConn, [In][Out] NetAddress[] pOutAddr);

	internal Result GetRemoteFakeIPForConnection(Connection hConn, [In][Out] NetAddress[] pOutAddr)
	{
		return _GetRemoteFakeIPForConnection(Self, hConn, pOutAddr);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingSockets_CreateFakeUDPPort")]
	private static extern IntPtr _CreateFakeUDPPort(IntPtr self, int idxFakeServerPort);

	internal IntPtr CreateFakeUDPPort(int idxFakeServerPort)
	{
		return _CreateFakeUDPPort(Self, idxFakeServerPort);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamNetworkingUtils : SteamInterface
{
	public const string Version = "SteamNetworkingUtils004";

	internal ISteamNetworkingUtils(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamNetworkingUtils_SteamAPI_v004();

	public override IntPtr GetGlobalInterfacePointer()
	{
		return SteamAPI_SteamNetworkingUtils_SteamAPI_v004();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_AllocateMessage")]
	private unsafe static extern NetMsg* _AllocateMessage(IntPtr self, int cbAllocateBuffer);

	internal unsafe NetMsg* AllocateMessage(int cbAllocateBuffer)
	{
		return _AllocateMessage(Self, cbAllocateBuffer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_InitRelayNetworkAccess")]
	private static extern void _InitRelayNetworkAccess(IntPtr self);

	internal void InitRelayNetworkAccess()
	{
		_InitRelayNetworkAccess(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_GetRelayNetworkStatus")]
	private static extern SteamNetworkingAvailability _GetRelayNetworkStatus(IntPtr self, ref SteamRelayNetworkStatus_t pDetails);

	internal SteamNetworkingAvailability GetRelayNetworkStatus(ref SteamRelayNetworkStatus_t pDetails)
	{
		return _GetRelayNetworkStatus(Self, ref pDetails);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_GetLocalPingLocation")]
	private static extern float _GetLocalPingLocation(IntPtr self, ref NetPingLocation result);

	internal float GetLocalPingLocation(ref NetPingLocation result)
	{
		return _GetLocalPingLocation(Self, ref result);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_EstimatePingTimeBetweenTwoLocations")]
	private static extern int _EstimatePingTimeBetweenTwoLocations(IntPtr self, ref NetPingLocation location1, ref NetPingLocation location2);

	internal int EstimatePingTimeBetweenTwoLocations(ref NetPingLocation location1, ref NetPingLocation location2)
	{
		return _EstimatePingTimeBetweenTwoLocations(Self, ref location1, ref location2);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_EstimatePingTimeFromLocalHost")]
	private static extern int _EstimatePingTimeFromLocalHost(IntPtr self, ref NetPingLocation remoteLocation);

	internal int EstimatePingTimeFromLocalHost(ref NetPingLocation remoteLocation)
	{
		return _EstimatePingTimeFromLocalHost(Self, ref remoteLocation);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_ConvertPingLocationToString")]
	private static extern void _ConvertPingLocationToString(IntPtr self, ref NetPingLocation location, IntPtr pszBuf, int cchBufSize);

	internal void ConvertPingLocationToString(ref NetPingLocation location, out string pszBuf)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			_ConvertPingLocationToString(Self, ref location, m, 32768);
			pszBuf = Helpers.MemoryToString(m);
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_ParsePingLocationString")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _ParsePingLocationString(IntPtr self, IntPtr pszString, ref NetPingLocation result);

	internal bool ParsePingLocationString(string pszString, ref NetPingLocation result)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszString);
		return _ParsePingLocationString(Self, utf8StringToNative.Pointer, ref result);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_CheckPingDataUpToDate")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _CheckPingDataUpToDate(IntPtr self, float flMaxAgeSeconds);

	internal bool CheckPingDataUpToDate(float flMaxAgeSeconds)
	{
		return _CheckPingDataUpToDate(Self, flMaxAgeSeconds);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_GetPingToDataCenter")]
	private static extern int _GetPingToDataCenter(IntPtr self, SteamNetworkingPOPID popID, ref SteamNetworkingPOPID pViaRelayPoP);

	internal int GetPingToDataCenter(SteamNetworkingPOPID popID, ref SteamNetworkingPOPID pViaRelayPoP)
	{
		return _GetPingToDataCenter(Self, popID, ref pViaRelayPoP);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_GetDirectPingToPOP")]
	private static extern int _GetDirectPingToPOP(IntPtr self, SteamNetworkingPOPID popID);

	internal int GetDirectPingToPOP(SteamNetworkingPOPID popID)
	{
		return _GetDirectPingToPOP(Self, popID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_GetPOPCount")]
	private static extern int _GetPOPCount(IntPtr self);

	internal int GetPOPCount()
	{
		return _GetPOPCount(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_GetPOPList")]
	private static extern int _GetPOPList(IntPtr self, ref SteamNetworkingPOPID list, int nListSz);

	internal int GetPOPList(ref SteamNetworkingPOPID list, int nListSz)
	{
		return _GetPOPList(Self, ref list, nListSz);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_GetLocalTimestamp")]
	private static extern long _GetLocalTimestamp(IntPtr self);

	internal long GetLocalTimestamp()
	{
		return _GetLocalTimestamp(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_SetDebugOutputFunction")]
	private static extern void _SetDebugOutputFunction(IntPtr self, NetDebugOutput eDetailLevel, NetDebugFunc pfnFunc);

	internal void SetDebugOutputFunction(NetDebugOutput eDetailLevel, NetDebugFunc pfnFunc)
	{
		_SetDebugOutputFunction(Self, eDetailLevel, pfnFunc);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_IsFakeIPv4")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _IsFakeIPv4(IntPtr self, uint nIPv4);

	internal bool IsFakeIPv4(uint nIPv4)
	{
		return _IsFakeIPv4(Self, nIPv4);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_GetIPv4FakeIPType")]
	private static extern SteamNetworkingFakeIPType _GetIPv4FakeIPType(IntPtr self, uint nIPv4);

	internal SteamNetworkingFakeIPType GetIPv4FakeIPType(uint nIPv4)
	{
		return _GetIPv4FakeIPType(Self, nIPv4);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_GetRealIdentityForFakeIP")]
	private static extern Result _GetRealIdentityForFakeIP(IntPtr self, ref NetAddress fakeIP, [In][Out] NetIdentity[] pOutRealIdentity);

	internal Result GetRealIdentityForFakeIP(ref NetAddress fakeIP, [In][Out] NetIdentity[] pOutRealIdentity)
	{
		return _GetRealIdentityForFakeIP(Self, ref fakeIP, pOutRealIdentity);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueInt32")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetGlobalConfigValueInt32(IntPtr self, NetConfig eValue, int val);

	internal bool SetGlobalConfigValueInt32(NetConfig eValue, int val)
	{
		return _SetGlobalConfigValueInt32(Self, eValue, val);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueFloat")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetGlobalConfigValueFloat(IntPtr self, NetConfig eValue, float val);

	internal bool SetGlobalConfigValueFloat(NetConfig eValue, float val)
	{
		return _SetGlobalConfigValueFloat(Self, eValue, val);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueString")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetGlobalConfigValueString(IntPtr self, NetConfig eValue, IntPtr val);

	internal bool SetGlobalConfigValueString(NetConfig eValue, string val)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(val);
		return _SetGlobalConfigValueString(Self, eValue, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValuePtr")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetGlobalConfigValuePtr(IntPtr self, NetConfig eValue, IntPtr val);

	internal bool SetGlobalConfigValuePtr(NetConfig eValue, IntPtr val)
	{
		return _SetGlobalConfigValuePtr(Self, eValue, val);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueInt32")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetConnectionConfigValueInt32(IntPtr self, Connection hConn, NetConfig eValue, int val);

	internal bool SetConnectionConfigValueInt32(Connection hConn, NetConfig eValue, int val)
	{
		return _SetConnectionConfigValueInt32(Self, hConn, eValue, val);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueFloat")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetConnectionConfigValueFloat(IntPtr self, Connection hConn, NetConfig eValue, float val);

	internal bool SetConnectionConfigValueFloat(Connection hConn, NetConfig eValue, float val)
	{
		return _SetConnectionConfigValueFloat(Self, hConn, eValue, val);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueString")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetConnectionConfigValueString(IntPtr self, Connection hConn, NetConfig eValue, IntPtr val);

	internal bool SetConnectionConfigValueString(Connection hConn, NetConfig eValue, string val)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(val);
		return _SetConnectionConfigValueString(Self, hConn, eValue, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetConnectionStatusChanged")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetGlobalCallback_SteamNetConnectionStatusChanged(IntPtr self, FnSteamNetConnectionStatusChanged fnCallback);

	internal bool SetGlobalCallback_SteamNetConnectionStatusChanged(FnSteamNetConnectionStatusChanged fnCallback)
	{
		return _SetGlobalCallback_SteamNetConnectionStatusChanged(Self, fnCallback);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetAuthenticationStatusChanged")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetGlobalCallback_SteamNetAuthenticationStatusChanged(IntPtr self, FnSteamNetAuthenticationStatusChanged fnCallback);

	internal bool SetGlobalCallback_SteamNetAuthenticationStatusChanged(FnSteamNetAuthenticationStatusChanged fnCallback)
	{
		return _SetGlobalCallback_SteamNetAuthenticationStatusChanged(Self, fnCallback);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamRelayNetworkStatusChanged")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetGlobalCallback_SteamRelayNetworkStatusChanged(IntPtr self, FnSteamRelayNetworkStatusChanged fnCallback);

	internal bool SetGlobalCallback_SteamRelayNetworkStatusChanged(FnSteamRelayNetworkStatusChanged fnCallback)
	{
		return _SetGlobalCallback_SteamRelayNetworkStatusChanged(Self, fnCallback);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_FakeIPResult")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetGlobalCallback_FakeIPResult(IntPtr self, FnSteamNetworkingFakeIPResult fnCallback);

	internal bool SetGlobalCallback_FakeIPResult(FnSteamNetworkingFakeIPResult fnCallback)
	{
		return _SetGlobalCallback_FakeIPResult(Self, fnCallback);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionRequest")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetGlobalCallback_MessagesSessionRequest(IntPtr self, FnSteamNetworkingMessagesSessionRequest fnCallback);

	internal bool SetGlobalCallback_MessagesSessionRequest(FnSteamNetworkingMessagesSessionRequest fnCallback)
	{
		return _SetGlobalCallback_MessagesSessionRequest(Self, fnCallback);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionFailed")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetGlobalCallback_MessagesSessionFailed(IntPtr self, FnSteamNetworkingMessagesSessionFailed fnCallback);

	internal bool SetGlobalCallback_MessagesSessionFailed(FnSteamNetworkingMessagesSessionFailed fnCallback)
	{
		return _SetGlobalCallback_MessagesSessionFailed(Self, fnCallback);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_SetConfigValue")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetConfigValue(IntPtr self, NetConfig eValue, NetConfigScope eScopeType, IntPtr scopeObj, NetConfigType eDataType, IntPtr pArg);

	internal bool SetConfigValue(NetConfig eValue, NetConfigScope eScopeType, IntPtr scopeObj, NetConfigType eDataType, IntPtr pArg)
	{
		return _SetConfigValue(Self, eValue, eScopeType, scopeObj, eDataType, pArg);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_SetConfigValueStruct")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetConfigValueStruct(IntPtr self, ref NetKeyValue opt, NetConfigScope eScopeType, IntPtr scopeObj);

	internal bool SetConfigValueStruct(ref NetKeyValue opt, NetConfigScope eScopeType, IntPtr scopeObj)
	{
		return _SetConfigValueStruct(Self, ref opt, eScopeType, scopeObj);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_GetConfigValue")]
	private static extern NetConfigResult _GetConfigValue(IntPtr self, NetConfig eValue, NetConfigScope eScopeType, IntPtr scopeObj, ref NetConfigType pOutDataType, IntPtr pResult, ref UIntPtr cbResult);

	internal NetConfigResult GetConfigValue(NetConfig eValue, NetConfigScope eScopeType, IntPtr scopeObj, ref NetConfigType pOutDataType, IntPtr pResult, ref UIntPtr cbResult)
	{
		return _GetConfigValue(Self, eValue, eScopeType, scopeObj, ref pOutDataType, pResult, ref cbResult);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_GetConfigValueInfo")]
	private static extern Utf8StringPointer _GetConfigValueInfo(IntPtr self, NetConfig eValue, ref NetConfigType pOutDataType, [In][Out] NetConfigScope[] pOutScope);

	internal string GetConfigValueInfo(NetConfig eValue, ref NetConfigType pOutDataType, [In][Out] NetConfigScope[] pOutScope)
	{
		return _GetConfigValueInfo(Self, eValue, ref pOutDataType, pOutScope);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_IterateGenericEditableConfigValues")]
	private static extern NetConfig _IterateGenericEditableConfigValues(IntPtr self, NetConfig eCurrent, [MarshalAs(UnmanagedType.U1)] bool bEnumerateDevVars);

	internal NetConfig IterateGenericEditableConfigValues(NetConfig eCurrent, [MarshalAs(UnmanagedType.U1)] bool bEnumerateDevVars)
	{
		return _IterateGenericEditableConfigValues(Self, eCurrent, bEnumerateDevVars);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ToString")]
	private static extern void _SteamNetworkingIPAddr_ToString(IntPtr self, ref NetAddress addr, IntPtr buf, uint cbBuf, [MarshalAs(UnmanagedType.U1)] bool bWithPort);

	internal void SteamNetworkingIPAddr_ToString(ref NetAddress addr, out string buf, [MarshalAs(UnmanagedType.U1)] bool bWithPort)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			_SteamNetworkingIPAddr_ToString(Self, ref addr, m, 32768u, bWithPort);
			buf = Helpers.MemoryToString(m);
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ParseString")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SteamNetworkingIPAddr_ParseString(IntPtr self, ref NetAddress pAddr, IntPtr pszStr);

	internal bool SteamNetworkingIPAddr_ParseString(ref NetAddress pAddr, string pszStr)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszStr);
		return _SteamNetworkingIPAddr_ParseString(Self, ref pAddr, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_GetFakeIPType")]
	private static extern SteamNetworkingFakeIPType _SteamNetworkingIPAddr_GetFakeIPType(IntPtr self, ref NetAddress addr);

	internal SteamNetworkingFakeIPType SteamNetworkingIPAddr_GetFakeIPType(ref NetAddress addr)
	{
		return _SteamNetworkingIPAddr_GetFakeIPType(Self, ref addr);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ToString")]
	private static extern void _SteamNetworkingIdentity_ToString(IntPtr self, ref NetIdentity identity, IntPtr buf, uint cbBuf);

	internal void SteamNetworkingIdentity_ToString(ref NetIdentity identity, out string buf)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			_SteamNetworkingIdentity_ToString(Self, ref identity, m, 32768u);
			buf = Helpers.MemoryToString(m);
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ParseString")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SteamNetworkingIdentity_ParseString(IntPtr self, ref NetIdentity pIdentity, IntPtr pszStr);

	internal bool SteamNetworkingIdentity_ParseString(ref NetIdentity pIdentity, string pszStr)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszStr);
		return _SteamNetworkingIdentity_ParseString(Self, ref pIdentity, utf8StringToNative.Pointer);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;

internal class ISteamParentalSettings : SteamInterface
{
	public const string Version = "STEAMPARENTALSETTINGS_INTERFACE_VERSION001";

	internal ISteamParentalSettings(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamParentalSettings_v001();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamParentalSettings_v001();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamParentalSettings_BIsParentalLockEnabled")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsParentalLockEnabled(IntPtr self);

	internal bool BIsParentalLockEnabled()
	{
		return _BIsParentalLockEnabled(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamParentalSettings_BIsParentalLockLocked")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsParentalLockLocked(IntPtr self);

	internal bool BIsParentalLockLocked()
	{
		return _BIsParentalLockLocked(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamParentalSettings_BIsAppBlocked")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsAppBlocked(IntPtr self, AppId nAppID);

	internal bool BIsAppBlocked(AppId nAppID)
	{
		return _BIsAppBlocked(Self, nAppID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamParentalSettings_BIsAppInBlockList")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsAppInBlockList(IntPtr self, AppId nAppID);

	internal bool BIsAppInBlockList(AppId nAppID)
	{
		return _BIsAppInBlockList(Self, nAppID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamParentalSettings_BIsFeatureBlocked")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsFeatureBlocked(IntPtr self, ParentalFeature eFeature);

	internal bool BIsFeatureBlocked(ParentalFeature eFeature)
	{
		return _BIsFeatureBlocked(Self, eFeature);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamParentalSettings_BIsFeatureInBlockList")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsFeatureInBlockList(IntPtr self, ParentalFeature eFeature);

	internal bool BIsFeatureInBlockList(ParentalFeature eFeature)
	{
		return _BIsFeatureInBlockList(Self, eFeature);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamParties : SteamInterface
{
	public const string Version = "SteamParties002";

	internal ISteamParties(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamParties_v002();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamParties_v002();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamParties_GetNumActiveBeacons")]
	private static extern uint _GetNumActiveBeacons(IntPtr self);

	internal uint GetNumActiveBeacons()
	{
		return _GetNumActiveBeacons(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamParties_GetBeaconByIndex")]
	private static extern PartyBeaconID_t _GetBeaconByIndex(IntPtr self, uint unIndex);

	internal PartyBeaconID_t GetBeaconByIndex(uint unIndex)
	{
		return _GetBeaconByIndex(Self, unIndex);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamParties_GetBeaconDetails")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetBeaconDetails(IntPtr self, PartyBeaconID_t ulBeaconID, ref SteamId pSteamIDBeaconOwner, ref SteamPartyBeaconLocation_t pLocation, IntPtr pchMetadata, int cchMetadata);

	internal bool GetBeaconDetails(PartyBeaconID_t ulBeaconID, ref SteamId pSteamIDBeaconOwner, ref SteamPartyBeaconLocation_t pLocation, out string pchMetadata)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			bool result = _GetBeaconDetails(Self, ulBeaconID, ref pSteamIDBeaconOwner, ref pLocation, m, 32768);
			pchMetadata = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamParties_JoinParty")]
	private static extern SteamAPICall_t _JoinParty(IntPtr self, PartyBeaconID_t ulBeaconID);

	internal CallResult<JoinPartyCallback_t> JoinParty(PartyBeaconID_t ulBeaconID)
	{
		return new CallResult<JoinPartyCallback_t>(_JoinParty(Self, ulBeaconID), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamParties_GetNumAvailableBeaconLocations")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetNumAvailableBeaconLocations(IntPtr self, ref uint puNumLocations);

	internal bool GetNumAvailableBeaconLocations(ref uint puNumLocations)
	{
		return _GetNumAvailableBeaconLocations(Self, ref puNumLocations);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamParties_GetAvailableBeaconLocations")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetAvailableBeaconLocations(IntPtr self, ref SteamPartyBeaconLocation_t pLocationList, uint uMaxNumLocations);

	internal bool GetAvailableBeaconLocations(ref SteamPartyBeaconLocation_t pLocationList, uint uMaxNumLocations)
	{
		return _GetAvailableBeaconLocations(Self, ref pLocationList, uMaxNumLocations);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamParties_CreateBeacon")]
	private static extern SteamAPICall_t _CreateBeacon(IntPtr self, uint unOpenSlots, ref SteamPartyBeaconLocation_t pBeaconLocation, IntPtr pchConnectString, IntPtr pchMetadata);

	internal CallResult<CreateBeaconCallback_t> CreateBeacon(uint unOpenSlots, SteamPartyBeaconLocation_t pBeaconLocation, string pchConnectString, string pchMetadata)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchConnectString);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchMetadata);
		return new CallResult<CreateBeaconCallback_t>(_CreateBeacon(Self, unOpenSlots, ref pBeaconLocation, utf8StringToNative.Pointer, utf8StringToNative2.Pointer), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamParties_OnReservationCompleted")]
	private static extern void _OnReservationCompleted(IntPtr self, PartyBeaconID_t ulBeacon, SteamId steamIDUser);

	internal void OnReservationCompleted(PartyBeaconID_t ulBeacon, SteamId steamIDUser)
	{
		_OnReservationCompleted(Self, ulBeacon, steamIDUser);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamParties_CancelReservation")]
	private static extern void _CancelReservation(IntPtr self, PartyBeaconID_t ulBeacon, SteamId steamIDUser);

	internal void CancelReservation(PartyBeaconID_t ulBeacon, SteamId steamIDUser)
	{
		_CancelReservation(Self, ulBeacon, steamIDUser);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamParties_ChangeNumOpenSlots")]
	private static extern SteamAPICall_t _ChangeNumOpenSlots(IntPtr self, PartyBeaconID_t ulBeacon, uint unOpenSlots);

	internal CallResult<ChangeNumOpenSlotsCallback_t> ChangeNumOpenSlots(PartyBeaconID_t ulBeacon, uint unOpenSlots)
	{
		return new CallResult<ChangeNumOpenSlotsCallback_t>(_ChangeNumOpenSlots(Self, ulBeacon, unOpenSlots), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamParties_DestroyBeacon")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _DestroyBeacon(IntPtr self, PartyBeaconID_t ulBeacon);

	internal bool DestroyBeacon(PartyBeaconID_t ulBeacon)
	{
		return _DestroyBeacon(Self, ulBeacon);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamParties_GetBeaconLocationData")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetBeaconLocationData(IntPtr self, SteamPartyBeaconLocation_t BeaconLocation, SteamPartyBeaconLocationData eData, IntPtr pchDataStringOut, int cchDataStringOut);

	internal bool GetBeaconLocationData(SteamPartyBeaconLocation_t BeaconLocation, SteamPartyBeaconLocationData eData, out string pchDataStringOut)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			bool result = _GetBeaconLocationData(Self, BeaconLocation, eData, m, 32768);
			pchDataStringOut = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamRemotePlay : SteamInterface
{
	public const string Version = "STEAMREMOTEPLAY_INTERFACE_VERSION002";

	internal ISteamRemotePlay(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamRemotePlay_v002();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamRemotePlay_v002();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemotePlay_GetSessionCount")]
	private static extern uint _GetSessionCount(IntPtr self);

	internal uint GetSessionCount()
	{
		return _GetSessionCount(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemotePlay_GetSessionID")]
	private static extern RemotePlaySessionID_t _GetSessionID(IntPtr self, int iSessionIndex);

	internal RemotePlaySessionID_t GetSessionID(int iSessionIndex)
	{
		return _GetSessionID(Self, iSessionIndex);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemotePlay_GetSessionSteamID")]
	private static extern SteamId _GetSessionSteamID(IntPtr self, RemotePlaySessionID_t unSessionID);

	internal SteamId GetSessionSteamID(RemotePlaySessionID_t unSessionID)
	{
		return _GetSessionSteamID(Self, unSessionID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemotePlay_GetSessionClientName")]
	private static extern Utf8StringPointer _GetSessionClientName(IntPtr self, RemotePlaySessionID_t unSessionID);

	internal string GetSessionClientName(RemotePlaySessionID_t unSessionID)
	{
		return _GetSessionClientName(Self, unSessionID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemotePlay_GetSessionClientFormFactor")]
	private static extern SteamDeviceFormFactor _GetSessionClientFormFactor(IntPtr self, RemotePlaySessionID_t unSessionID);

	internal SteamDeviceFormFactor GetSessionClientFormFactor(RemotePlaySessionID_t unSessionID)
	{
		return _GetSessionClientFormFactor(Self, unSessionID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemotePlay_BGetSessionClientResolution")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BGetSessionClientResolution(IntPtr self, RemotePlaySessionID_t unSessionID, ref int pnResolutionX, ref int pnResolutionY);

	internal bool BGetSessionClientResolution(RemotePlaySessionID_t unSessionID, ref int pnResolutionX, ref int pnResolutionY)
	{
		return _BGetSessionClientResolution(Self, unSessionID, ref pnResolutionX, ref pnResolutionY);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemotePlay_BStartRemotePlayTogether")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BStartRemotePlayTogether(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bShowOverlay);

	internal bool BStartRemotePlayTogether([MarshalAs(UnmanagedType.U1)] bool bShowOverlay)
	{
		return _BStartRemotePlayTogether(Self, bShowOverlay);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemotePlay_BSendRemotePlayTogetherInvite")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BSendRemotePlayTogetherInvite(IntPtr self, SteamId steamIDFriend);

	internal bool BSendRemotePlayTogetherInvite(SteamId steamIDFriend)
	{
		return _BSendRemotePlayTogetherInvite(Self, steamIDFriend);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamRemoteStorage : SteamInterface
{
	public const string Version = "STEAMREMOTESTORAGE_INTERFACE_VERSION016";

	internal ISteamRemoteStorage(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamRemoteStorage_v016();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamRemoteStorage_v016();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_FileWrite")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _FileWrite(IntPtr self, IntPtr pchFile, IntPtr pvData, int cubData);

	internal bool FileWrite(string pchFile, IntPtr pvData, int cubData)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchFile);
		return _FileWrite(Self, utf8StringToNative.Pointer, pvData, cubData);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_FileRead")]
	private static extern int _FileRead(IntPtr self, IntPtr pchFile, IntPtr pvData, int cubDataToRead);

	internal int FileRead(string pchFile, IntPtr pvData, int cubDataToRead)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchFile);
		return _FileRead(Self, utf8StringToNative.Pointer, pvData, cubDataToRead);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_FileWriteAsync")]
	private static extern SteamAPICall_t _FileWriteAsync(IntPtr self, IntPtr pchFile, IntPtr pvData, uint cubData);

	internal CallResult<RemoteStorageFileWriteAsyncComplete_t> FileWriteAsync(string pchFile, IntPtr pvData, uint cubData)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchFile);
		return new CallResult<RemoteStorageFileWriteAsyncComplete_t>(_FileWriteAsync(Self, utf8StringToNative.Pointer, pvData, cubData), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_FileReadAsync")]
	private static extern SteamAPICall_t _FileReadAsync(IntPtr self, IntPtr pchFile, uint nOffset, uint cubToRead);

	internal CallResult<RemoteStorageFileReadAsyncComplete_t> FileReadAsync(string pchFile, uint nOffset, uint cubToRead)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchFile);
		return new CallResult<RemoteStorageFileReadAsyncComplete_t>(_FileReadAsync(Self, utf8StringToNative.Pointer, nOffset, cubToRead), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_FileReadAsyncComplete")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _FileReadAsyncComplete(IntPtr self, SteamAPICall_t hReadCall, IntPtr pvBuffer, uint cubToRead);

	internal bool FileReadAsyncComplete(SteamAPICall_t hReadCall, IntPtr pvBuffer, uint cubToRead)
	{
		return _FileReadAsyncComplete(Self, hReadCall, pvBuffer, cubToRead);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_FileForget")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _FileForget(IntPtr self, IntPtr pchFile);

	internal bool FileForget(string pchFile)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchFile);
		return _FileForget(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_FileDelete")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _FileDelete(IntPtr self, IntPtr pchFile);

	internal bool FileDelete(string pchFile)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchFile);
		return _FileDelete(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_FileShare")]
	private static extern SteamAPICall_t _FileShare(IntPtr self, IntPtr pchFile);

	internal CallResult<RemoteStorageFileShareResult_t> FileShare(string pchFile)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchFile);
		return new CallResult<RemoteStorageFileShareResult_t>(_FileShare(Self, utf8StringToNative.Pointer), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_SetSyncPlatforms")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetSyncPlatforms(IntPtr self, IntPtr pchFile, RemoteStoragePlatform eRemoteStoragePlatform);

	internal bool SetSyncPlatforms(string pchFile, RemoteStoragePlatform eRemoteStoragePlatform)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchFile);
		return _SetSyncPlatforms(Self, utf8StringToNative.Pointer, eRemoteStoragePlatform);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_FileWriteStreamOpen")]
	private static extern UGCFileWriteStreamHandle_t _FileWriteStreamOpen(IntPtr self, IntPtr pchFile);

	internal UGCFileWriteStreamHandle_t FileWriteStreamOpen(string pchFile)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchFile);
		return _FileWriteStreamOpen(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_FileWriteStreamWriteChunk")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _FileWriteStreamWriteChunk(IntPtr self, UGCFileWriteStreamHandle_t writeHandle, IntPtr pvData, int cubData);

	internal bool FileWriteStreamWriteChunk(UGCFileWriteStreamHandle_t writeHandle, IntPtr pvData, int cubData)
	{
		return _FileWriteStreamWriteChunk(Self, writeHandle, pvData, cubData);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_FileWriteStreamClose")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _FileWriteStreamClose(IntPtr self, UGCFileWriteStreamHandle_t writeHandle);

	internal bool FileWriteStreamClose(UGCFileWriteStreamHandle_t writeHandle)
	{
		return _FileWriteStreamClose(Self, writeHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_FileWriteStreamCancel")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _FileWriteStreamCancel(IntPtr self, UGCFileWriteStreamHandle_t writeHandle);

	internal bool FileWriteStreamCancel(UGCFileWriteStreamHandle_t writeHandle)
	{
		return _FileWriteStreamCancel(Self, writeHandle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_FileExists")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _FileExists(IntPtr self, IntPtr pchFile);

	internal bool FileExists(string pchFile)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchFile);
		return _FileExists(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_FilePersisted")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _FilePersisted(IntPtr self, IntPtr pchFile);

	internal bool FilePersisted(string pchFile)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchFile);
		return _FilePersisted(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_GetFileSize")]
	private static extern int _GetFileSize(IntPtr self, IntPtr pchFile);

	internal int GetFileSize(string pchFile)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchFile);
		return _GetFileSize(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_GetFileTimestamp")]
	private static extern long _GetFileTimestamp(IntPtr self, IntPtr pchFile);

	internal long GetFileTimestamp(string pchFile)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchFile);
		return _GetFileTimestamp(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_GetSyncPlatforms")]
	private static extern RemoteStoragePlatform _GetSyncPlatforms(IntPtr self, IntPtr pchFile);

	internal RemoteStoragePlatform GetSyncPlatforms(string pchFile)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchFile);
		return _GetSyncPlatforms(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_GetFileCount")]
	private static extern int _GetFileCount(IntPtr self);

	internal int GetFileCount()
	{
		return _GetFileCount(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_GetFileNameAndSize")]
	private static extern Utf8StringPointer _GetFileNameAndSize(IntPtr self, int iFile, ref int pnFileSizeInBytes);

	internal string GetFileNameAndSize(int iFile, ref int pnFileSizeInBytes)
	{
		return _GetFileNameAndSize(Self, iFile, ref pnFileSizeInBytes);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_GetQuota")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetQuota(IntPtr self, ref ulong pnTotalBytes, ref ulong puAvailableBytes);

	internal bool GetQuota(ref ulong pnTotalBytes, ref ulong puAvailableBytes)
	{
		return _GetQuota(Self, ref pnTotalBytes, ref puAvailableBytes);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_IsCloudEnabledForAccount")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _IsCloudEnabledForAccount(IntPtr self);

	internal bool IsCloudEnabledForAccount()
	{
		return _IsCloudEnabledForAccount(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_IsCloudEnabledForApp")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _IsCloudEnabledForApp(IntPtr self);

	internal bool IsCloudEnabledForApp()
	{
		return _IsCloudEnabledForApp(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_SetCloudEnabledForApp")]
	private static extern void _SetCloudEnabledForApp(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bEnabled);

	internal void SetCloudEnabledForApp([MarshalAs(UnmanagedType.U1)] bool bEnabled)
	{
		_SetCloudEnabledForApp(Self, bEnabled);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_UGCDownload")]
	private static extern SteamAPICall_t _UGCDownload(IntPtr self, UGCHandle_t hContent, uint unPriority);

	internal CallResult<RemoteStorageDownloadUGCResult_t> UGCDownload(UGCHandle_t hContent, uint unPriority)
	{
		return new CallResult<RemoteStorageDownloadUGCResult_t>(_UGCDownload(Self, hContent, unPriority), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_GetUGCDownloadProgress")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetUGCDownloadProgress(IntPtr self, UGCHandle_t hContent, ref int pnBytesDownloaded, ref int pnBytesExpected);

	internal bool GetUGCDownloadProgress(UGCHandle_t hContent, ref int pnBytesDownloaded, ref int pnBytesExpected)
	{
		return _GetUGCDownloadProgress(Self, hContent, ref pnBytesDownloaded, ref pnBytesExpected);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_GetUGCDetails")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetUGCDetails(IntPtr self, UGCHandle_t hContent, ref AppId pnAppID, [In][Out] ref char[] ppchName, ref int pnFileSizeInBytes, ref SteamId pSteamIDOwner);

	internal bool GetUGCDetails(UGCHandle_t hContent, ref AppId pnAppID, [In][Out] ref char[] ppchName, ref int pnFileSizeInBytes, ref SteamId pSteamIDOwner)
	{
		return _GetUGCDetails(Self, hContent, ref pnAppID, ref ppchName, ref pnFileSizeInBytes, ref pSteamIDOwner);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_UGCRead")]
	private static extern int _UGCRead(IntPtr self, UGCHandle_t hContent, IntPtr pvData, int cubDataToRead, uint cOffset, UGCReadAction eAction);

	internal int UGCRead(UGCHandle_t hContent, IntPtr pvData, int cubDataToRead, uint cOffset, UGCReadAction eAction)
	{
		return _UGCRead(Self, hContent, pvData, cubDataToRead, cOffset, eAction);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_GetCachedUGCCount")]
	private static extern int _GetCachedUGCCount(IntPtr self);

	internal int GetCachedUGCCount()
	{
		return _GetCachedUGCCount(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_GetCachedUGCHandle")]
	private static extern UGCHandle_t _GetCachedUGCHandle(IntPtr self, int iCachedContent);

	internal UGCHandle_t GetCachedUGCHandle(int iCachedContent)
	{
		return _GetCachedUGCHandle(Self, iCachedContent);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_UGCDownloadToLocation")]
	private static extern SteamAPICall_t _UGCDownloadToLocation(IntPtr self, UGCHandle_t hContent, IntPtr pchLocation, uint unPriority);

	internal CallResult<RemoteStorageDownloadUGCResult_t> UGCDownloadToLocation(UGCHandle_t hContent, string pchLocation, uint unPriority)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchLocation);
		return new CallResult<RemoteStorageDownloadUGCResult_t>(_UGCDownloadToLocation(Self, hContent, utf8StringToNative.Pointer, unPriority), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_GetLocalFileChangeCount")]
	private static extern int _GetLocalFileChangeCount(IntPtr self);

	internal int GetLocalFileChangeCount()
	{
		return _GetLocalFileChangeCount(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_GetLocalFileChange")]
	private static extern Utf8StringPointer _GetLocalFileChange(IntPtr self, int iFile, ref RemoteStorageLocalFileChange pEChangeType, ref RemoteStorageFilePathType pEFilePathType);

	internal string GetLocalFileChange(int iFile, ref RemoteStorageLocalFileChange pEChangeType, ref RemoteStorageFilePathType pEFilePathType)
	{
		return _GetLocalFileChange(Self, iFile, ref pEChangeType, ref pEFilePathType);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_BeginFileWriteBatch")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BeginFileWriteBatch(IntPtr self);

	internal bool BeginFileWriteBatch()
	{
		return _BeginFileWriteBatch(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamRemoteStorage_EndFileWriteBatch")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _EndFileWriteBatch(IntPtr self);

	internal bool EndFileWriteBatch()
	{
		return _EndFileWriteBatch(Self);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamScreenshots : SteamInterface
{
	public const string Version = "STEAMSCREENSHOTS_INTERFACE_VERSION003";

	internal ISteamScreenshots(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamScreenshots_v003();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamScreenshots_v003();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamScreenshots_WriteScreenshot")]
	private static extern ScreenshotHandle _WriteScreenshot(IntPtr self, IntPtr pubRGB, uint cubRGB, int nWidth, int nHeight);

	internal ScreenshotHandle WriteScreenshot(IntPtr pubRGB, uint cubRGB, int nWidth, int nHeight)
	{
		return _WriteScreenshot(Self, pubRGB, cubRGB, nWidth, nHeight);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamScreenshots_AddScreenshotToLibrary")]
	private static extern ScreenshotHandle _AddScreenshotToLibrary(IntPtr self, IntPtr pchFilename, IntPtr pchThumbnailFilename, int nWidth, int nHeight);

	internal ScreenshotHandle AddScreenshotToLibrary(string pchFilename, string pchThumbnailFilename, int nWidth, int nHeight)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchFilename);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchThumbnailFilename);
		return _AddScreenshotToLibrary(Self, utf8StringToNative.Pointer, utf8StringToNative2.Pointer, nWidth, nHeight);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamScreenshots_TriggerScreenshot")]
	private static extern void _TriggerScreenshot(IntPtr self);

	internal void TriggerScreenshot()
	{
		_TriggerScreenshot(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamScreenshots_HookScreenshots")]
	private static extern void _HookScreenshots(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bHook);

	internal void HookScreenshots([MarshalAs(UnmanagedType.U1)] bool bHook)
	{
		_HookScreenshots(Self, bHook);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamScreenshots_SetLocation")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetLocation(IntPtr self, ScreenshotHandle hScreenshot, IntPtr pchLocation);

	internal bool SetLocation(ScreenshotHandle hScreenshot, string pchLocation)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchLocation);
		return _SetLocation(Self, hScreenshot, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamScreenshots_TagUser")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _TagUser(IntPtr self, ScreenshotHandle hScreenshot, SteamId steamID);

	internal bool TagUser(ScreenshotHandle hScreenshot, SteamId steamID)
	{
		return _TagUser(Self, hScreenshot, steamID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamScreenshots_TagPublishedFile")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _TagPublishedFile(IntPtr self, ScreenshotHandle hScreenshot, PublishedFileId unPublishedFileID);

	internal bool TagPublishedFile(ScreenshotHandle hScreenshot, PublishedFileId unPublishedFileID)
	{
		return _TagPublishedFile(Self, hScreenshot, unPublishedFileID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamScreenshots_IsScreenshotsHooked")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _IsScreenshotsHooked(IntPtr self);

	internal bool IsScreenshotsHooked()
	{
		return _IsScreenshotsHooked(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamScreenshots_AddVRScreenshotToLibrary")]
	private static extern ScreenshotHandle _AddVRScreenshotToLibrary(IntPtr self, VRScreenshotType eType, IntPtr pchFilename, IntPtr pchVRFilename);

	internal ScreenshotHandle AddVRScreenshotToLibrary(VRScreenshotType eType, string pchFilename, string pchVRFilename)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchFilename);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchVRFilename);
		return _AddVRScreenshotToLibrary(Self, eType, utf8StringToNative.Pointer, utf8StringToNative2.Pointer);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamTimeline : SteamInterface
{
	public const string Version = "STEAMTIMELINE_INTERFACE_V004";

	internal ISteamTimeline(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamTimeline_v004();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamTimeline_v004();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamTimeline_SetTimelineTooltip")]
	private static extern void _SetTimelineTooltip(IntPtr self, IntPtr pchDescription, float flTimeDelta);

	internal void SetTimelineTooltip(string pchDescription, float flTimeDelta)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchDescription);
		_SetTimelineTooltip(Self, utf8StringToNative.Pointer, flTimeDelta);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamTimeline_ClearTimelineTooltip")]
	private static extern void _ClearTimelineTooltip(IntPtr self, float flTimeDelta);

	internal void ClearTimelineTooltip(float flTimeDelta)
	{
		_ClearTimelineTooltip(Self, flTimeDelta);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamTimeline_SetTimelineGameMode")]
	private static extern void _SetTimelineGameMode(IntPtr self, TimelineGameMode eMode);

	internal void SetTimelineGameMode(TimelineGameMode eMode)
	{
		_SetTimelineGameMode(Self, eMode);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamTimeline_AddInstantaneousTimelineEvent")]
	private static extern TimelineEventHandle _AddInstantaneousTimelineEvent(IntPtr self, IntPtr pchTitle, IntPtr pchDescription, IntPtr pchIcon, uint unIconPriority, float flStartOffsetSeconds, TimelineEventClipPriority ePossibleClip);

	internal TimelineEventHandle AddInstantaneousTimelineEvent(string pchTitle, string pchDescription, string pchIcon, uint unIconPriority, float flStartOffsetSeconds, TimelineEventClipPriority ePossibleClip)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchTitle);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchDescription);
		using Utf8StringToNative utf8StringToNative3 = new Utf8StringToNative(pchIcon);
		return _AddInstantaneousTimelineEvent(Self, utf8StringToNative.Pointer, utf8StringToNative2.Pointer, utf8StringToNative3.Pointer, unIconPriority, flStartOffsetSeconds, ePossibleClip);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamTimeline_AddRangeTimelineEvent")]
	private static extern TimelineEventHandle _AddRangeTimelineEvent(IntPtr self, IntPtr pchTitle, IntPtr pchDescription, IntPtr pchIcon, uint unIconPriority, float flStartOffsetSeconds, float flDuration, TimelineEventClipPriority ePossibleClip);

	internal TimelineEventHandle AddRangeTimelineEvent(string pchTitle, string pchDescription, string pchIcon, uint unIconPriority, float flStartOffsetSeconds, float flDuration, TimelineEventClipPriority ePossibleClip)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchTitle);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchDescription);
		using Utf8StringToNative utf8StringToNative3 = new Utf8StringToNative(pchIcon);
		return _AddRangeTimelineEvent(Self, utf8StringToNative.Pointer, utf8StringToNative2.Pointer, utf8StringToNative3.Pointer, unIconPriority, flStartOffsetSeconds, flDuration, ePossibleClip);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamTimeline_StartRangeTimelineEvent")]
	private static extern TimelineEventHandle _StartRangeTimelineEvent(IntPtr self, IntPtr pchTitle, IntPtr pchDescription, IntPtr pchIcon, uint unPriority, float flStartOffsetSeconds, TimelineEventClipPriority ePossibleClip);

	internal TimelineEventHandle StartRangeTimelineEvent(string pchTitle, string pchDescription, string pchIcon, uint unPriority, float flStartOffsetSeconds, TimelineEventClipPriority ePossibleClip)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchTitle);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchDescription);
		using Utf8StringToNative utf8StringToNative3 = new Utf8StringToNative(pchIcon);
		return _StartRangeTimelineEvent(Self, utf8StringToNative.Pointer, utf8StringToNative2.Pointer, utf8StringToNative3.Pointer, unPriority, flStartOffsetSeconds, ePossibleClip);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamTimeline_UpdateRangeTimelineEvent")]
	private static extern void _UpdateRangeTimelineEvent(IntPtr self, TimelineEventHandle ulEvent, IntPtr pchTitle, IntPtr pchDescription, IntPtr pchIcon, uint unPriority, TimelineEventClipPriority ePossibleClip);

	internal void UpdateRangeTimelineEvent(TimelineEventHandle ulEvent, string pchTitle, string pchDescription, string pchIcon, uint unPriority, TimelineEventClipPriority ePossibleClip)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchTitle);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchDescription);
		using Utf8StringToNative utf8StringToNative3 = new Utf8StringToNative(pchIcon);
		_UpdateRangeTimelineEvent(Self, ulEvent, utf8StringToNative.Pointer, utf8StringToNative2.Pointer, utf8StringToNative3.Pointer, unPriority, ePossibleClip);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamTimeline_EndRangeTimelineEvent")]
	private static extern void _EndRangeTimelineEvent(IntPtr self, TimelineEventHandle ulEvent, float flEndOffsetSeconds);

	internal void EndRangeTimelineEvent(TimelineEventHandle ulEvent, float flEndOffsetSeconds)
	{
		_EndRangeTimelineEvent(Self, ulEvent, flEndOffsetSeconds);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamTimeline_RemoveTimelineEvent")]
	private static extern void _RemoveTimelineEvent(IntPtr self, TimelineEventHandle ulEvent);

	internal void RemoveTimelineEvent(TimelineEventHandle ulEvent)
	{
		_RemoveTimelineEvent(Self, ulEvent);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamTimeline_DoesEventRecordingExist")]
	private static extern SteamAPICall_t _DoesEventRecordingExist(IntPtr self, TimelineEventHandle ulEvent);

	internal CallResult<SteamTimelineEventRecordingExists_t> DoesEventRecordingExist(TimelineEventHandle ulEvent)
	{
		return new CallResult<SteamTimelineEventRecordingExists_t>(_DoesEventRecordingExist(Self, ulEvent), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamTimeline_StartGamePhase")]
	private static extern void _StartGamePhase(IntPtr self);

	internal void StartGamePhase()
	{
		_StartGamePhase(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamTimeline_EndGamePhase")]
	private static extern void _EndGamePhase(IntPtr self);

	internal void EndGamePhase()
	{
		_EndGamePhase(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamTimeline_SetGamePhaseID")]
	private static extern void _SetGamePhaseID(IntPtr self, IntPtr pchPhaseID);

	internal void SetGamePhaseID(string pchPhaseID)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchPhaseID);
		_SetGamePhaseID(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamTimeline_DoesGamePhaseRecordingExist")]
	private static extern SteamAPICall_t _DoesGamePhaseRecordingExist(IntPtr self, IntPtr pchPhaseID);

	internal CallResult<SteamTimelineGamePhaseRecordingExists_t> DoesGamePhaseRecordingExist(string pchPhaseID)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchPhaseID);
		return new CallResult<SteamTimelineGamePhaseRecordingExists_t>(_DoesGamePhaseRecordingExist(Self, utf8StringToNative.Pointer), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamTimeline_AddGamePhaseTag")]
	private static extern void _AddGamePhaseTag(IntPtr self, IntPtr pchTagName, IntPtr pchTagIcon, IntPtr pchTagGroup, uint unPriority);

	internal void AddGamePhaseTag(string pchTagName, string pchTagIcon, string pchTagGroup, uint unPriority)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchTagName);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchTagIcon);
		using Utf8StringToNative utf8StringToNative3 = new Utf8StringToNative(pchTagGroup);
		_AddGamePhaseTag(Self, utf8StringToNative.Pointer, utf8StringToNative2.Pointer, utf8StringToNative3.Pointer, unPriority);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamTimeline_SetGamePhaseAttribute")]
	private static extern void _SetGamePhaseAttribute(IntPtr self, IntPtr pchAttributeGroup, IntPtr pchAttributeValue, uint unPriority);

	internal void SetGamePhaseAttribute(string pchAttributeGroup, string pchAttributeValue, uint unPriority)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchAttributeGroup);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchAttributeValue);
		_SetGamePhaseAttribute(Self, utf8StringToNative.Pointer, utf8StringToNative2.Pointer, unPriority);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamTimeline_OpenOverlayToGamePhase")]
	private static extern void _OpenOverlayToGamePhase(IntPtr self, IntPtr pchPhaseID);

	internal void OpenOverlayToGamePhase(string pchPhaseID)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchPhaseID);
		_OpenOverlayToGamePhase(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamTimeline_OpenOverlayToTimelineEvent")]
	private static extern void _OpenOverlayToTimelineEvent(IntPtr self, TimelineEventHandle ulEvent);

	internal void OpenOverlayToTimelineEvent(TimelineEventHandle ulEvent)
	{
		_OpenOverlayToTimelineEvent(Self, ulEvent);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamUGC : SteamInterface
{
	public const string Version = "STEAMUGC_INTERFACE_VERSION020";

	internal ISteamUGC(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamUGC_v020();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamUGC_v020();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamGameServerUGC_v020();

	public override IntPtr GetServerInterfacePointer()
	{
		return SteamAPI_SteamGameServerUGC_v020();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_CreateQueryUserUGCRequest")]
	private static extern UGCQueryHandle_t _CreateQueryUserUGCRequest(IntPtr self, AccountID_t unAccountID, UserUGCList eListType, UgcType eMatchingUGCType, UserUGCListSortOrder eSortOrder, AppId nCreatorAppID, AppId nConsumerAppID, uint unPage);

	internal UGCQueryHandle_t CreateQueryUserUGCRequest(AccountID_t unAccountID, UserUGCList eListType, UgcType eMatchingUGCType, UserUGCListSortOrder eSortOrder, AppId nCreatorAppID, AppId nConsumerAppID, uint unPage)
	{
		return _CreateQueryUserUGCRequest(Self, unAccountID, eListType, eMatchingUGCType, eSortOrder, nCreatorAppID, nConsumerAppID, unPage);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_CreateQueryAllUGCRequestPage")]
	private static extern UGCQueryHandle_t _CreateQueryAllUGCRequest(IntPtr self, UGCQuery eQueryType, UgcType eMatchingeMatchingUGCTypeFileType, AppId nCreatorAppID, AppId nConsumerAppID, uint unPage);

	internal UGCQueryHandle_t CreateQueryAllUGCRequest(UGCQuery eQueryType, UgcType eMatchingeMatchingUGCTypeFileType, AppId nCreatorAppID, AppId nConsumerAppID, uint unPage)
	{
		return _CreateQueryAllUGCRequest(Self, eQueryType, eMatchingeMatchingUGCTypeFileType, nCreatorAppID, nConsumerAppID, unPage);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_CreateQueryAllUGCRequestCursor")]
	private static extern UGCQueryHandle_t _CreateQueryAllUGCRequest(IntPtr self, UGCQuery eQueryType, UgcType eMatchingeMatchingUGCTypeFileType, AppId nCreatorAppID, AppId nConsumerAppID, IntPtr pchCursor);

	internal UGCQueryHandle_t CreateQueryAllUGCRequest(UGCQuery eQueryType, UgcType eMatchingeMatchingUGCTypeFileType, AppId nCreatorAppID, AppId nConsumerAppID, string pchCursor)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchCursor);
		return _CreateQueryAllUGCRequest(Self, eQueryType, eMatchingeMatchingUGCTypeFileType, nCreatorAppID, nConsumerAppID, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_CreateQueryUGCDetailsRequest")]
	private static extern UGCQueryHandle_t _CreateQueryUGCDetailsRequest(IntPtr self, [In][Out] PublishedFileId[] pvecPublishedFileID, uint unNumPublishedFileIDs);

	internal UGCQueryHandle_t CreateQueryUGCDetailsRequest([In][Out] PublishedFileId[] pvecPublishedFileID, uint unNumPublishedFileIDs)
	{
		return _CreateQueryUGCDetailsRequest(Self, pvecPublishedFileID, unNumPublishedFileIDs);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SendQueryUGCRequest")]
	private static extern SteamAPICall_t _SendQueryUGCRequest(IntPtr self, UGCQueryHandle_t handle);

	internal CallResult<SteamUGCQueryCompleted_t> SendQueryUGCRequest(UGCQueryHandle_t handle)
	{
		return new CallResult<SteamUGCQueryCompleted_t>(_SendQueryUGCRequest(Self, handle), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetQueryUGCResult")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetQueryUGCResult(IntPtr self, UGCQueryHandle_t handle, uint index, ref SteamUGCDetails_t pDetails);

	internal bool GetQueryUGCResult(UGCQueryHandle_t handle, uint index, ref SteamUGCDetails_t pDetails)
	{
		return _GetQueryUGCResult(Self, handle, index, ref pDetails);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetQueryUGCNumTags")]
	private static extern uint _GetQueryUGCNumTags(IntPtr self, UGCQueryHandle_t handle, uint index);

	internal uint GetQueryUGCNumTags(UGCQueryHandle_t handle, uint index)
	{
		return _GetQueryUGCNumTags(Self, handle, index);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetQueryUGCTag")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetQueryUGCTag(IntPtr self, UGCQueryHandle_t handle, uint index, uint indexTag, IntPtr pchValue, uint cchValueSize);

	internal bool GetQueryUGCTag(UGCQueryHandle_t handle, uint index, uint indexTag, out string pchValue)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			bool result = _GetQueryUGCTag(Self, handle, index, indexTag, m, 32768u);
			pchValue = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetQueryUGCTagDisplayName")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetQueryUGCTagDisplayName(IntPtr self, UGCQueryHandle_t handle, uint index, uint indexTag, IntPtr pchValue, uint cchValueSize);

	internal bool GetQueryUGCTagDisplayName(UGCQueryHandle_t handle, uint index, uint indexTag, out string pchValue)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			bool result = _GetQueryUGCTagDisplayName(Self, handle, index, indexTag, m, 32768u);
			pchValue = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetQueryUGCPreviewURL")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetQueryUGCPreviewURL(IntPtr self, UGCQueryHandle_t handle, uint index, IntPtr pchURL, uint cchURLSize);

	internal bool GetQueryUGCPreviewURL(UGCQueryHandle_t handle, uint index, out string pchURL)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			bool result = _GetQueryUGCPreviewURL(Self, handle, index, m, 32768u);
			pchURL = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetQueryUGCMetadata")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetQueryUGCMetadata(IntPtr self, UGCQueryHandle_t handle, uint index, IntPtr pchMetadata, uint cchMetadatasize);

	internal bool GetQueryUGCMetadata(UGCQueryHandle_t handle, uint index, out string pchMetadata)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			bool result = _GetQueryUGCMetadata(Self, handle, index, m, 32768u);
			pchMetadata = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetQueryUGCChildren")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetQueryUGCChildren(IntPtr self, UGCQueryHandle_t handle, uint index, [In][Out] PublishedFileId[] pvecPublishedFileID, uint cMaxEntries);

	internal bool GetQueryUGCChildren(UGCQueryHandle_t handle, uint index, [In][Out] PublishedFileId[] pvecPublishedFileID, uint cMaxEntries)
	{
		return _GetQueryUGCChildren(Self, handle, index, pvecPublishedFileID, cMaxEntries);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetQueryUGCStatistic")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetQueryUGCStatistic(IntPtr self, UGCQueryHandle_t handle, uint index, ItemStatistic eStatType, ref ulong pStatValue);

	internal bool GetQueryUGCStatistic(UGCQueryHandle_t handle, uint index, ItemStatistic eStatType, ref ulong pStatValue)
	{
		return _GetQueryUGCStatistic(Self, handle, index, eStatType, ref pStatValue);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetQueryUGCNumAdditionalPreviews")]
	private static extern uint _GetQueryUGCNumAdditionalPreviews(IntPtr self, UGCQueryHandle_t handle, uint index);

	internal uint GetQueryUGCNumAdditionalPreviews(UGCQueryHandle_t handle, uint index)
	{
		return _GetQueryUGCNumAdditionalPreviews(Self, handle, index);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetQueryUGCAdditionalPreview")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetQueryUGCAdditionalPreview(IntPtr self, UGCQueryHandle_t handle, uint index, uint previewIndex, IntPtr pchURLOrVideoID, uint cchURLSize, IntPtr pchOriginalFileName, uint cchOriginalFileNameSize, ref ItemPreviewType pPreviewType);

	internal bool GetQueryUGCAdditionalPreview(UGCQueryHandle_t handle, uint index, uint previewIndex, out string pchURLOrVideoID, out string pchOriginalFileName, ref ItemPreviewType pPreviewType)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			Helpers.Memory m2 = Helpers.TakeMemory();
			try
			{
				bool result = _GetQueryUGCAdditionalPreview(Self, handle, index, previewIndex, m, 32768u, m2, 32768u, ref pPreviewType);
				pchURLOrVideoID = Helpers.MemoryToString(m);
				pchOriginalFileName = Helpers.MemoryToString(m2);
				return result;
			}
			finally
			{
				((IDisposable)m2/*cast due to .constrained prefix*/).Dispose();
			}
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetQueryUGCNumKeyValueTags")]
	private static extern uint _GetQueryUGCNumKeyValueTags(IntPtr self, UGCQueryHandle_t handle, uint index);

	internal uint GetQueryUGCNumKeyValueTags(UGCQueryHandle_t handle, uint index)
	{
		return _GetQueryUGCNumKeyValueTags(Self, handle, index);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetQueryUGCKeyValueTag")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetQueryUGCKeyValueTag(IntPtr self, UGCQueryHandle_t handle, uint index, uint keyValueTagIndex, IntPtr pchKey, uint cchKeySize, IntPtr pchValue, uint cchValueSize);

	internal bool GetQueryUGCKeyValueTag(UGCQueryHandle_t handle, uint index, uint keyValueTagIndex, out string pchKey, out string pchValue)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			Helpers.Memory m2 = Helpers.TakeMemory();
			try
			{
				bool result = _GetQueryUGCKeyValueTag(Self, handle, index, keyValueTagIndex, m, 32768u, m2, 32768u);
				pchKey = Helpers.MemoryToString(m);
				pchValue = Helpers.MemoryToString(m2);
				return result;
			}
			finally
			{
				((IDisposable)m2/*cast due to .constrained prefix*/).Dispose();
			}
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetQueryFirstUGCKeyValueTag")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetQueryUGCKeyValueTag(IntPtr self, UGCQueryHandle_t handle, uint index, IntPtr pchKey, IntPtr pchValue, uint cchValueSize);

	internal bool GetQueryUGCKeyValueTag(UGCQueryHandle_t handle, uint index, string pchKey, out string pchValue)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchKey);
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			bool result = _GetQueryUGCKeyValueTag(Self, handle, index, utf8StringToNative.Pointer, m, 32768u);
			pchValue = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetNumSupportedGameVersions")]
	private static extern uint _GetNumSupportedGameVersions(IntPtr self, UGCQueryHandle_t handle, uint index);

	internal uint GetNumSupportedGameVersions(UGCQueryHandle_t handle, uint index)
	{
		return _GetNumSupportedGameVersions(Self, handle, index);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetSupportedGameVersionData")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetSupportedGameVersionData(IntPtr self, UGCQueryHandle_t handle, uint index, uint versionIndex, IntPtr pchGameBranchMin, IntPtr pchGameBranchMax, uint cchGameBranchSize);

	internal bool GetSupportedGameVersionData(UGCQueryHandle_t handle, uint index, uint versionIndex, out string pchGameBranchMin, out string pchGameBranchMax)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			Helpers.Memory m2 = Helpers.TakeMemory();
			try
			{
				bool result = _GetSupportedGameVersionData(Self, handle, index, versionIndex, m, m2, 32768u);
				pchGameBranchMin = Helpers.MemoryToString(m);
				pchGameBranchMax = Helpers.MemoryToString(m2);
				return result;
			}
			finally
			{
				((IDisposable)m2/*cast due to .constrained prefix*/).Dispose();
			}
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetQueryUGCContentDescriptors")]
	private static extern uint _GetQueryUGCContentDescriptors(IntPtr self, UGCQueryHandle_t handle, uint index, [In][Out] UGCContentDescriptorID[] pvecDescriptors, uint cMaxEntries);

	internal uint GetQueryUGCContentDescriptors(UGCQueryHandle_t handle, uint index, [In][Out] UGCContentDescriptorID[] pvecDescriptors, uint cMaxEntries)
	{
		return _GetQueryUGCContentDescriptors(Self, handle, index, pvecDescriptors, cMaxEntries);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_ReleaseQueryUGCRequest")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _ReleaseQueryUGCRequest(IntPtr self, UGCQueryHandle_t handle);

	internal bool ReleaseQueryUGCRequest(UGCQueryHandle_t handle)
	{
		return _ReleaseQueryUGCRequest(Self, handle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_AddRequiredTag")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _AddRequiredTag(IntPtr self, UGCQueryHandle_t handle, IntPtr pTagName);

	internal bool AddRequiredTag(UGCQueryHandle_t handle, string pTagName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pTagName);
		return _AddRequiredTag(Self, handle, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_AddRequiredTagGroup")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _AddRequiredTagGroup(IntPtr self, UGCQueryHandle_t handle, ref SteamParamStringArray_t pTagGroups);

	internal bool AddRequiredTagGroup(UGCQueryHandle_t handle, ref SteamParamStringArray_t pTagGroups)
	{
		return _AddRequiredTagGroup(Self, handle, ref pTagGroups);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_AddExcludedTag")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _AddExcludedTag(IntPtr self, UGCQueryHandle_t handle, IntPtr pTagName);

	internal bool AddExcludedTag(UGCQueryHandle_t handle, string pTagName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pTagName);
		return _AddExcludedTag(Self, handle, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetReturnOnlyIDs")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetReturnOnlyIDs(IntPtr self, UGCQueryHandle_t handle, [MarshalAs(UnmanagedType.U1)] bool bReturnOnlyIDs);

	internal bool SetReturnOnlyIDs(UGCQueryHandle_t handle, [MarshalAs(UnmanagedType.U1)] bool bReturnOnlyIDs)
	{
		return _SetReturnOnlyIDs(Self, handle, bReturnOnlyIDs);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetReturnKeyValueTags")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetReturnKeyValueTags(IntPtr self, UGCQueryHandle_t handle, [MarshalAs(UnmanagedType.U1)] bool bReturnKeyValueTags);

	internal bool SetReturnKeyValueTags(UGCQueryHandle_t handle, [MarshalAs(UnmanagedType.U1)] bool bReturnKeyValueTags)
	{
		return _SetReturnKeyValueTags(Self, handle, bReturnKeyValueTags);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetReturnLongDescription")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetReturnLongDescription(IntPtr self, UGCQueryHandle_t handle, [MarshalAs(UnmanagedType.U1)] bool bReturnLongDescription);

	internal bool SetReturnLongDescription(UGCQueryHandle_t handle, [MarshalAs(UnmanagedType.U1)] bool bReturnLongDescription)
	{
		return _SetReturnLongDescription(Self, handle, bReturnLongDescription);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetReturnMetadata")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetReturnMetadata(IntPtr self, UGCQueryHandle_t handle, [MarshalAs(UnmanagedType.U1)] bool bReturnMetadata);

	internal bool SetReturnMetadata(UGCQueryHandle_t handle, [MarshalAs(UnmanagedType.U1)] bool bReturnMetadata)
	{
		return _SetReturnMetadata(Self, handle, bReturnMetadata);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetReturnChildren")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetReturnChildren(IntPtr self, UGCQueryHandle_t handle, [MarshalAs(UnmanagedType.U1)] bool bReturnChildren);

	internal bool SetReturnChildren(UGCQueryHandle_t handle, [MarshalAs(UnmanagedType.U1)] bool bReturnChildren)
	{
		return _SetReturnChildren(Self, handle, bReturnChildren);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetReturnAdditionalPreviews")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetReturnAdditionalPreviews(IntPtr self, UGCQueryHandle_t handle, [MarshalAs(UnmanagedType.U1)] bool bReturnAdditionalPreviews);

	internal bool SetReturnAdditionalPreviews(UGCQueryHandle_t handle, [MarshalAs(UnmanagedType.U1)] bool bReturnAdditionalPreviews)
	{
		return _SetReturnAdditionalPreviews(Self, handle, bReturnAdditionalPreviews);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetReturnTotalOnly")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetReturnTotalOnly(IntPtr self, UGCQueryHandle_t handle, [MarshalAs(UnmanagedType.U1)] bool bReturnTotalOnly);

	internal bool SetReturnTotalOnly(UGCQueryHandle_t handle, [MarshalAs(UnmanagedType.U1)] bool bReturnTotalOnly)
	{
		return _SetReturnTotalOnly(Self, handle, bReturnTotalOnly);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetReturnPlaytimeStats")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetReturnPlaytimeStats(IntPtr self, UGCQueryHandle_t handle, uint unDays);

	internal bool SetReturnPlaytimeStats(UGCQueryHandle_t handle, uint unDays)
	{
		return _SetReturnPlaytimeStats(Self, handle, unDays);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetLanguage")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetLanguage(IntPtr self, UGCQueryHandle_t handle, IntPtr pchLanguage);

	internal bool SetLanguage(UGCQueryHandle_t handle, string pchLanguage)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchLanguage);
		return _SetLanguage(Self, handle, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetAllowCachedResponse")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetAllowCachedResponse(IntPtr self, UGCQueryHandle_t handle, uint unMaxAgeSeconds);

	internal bool SetAllowCachedResponse(UGCQueryHandle_t handle, uint unMaxAgeSeconds)
	{
		return _SetAllowCachedResponse(Self, handle, unMaxAgeSeconds);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetAdminQuery")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetAdminQuery(IntPtr self, UGCUpdateHandle_t handle, [MarshalAs(UnmanagedType.U1)] bool bAdminQuery);

	internal bool SetAdminQuery(UGCUpdateHandle_t handle, [MarshalAs(UnmanagedType.U1)] bool bAdminQuery)
	{
		return _SetAdminQuery(Self, handle, bAdminQuery);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetCloudFileNameFilter")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetCloudFileNameFilter(IntPtr self, UGCQueryHandle_t handle, IntPtr pMatchCloudFileName);

	internal bool SetCloudFileNameFilter(UGCQueryHandle_t handle, string pMatchCloudFileName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pMatchCloudFileName);
		return _SetCloudFileNameFilter(Self, handle, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetMatchAnyTag")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetMatchAnyTag(IntPtr self, UGCQueryHandle_t handle, [MarshalAs(UnmanagedType.U1)] bool bMatchAnyTag);

	internal bool SetMatchAnyTag(UGCQueryHandle_t handle, [MarshalAs(UnmanagedType.U1)] bool bMatchAnyTag)
	{
		return _SetMatchAnyTag(Self, handle, bMatchAnyTag);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetSearchText")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetSearchText(IntPtr self, UGCQueryHandle_t handle, IntPtr pSearchText);

	internal bool SetSearchText(UGCQueryHandle_t handle, string pSearchText)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pSearchText);
		return _SetSearchText(Self, handle, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetRankedByTrendDays")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetRankedByTrendDays(IntPtr self, UGCQueryHandle_t handle, uint unDays);

	internal bool SetRankedByTrendDays(UGCQueryHandle_t handle, uint unDays)
	{
		return _SetRankedByTrendDays(Self, handle, unDays);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetTimeCreatedDateRange")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetTimeCreatedDateRange(IntPtr self, UGCQueryHandle_t handle, RTime32 rtStart, RTime32 rtEnd);

	internal bool SetTimeCreatedDateRange(UGCQueryHandle_t handle, RTime32 rtStart, RTime32 rtEnd)
	{
		return _SetTimeCreatedDateRange(Self, handle, rtStart, rtEnd);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetTimeUpdatedDateRange")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetTimeUpdatedDateRange(IntPtr self, UGCQueryHandle_t handle, RTime32 rtStart, RTime32 rtEnd);

	internal bool SetTimeUpdatedDateRange(UGCQueryHandle_t handle, RTime32 rtStart, RTime32 rtEnd)
	{
		return _SetTimeUpdatedDateRange(Self, handle, rtStart, rtEnd);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_AddRequiredKeyValueTag")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _AddRequiredKeyValueTag(IntPtr self, UGCQueryHandle_t handle, IntPtr pKey, IntPtr pValue);

	internal bool AddRequiredKeyValueTag(UGCQueryHandle_t handle, string pKey, string pValue)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pKey);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pValue);
		return _AddRequiredKeyValueTag(Self, handle, utf8StringToNative.Pointer, utf8StringToNative2.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_CreateItem")]
	private static extern SteamAPICall_t _CreateItem(IntPtr self, AppId nConsumerAppId, WorkshopFileType eFileType);

	internal CallResult<CreateItemResult_t> CreateItem(AppId nConsumerAppId, WorkshopFileType eFileType)
	{
		return new CallResult<CreateItemResult_t>(_CreateItem(Self, nConsumerAppId, eFileType), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_StartItemUpdate")]
	private static extern UGCUpdateHandle_t _StartItemUpdate(IntPtr self, AppId nConsumerAppId, PublishedFileId nPublishedFileID);

	internal UGCUpdateHandle_t StartItemUpdate(AppId nConsumerAppId, PublishedFileId nPublishedFileID)
	{
		return _StartItemUpdate(Self, nConsumerAppId, nPublishedFileID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetItemTitle")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetItemTitle(IntPtr self, UGCUpdateHandle_t handle, IntPtr pchTitle);

	internal bool SetItemTitle(UGCUpdateHandle_t handle, string pchTitle)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchTitle);
		return _SetItemTitle(Self, handle, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetItemDescription")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetItemDescription(IntPtr self, UGCUpdateHandle_t handle, IntPtr pchDescription);

	internal bool SetItemDescription(UGCUpdateHandle_t handle, string pchDescription)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchDescription);
		return _SetItemDescription(Self, handle, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetItemUpdateLanguage")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetItemUpdateLanguage(IntPtr self, UGCUpdateHandle_t handle, IntPtr pchLanguage);

	internal bool SetItemUpdateLanguage(UGCUpdateHandle_t handle, string pchLanguage)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchLanguage);
		return _SetItemUpdateLanguage(Self, handle, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetItemMetadata")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetItemMetadata(IntPtr self, UGCUpdateHandle_t handle, IntPtr pchMetaData);

	internal bool SetItemMetadata(UGCUpdateHandle_t handle, string pchMetaData)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchMetaData);
		return _SetItemMetadata(Self, handle, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetItemVisibility")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetItemVisibility(IntPtr self, UGCUpdateHandle_t handle, RemoteStoragePublishedFileVisibility eVisibility);

	internal bool SetItemVisibility(UGCUpdateHandle_t handle, RemoteStoragePublishedFileVisibility eVisibility)
	{
		return _SetItemVisibility(Self, handle, eVisibility);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetItemTags")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetItemTags(IntPtr self, UGCUpdateHandle_t updateHandle, ref SteamParamStringArray_t pTags, [MarshalAs(UnmanagedType.U1)] bool bAllowAdminTags);

	internal bool SetItemTags(UGCUpdateHandle_t updateHandle, ref SteamParamStringArray_t pTags, [MarshalAs(UnmanagedType.U1)] bool bAllowAdminTags)
	{
		return _SetItemTags(Self, updateHandle, ref pTags, bAllowAdminTags);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetItemContent")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetItemContent(IntPtr self, UGCUpdateHandle_t handle, IntPtr pszContentFolder);

	internal bool SetItemContent(UGCUpdateHandle_t handle, string pszContentFolder)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszContentFolder);
		return _SetItemContent(Self, handle, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetItemPreview")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetItemPreview(IntPtr self, UGCUpdateHandle_t handle, IntPtr pszPreviewFile);

	internal bool SetItemPreview(UGCUpdateHandle_t handle, string pszPreviewFile)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszPreviewFile);
		return _SetItemPreview(Self, handle, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetAllowLegacyUpload")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetAllowLegacyUpload(IntPtr self, UGCUpdateHandle_t handle, [MarshalAs(UnmanagedType.U1)] bool bAllowLegacyUpload);

	internal bool SetAllowLegacyUpload(UGCUpdateHandle_t handle, [MarshalAs(UnmanagedType.U1)] bool bAllowLegacyUpload)
	{
		return _SetAllowLegacyUpload(Self, handle, bAllowLegacyUpload);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_RemoveAllItemKeyValueTags")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _RemoveAllItemKeyValueTags(IntPtr self, UGCUpdateHandle_t handle);

	internal bool RemoveAllItemKeyValueTags(UGCUpdateHandle_t handle)
	{
		return _RemoveAllItemKeyValueTags(Self, handle);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_RemoveItemKeyValueTags")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _RemoveItemKeyValueTags(IntPtr self, UGCUpdateHandle_t handle, IntPtr pchKey);

	internal bool RemoveItemKeyValueTags(UGCUpdateHandle_t handle, string pchKey)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchKey);
		return _RemoveItemKeyValueTags(Self, handle, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_AddItemKeyValueTag")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _AddItemKeyValueTag(IntPtr self, UGCUpdateHandle_t handle, IntPtr pchKey, IntPtr pchValue);

	internal bool AddItemKeyValueTag(UGCUpdateHandle_t handle, string pchKey, string pchValue)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchKey);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchValue);
		return _AddItemKeyValueTag(Self, handle, utf8StringToNative.Pointer, utf8StringToNative2.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_AddItemPreviewFile")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _AddItemPreviewFile(IntPtr self, UGCUpdateHandle_t handle, IntPtr pszPreviewFile, ItemPreviewType type);

	internal bool AddItemPreviewFile(UGCUpdateHandle_t handle, string pszPreviewFile, ItemPreviewType type)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszPreviewFile);
		return _AddItemPreviewFile(Self, handle, utf8StringToNative.Pointer, type);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_AddItemPreviewVideo")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _AddItemPreviewVideo(IntPtr self, UGCUpdateHandle_t handle, IntPtr pszVideoID);

	internal bool AddItemPreviewVideo(UGCUpdateHandle_t handle, string pszVideoID)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszVideoID);
		return _AddItemPreviewVideo(Self, handle, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_UpdateItemPreviewFile")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _UpdateItemPreviewFile(IntPtr self, UGCUpdateHandle_t handle, uint index, IntPtr pszPreviewFile);

	internal bool UpdateItemPreviewFile(UGCUpdateHandle_t handle, uint index, string pszPreviewFile)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszPreviewFile);
		return _UpdateItemPreviewFile(Self, handle, index, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_UpdateItemPreviewVideo")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _UpdateItemPreviewVideo(IntPtr self, UGCUpdateHandle_t handle, uint index, IntPtr pszVideoID);

	internal bool UpdateItemPreviewVideo(UGCUpdateHandle_t handle, uint index, string pszVideoID)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszVideoID);
		return _UpdateItemPreviewVideo(Self, handle, index, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_RemoveItemPreview")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _RemoveItemPreview(IntPtr self, UGCUpdateHandle_t handle, uint index);

	internal bool RemoveItemPreview(UGCUpdateHandle_t handle, uint index)
	{
		return _RemoveItemPreview(Self, handle, index);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_AddContentDescriptor")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _AddContentDescriptor(IntPtr self, UGCUpdateHandle_t handle, UGCContentDescriptorID descid);

	internal bool AddContentDescriptor(UGCUpdateHandle_t handle, UGCContentDescriptorID descid)
	{
		return _AddContentDescriptor(Self, handle, descid);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_RemoveContentDescriptor")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _RemoveContentDescriptor(IntPtr self, UGCUpdateHandle_t handle, UGCContentDescriptorID descid);

	internal bool RemoveContentDescriptor(UGCUpdateHandle_t handle, UGCContentDescriptorID descid)
	{
		return _RemoveContentDescriptor(Self, handle, descid);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetRequiredGameVersions")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetRequiredGameVersions(IntPtr self, UGCUpdateHandle_t handle, IntPtr pszGameBranchMin, IntPtr pszGameBranchMax);

	internal bool SetRequiredGameVersions(UGCUpdateHandle_t handle, string pszGameBranchMin, string pszGameBranchMax)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszGameBranchMin);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pszGameBranchMax);
		return _SetRequiredGameVersions(Self, handle, utf8StringToNative.Pointer, utf8StringToNative2.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SubmitItemUpdate")]
	private static extern SteamAPICall_t _SubmitItemUpdate(IntPtr self, UGCUpdateHandle_t handle, IntPtr pchChangeNote);

	internal CallResult<SubmitItemUpdateResult_t> SubmitItemUpdate(UGCUpdateHandle_t handle, string pchChangeNote)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchChangeNote);
		return new CallResult<SubmitItemUpdateResult_t>(_SubmitItemUpdate(Self, handle, utf8StringToNative.Pointer), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetItemUpdateProgress")]
	private static extern ItemUpdateStatus _GetItemUpdateProgress(IntPtr self, UGCUpdateHandle_t handle, ref ulong punBytesProcessed, ref ulong punBytesTotal);

	internal ItemUpdateStatus GetItemUpdateProgress(UGCUpdateHandle_t handle, ref ulong punBytesProcessed, ref ulong punBytesTotal)
	{
		return _GetItemUpdateProgress(Self, handle, ref punBytesProcessed, ref punBytesTotal);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SetUserItemVote")]
	private static extern SteamAPICall_t _SetUserItemVote(IntPtr self, PublishedFileId nPublishedFileID, [MarshalAs(UnmanagedType.U1)] bool bVoteUp);

	internal CallResult<SetUserItemVoteResult_t> SetUserItemVote(PublishedFileId nPublishedFileID, [MarshalAs(UnmanagedType.U1)] bool bVoteUp)
	{
		return new CallResult<SetUserItemVoteResult_t>(_SetUserItemVote(Self, nPublishedFileID, bVoteUp), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetUserItemVote")]
	private static extern SteamAPICall_t _GetUserItemVote(IntPtr self, PublishedFileId nPublishedFileID);

	internal CallResult<GetUserItemVoteResult_t> GetUserItemVote(PublishedFileId nPublishedFileID)
	{
		return new CallResult<GetUserItemVoteResult_t>(_GetUserItemVote(Self, nPublishedFileID), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_AddItemToFavorites")]
	private static extern SteamAPICall_t _AddItemToFavorites(IntPtr self, AppId nAppId, PublishedFileId nPublishedFileID);

	internal CallResult<UserFavoriteItemsListChanged_t> AddItemToFavorites(AppId nAppId, PublishedFileId nPublishedFileID)
	{
		return new CallResult<UserFavoriteItemsListChanged_t>(_AddItemToFavorites(Self, nAppId, nPublishedFileID), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_RemoveItemFromFavorites")]
	private static extern SteamAPICall_t _RemoveItemFromFavorites(IntPtr self, AppId nAppId, PublishedFileId nPublishedFileID);

	internal CallResult<UserFavoriteItemsListChanged_t> RemoveItemFromFavorites(AppId nAppId, PublishedFileId nPublishedFileID)
	{
		return new CallResult<UserFavoriteItemsListChanged_t>(_RemoveItemFromFavorites(Self, nAppId, nPublishedFileID), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SubscribeItem")]
	private static extern SteamAPICall_t _SubscribeItem(IntPtr self, PublishedFileId nPublishedFileID);

	internal CallResult<RemoteStorageSubscribePublishedFileResult_t> SubscribeItem(PublishedFileId nPublishedFileID)
	{
		return new CallResult<RemoteStorageSubscribePublishedFileResult_t>(_SubscribeItem(Self, nPublishedFileID), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_UnsubscribeItem")]
	private static extern SteamAPICall_t _UnsubscribeItem(IntPtr self, PublishedFileId nPublishedFileID);

	internal CallResult<RemoteStorageUnsubscribePublishedFileResult_t> UnsubscribeItem(PublishedFileId nPublishedFileID)
	{
		return new CallResult<RemoteStorageUnsubscribePublishedFileResult_t>(_UnsubscribeItem(Self, nPublishedFileID), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetNumSubscribedItems")]
	private static extern uint _GetNumSubscribedItems(IntPtr self);

	internal uint GetNumSubscribedItems()
	{
		return _GetNumSubscribedItems(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetSubscribedItems")]
	private static extern uint _GetSubscribedItems(IntPtr self, [In][Out] PublishedFileId[] pvecPublishedFileID, uint cMaxEntries);

	internal uint GetSubscribedItems([In][Out] PublishedFileId[] pvecPublishedFileID, uint cMaxEntries)
	{
		return _GetSubscribedItems(Self, pvecPublishedFileID, cMaxEntries);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetItemState")]
	private static extern uint _GetItemState(IntPtr self, PublishedFileId nPublishedFileID);

	internal uint GetItemState(PublishedFileId nPublishedFileID)
	{
		return _GetItemState(Self, nPublishedFileID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetItemInstallInfo")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetItemInstallInfo(IntPtr self, PublishedFileId nPublishedFileID, ref ulong punSizeOnDisk, IntPtr pchFolder, uint cchFolderSize, ref uint punTimeStamp);

	internal bool GetItemInstallInfo(PublishedFileId nPublishedFileID, ref ulong punSizeOnDisk, out string pchFolder, ref uint punTimeStamp)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			bool result = _GetItemInstallInfo(Self, nPublishedFileID, ref punSizeOnDisk, m, 32768u, ref punTimeStamp);
			pchFolder = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetItemDownloadInfo")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetItemDownloadInfo(IntPtr self, PublishedFileId nPublishedFileID, ref ulong punBytesDownloaded, ref ulong punBytesTotal);

	internal bool GetItemDownloadInfo(PublishedFileId nPublishedFileID, ref ulong punBytesDownloaded, ref ulong punBytesTotal)
	{
		return _GetItemDownloadInfo(Self, nPublishedFileID, ref punBytesDownloaded, ref punBytesTotal);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_DownloadItem")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _DownloadItem(IntPtr self, PublishedFileId nPublishedFileID, [MarshalAs(UnmanagedType.U1)] bool bHighPriority);

	internal bool DownloadItem(PublishedFileId nPublishedFileID, [MarshalAs(UnmanagedType.U1)] bool bHighPriority)
	{
		return _DownloadItem(Self, nPublishedFileID, bHighPriority);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_BInitWorkshopForGameServer")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BInitWorkshopForGameServer(IntPtr self, DepotId_t unWorkshopDepotID, IntPtr pszFolder);

	internal bool BInitWorkshopForGameServer(DepotId_t unWorkshopDepotID, string pszFolder)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pszFolder);
		return _BInitWorkshopForGameServer(Self, unWorkshopDepotID, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_SuspendDownloads")]
	private static extern void _SuspendDownloads(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bSuspend);

	internal void SuspendDownloads([MarshalAs(UnmanagedType.U1)] bool bSuspend)
	{
		_SuspendDownloads(Self, bSuspend);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_StartPlaytimeTracking")]
	private static extern SteamAPICall_t _StartPlaytimeTracking(IntPtr self, [In][Out] PublishedFileId[] pvecPublishedFileID, uint unNumPublishedFileIDs);

	internal CallResult<StartPlaytimeTrackingResult_t> StartPlaytimeTracking([In][Out] PublishedFileId[] pvecPublishedFileID, uint unNumPublishedFileIDs)
	{
		return new CallResult<StartPlaytimeTrackingResult_t>(_StartPlaytimeTracking(Self, pvecPublishedFileID, unNumPublishedFileIDs), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_StopPlaytimeTracking")]
	private static extern SteamAPICall_t _StopPlaytimeTracking(IntPtr self, [In][Out] PublishedFileId[] pvecPublishedFileID, uint unNumPublishedFileIDs);

	internal CallResult<StopPlaytimeTrackingResult_t> StopPlaytimeTracking([In][Out] PublishedFileId[] pvecPublishedFileID, uint unNumPublishedFileIDs)
	{
		return new CallResult<StopPlaytimeTrackingResult_t>(_StopPlaytimeTracking(Self, pvecPublishedFileID, unNumPublishedFileIDs), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_StopPlaytimeTrackingForAllItems")]
	private static extern SteamAPICall_t _StopPlaytimeTrackingForAllItems(IntPtr self);

	internal CallResult<StopPlaytimeTrackingResult_t> StopPlaytimeTrackingForAllItems()
	{
		return new CallResult<StopPlaytimeTrackingResult_t>(_StopPlaytimeTrackingForAllItems(Self), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_AddDependency")]
	private static extern SteamAPICall_t _AddDependency(IntPtr self, PublishedFileId nParentPublishedFileID, PublishedFileId nChildPublishedFileID);

	internal CallResult<AddUGCDependencyResult_t> AddDependency(PublishedFileId nParentPublishedFileID, PublishedFileId nChildPublishedFileID)
	{
		return new CallResult<AddUGCDependencyResult_t>(_AddDependency(Self, nParentPublishedFileID, nChildPublishedFileID), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_RemoveDependency")]
	private static extern SteamAPICall_t _RemoveDependency(IntPtr self, PublishedFileId nParentPublishedFileID, PublishedFileId nChildPublishedFileID);

	internal CallResult<RemoveUGCDependencyResult_t> RemoveDependency(PublishedFileId nParentPublishedFileID, PublishedFileId nChildPublishedFileID)
	{
		return new CallResult<RemoveUGCDependencyResult_t>(_RemoveDependency(Self, nParentPublishedFileID, nChildPublishedFileID), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_AddAppDependency")]
	private static extern SteamAPICall_t _AddAppDependency(IntPtr self, PublishedFileId nPublishedFileID, AppId nAppID);

	internal CallResult<AddAppDependencyResult_t> AddAppDependency(PublishedFileId nPublishedFileID, AppId nAppID)
	{
		return new CallResult<AddAppDependencyResult_t>(_AddAppDependency(Self, nPublishedFileID, nAppID), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_RemoveAppDependency")]
	private static extern SteamAPICall_t _RemoveAppDependency(IntPtr self, PublishedFileId nPublishedFileID, AppId nAppID);

	internal CallResult<RemoveAppDependencyResult_t> RemoveAppDependency(PublishedFileId nPublishedFileID, AppId nAppID)
	{
		return new CallResult<RemoveAppDependencyResult_t>(_RemoveAppDependency(Self, nPublishedFileID, nAppID), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetAppDependencies")]
	private static extern SteamAPICall_t _GetAppDependencies(IntPtr self, PublishedFileId nPublishedFileID);

	internal CallResult<GetAppDependenciesResult_t> GetAppDependencies(PublishedFileId nPublishedFileID)
	{
		return new CallResult<GetAppDependenciesResult_t>(_GetAppDependencies(Self, nPublishedFileID), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_DeleteItem")]
	private static extern SteamAPICall_t _DeleteItem(IntPtr self, PublishedFileId nPublishedFileID);

	internal CallResult<DeleteItemResult_t> DeleteItem(PublishedFileId nPublishedFileID)
	{
		return new CallResult<DeleteItemResult_t>(_DeleteItem(Self, nPublishedFileID), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_ShowWorkshopEULA")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _ShowWorkshopEULA(IntPtr self);

	internal bool ShowWorkshopEULA()
	{
		return _ShowWorkshopEULA(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetWorkshopEULAStatus")]
	private static extern SteamAPICall_t _GetWorkshopEULAStatus(IntPtr self);

	internal CallResult<WorkshopEULAStatus_t> GetWorkshopEULAStatus()
	{
		return new CallResult<WorkshopEULAStatus_t>(_GetWorkshopEULAStatus(Self), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUGC_GetUserContentDescriptorPreferences")]
	private static extern uint _GetUserContentDescriptorPreferences(IntPtr self, [In][Out] UGCContentDescriptorID[] pvecDescriptors, uint cMaxEntries);

	internal uint GetUserContentDescriptorPreferences([In][Out] UGCContentDescriptorID[] pvecDescriptors, uint cMaxEntries)
	{
		return _GetUserContentDescriptorPreferences(Self, pvecDescriptors, cMaxEntries);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamUser : SteamInterface
{
	public const string Version = "SteamUser023";

	internal ISteamUser(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamUser_v023();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamUser_v023();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_GetHSteamUser")]
	private static extern HSteamUser _GetHSteamUser(IntPtr self);

	internal HSteamUser GetHSteamUser()
	{
		return _GetHSteamUser(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_BLoggedOn")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BLoggedOn(IntPtr self);

	internal bool BLoggedOn()
	{
		return _BLoggedOn(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_GetSteamID")]
	private static extern SteamId _GetSteamID(IntPtr self);

	internal SteamId GetSteamID()
	{
		return _GetSteamID(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_InitiateGameConnection_DEPRECATED")]
	private static extern int _InitiateGameConnection_DEPRECATED(IntPtr self, IntPtr pAuthBlob, int cbMaxAuthBlob, SteamId steamIDGameServer, uint unIPServer, ushort usPortServer, [MarshalAs(UnmanagedType.U1)] bool bSecure);

	internal int InitiateGameConnection_DEPRECATED(IntPtr pAuthBlob, int cbMaxAuthBlob, SteamId steamIDGameServer, uint unIPServer, ushort usPortServer, [MarshalAs(UnmanagedType.U1)] bool bSecure)
	{
		return _InitiateGameConnection_DEPRECATED(Self, pAuthBlob, cbMaxAuthBlob, steamIDGameServer, unIPServer, usPortServer, bSecure);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_TerminateGameConnection_DEPRECATED")]
	private static extern void _TerminateGameConnection_DEPRECATED(IntPtr self, uint unIPServer, ushort usPortServer);

	internal void TerminateGameConnection_DEPRECATED(uint unIPServer, ushort usPortServer)
	{
		_TerminateGameConnection_DEPRECATED(Self, unIPServer, usPortServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_TrackAppUsageEvent")]
	private static extern void _TrackAppUsageEvent(IntPtr self, GameId gameID, int eAppUsageEvent, IntPtr pchExtraInfo);

	internal void TrackAppUsageEvent(GameId gameID, int eAppUsageEvent, string pchExtraInfo)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchExtraInfo);
		_TrackAppUsageEvent(Self, gameID, eAppUsageEvent, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_GetUserDataFolder")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetUserDataFolder(IntPtr self, IntPtr pchBuffer, int cubBuffer);

	internal bool GetUserDataFolder(out string pchBuffer)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			bool result = _GetUserDataFolder(Self, m, 32768);
			pchBuffer = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_StartVoiceRecording")]
	private static extern void _StartVoiceRecording(IntPtr self);

	internal void StartVoiceRecording()
	{
		_StartVoiceRecording(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_StopVoiceRecording")]
	private static extern void _StopVoiceRecording(IntPtr self);

	internal void StopVoiceRecording()
	{
		_StopVoiceRecording(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_GetAvailableVoice")]
	private static extern VoiceResult _GetAvailableVoice(IntPtr self, ref uint pcbCompressed, ref uint pcbUncompressed_Deprecated, uint nUncompressedVoiceDesiredSampleRate_Deprecated);

	internal VoiceResult GetAvailableVoice(ref uint pcbCompressed, ref uint pcbUncompressed_Deprecated, uint nUncompressedVoiceDesiredSampleRate_Deprecated)
	{
		return _GetAvailableVoice(Self, ref pcbCompressed, ref pcbUncompressed_Deprecated, nUncompressedVoiceDesiredSampleRate_Deprecated);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_GetVoice")]
	private static extern VoiceResult _GetVoice(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bWantCompressed, IntPtr pDestBuffer, uint cbDestBufferSize, ref uint nBytesWritten, [MarshalAs(UnmanagedType.U1)] bool bWantUncompressed_Deprecated, IntPtr pUncompressedDestBuffer_Deprecated, uint cbUncompressedDestBufferSize_Deprecated, ref uint nUncompressBytesWritten_Deprecated, uint nUncompressedVoiceDesiredSampleRate_Deprecated);

	internal VoiceResult GetVoice([MarshalAs(UnmanagedType.U1)] bool bWantCompressed, IntPtr pDestBuffer, uint cbDestBufferSize, ref uint nBytesWritten, [MarshalAs(UnmanagedType.U1)] bool bWantUncompressed_Deprecated, IntPtr pUncompressedDestBuffer_Deprecated, uint cbUncompressedDestBufferSize_Deprecated, ref uint nUncompressBytesWritten_Deprecated, uint nUncompressedVoiceDesiredSampleRate_Deprecated)
	{
		return _GetVoice(Self, bWantCompressed, pDestBuffer, cbDestBufferSize, ref nBytesWritten, bWantUncompressed_Deprecated, pUncompressedDestBuffer_Deprecated, cbUncompressedDestBufferSize_Deprecated, ref nUncompressBytesWritten_Deprecated, nUncompressedVoiceDesiredSampleRate_Deprecated);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_DecompressVoice")]
	private static extern VoiceResult _DecompressVoice(IntPtr self, IntPtr pCompressed, uint cbCompressed, IntPtr pDestBuffer, uint cbDestBufferSize, ref uint nBytesWritten, uint nDesiredSampleRate);

	internal VoiceResult DecompressVoice(IntPtr pCompressed, uint cbCompressed, IntPtr pDestBuffer, uint cbDestBufferSize, ref uint nBytesWritten, uint nDesiredSampleRate)
	{
		return _DecompressVoice(Self, pCompressed, cbCompressed, pDestBuffer, cbDestBufferSize, ref nBytesWritten, nDesiredSampleRate);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_GetVoiceOptimalSampleRate")]
	private static extern uint _GetVoiceOptimalSampleRate(IntPtr self);

	internal uint GetVoiceOptimalSampleRate()
	{
		return _GetVoiceOptimalSampleRate(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_GetAuthSessionTicket")]
	private static extern HAuthTicket _GetAuthSessionTicket(IntPtr self, IntPtr pTicket, int cbMaxTicket, ref uint pcbTicket, ref NetIdentity pSteamNetworkingIdentity);

	internal HAuthTicket GetAuthSessionTicket(IntPtr pTicket, int cbMaxTicket, ref uint pcbTicket, ref NetIdentity pSteamNetworkingIdentity)
	{
		return _GetAuthSessionTicket(Self, pTicket, cbMaxTicket, ref pcbTicket, ref pSteamNetworkingIdentity);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_GetAuthTicketForWebApi")]
	private static extern HAuthTicket _GetAuthTicketForWebApi(IntPtr self, IntPtr pchIdentity);

	internal HAuthTicket GetAuthTicketForWebApi(string pchIdentity)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchIdentity);
		return _GetAuthTicketForWebApi(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_BeginAuthSession")]
	private static extern BeginAuthResult _BeginAuthSession(IntPtr self, IntPtr pAuthTicket, int cbAuthTicket, SteamId steamID);

	internal BeginAuthResult BeginAuthSession(IntPtr pAuthTicket, int cbAuthTicket, SteamId steamID)
	{
		return _BeginAuthSession(Self, pAuthTicket, cbAuthTicket, steamID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_EndAuthSession")]
	private static extern void _EndAuthSession(IntPtr self, SteamId steamID);

	internal void EndAuthSession(SteamId steamID)
	{
		_EndAuthSession(Self, steamID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_CancelAuthTicket")]
	private static extern void _CancelAuthTicket(IntPtr self, HAuthTicket hAuthTicket);

	internal void CancelAuthTicket(HAuthTicket hAuthTicket)
	{
		_CancelAuthTicket(Self, hAuthTicket);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_UserHasLicenseForApp")]
	private static extern UserHasLicenseForAppResult _UserHasLicenseForApp(IntPtr self, SteamId steamID, AppId appID);

	internal UserHasLicenseForAppResult UserHasLicenseForApp(SteamId steamID, AppId appID)
	{
		return _UserHasLicenseForApp(Self, steamID, appID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_BIsBehindNAT")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsBehindNAT(IntPtr self);

	internal bool BIsBehindNAT()
	{
		return _BIsBehindNAT(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_AdvertiseGame")]
	private static extern void _AdvertiseGame(IntPtr self, SteamId steamIDGameServer, uint unIPServer, ushort usPortServer);

	internal void AdvertiseGame(SteamId steamIDGameServer, uint unIPServer, ushort usPortServer)
	{
		_AdvertiseGame(Self, steamIDGameServer, unIPServer, usPortServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_RequestEncryptedAppTicket")]
	private static extern SteamAPICall_t _RequestEncryptedAppTicket(IntPtr self, IntPtr pDataToInclude, int cbDataToInclude);

	internal CallResult<EncryptedAppTicketResponse_t> RequestEncryptedAppTicket(IntPtr pDataToInclude, int cbDataToInclude)
	{
		return new CallResult<EncryptedAppTicketResponse_t>(_RequestEncryptedAppTicket(Self, pDataToInclude, cbDataToInclude), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_GetEncryptedAppTicket")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetEncryptedAppTicket(IntPtr self, IntPtr pTicket, int cbMaxTicket, ref uint pcbTicket);

	internal bool GetEncryptedAppTicket(IntPtr pTicket, int cbMaxTicket, ref uint pcbTicket)
	{
		return _GetEncryptedAppTicket(Self, pTicket, cbMaxTicket, ref pcbTicket);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_GetGameBadgeLevel")]
	private static extern int _GetGameBadgeLevel(IntPtr self, int nSeries, [MarshalAs(UnmanagedType.U1)] bool bFoil);

	internal int GetGameBadgeLevel(int nSeries, [MarshalAs(UnmanagedType.U1)] bool bFoil)
	{
		return _GetGameBadgeLevel(Self, nSeries, bFoil);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_GetPlayerSteamLevel")]
	private static extern int _GetPlayerSteamLevel(IntPtr self);

	internal int GetPlayerSteamLevel()
	{
		return _GetPlayerSteamLevel(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_RequestStoreAuthURL")]
	private static extern SteamAPICall_t _RequestStoreAuthURL(IntPtr self, IntPtr pchRedirectURL);

	internal CallResult<StoreAuthURLResponse_t> RequestStoreAuthURL(string pchRedirectURL)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchRedirectURL);
		return new CallResult<StoreAuthURLResponse_t>(_RequestStoreAuthURL(Self, utf8StringToNative.Pointer), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_BIsPhoneVerified")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsPhoneVerified(IntPtr self);

	internal bool BIsPhoneVerified()
	{
		return _BIsPhoneVerified(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_BIsTwoFactorEnabled")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsTwoFactorEnabled(IntPtr self);

	internal bool BIsTwoFactorEnabled()
	{
		return _BIsTwoFactorEnabled(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_BIsPhoneIdentifying")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsPhoneIdentifying(IntPtr self);

	internal bool BIsPhoneIdentifying()
	{
		return _BIsPhoneIdentifying(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_BIsPhoneRequiringVerification")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BIsPhoneRequiringVerification(IntPtr self);

	internal bool BIsPhoneRequiringVerification()
	{
		return _BIsPhoneRequiringVerification(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_GetMarketEligibility")]
	private static extern SteamAPICall_t _GetMarketEligibility(IntPtr self);

	internal CallResult<MarketEligibilityResponse_t> GetMarketEligibility()
	{
		return new CallResult<MarketEligibilityResponse_t>(_GetMarketEligibility(Self), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_GetDurationControl")]
	private static extern SteamAPICall_t _GetDurationControl(IntPtr self);

	internal CallResult<DurationControl_t> GetDurationControl()
	{
		return new CallResult<DurationControl_t>(_GetDurationControl(Self), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUser_BSetDurationControlOnlineState")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BSetDurationControlOnlineState(IntPtr self, DurationControlOnlineState eNewState);

	internal bool BSetDurationControlOnlineState(DurationControlOnlineState eNewState)
	{
		return _BSetDurationControlOnlineState(Self, eNewState);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamUserStats : SteamInterface
{
	public const string Version = "STEAMUSERSTATS_INTERFACE_VERSION013";

	internal ISteamUserStats(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamUserStats_v013();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamUserStats_v013();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetStatInt32")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetStat(IntPtr self, IntPtr pchName, ref int pData);

	internal bool GetStat(string pchName, ref int pData)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _GetStat(Self, utf8StringToNative.Pointer, ref pData);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetStatFloat")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetStat(IntPtr self, IntPtr pchName, ref float pData);

	internal bool GetStat(string pchName, ref float pData)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _GetStat(Self, utf8StringToNative.Pointer, ref pData);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_SetStatInt32")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetStat(IntPtr self, IntPtr pchName, int nData);

	internal bool SetStat(string pchName, int nData)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _SetStat(Self, utf8StringToNative.Pointer, nData);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_SetStatFloat")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetStat(IntPtr self, IntPtr pchName, float fData);

	internal bool SetStat(string pchName, float fData)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _SetStat(Self, utf8StringToNative.Pointer, fData);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_UpdateAvgRateStat")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _UpdateAvgRateStat(IntPtr self, IntPtr pchName, float flCountThisSession, double dSessionLength);

	internal bool UpdateAvgRateStat(string pchName, float flCountThisSession, double dSessionLength)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _UpdateAvgRateStat(Self, utf8StringToNative.Pointer, flCountThisSession, dSessionLength);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetAchievement")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetAchievement(IntPtr self, IntPtr pchName, [MarshalAs(UnmanagedType.U1)] ref bool pbAchieved);

	internal bool GetAchievement(string pchName, [MarshalAs(UnmanagedType.U1)] ref bool pbAchieved)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _GetAchievement(Self, utf8StringToNative.Pointer, ref pbAchieved);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_SetAchievement")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _SetAchievement(IntPtr self, IntPtr pchName);

	internal bool SetAchievement(string pchName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _SetAchievement(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_ClearAchievement")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _ClearAchievement(IntPtr self, IntPtr pchName);

	internal bool ClearAchievement(string pchName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _ClearAchievement(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetAchievementAndUnlockTime")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetAchievementAndUnlockTime(IntPtr self, IntPtr pchName, [MarshalAs(UnmanagedType.U1)] ref bool pbAchieved, ref uint punUnlockTime);

	internal bool GetAchievementAndUnlockTime(string pchName, [MarshalAs(UnmanagedType.U1)] ref bool pbAchieved, ref uint punUnlockTime)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _GetAchievementAndUnlockTime(Self, utf8StringToNative.Pointer, ref pbAchieved, ref punUnlockTime);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_StoreStats")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _StoreStats(IntPtr self);

	internal bool StoreStats()
	{
		return _StoreStats(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetAchievementIcon")]
	private static extern int _GetAchievementIcon(IntPtr self, IntPtr pchName);

	internal int GetAchievementIcon(string pchName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _GetAchievementIcon(Self, utf8StringToNative.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetAchievementDisplayAttribute")]
	private static extern Utf8StringPointer _GetAchievementDisplayAttribute(IntPtr self, IntPtr pchName, IntPtr pchKey);

	internal string GetAchievementDisplayAttribute(string pchName, string pchKey)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchKey);
		return _GetAchievementDisplayAttribute(Self, utf8StringToNative.Pointer, utf8StringToNative2.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_IndicateAchievementProgress")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _IndicateAchievementProgress(IntPtr self, IntPtr pchName, uint nCurProgress, uint nMaxProgress);

	internal bool IndicateAchievementProgress(string pchName, uint nCurProgress, uint nMaxProgress)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _IndicateAchievementProgress(Self, utf8StringToNative.Pointer, nCurProgress, nMaxProgress);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetNumAchievements")]
	private static extern uint _GetNumAchievements(IntPtr self);

	internal uint GetNumAchievements()
	{
		return _GetNumAchievements(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetAchievementName")]
	private static extern Utf8StringPointer _GetAchievementName(IntPtr self, uint iAchievement);

	internal string GetAchievementName(uint iAchievement)
	{
		return _GetAchievementName(Self, iAchievement);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_RequestUserStats")]
	private static extern SteamAPICall_t _RequestUserStats(IntPtr self, SteamId steamIDUser);

	internal CallResult<UserStatsReceived_t> RequestUserStats(SteamId steamIDUser)
	{
		return new CallResult<UserStatsReceived_t>(_RequestUserStats(Self, steamIDUser), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetUserStatInt32")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetUserStat(IntPtr self, SteamId steamIDUser, IntPtr pchName, ref int pData);

	internal bool GetUserStat(SteamId steamIDUser, string pchName, ref int pData)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _GetUserStat(Self, steamIDUser, utf8StringToNative.Pointer, ref pData);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetUserStatFloat")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetUserStat(IntPtr self, SteamId steamIDUser, IntPtr pchName, ref float pData);

	internal bool GetUserStat(SteamId steamIDUser, string pchName, ref float pData)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _GetUserStat(Self, steamIDUser, utf8StringToNative.Pointer, ref pData);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetUserAchievement")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetUserAchievement(IntPtr self, SteamId steamIDUser, IntPtr pchName, [MarshalAs(UnmanagedType.U1)] ref bool pbAchieved);

	internal bool GetUserAchievement(SteamId steamIDUser, string pchName, [MarshalAs(UnmanagedType.U1)] ref bool pbAchieved)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _GetUserAchievement(Self, steamIDUser, utf8StringToNative.Pointer, ref pbAchieved);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetUserAchievementAndUnlockTime")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetUserAchievementAndUnlockTime(IntPtr self, SteamId steamIDUser, IntPtr pchName, [MarshalAs(UnmanagedType.U1)] ref bool pbAchieved, ref uint punUnlockTime);

	internal bool GetUserAchievementAndUnlockTime(SteamId steamIDUser, string pchName, [MarshalAs(UnmanagedType.U1)] ref bool pbAchieved, ref uint punUnlockTime)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _GetUserAchievementAndUnlockTime(Self, steamIDUser, utf8StringToNative.Pointer, ref pbAchieved, ref punUnlockTime);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_ResetAllStats")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _ResetAllStats(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bAchievementsToo);

	internal bool ResetAllStats([MarshalAs(UnmanagedType.U1)] bool bAchievementsToo)
	{
		return _ResetAllStats(Self, bAchievementsToo);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_FindOrCreateLeaderboard")]
	private static extern SteamAPICall_t _FindOrCreateLeaderboard(IntPtr self, IntPtr pchLeaderboardName, LeaderboardSort eLeaderboardSortMethod, LeaderboardDisplay eLeaderboardDisplayType);

	internal CallResult<LeaderboardFindResult_t> FindOrCreateLeaderboard(string pchLeaderboardName, LeaderboardSort eLeaderboardSortMethod, LeaderboardDisplay eLeaderboardDisplayType)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchLeaderboardName);
		return new CallResult<LeaderboardFindResult_t>(_FindOrCreateLeaderboard(Self, utf8StringToNative.Pointer, eLeaderboardSortMethod, eLeaderboardDisplayType), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_FindLeaderboard")]
	private static extern SteamAPICall_t _FindLeaderboard(IntPtr self, IntPtr pchLeaderboardName);

	internal CallResult<LeaderboardFindResult_t> FindLeaderboard(string pchLeaderboardName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchLeaderboardName);
		return new CallResult<LeaderboardFindResult_t>(_FindLeaderboard(Self, utf8StringToNative.Pointer), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetLeaderboardName")]
	private static extern Utf8StringPointer _GetLeaderboardName(IntPtr self, SteamLeaderboard_t hSteamLeaderboard);

	internal string GetLeaderboardName(SteamLeaderboard_t hSteamLeaderboard)
	{
		return _GetLeaderboardName(Self, hSteamLeaderboard);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetLeaderboardEntryCount")]
	private static extern int _GetLeaderboardEntryCount(IntPtr self, SteamLeaderboard_t hSteamLeaderboard);

	internal int GetLeaderboardEntryCount(SteamLeaderboard_t hSteamLeaderboard)
	{
		return _GetLeaderboardEntryCount(Self, hSteamLeaderboard);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetLeaderboardSortMethod")]
	private static extern LeaderboardSort _GetLeaderboardSortMethod(IntPtr self, SteamLeaderboard_t hSteamLeaderboard);

	internal LeaderboardSort GetLeaderboardSortMethod(SteamLeaderboard_t hSteamLeaderboard)
	{
		return _GetLeaderboardSortMethod(Self, hSteamLeaderboard);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetLeaderboardDisplayType")]
	private static extern LeaderboardDisplay _GetLeaderboardDisplayType(IntPtr self, SteamLeaderboard_t hSteamLeaderboard);

	internal LeaderboardDisplay GetLeaderboardDisplayType(SteamLeaderboard_t hSteamLeaderboard)
	{
		return _GetLeaderboardDisplayType(Self, hSteamLeaderboard);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_DownloadLeaderboardEntries")]
	private static extern SteamAPICall_t _DownloadLeaderboardEntries(IntPtr self, SteamLeaderboard_t hSteamLeaderboard, LeaderboardDataRequest eLeaderboardDataRequest, int nRangeStart, int nRangeEnd);

	internal CallResult<LeaderboardScoresDownloaded_t> DownloadLeaderboardEntries(SteamLeaderboard_t hSteamLeaderboard, LeaderboardDataRequest eLeaderboardDataRequest, int nRangeStart, int nRangeEnd)
	{
		return new CallResult<LeaderboardScoresDownloaded_t>(_DownloadLeaderboardEntries(Self, hSteamLeaderboard, eLeaderboardDataRequest, nRangeStart, nRangeEnd), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_DownloadLeaderboardEntriesForUsers")]
	private static extern SteamAPICall_t _DownloadLeaderboardEntriesForUsers(IntPtr self, SteamLeaderboard_t hSteamLeaderboard, [In][Out] SteamId[] prgUsers, int cUsers);

	internal CallResult<LeaderboardScoresDownloaded_t> DownloadLeaderboardEntriesForUsers(SteamLeaderboard_t hSteamLeaderboard, [In][Out] SteamId[] prgUsers, int cUsers)
	{
		return new CallResult<LeaderboardScoresDownloaded_t>(_DownloadLeaderboardEntriesForUsers(Self, hSteamLeaderboard, prgUsers, cUsers), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetDownloadedLeaderboardEntry")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetDownloadedLeaderboardEntry(IntPtr self, SteamLeaderboardEntries_t hSteamLeaderboardEntries, int index, ref LeaderboardEntry_t pLeaderboardEntry, [In][Out] int[] pDetails, int cDetailsMax);

	internal bool GetDownloadedLeaderboardEntry(SteamLeaderboardEntries_t hSteamLeaderboardEntries, int index, ref LeaderboardEntry_t pLeaderboardEntry, [In][Out] int[] pDetails, int cDetailsMax)
	{
		return _GetDownloadedLeaderboardEntry(Self, hSteamLeaderboardEntries, index, ref pLeaderboardEntry, pDetails, cDetailsMax);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_UploadLeaderboardScore")]
	private static extern SteamAPICall_t _UploadLeaderboardScore(IntPtr self, SteamLeaderboard_t hSteamLeaderboard, LeaderboardUploadScoreMethod eLeaderboardUploadScoreMethod, int nScore, [In][Out] int[] pScoreDetails, int cScoreDetailsCount);

	internal CallResult<LeaderboardScoreUploaded_t> UploadLeaderboardScore(SteamLeaderboard_t hSteamLeaderboard, LeaderboardUploadScoreMethod eLeaderboardUploadScoreMethod, int nScore, [In][Out] int[] pScoreDetails, int cScoreDetailsCount)
	{
		return new CallResult<LeaderboardScoreUploaded_t>(_UploadLeaderboardScore(Self, hSteamLeaderboard, eLeaderboardUploadScoreMethod, nScore, pScoreDetails, cScoreDetailsCount), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_AttachLeaderboardUGC")]
	private static extern SteamAPICall_t _AttachLeaderboardUGC(IntPtr self, SteamLeaderboard_t hSteamLeaderboard, UGCHandle_t hUGC);

	internal CallResult<LeaderboardUGCSet_t> AttachLeaderboardUGC(SteamLeaderboard_t hSteamLeaderboard, UGCHandle_t hUGC)
	{
		return new CallResult<LeaderboardUGCSet_t>(_AttachLeaderboardUGC(Self, hSteamLeaderboard, hUGC), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetNumberOfCurrentPlayers")]
	private static extern SteamAPICall_t _GetNumberOfCurrentPlayers(IntPtr self);

	internal CallResult<NumberOfCurrentPlayers_t> GetNumberOfCurrentPlayers()
	{
		return new CallResult<NumberOfCurrentPlayers_t>(_GetNumberOfCurrentPlayers(Self), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_RequestGlobalAchievementPercentages")]
	private static extern SteamAPICall_t _RequestGlobalAchievementPercentages(IntPtr self);

	internal CallResult<GlobalAchievementPercentagesReady_t> RequestGlobalAchievementPercentages()
	{
		return new CallResult<GlobalAchievementPercentagesReady_t>(_RequestGlobalAchievementPercentages(Self), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetMostAchievedAchievementInfo")]
	private static extern int _GetMostAchievedAchievementInfo(IntPtr self, IntPtr pchName, uint unNameBufLen, ref float pflPercent, [MarshalAs(UnmanagedType.U1)] ref bool pbAchieved);

	internal int GetMostAchievedAchievementInfo(out string pchName, ref float pflPercent, [MarshalAs(UnmanagedType.U1)] ref bool pbAchieved)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			int result = _GetMostAchievedAchievementInfo(Self, m, 32768u, ref pflPercent, ref pbAchieved);
			pchName = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetNextMostAchievedAchievementInfo")]
	private static extern int _GetNextMostAchievedAchievementInfo(IntPtr self, int iIteratorPrevious, IntPtr pchName, uint unNameBufLen, ref float pflPercent, [MarshalAs(UnmanagedType.U1)] ref bool pbAchieved);

	internal int GetNextMostAchievedAchievementInfo(int iIteratorPrevious, out string pchName, ref float pflPercent, [MarshalAs(UnmanagedType.U1)] ref bool pbAchieved)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			int result = _GetNextMostAchievedAchievementInfo(Self, iIteratorPrevious, m, 32768u, ref pflPercent, ref pbAchieved);
			pchName = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetAchievementAchievedPercent")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetAchievementAchievedPercent(IntPtr self, IntPtr pchName, ref float pflPercent);

	internal bool GetAchievementAchievedPercent(string pchName, ref float pflPercent)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _GetAchievementAchievedPercent(Self, utf8StringToNative.Pointer, ref pflPercent);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_RequestGlobalStats")]
	private static extern SteamAPICall_t _RequestGlobalStats(IntPtr self, int nHistoryDays);

	internal CallResult<GlobalStatsReceived_t> RequestGlobalStats(int nHistoryDays)
	{
		return new CallResult<GlobalStatsReceived_t>(_RequestGlobalStats(Self, nHistoryDays), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetGlobalStatInt64")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetGlobalStat(IntPtr self, IntPtr pchStatName, ref long pData);

	internal bool GetGlobalStat(string pchStatName, ref long pData)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchStatName);
		return _GetGlobalStat(Self, utf8StringToNative.Pointer, ref pData);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetGlobalStatDouble")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetGlobalStat(IntPtr self, IntPtr pchStatName, ref double pData);

	internal bool GetGlobalStat(string pchStatName, ref double pData)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchStatName);
		return _GetGlobalStat(Self, utf8StringToNative.Pointer, ref pData);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetGlobalStatHistoryInt64")]
	private static extern int _GetGlobalStatHistory(IntPtr self, IntPtr pchStatName, [In][Out] long[] pData, uint cubData);

	internal int GetGlobalStatHistory(string pchStatName, [In][Out] long[] pData, uint cubData)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchStatName);
		return _GetGlobalStatHistory(Self, utf8StringToNative.Pointer, pData, cubData);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetGlobalStatHistoryDouble")]
	private static extern int _GetGlobalStatHistory(IntPtr self, IntPtr pchStatName, [In][Out] double[] pData, uint cubData);

	internal int GetGlobalStatHistory(string pchStatName, [In][Out] double[] pData, uint cubData)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchStatName);
		return _GetGlobalStatHistory(Self, utf8StringToNative.Pointer, pData, cubData);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetAchievementProgressLimitsInt32")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetAchievementProgressLimits(IntPtr self, IntPtr pchName, ref int pnMinProgress, ref int pnMaxProgress);

	internal bool GetAchievementProgressLimits(string pchName, ref int pnMinProgress, ref int pnMaxProgress)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _GetAchievementProgressLimits(Self, utf8StringToNative.Pointer, ref pnMinProgress, ref pnMaxProgress);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUserStats_GetAchievementProgressLimitsFloat")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetAchievementProgressLimits(IntPtr self, IntPtr pchName, ref float pfMinProgress, ref float pfMaxProgress);

	internal bool GetAchievementProgressLimits(string pchName, ref float pfMinProgress, ref float pfMaxProgress)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchName);
		return _GetAchievementProgressLimits(Self, utf8StringToNative.Pointer, ref pfMinProgress, ref pfMaxProgress);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

internal class ISteamUtils : SteamInterface
{
	public const string Version = "SteamUtils010";

	internal ISteamUtils(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamUtils_v010();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamUtils_v010();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamGameServerUtils_v010();

	public override IntPtr GetServerInterfacePointer()
	{
		return SteamAPI_SteamGameServerUtils_v010();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_GetSecondsSinceAppActive")]
	private static extern uint _GetSecondsSinceAppActive(IntPtr self);

	internal uint GetSecondsSinceAppActive()
	{
		return _GetSecondsSinceAppActive(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_GetSecondsSinceComputerActive")]
	private static extern uint _GetSecondsSinceComputerActive(IntPtr self);

	internal uint GetSecondsSinceComputerActive()
	{
		return _GetSecondsSinceComputerActive(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_GetConnectedUniverse")]
	private static extern Universe _GetConnectedUniverse(IntPtr self);

	internal Universe GetConnectedUniverse()
	{
		return _GetConnectedUniverse(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_GetServerRealTime")]
	private static extern uint _GetServerRealTime(IntPtr self);

	internal uint GetServerRealTime()
	{
		return _GetServerRealTime(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_GetIPCountry")]
	private static extern Utf8StringPointer _GetIPCountry(IntPtr self);

	internal string GetIPCountry()
	{
		return _GetIPCountry(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_GetImageSize")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetImageSize(IntPtr self, int iImage, ref uint pnWidth, ref uint pnHeight);

	internal bool GetImageSize(int iImage, ref uint pnWidth, ref uint pnHeight)
	{
		return _GetImageSize(Self, iImage, ref pnWidth, ref pnHeight);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_GetImageRGBA")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetImageRGBA(IntPtr self, int iImage, [In][Out] byte[] pubDest, int nDestBufferSize);

	internal bool GetImageRGBA(int iImage, [In][Out] byte[] pubDest, int nDestBufferSize)
	{
		return _GetImageRGBA(Self, iImage, pubDest, nDestBufferSize);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_GetCurrentBatteryPower")]
	private static extern byte _GetCurrentBatteryPower(IntPtr self);

	internal byte GetCurrentBatteryPower()
	{
		return _GetCurrentBatteryPower(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_GetAppID")]
	private static extern uint _GetAppID(IntPtr self);

	internal uint GetAppID()
	{
		return _GetAppID(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_SetOverlayNotificationPosition")]
	private static extern void _SetOverlayNotificationPosition(IntPtr self, NotificationPosition eNotificationPosition);

	internal void SetOverlayNotificationPosition(NotificationPosition eNotificationPosition)
	{
		_SetOverlayNotificationPosition(Self, eNotificationPosition);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_IsAPICallCompleted")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _IsAPICallCompleted(IntPtr self, SteamAPICall_t hSteamAPICall, [MarshalAs(UnmanagedType.U1)] ref bool pbFailed);

	internal bool IsAPICallCompleted(SteamAPICall_t hSteamAPICall, [MarshalAs(UnmanagedType.U1)] ref bool pbFailed)
	{
		return _IsAPICallCompleted(Self, hSteamAPICall, ref pbFailed);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_GetAPICallFailureReason")]
	private static extern SteamAPICallFailure _GetAPICallFailureReason(IntPtr self, SteamAPICall_t hSteamAPICall);

	internal SteamAPICallFailure GetAPICallFailureReason(SteamAPICall_t hSteamAPICall)
	{
		return _GetAPICallFailureReason(Self, hSteamAPICall);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_GetAPICallResult")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetAPICallResult(IntPtr self, SteamAPICall_t hSteamAPICall, IntPtr pCallback, int cubCallback, int iCallbackExpected, [MarshalAs(UnmanagedType.U1)] ref bool pbFailed);

	internal bool GetAPICallResult(SteamAPICall_t hSteamAPICall, IntPtr pCallback, int cubCallback, int iCallbackExpected, [MarshalAs(UnmanagedType.U1)] ref bool pbFailed)
	{
		return _GetAPICallResult(Self, hSteamAPICall, pCallback, cubCallback, iCallbackExpected, ref pbFailed);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_GetIPCCallCount")]
	private static extern uint _GetIPCCallCount(IntPtr self);

	internal uint GetIPCCallCount()
	{
		return _GetIPCCallCount(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_SetWarningMessageHook")]
	private static extern void _SetWarningMessageHook(IntPtr self, IntPtr pFunction);

	internal void SetWarningMessageHook(IntPtr pFunction)
	{
		_SetWarningMessageHook(Self, pFunction);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_IsOverlayEnabled")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _IsOverlayEnabled(IntPtr self);

	internal bool IsOverlayEnabled()
	{
		return _IsOverlayEnabled(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_BOverlayNeedsPresent")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _BOverlayNeedsPresent(IntPtr self);

	internal bool BOverlayNeedsPresent()
	{
		return _BOverlayNeedsPresent(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_CheckFileSignature")]
	private static extern SteamAPICall_t _CheckFileSignature(IntPtr self, IntPtr szFileName);

	internal CallResult<CheckFileSignature_t> CheckFileSignature(string szFileName)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(szFileName);
		return new CallResult<CheckFileSignature_t>(_CheckFileSignature(Self, utf8StringToNative.Pointer), base.IsServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_ShowGamepadTextInput")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _ShowGamepadTextInput(IntPtr self, GamepadTextInputMode eInputMode, GamepadTextInputLineMode eLineInputMode, IntPtr pchDescription, uint unCharMax, IntPtr pchExistingText);

	internal bool ShowGamepadTextInput(GamepadTextInputMode eInputMode, GamepadTextInputLineMode eLineInputMode, string pchDescription, uint unCharMax, string pchExistingText)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchDescription);
		using Utf8StringToNative utf8StringToNative2 = new Utf8StringToNative(pchExistingText);
		return _ShowGamepadTextInput(Self, eInputMode, eLineInputMode, utf8StringToNative.Pointer, unCharMax, utf8StringToNative2.Pointer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_GetEnteredGamepadTextLength")]
	private static extern uint _GetEnteredGamepadTextLength(IntPtr self);

	internal uint GetEnteredGamepadTextLength()
	{
		return _GetEnteredGamepadTextLength(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_GetEnteredGamepadTextInput")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetEnteredGamepadTextInput(IntPtr self, IntPtr pchText, uint cchText);

	internal bool GetEnteredGamepadTextInput(out string pchText)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			bool result = _GetEnteredGamepadTextInput(Self, m, 32768u);
			pchText = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_GetSteamUILanguage")]
	private static extern Utf8StringPointer _GetSteamUILanguage(IntPtr self);

	internal string GetSteamUILanguage()
	{
		return _GetSteamUILanguage(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_IsSteamRunningInVR")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _IsSteamRunningInVR(IntPtr self);

	internal bool IsSteamRunningInVR()
	{
		return _IsSteamRunningInVR(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_SetOverlayNotificationInset")]
	private static extern void _SetOverlayNotificationInset(IntPtr self, int nHorizontalInset, int nVerticalInset);

	internal void SetOverlayNotificationInset(int nHorizontalInset, int nVerticalInset)
	{
		_SetOverlayNotificationInset(Self, nHorizontalInset, nVerticalInset);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_IsSteamInBigPictureMode")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _IsSteamInBigPictureMode(IntPtr self);

	internal bool IsSteamInBigPictureMode()
	{
		return _IsSteamInBigPictureMode(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_StartVRDashboard")]
	private static extern void _StartVRDashboard(IntPtr self);

	internal void StartVRDashboard()
	{
		_StartVRDashboard(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_IsVRHeadsetStreamingEnabled")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _IsVRHeadsetStreamingEnabled(IntPtr self);

	internal bool IsVRHeadsetStreamingEnabled()
	{
		return _IsVRHeadsetStreamingEnabled(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_SetVRHeadsetStreamingEnabled")]
	private static extern void _SetVRHeadsetStreamingEnabled(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bEnabled);

	internal void SetVRHeadsetStreamingEnabled([MarshalAs(UnmanagedType.U1)] bool bEnabled)
	{
		_SetVRHeadsetStreamingEnabled(Self, bEnabled);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_IsSteamChinaLauncher")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _IsSteamChinaLauncher(IntPtr self);

	internal bool IsSteamChinaLauncher()
	{
		return _IsSteamChinaLauncher(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_InitFilterText")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _InitFilterText(IntPtr self, uint unFilterOptions);

	internal bool InitFilterText(uint unFilterOptions)
	{
		return _InitFilterText(Self, unFilterOptions);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_FilterText")]
	private static extern int _FilterText(IntPtr self, TextFilteringContext eContext, SteamId sourceSteamID, IntPtr pchInputMessage, IntPtr pchOutFilteredText, uint nByteSizeOutFilteredText);

	internal int FilterText(TextFilteringContext eContext, SteamId sourceSteamID, string pchInputMessage, out string pchOutFilteredText)
	{
		using Utf8StringToNative utf8StringToNative = new Utf8StringToNative(pchInputMessage);
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			int result = _FilterText(Self, eContext, sourceSteamID, utf8StringToNative.Pointer, m, 32768u);
			pchOutFilteredText = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_GetIPv6ConnectivityState")]
	private static extern SteamIPv6ConnectivityState _GetIPv6ConnectivityState(IntPtr self, SteamIPv6ConnectivityProtocol eProtocol);

	internal SteamIPv6ConnectivityState GetIPv6ConnectivityState(SteamIPv6ConnectivityProtocol eProtocol)
	{
		return _GetIPv6ConnectivityState(Self, eProtocol);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_IsSteamRunningOnSteamDeck")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _IsSteamRunningOnSteamDeck(IntPtr self);

	internal bool IsSteamRunningOnSteamDeck()
	{
		return _IsSteamRunningOnSteamDeck(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_ShowFloatingGamepadTextInput")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _ShowFloatingGamepadTextInput(IntPtr self, TextInputMode eKeyboardMode, int nTextFieldXPosition, int nTextFieldYPosition, int nTextFieldWidth, int nTextFieldHeight);

	internal bool ShowFloatingGamepadTextInput(TextInputMode eKeyboardMode, int nTextFieldXPosition, int nTextFieldYPosition, int nTextFieldWidth, int nTextFieldHeight)
	{
		return _ShowFloatingGamepadTextInput(Self, eKeyboardMode, nTextFieldXPosition, nTextFieldYPosition, nTextFieldWidth, nTextFieldHeight);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_SetGameLauncherMode")]
	private static extern void _SetGameLauncherMode(IntPtr self, [MarshalAs(UnmanagedType.U1)] bool bLauncherMode);

	internal void SetGameLauncherMode([MarshalAs(UnmanagedType.U1)] bool bLauncherMode)
	{
		_SetGameLauncherMode(Self, bLauncherMode);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_DismissFloatingGamepadTextInput")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _DismissFloatingGamepadTextInput(IntPtr self);

	internal bool DismissFloatingGamepadTextInput()
	{
		return _DismissFloatingGamepadTextInput(Self);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamUtils_DismissGamepadTextInput")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _DismissGamepadTextInput(IntPtr self);

	internal bool DismissGamepadTextInput()
	{
		return _DismissGamepadTextInput(Self);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;

internal class ISteamVideo : SteamInterface
{
	public const string Version = "STEAMVIDEO_INTERFACE_V007";

	internal ISteamVideo(bool IsGameServer)
	{
		SetupInterface(IsGameServer);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr SteamAPI_SteamVideo_v007();

	public override IntPtr GetUserInterfacePointer()
	{
		return SteamAPI_SteamVideo_v007();
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamVideo_GetVideoURL")]
	private static extern void _GetVideoURL(IntPtr self, AppId unVideoAppID);

	internal void GetVideoURL(AppId unVideoAppID)
	{
		_GetVideoURL(Self, unVideoAppID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamVideo_IsBroadcasting")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _IsBroadcasting(IntPtr self, ref int pnNumViewers);

	internal bool IsBroadcasting(ref int pnNumViewers)
	{
		return _IsBroadcasting(Self, ref pnNumViewers);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamVideo_GetOPFSettings")]
	private static extern void _GetOPFSettings(IntPtr self, AppId unVideoAppID);

	internal void GetOPFSettings(AppId unVideoAppID)
	{
		_GetOPFSettings(Self, unVideoAppID);
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_ISteamVideo_GetOPFStringForApp")]
	[return: MarshalAs(UnmanagedType.I1)]
	private static extern bool _GetOPFStringForApp(IntPtr self, AppId unVideoAppID, IntPtr pchBuffer, ref int pnBufferSize);

	internal bool GetOPFStringForApp(AppId unVideoAppID, out string pchBuffer)
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			int pnBufferSize = 32768;
			bool result = _GetOPFStringForApp(Self, unVideoAppID, m, ref pnBufferSize);
			pchBuffer = Helpers.MemoryToString(m);
			return result;
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}
}


internal enum SteamIPType
{
	Type4,
	Type6
}


public enum Universe
{
	Invalid,
	Public,
	Beta,
	Internal,
	Dev,
	Max
}


public enum Result
{
	None = 0,
	OK = 1,
	Fail = 2,
	NoConnection = 3,
	InvalidPassword = 5,
	LoggedInElsewhere = 6,
	InvalidProtocolVer = 7,
	InvalidParam = 8,
	FileNotFound = 9,
	Busy = 10,
	InvalidState = 11,
	InvalidName = 12,
	InvalidEmail = 13,
	DuplicateName = 14,
	AccessDenied = 15,
	Timeout = 16,
	Banned = 17,
	AccountNotFound = 18,
	InvalidSteamID = 19,
	ServiceUnavailable = 20,
	NotLoggedOn = 21,
	Pending = 22,
	EncryptionFailure = 23,
	InsufficientPrivilege = 24,
	LimitExceeded = 25,
	Revoked = 26,
	Expired = 27,
	AlreadyRedeemed = 28,
	DuplicateRequest = 29,
	AlreadyOwned = 30,
	IPNotFound = 31,
	PersistFailed = 32,
	LockingFailed = 33,
	LogonSessionReplaced = 34,
	ConnectFailed = 35,
	HandshakeFailed = 36,
	IOFailure = 37,
	RemoteDisconnect = 38,
	ShoppingCartNotFound = 39,
	Blocked = 40,
	Ignored = 41,
	NoMatch = 42,
	AccountDisabled = 43,
	ServiceReadOnly = 44,
	AccountNotFeatured = 45,
	AdministratorOK = 46,
	ContentVersion = 47,
	TryAnotherCM = 48,
	PasswordRequiredToKickSession = 49,
	AlreadyLoggedInElsewhere = 50,
	Suspended = 51,
	Cancelled = 52,
	DataCorruption = 53,
	DiskFull = 54,
	RemoteCallFailed = 55,
	PasswordUnset = 56,
	ExternalAccountUnlinked = 57,
	PSNTicketInvalid = 58,
	ExternalAccountAlreadyLinked = 59,
	RemoteFileConflict = 60,
	IllegalPassword = 61,
	SameAsPreviousValue = 62,
	AccountLogonDenied = 63,
	CannotUseOldPassword = 64,
	InvalidLoginAuthCode = 65,
	AccountLogonDeniedNoMail = 66,
	HardwareNotCapableOfIPT = 67,
	IPTInitError = 68,
	ParentalControlRestricted = 69,
	FacebookQueryError = 70,
	ExpiredLoginAuthCode = 71,
	IPLoginRestrictionFailed = 72,
	AccountLockedDown = 73,
	AccountLogonDeniedVerifiedEmailRequired = 74,
	NoMatchingURL = 75,
	BadResponse = 76,
	RequirePasswordReEntry = 77,
	ValueOutOfRange = 78,
	UnexpectedError = 79,
	Disabled = 80,
	InvalidCEGSubmission = 81,
	RestrictedDevice = 82,
	RegionLocked = 83,
	RateLimitExceeded = 84,
	AccountLoginDeniedNeedTwoFactor = 85,
	ItemDeleted = 86,
	AccountLoginDeniedThrottle = 87,
	TwoFactorCodeMismatch = 88,
	TwoFactorActivationCodeMismatch = 89,
	AccountAssociatedToMultiplePartners = 90,
	NotModified = 91,
	NoMobileDevice = 92,
	TimeNotSynced = 93,
	SmsCodeFailed = 94,
	AccountLimitExceeded = 95,
	AccountActivityLimitExceeded = 96,
	PhoneActivityLimitExceeded = 97,
	RefundToWallet = 98,
	EmailSendFailure = 99,
	NotSettled = 100,
	NeedCaptcha = 101,
	GSLTDenied = 102,
	GSOwnerDenied = 103,
	InvalidItemType = 104,
	IPBanned = 105,
	GSLTExpired = 106,
	InsufficientFunds = 107,
	TooManyPending = 108,
	NoSiteLicensesFound = 109,
	WGNetworkSendExceeded = 110,
	AccountNotFriends = 111,
	LimitedUserAccount = 112,
	CantRemoveItem = 113,
	AccountDeleted = 114,
	ExistingUserCancelledLicense = 115,
	CommunityCooldown = 116,
	NoLauncherSpecified = 117,
	MustAgreeToSSA = 118,
	LauncherMigrated = 119,
	SteamRealmMismatch = 120,
	InvalidSignature = 121,
	ParseFailure = 122,
	NoVerifiedPhone = 123,
	InsufficientBattery = 124,
	ChargerRequired = 125,
	CachedCredentialInvalid = 126,
	K_EResultPhoneNumberIsVOIP = 127,
	NotSupported = 128,
	FamilySizeLimitExceeded = 129,
	OfflineAppCacheInvalid = 130
}


internal enum VoiceResult
{
	OK,
	NotInitialized,
	NotRecording,
	NoData,
	BufferTooSmall,
	DataCorrupted,
	Restricted,
	UnsupportedCodec,
	ReceiverOutOfDate,
	ReceiverDidNotAnswer
}


internal enum DenyReason
{
	Invalid,
	InvalidVersion,
	Generic,
	NotLoggedOn,
	NoLicense,
	Cheater,
	LoggedInElseWhere,
	UnknownText,
	IncompatibleAnticheat,
	MemoryCorruption,
	IncompatibleSoftware,
	SteamConnectionLost,
	SteamConnectionError,
	SteamResponseTimedOut,
	SteamValidationStalled,
	SteamOwnerLeftGuestUser
}


public enum BeginAuthResult
{
	OK,
	InvalidTicket,
	DuplicateRequest,
	InvalidVersion,
	GameMismatch,
	ExpiredTicket
}


public enum AuthResponse
{
	OK,
	UserNotConnectedToSteam,
	NoLicenseOrExpired,
	VACBanned,
	LoggedInElseWhere,
	VACCheckTimedOut,
	AuthTicketCanceled,
	AuthTicketInvalidAlreadyUsed,
	AuthTicketInvalid,
	PublisherIssuedBan,
	AuthTicketNetworkIdentityFailure
}


public enum UserHasLicenseForAppResult
{
	HasLicense,
	DoesNotHaveLicense,
	NoAuth
}


internal enum AccountType
{
	Invalid,
	Individual,
	Multiseat,
	GameServer,
	AnonGameServer,
	Pending,
	ContentServer,
	Clan,
	Chat,
	ConsoleUser,
	AnonUser,
	Max
}


internal enum ChatEntryType
{
	Invalid = 0,
	ChatMsg = 1,
	Typing = 2,
	InviteGame = 3,
	Emote = 4,
	LeftConversation = 6,
	Entered = 7,
	WasKicked = 8,
	WasBanned = 9,
	Disconnected = 10,
	HistoricalChat = 11,
	LinkBlocked = 14
}


public enum RoomEnter
{
	Success = 1,
	DoesntExist = 2,
	NotAllowed = 3,
	Full = 4,
	Error = 5,
	Banned = 6,
	Limited = 7,
	ClanDisabled = 8,
	CommunityBan = 9,
	MemberBlockedYou = 10,
	YouBlockedMember = 11,
	RatelimitExceeded = 15
}


internal enum ChatSteamIDInstanceFlags
{
	AccountInstanceMask = 4095,
	InstanceFlagClan = 524288,
	InstanceFlagLobby = 262144,
	InstanceFlagMMSLobby = 131072
}


public enum NotificationPosition
{
	Invalid = -1,
	TopLeft,
	TopRight,
	BottomLeft,
	BottomRight
}


public enum BroadcastUploadResult
{
	None,
	OK,
	InitFailed,
	FrameFailed,
	Timeout,
	BandwidthExceeded,
	LowFPS,
	MissingKeyFrames,
	NoConnection,
	RelayFailed,
	SettingsChanged,
	MissingAudio,
	TooFarBehind,
	TranscodeBehind,
	NotAllowedToPlay,
	Busy,
	Banned,
	AlreadyActive,
	ForcedOff,
	AudioBehind,
	Shutdown,
	Disconnect,
	VideoInitFailed,
	AudioInitFailed
}


internal enum MarketNotAllowedReasonFlags
{
	None = 0,
	TemporaryFailure = 1,
	AccountDisabled = 2,
	AccountLockedDown = 4,
	AccountLimited = 8,
	TradeBanned = 0x10,
	AccountNotTrusted = 0x20,
	SteamGuardNotEnabled = 0x40,
	SteamGuardOnlyRecentlyEnabled = 0x80,
	RecentPasswordReset = 0x100,
	NewPaymentMethod = 0x200,
	InvalidCookie = 0x400,
	UsingNewDevice = 0x800,
	RecentSelfRefund = 0x1000,
	NewPaymentMethodCannotBeVerified = 0x2000,
	NoRecentPurchases = 0x4000,
	AcceptedWalletGift = 0x8000
}


public enum DurationControlProgress
{
	Progress_Full,
	Progress_Half,
	Progress_None,
	ExitSoon_3h,
	ExitSoon_5h,
	ExitSoon_Night
}


internal enum DurationControlNotification
{
	None,
	DurationControlNotification1Hour,
	DurationControlNotification3Hours,
	HalfProgress,
	NoProgress,
	ExitSoon_3h,
	ExitSoon_5h,
	ExitSoon_Night
}


internal enum DurationControlOnlineState
{
	Invalid,
	Offline,
	Online,
	OnlineHighPri
}


internal enum BetaBranchFlags
{
	None = 0,
	Default = 1,
	Available = 2,
	Private = 4,
	Selected = 8,
	Installed = 0x10
}


internal enum GameSearchErrorCode_t
{
	OK = 1,
	Failed_Search_Already_In_Progress,
	Failed_No_Search_In_Progress,
	Failed_Not_Lobby_Leader,
	Failed_No_Host_Available,
	Failed_Search_Params_Invalid,
	Failed_Offline,
	Failed_NotAuthorized,
	Failed_Unknown_Error
}


internal enum PlayerResult_t
{
	FailedToConnect = 1,
	Abandoned,
	Kicked,
	Incomplete,
	Completed
}


internal enum SteamIPv6ConnectivityProtocol
{
	Invalid,
	HTTP,
	UDP
}


internal enum SteamIPv6ConnectivityState
{
	Unknown,
	Good,
	Bad
}


public enum Relationship
{
	None,
	Blocked,
	RequestRecipient,
	Friend,
	RequestInitiator,
	Ignored,
	IgnoredFriend,
	Suggested_DEPRECATED,
	Max
}


public enum FriendState
{
	Offline,
	Online,
	Busy,
	Away,
	Snooze,
	LookingToTrade,
	LookingToPlay,
	Invisible,
	Max
}


internal enum FriendFlags
{
	None = 0,
	Blocked = 1,
	FriendshipRequested = 2,
	Immediate = 4,
	ClanMember = 8,
	OnGameServer = 16,
	RequestingFriendship = 128,
	RequestingInfo = 256,
	Ignored = 512,
	IgnoredFriend = 1024,
	ChatMember = 4096,
	All = 65535
}


internal enum UserRestriction
{
	None = 0,
	Unknown = 1,
	AnyChat = 2,
	VoiceChat = 4,
	GroupChat = 8,
	Rating = 0x10,
	GameInvites = 0x20,
	Trading = 0x40
}


public enum OverlayToStoreFlag
{
	None,
	AddToCart,
	AddToCartAndShow
}


internal enum ActivateGameOverlayToWebPageMode
{
	Default,
	Modal
}


internal enum CommunityProfileItemType
{
	AnimatedAvatar,
	AvatarFrame,
	ProfileModifier,
	ProfileBackground,
	MiniProfileBackground
}


internal enum CommunityProfileItemProperty
{
	ImageSmall,
	ImageLarge,
	InternalName,
	Title,
	Description,
	AppID,
	TypeID,
	Class,
	MovieWebM,
	MovieMP4,
	MovieWebMSmall,
	MovieMP4Small
}


internal enum PersonaChange
{
	Name = 1,
	Status = 2,
	ComeOnline = 4,
	GoneOffline = 8,
	GamePlayed = 0x10,
	GameServer = 0x20,
	Avatar = 0x40,
	JoinedSource = 0x80,
	LeftSource = 0x100,
	RelationshipChanged = 0x200,
	NameFirstSet = 0x400,
	Broadcast = 0x800,
	Nickname = 0x1000,
	SteamLevel = 0x2000,
	RichPresence = 0x4000
}


internal enum SteamAPICallFailure
{
	None = -1,
	SteamGone,
	NetworkFailure,
	InvalidHandle,
	MismatchedCallback
}


public enum GamepadTextInputMode
{
	Normal,
	Password
}


public enum GamepadTextInputLineMode
{
	SingleLine,
	MultipleLines
}


public enum TextInputMode
{
	SingleLine,
	MultipleLines,
	Email,
	Numeric
}


public enum TextFilteringContext
{
	Unknown,
	GameContent,
	Chat,
	Name
}


public enum CheckFileSignature
{
	InvalidSignature,
	ValidSignature,
	FileNotFound,
	NoSignaturesFoundForThisApp,
	NoSignaturesFoundForThisFile
}


internal enum MatchMakingServerResponse
{
	ServerResponded,
	ServerFailedToRespond,
	NoServersListedOnMasterServer
}


internal enum LobbyType
{
	Private,
	FriendsOnly,
	Public,
	Invisible,
	PrivateUnique
}


internal enum LobbyComparison
{
	EqualToOrLessThan = -2,
	LessThan,
	Equal,
	GreaterThan,
	EqualToOrGreaterThan,
	NotEqual
}


internal enum LobbyDistanceFilter
{
	Close,
	Default,
	Far,
	Worldwide
}


internal enum ChatMemberStateChange
{
	Entered = 1,
	Left = 2,
	Disconnected = 4,
	Kicked = 8,
	Banned = 0x10
}


internal enum SteamPartyBeaconLocationType
{
	Invalid,
	ChatGroup,
	Max
}


internal enum SteamPartyBeaconLocationData
{
	Invalid,
	Name,
	IconURLSmall,
	IconURLMedium,
	IconURLLarge
}


internal enum RemoteStoragePlatform
{
	None = 0,
	Windows = 1,
	OSX = 2,
	PS3 = 4,
	Linux = 8,
	Switch = 16,
	Android = 32,
	IOS = 64,
	All = -1
}


internal enum RemoteStoragePublishedFileVisibility
{
	Public,
	FriendsOnly,
	Private,
	Unlisted
}


internal enum WorkshopFileType
{
	First = 0,
	Community = 0,
	Microtransaction = 1,
	Collection = 2,
	Art = 3,
	Video = 4,
	Screenshot = 5,
	Game = 6,
	Software = 7,
	Concept = 8,
	WebGuide = 9,
	IntegratedGuide = 10,
	Merch = 11,
	ControllerBinding = 12,
	SteamworksAccessInvite = 13,
	SteamVideo = 14,
	GameManagedItem = 15,
	Clip = 16,
	Max = 17
}


internal enum WorkshopVote
{
	Unvoted,
	For,
	Against,
	Later
}


internal enum WorkshopFileAction
{
	Played,
	Completed
}


internal enum WorkshopEnumerationType
{
	RankedByVote,
	Recent,
	Trending,
	FavoritesOfFriends,
	VotedByFriends,
	ContentByFriends,
	RecentFromFollowedUsers
}


internal enum WorkshopVideoProvider
{
	None,
	Youtube
}


internal enum UGCReadAction
{
	ontinueReadingUntilFinished,
	ontinueReading,
	lose
}


internal enum RemoteStorageLocalFileChange
{
	Invalid,
	FileUpdated,
	FileDeleted
}


internal enum RemoteStorageFilePathType
{
	Invalid,
	Absolute,
	APIFilename
}


internal enum LeaderboardDataRequest
{
	Global,
	GlobalAroundUser,
	Friends,
	Users
}


internal enum LeaderboardUploadScoreMethod
{
	None,
	KeepBest,
	ForceUpdate
}


public enum P2PSessionError
{
	None = 0,
	NoRightsToApp = 2,
	Timeout = 4,
	NotRunningApp_DELETED = 1,
	DestinationNotLoggedIn_DELETED = 3,
	Max = 5
}


public enum P2PSend
{
	Unreliable,
	UnreliableNoDelay,
	Reliable,
	ReliableWithBuffering
}


internal enum VRScreenshotType
{
	None,
	Mono,
	Stereo,
	MonoCubemap,
	MonoPanorama,
	StereoPanorama
}


public enum MusicStatus
{
	Undefined,
	Playing,
	Paused,
	Idle
}


internal enum HTTPMethod
{
	Invalid,
	GET,
	HEAD,
	POST,
	PUT,
	DELETE,
	OPTIONS,
	PATCH
}


internal enum HTTPStatusCode
{
	Invalid = 0,
	Code100Continue = 100,
	Code101SwitchingProtocols = 101,
	Code200OK = 200,
	Code201Created = 201,
	Code202Accepted = 202,
	Code203NonAuthoritative = 203,
	Code204NoContent = 204,
	Code205ResetContent = 205,
	Code206PartialContent = 206,
	Code300MultipleChoices = 300,
	Code301MovedPermanently = 301,
	Code302Found = 302,
	Code303SeeOther = 303,
	Code304NotModified = 304,
	Code305UseProxy = 305,
	Code307TemporaryRedirect = 307,
	Code308PermanentRedirect = 308,
	Code400BadRequest = 400,
	Code401Unauthorized = 401,
	Code402PaymentRequired = 402,
	Code403Forbidden = 403,
	Code404NotFound = 404,
	Code405MethodNotAllowed = 405,
	Code406NotAcceptable = 406,
	Code407ProxyAuthRequired = 407,
	Code408RequestTimeout = 408,
	Code409Conflict = 409,
	Code410Gone = 410,
	Code411LengthRequired = 411,
	Code412PreconditionFailed = 412,
	Code413RequestEntityTooLarge = 413,
	Code414RequestURITooLong = 414,
	Code415UnsupportedMediaType = 415,
	Code416RequestedRangeNotSatisfiable = 416,
	Code417ExpectationFailed = 417,
	Code4xxUnknown = 418,
	Code429TooManyRequests = 429,
	Code444ConnectionClosed = 444,
	Code500InternalServerError = 500,
	Code501NotImplemented = 501,
	Code502BadGateway = 502,
	Code503ServiceUnavailable = 503,
	Code504GatewayTimeout = 504,
	Code505HTTPVersionNotSupported = 505,
	Code5xxUnknown = 599
}


public enum InputSourceMode
{
	None,
	Dpad,
	Buttons,
	FourButtons,
	AbsoluteMouse,
	RelativeMouse,
	JoystickMove,
	JoystickMouse,
	JoystickCamera,
	ScrollWheel,
	Trigger,
	TouchMenu,
	MouseJoystick,
	MouseRegion,
	RadialMenu,
	SingleButton,
	Switches
}


internal enum InputActionOrigin
{
	None = 0,
	SteamController_A = 1,
	SteamController_B = 2,
	SteamController_X = 3,
	SteamController_Y = 4,
	SteamController_LeftBumper = 5,
	SteamController_RightBumper = 6,
	SteamController_LeftGrip = 7,
	SteamController_RightGrip = 8,
	SteamController_Start = 9,
	SteamController_Back = 10,
	SteamController_LeftPad_Touch = 11,
	SteamController_LeftPad_Swipe = 12,
	SteamController_LeftPad_Click = 13,
	SteamController_LeftPad_DPadNorth = 14,
	SteamController_LeftPad_DPadSouth = 15,
	SteamController_LeftPad_DPadWest = 16,
	SteamController_LeftPad_DPadEast = 17,
	SteamController_RightPad_Touch = 18,
	SteamController_RightPad_Swipe = 19,
	SteamController_RightPad_Click = 20,
	SteamController_RightPad_DPadNorth = 21,
	SteamController_RightPad_DPadSouth = 22,
	SteamController_RightPad_DPadWest = 23,
	SteamController_RightPad_DPadEast = 24,
	SteamController_LeftTrigger_Pull = 25,
	SteamController_LeftTrigger_Click = 26,
	SteamController_RightTrigger_Pull = 27,
	SteamController_RightTrigger_Click = 28,
	SteamController_LeftStick_Move = 29,
	SteamController_LeftStick_Click = 30,
	SteamController_LeftStick_DPadNorth = 31,
	SteamController_LeftStick_DPadSouth = 32,
	SteamController_LeftStick_DPadWest = 33,
	SteamController_LeftStick_DPadEast = 34,
	SteamController_Gyro_Move = 35,
	SteamController_Gyro_Pitch = 36,
	SteamController_Gyro_Yaw = 37,
	SteamController_Gyro_Roll = 38,
	SteamController_Reserved0 = 39,
	SteamController_Reserved1 = 40,
	SteamController_Reserved2 = 41,
	SteamController_Reserved3 = 42,
	SteamController_Reserved4 = 43,
	SteamController_Reserved5 = 44,
	SteamController_Reserved6 = 45,
	SteamController_Reserved7 = 46,
	SteamController_Reserved8 = 47,
	SteamController_Reserved9 = 48,
	SteamController_Reserved10 = 49,
	PS4_X = 50,
	PS4_Circle = 51,
	PS4_Triangle = 52,
	PS4_Square = 53,
	PS4_LeftBumper = 54,
	PS4_RightBumper = 55,
	PS4_Options = 56,
	PS4_Share = 57,
	PS4_LeftPad_Touch = 58,
	PS4_LeftPad_Swipe = 59,
	PS4_LeftPad_Click = 60,
	PS4_LeftPad_DPadNorth = 61,
	PS4_LeftPad_DPadSouth = 62,
	PS4_LeftPad_DPadWest = 63,
	PS4_LeftPad_DPadEast = 64,
	PS4_RightPad_Touch = 65,
	PS4_RightPad_Swipe = 66,
	PS4_RightPad_Click = 67,
	PS4_RightPad_DPadNorth = 68,
	PS4_RightPad_DPadSouth = 69,
	PS4_RightPad_DPadWest = 70,
	PS4_RightPad_DPadEast = 71,
	PS4_CenterPad_Touch = 72,
	PS4_CenterPad_Swipe = 73,
	PS4_CenterPad_Click = 74,
	PS4_CenterPad_DPadNorth = 75,
	PS4_CenterPad_DPadSouth = 76,
	PS4_CenterPad_DPadWest = 77,
	PS4_CenterPad_DPadEast = 78,
	PS4_LeftTrigger_Pull = 79,
	PS4_LeftTrigger_Click = 80,
	PS4_RightTrigger_Pull = 81,
	PS4_RightTrigger_Click = 82,
	PS4_LeftStick_Move = 83,
	PS4_LeftStick_Click = 84,
	PS4_LeftStick_DPadNorth = 85,
	PS4_LeftStick_DPadSouth = 86,
	PS4_LeftStick_DPadWest = 87,
	PS4_LeftStick_DPadEast = 88,
	PS4_RightStick_Move = 89,
	PS4_RightStick_Click = 90,
	PS4_RightStick_DPadNorth = 91,
	PS4_RightStick_DPadSouth = 92,
	PS4_RightStick_DPadWest = 93,
	PS4_RightStick_DPadEast = 94,
	PS4_DPad_North = 95,
	PS4_DPad_South = 96,
	PS4_DPad_West = 97,
	PS4_DPad_East = 98,
	PS4_Gyro_Move = 99,
	PS4_Gyro_Pitch = 100,
	PS4_Gyro_Yaw = 101,
	PS4_Gyro_Roll = 102,
	PS4_DPad_Move = 103,
	PS4_Reserved1 = 104,
	PS4_Reserved2 = 105,
	PS4_Reserved3 = 106,
	PS4_Reserved4 = 107,
	PS4_Reserved5 = 108,
	PS4_Reserved6 = 109,
	PS4_Reserved7 = 110,
	PS4_Reserved8 = 111,
	PS4_Reserved9 = 112,
	PS4_Reserved10 = 113,
	XBoxOne_A = 114,
	XBoxOne_B = 115,
	XBoxOne_X = 116,
	XBoxOne_Y = 117,
	XBoxOne_LeftBumper = 118,
	XBoxOne_RightBumper = 119,
	XBoxOne_Menu = 120,
	XBoxOne_View = 121,
	XBoxOne_LeftTrigger_Pull = 122,
	XBoxOne_LeftTrigger_Click = 123,
	XBoxOne_RightTrigger_Pull = 124,
	XBoxOne_RightTrigger_Click = 125,
	XBoxOne_LeftStick_Move = 126,
	XBoxOne_LeftStick_Click = 127,
	XBoxOne_LeftStick_DPadNorth = 128,
	XBoxOne_LeftStick_DPadSouth = 129,
	XBoxOne_LeftStick_DPadWest = 130,
	XBoxOne_LeftStick_DPadEast = 131,
	XBoxOne_RightStick_Move = 132,
	XBoxOne_RightStick_Click = 133,
	XBoxOne_RightStick_DPadNorth = 134,
	XBoxOne_RightStick_DPadSouth = 135,
	XBoxOne_RightStick_DPadWest = 136,
	XBoxOne_RightStick_DPadEast = 137,
	XBoxOne_DPad_North = 138,
	XBoxOne_DPad_South = 139,
	XBoxOne_DPad_West = 140,
	XBoxOne_DPad_East = 141,
	XBoxOne_DPad_Move = 142,
	XBoxOne_LeftGrip_Lower = 143,
	XBoxOne_LeftGrip_Upper = 144,
	XBoxOne_RightGrip_Lower = 145,
	XBoxOne_RightGrip_Upper = 146,
	XBoxOne_Share = 147,
	XBoxOne_Reserved6 = 148,
	XBoxOne_Reserved7 = 149,
	XBoxOne_Reserved8 = 150,
	XBoxOne_Reserved9 = 151,
	XBoxOne_Reserved10 = 152,
	XBox360_A = 153,
	XBox360_B = 154,
	XBox360_X = 155,
	XBox360_Y = 156,
	XBox360_LeftBumper = 157,
	XBox360_RightBumper = 158,
	XBox360_Start = 159,
	XBox360_Back = 160,
	XBox360_LeftTrigger_Pull = 161,
	XBox360_LeftTrigger_Click = 162,
	XBox360_RightTrigger_Pull = 163,
	XBox360_RightTrigger_Click = 164,
	XBox360_LeftStick_Move = 165,
	XBox360_LeftStick_Click = 166,
	XBox360_LeftStick_DPadNorth = 167,
	XBox360_LeftStick_DPadSouth = 168,
	XBox360_LeftStick_DPadWest = 169,
	XBox360_LeftStick_DPadEast = 170,
	XBox360_RightStick_Move = 171,
	XBox360_RightStick_Click = 172,
	XBox360_RightStick_DPadNorth = 173,
	XBox360_RightStick_DPadSouth = 174,
	XBox360_RightStick_DPadWest = 175,
	XBox360_RightStick_DPadEast = 176,
	XBox360_DPad_North = 177,
	XBox360_DPad_South = 178,
	XBox360_DPad_West = 179,
	XBox360_DPad_East = 180,
	XBox360_DPad_Move = 181,
	XBox360_Reserved1 = 182,
	XBox360_Reserved2 = 183,
	XBox360_Reserved3 = 184,
	XBox360_Reserved4 = 185,
	XBox360_Reserved5 = 186,
	XBox360_Reserved6 = 187,
	XBox360_Reserved7 = 188,
	XBox360_Reserved8 = 189,
	XBox360_Reserved9 = 190,
	XBox360_Reserved10 = 191,
	Switch_A = 192,
	Switch_B = 193,
	Switch_X = 194,
	Switch_Y = 195,
	Switch_LeftBumper = 196,
	Switch_RightBumper = 197,
	Switch_Plus = 198,
	Switch_Minus = 199,
	Switch_Capture = 200,
	Switch_LeftTrigger_Pull = 201,
	Switch_LeftTrigger_Click = 202,
	Switch_RightTrigger_Pull = 203,
	Switch_RightTrigger_Click = 204,
	Switch_LeftStick_Move = 205,
	Switch_LeftStick_Click = 206,
	Switch_LeftStick_DPadNorth = 207,
	Switch_LeftStick_DPadSouth = 208,
	Switch_LeftStick_DPadWest = 209,
	Switch_LeftStick_DPadEast = 210,
	Switch_RightStick_Move = 211,
	Switch_RightStick_Click = 212,
	Switch_RightStick_DPadNorth = 213,
	Switch_RightStick_DPadSouth = 214,
	Switch_RightStick_DPadWest = 215,
	Switch_RightStick_DPadEast = 216,
	Switch_DPad_North = 217,
	Switch_DPad_South = 218,
	Switch_DPad_West = 219,
	Switch_DPad_East = 220,
	Switch_ProGyro_Move = 221,
	Switch_ProGyro_Pitch = 222,
	Switch_ProGyro_Yaw = 223,
	Switch_ProGyro_Roll = 224,
	Switch_DPad_Move = 225,
	Switch_Reserved1 = 226,
	Switch_Reserved2 = 227,
	Switch_Reserved3 = 228,
	Switch_Reserved4 = 229,
	Switch_Reserved5 = 230,
	Switch_Reserved6 = 231,
	Switch_Reserved7 = 232,
	Switch_Reserved8 = 233,
	Switch_Reserved9 = 234,
	Switch_Reserved10 = 235,
	Switch_RightGyro_Move = 236,
	Switch_RightGyro_Pitch = 237,
	Switch_RightGyro_Yaw = 238,
	Switch_RightGyro_Roll = 239,
	Switch_LeftGyro_Move = 240,
	Switch_LeftGyro_Pitch = 241,
	Switch_LeftGyro_Yaw = 242,
	Switch_LeftGyro_Roll = 243,
	Switch_LeftGrip_Lower = 244,
	Switch_LeftGrip_Upper = 245,
	Switch_RightGrip_Lower = 246,
	Switch_RightGrip_Upper = 247,
	Switch_JoyConButton_N = 248,
	Switch_JoyConButton_E = 249,
	Switch_JoyConButton_S = 250,
	Switch_JoyConButton_W = 251,
	Switch_Reserved15 = 252,
	Switch_Reserved16 = 253,
	Switch_Reserved17 = 254,
	Switch_Reserved18 = 255,
	Switch_Reserved19 = 256,
	Switch_Reserved20 = 257,
	PS5_X = 258,
	PS5_Circle = 259,
	PS5_Triangle = 260,
	PS5_Square = 261,
	PS5_LeftBumper = 262,
	PS5_RightBumper = 263,
	PS5_Option = 264,
	PS5_Create = 265,
	PS5_Mute = 266,
	PS5_LeftPad_Touch = 267,
	PS5_LeftPad_Swipe = 268,
	PS5_LeftPad_Click = 269,
	PS5_LeftPad_DPadNorth = 270,
	PS5_LeftPad_DPadSouth = 271,
	PS5_LeftPad_DPadWest = 272,
	PS5_LeftPad_DPadEast = 273,
	PS5_RightPad_Touch = 274,
	PS5_RightPad_Swipe = 275,
	PS5_RightPad_Click = 276,
	PS5_RightPad_DPadNorth = 277,
	PS5_RightPad_DPadSouth = 278,
	PS5_RightPad_DPadWest = 279,
	PS5_RightPad_DPadEast = 280,
	PS5_CenterPad_Touch = 281,
	PS5_CenterPad_Swipe = 282,
	PS5_CenterPad_Click = 283,
	PS5_CenterPad_DPadNorth = 284,
	PS5_CenterPad_DPadSouth = 285,
	PS5_CenterPad_DPadWest = 286,
	PS5_CenterPad_DPadEast = 287,
	PS5_LeftTrigger_Pull = 288,
	PS5_LeftTrigger_Click = 289,
	PS5_RightTrigger_Pull = 290,
	PS5_RightTrigger_Click = 291,
	PS5_LeftStick_Move = 292,
	PS5_LeftStick_Click = 293,
	PS5_LeftStick_DPadNorth = 294,
	PS5_LeftStick_DPadSouth = 295,
	PS5_LeftStick_DPadWest = 296,
	PS5_LeftStick_DPadEast = 297,
	PS5_RightStick_Move = 298,
	PS5_RightStick_Click = 299,
	PS5_RightStick_DPadNorth = 300,
	PS5_RightStick_DPadSouth = 301,
	PS5_RightStick_DPadWest = 302,
	PS5_RightStick_DPadEast = 303,
	PS5_DPad_North = 304,
	PS5_DPad_South = 305,
	PS5_DPad_West = 306,
	PS5_DPad_East = 307,
	PS5_Gyro_Move = 308,
	PS5_Gyro_Pitch = 309,
	PS5_Gyro_Yaw = 310,
	PS5_Gyro_Roll = 311,
	PS5_DPad_Move = 312,
	PS5_LeftGrip = 313,
	PS5_RightGrip = 314,
	PS5_LeftFn = 315,
	PS5_RightFn = 316,
	PS5_Reserved5 = 317,
	PS5_Reserved6 = 318,
	PS5_Reserved7 = 319,
	PS5_Reserved8 = 320,
	PS5_Reserved9 = 321,
	PS5_Reserved10 = 322,
	PS5_Reserved11 = 323,
	PS5_Reserved12 = 324,
	PS5_Reserved13 = 325,
	PS5_Reserved14 = 326,
	PS5_Reserved15 = 327,
	PS5_Reserved16 = 328,
	PS5_Reserved17 = 329,
	PS5_Reserved18 = 330,
	PS5_Reserved19 = 331,
	PS5_Reserved20 = 332,
	SteamDeck_A = 333,
	SteamDeck_B = 334,
	SteamDeck_X = 335,
	SteamDeck_Y = 336,
	SteamDeck_L1 = 337,
	SteamDeck_R1 = 338,
	SteamDeck_Menu = 339,
	SteamDeck_View = 340,
	SteamDeck_LeftPad_Touch = 341,
	SteamDeck_LeftPad_Swipe = 342,
	SteamDeck_LeftPad_Click = 343,
	SteamDeck_LeftPad_DPadNorth = 344,
	SteamDeck_LeftPad_DPadSouth = 345,
	SteamDeck_LeftPad_DPadWest = 346,
	SteamDeck_LeftPad_DPadEast = 347,
	SteamDeck_RightPad_Touch = 348,
	SteamDeck_RightPad_Swipe = 349,
	SteamDeck_RightPad_Click = 350,
	SteamDeck_RightPad_DPadNorth = 351,
	SteamDeck_RightPad_DPadSouth = 352,
	SteamDeck_RightPad_DPadWest = 353,
	SteamDeck_RightPad_DPadEast = 354,
	SteamDeck_L2_SoftPull = 355,
	SteamDeck_L2 = 356,
	SteamDeck_R2_SoftPull = 357,
	SteamDeck_R2 = 358,
	SteamDeck_LeftStick_Move = 359,
	SteamDeck_L3 = 360,
	SteamDeck_LeftStick_DPadNorth = 361,
	SteamDeck_LeftStick_DPadSouth = 362,
	SteamDeck_LeftStick_DPadWest = 363,
	SteamDeck_LeftStick_DPadEast = 364,
	SteamDeck_LeftStick_Touch = 365,
	SteamDeck_RightStick_Move = 366,
	SteamDeck_R3 = 367,
	SteamDeck_RightStick_DPadNorth = 368,
	SteamDeck_RightStick_DPadSouth = 369,
	SteamDeck_RightStick_DPadWest = 370,
	SteamDeck_RightStick_DPadEast = 371,
	SteamDeck_RightStick_Touch = 372,
	SteamDeck_L4 = 373,
	SteamDeck_R4 = 374,
	SteamDeck_L5 = 375,
	SteamDeck_R5 = 376,
	SteamDeck_DPad_Move = 377,
	SteamDeck_DPad_North = 378,
	SteamDeck_DPad_South = 379,
	SteamDeck_DPad_West = 380,
	SteamDeck_DPad_East = 381,
	SteamDeck_Gyro_Move = 382,
	SteamDeck_Gyro_Pitch = 383,
	SteamDeck_Gyro_Yaw = 384,
	SteamDeck_Gyro_Roll = 385,
	SteamDeck_Reserved1 = 386,
	SteamDeck_Reserved2 = 387,
	SteamDeck_Reserved3 = 388,
	SteamDeck_Reserved4 = 389,
	SteamDeck_Reserved5 = 390,
	SteamDeck_Reserved6 = 391,
	SteamDeck_Reserved7 = 392,
	SteamDeck_Reserved8 = 393,
	SteamDeck_Reserved9 = 394,
	SteamDeck_Reserved10 = 395,
	SteamDeck_Reserved11 = 396,
	SteamDeck_Reserved12 = 397,
	SteamDeck_Reserved13 = 398,
	SteamDeck_Reserved14 = 399,
	SteamDeck_Reserved15 = 400,
	SteamDeck_Reserved16 = 401,
	SteamDeck_Reserved17 = 402,
	SteamDeck_Reserved18 = 403,
	SteamDeck_Reserved19 = 404,
	SteamDeck_Reserved20 = 405,
	Horipad_M1 = 406,
	Horipad_M2 = 407,
	Horipad_L4 = 408,
	Horipad_R4 = 409,
	Count = 410,
	MaximumPossibleValue = 32767
}


internal enum XboxOrigin
{
	A,
	B,
	X,
	Y,
	LeftBumper,
	RightBumper,
	Menu,
	View,
	LeftTrigger_Pull,
	LeftTrigger_Click,
	RightTrigger_Pull,
	RightTrigger_Click,
	LeftStick_Move,
	LeftStick_Click,
	LeftStick_DPadNorth,
	LeftStick_DPadSouth,
	LeftStick_DPadWest,
	LeftStick_DPadEast,
	RightStick_Move,
	RightStick_Click,
	RightStick_DPadNorth,
	RightStick_DPadSouth,
	RightStick_DPadWest,
	RightStick_DPadEast,
	DPad_North,
	DPad_South,
	DPad_West,
	DPad_East,
	Count
}


internal enum SteamControllerPad
{
	Left,
	Right
}


internal enum ControllerHapticLocation
{
	Left = 1,
	Right,
	Both
}


internal enum ControllerHapticType
{
	Off,
	Tick,
	Click
}


public enum InputType
{
	Unknown = 0,
	SteamController = 1,
	XBox360Controller = 2,
	XBoxOneController = 3,
	GenericGamepad = 4,
	PS4Controller = 5,
	AppleMFiController = 6,
	AndroidController = 7,
	SwitchJoyConPair = 8,
	SwitchJoyConSingle = 9,
	SwitchProController = 10,
	MobileTouch = 11,
	PS3Controller = 12,
	PS5Controller = 13,
	SteamDeckController = 14,
	Count = 15,
	MaximumPossibleValue = 255
}


internal enum SteamInputConfigurationEnableType
{
	None = 0,
	Playstation = 1,
	Xbox = 2,
	Generic = 4,
	Switch = 8
}


internal enum SteamInputLEDFlag
{
	SetColor,
	RestoreUserDefault
}


public enum GlyphSize
{
	Small,
	Medium,
	Large,
	Count
}


internal enum SteamInputGlyphStyle
{
	Knockout = 0,
	Light = 1,
	Dark = 2,
	NeutralColorABXY = 0x10,
	SolidABXY = 0x20
}


internal enum SteamInputActionEventType
{
	DigitalAction,
	AnalogAction
}


internal enum ControllerActionOrigin
{
	None = 0,
	A = 1,
	B = 2,
	X = 3,
	Y = 4,
	LeftBumper = 5,
	RightBumper = 6,
	LeftGrip = 7,
	RightGrip = 8,
	Start = 9,
	Back = 10,
	LeftPad_Touch = 11,
	LeftPad_Swipe = 12,
	LeftPad_Click = 13,
	LeftPad_DPadNorth = 14,
	LeftPad_DPadSouth = 15,
	LeftPad_DPadWest = 16,
	LeftPad_DPadEast = 17,
	RightPad_Touch = 18,
	RightPad_Swipe = 19,
	RightPad_Click = 20,
	RightPad_DPadNorth = 21,
	RightPad_DPadSouth = 22,
	RightPad_DPadWest = 23,
	RightPad_DPadEast = 24,
	LeftTrigger_Pull = 25,
	LeftTrigger_Click = 26,
	RightTrigger_Pull = 27,
	RightTrigger_Click = 28,
	LeftStick_Move = 29,
	LeftStick_Click = 30,
	LeftStick_DPadNorth = 31,
	LeftStick_DPadSouth = 32,
	LeftStick_DPadWest = 33,
	LeftStick_DPadEast = 34,
	Gyro_Move = 35,
	Gyro_Pitch = 36,
	Gyro_Yaw = 37,
	Gyro_Roll = 38,
	PS4_X = 39,
	PS4_Circle = 40,
	PS4_Triangle = 41,
	PS4_Square = 42,
	PS4_LeftBumper = 43,
	PS4_RightBumper = 44,
	PS4_Options = 45,
	PS4_Share = 46,
	PS4_LeftPad_Touch = 47,
	PS4_LeftPad_Swipe = 48,
	PS4_LeftPad_Click = 49,
	PS4_LeftPad_DPadNorth = 50,
	PS4_LeftPad_DPadSouth = 51,
	PS4_LeftPad_DPadWest = 52,
	PS4_LeftPad_DPadEast = 53,
	PS4_RightPad_Touch = 54,
	PS4_RightPad_Swipe = 55,
	PS4_RightPad_Click = 56,
	PS4_RightPad_DPadNorth = 57,
	PS4_RightPad_DPadSouth = 58,
	PS4_RightPad_DPadWest = 59,
	PS4_RightPad_DPadEast = 60,
	PS4_CenterPad_Touch = 61,
	PS4_CenterPad_Swipe = 62,
	PS4_CenterPad_Click = 63,
	PS4_CenterPad_DPadNorth = 64,
	PS4_CenterPad_DPadSouth = 65,
	PS4_CenterPad_DPadWest = 66,
	PS4_CenterPad_DPadEast = 67,
	PS4_LeftTrigger_Pull = 68,
	PS4_LeftTrigger_Click = 69,
	PS4_RightTrigger_Pull = 70,
	PS4_RightTrigger_Click = 71,
	PS4_LeftStick_Move = 72,
	PS4_LeftStick_Click = 73,
	PS4_LeftStick_DPadNorth = 74,
	PS4_LeftStick_DPadSouth = 75,
	PS4_LeftStick_DPadWest = 76,
	PS4_LeftStick_DPadEast = 77,
	PS4_RightStick_Move = 78,
	PS4_RightStick_Click = 79,
	PS4_RightStick_DPadNorth = 80,
	PS4_RightStick_DPadSouth = 81,
	PS4_RightStick_DPadWest = 82,
	PS4_RightStick_DPadEast = 83,
	PS4_DPad_North = 84,
	PS4_DPad_South = 85,
	PS4_DPad_West = 86,
	PS4_DPad_East = 87,
	PS4_Gyro_Move = 88,
	PS4_Gyro_Pitch = 89,
	PS4_Gyro_Yaw = 90,
	PS4_Gyro_Roll = 91,
	XBoxOne_A = 92,
	XBoxOne_B = 93,
	XBoxOne_X = 94,
	XBoxOne_Y = 95,
	XBoxOne_LeftBumper = 96,
	XBoxOne_RightBumper = 97,
	XBoxOne_Menu = 98,
	XBoxOne_View = 99,
	XBoxOne_LeftTrigger_Pull = 100,
	XBoxOne_LeftTrigger_Click = 101,
	XBoxOne_RightTrigger_Pull = 102,
	XBoxOne_RightTrigger_Click = 103,
	XBoxOne_LeftStick_Move = 104,
	XBoxOne_LeftStick_Click = 105,
	XBoxOne_LeftStick_DPadNorth = 106,
	XBoxOne_LeftStick_DPadSouth = 107,
	XBoxOne_LeftStick_DPadWest = 108,
	XBoxOne_LeftStick_DPadEast = 109,
	XBoxOne_RightStick_Move = 110,
	XBoxOne_RightStick_Click = 111,
	XBoxOne_RightStick_DPadNorth = 112,
	XBoxOne_RightStick_DPadSouth = 113,
	XBoxOne_RightStick_DPadWest = 114,
	XBoxOne_RightStick_DPadEast = 115,
	XBoxOne_DPad_North = 116,
	XBoxOne_DPad_South = 117,
	XBoxOne_DPad_West = 118,
	XBoxOne_DPad_East = 119,
	XBox360_A = 120,
	XBox360_B = 121,
	XBox360_X = 122,
	XBox360_Y = 123,
	XBox360_LeftBumper = 124,
	XBox360_RightBumper = 125,
	XBox360_Start = 126,
	XBox360_Back = 127,
	XBox360_LeftTrigger_Pull = 128,
	XBox360_LeftTrigger_Click = 129,
	XBox360_RightTrigger_Pull = 130,
	XBox360_RightTrigger_Click = 131,
	XBox360_LeftStick_Move = 132,
	XBox360_LeftStick_Click = 133,
	XBox360_LeftStick_DPadNorth = 134,
	XBox360_LeftStick_DPadSouth = 135,
	XBox360_LeftStick_DPadWest = 136,
	XBox360_LeftStick_DPadEast = 137,
	XBox360_RightStick_Move = 138,
	XBox360_RightStick_Click = 139,
	XBox360_RightStick_DPadNorth = 140,
	XBox360_RightStick_DPadSouth = 141,
	XBox360_RightStick_DPadWest = 142,
	XBox360_RightStick_DPadEast = 143,
	XBox360_DPad_North = 144,
	XBox360_DPad_South = 145,
	XBox360_DPad_West = 146,
	XBox360_DPad_East = 147,
	SteamV2_A = 148,
	SteamV2_B = 149,
	SteamV2_X = 150,
	SteamV2_Y = 151,
	SteamV2_LeftBumper = 152,
	SteamV2_RightBumper = 153,
	SteamV2_LeftGrip_Lower = 154,
	SteamV2_LeftGrip_Upper = 155,
	SteamV2_RightGrip_Lower = 156,
	SteamV2_RightGrip_Upper = 157,
	SteamV2_LeftBumper_Pressure = 158,
	SteamV2_RightBumper_Pressure = 159,
	SteamV2_LeftGrip_Pressure = 160,
	SteamV2_RightGrip_Pressure = 161,
	SteamV2_LeftGrip_Upper_Pressure = 162,
	SteamV2_RightGrip_Upper_Pressure = 163,
	SteamV2_Start = 164,
	SteamV2_Back = 165,
	SteamV2_LeftPad_Touch = 166,
	SteamV2_LeftPad_Swipe = 167,
	SteamV2_LeftPad_Click = 168,
	SteamV2_LeftPad_Pressure = 169,
	SteamV2_LeftPad_DPadNorth = 170,
	SteamV2_LeftPad_DPadSouth = 171,
	SteamV2_LeftPad_DPadWest = 172,
	SteamV2_LeftPad_DPadEast = 173,
	SteamV2_RightPad_Touch = 174,
	SteamV2_RightPad_Swipe = 175,
	SteamV2_RightPad_Click = 176,
	SteamV2_RightPad_Pressure = 177,
	SteamV2_RightPad_DPadNorth = 178,
	SteamV2_RightPad_DPadSouth = 179,
	SteamV2_RightPad_DPadWest = 180,
	SteamV2_RightPad_DPadEast = 181,
	SteamV2_LeftTrigger_Pull = 182,
	SteamV2_LeftTrigger_Click = 183,
	SteamV2_RightTrigger_Pull = 184,
	SteamV2_RightTrigger_Click = 185,
	SteamV2_LeftStick_Move = 186,
	SteamV2_LeftStick_Click = 187,
	SteamV2_LeftStick_DPadNorth = 188,
	SteamV2_LeftStick_DPadSouth = 189,
	SteamV2_LeftStick_DPadWest = 190,
	SteamV2_LeftStick_DPadEast = 191,
	SteamV2_Gyro_Move = 192,
	SteamV2_Gyro_Pitch = 193,
	SteamV2_Gyro_Yaw = 194,
	SteamV2_Gyro_Roll = 195,
	Switch_A = 196,
	Switch_B = 197,
	Switch_X = 198,
	Switch_Y = 199,
	Switch_LeftBumper = 200,
	Switch_RightBumper = 201,
	Switch_Plus = 202,
	Switch_Minus = 203,
	Switch_Capture = 204,
	Switch_LeftTrigger_Pull = 205,
	Switch_LeftTrigger_Click = 206,
	Switch_RightTrigger_Pull = 207,
	Switch_RightTrigger_Click = 208,
	Switch_LeftStick_Move = 209,
	Switch_LeftStick_Click = 210,
	Switch_LeftStick_DPadNorth = 211,
	Switch_LeftStick_DPadSouth = 212,
	Switch_LeftStick_DPadWest = 213,
	Switch_LeftStick_DPadEast = 214,
	Switch_RightStick_Move = 215,
	Switch_RightStick_Click = 216,
	Switch_RightStick_DPadNorth = 217,
	Switch_RightStick_DPadSouth = 218,
	Switch_RightStick_DPadWest = 219,
	Switch_RightStick_DPadEast = 220,
	Switch_DPad_North = 221,
	Switch_DPad_South = 222,
	Switch_DPad_West = 223,
	Switch_DPad_East = 224,
	Switch_ProGyro_Move = 225,
	Switch_ProGyro_Pitch = 226,
	Switch_ProGyro_Yaw = 227,
	Switch_ProGyro_Roll = 228,
	Switch_RightGyro_Move = 229,
	Switch_RightGyro_Pitch = 230,
	Switch_RightGyro_Yaw = 231,
	Switch_RightGyro_Roll = 232,
	Switch_LeftGyro_Move = 233,
	Switch_LeftGyro_Pitch = 234,
	Switch_LeftGyro_Yaw = 235,
	Switch_LeftGyro_Roll = 236,
	Switch_LeftGrip_Lower = 237,
	Switch_LeftGrip_Upper = 238,
	Switch_RightGrip_Lower = 239,
	Switch_RightGrip_Upper = 240,
	PS4_DPad_Move = 241,
	XBoxOne_DPad_Move = 242,
	XBox360_DPad_Move = 243,
	Switch_DPad_Move = 244,
	PS5_X = 245,
	PS5_Circle = 246,
	PS5_Triangle = 247,
	PS5_Square = 248,
	PS5_LeftBumper = 249,
	PS5_RightBumper = 250,
	PS5_Option = 251,
	PS5_Create = 252,
	PS5_Mute = 253,
	PS5_LeftPad_Touch = 254,
	PS5_LeftPad_Swipe = 255,
	PS5_LeftPad_Click = 256,
	PS5_LeftPad_DPadNorth = 257,
	PS5_LeftPad_DPadSouth = 258,
	PS5_LeftPad_DPadWest = 259,
	PS5_LeftPad_DPadEast = 260,
	PS5_RightPad_Touch = 261,
	PS5_RightPad_Swipe = 262,
	PS5_RightPad_Click = 263,
	PS5_RightPad_DPadNorth = 264,
	PS5_RightPad_DPadSouth = 265,
	PS5_RightPad_DPadWest = 266,
	PS5_RightPad_DPadEast = 267,
	PS5_CenterPad_Touch = 268,
	PS5_CenterPad_Swipe = 269,
	PS5_CenterPad_Click = 270,
	PS5_CenterPad_DPadNorth = 271,
	PS5_CenterPad_DPadSouth = 272,
	PS5_CenterPad_DPadWest = 273,
	PS5_CenterPad_DPadEast = 274,
	PS5_LeftTrigger_Pull = 275,
	PS5_LeftTrigger_Click = 276,
	PS5_RightTrigger_Pull = 277,
	PS5_RightTrigger_Click = 278,
	PS5_LeftStick_Move = 279,
	PS5_LeftStick_Click = 280,
	PS5_LeftStick_DPadNorth = 281,
	PS5_LeftStick_DPadSouth = 282,
	PS5_LeftStick_DPadWest = 283,
	PS5_LeftStick_DPadEast = 284,
	PS5_RightStick_Move = 285,
	PS5_RightStick_Click = 286,
	PS5_RightStick_DPadNorth = 287,
	PS5_RightStick_DPadSouth = 288,
	PS5_RightStick_DPadWest = 289,
	PS5_RightStick_DPadEast = 290,
	PS5_DPad_Move = 291,
	PS5_DPad_North = 292,
	PS5_DPad_South = 293,
	PS5_DPad_West = 294,
	PS5_DPad_East = 295,
	PS5_Gyro_Move = 296,
	PS5_Gyro_Pitch = 297,
	PS5_Gyro_Yaw = 298,
	PS5_Gyro_Roll = 299,
	XBoxOne_LeftGrip_Lower = 300,
	XBoxOne_LeftGrip_Upper = 301,
	XBoxOne_RightGrip_Lower = 302,
	XBoxOne_RightGrip_Upper = 303,
	XBoxOne_Share = 304,
	SteamDeck_A = 305,
	SteamDeck_B = 306,
	SteamDeck_X = 307,
	SteamDeck_Y = 308,
	SteamDeck_L1 = 309,
	SteamDeck_R1 = 310,
	SteamDeck_Menu = 311,
	SteamDeck_View = 312,
	SteamDeck_LeftPad_Touch = 313,
	SteamDeck_LeftPad_Swipe = 314,
	SteamDeck_LeftPad_Click = 315,
	SteamDeck_LeftPad_DPadNorth = 316,
	SteamDeck_LeftPad_DPadSouth = 317,
	SteamDeck_LeftPad_DPadWest = 318,
	SteamDeck_LeftPad_DPadEast = 319,
	SteamDeck_RightPad_Touch = 320,
	SteamDeck_RightPad_Swipe = 321,
	SteamDeck_RightPad_Click = 322,
	SteamDeck_RightPad_DPadNorth = 323,
	SteamDeck_RightPad_DPadSouth = 324,
	SteamDeck_RightPad_DPadWest = 325,
	SteamDeck_RightPad_DPadEast = 326,
	SteamDeck_L2_SoftPull = 327,
	SteamDeck_L2 = 328,
	SteamDeck_R2_SoftPull = 329,
	SteamDeck_R2 = 330,
	SteamDeck_LeftStick_Move = 331,
	SteamDeck_L3 = 332,
	SteamDeck_LeftStick_DPadNorth = 333,
	SteamDeck_LeftStick_DPadSouth = 334,
	SteamDeck_LeftStick_DPadWest = 335,
	SteamDeck_LeftStick_DPadEast = 336,
	SteamDeck_LeftStick_Touch = 337,
	SteamDeck_RightStick_Move = 338,
	SteamDeck_R3 = 339,
	SteamDeck_RightStick_DPadNorth = 340,
	SteamDeck_RightStick_DPadSouth = 341,
	SteamDeck_RightStick_DPadWest = 342,
	SteamDeck_RightStick_DPadEast = 343,
	SteamDeck_RightStick_Touch = 344,
	SteamDeck_L4 = 345,
	SteamDeck_R4 = 346,
	SteamDeck_L5 = 347,
	SteamDeck_R5 = 348,
	SteamDeck_DPad_Move = 349,
	SteamDeck_DPad_North = 350,
	SteamDeck_DPad_South = 351,
	SteamDeck_DPad_West = 352,
	SteamDeck_DPad_East = 353,
	SteamDeck_Gyro_Move = 354,
	SteamDeck_Gyro_Pitch = 355,
	SteamDeck_Gyro_Yaw = 356,
	SteamDeck_Gyro_Roll = 357,
	SteamDeck_Reserved1 = 358,
	SteamDeck_Reserved2 = 359,
	SteamDeck_Reserved3 = 360,
	SteamDeck_Reserved4 = 361,
	SteamDeck_Reserved5 = 362,
	SteamDeck_Reserved6 = 363,
	SteamDeck_Reserved7 = 364,
	SteamDeck_Reserved8 = 365,
	SteamDeck_Reserved9 = 366,
	SteamDeck_Reserved10 = 367,
	SteamDeck_Reserved11 = 368,
	SteamDeck_Reserved12 = 369,
	SteamDeck_Reserved13 = 370,
	SteamDeck_Reserved14 = 371,
	SteamDeck_Reserved15 = 372,
	SteamDeck_Reserved16 = 373,
	SteamDeck_Reserved17 = 374,
	SteamDeck_Reserved18 = 375,
	SteamDeck_Reserved19 = 376,
	SteamDeck_Reserved20 = 377,
	Switch_JoyConButton_N = 378,
	Switch_JoyConButton_E = 379,
	Switch_JoyConButton_S = 380,
	Switch_JoyConButton_W = 381,
	PS5_LeftGrip = 382,
	PS5_RightGrip = 383,
	PS5_LeftFn = 384,
	PS5_RightFn = 385,
	Horipad_M1 = 386,
	Horipad_M2 = 387,
	Horipad_L4 = 388,
	Horipad_R4 = 389,
	Count = 390,
	MaximumPossibleValue = 32767
}


internal enum SteamControllerLEDFlag
{
	SetColor,
	RestoreUserDefault
}


public enum UgcType
{
	Items = 0,
	Items_Mtx = 1,
	Items_ReadyToUse = 2,
	Collections = 3,
	Artwork = 4,
	Videos = 5,
	Screenshots = 6,
	AllGuides = 7,
	WebGuides = 8,
	IntegratedGuides = 9,
	UsableInGame = 10,
	ControllerBindings = 11,
	GameManagedItems = 12,
	All = -1
}


internal enum UserUGCList
{
	Published,
	VotedOn,
	VotedUp,
	VotedDown,
	WillVoteLater,
	Favorited,
	Subscribed,
	UsedOrPlayed,
	Followed
}


internal enum UserUGCListSortOrder
{
	CreationOrderDesc,
	CreationOrderAsc,
	TitleAsc,
	LastUpdatedDesc,
	SubscriptionDateDesc,
	VoteScoreDesc,
	ForModeration
}


internal enum UGCQuery
{
	RankedByVote,
	RankedByPublicationDate,
	AcceptedForGameRankedByAcceptanceDate,
	RankedByTrend,
	FavoritedByFriendsRankedByPublicationDate,
	CreatedByFriendsRankedByPublicationDate,
	RankedByNumTimesReported,
	CreatedByFollowedUsersRankedByPublicationDate,
	NotYetRated,
	RankedByTotalVotesAsc,
	RankedByVotesUp,
	RankedByTextSearch,
	RankedByTotalUniqueSubscriptions,
	RankedByPlaytimeTrend,
	RankedByTotalPlaytime,
	RankedByAveragePlaytimeTrend,
	RankedByLifetimeAveragePlaytime,
	RankedByPlaytimeSessionsTrend,
	RankedByLifetimePlaytimeSessions,
	RankedByLastUpdatedDate
}


internal enum ItemUpdateStatus
{
	Invalid,
	PreparingConfig,
	PreparingContent,
	UploadingContent,
	UploadingPreviewFile,
	CommittingChanges
}


internal enum ItemState
{
	None = 0,
	Subscribed = 1,
	LegacyItem = 2,
	Installed = 4,
	NeedsUpdate = 8,
	Downloading = 0x10,
	DownloadPending = 0x20,
	DisabledLocally = 0x40
}


internal enum ItemStatistic
{
	NumSubscriptions,
	NumFavorites,
	NumFollowers,
	NumUniqueSubscriptions,
	NumUniqueFavorites,
	NumUniqueFollowers,
	NumUniqueWebsiteViews,
	ReportScore,
	NumSecondsPlayed,
	NumPlaytimeSessions,
	NumComments,
	NumSecondsPlayedDuringTimePeriod,
	NumPlaytimeSessionsDuringTimePeriod
}


public enum ItemPreviewType
{
	Image = 0,
	YouTubeVideo = 1,
	Sketchfab = 2,
	EnvironmentMap_HorizontalCross = 3,
	EnvironmentMap_LatLong = 4,
	Clip = 5,
	ReservedMax = 255
}


internal enum UGCContentDescriptorID
{
	NudityOrSexualContent = 1,
	FrequentViolenceOrGore,
	AdultOnlySexualContent,
	GratuitousSexualContent,
	AnyMatureContent
}


internal enum SteamItemFlags
{
	NoTrade = 1,
	Removed = 0x100,
	Consumed = 0x200
}


public enum TimelineGameMode
{
	Invalid,
	Playing,
	Staging,
	Menus,
	LoadingScreen,
	Max
}


public enum TimelineEventClipPriority
{
	Invalid,
	None,
	Standard,
	Featured
}


public enum ParentalFeature
{
	Invalid,
	Store,
	Community,
	Profile,
	Friends,
	News,
	Trading,
	Settings,
	Console,
	Browser,
	ParentalSetup,
	Library,
	Test,
	SiteLicense,
	KioskMode_Deprecated,
	BlockAlways,
	Max
}


public enum SteamDeviceFormFactor
{
	Unknown,
	Phone,
	Tablet,
	Computer,
	TV,
	VRHeadset
}


public enum SteamNetworkingAvailability
{
	CannotTry = -102,
	Failed = -101,
	Previously = -100,
	Retrying = -10,
	NeverTried = 1,
	Waiting = 2,
	Attempting = 3,
	Current = 100,
	Unknown = 0,
	Force32bit = int.MaxValue
}


internal enum NetIdentityType
{
	Invalid = 0,
	SteamID = 16,
	XboxPairwiseID = 17,
	SonyPSN = 18,
	IPAddress = 1,
	GenericString = 2,
	GenericBytes = 3,
	UnknownType = 4,
	Force32bit = int.MaxValue
}


internal enum SteamNetworkingFakeIPType
{
	Invalid,
	NotFake,
	GlobalIPv4,
	LocalIPv4
}


public enum ConnectionState
{
	None = 0,
	Connecting = 1,
	FindingRoute = 2,
	Connected = 3,
	ClosedByPeer = 4,
	ProblemDetectedLocally = 5,
	FinWait = -1,
	Linger = -2,
	Dead = -3
}


public enum NetConnectionEnd
{
	Invalid = 0,
	App_Min = 1000,
	App_Generic = 1000,
	App_Max = 1999,
	AppException_Min = 2000,
	AppException_Generic = 2000,
	AppException_Max = 2999,
	Local_Min = 3000,
	Local_OfflineMode = 3001,
	Local_ManyRelayConnectivity = 3002,
	Local_HostedServerPrimaryRelay = 3003,
	Local_NetworkConfig = 3004,
	Local_Rights = 3005,
	Local_P2P_ICE_NoPublicAddresses = 3006,
	Local_Max = 3999,
	Remote_Min = 4000,
	Remote_Timeout = 4001,
	Remote_BadCrypt = 4002,
	Remote_BadCert = 4003,
	Remote_BadProtocolVersion = 4006,
	Remote_P2P_ICE_NoPublicAddresses = 4007,
	Remote_Max = 4999,
	Misc_Min = 5000,
	Misc_Generic = 5001,
	Misc_InternalError = 5002,
	Misc_Timeout = 5003,
	Misc_SteamConnectivity = 5005,
	Misc_NoRelaySessionsToClient = 5006,
	Misc_P2P_Rendezvous = 5008,
	Misc_P2P_NAT_Firewall = 5009,
	Misc_PeerSentNoConnection = 5010,
	Misc_Max = 5999
}


internal enum NetConfigScope
{
	Global = 1,
	SocketsInterface,
	ListenSocket,
	Connection
}


internal enum NetConfigType
{
	Int32 = 1,
	Int64,
	Float,
	String,
	Ptr
}


internal enum NetConfig
{
	Invalid = 0,
	TimeoutInitial = 24,
	TimeoutConnected = 25,
	SendBufferSize = 9,
	RecvBufferSize = 47,
	RecvBufferMessages = 48,
	RecvMaxMessageSize = 49,
	RecvMaxSegmentsPerPacket = 50,
	ConnectionUserData = 40,
	SendRateMin = 10,
	SendRateMax = 11,
	NagleTime = 12,
	IP_AllowWithoutAuth = 23,
	IPLocalHost_AllowWithoutAuth = 52,
	MTU_PacketSize = 32,
	MTU_DataSize = 33,
	Unencrypted = 34,
	SymmetricConnect = 37,
	LocalVirtualPort = 38,
	DualWifi_Enable = 39,
	EnableDiagnosticsUI = 46,
	SendTimeSincePreviousPacket = 59,
	FakePacketLoss_Send = 2,
	FakePacketLoss_Recv = 3,
	FakePacketLag_Send = 4,
	FakePacketLag_Recv = 5,
	FakePacketJitter_Send_Avg = 53,
	FakePacketJitter_Send_Max = 54,
	FakePacketJitter_Send_Pct = 55,
	FakePacketJitter_Recv_Avg = 56,
	FakePacketJitter_Recv_Max = 57,
	FakePacketJitter_Recv_Pct = 58,
	FakePacketReorder_Send = 6,
	FakePacketReorder_Recv = 7,
	FakePacketReorder_Time = 8,
	FakePacketDup_Send = 26,
	FakePacketDup_Recv = 27,
	FakePacketDup_TimeMax = 28,
	PacketTraceMaxBytes = 41,
	FakeRateLimit_Send_Rate = 42,
	FakeRateLimit_Send_Burst = 43,
	FakeRateLimit_Recv_Rate = 44,
	FakeRateLimit_Recv_Burst = 45,
	OutOfOrderCorrectionWindowMicroseconds = 51,
	Callback_ConnectionStatusChanged = 201,
	Callback_AuthStatusChanged = 202,
	Callback_RelayNetworkStatusChanged = 203,
	Callback_MessagesSessionRequest = 204,
	Callback_MessagesSessionFailed = 205,
	Callback_CreateConnectionSignaling = 206,
	Callback_FakeIPResult = 207,
	P2P_STUN_ServerList = 103,
	P2P_Transport_ICE_Enable = 104,
	P2P_Transport_ICE_Penalty = 105,
	P2P_Transport_SDR_Penalty = 106,
	P2P_TURN_ServerList = 107,
	P2P_TURN_UserList = 108,
	P2P_TURN_PassList = 109,
	P2P_Transport_ICE_Implementation = 110,
	SDRClient_ConsecutitivePingTimeoutsFailInitial = 19,
	SDRClient_ConsecutitivePingTimeoutsFail = 20,
	SDRClient_MinPingsBeforePingAccurate = 21,
	SDRClient_SingleSocket = 22,
	SDRClient_ForceRelayCluster = 29,
	SDRClient_DevTicket = 30,
	SDRClient_ForceProxyAddr = 31,
	SDRClient_FakeClusterPing = 36,
	SDRClient_LimitPingProbesToNearestN = 60,
	LogLevel_AckRTT = 13,
	LogLevel_PacketDecode = 14,
	LogLevel_Message = 15,
	LogLevel_PacketGaps = 16,
	LogLevel_P2PRendezvous = 17,
	LogLevel_SDRRelayPings = 18,
	ECN = 999,
	DELETED_EnumerateDevVars = 35
}


internal enum NetConfigResult
{
	BadValue = -1,
	BadScopeObj = -2,
	BufferTooSmall = -3,
	OK = 1,
	OKInherited = 2
}


public enum NetDebugOutput
{
	None,
	Bug,
	Error,
	Important,
	Warning,
	Msg,
	Verbose,
	Debug,
	Everything
}


internal enum SteamAPIInitResult
{
	OK,
	FailedGeneric,
	NoSteamClient,
	VersionMismatch
}


internal enum ServerMode
{
	Invalid,
	NoAuthentication,
	Authentication,
	AuthenticationAndSecure
}


using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Threading;
using Steamworks;
using Steamworks.Data;

internal static class BufferManager
{
	private sealed class ReferenceCounter
	{
		private int _count;

		public IntPtr Pointer { get; private set; }

		public int Size { get; private set; }

		public void Set(IntPtr ptr, int size, int referenceCount)
		{
			if (ptr == IntPtr.Zero)
			{
				throw new ArgumentNullException("ptr");
			}
			if (size <= 0)
			{
				throw new ArgumentOutOfRangeException("size");
			}
			if (referenceCount <= 0)
			{
				throw new ArgumentOutOfRangeException("referenceCount");
			}
			Pointer = ptr;
			Size = size;
			Interlocked.Exchange(ref _count, referenceCount);
		}

		public bool Decrement()
		{
			int num = Interlocked.Decrement(ref _count);
			if (num < 0)
			{
				SteamNetworkingUtils.LogDebugMessage(NetDebugOutput.Bug, "Prevented double free of BufferManager pointer");
				return false;
			}
			return num == 0;
		}
	}

	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	private unsafe delegate void FreeFn(NetMsg* msg);

	private static readonly Stack<ReferenceCounter> ReferenceCounterPool = new Stack<ReferenceCounter>(1024);

	private static readonly Dictionary<int, Stack<IntPtr>> BufferPools = new Dictionary<int, Stack<IntPtr>>();

	private static readonly Dictionary<IntPtr, ReferenceCounter> ReferenceCounters = new Dictionary<IntPtr, ReferenceCounter>(1024);

	private unsafe static readonly FreeFn FreeFunctionPin = Free;

	public static readonly IntPtr FreeFunctionPointer = Marshal.GetFunctionPointerForDelegate(FreeFunctionPin);

	private const int Bucket512 = 512;

	private const int Bucket1Kb = 1024;

	private const int Bucket4Kb = 4096;

	private const int Bucket16Kb = 16384;

	private const int Bucket64Kb = 65536;

	private const int Bucket256Kb = 262144;

	public static IntPtr Get(int size, int referenceCount)
	{
		if (size < 0 || size > 16777216)
		{
			throw new ArgumentOutOfRangeException("size");
		}
		if (referenceCount <= 0)
		{
			throw new ArgumentOutOfRangeException("referenceCount");
		}
		AllocateBuffer(size, out var ptr, out var size2);
		ReferenceCounter value = AllocateReferenceCounter(ptr, size2, referenceCount);
		lock (ReferenceCounters)
		{
			ReferenceCounters.Add(ptr, value);
			return ptr;
		}
	}

	[MonoPInvokeCallback]
	private unsafe static void Free(NetMsg* msg)
	{
		IntPtr dataPtr = msg->DataPtr;
		lock (ReferenceCounters)
		{
			if (!ReferenceCounters.TryGetValue(dataPtr, out var value))
			{
				SteamNetworkingUtils.LogDebugMessage(NetDebugOutput.Bug, string.Format("Attempt to free pointer not tracked by {0}: {1:X8}", "BufferManager", dataPtr.ToInt64()));
			}
			else if (value.Decrement())
			{
				ReferenceCounters.Remove(dataPtr);
				FreeBuffer(dataPtr, value.Size);
				FreeReferenceCounter(value);
			}
		}
	}

	private static ReferenceCounter AllocateReferenceCounter(IntPtr ptr, int size, int referenceCount)
	{
		lock (ReferenceCounterPool)
		{
			ReferenceCounter obj = ((ReferenceCounterPool.Count > 0) ? ReferenceCounterPool.Pop() : new ReferenceCounter());
			obj.Set(ptr, size, referenceCount);
			return obj;
		}
	}

	private static void FreeReferenceCounter(ReferenceCounter counter)
	{
		if (counter == null)
		{
			throw new ArgumentNullException("counter");
		}
		lock (ReferenceCounterPool)
		{
			if (ReferenceCounterPool.Count < 1024)
			{
				ReferenceCounterPool.Push(counter);
			}
		}
	}

	private static void AllocateBuffer(int minimumSize, out IntPtr ptr, out int size)
	{
		int bucketSize = GetBucketSize(minimumSize);
		if (bucketSize <= 0)
		{
			ptr = Marshal.AllocHGlobal(minimumSize);
			size = minimumSize;
			return;
		}
		lock (BufferPools)
		{
			if (!BufferPools.TryGetValue(bucketSize, out var value) || value.Count == 0)
			{
				ptr = Marshal.AllocHGlobal(bucketSize);
				size = bucketSize;
			}
			else
			{
				ptr = value.Pop();
				size = bucketSize;
			}
		}
	}

	private static void FreeBuffer(IntPtr ptr, int size)
	{
		int bucketSize = GetBucketSize(size);
		int bucketLimit = GetBucketLimit(size);
		if (bucketSize <= 0 || bucketLimit <= 0)
		{
			Marshal.FreeHGlobal(ptr);
			return;
		}
		lock (BufferPools)
		{
			if (!BufferPools.TryGetValue(bucketSize, out var value))
			{
				value = new Stack<IntPtr>(bucketLimit);
				BufferPools.Add(bucketSize, value);
			}
			if (value.Count >= bucketLimit)
			{
				Marshal.FreeHGlobal(ptr);
			}
			else
			{
				value.Push(ptr);
			}
		}
	}

	private static int GetBucketSize(int size)
	{
		if (size <= 512)
		{
			return 512;
		}
		if (size <= 1024)
		{
			return 1024;
		}
		if (size <= 4096)
		{
			return 4096;
		}
		if (size <= 16384)
		{
			return 16384;
		}
		if (size <= 65536)
		{
			return 65536;
		}
		if (size <= 262144)
		{
			return 262144;
		}
		return -1;
	}

	private static int GetBucketLimit(int size)
	{
		if (size <= 512)
		{
			return 1024;
		}
		if (size <= 1024)
		{
			return 512;
		}
		if (size <= 4096)
		{
			return 128;
		}
		if (size <= 16384)
		{
			return 32;
		}
		if (size <= 65536)
		{
			return 16;
		}
		if (size <= 262144)
		{
			return 8;
		}
		return -1;
	}
}


using System;
using Steamworks;
using Steamworks.Data;

public class ConnectionManager
{
	public Connection Connection;

	public bool Connected;

	public bool Connecting = true;

	public IConnectionManager Interface { get; set; }

	public ConnectionInfo ConnectionInfo { get; internal set; }

	public string ConnectionName
	{
		get
		{
			return Connection.ConnectionName;
		}
		set
		{
			Connection.ConnectionName = value;
		}
	}

	public long UserData
	{
		get
		{
			return Connection.UserData;
		}
		set
		{
			Connection.UserData = value;
		}
	}

	public void Close(bool linger = false, int reasonCode = 0, string debugString = "Closing Connection")
	{
		Connection.Close(linger, reasonCode, debugString);
	}

	public override string ToString()
	{
		return Connection.ToString();
	}

	public virtual void OnConnectionChanged(ConnectionInfo info)
	{
		ConnectionInfo = info;
		switch (info.State)
		{
		case ConnectionState.Connecting:
			if (!Connecting && !Connected)
			{
				Connecting = true;
				OnConnecting(info);
			}
			break;
		case ConnectionState.Connected:
			if (Connecting && !Connected)
			{
				Connecting = false;
				Connected = true;
				OnConnected(info);
			}
			break;
		case ConnectionState.None:
		case ConnectionState.ClosedByPeer:
		case ConnectionState.ProblemDetectedLocally:
			if (Connecting || Connected)
			{
				Connecting = false;
				Connected = false;
				OnDisconnected(info);
			}
			break;
		case ConnectionState.FindingRoute:
			break;
		}
	}

	public virtual void OnConnecting(ConnectionInfo info)
	{
		Interface?.OnConnecting(info);
	}

	public virtual void OnConnected(ConnectionInfo info)
	{
		Interface?.OnConnected(info);
	}

	public virtual void OnDisconnected(ConnectionInfo info)
	{
		Interface?.OnDisconnected(info);
	}

	public unsafe int Receive(int bufferSize = 32, bool receiveToEnd = true)
	{
		if (bufferSize < 1 || bufferSize > 256)
		{
			throw new ArgumentOutOfRangeException("bufferSize");
		}
		int num = 0;
		NetMsg** ptr = stackalloc NetMsg*[bufferSize];
		int num2;
		do
		{
			num2 = SteamNetworkingSockets.Internal.ReceiveMessagesOnConnection(Connection, new IntPtr(ptr), bufferSize);
			num += num2;
			try
			{
				for (int i = 0; i < num2; i++)
				{
					ReceiveMessage(ref ptr[i]);
				}
			}
			catch
			{
				for (int j = 0; j < num2; j++)
				{
					if (ptr[j] != null)
					{
						NetMsg.InternalRelease(ptr[j]);
					}
				}
				throw;
			}
		}
		while (receiveToEnd && num2 >= bufferSize);
		return num;
	}

	public unsafe void SendMessages(Connection[] connections, int connectionCount, IntPtr ptr, int size, SendType sendType = SendType.Reliable, Result[] results = null)
	{
		if (connections == null)
		{
			throw new ArgumentNullException("connections");
		}
		if (connectionCount < 0 || connectionCount > connections.Length)
		{
			throw new ArgumentException("`connectionCount` must be between 0 and `connections.Length`", "connectionCount");
		}
		if (results != null && connectionCount > results.Length)
		{
			throw new ArgumentException("`results` must have at least `connectionCount` entries", "results");
		}
		if (connectionCount > 1024)
		{
			throw new ArgumentOutOfRangeException("connectionCount");
		}
		if (ptr == IntPtr.Zero)
		{
			throw new ArgumentNullException("ptr");
		}
		if (size == 0)
		{
			throw new ArgumentException("`size` cannot be zero", "size");
		}
		if (connectionCount == 0)
		{
			return;
		}
		IntPtr intPtr = BufferManager.Get(size, connectionCount);
		Buffer.MemoryCopy((void*)ptr, (void*)intPtr, size, size);
		NetMsg** ptr2 = stackalloc NetMsg*[connectionCount];
		long* ptr3 = stackalloc long[(results != null) ? connectionCount : 0];
		for (int i = 0; i < connectionCount; i++)
		{
			ptr2[i] = SteamNetworkingUtils.AllocateMessage();
			ptr2[i]->Connection = connections[i];
			ptr2[i]->Flags = sendType;
			ptr2[i]->DataPtr = intPtr;
			ptr2[i]->DataSize = size;
			ptr2[i]->FreeDataPtr = BufferManager.FreeFunctionPointer;
		}
		SteamNetworkingSockets.Internal.SendMessages(connectionCount, ptr2, ptr3);
		if (results == null)
		{
			return;
		}
		for (int j = 0; j < connectionCount; j++)
		{
			if (ptr3[j] < 0)
			{
				results[j] = (Result)(-ptr3[j]);
			}
			else
			{
				results[j] = Result.OK;
			}
		}
	}

	public unsafe void SendMessages(Connection[] connections, int connectionCount, byte[] data, SendType sendType = SendType.Reliable, Result[] results = null)
	{
		fixed (byte* ptr = data)
		{
			SendMessages(connections, connectionCount, (IntPtr)ptr, data.Length, sendType, results);
		}
	}

	public unsafe void SendMessages(Connection[] connections, int connectionCount, byte[] data, int offset, int length, SendType sendType = SendType.Reliable, Result[] results = null)
	{
		fixed (byte* ptr = data)
		{
			SendMessages(connections, connectionCount, (IntPtr)ptr + offset, length, sendType, results);
		}
	}

	public void SendMessages(Connection[] connections, int connectionCount, string str, SendType sendType = SendType.Reliable, Result[] results = null)
	{
		byte[] bytes = Utility.Utf8NoBom.GetBytes(str);
		SendMessages(connections, connectionCount, bytes, sendType, results);
	}

	internal unsafe void ReceiveMessage(ref NetMsg* msg)
	{
		try
		{
			OnMessage(msg->DataPtr, msg->DataSize, msg->RecvTime, msg->MessageNumber, msg->Channel);
		}
		finally
		{
			NetMsg.InternalRelease(msg);
			msg = null;
		}
	}

	public virtual void OnMessage(IntPtr data, int size, long messageNum, long recvTime, int channel)
	{
		Interface?.OnMessage(data, size, messageNum, recvTime, channel);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
internal delegate void NetDebugFunc([In] NetDebugOutput nType, [In] IntPtr pszMsg);


using System.Runtime.InteropServices;
using Steamworks.Data;

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
internal delegate void FnSteamNetConnectionStatusChanged(ref SteamNetConnectionStatusChangedCallback_t arg);


using System.Runtime.InteropServices;
using Steamworks.Data;

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
internal delegate void FnSteamNetAuthenticationStatusChanged(ref SteamNetAuthenticationStatus_t arg);


using System.Runtime.InteropServices;
using Steamworks.Data;

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
internal delegate void FnSteamRelayNetworkStatusChanged(ref SteamRelayNetworkStatus_t arg);


using System.Runtime.InteropServices;
using Steamworks.Data;

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
internal delegate void FnSteamNetworkingMessagesSessionRequest(ref SteamNetworkingMessagesSessionRequest_t arg);


using System.Runtime.InteropServices;
using Steamworks.Data;

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
internal delegate void FnSteamNetworkingMessagesSessionFailed(ref SteamNetworkingMessagesSessionFailed_t arg);


using System.Runtime.InteropServices;
using Steamworks.Data;

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
internal delegate void FnSteamNetworkingFakeIPResult(ref SteamNetworkingFakeIPResult_t arg);


using System;
using Steamworks.Data;

public interface IConnectionManager
{
	void OnConnecting(ConnectionInfo info);

	void OnConnected(ConnectionInfo info);

	void OnDisconnected(ConnectionInfo info);

	void OnMessage(IntPtr data, int size, long messageNum, long recvTime, int channel);
}


using System;
using Steamworks.Data;

public interface ISocketManager
{
	void OnConnecting(Connection connection, ConnectionInfo info);

	void OnConnected(Connection connection, ConnectionInfo info);

	void OnDisconnected(Connection connection, ConnectionInfo info);

	void OnMessage(Connection connection, NetIdentity identity, IntPtr data, int size, long messageNum, long recvTime, int channel);
}


using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

public class SocketManager
{
	public HashSet<Connection> Connecting = new HashSet<Connection>();

	public HashSet<Connection> Connected = new HashSet<Connection>();

	internal HSteamNetPollGroup pollGroup;

	public ISocketManager Interface { get; set; }

	public Socket Socket { get; internal set; }

	public override string ToString()
	{
		return Socket.ToString();
	}

	internal void Initialize()
	{
		pollGroup = SteamNetworkingSockets.Internal.CreatePollGroup();
	}

	public bool Close()
	{
		if (SteamNetworkingSockets.Internal.IsValid)
		{
			SteamNetworkingSockets.Internal.DestroyPollGroup(pollGroup);
			Socket.Close();
		}
		pollGroup = 0u;
		Socket = 0u;
		return true;
	}

	public virtual void OnConnectionChanged(Connection connection, ConnectionInfo info)
	{
		switch (info.State)
		{
		case ConnectionState.Connecting:
			if (!Connecting.Contains(connection) && !Connected.Contains(connection))
			{
				Connecting.Add(connection);
				OnConnecting(connection, info);
			}
			break;
		case ConnectionState.Connected:
			if (Connecting.Contains(connection) && !Connected.Contains(connection))
			{
				Connecting.Remove(connection);
				Connected.Add(connection);
				OnConnected(connection, info);
			}
			break;
		case ConnectionState.None:
		case ConnectionState.ClosedByPeer:
		case ConnectionState.ProblemDetectedLocally:
			if (Connecting.Contains(connection) || Connected.Contains(connection))
			{
				Connecting.Remove(connection);
				Connected.Remove(connection);
				OnDisconnected(connection, info);
			}
			break;
		case ConnectionState.FindingRoute:
			break;
		}
	}

	public virtual void OnConnecting(Connection connection, ConnectionInfo info)
	{
		if (Interface != null)
		{
			Interface.OnConnecting(connection, info);
		}
		else
		{
			connection.Accept();
		}
	}

	public virtual void OnConnected(Connection connection, ConnectionInfo info)
	{
		SteamNetworkingSockets.Internal.SetConnectionPollGroup(connection, pollGroup);
		Interface?.OnConnected(connection, info);
	}

	public virtual void OnDisconnected(Connection connection, ConnectionInfo info)
	{
		if (Interface != null)
		{
			Interface.OnDisconnected(connection, info);
		}
		else
		{
			connection.Close();
		}
	}

	public int Receive(int bufferSize = 32, bool receiveToEnd = true)
	{
		int num = 0;
		IntPtr intPtr = Marshal.AllocHGlobal(IntPtr.Size * bufferSize);
		try
		{
			num = SteamNetworkingSockets.Internal.ReceiveMessagesOnPollGroup(pollGroup, intPtr, bufferSize);
			for (int i = 0; i < num; i++)
			{
				ReceiveMessage(Marshal.ReadIntPtr(intPtr, i * IntPtr.Size));
			}
		}
		finally
		{
			Marshal.FreeHGlobal(intPtr);
		}
		if (receiveToEnd && num == bufferSize)
		{
			num += Receive(bufferSize);
		}
		return num;
	}

	internal unsafe void ReceiveMessage(IntPtr msgPtr)
	{
		NetMsg netMsg = Marshal.PtrToStructure<NetMsg>(msgPtr);
		try
		{
			OnMessage(netMsg.Connection, netMsg.Identity, netMsg.DataPtr, netMsg.DataSize, netMsg.RecvTime, netMsg.MessageNumber, netMsg.Channel);
		}
		finally
		{
			NetMsg.InternalRelease((NetMsg*)(void*)msgPtr);
		}
	}

	public virtual void OnMessage(Connection connection, NetIdentity identity, IntPtr data, int size, long messageNum, long recvTime, int channel)
	{
		Interface?.OnMessage(connection, identity, data, size, messageNum, recvTime, channel);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;

public class SteamApps : SteamSharedClass<SteamApps>
{
	[CompilerGenerated]
	private sealed class <DlcInformation>d__29 : IEnumerable<DlcInformation>, IEnumerable, IEnumerator<DlcInformation>, IDisposable, IEnumerator
	{
		private int <>1__state;

		private DlcInformation <>2__current;

		private int <>l__initialThreadId;

		private AppId <appid>5__2;

		private bool <available>5__3;

		private int <i>5__4;

		DlcInformation IEnumerator<DlcInformation>.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		object IEnumerator.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		[DebuggerHidden]
		public <DlcInformation>d__29(int <>1__state)
		{
			this.<>1__state = <>1__state;
			<>l__initialThreadId = Environment.CurrentManagedThreadId;
		}

		[DebuggerHidden]
		void IDisposable.Dispose()
		{
			<>1__state = -2;
		}

		private bool MoveNext()
		{
			int num = <>1__state;
			if (num != 0)
			{
				if (num != 1)
				{
					return false;
				}
				<>1__state = -1;
				goto IL_00a1;
			}
			<>1__state = -1;
			<appid>5__2 = default(AppId);
			<available>5__3 = false;
			<i>5__4 = 0;
			goto IL_00b1;
			IL_00a1:
			<i>5__4++;
			goto IL_00b1;
			IL_00b1:
			if (<i>5__4 < Internal.GetDLCCount())
			{
				if (Internal.BGetDLCDataByIndex(<i>5__4, ref <appid>5__2, ref <available>5__3, out var pchName))
				{
					<>2__current = new DlcInformation
					{
						AppId = <appid>5__2.Value,
						Name = pchName,
						Available = <available>5__3
					};
					<>1__state = 1;
					return true;
				}
				goto IL_00a1;
			}
			return false;
		}

		bool IEnumerator.MoveNext()
		{
			//ILSpy generated this explicit interface implementation from .override directive in MoveNext
			return this.MoveNext();
		}

		[DebuggerHidden]
		void IEnumerator.Reset()
		{
			throw new NotSupportedException();
		}

		[DebuggerHidden]
		IEnumerator<DlcInformation> IEnumerable<DlcInformation>.GetEnumerator()
		{
			if (<>1__state == -2 && <>l__initialThreadId == Environment.CurrentManagedThreadId)
			{
				<>1__state = 0;
				return this;
			}
			return new <DlcInformation>d__29(0);
		}

		[DebuggerHidden]
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<DlcInformation>)this).GetEnumerator();
		}
	}

	[CompilerGenerated]
	private sealed class <InstalledDepots>d__35 : IEnumerable<DepotId>, IEnumerable, IEnumerator<DepotId>, IDisposable, IEnumerator
	{
		private int <>1__state;

		private DepotId <>2__current;

		private int <>l__initialThreadId;

		private AppId appid;

		public AppId <>3__appid;

		private DepotId_t[] <depots>5__2;

		private uint <count>5__3;

		private int <i>5__4;

		DepotId IEnumerator<DepotId>.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		object IEnumerator.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		[DebuggerHidden]
		public <InstalledDepots>d__35(int <>1__state)
		{
			this.<>1__state = <>1__state;
			<>l__initialThreadId = Environment.CurrentManagedThreadId;
		}

		[DebuggerHidden]
		void IDisposable.Dispose()
		{
			<depots>5__2 = null;
			<>1__state = -2;
		}

		private bool MoveNext()
		{
			switch (<>1__state)
			{
			default:
				return false;
			case 0:
				<>1__state = -1;
				if ((uint)appid == 0)
				{
					appid = SteamClient.AppId;
				}
				<depots>5__2 = new DepotId_t[32];
				<count>5__3 = Internal.GetInstalledDepots(appid.Value, <depots>5__2, (uint)<depots>5__2.Length);
				<i>5__4 = 0;
				break;
			case 1:
				<>1__state = -1;
				<i>5__4++;
				break;
			}
			if (<i>5__4 < <count>5__3)
			{
				<>2__current = new DepotId
				{
					Value = <depots>5__2[<i>5__4].Value
				};
				<>1__state = 1;
				return true;
			}
			return false;
		}

		bool IEnumerator.MoveNext()
		{
			//ILSpy generated this explicit interface implementation from .override directive in MoveNext
			return this.MoveNext();
		}

		[DebuggerHidden]
		void IEnumerator.Reset()
		{
			throw new NotSupportedException();
		}

		[DebuggerHidden]
		IEnumerator<DepotId> IEnumerable<DepotId>.GetEnumerator()
		{
			<InstalledDepots>d__35 <InstalledDepots>d__;
			if (<>1__state == -2 && <>l__initialThreadId == Environment.CurrentManagedThreadId)
			{
				<>1__state = 0;
				<InstalledDepots>d__ = this;
			}
			else
			{
				<InstalledDepots>d__ = new <InstalledDepots>d__35(0);
			}
			<InstalledDepots>d__.appid = <>3__appid;
			return <InstalledDepots>d__;
		}

		[DebuggerHidden]
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<DepotId>)this).GetEnumerator();
		}
	}

	internal static ISteamApps Internal => SteamSharedClass<SteamApps>.Interface as ISteamApps;

	public static bool IsSubscribed => Internal.BIsSubscribed();

	public static bool IsSubscribedFromFamilySharing => Internal.BIsSubscribedFromFamilySharing();

	public static bool IsLowViolence => Internal.BIsLowViolence();

	public static bool IsCybercafe => Internal.BIsCybercafe();

	public static bool IsVACBanned => Internal.BIsVACBanned();

	public static string GameLanguage => Internal.GetCurrentGameLanguage();

	public static string[] AvailableLanguages => Internal.GetAvailableGameLanguages().Split(new char[1] { ',' }, StringSplitOptions.RemoveEmptyEntries);

	public static bool IsSubscribedFromFreeWeekend => Internal.BIsSubscribedFromFreeWeekend();

	public static string CurrentBetaName
	{
		get
		{
			if (!Internal.GetCurrentBetaName(out var pchName))
			{
				return null;
			}
			return pchName;
		}
	}

	public static SteamId AppOwner => Internal.GetAppOwner().Value;

	public static int BuildId => Internal.GetAppBuildId();

	public static string CommandLine
	{
		get
		{
			Internal.GetLaunchCommandLine(out var pszCommandLine);
			return pszCommandLine;
		}
	}

	public static event Action<AppId> OnDlcInstalled;

	public static event Action OnNewLaunchParameters;

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamApps(server));
		if (SteamSharedClass<SteamApps>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		InstallEvents();
		return true;
	}

	internal static void InstallEvents()
	{
		Dispatch.Install(delegate(DlcInstalled_t x)
		{
			SteamApps.OnDlcInstalled?.Invoke(x.AppID);
		});
		Dispatch.Install<NewUrlLaunchParameters_t>(delegate
		{
			SteamApps.OnNewLaunchParameters?.Invoke();
		});
	}

	public static bool IsSubscribedToApp(AppId appid)
	{
		return Internal.BIsSubscribedApp(appid.Value);
	}

	public static bool IsDlcInstalled(AppId appid)
	{
		return Internal.BIsDlcInstalled(appid.Value);
	}

	public static DateTime PurchaseTime(AppId appid = default(AppId))
	{
		if ((uint)appid == 0)
		{
			appid = SteamClient.AppId;
		}
		return Epoch.ToDateTime(Internal.GetEarliestPurchaseUnixTime(appid.Value));
	}

	[IteratorStateMachine(typeof(<DlcInformation>d__29))]
	public static IEnumerable<DlcInformation> DlcInformation()
	{
		//yield-return decompiler failed: Unexpected instruction in Iterator.Dispose()
		return new <DlcInformation>d__29(-2);
	}

	public static void InstallDlc(AppId appid)
	{
		Internal.InstallDLC(appid.Value);
	}

	public static void UninstallDlc(AppId appid)
	{
		Internal.UninstallDLC(appid.Value);
	}

	public static void MarkContentCorrupt(bool missingFilesOnly)
	{
		Internal.MarkContentCorrupt(missingFilesOnly);
	}

	[IteratorStateMachine(typeof(<InstalledDepots>d__35))]
	public static IEnumerable<DepotId> InstalledDepots(AppId appid = default(AppId))
	{
		//yield-return decompiler failed: Unexpected instruction in Iterator.Dispose()
		return new <InstalledDepots>d__35(-2)
		{
			<>3__appid = appid
		};
	}

	public static string AppInstallDir(AppId appid = default(AppId))
	{
		if ((uint)appid == 0)
		{
			appid = SteamClient.AppId;
		}
		if (Internal.GetAppInstallDir(appid.Value, out var pchFolder) == 0)
		{
			return null;
		}
		return pchFolder;
	}

	public static bool IsAppInstalled(AppId appid)
	{
		return Internal.BIsAppInstalled(appid.Value);
	}

	public static string GetLaunchParam(string param)
	{
		return Internal.GetLaunchQueryParam(param);
	}

	public static DownloadProgress DlcDownloadProgress(AppId appid)
	{
		ulong punBytesDownloaded = 0uL;
		ulong punBytesTotal = 0uL;
		if (!Internal.GetDlcDownloadProgress(appid.Value, ref punBytesDownloaded, ref punBytesTotal))
		{
			return default(DownloadProgress);
		}
		DownloadProgress result = default(DownloadProgress);
		result.BytesDownloaded = punBytesDownloaded;
		result.BytesTotal = punBytesTotal;
		result.Active = true;
		return result;
	}

	public static async Task<FileDetails?> GetFileDetailsAsync(string filename)
	{
		FileDetailsResult_t? fileDetailsResult_t = await Internal.GetFileDetails(filename);
		if (!fileDetailsResult_t.HasValue || fileDetailsResult_t.Value.Result != Result.OK)
		{
			return null;
		}
		FileDetails value = default(FileDetails);
		value.SizeInBytes = fileDetailsResult_t.Value.FileSize;
		value.Flags = fileDetailsResult_t.Value.Flags;
		value.Sha1 = string.Join("", fileDetailsResult_t.Value.FileSHA.Select((byte x) => x.ToString("x")));
		return value;
	}

	public static bool IsTimedTrial(out int secondsAllowed, out int secondsPlayed)
	{
		uint punSecondsAllowed = 0u;
		uint punSecondsPlayed = 0u;
		secondsAllowed = 0;
		secondsPlayed = 0;
		if (!Internal.BIsTimedTrial(ref punSecondsAllowed, ref punSecondsPlayed))
		{
			return false;
		}
		secondsAllowed = (int)punSecondsAllowed;
		secondsPlayed = (int)punSecondsPlayed;
		return true;
	}
}


using System;
using System.Collections.Generic;
using Steamworks;

public static class SteamClient
{
	private static bool initialized;

	private static readonly List<SteamClass> openInterfaces = new List<SteamClass>();

	public static bool IsValid => initialized;

	public static bool IsLoggedOn => SteamUser.Internal.BLoggedOn();

	public static SteamId SteamId => SteamUser.Internal.GetSteamID();

	public static string Name => SteamFriends.Internal.GetPersonaName();

	public static FriendState State => SteamFriends.Internal.GetPersonaState();

	public static AppId AppId { get; internal set; }

	public static void Init(uint appid, bool asyncCallbacks = true)
	{
		if (initialized)
		{
			throw new Exception("Calling SteamClient.Init but is already initialized");
		}
		Environment.SetEnvironmentVariable("SteamAppId", appid.ToString());
		Environment.SetEnvironmentVariable("SteamGameId", appid.ToString());
		string pOutErrMsg;
		SteamAPIInitResult steamAPIInitResult = SteamAPI.Init(Helpers.BuildVersionString("STEAMAPPS_INTERFACE_VERSION008", "SteamFriends017", "SteamInput006", "STEAMINVENTORY_INTERFACE_V003", "SteamMatchMaking009", "SteamMatchMakingServers002", "STEAMMUSIC_INTERFACE_VERSION001", "SteamNetworking006", "SteamNetworkingSockets012", "SteamNetworkingUtils004", "STEAMPARENTALSETTINGS_INTERFACE_VERSION001", "SteamParties002", "STEAMREMOTESTORAGE_INTERFACE_VERSION016", "STEAMSCREENSHOTS_INTERFACE_VERSION003", "STEAMUGC_INTERFACE_VERSION020", "SteamUser023", "STEAMUSERSTATS_INTERFACE_VERSION013", "SteamUtils010", "STEAMVIDEO_INTERFACE_V007", "STEAMREMOTEPLAY_INTERFACE_VERSION002", "STEAMTIMELINE_INTERFACE_V004"), out pOutErrMsg);
		if (steamAPIInitResult != 0)
		{
			throw new Exception($"SteamApi_Init failed with {steamAPIInitResult} - error: {pOutErrMsg}");
		}
		AppId = appid;
		initialized = true;
		Dispatch.Init();
		Dispatch.ClientPipe = SteamAPI.GetHSteamPipe();
		AddInterface<SteamApps>();
		AddInterface<SteamFriends>();
		AddInterface<SteamInput>();
		AddInterface<SteamInventory>();
		AddInterface<SteamMatchmaking>();
		AddInterface<SteamMatchmakingServers>();
		AddInterface<SteamMusic>();
		AddInterface<SteamNetworking>();
		AddInterface<SteamNetworkingSockets>();
		AddInterface<SteamNetworkingUtils>();
		AddInterface<SteamParental>();
		AddInterface<SteamParties>();
		AddInterface<SteamRemoteStorage>();
		AddInterface<SteamScreenshots>();
		AddInterface<SteamUGC>();
		AddInterface<SteamUser>();
		AddInterface<SteamUserStats>();
		AddInterface<SteamUtils>();
		AddInterface<SteamVideo>();
		AddInterface<SteamRemotePlay>();
		AddInterface<SteamTimeline>();
		initialized = openInterfaces.Count > 0;
		if (asyncCallbacks)
		{
			Dispatch.LoopClientAsync();
		}
	}

	internal static void AddInterface<T>() where T : SteamClass, new()
	{
		T val = new T();
		if (val.InitializeInterface(server: false))
		{
			openInterfaces.Add(val);
		}
		else
		{
			val.DestroyInterface(server: false);
		}
	}

	internal static void ShutdownInterfaces()
	{
		foreach (SteamClass openInterface in openInterfaces)
		{
			openInterface.DestroyInterface(server: false);
		}
		openInterfaces.Clear();
	}

	public static void Shutdown()
	{
		if (IsValid)
		{
			Cleanup();
			SteamAPI.Shutdown();
		}
	}

	internal static void Cleanup()
	{
		Dispatch.ShutdownClient();
		initialized = false;
		ShutdownInterfaces();
	}

	public static void RunCallbacks()
	{
		if (Dispatch.ClientPipe != 0)
		{
			Dispatch.Frame(Dispatch.ClientPipe);
		}
	}

	public static bool RestartAppIfNecessary(uint appid)
	{
		return SteamAPI.RestartAppIfNecessary(appid);
	}

	internal static void ValidCheck()
	{
		if (!IsValid)
		{
			throw new Exception("SteamClient isn't initialized");
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;

public class SteamFriends : SteamClientClass<SteamFriends>
{
	[CompilerGenerated]
	private sealed class <GetClans>d__43 : IEnumerable<Clan>, IEnumerable, IEnumerator<Clan>, IDisposable, IEnumerator
	{
		private int <>1__state;

		private Clan <>2__current;

		private int <>l__initialThreadId;

		private int <i>5__2;

		Clan IEnumerator<Clan>.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		object IEnumerator.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		[DebuggerHidden]
		public <GetClans>d__43(int <>1__state)
		{
			this.<>1__state = <>1__state;
			<>l__initialThreadId = Environment.CurrentManagedThreadId;
		}

		[DebuggerHidden]
		void IDisposable.Dispose()
		{
			<>1__state = -2;
		}

		private bool MoveNext()
		{
			switch (<>1__state)
			{
			default:
				return false;
			case 0:
				<>1__state = -1;
				<i>5__2 = 0;
				break;
			case 1:
				<>1__state = -1;
				<i>5__2++;
				break;
			}
			if (<i>5__2 < Internal.GetClanCount())
			{
				<>2__current = new Clan(Internal.GetClanByIndex(<i>5__2));
				<>1__state = 1;
				return true;
			}
			return false;
		}

		bool IEnumerator.MoveNext()
		{
			//ILSpy generated this explicit interface implementation from .override directive in MoveNext
			return this.MoveNext();
		}

		[DebuggerHidden]
		void IEnumerator.Reset()
		{
			throw new NotSupportedException();
		}

		[DebuggerHidden]
		IEnumerator<Clan> IEnumerable<Clan>.GetEnumerator()
		{
			if (<>1__state == -2 && <>l__initialThreadId == Environment.CurrentManagedThreadId)
			{
				<>1__state = 0;
				return this;
			}
			return new <GetClans>d__43(0);
		}

		[DebuggerHidden]
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<Clan>)this).GetEnumerator();
		}
	}

	[CompilerGenerated]
	private sealed class <GetFriendsWithFlag>d__34 : IEnumerable<Friend>, IEnumerable, IEnumerator<Friend>, IDisposable, IEnumerator
	{
		private int <>1__state;

		private Friend <>2__current;

		private int <>l__initialThreadId;

		private FriendFlags flag;

		public FriendFlags <>3__flag;

		private int <i>5__2;

		Friend IEnumerator<Friend>.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		object IEnumerator.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		[DebuggerHidden]
		public <GetFriendsWithFlag>d__34(int <>1__state)
		{
			this.<>1__state = <>1__state;
			<>l__initialThreadId = Environment.CurrentManagedThreadId;
		}

		[DebuggerHidden]
		void IDisposable.Dispose()
		{
			<>1__state = -2;
		}

		private bool MoveNext()
		{
			switch (<>1__state)
			{
			default:
				return false;
			case 0:
				<>1__state = -1;
				<i>5__2 = 0;
				break;
			case 1:
				<>1__state = -1;
				<i>5__2++;
				break;
			}
			if (<i>5__2 < Internal.GetFriendCount((int)flag))
			{
				<>2__current = new Friend(Internal.GetFriendByIndex(<i>5__2, (int)flag));
				<>1__state = 1;
				return true;
			}
			return false;
		}

		bool IEnumerator.MoveNext()
		{
			//ILSpy generated this explicit interface implementation from .override directive in MoveNext
			return this.MoveNext();
		}

		[DebuggerHidden]
		void IEnumerator.Reset()
		{
			throw new NotSupportedException();
		}

		[DebuggerHidden]
		IEnumerator<Friend> IEnumerable<Friend>.GetEnumerator()
		{
			<GetFriendsWithFlag>d__34 <GetFriendsWithFlag>d__;
			if (<>1__state == -2 && <>l__initialThreadId == Environment.CurrentManagedThreadId)
			{
				<>1__state = 0;
				<GetFriendsWithFlag>d__ = this;
			}
			else
			{
				<GetFriendsWithFlag>d__ = new <GetFriendsWithFlag>d__34(0);
			}
			<GetFriendsWithFlag>d__.flag = <>3__flag;
			return <GetFriendsWithFlag>d__;
		}

		[DebuggerHidden]
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<Friend>)this).GetEnumerator();
		}
	}

	[CompilerGenerated]
	private sealed class <GetFromSource>d__42 : IEnumerable<Friend>, IEnumerable, IEnumerator<Friend>, IDisposable, IEnumerator
	{
		private int <>1__state;

		private Friend <>2__current;

		private int <>l__initialThreadId;

		private SteamId steamid;

		public SteamId <>3__steamid;

		private int <i>5__2;

		Friend IEnumerator<Friend>.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		object IEnumerator.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		[DebuggerHidden]
		public <GetFromSource>d__42(int <>1__state)
		{
			this.<>1__state = <>1__state;
			<>l__initialThreadId = Environment.CurrentManagedThreadId;
		}

		[DebuggerHidden]
		void IDisposable.Dispose()
		{
			<>1__state = -2;
		}

		private bool MoveNext()
		{
			switch (<>1__state)
			{
			default:
				return false;
			case 0:
				<>1__state = -1;
				<i>5__2 = 0;
				break;
			case 1:
				<>1__state = -1;
				<i>5__2++;
				break;
			}
			if (<i>5__2 < Internal.GetFriendCountFromSource(steamid))
			{
				<>2__current = new Friend(Internal.GetFriendFromSourceByIndex(steamid, <i>5__2));
				<>1__state = 1;
				return true;
			}
			return false;
		}

		bool IEnumerator.MoveNext()
		{
			//ILSpy generated this explicit interface implementation from .override directive in MoveNext
			return this.MoveNext();
		}

		[DebuggerHidden]
		void IEnumerator.Reset()
		{
			throw new NotSupportedException();
		}

		[DebuggerHidden]
		IEnumerator<Friend> IEnumerable<Friend>.GetEnumerator()
		{
			<GetFromSource>d__42 <GetFromSource>d__;
			if (<>1__state == -2 && <>l__initialThreadId == Environment.CurrentManagedThreadId)
			{
				<>1__state = 0;
				<GetFromSource>d__ = this;
			}
			else
			{
				<GetFromSource>d__ = new <GetFromSource>d__42(0);
			}
			<GetFromSource>d__.steamid = <>3__steamid;
			return <GetFromSource>d__;
		}

		[DebuggerHidden]
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<Friend>)this).GetEnumerator();
		}
	}

	[CompilerGenerated]
	private sealed class <GetPlayedWith>d__41 : IEnumerable<Friend>, IEnumerable, IEnumerator<Friend>, IDisposable, IEnumerator
	{
		private int <>1__state;

		private Friend <>2__current;

		private int <>l__initialThreadId;

		private int <i>5__2;

		Friend IEnumerator<Friend>.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		object IEnumerator.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		[DebuggerHidden]
		public <GetPlayedWith>d__41(int <>1__state)
		{
			this.<>1__state = <>1__state;
			<>l__initialThreadId = Environment.CurrentManagedThreadId;
		}

		[DebuggerHidden]
		void IDisposable.Dispose()
		{
			<>1__state = -2;
		}

		private bool MoveNext()
		{
			switch (<>1__state)
			{
			default:
				return false;
			case 0:
				<>1__state = -1;
				<i>5__2 = 0;
				break;
			case 1:
				<>1__state = -1;
				<i>5__2++;
				break;
			}
			if (<i>5__2 < Internal.GetCoplayFriendCount())
			{
				<>2__current = new Friend(Internal.GetCoplayFriend(<i>5__2));
				<>1__state = 1;
				return true;
			}
			return false;
		}

		bool IEnumerator.MoveNext()
		{
			//ILSpy generated this explicit interface implementation from .override directive in MoveNext
			return this.MoveNext();
		}

		[DebuggerHidden]
		void IEnumerator.Reset()
		{
			throw new NotSupportedException();
		}

		[DebuggerHidden]
		IEnumerator<Friend> IEnumerable<Friend>.GetEnumerator()
		{
			if (<>1__state == -2 && <>l__initialThreadId == Environment.CurrentManagedThreadId)
			{
				<>1__state = 0;
				return this;
			}
			return new <GetPlayedWith>d__41(0);
		}

		[DebuggerHidden]
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<Friend>)this).GetEnumerator();
		}
	}

	private static Dictionary<string, string> richPresence;

	private static bool _listenForFriendsMessages;

	internal static ISteamFriends Internal => SteamClientClass<SteamFriends>.Interface as ISteamFriends;

	public static bool ListenForFriendsMessages
	{
		get
		{
			return _listenForFriendsMessages;
		}
		set
		{
			_listenForFriendsMessages = value;
			Internal.SetListenForFriendsMessages(value);
		}
	}

	public static event Action<Friend, string, string> OnChatMessage;

	public static event Action<Friend, string, string> OnClanChatMessage;

	public static event Action<Friend> OnPersonaStateChange;

	public static event Action<Friend, string> OnGameRichPresenceJoinRequested;

	public static event Action<bool> OnGameOverlayActivated;

	public static event Action<string, string> OnGameServerChangeRequested;

	public static event Action<Lobby, SteamId> OnGameLobbyJoinRequested;

	public static event Action<Friend> OnFriendRichPresenceUpdate;

	public static event Action<string> OnOverlayBrowserProtocol;

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamFriends(server));
		if (SteamClientClass<SteamFriends>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		richPresence = new Dictionary<string, string>();
		InstallEvents();
		return true;
	}

	internal void InstallEvents()
	{
		Dispatch.Install(delegate(PersonaStateChange_t x)
		{
			SteamFriends.OnPersonaStateChange?.Invoke(new Friend(x.SteamID));
		});
		Dispatch.Install(delegate(GameRichPresenceJoinRequested_t x)
		{
			SteamFriends.OnGameRichPresenceJoinRequested?.Invoke(new Friend(x.SteamIDFriend), x.ConnectUTF8());
		});
		Dispatch.Install<GameConnectedFriendChatMsg_t>(OnFriendChatMessage);
		Dispatch.Install<GameConnectedClanChatMsg_t>(OnGameConnectedClanChatMessage);
		Dispatch.Install(delegate(GameOverlayActivated_t x)
		{
			SteamFriends.OnGameOverlayActivated?.Invoke(x.Active != 0);
		});
		Dispatch.Install(delegate(GameServerChangeRequested_t x)
		{
			SteamFriends.OnGameServerChangeRequested?.Invoke(x.ServerUTF8(), x.PasswordUTF8());
		});
		Dispatch.Install(delegate(GameLobbyJoinRequested_t x)
		{
			SteamFriends.OnGameLobbyJoinRequested?.Invoke(new Lobby(x.SteamIDLobby), x.SteamIDFriend);
		});
		Dispatch.Install(delegate(FriendRichPresenceUpdate_t x)
		{
			SteamFriends.OnFriendRichPresenceUpdate?.Invoke(new Friend(x.SteamIDFriend));
		});
		Dispatch.Install(delegate(OverlayBrowserProtocolNavigation_t x)
		{
			SteamFriends.OnOverlayBrowserProtocol?.Invoke(x.RgchURIUTF8());
		});
	}

	private static void OnFriendChatMessage(GameConnectedFriendChatMsg_t data)
	{
		if (SteamFriends.OnChatMessage == null)
		{
			return;
		}
		Friend arg = new Friend(data.SteamIDUser);
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			ChatEntryType peChatEntryType = ChatEntryType.ChatMsg;
			if (Internal.GetFriendMessage(data.SteamIDUser, data.MessageID, m, 32768, ref peChatEntryType) != 0 || peChatEntryType != 0)
			{
				string arg2 = peChatEntryType.ToString();
				string arg3 = Helpers.MemoryToString(m);
				SteamFriends.OnChatMessage(arg, arg2, arg3);
			}
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	private static void OnGameConnectedClanChatMessage(GameConnectedClanChatMsg_t data)
	{
		if (SteamFriends.OnClanChatMessage == null)
		{
			return;
		}
		Friend arg = new Friend(data.SteamIDUser);
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			ChatEntryType peChatEntryType = ChatEntryType.ChatMsg;
			SteamId psteamidChatter = data.SteamIDUser;
			if (Internal.GetClanChatMessage(data.SteamIDClanChat, data.MessageID, m, 32768, ref peChatEntryType, ref psteamidChatter) != 0 || peChatEntryType != 0)
			{
				string arg2 = peChatEntryType.ToString();
				string arg3 = Helpers.MemoryToString(m);
				SteamFriends.OnClanChatMessage(arg, arg2, arg3);
			}
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[IteratorStateMachine(typeof(<GetFriendsWithFlag>d__34))]
	private static IEnumerable<Friend> GetFriendsWithFlag(FriendFlags flag)
	{
		//yield-return decompiler failed: Unexpected instruction in Iterator.Dispose()
		return new <GetFriendsWithFlag>d__34(-2)
		{
			<>3__flag = flag
		};
	}

	public static IEnumerable<Friend> GetFriends()
	{
		return GetFriendsWithFlag(FriendFlags.Immediate);
	}

	public static IEnumerable<Friend> GetBlocked()
	{
		return GetFriendsWithFlag(FriendFlags.Blocked);
	}

	public static IEnumerable<Friend> GetFriendsRequested()
	{
		return GetFriendsWithFlag(FriendFlags.FriendshipRequested);
	}

	public static IEnumerable<Friend> GetFriendsClanMembers()
	{
		return GetFriendsWithFlag(FriendFlags.ClanMember);
	}

	public static IEnumerable<Friend> GetFriendsOnGameServer()
	{
		return GetFriendsWithFlag(FriendFlags.OnGameServer);
	}

	public static IEnumerable<Friend> GetFriendsRequestingFriendship()
	{
		return GetFriendsWithFlag(FriendFlags.RequestingFriendship);
	}

	[IteratorStateMachine(typeof(<GetPlayedWith>d__41))]
	public static IEnumerable<Friend> GetPlayedWith()
	{
		//yield-return decompiler failed: Unexpected instruction in Iterator.Dispose()
		return new <GetPlayedWith>d__41(-2);
	}

	[IteratorStateMachine(typeof(<GetFromSource>d__42))]
	public static IEnumerable<Friend> GetFromSource(SteamId steamid)
	{
		//yield-return decompiler failed: Unexpected instruction in Iterator.Dispose()
		return new <GetFromSource>d__42(-2)
		{
			<>3__steamid = steamid
		};
	}

	[IteratorStateMachine(typeof(<GetClans>d__43))]
	public static IEnumerable<Clan> GetClans()
	{
		//yield-return decompiler failed: Unexpected instruction in Iterator.Dispose()
		return new <GetClans>d__43(-2);
	}

	public static void OpenOverlay(string type)
	{
		Internal.ActivateGameOverlay(type);
	}

	public static void OpenUserOverlay(SteamId id, string type)
	{
		Internal.ActivateGameOverlayToUser(type, id);
	}

	public static void OpenStoreOverlay(AppId id, OverlayToStoreFlag overlayToStoreFlag = OverlayToStoreFlag.None)
	{
		Internal.ActivateGameOverlayToStore(id.Value, overlayToStoreFlag);
	}

	public static void OpenWebOverlay(string url, bool modal = false)
	{
		Internal.ActivateGameOverlayToWebPage(url, modal ? ActivateGameOverlayToWebPageMode.Modal : ActivateGameOverlayToWebPageMode.Default);
	}

	public static void OpenGameInviteOverlay(SteamId lobby)
	{
		Internal.ActivateGameOverlayInviteDialog(lobby);
	}

	public static void SetPlayedWith(SteamId steamid)
	{
		Internal.SetPlayedWith(steamid);
	}

	public static bool RequestUserInformation(SteamId steamid, bool nameonly = true)
	{
		return Internal.RequestUserInformation(steamid, nameonly);
	}

	internal static async Task CacheUserInformationAsync(SteamId steamid, bool nameonly)
	{
		if (RequestUserInformation(steamid, nameonly))
		{
			await Task.Delay(100);
			while (RequestUserInformation(steamid, nameonly))
			{
				await Task.Delay(50);
			}
			await Task.Delay(500);
		}
	}

	public static async Task<Image?> GetSmallAvatarAsync(SteamId steamid)
	{
		await CacheUserInformationAsync(steamid, nameonly: false);
		return SteamUtils.GetImage(Internal.GetSmallFriendAvatar(steamid));
	}

	public static async Task<Image?> GetMediumAvatarAsync(SteamId steamid)
	{
		await CacheUserInformationAsync(steamid, nameonly: false);
		return SteamUtils.GetImage(Internal.GetMediumFriendAvatar(steamid));
	}

	public static async Task<Image?> GetLargeAvatarAsync(SteamId steamid)
	{
		await CacheUserInformationAsync(steamid, nameonly: false);
		int largeFriendAvatar;
		for (largeFriendAvatar = Internal.GetLargeFriendAvatar(steamid); largeFriendAvatar == -1; largeFriendAvatar = Internal.GetLargeFriendAvatar(steamid))
		{
			await Task.Delay(50);
		}
		return SteamUtils.GetImage(largeFriendAvatar);
	}

	public static string GetRichPresence(string key)
	{
		if (richPresence.TryGetValue(key, out var value))
		{
			return value;
		}
		return null;
	}

	public static bool SetRichPresence(string key, string value)
	{
		bool num = Internal.SetRichPresence(key, value);
		if (num)
		{
			richPresence[key] = value;
		}
		return num;
	}

	public static void ClearRichPresence()
	{
		richPresence.Clear();
		Internal.ClearRichPresence();
	}

	public static async Task<bool> IsFollowing(SteamId steamID)
	{
		return (await Internal.IsFollowing(steamID)).Value.IsFollowing;
	}

	public static async Task<int> GetFollowerCount(SteamId steamID)
	{
		return (await Internal.GetFollowerCount(steamID)).Value.Count;
	}

	public static async Task<SteamId[]> GetFollowingList()
	{
		int resultCount = 0;
		List<SteamId> steamIds = new List<SteamId>();
		FriendsEnumerateFollowingList_t? friendsEnumerateFollowingList_t;
		do
		{
			FriendsEnumerateFollowingList_t? friendsEnumerateFollowingList_t2 = (friendsEnumerateFollowingList_t = await Internal.EnumerateFollowingList((uint)resultCount));
			if (!friendsEnumerateFollowingList_t2.HasValue)
			{
				continue;
			}
			resultCount += friendsEnumerateFollowingList_t.Value.ResultsReturned;
			Array.ForEach(friendsEnumerateFollowingList_t.Value.GSteamID, delegate(ulong id)
			{
				if (id != 0)
				{
					steamIds.Add(id);
				}
			});
		}
		while (friendsEnumerateFollowingList_t.HasValue && resultCount < friendsEnumerateFollowingList_t.Value.TotalResultCount);
		return steamIds.ToArray();
	}

	public static bool RegisterProtocolInOverlayBrowser(string protocol)
	{
		return Internal.RegisterProtocolInOverlayBrowser(protocol);
	}

	public static async Task<bool> JoinClanChatRoom(SteamId chatId)
	{
		JoinClanChatRoomCompletionResult_t? joinClanChatRoomCompletionResult_t = await Internal.JoinClanChatRoom(chatId);
		if (!joinClanChatRoomCompletionResult_t.HasValue)
		{
			return false;
		}
		return joinClanChatRoomCompletionResult_t.Value.ChatRoomEnterResponse == RoomEnter.Success;
	}

	public static bool SendClanChatRoomMessage(SteamId chatId, string message)
	{
		return Internal.SendClanChatMessage(chatId, message);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using Steamworks;
using Steamworks.Data;

public class SteamInput : SteamClientClass<SteamInput>
{
	[CompilerGenerated]
	private sealed class <get_Controllers>d__7 : IEnumerable<Controller>, IEnumerable, IEnumerator<Controller>, IDisposable, IEnumerator
	{
		private int <>1__state;

		private Controller <>2__current;

		private int <>l__initialThreadId;

		private int <num>5__2;

		private int <i>5__3;

		Controller IEnumerator<Controller>.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		object IEnumerator.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		[DebuggerHidden]
		public <get_Controllers>d__7(int <>1__state)
		{
			this.<>1__state = <>1__state;
			<>l__initialThreadId = Environment.CurrentManagedThreadId;
		}

		[DebuggerHidden]
		void IDisposable.Dispose()
		{
			<>1__state = -2;
		}

		private bool MoveNext()
		{
			switch (<>1__state)
			{
			default:
				return false;
			case 0:
				<>1__state = -1;
				<num>5__2 = Internal.GetConnectedControllers(queryArray);
				<i>5__3 = 0;
				break;
			case 1:
				<>1__state = -1;
				<i>5__3++;
				break;
			}
			if (<i>5__3 < <num>5__2)
			{
				<>2__current = new Controller(queryArray[<i>5__3]);
				<>1__state = 1;
				return true;
			}
			return false;
		}

		bool IEnumerator.MoveNext()
		{
			//ILSpy generated this explicit interface implementation from .override directive in MoveNext
			return this.MoveNext();
		}

		[DebuggerHidden]
		void IEnumerator.Reset()
		{
			throw new NotSupportedException();
		}

		[DebuggerHidden]
		IEnumerator<Controller> IEnumerable<Controller>.GetEnumerator()
		{
			if (<>1__state == -2 && <>l__initialThreadId == Environment.CurrentManagedThreadId)
			{
				<>1__state = 0;
				return this;
			}
			return new <get_Controllers>d__7(0);
		}

		[DebuggerHidden]
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<Controller>)this).GetEnumerator();
		}
	}

	internal const int STEAM_CONTROLLER_MAX_COUNT = 16;

	private static readonly InputHandle_t[] queryArray = new InputHandle_t[16];

	internal static Dictionary<string, InputDigitalActionHandle_t> DigitalHandles = new Dictionary<string, InputDigitalActionHandle_t>();

	internal static Dictionary<string, InputAnalogActionHandle_t> AnalogHandles = new Dictionary<string, InputAnalogActionHandle_t>();

	internal static Dictionary<string, InputActionSetHandle_t> ActionSets = new Dictionary<string, InputActionSetHandle_t>();

	internal static ISteamInput Internal => SteamClientClass<SteamInput>.Interface as ISteamInput;

	public static IEnumerable<Controller> Controllers
	{
		[IteratorStateMachine(typeof(<get_Controllers>d__7))]
		get
		{
			//yield-return decompiler failed: Unexpected instruction in Iterator.Dispose()
			return new <get_Controllers>d__7(-2);
		}
	}

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamInput(server));
		if (SteamClientClass<SteamInput>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		return true;
	}

	public static void RunFrame()
	{
		Internal.RunFrame(bReservedValue: false);
	}

	public static string GetDigitalActionGlyph(Controller controller, string action)
	{
		InputActionOrigin originsOut = InputActionOrigin.None;
		Internal.GetDigitalActionOrigins(controller.Handle, Internal.GetCurrentActionSet(controller.Handle), GetDigitalActionHandle(action), ref originsOut);
		return Internal.GetGlyphForActionOrigin_Legacy(originsOut);
	}

	public static string GetPngActionGlyph(Controller controller, string action, GlyphSize size)
	{
		InputActionOrigin originsOut = InputActionOrigin.None;
		Internal.GetDigitalActionOrigins(controller.Handle, Internal.GetCurrentActionSet(controller.Handle), GetDigitalActionHandle(action), ref originsOut);
		return Internal.GetGlyphPNGForActionOrigin(originsOut, size, 0u);
	}

	public static string GetSvgActionGlyph(Controller controller, string action)
	{
		InputActionOrigin originsOut = InputActionOrigin.None;
		Internal.GetDigitalActionOrigins(controller.Handle, Internal.GetCurrentActionSet(controller.Handle), GetDigitalActionHandle(action), ref originsOut);
		return Internal.GetGlyphSVGForActionOrigin(originsOut, 0u);
	}

	internal static InputDigitalActionHandle_t GetDigitalActionHandle(string name)
	{
		if (DigitalHandles.TryGetValue(name, out var value))
		{
			return value;
		}
		value = Internal.GetDigitalActionHandle(name);
		DigitalHandles.Add(name, value);
		return value;
	}

	internal static InputAnalogActionHandle_t GetAnalogActionHandle(string name)
	{
		if (AnalogHandles.TryGetValue(name, out var value))
		{
			return value;
		}
		value = Internal.GetAnalogActionHandle(name);
		AnalogHandles.Add(name, value);
		return value;
	}

	internal static InputActionSetHandle_t GetActionSetHandle(string name)
	{
		if (ActionSets.TryGetValue(name, out var value))
		{
			return value;
		}
		value = Internal.GetActionSetHandle(name);
		ActionSets.Add(name, value);
		return value;
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;

public class SteamInventory : SteamSharedClass<SteamInventory>
{
	private static Dictionary<int, InventoryDef> _defMap;

	internal static ISteamInventory Internal => SteamSharedClass<SteamInventory>.Interface as ISteamInventory;

	public static string Currency { get; internal set; }

	public static InventoryItem[] Items { get; internal set; }

	public static InventoryDef[] Definitions { get; internal set; }

	public static event Action<InventoryResult> OnInventoryUpdated;

	public static event Action OnDefinitionsUpdated;

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamInventory(server));
		if (SteamSharedClass<SteamInventory>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		InstallEvents(server);
		return true;
	}

	internal static void InstallEvents(bool server)
	{
		if (!server)
		{
			Dispatch.Install(delegate(SteamInventoryFullUpdate_t x)
			{
				InventoryUpdated(x);
			});
		}
		Dispatch.Install<SteamInventoryDefinitionUpdate_t>(delegate
		{
			LoadDefinitions();
		}, server);
	}

	private static void InventoryUpdated(SteamInventoryFullUpdate_t x)
	{
		InventoryResult obj = new InventoryResult(x.Handle, expired: false);
		Items = obj.GetItems();
		SteamInventory.OnInventoryUpdated?.Invoke(obj);
	}

	private static void LoadDefinitions()
	{
		Definitions = GetDefinitions();
		if (Definitions != null)
		{
			_defMap = new Dictionary<int, InventoryDef>();
			InventoryDef[] definitions = Definitions;
			foreach (InventoryDef inventoryDef in definitions)
			{
				_defMap[inventoryDef.Id] = inventoryDef;
			}
			SteamInventory.OnDefinitionsUpdated?.Invoke();
		}
	}

	public static void LoadItemDefinitions()
	{
		if (Definitions == null)
		{
			LoadDefinitions();
		}
		Internal.LoadItemDefinitions();
	}

	public static async Task<bool> WaitForDefinitions(float timeoutSeconds = 30f)
	{
		if (Definitions != null)
		{
			return true;
		}
		LoadDefinitions();
		LoadItemDefinitions();
		if (Definitions != null)
		{
			return true;
		}
		Stopwatch sw = Stopwatch.StartNew();
		while (Definitions == null)
		{
			if (sw.Elapsed.TotalSeconds > (double)timeoutSeconds)
			{
				return false;
			}
			await Task.Delay(10);
		}
		return true;
	}

	public static InventoryDef FindDefinition(InventoryDefId defId)
	{
		if (_defMap == null)
		{
			return null;
		}
		if (_defMap.TryGetValue(defId, out var value))
		{
			return value;
		}
		return null;
	}

	public static async Task<InventoryDef[]> GetDefinitionsWithPricesAsync()
	{
		SteamInventoryRequestPricesResult_t? steamInventoryRequestPricesResult_t = await Internal.RequestPrices();
		if (!steamInventoryRequestPricesResult_t.HasValue || steamInventoryRequestPricesResult_t.Value.Result != Result.OK)
		{
			return null;
		}
		Currency = steamInventoryRequestPricesResult_t?.CurrencyUTF8();
		uint numItemsWithPrices = Internal.GetNumItemsWithPrices();
		if (numItemsWithPrices == 0)
		{
			return null;
		}
		InventoryDefId[] array = new InventoryDefId[numItemsWithPrices];
		ulong[] pCurrentPrices = new ulong[numItemsWithPrices];
		ulong[] pBasePrices = new ulong[numItemsWithPrices];
		if (!Internal.GetItemsWithPrices(array, pCurrentPrices, pBasePrices, numItemsWithPrices))
		{
			return null;
		}
		return array.Select((InventoryDefId x) => new InventoryDef(x)).ToArray();
	}

	internal static InventoryDef[] GetDefinitions()
	{
		uint punItemDefIDsArraySize = 0u;
		if (!Internal.GetItemDefinitionIDs(null, ref punItemDefIDsArraySize))
		{
			return null;
		}
		InventoryDefId[] array = new InventoryDefId[punItemDefIDsArraySize];
		if (!Internal.GetItemDefinitionIDs(array, ref punItemDefIDsArraySize))
		{
			return null;
		}
		return array.Select((InventoryDefId x) => new InventoryDef(x)).ToArray();
	}

	public static bool GetAllItems()
	{
		SteamInventoryResult_t pResultHandle = Defines.k_SteamInventoryResultInvalid;
		return Internal.GetAllItems(ref pResultHandle);
	}

	public static async Task<InventoryResult?> GetAllItemsAsync()
	{
		SteamInventoryResult_t pResultHandle = Defines.k_SteamInventoryResultInvalid;
		if (!Internal.GetAllItems(ref pResultHandle))
		{
			return null;
		}
		return await InventoryResult.GetAsync(pResultHandle);
	}

	public static async Task<InventoryResult?> GenerateItemAsync(InventoryDef target, int amount)
	{
		SteamInventoryResult_t pResultHandle = Defines.k_SteamInventoryResultInvalid;
		InventoryDefId[] pArrayItemDefs = new InventoryDefId[1] { target.Id };
		uint[] punArrayQuantity = new uint[1] { (uint)amount };
		if (!Internal.GenerateItems(ref pResultHandle, pArrayItemDefs, punArrayQuantity, 1u))
		{
			return null;
		}
		return await InventoryResult.GetAsync(pResultHandle);
	}

	public static async Task<InventoryResult?> CraftItemAsync(InventoryItem[] list, InventoryDef target)
	{
		SteamInventoryResult_t pResultHandle = Defines.k_SteamInventoryResultInvalid;
		InventoryDefId[] pArrayGenerate = new InventoryDefId[1] { target.Id };
		uint[] punArrayGenerateQuantity = new uint[1] { 1u };
		InventoryItemId[] array = list.Select((InventoryItem x) => x.Id).ToArray();
		uint[] punArrayDestroyQuantity = list.Select((InventoryItem x) => 1u).ToArray();
		if (!Internal.ExchangeItems(ref pResultHandle, pArrayGenerate, punArrayGenerateQuantity, 1u, array, punArrayDestroyQuantity, (uint)array.Length))
		{
			return null;
		}
		return await InventoryResult.GetAsync(pResultHandle);
	}

	public static async Task<InventoryResult?> CraftItemAsync(InventoryItem.Amount[] list, InventoryDef target)
	{
		SteamInventoryResult_t pResultHandle = Defines.k_SteamInventoryResultInvalid;
		InventoryDefId[] pArrayGenerate = new InventoryDefId[1] { target.Id };
		uint[] punArrayGenerateQuantity = new uint[1] { 1u };
		InventoryItemId[] array = list.Select((InventoryItem.Amount x) => x.Item.Id).ToArray();
		uint[] punArrayDestroyQuantity = list.Select((InventoryItem.Amount x) => (uint)x.Quantity).ToArray();
		if (!Internal.ExchangeItems(ref pResultHandle, pArrayGenerate, punArrayGenerateQuantity, 1u, array, punArrayDestroyQuantity, (uint)array.Length))
		{
			return null;
		}
		return await InventoryResult.GetAsync(pResultHandle);
	}

	public static async Task<InventoryResult?> DeserializeAsync(byte[] data, int dataLength = -1)
	{
		if (data == null)
		{
			throw new ArgumentException("data should not be null");
		}
		if (dataLength == -1)
		{
			dataLength = data.Length;
		}
		IntPtr ptr = Marshal.AllocHGlobal(dataLength);
		try
		{
			Marshal.Copy(data, 0, ptr, dataLength);
			SteamInventoryResult_t pOutResultHandle = Defines.k_SteamInventoryResultInvalid;
			if (!Internal.DeserializeResult(ref pOutResultHandle, ptr, (uint)dataLength, bRESERVED_MUST_BE_FALSE: false))
			{
				return null;
			}
			return await InventoryResult.GetAsync(pOutResultHandle.Value);
		}
		finally
		{
			Marshal.FreeHGlobal(ptr);
		}
	}

	public static async Task<InventoryResult?> GrantPromoItemsAsync()
	{
		SteamInventoryResult_t pResultHandle = Defines.k_SteamInventoryResultInvalid;
		if (!Internal.GrantPromoItems(ref pResultHandle))
		{
			return null;
		}
		return await InventoryResult.GetAsync(pResultHandle);
	}

	public static async Task<InventoryResult?> TriggerItemDropAsync(InventoryDefId id)
	{
		SteamInventoryResult_t pResultHandle = Defines.k_SteamInventoryResultInvalid;
		if (!Internal.TriggerItemDrop(ref pResultHandle, id))
		{
			return null;
		}
		return await InventoryResult.GetAsync(pResultHandle);
	}

	public static async Task<InventoryResult?> AddPromoItemAsync(InventoryDefId id)
	{
		SteamInventoryResult_t pResultHandle = Defines.k_SteamInventoryResultInvalid;
		if (!Internal.AddPromoItem(ref pResultHandle, id))
		{
			return null;
		}
		return await InventoryResult.GetAsync(pResultHandle);
	}

	public static async Task<InventoryPurchaseResult?> StartPurchaseAsync(InventoryDef[] items)
	{
		Dictionary<InventoryDefId, uint> dictionary = (from x in items
			group x by x._id).ToDictionary((IGrouping<InventoryDefId, InventoryDef> x) => x.Key, (IGrouping<InventoryDefId, InventoryDef> x) => (uint)x.Count());
		InventoryDefId[] array = dictionary.Keys.ToArray();
		uint[] punArrayQuantity = dictionary.Values.ToArray();
		SteamInventoryStartPurchaseResult_t? steamInventoryStartPurchaseResult_t = await Internal.StartPurchase(array, punArrayQuantity, (uint)array.Length);
		if (!steamInventoryStartPurchaseResult_t.HasValue)
		{
			return null;
		}
		InventoryPurchaseResult value = default(InventoryPurchaseResult);
		value.Result = steamInventoryStartPurchaseResult_t.Value.Result;
		value.OrderID = steamInventoryStartPurchaseResult_t.Value.OrderID;
		value.TransID = steamInventoryStartPurchaseResult_t.Value.TransID;
		return value;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;

public class SteamMatchmaking : SteamClientClass<SteamMatchmaking>
{
	[CompilerGenerated]
	private sealed class <GetFavoriteServers>d__47 : IEnumerable<ServerInfo>, IEnumerable, IEnumerator<ServerInfo>, IDisposable, IEnumerator
	{
		private int <>1__state;

		private ServerInfo <>2__current;

		private int <>l__initialThreadId;

		private int <count>5__2;

		private int <i>5__3;

		ServerInfo IEnumerator<ServerInfo>.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		object IEnumerator.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		[DebuggerHidden]
		public <GetFavoriteServers>d__47(int <>1__state)
		{
			this.<>1__state = <>1__state;
			<>l__initialThreadId = Environment.CurrentManagedThreadId;
		}

		[DebuggerHidden]
		void IDisposable.Dispose()
		{
			<>1__state = -2;
		}

		private bool MoveNext()
		{
			int num = <>1__state;
			if (num != 0)
			{
				if (num != 1)
				{
					return false;
				}
				<>1__state = -1;
				goto IL_0088;
			}
			<>1__state = -1;
			<count>5__2 = Internal.GetFavoriteGameCount();
			<i>5__3 = 0;
			goto IL_009a;
			IL_0088:
			<i>5__3++;
			goto IL_009a;
			IL_009a:
			if (<i>5__3 < <count>5__2)
			{
				uint pRTime32LastPlayedOnServer = 0u;
				uint punFlags = 0u;
				ushort pnQueryPort = 0;
				ushort pnConnPort = 0;
				uint pnIP = 0u;
				AppId pnAppID = default(AppId);
				if (Internal.GetFavoriteGame(<i>5__3, ref pnAppID, ref pnIP, ref pnConnPort, ref pnQueryPort, ref punFlags, ref pRTime32LastPlayedOnServer) && (punFlags & 1) != 0)
				{
					<>2__current = new ServerInfo(pnIP, pnConnPort, pnQueryPort, pRTime32LastPlayedOnServer);
					<>1__state = 1;
					return true;
				}
				goto IL_0088;
			}
			return false;
		}

		bool IEnumerator.MoveNext()
		{
			//ILSpy generated this explicit interface implementation from .override directive in MoveNext
			return this.MoveNext();
		}

		[DebuggerHidden]
		void IEnumerator.Reset()
		{
			throw new NotSupportedException();
		}

		[DebuggerHidden]
		IEnumerator<ServerInfo> IEnumerable<ServerInfo>.GetEnumerator()
		{
			if (<>1__state == -2 && <>l__initialThreadId == Environment.CurrentManagedThreadId)
			{
				<>1__state = 0;
				return this;
			}
			return new <GetFavoriteServers>d__47(0);
		}

		[DebuggerHidden]
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<ServerInfo>)this).GetEnumerator();
		}
	}

	[CompilerGenerated]
	private sealed class <GetHistoryServers>d__48 : IEnumerable<ServerInfo>, IEnumerable, IEnumerator<ServerInfo>, IDisposable, IEnumerator
	{
		private int <>1__state;

		private ServerInfo <>2__current;

		private int <>l__initialThreadId;

		private int <count>5__2;

		private int <i>5__3;

		ServerInfo IEnumerator<ServerInfo>.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		object IEnumerator.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		[DebuggerHidden]
		public <GetHistoryServers>d__48(int <>1__state)
		{
			this.<>1__state = <>1__state;
			<>l__initialThreadId = Environment.CurrentManagedThreadId;
		}

		[DebuggerHidden]
		void IDisposable.Dispose()
		{
			<>1__state = -2;
		}

		private bool MoveNext()
		{
			int num = <>1__state;
			if (num != 0)
			{
				if (num != 1)
				{
					return false;
				}
				<>1__state = -1;
				goto IL_0088;
			}
			<>1__state = -1;
			<count>5__2 = Internal.GetFavoriteGameCount();
			<i>5__3 = 0;
			goto IL_009a;
			IL_0088:
			<i>5__3++;
			goto IL_009a;
			IL_009a:
			if (<i>5__3 < <count>5__2)
			{
				uint pRTime32LastPlayedOnServer = 0u;
				uint punFlags = 0u;
				ushort pnQueryPort = 0;
				ushort pnConnPort = 0;
				uint pnIP = 0u;
				AppId pnAppID = default(AppId);
				if (Internal.GetFavoriteGame(<i>5__3, ref pnAppID, ref pnIP, ref pnConnPort, ref pnQueryPort, ref punFlags, ref pRTime32LastPlayedOnServer) && (punFlags & 2) != 0)
				{
					<>2__current = new ServerInfo(pnIP, pnConnPort, pnQueryPort, pRTime32LastPlayedOnServer);
					<>1__state = 1;
					return true;
				}
				goto IL_0088;
			}
			return false;
		}

		bool IEnumerator.MoveNext()
		{
			//ILSpy generated this explicit interface implementation from .override directive in MoveNext
			return this.MoveNext();
		}

		[DebuggerHidden]
		void IEnumerator.Reset()
		{
			throw new NotSupportedException();
		}

		[DebuggerHidden]
		IEnumerator<ServerInfo> IEnumerable<ServerInfo>.GetEnumerator()
		{
			if (<>1__state == -2 && <>l__initialThreadId == Environment.CurrentManagedThreadId)
			{
				<>1__state = 0;
				return this;
			}
			return new <GetHistoryServers>d__48(0);
		}

		[DebuggerHidden]
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<ServerInfo>)this).GetEnumerator();
		}
	}

	internal static ISteamMatchmaking Internal => SteamClientClass<SteamMatchmaking>.Interface as ISteamMatchmaking;

	internal static int MaxLobbyKeyLength => 255;

	public static LobbyQuery LobbyList => default(LobbyQuery);

	public static event Action<Friend, Lobby> OnLobbyInvite;

	public static event Action<Lobby> OnLobbyEntered;

	public static event Action<Result, Lobby> OnLobbyCreated;

	public static event Action<Lobby, uint, ushort, SteamId> OnLobbyGameCreated;

	public static event Action<Lobby> OnLobbyDataChanged;

	public static event Action<Lobby, Friend> OnLobbyMemberDataChanged;

	public static event Action<Lobby, Friend> OnLobbyMemberJoined;

	public static event Action<Lobby, Friend> OnLobbyMemberLeave;

	public static event Action<Lobby, Friend> OnLobbyMemberDisconnected;

	public static event Action<Lobby, Friend, Friend> OnLobbyMemberKicked;

	public static event Action<Lobby, Friend, Friend> OnLobbyMemberBanned;

	public static event Action<Lobby, Friend, string> OnChatMessage;

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamMatchmaking(server));
		if (SteamClientClass<SteamMatchmaking>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		InstallEvents();
		return true;
	}

	internal static void InstallEvents()
	{
		Dispatch.Install(delegate(LobbyInvite_t x)
		{
			SteamMatchmaking.OnLobbyInvite?.Invoke(new Friend(x.SteamIDUser), new Lobby(x.SteamIDLobby));
		});
		Dispatch.Install(delegate(LobbyEnter_t x)
		{
			SteamMatchmaking.OnLobbyEntered?.Invoke(new Lobby(x.SteamIDLobby));
		});
		Dispatch.Install(delegate(LobbyCreated_t x)
		{
			SteamMatchmaking.OnLobbyCreated?.Invoke(x.Result, new Lobby(x.SteamIDLobby));
		});
		Dispatch.Install(delegate(LobbyGameCreated_t x)
		{
			SteamMatchmaking.OnLobbyGameCreated?.Invoke(new Lobby(x.SteamIDLobby), x.IP, x.Port, x.SteamIDGameServer);
		});
		Dispatch.Install(delegate(LobbyDataUpdate_t x)
		{
			if (x.Success != 0)
			{
				if (x.SteamIDLobby == x.SteamIDMember)
				{
					SteamMatchmaking.OnLobbyDataChanged?.Invoke(new Lobby(x.SteamIDLobby));
				}
				else
				{
					SteamMatchmaking.OnLobbyMemberDataChanged?.Invoke(new Lobby(x.SteamIDLobby), new Friend(x.SteamIDMember));
				}
			}
		});
		Dispatch.Install(delegate(LobbyChatUpdate_t x)
		{
			if ((x.GfChatMemberStateChange & 1) != 0)
			{
				SteamMatchmaking.OnLobbyMemberJoined?.Invoke(new Lobby(x.SteamIDLobby), new Friend(x.SteamIDUserChanged));
			}
			if ((x.GfChatMemberStateChange & 2) != 0)
			{
				SteamMatchmaking.OnLobbyMemberLeave?.Invoke(new Lobby(x.SteamIDLobby), new Friend(x.SteamIDUserChanged));
			}
			if ((x.GfChatMemberStateChange & 4) != 0)
			{
				SteamMatchmaking.OnLobbyMemberDisconnected?.Invoke(new Lobby(x.SteamIDLobby), new Friend(x.SteamIDUserChanged));
			}
			if ((x.GfChatMemberStateChange & 8) != 0)
			{
				SteamMatchmaking.OnLobbyMemberKicked?.Invoke(new Lobby(x.SteamIDLobby), new Friend(x.SteamIDUserChanged), new Friend(x.SteamIDMakingChange));
			}
			if ((x.GfChatMemberStateChange & 0x10) != 0)
			{
				SteamMatchmaking.OnLobbyMemberBanned?.Invoke(new Lobby(x.SteamIDLobby), new Friend(x.SteamIDUserChanged), new Friend(x.SteamIDMakingChange));
			}
		});
		Dispatch.Install<LobbyChatMsg_t>(OnLobbyChatMessageRecievedAPI);
	}

	private static void OnLobbyChatMessageRecievedAPI(LobbyChatMsg_t callback)
	{
		SteamId pSteamIDUser = default(SteamId);
		ChatEntryType peChatEntryType = ChatEntryType.Invalid;
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			if (Internal.GetLobbyChatEntry(callback.SteamIDLobby, (int)callback.ChatID, ref pSteamIDUser, m, 32768, ref peChatEntryType) > 0)
			{
				SteamMatchmaking.OnChatMessage?.Invoke(new Lobby(callback.SteamIDLobby), new Friend(pSteamIDUser), Helpers.MemoryToString(m));
			}
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public static async Task<Lobby?> CreateLobbyAsync(int maxMembers = 100)
	{
		LobbyCreated_t? lobbyCreated_t = await Internal.CreateLobby(LobbyType.Invisible, maxMembers);
		if (!lobbyCreated_t.HasValue || lobbyCreated_t.Value.Result != Result.OK)
		{
			return null;
		}
		Lobby value = default(Lobby);
		value.Id = lobbyCreated_t.Value.SteamIDLobby;
		return value;
	}

	public static async Task<Lobby?> JoinLobbyAsync(SteamId lobbyId)
	{
		LobbyEnter_t? lobbyEnter_t = await Internal.JoinLobby(lobbyId);
		if (!lobbyEnter_t.HasValue)
		{
			return null;
		}
		Lobby value = default(Lobby);
		value.Id = lobbyEnter_t.Value.SteamIDLobby;
		return value;
	}

	[IteratorStateMachine(typeof(<GetFavoriteServers>d__47))]
	public static IEnumerable<ServerInfo> GetFavoriteServers()
	{
		//yield-return decompiler failed: Unexpected instruction in Iterator.Dispose()
		return new <GetFavoriteServers>d__47(-2);
	}

	[IteratorStateMachine(typeof(<GetHistoryServers>d__48))]
	public static IEnumerable<ServerInfo> GetHistoryServers()
	{
		//yield-return decompiler failed: Unexpected instruction in Iterator.Dispose()
		return new <GetHistoryServers>d__48(-2);
	}
}


using System;
using Steamworks;

internal class SteamMatchmakingServers : SteamClientClass<SteamMatchmakingServers>
{
	internal static ISteamMatchmakingServers Internal => SteamClientClass<SteamMatchmakingServers>.Interface as ISteamMatchmakingServers;

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamMatchmakingServers(server));
		if (SteamClientClass<SteamMatchmakingServers>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		return true;
	}
}


using System;
using Steamworks;
using Steamworks.Data;

public class SteamMusic : SteamClientClass<SteamMusic>
{
	internal static ISteamMusic Internal => SteamClientClass<SteamMusic>.Interface as ISteamMusic;

	public static bool IsEnabled => Internal.BIsEnabled();

	public static bool IsPlaying => Internal.BIsPlaying();

	public static MusicStatus Status => Internal.GetPlaybackStatus();

	public static float Volume
	{
		get
		{
			return Internal.GetVolume();
		}
		set
		{
			Internal.SetVolume(value);
		}
	}

	public static event Action OnPlaybackChanged;

	public static event Action<float> OnVolumeChanged;

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamMusic(server));
		if (SteamClientClass<SteamMusic>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		InstallEvents();
		return true;
	}

	internal static void InstallEvents()
	{
		Dispatch.Install<PlaybackStatusHasChanged_t>(delegate
		{
			SteamMusic.OnPlaybackChanged?.Invoke();
		});
		Dispatch.Install(delegate(VolumeHasChanged_t x)
		{
			SteamMusic.OnVolumeChanged?.Invoke(x.NewVolume);
		});
	}

	public static void Play()
	{
		Internal.Play();
	}

	public static void Pause()
	{
		Internal.Pause();
	}

	public static void PlayPrevious()
	{
		Internal.PlayPrevious();
	}

	public static void PlayNext()
	{
		Internal.PlayNext();
	}
}


using System;
using Steamworks;
using Steamworks.Data;

public class SteamNetworking : SteamSharedClass<SteamNetworking>
{
	public static Action<SteamId> OnP2PSessionRequest;

	public static Action<SteamId, P2PSessionError> OnP2PConnectionFailed;

	internal static ISteamNetworking Internal => SteamSharedClass<SteamNetworking>.Interface as ISteamNetworking;

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamNetworking(server));
		if (SteamSharedClass<SteamNetworking>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		InstallEvents(server);
		return true;
	}

	internal static void InstallEvents(bool server)
	{
		Dispatch.Install(delegate(P2PSessionRequest_t x)
		{
			OnP2PSessionRequest?.Invoke(x.SteamIDRemote);
		}, server);
		Dispatch.Install(delegate(P2PSessionConnectFail_t x)
		{
			OnP2PConnectionFailed?.Invoke(x.SteamIDRemote, (P2PSessionError)x.P2PSessionError);
		}, server);
	}

	public static bool AcceptP2PSessionWithUser(SteamId user)
	{
		return Internal.AcceptP2PSessionWithUser(user);
	}

	public static bool AllowP2PPacketRelay(bool allow)
	{
		return Internal.AllowP2PPacketRelay(allow);
	}

	public static bool CloseP2PSessionWithUser(SteamId user)
	{
		return Internal.CloseP2PSessionWithUser(user);
	}

	public static bool IsP2PPacketAvailable(int channel = 0)
	{
		uint pcubMsgSize = 0u;
		return Internal.IsP2PPacketAvailable(ref pcubMsgSize, channel);
	}

	public static bool IsP2PPacketAvailable(out uint msgSize, int channel = 0)
	{
		msgSize = 0u;
		return Internal.IsP2PPacketAvailable(ref msgSize, channel);
	}

	public unsafe static P2Packet? ReadP2PPacket(int channel = 0)
	{
		uint pcubMsgSize = 0u;
		if (!Internal.IsP2PPacketAvailable(ref pcubMsgSize, channel))
		{
			return null;
		}
		byte[] array = Helpers.TakeBuffer((int)pcubMsgSize);
		fixed (byte* ptr = array)
		{
			SteamId psteamIDRemote = 1uL;
			if (!Internal.ReadP2PPacket((IntPtr)ptr, (uint)array.Length, ref pcubMsgSize, ref psteamIDRemote, channel) || pcubMsgSize == 0)
			{
				return null;
			}
			byte[] array2 = new byte[pcubMsgSize];
			Array.Copy(array, 0L, array2, 0L, pcubMsgSize);
			P2Packet value = default(P2Packet);
			value.SteamId = psteamIDRemote;
			value.Data = array2;
			return value;
		}
	}

	public unsafe static bool ReadP2PPacket(byte[] buffer, ref uint size, ref SteamId steamid, int channel = 0)
	{
		fixed (byte* ptr = buffer)
		{
			return Internal.ReadP2PPacket((IntPtr)ptr, (uint)buffer.Length, ref size, ref steamid, channel);
		}
	}

	public unsafe static bool ReadP2PPacket(byte* buffer, uint cbuf, ref uint size, ref SteamId steamid, int channel = 0)
	{
		return Internal.ReadP2PPacket((IntPtr)buffer, cbuf, ref size, ref steamid, channel);
	}

	public unsafe static bool SendP2PPacket(SteamId steamid, byte[] data, int length = -1, int nChannel = 0, P2PSend sendType = P2PSend.Reliable)
	{
		if (length <= 0)
		{
			length = data.Length;
		}
		fixed (byte* ptr = data)
		{
			return Internal.SendP2PPacket(steamid, (IntPtr)ptr, (uint)length, sendType, nChannel);
		}
	}

	public unsafe static bool SendP2PPacket(SteamId steamid, byte* data, uint length, int nChannel = 1, P2PSend sendType = P2PSend.Reliable)
	{
		return Internal.SendP2PPacket(steamid, (IntPtr)data, length, sendType, nChannel);
	}
}


using System;
using System.Collections.Generic;
using Steamworks;
using Steamworks.Data;

public class SteamNetworkingSockets : SteamSharedClass<SteamNetworkingSockets>
{
	private static readonly Dictionary<uint, SocketManager> SocketInterfaces = new Dictionary<uint, SocketManager>();

	private static readonly Dictionary<uint, ConnectionManager> ConnectionInterfaces = new Dictionary<uint, ConnectionManager>();

	internal static ISteamNetworkingSockets Internal => SteamSharedClass<SteamNetworkingSockets>.Interface as ISteamNetworkingSockets;

	public static NetIdentity Identity
	{
		get
		{
			NetIdentity pIdentity = default(NetIdentity);
			Internal.GetIdentity(ref pIdentity);
			return pIdentity;
		}
	}

	public static event Action<Connection, ConnectionInfo> OnConnectionStatusChanged;

	public static event Action<NetAddress> OnFakeIPResult;

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamNetworkingSockets(server));
		if (SteamSharedClass<SteamNetworkingSockets>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		InstallEvents(server);
		return true;
	}

	internal static SocketManager GetSocketManager(uint id)
	{
		if (SocketInterfaces == null)
		{
			return null;
		}
		if (id == 0)
		{
			throw new ArgumentException("Invalid Socket");
		}
		if (SocketInterfaces.TryGetValue(id, out var value))
		{
			return value;
		}
		return null;
	}

	internal static void SetSocketManager(uint id, SocketManager manager)
	{
		if (id == 0)
		{
			throw new ArgumentException("Invalid Socket");
		}
		SocketInterfaces[id] = manager;
	}

	internal static ConnectionManager GetConnectionManager(uint id)
	{
		if (ConnectionInterfaces == null)
		{
			return null;
		}
		if (id == 0)
		{
			return null;
		}
		if (ConnectionInterfaces.TryGetValue(id, out var value))
		{
			return value;
		}
		return null;
	}

	internal static void SetConnectionManager(uint id, ConnectionManager manager)
	{
		if (id == 0)
		{
			throw new ArgumentException("Invalid Connection");
		}
		ConnectionInterfaces[id] = manager;
	}

	internal void InstallEvents(bool server)
	{
		Dispatch.Install<SteamNetConnectionStatusChangedCallback_t>(ConnectionStatusChanged, server);
		Dispatch.Install<SteamNetworkingFakeIPResult_t>(FakeIPResult, server);
	}

	private static void ConnectionStatusChanged(SteamNetConnectionStatusChangedCallback_t data)
	{
		if (data.Nfo.listenSocket.Id != 0)
		{
			GetSocketManager(data.Nfo.listenSocket.Id)?.OnConnectionChanged(data.Conn, data.Nfo);
		}
		else
		{
			GetConnectionManager(data.Conn.Id)?.OnConnectionChanged(data.Nfo);
		}
		SteamNetworkingSockets.OnConnectionStatusChanged?.Invoke(data.Conn, data.Nfo);
	}

	private static void FakeIPResult(SteamNetworkingFakeIPResult_t data)
	{
		ushort[] ports = data.Ports;
		foreach (ushort num in ports)
		{
			if (num != 0)
			{
				NetAddress obj = NetAddress.From(Utility.Int32ToIp(data.IP), num);
				SteamNetworkingSockets.OnFakeIPResult?.Invoke(obj);
			}
		}
	}

	public static T CreateNormalSocket<T>(NetAddress address) where T : SocketManager, new()
	{
		T val = new T();
		NetKeyValue[] array = Array.Empty<NetKeyValue>();
		val.Socket = Internal.CreateListenSocketIP(ref address, array.Length, array);
		val.Initialize();
		SetSocketManager(val.Socket.Id, val);
		return val;
	}

	public static SocketManager CreateNormalSocket(NetAddress address, ISocketManager intrface)
	{
		NetKeyValue[] array = Array.Empty<NetKeyValue>();
		Socket socket = Internal.CreateListenSocketIP(ref address, array.Length, array);
		SocketManager socketManager = new SocketManager
		{
			Socket = socket,
			Interface = intrface
		};
		socketManager.Initialize();
		SetSocketManager(socketManager.Socket.Id, socketManager);
		return socketManager;
	}

	public static T ConnectNormal<T>(NetAddress address) where T : ConnectionManager, new()
	{
		T val = new T();
		NetKeyValue[] array = Array.Empty<NetKeyValue>();
		val.Connection = Internal.ConnectByIPAddress(ref address, array.Length, array);
		SetConnectionManager(val.Connection.Id, val);
		return val;
	}

	public static ConnectionManager ConnectNormal(NetAddress address, IConnectionManager iface)
	{
		NetKeyValue[] array = Array.Empty<NetKeyValue>();
		Connection connection = Internal.ConnectByIPAddress(ref address, array.Length, array);
		ConnectionManager connectionManager = new ConnectionManager
		{
			Connection = connection,
			Interface = iface
		};
		SetConnectionManager(connectionManager.Connection.Id, connectionManager);
		return connectionManager;
	}

	public static T CreateRelaySocket<T>(int virtualport = 0) where T : SocketManager, new()
	{
		T val = new T();
		NetKeyValue[] array = Array.Empty<NetKeyValue>();
		val.Socket = Internal.CreateListenSocketP2P(virtualport, array.Length, array);
		val.Initialize();
		SetSocketManager(val.Socket.Id, val);
		return val;
	}

	public static SocketManager CreateRelaySocket(int virtualport, ISocketManager intrface)
	{
		NetKeyValue[] array = Array.Empty<NetKeyValue>();
		Socket socket = Internal.CreateListenSocketP2P(virtualport, array.Length, array);
		SocketManager socketManager = new SocketManager
		{
			Socket = socket,
			Interface = intrface
		};
		socketManager.Initialize();
		SetSocketManager(socketManager.Socket.Id, socketManager);
		return socketManager;
	}

	public static T ConnectRelay<T>(SteamId serverId, int virtualport = 0) where T : ConnectionManager, new()
	{
		T val = new T();
		NetIdentity identityRemote = serverId;
		NetKeyValue[] array = Array.Empty<NetKeyValue>();
		val.Connection = Internal.ConnectP2P(ref identityRemote, virtualport, array.Length, array);
		SetConnectionManager(val.Connection.Id, val);
		return val;
	}

	public static ConnectionManager ConnectRelay(SteamId serverId, int virtualport, IConnectionManager iface)
	{
		NetIdentity identityRemote = serverId;
		NetKeyValue[] array = Array.Empty<NetKeyValue>();
		Connection connection = Internal.ConnectP2P(ref identityRemote, virtualport, array.Length, array);
		ConnectionManager connectionManager = new ConnectionManager
		{
			Connection = connection,
			Interface = iface
		};
		SetConnectionManager(connectionManager.Connection.Id, connectionManager);
		return connectionManager;
	}

	public static bool RequestFakeIP(int numFakePorts = 1)
	{
		return Internal.BeginAsyncRequestFakeIP(numFakePorts);
	}

	public static Result GetFakeIP(int fakePortIndex, out NetAddress address)
	{
		SteamNetworkingFakeIPResult_t pInfo = default(SteamNetworkingFakeIPResult_t);
		Internal.GetFakeIP(0, ref pInfo);
		address = NetAddress.From(Utility.Int32ToIp(pInfo.IP), pInfo.Ports[fakePortIndex]);
		return pInfo.Result;
	}

	public static T CreateRelaySocketFakeIP<T>(int fakePortIndex = 0) where T : SocketManager, new()
	{
		T val = new T();
		NetKeyValue[] array = Array.Empty<NetKeyValue>();
		val.Socket = Internal.CreateListenSocketP2PFakeIP(0, array.Length, array);
		val.Initialize();
		SetSocketManager(val.Socket.Id, val);
		return val;
	}

	public static SocketManager CreateRelaySocketFakeIP(int fakePortIndex, ISocketManager intrface)
	{
		NetKeyValue[] array = Array.Empty<NetKeyValue>();
		Socket socket = Internal.CreateListenSocketP2PFakeIP(0, array.Length, array);
		SocketManager socketManager = new SocketManager
		{
			Socket = socket,
			Interface = intrface
		};
		socketManager.Initialize();
		SetSocketManager(socketManager.Socket.Id, socketManager);
		return socketManager;
	}
}


using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;

public class SteamNetworkingUtils : SteamSharedClass<SteamNetworkingUtils>
{
	private struct DebugMessage
	{
		public NetDebugOutput Type;

		public string Msg;
	}

	private static NetDebugOutput _debugLevel;

	private static NetDebugFunc _debugFunc;

	private static ConcurrentQueue<DebugMessage> debugMessages = new ConcurrentQueue<DebugMessage>();

	internal static ISteamNetworkingUtils Internal => SteamSharedClass<SteamNetworkingUtils>.Interface as ISteamNetworkingUtils;

	public static SteamNetworkingAvailability Status { get; private set; }

	public static NetPingLocation? LocalPingLocation
	{
		get
		{
			NetPingLocation result = default(NetPingLocation);
			if (Internal.GetLocalPingLocation(ref result) < 0f)
			{
				return null;
			}
			return result;
		}
	}

	public static long LocalTimestamp => Internal.GetLocalTimestamp();

	public static float FakeSendPacketLoss
	{
		get
		{
			return GetConfigFloat(NetConfig.FakePacketLoss_Send);
		}
		set
		{
			SetConfigFloat(NetConfig.FakePacketLoss_Send, value);
		}
	}

	public static float FakeRecvPacketLoss
	{
		get
		{
			return GetConfigFloat(NetConfig.FakePacketLoss_Recv);
		}
		set
		{
			SetConfigFloat(NetConfig.FakePacketLoss_Recv, value);
		}
	}

	public static float FakeSendPacketLag
	{
		get
		{
			return GetConfigFloat(NetConfig.FakePacketLag_Send);
		}
		set
		{
			SetConfigFloat(NetConfig.FakePacketLag_Send, value);
		}
	}

	public static float FakeRecvPacketLag
	{
		get
		{
			return GetConfigFloat(NetConfig.FakePacketLag_Recv);
		}
		set
		{
			SetConfigFloat(NetConfig.FakePacketLag_Recv, value);
		}
	}

	public static int ConnectionTimeout
	{
		get
		{
			return GetConfigInt(NetConfig.TimeoutInitial);
		}
		set
		{
			SetConfigInt(NetConfig.TimeoutInitial, value);
		}
	}

	public static int Timeout
	{
		get
		{
			return GetConfigInt(NetConfig.TimeoutConnected);
		}
		set
		{
			SetConfigInt(NetConfig.TimeoutConnected, value);
		}
	}

	public static int SendBufferSize
	{
		get
		{
			return GetConfigInt(NetConfig.SendBufferSize);
		}
		set
		{
			SetConfigInt(NetConfig.SendBufferSize, value);
		}
	}

	public static int SendRateMin
	{
		get
		{
			return GetConfigInt(NetConfig.SendRateMin);
		}
		set
		{
			SetConfigInt(NetConfig.SendRateMin, value);
		}
	}

	public static int SendRateMax
	{
		get
		{
			return GetConfigInt(NetConfig.SendRateMax);
		}
		set
		{
			SetConfigInt(NetConfig.SendRateMax, value);
		}
	}

	public static int NagleTime
	{
		get
		{
			return GetConfigInt(NetConfig.NagleTime);
		}
		set
		{
			SetConfigInt(NetConfig.NagleTime, value);
		}
	}

	public static int AllowWithoutAuth
	{
		get
		{
			return GetConfigInt(NetConfig.IP_AllowWithoutAuth);
		}
		set
		{
			SetConfigInt(NetConfig.IP_AllowWithoutAuth, value);
		}
	}

	public static int Unencrypted
	{
		get
		{
			return GetConfigInt(NetConfig.Unencrypted);
		}
		set
		{
			SetConfigInt(NetConfig.Unencrypted, value);
		}
	}

	public static int DebugLevelAckRTT
	{
		get
		{
			return GetConfigInt(NetConfig.LogLevel_AckRTT);
		}
		set
		{
			SetConfigInt(NetConfig.LogLevel_AckRTT, value);
		}
	}

	public static int DebugLevelPacketDecode
	{
		get
		{
			return GetConfigInt(NetConfig.LogLevel_PacketDecode);
		}
		set
		{
			SetConfigInt(NetConfig.LogLevel_PacketDecode, value);
		}
	}

	public static int DebugLevelMessage
	{
		get
		{
			return GetConfigInt(NetConfig.LogLevel_Message);
		}
		set
		{
			SetConfigInt(NetConfig.LogLevel_Message, value);
		}
	}

	public static int DebugLevelPacketGaps
	{
		get
		{
			return GetConfigInt(NetConfig.LogLevel_PacketGaps);
		}
		set
		{
			SetConfigInt(NetConfig.LogLevel_PacketGaps, value);
		}
	}

	public static int DebugLevelP2PRendezvous
	{
		get
		{
			return GetConfigInt(NetConfig.LogLevel_P2PRendezvous);
		}
		set
		{
			SetConfigInt(NetConfig.LogLevel_P2PRendezvous, value);
		}
	}

	public static int DebugLevelSDRRelayPings
	{
		get
		{
			return GetConfigInt(NetConfig.LogLevel_SDRRelayPings);
		}
		set
		{
			SetConfigInt(NetConfig.LogLevel_SDRRelayPings, value);
		}
	}

	public static NetDebugOutput DebugLevel
	{
		get
		{
			return _debugLevel;
		}
		set
		{
			_debugLevel = value;
			_debugFunc = OnDebugMessage;
			Internal.SetDebugOutputFunction(value, _debugFunc);
		}
	}

	public static event Action<NetDebugOutput, string> OnDebugOutput;

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamNetworkingUtils(server));
		if (SteamSharedClass<SteamNetworkingUtils>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		InstallCallbacks(server);
		return true;
	}

	private static void InstallCallbacks(bool server)
	{
		Dispatch.Install(delegate(SteamRelayNetworkStatus_t x)
		{
			Status = x.Avail;
		}, server);
	}

	public static void InitRelayNetworkAccess()
	{
		Internal.InitRelayNetworkAccess();
	}

	public static int EstimatePingTo(NetPingLocation target)
	{
		return Internal.EstimatePingTimeFromLocalHost(ref target);
	}

	public static async Task WaitForPingDataAsync(float maxAgeInSeconds = 300f)
	{
		if (!Internal.CheckPingDataUpToDate(maxAgeInSeconds))
		{
			SteamRelayNetworkStatus_t status = default(SteamRelayNetworkStatus_t);
			while (Internal.GetRelayNetworkStatus(ref status) != SteamNetworkingAvailability.Current)
			{
				await Task.Delay(10);
			}
		}
	}

	[MonoPInvokeCallback]
	private static void OnDebugMessage(NetDebugOutput nType, IntPtr str)
	{
		debugMessages.Enqueue(new DebugMessage
		{
			Type = nType,
			Msg = Helpers.MemoryToString(str)
		});
	}

	internal static void LogDebugMessage(NetDebugOutput type, string message)
	{
		debugMessages.Enqueue(new DebugMessage
		{
			Type = type,
			Msg = message
		});
	}

	internal static void OutputDebugMessages()
	{
		if (!debugMessages.IsEmpty)
		{
			DebugMessage result;
			while (debugMessages.TryDequeue(out result))
			{
				SteamNetworkingUtils.OnDebugOutput?.Invoke(result.Type, result.Msg);
			}
		}
	}

	internal unsafe static NetMsg* AllocateMessage()
	{
		return Internal.AllocateMessage(0);
	}

	internal unsafe static bool SetConfigInt(NetConfig type, int value)
	{
		int* ptr = &value;
		return Internal.SetConfigValue(type, NetConfigScope.Global, IntPtr.Zero, NetConfigType.Int32, (IntPtr)ptr);
	}

	internal unsafe static int GetConfigInt(NetConfig type)
	{
		int result = 0;
		NetConfigType pOutDataType = NetConfigType.Int32;
		int* ptr = &result;
		UIntPtr cbResult = new UIntPtr(4u);
		if (Internal.GetConfigValue(type, NetConfigScope.Global, IntPtr.Zero, ref pOutDataType, (IntPtr)ptr, ref cbResult) != NetConfigResult.OK)
		{
			return 0;
		}
		return result;
	}

	internal unsafe static bool SetConfigFloat(NetConfig type, float value)
	{
		float* ptr = &value;
		return Internal.SetConfigValue(type, NetConfigScope.Global, IntPtr.Zero, NetConfigType.Float, (IntPtr)ptr);
	}

	internal unsafe static float GetConfigFloat(NetConfig type)
	{
		float result = 0f;
		NetConfigType pOutDataType = NetConfigType.Float;
		float* ptr = &result;
		UIntPtr cbResult = new UIntPtr(4u);
		if (Internal.GetConfigValue(type, NetConfigScope.Global, IntPtr.Zero, ref pOutDataType, (IntPtr)ptr, ref cbResult) != NetConfigResult.OK)
		{
			return 0f;
		}
		return result;
	}

	internal unsafe static bool SetConfigString(NetConfig type, string value)
	{
		fixed (byte* bytes = Utility.Utf8NoBom.GetBytes(value))
		{
			return Internal.SetConfigValue(type, NetConfigScope.Global, IntPtr.Zero, NetConfigType.String, (IntPtr)bytes);
		}
	}
}


using System;
using Steamworks;
using Steamworks.Data;

public class SteamParental : SteamSharedClass<SteamParental>
{
	internal static ISteamParentalSettings Internal => SteamSharedClass<SteamParental>.Interface as ISteamParentalSettings;

	public static bool IsParentalLockEnabled => Internal.BIsParentalLockEnabled();

	public static bool IsParentalLockLocked => Internal.BIsParentalLockLocked();

	public static event Action OnSettingsChanged;

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamParentalSettings(server));
		if (SteamSharedClass<SteamParental>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		InstallEvents(server);
		return true;
	}

	internal static void InstallEvents(bool server)
	{
		Dispatch.Install<SteamParentalSettingsChanged_t>(delegate
		{
			SteamParental.OnSettingsChanged?.Invoke();
		}, server);
	}

	public static bool IsAppBlocked(AppId app)
	{
		return Internal.BIsAppBlocked(app.Value);
	}

	public static bool BIsAppInBlockList(AppId app)
	{
		return Internal.BIsAppInBlockList(app.Value);
	}

	public static bool IsFeatureBlocked(ParentalFeature feature)
	{
		return Internal.BIsFeatureBlocked(feature);
	}

	public static bool BIsFeatureInBlockList(ParentalFeature feature)
	{
		return Internal.BIsFeatureInBlockList(feature);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using Steamworks;
using Steamworks.Data;

public class SteamParties : SteamClientClass<SteamParties>
{
	[CompilerGenerated]
	private sealed class <get_ActiveBeacons>d__13 : IEnumerable<PartyBeacon>, IEnumerable, IEnumerator<PartyBeacon>, IDisposable, IEnumerator
	{
		private int <>1__state;

		private PartyBeacon <>2__current;

		private int <>l__initialThreadId;

		private uint <i>5__2;

		PartyBeacon IEnumerator<PartyBeacon>.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		object IEnumerator.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		[DebuggerHidden]
		public <get_ActiveBeacons>d__13(int <>1__state)
		{
			this.<>1__state = <>1__state;
			<>l__initialThreadId = Environment.CurrentManagedThreadId;
		}

		[DebuggerHidden]
		void IDisposable.Dispose()
		{
			<>1__state = -2;
		}

		private bool MoveNext()
		{
			switch (<>1__state)
			{
			default:
				return false;
			case 0:
				<>1__state = -1;
				<i>5__2 = 0u;
				break;
			case 1:
				<>1__state = -1;
				<i>5__2++;
				break;
			}
			if (<i>5__2 < ActiveBeaconCount)
			{
				<>2__current = new PartyBeacon
				{
					Id = Internal.GetBeaconByIndex(<i>5__2)
				};
				<>1__state = 1;
				return true;
			}
			return false;
		}

		bool IEnumerator.MoveNext()
		{
			//ILSpy generated this explicit interface implementation from .override directive in MoveNext
			return this.MoveNext();
		}

		[DebuggerHidden]
		void IEnumerator.Reset()
		{
			throw new NotSupportedException();
		}

		[DebuggerHidden]
		IEnumerator<PartyBeacon> IEnumerable<PartyBeacon>.GetEnumerator()
		{
			if (<>1__state == -2 && <>l__initialThreadId == Environment.CurrentManagedThreadId)
			{
				<>1__state = 0;
				return this;
			}
			return new <get_ActiveBeacons>d__13(0);
		}

		[DebuggerHidden]
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<PartyBeacon>)this).GetEnumerator();
		}
	}

	internal static ISteamParties Internal => SteamClientClass<SteamParties>.Interface as ISteamParties;

	public static int ActiveBeaconCount => (int)Internal.GetNumActiveBeacons();

	public static IEnumerable<PartyBeacon> ActiveBeacons
	{
		[IteratorStateMachine(typeof(<get_ActiveBeacons>d__13))]
		get
		{
			//yield-return decompiler failed: Unexpected instruction in Iterator.Dispose()
			return new <get_ActiveBeacons>d__13(-2);
		}
	}

	public static event Action OnBeaconLocationsUpdated;

	public static event Action OnActiveBeaconsUpdated;

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamParties(server));
		if (SteamClientClass<SteamParties>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		InstallEvents(server);
		return true;
	}

	internal void InstallEvents(bool server)
	{
		Dispatch.Install<AvailableBeaconLocationsUpdated_t>(delegate
		{
			SteamParties.OnBeaconLocationsUpdated?.Invoke();
		}, server);
		Dispatch.Install<ActiveBeaconsUpdated_t>(delegate
		{
			SteamParties.OnActiveBeaconsUpdated?.Invoke();
		}, server);
	}
}


using System;
using Steamworks;
using Steamworks.Data;

public class SteamRemotePlay : SteamClientClass<SteamRemotePlay>
{
	internal static ISteamRemotePlay Internal => SteamClientClass<SteamRemotePlay>.Interface as ISteamRemotePlay;

	public static int SessionCount => (int)Internal.GetSessionCount();

	public static event Action<RemotePlaySession> OnSessionConnected;

	public static event Action<RemotePlaySession> OnSessionDisconnected;

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamRemotePlay(server));
		if (SteamClientClass<SteamRemotePlay>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		InstallEvents(server);
		return true;
	}

	internal void InstallEvents(bool server)
	{
		Dispatch.Install(delegate(SteamRemotePlaySessionConnected_t x)
		{
			SteamRemotePlay.OnSessionConnected?.Invoke(x.SessionID);
		}, server);
		Dispatch.Install(delegate(SteamRemotePlaySessionDisconnected_t x)
		{
			SteamRemotePlay.OnSessionDisconnected?.Invoke(x.SessionID);
		}, server);
	}

	public static RemotePlaySession GetSession(int index)
	{
		return Internal.GetSessionID(index).Value;
	}

	public static bool SendInvite(SteamId steamid)
	{
		return Internal.BSendRemotePlayTogetherInvite(steamid);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using Steamworks;

public class SteamRemoteStorage : SteamClientClass<SteamRemoteStorage>
{
	[CompilerGenerated]
	private sealed class <get_Files>d__27 : IEnumerable<string>, IEnumerable, IEnumerator<string>, IDisposable, IEnumerator
	{
		private int <>1__state;

		private string <>2__current;

		private int <>l__initialThreadId;

		private int <_>5__2;

		private int <i>5__3;

		string IEnumerator<string>.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		object IEnumerator.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		[DebuggerHidden]
		public <get_Files>d__27(int <>1__state)
		{
			this.<>1__state = <>1__state;
			<>l__initialThreadId = Environment.CurrentManagedThreadId;
		}

		[DebuggerHidden]
		void IDisposable.Dispose()
		{
			<>1__state = -2;
		}

		private bool MoveNext()
		{
			switch (<>1__state)
			{
			default:
				return false;
			case 0:
				<>1__state = -1;
				<_>5__2 = 0;
				<i>5__3 = 0;
				break;
			case 1:
				<>1__state = -1;
				<i>5__3++;
				break;
			}
			if (<i>5__3 < FileCount)
			{
				string fileNameAndSize = Internal.GetFileNameAndSize(<i>5__3, ref <_>5__2);
				<>2__current = fileNameAndSize;
				<>1__state = 1;
				return true;
			}
			return false;
		}

		bool IEnumerator.MoveNext()
		{
			//ILSpy generated this explicit interface implementation from .override directive in MoveNext
			return this.MoveNext();
		}

		[DebuggerHidden]
		void IEnumerator.Reset()
		{
			throw new NotSupportedException();
		}

		[DebuggerHidden]
		IEnumerator<string> IEnumerable<string>.GetEnumerator()
		{
			if (<>1__state == -2 && <>l__initialThreadId == Environment.CurrentManagedThreadId)
			{
				<>1__state = 0;
				return this;
			}
			return new <get_Files>d__27(0);
		}

		[DebuggerHidden]
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<string>)this).GetEnumerator();
		}
	}

	internal static ISteamRemoteStorage Internal => SteamClientClass<SteamRemoteStorage>.Interface as ISteamRemoteStorage;

	public static ulong QuotaBytes
	{
		get
		{
			ulong pnTotalBytes = 0uL;
			ulong puAvailableBytes = 0uL;
			Internal.GetQuota(ref pnTotalBytes, ref puAvailableBytes);
			return pnTotalBytes;
		}
	}

	public static ulong QuotaUsedBytes
	{
		get
		{
			ulong pnTotalBytes = 0uL;
			ulong puAvailableBytes = 0uL;
			Internal.GetQuota(ref pnTotalBytes, ref puAvailableBytes);
			return pnTotalBytes - puAvailableBytes;
		}
	}

	public static ulong QuotaRemainingBytes
	{
		get
		{
			ulong pnTotalBytes = 0uL;
			ulong puAvailableBytes = 0uL;
			Internal.GetQuota(ref pnTotalBytes, ref puAvailableBytes);
			return puAvailableBytes;
		}
	}

	public static bool IsCloudEnabled
	{
		get
		{
			if (IsCloudEnabledForAccount)
			{
				return IsCloudEnabledForApp;
			}
			return false;
		}
	}

	public static bool IsCloudEnabledForAccount => Internal.IsCloudEnabledForAccount();

	public static bool IsCloudEnabledForApp
	{
		get
		{
			return Internal.IsCloudEnabledForApp();
		}
		set
		{
			Internal.SetCloudEnabledForApp(value);
		}
	}

	public static int FileCount => Internal.GetFileCount();

	public static IEnumerable<string> Files
	{
		[IteratorStateMachine(typeof(<get_Files>d__27))]
		get
		{
			//yield-return decompiler failed: Unexpected instruction in Iterator.Dispose()
			return new <get_Files>d__27(-2);
		}
	}

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamRemoteStorage(server));
		if (SteamClientClass<SteamRemoteStorage>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		return true;
	}

	public unsafe static bool FileWrite(string filename, byte[] data)
	{
		fixed (byte* ptr = data)
		{
			return Internal.FileWrite(filename, (IntPtr)ptr, data.Length);
		}
	}

	public unsafe static byte[] FileRead(string filename)
	{
		int num = FileSize(filename);
		if (num <= 0)
		{
			return null;
		}
		byte[] array = new byte[num];
		fixed (byte* ptr = array)
		{
			if (Internal.FileRead(filename, (IntPtr)ptr, num) != num)
			{
				return null;
			}
			return array;
		}
	}

	public static bool FileExists(string filename)
	{
		return Internal.FileExists(filename);
	}

	public static bool FilePersisted(string filename)
	{
		return Internal.FilePersisted(filename);
	}

	public static DateTime FileTime(string filename)
	{
		return Epoch.ToDateTime(Internal.GetFileTimestamp(filename));
	}

	public static int FileSize(string filename)
	{
		return Internal.GetFileSize(filename);
	}

	public static bool FileForget(string filename)
	{
		return Internal.FileForget(filename);
	}

	public static bool FileDelete(string filename)
	{
		return Internal.FileDelete(filename);
	}
}


using System;
using Steamworks;
using Steamworks.Data;

public class SteamScreenshots : SteamClientClass<SteamScreenshots>
{
	internal static ISteamScreenshots Internal => SteamClientClass<SteamScreenshots>.Interface as ISteamScreenshots;

	public static bool Hooked
	{
		get
		{
			return Internal.IsScreenshotsHooked();
		}
		set
		{
			Internal.HookScreenshots(value);
		}
	}

	public static event Action OnScreenshotRequested;

	public static event Action<Screenshot> OnScreenshotReady;

	public static event Action<Result> OnScreenshotFailed;

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamScreenshots(server));
		if (SteamClientClass<SteamScreenshots>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		InstallEvents();
		return true;
	}

	internal static void InstallEvents()
	{
		Dispatch.Install<ScreenshotRequested_t>(delegate
		{
			SteamScreenshots.OnScreenshotRequested?.Invoke();
		});
		Dispatch.Install(delegate(ScreenshotReady_t x)
		{
			if (x.Result != Result.OK)
			{
				SteamScreenshots.OnScreenshotFailed?.Invoke(x.Result);
			}
			else
			{
				SteamScreenshots.OnScreenshotReady?.Invoke(new Screenshot
				{
					Value = x.Local
				});
			}
		});
	}

	public unsafe static Screenshot? WriteScreenshot(byte[] data, int width, int height)
	{
		fixed (byte* ptr = data)
		{
			ScreenshotHandle value = Internal.WriteScreenshot((IntPtr)ptr, (uint)data.Length, width, height);
			if (value.Value == 0)
			{
				return null;
			}
			Screenshot value2 = default(Screenshot);
			value2.Value = value;
			return value2;
		}
	}

	public static Screenshot? AddScreenshot(string filename, string thumbnail, int width, int height)
	{
		ScreenshotHandle value = Internal.AddScreenshotToLibrary(filename, thumbnail, width, height);
		if (value.Value == 0)
		{
			return null;
		}
		Screenshot value2 = default(Screenshot);
		value2.Value = value;
		return value2;
	}

	public static void TriggerScreenshot()
	{
		Internal.TriggerScreenshot();
	}
}


using System;
using System.Collections.Generic;
using System.Net;
using Steamworks;
using Steamworks.Data;

public class SteamServer : SteamServerClass<SteamServer>
{
	private static readonly List<SteamClass> openInterfaces = new List<SteamClass>();

	private static bool _dedicatedServer;

	private static int _maxplayers = 0;

	private static int _botcount = 0;

	private static string _mapname;

	private static string _modDir = "";

	private static string _product = "";

	private static string _gameDescription = "";

	private static string _serverName = "";

	private static bool _passworded;

	private static string _gametags = "";

	private static Dictionary<string, string> KeyValue = new Dictionary<string, string>();

	internal static ISteamGameServer Internal => SteamServerClass<SteamServer>.Interface as ISteamGameServer;

	public static bool IsValid
	{
		get
		{
			if (Internal != null)
			{
				return Internal.IsValid;
			}
			return false;
		}
	}

	public static bool DedicatedServer
	{
		get
		{
			return _dedicatedServer;
		}
		set
		{
			if (_dedicatedServer != value)
			{
				Internal.SetDedicatedServer(value);
				_dedicatedServer = value;
			}
		}
	}

	public static int MaxPlayers
	{
		get
		{
			return _maxplayers;
		}
		set
		{
			if (_maxplayers != value)
			{
				Internal.SetMaxPlayerCount(value);
				_maxplayers = value;
			}
		}
	}

	public static int BotCount
	{
		get
		{
			return _botcount;
		}
		set
		{
			if (_botcount != value)
			{
				Internal.SetBotPlayerCount(value);
				_botcount = value;
			}
		}
	}

	public static string MapName
	{
		get
		{
			return _mapname;
		}
		set
		{
			if (!(_mapname == value))
			{
				Internal.SetMapName(value);
				_mapname = value;
			}
		}
	}

	public static string ModDir
	{
		get
		{
			return _modDir;
		}
		internal set
		{
			if (!(_modDir == value))
			{
				Internal.SetModDir(value);
				_modDir = value;
			}
		}
	}

	public static string Product
	{
		get
		{
			return _product;
		}
		internal set
		{
			if (!(_product == value))
			{
				Internal.SetProduct(value);
				_product = value;
			}
		}
	}

	public static string GameDescription
	{
		get
		{
			return _gameDescription;
		}
		internal set
		{
			if (!(_gameDescription == value))
			{
				Internal.SetGameDescription(value);
				_gameDescription = value;
			}
		}
	}

	public static string ServerName
	{
		get
		{
			return _serverName;
		}
		set
		{
			if (!(_serverName == value))
			{
				Internal.SetServerName(value);
				_serverName = value;
			}
		}
	}

	public static bool Passworded
	{
		get
		{
			return _passworded;
		}
		set
		{
			if (_passworded != value)
			{
				Internal.SetPasswordProtected(value);
				_passworded = value;
			}
		}
	}

	public static string GameTags
	{
		get
		{
			return _gametags;
		}
		set
		{
			if (!(_gametags == value))
			{
				Internal.SetGameTags(value);
				_gametags = value;
			}
		}
	}

	public static SteamId SteamId => Internal.GetSteamID();

	public static bool LoggedOn => Internal.BLoggedOn();

	public static IPAddress PublicIp => Internal.GetPublicIP();

	[Obsolete("Renamed to AdvertiseServer in 1.52")]
	public static bool AutomaticHeartbeats
	{
		set
		{
			Internal.SetAdvertiseServerActive(value);
		}
	}

	public static bool AdvertiseServer
	{
		set
		{
			Internal.SetAdvertiseServerActive(value);
		}
	}

	public static event Action<SteamId, SteamId, AuthResponse> OnValidateAuthTicketResponse;

	public static event Action OnSteamServersConnected;

	public static event Action<Result, bool> OnSteamServerConnectFailure;

	public static event Action<Result> OnSteamServersDisconnected;

	public static event Action<SteamNetworkingAvailability> OnSteamNetAuthenticationStatus;

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamGameServer(server));
		if (SteamServerClass<SteamServer>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		InstallEvents();
		return true;
	}

	internal static void InstallEvents()
	{
		Dispatch.Install(delegate(ValidateAuthTicketResponse_t x)
		{
			SteamServer.OnValidateAuthTicketResponse?.Invoke(x.SteamID, x.OwnerSteamID, x.AuthSessionResponse);
		}, server: true);
		Dispatch.Install<SteamServersConnected_t>(delegate
		{
			SteamServer.OnSteamServersConnected?.Invoke();
		}, server: true);
		Dispatch.Install(delegate(SteamServerConnectFailure_t x)
		{
			SteamServer.OnSteamServerConnectFailure?.Invoke(x.Result, x.StillRetrying);
		}, server: true);
		Dispatch.Install(delegate(SteamServersDisconnected_t x)
		{
			SteamServer.OnSteamServersDisconnected?.Invoke(x.Result);
		}, server: true);
		Dispatch.Install(delegate(SteamNetAuthenticationStatus_t x)
		{
			SteamServer.OnSteamNetAuthenticationStatus?.Invoke(x.Avail);
		}, server: true);
	}

	public static void Init(AppId appid, SteamServerInit init, bool asyncCallbacks = true)
	{
		if (IsValid)
		{
			throw new Exception("Calling SteamServer.Init but is already initialized");
		}
		uint num = 0u;
		if (init.IpAddress != null)
		{
			num = init.IpAddress.IpToInt32();
		}
		Environment.SetEnvironmentVariable("SteamAppId", appid.ToString());
		Environment.SetEnvironmentVariable("SteamGameId", appid.ToString());
		int num2 = (init.Secure ? 3 : 2);
		string pszInternalCheckInterfaceVersions = Helpers.BuildVersionString("SteamGameServer015", "SteamUtils010", "SteamNetworking006", "SteamGameServerStats001", "STEAMINVENTORY_INTERFACE_V003", "STEAMUGC_INTERFACE_VERSION020", "STEAMAPPS_INTERFACE_VERSION008", "SteamNetworkingUtils004", "SteamNetworkingSockets012");
		if (SteamInternal.GameServer_Init(num, init.GamePort, init.QueryPort, num2, init.VersionString, pszInternalCheckInterfaceVersions, out var pOutErrMsg) != 0)
		{
			throw new Exception($"InitGameServer({num},{init.GamePort},{init.QueryPort},{num2},\"{init.VersionString}\") returned false - error: {pOutErrMsg}");
		}
		Dispatch.Init();
		Dispatch.ServerPipe = SteamGameServer.GetHSteamPipe();
		AddInterface<SteamServer>();
		AddInterface<SteamUtils>();
		AddInterface<SteamNetworking>();
		AddInterface<SteamServerStats>();
		AddInterface<SteamInventory>();
		AddInterface<SteamUGC>();
		AddInterface<SteamApps>();
		AddInterface<SteamNetworkingUtils>();
		AddInterface<SteamNetworkingSockets>();
		AdvertiseServer = true;
		MaxPlayers = 32;
		BotCount = 0;
		Product = $"{appid.Value}";
		ModDir = init.ModDir;
		GameDescription = init.GameDescription;
		Passworded = false;
		DedicatedServer = init.DedicatedServer;
		if (asyncCallbacks)
		{
			Dispatch.LoopServerAsync();
		}
	}

	internal static void AddInterface<T>() where T : SteamClass, new()
	{
		T val = new T();
		val.InitializeInterface(server: true);
		openInterfaces.Add(val);
	}

	internal static void ShutdownInterfaces()
	{
		foreach (SteamClass openInterface in openInterfaces)
		{
			openInterface.DestroyInterface(server: true);
		}
		openInterfaces.Clear();
	}

	public static void Shutdown()
	{
		Dispatch.ShutdownServer();
		ShutdownInterfaces();
		SteamGameServer.Shutdown();
	}

	public static void RunCallbacks()
	{
		if (Dispatch.ServerPipe != 0)
		{
			Dispatch.Frame(Dispatch.ServerPipe);
		}
	}

	public static void LogOnAnonymous()
	{
		Internal.LogOnAnonymous();
		ForceHeartbeat();
	}

	public static void LogOff()
	{
		Internal.LogOff();
	}

	[Obsolete("No longer used")]
	public static void ForceHeartbeat()
	{
	}

	public static void UpdatePlayer(SteamId steamid, string name, int score)
	{
		Internal.BUpdateUserData(steamid, name, (uint)score);
	}

	public static void SetKey(string Key, string Value)
	{
		if (KeyValue.ContainsKey(Key))
		{
			if (KeyValue[Key] == Value)
			{
				return;
			}
			KeyValue[Key] = Value;
		}
		else
		{
			KeyValue.Add(Key, Value);
		}
		Internal.SetKeyValue(Key, Value);
	}

	public static void ClearKeys()
	{
		KeyValue.Clear();
		Internal.ClearAllKeyValues();
	}

	public unsafe static bool BeginAuthSession(byte[] data, SteamId steamid)
	{
		fixed (byte* ptr = data)
		{
			if (Internal.BeginAuthSession((IntPtr)ptr, data.Length, steamid) == BeginAuthResult.OK)
			{
				return true;
			}
			return false;
		}
	}

	public static void EndSession(SteamId steamid)
	{
		Internal.EndAuthSession(steamid);
	}

	public unsafe static bool GetOutgoingPacket(out OutgoingPacket packet)
	{
		byte[] array = Helpers.TakeBuffer(32768);
		packet = default(OutgoingPacket);
		fixed (byte* ptr = array)
		{
			uint pNetAdr = 0u;
			ushort pPort = 0;
			int nextOutgoingPacket = Internal.GetNextOutgoingPacket((IntPtr)ptr, array.Length, ref pNetAdr, ref pPort);
			if (nextOutgoingPacket == 0)
			{
				return false;
			}
			packet.Size = nextOutgoingPacket;
			packet.Data = array;
			packet.Address = pNetAdr;
			packet.Port = pPort;
			return true;
		}
	}

	public unsafe static void HandleIncomingPacket(byte[] data, int size, uint address, ushort port)
	{
		fixed (byte* ptr = data)
		{
			HandleIncomingPacket((IntPtr)ptr, size, address, port);
		}
	}

	public static void HandleIncomingPacket(IntPtr ptr, int size, uint address, ushort port)
	{
		Internal.HandleIncomingPacket(ptr, size, address, port);
	}

	public static UserHasLicenseForAppResult UserHasLicenseForApp(SteamId steamid, AppId appid)
	{
		return Internal.UserHasLicenseForApp(steamid, appid);
	}
}


using System;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;

public class SteamServerStats : SteamServerClass<SteamServerStats>
{
	internal static ISteamGameServerStats Internal => SteamServerClass<SteamServerStats>.Interface as ISteamGameServerStats;

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamGameServerStats(server));
		if (SteamServerClass<SteamServerStats>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		return true;
	}

	public static async Task<Result> RequestUserStatsAsync(SteamId steamid)
	{
		GSStatsReceived_t? gSStatsReceived_t = await Internal.RequestUserStats(steamid);
		if (!gSStatsReceived_t.HasValue)
		{
			return Result.Fail;
		}
		return gSStatsReceived_t.Value.Result;
	}

	public static bool SetInt(SteamId steamid, string name, int stat)
	{
		return Internal.SetUserStat(steamid, name, stat);
	}

	public static bool SetFloat(SteamId steamid, string name, float stat)
	{
		return Internal.SetUserStat(steamid, name, stat);
	}

	public static int GetInt(SteamId steamid, string name, int defaultValue = 0)
	{
		int pData = defaultValue;
		if (!Internal.GetUserStat(steamid, name, ref pData))
		{
			return defaultValue;
		}
		return pData;
	}

	public static float GetFloat(SteamId steamid, string name, float defaultValue = 0f)
	{
		float pData = defaultValue;
		if (!Internal.GetUserStat(steamid, name, ref pData))
		{
			return defaultValue;
		}
		return pData;
	}

	public static bool SetAchievement(SteamId steamid, string name)
	{
		return Internal.SetUserAchievement(steamid, name);
	}

	public static bool ClearAchievement(SteamId steamid, string name)
	{
		return Internal.ClearUserAchievement(steamid, name);
	}

	public static bool GetAchievement(SteamId steamid, string name)
	{
		bool pbAchieved = false;
		if (!Internal.GetUserAchievement(steamid, name, ref pbAchieved))
		{
			return false;
		}
		return pbAchieved;
	}

	public static async Task<Result> StoreUserStats(SteamId steamid)
	{
		GSStatsStored_t? gSStatsStored_t = await Internal.StoreUserStats(steamid);
		if (!gSStatsStored_t.HasValue)
		{
			return Result.Fail;
		}
		return gSStatsStored_t.Value.Result;
	}
}


using System;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;

public class SteamTimeline : SteamClientClass<SteamTimeline>
{
	internal static ISteamTimeline Internal => SteamClientClass<SteamTimeline>.Interface as ISteamTimeline;

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamTimeline(server));
		if (SteamClientClass<SteamTimeline>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		InstallEvents();
		return true;
	}

	internal static void InstallEvents()
	{
	}

	public static void SetTimelineTooltip(string description, float timeOffsetSeconds)
	{
		Internal.SetTimelineTooltip(description, timeOffsetSeconds);
	}

	public static void ClearTimelineTooltip(float timeOffsetSeconds)
	{
		Internal.ClearTimelineTooltip(timeOffsetSeconds);
	}

	public static TimelineEventHandle AddInstantaneousTimelineEvent(string title, string description, string icon, uint priority, float startOffsetSeconds, TimelineEventClipPriority possibleClip)
	{
		return Internal.AddInstantaneousTimelineEvent(title, description, icon, priority, startOffsetSeconds, possibleClip);
	}

	public static TimelineEventHandle AddRangeTimelineEvent(string title, string description, string icon, uint priority, float startOffsetSeconds, float durationSeconds, TimelineEventClipPriority possibleClip)
	{
		return Internal.AddRangeTimelineEvent(title, description, icon, priority, startOffsetSeconds, durationSeconds, possibleClip);
	}

	public static TimelineEventHandle StartRangeTimelineEvent(string title, string description, string icon, uint priority, float startOffsetSeconds, TimelineEventClipPriority possibleClip)
	{
		return Internal.StartRangeTimelineEvent(title, description, icon, priority, startOffsetSeconds, possibleClip);
	}

	public static void UpdateRangeTimelineEvent(TimelineEventHandle handle, string title, string description, string icon, uint priority, TimelineEventClipPriority possibleClip)
	{
		Internal.UpdateRangeTimelineEvent(handle, title, description, icon, priority, possibleClip);
	}

	public static void EndRangeTimelineEvent(TimelineEventHandle handle, float endOffsetSeconds)
	{
		Internal.EndRangeTimelineEvent(handle, endOffsetSeconds);
	}

	public static void RemoveTimelineEvent(TimelineEventHandle handle)
	{
		Internal.RemoveTimelineEvent(handle);
	}

	public static async Task<bool> DoesEventRecordingExist(TimelineEventHandle handle)
	{
		return (await Internal.DoesEventRecordingExist(handle))?.RecordingExists ?? false;
	}

	public static void StartGamePhase()
	{
		Internal.StartGamePhase();
	}

	public static void EndGamePhase()
	{
		Internal.EndGamePhase();
	}

	public static void SetGamePhaseId(string phaseId)
	{
		Internal.SetGamePhaseID(phaseId);
	}

	public static async Task<GamePhaseRecordingInfo?> DoesGamePhaseRecordingExist(string phaseId)
	{
		SteamTimelineGamePhaseRecordingExists_t? steamTimelineGamePhaseRecordingExists_t = await Internal.DoesGamePhaseRecordingExist(phaseId);
		if (!steamTimelineGamePhaseRecordingExists_t.HasValue)
		{
			return null;
		}
		SteamTimelineGamePhaseRecordingExists_t value = steamTimelineGamePhaseRecordingExists_t.Value;
		GamePhaseRecordingInfo value2 = default(GamePhaseRecordingInfo);
		value2.PhaseId = value.PhaseIDUTF8();
		value2.RecordingMs = value.RecordingMS;
		value2.LongestClipMs = value.LongestClipMS;
		value2.ClipCount = value.ClipCount;
		value2.ScreenshotCount = value.ScreenshotCount;
		return value2;
	}

	public static void AddGamePhaseTag(string tagName, string icon, string tagGroup, uint priority)
	{
		Internal.AddGamePhaseTag(tagName, icon, tagGroup, priority);
	}

	public static void SetGamePhaseAttribute(string attributeGroup, string attributeValue, uint priority)
	{
		Internal.SetGamePhaseAttribute(attributeGroup, attributeValue, priority);
	}

	public static void SetTimelineGameMode(TimelineGameMode gameMode)
	{
		Internal.SetTimelineGameMode(gameMode);
	}

	public static void OpenOverlayToGamePhase(string phaseId)
	{
		Internal.OpenOverlayToGamePhase(phaseId);
	}

	public static void OpenOverlayToTimelineEvent(TimelineEventHandle handle)
	{
		Internal.OpenOverlayToTimelineEvent(handle);
	}
}


using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;
using Steamworks.Ugc;

public class SteamUGC : SteamSharedClass<SteamUGC>
{
	internal static ISteamUGC Internal => SteamSharedClass<SteamUGC>.Interface as ISteamUGC;

	public static event Action<Result> OnDownloadItemResult;

	public static event Action<AppId, PublishedFileId> OnItemSubscribed;

	public static event Action<AppId, PublishedFileId> OnItemUnsubscribed;

	public static event Action<AppId, PublishedFileId> OnItemInstalled;

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamUGC(server));
		if (SteamSharedClass<SteamUGC>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		InstallEvents(server);
		return true;
	}

	internal static void InstallEvents(bool server)
	{
		Dispatch.Install(delegate(DownloadItemResult_t x)
		{
			SteamUGC.OnDownloadItemResult?.Invoke(x.Result);
		}, server);
		Dispatch.Install(delegate(RemoteStoragePublishedFileSubscribed_t x)
		{
			SteamUGC.OnItemSubscribed?.Invoke(x.AppID.Value, x.PublishedFileId);
		}, server);
		Dispatch.Install(delegate(RemoteStoragePublishedFileUnsubscribed_t x)
		{
			SteamUGC.OnItemUnsubscribed?.Invoke(x.AppID.Value, x.PublishedFileId);
		}, server);
		Dispatch.Install(delegate(ItemInstalled_t x)
		{
			SteamUGC.OnItemInstalled?.Invoke(x.AppID.Value, x.PublishedFileId);
		}, server);
	}

	public static async Task<bool> DeleteFileAsync(PublishedFileId fileId)
	{
		DeleteItemResult_t? deleteItemResult_t = await Internal.DeleteItem(fileId);
		return deleteItemResult_t.HasValue && deleteItemResult_t.GetValueOrDefault().Result == Result.OK;
	}

	public static bool Download(PublishedFileId fileId, bool highPriority = false)
	{
		return Internal.DownloadItem(fileId, highPriority);
	}

	public static async Task<bool> DownloadAsync(PublishedFileId fileId, Action<float> progress = null, int milisecondsUpdateDelay = 60, CancellationToken ct = default(CancellationToken))
	{
		Item item = new Item(fileId);
		if (ct == default(CancellationToken))
		{
			ct = new CancellationTokenSource(TimeSpan.FromSeconds(60.0)).Token;
		}
		progress?.Invoke(0f);
		if (!Download(fileId, highPriority: true))
		{
			return item.IsInstalled;
		}
		Action<Result> onDownloadStarted = null;
		try
		{
			bool downloadStarted = false;
			onDownloadStarted = delegate
			{
				downloadStarted = true;
			};
			OnDownloadItemResult += onDownloadStarted;
			while (!downloadStarted && !ct.IsCancellationRequested)
			{
				await Task.Delay(milisecondsUpdateDelay);
			}
		}
		finally
		{
			OnDownloadItemResult -= onDownloadStarted;
		}
		progress?.Invoke(0.2f);
		await Task.Delay(milisecondsUpdateDelay);
		while (!ct.IsCancellationRequested)
		{
			progress?.Invoke(0.2f + item.DownloadAmount * 0.8f);
			if (!item.IsDownloading && item.IsInstalled)
			{
				break;
			}
			await Task.Delay(milisecondsUpdateDelay);
		}
		progress?.Invoke(1f);
		return item.IsInstalled;
	}

	public static async Task<Item?> QueryFileAsync(PublishedFileId fileId)
	{
		ResultPage? resultPage = await Query.All.WithFileId(fileId).GetPageAsync(1);
		if (!resultPage.HasValue || resultPage.Value.ResultCount != 1)
		{
			return null;
		}
		Item value = resultPage.Value.Entries.First();
		resultPage.Value.Dispose();
		return value;
	}

	public static async Task<bool> StartPlaytimeTracking(PublishedFileId fileId)
	{
		return (await Internal.StartPlaytimeTracking(new PublishedFileId[1] { fileId }, 1u)).Value.Result == Result.OK;
	}

	public static async Task<bool> StopPlaytimeTracking(PublishedFileId fileId)
	{
		return (await Internal.StopPlaytimeTracking(new PublishedFileId[1] { fileId }, 1u)).Value.Result == Result.OK;
	}

	public static async Task<bool> StopPlaytimeTrackingForAllItems()
	{
		return (await Internal.StopPlaytimeTrackingForAllItems()).Value.Result == Result.OK;
	}

	public static void SuspendDownloads()
	{
		Internal.SuspendDownloads(bSuspend: true);
	}

	public static void ResumeDownloads()
	{
		Internal.SuspendDownloads(bSuspend: false);
	}

	public static bool ShowWorkshopEula()
	{
		return Internal.ShowWorkshopEULA();
	}

	public static async Task<bool?> GetWorkshopEulaStatus()
	{
		return (await Internal.GetWorkshopEULAStatus())?.Accepted;
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;

public class SteamUser : SteamClientClass<SteamUser>
{
	private static Dictionary<string, string> richPresence;

	private static bool _recordingVoice;

	private static byte[] readBuffer = new byte[131072];

	private static uint sampleRate = 48000u;

	internal static ISteamUser Internal => SteamClientClass<SteamUser>.Interface as ISteamUser;

	public static bool VoiceRecord
	{
		get
		{
			return _recordingVoice;
		}
		set
		{
			_recordingVoice = value;
			if (value)
			{
				Internal.StartVoiceRecording();
			}
			else
			{
				Internal.StopVoiceRecording();
			}
		}
	}

	public static bool HasVoiceData
	{
		get
		{
			uint pcbCompressed = 0u;
			uint pcbUncompressed_Deprecated = 0u;
			if (Internal.GetAvailableVoice(ref pcbCompressed, ref pcbUncompressed_Deprecated, 0u) != 0)
			{
				return false;
			}
			return pcbCompressed != 0;
		}
	}

	public static uint SampleRate
	{
		get
		{
			return sampleRate;
		}
		set
		{
			if (SampleRate < 11025)
			{
				throw new Exception("Sample Rate must be between 11025 and 48000");
			}
			if (SampleRate > 48000)
			{
				throw new Exception("Sample Rate must be between 11025 and 48000");
			}
			sampleRate = value;
		}
	}

	public static uint OptimalSampleRate => Internal.GetVoiceOptimalSampleRate();

	public static bool IsBehindNAT => Internal.BIsBehindNAT();

	public static int SteamLevel => Internal.GetPlayerSteamLevel();

	public static bool IsPhoneVerified => Internal.BIsPhoneVerified();

	public static bool IsTwoFactorEnabled => Internal.BIsTwoFactorEnabled();

	public static bool IsPhoneIdentifying => Internal.BIsPhoneIdentifying();

	public static bool IsPhoneRequiringVerification => Internal.BIsPhoneRequiringVerification();

	public static event Action OnSteamServersConnected;

	public static event Action OnSteamServerConnectFailure;

	public static event Action OnSteamServersDisconnected;

	public static event Action OnClientGameServerDeny;

	public static event Action OnLicensesUpdated;

	public static event Action<SteamId, SteamId, AuthResponse> OnValidateAuthTicketResponse;

	internal static event Action<GetAuthSessionTicketResponse_t> OnGetAuthSessionTicketResponse;

	internal static event Action<GetTicketForWebApiResponse_t> OnGetTicketForWebApiResponse;

	public static event Action<AppId, ulong, bool> OnMicroTxnAuthorizationResponse;

	public static event Action<string> OnGameWebCallback;

	public static event Action<DurationControl> OnDurationControl;

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamUser(server));
		if (SteamClientClass<SteamUser>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		InstallEvents();
		richPresence = new Dictionary<string, string>();
		SampleRate = OptimalSampleRate;
		return true;
	}

	internal static void InstallEvents()
	{
		Dispatch.Install<SteamServersConnected_t>(delegate
		{
			SteamUser.OnSteamServersConnected?.Invoke();
		});
		Dispatch.Install<SteamServerConnectFailure_t>(delegate
		{
			SteamUser.OnSteamServerConnectFailure?.Invoke();
		});
		Dispatch.Install<SteamServersDisconnected_t>(delegate
		{
			SteamUser.OnSteamServersDisconnected?.Invoke();
		});
		Dispatch.Install<ClientGameServerDeny_t>(delegate
		{
			SteamUser.OnClientGameServerDeny?.Invoke();
		});
		Dispatch.Install<LicensesUpdated_t>(delegate
		{
			SteamUser.OnLicensesUpdated?.Invoke();
		});
		Dispatch.Install(delegate(ValidateAuthTicketResponse_t x)
		{
			SteamUser.OnValidateAuthTicketResponse?.Invoke(x.SteamID, x.OwnerSteamID, x.AuthSessionResponse);
		});
		Dispatch.Install(delegate(MicroTxnAuthorizationResponse_t x)
		{
			SteamUser.OnMicroTxnAuthorizationResponse?.Invoke(x.AppID, x.OrderID, x.Authorized != 0);
		});
		Dispatch.Install(delegate(GameWebCallback_t x)
		{
			SteamUser.OnGameWebCallback?.Invoke(x.URLUTF8());
		});
		Dispatch.Install(delegate(GetAuthSessionTicketResponse_t x)
		{
			SteamUser.OnGetAuthSessionTicketResponse?.Invoke(x);
		});
		Dispatch.Install(delegate(GetTicketForWebApiResponse_t x)
		{
			SteamUser.OnGetTicketForWebApiResponse?.Invoke(x);
		});
		Dispatch.Install(delegate(DurationControl_t x)
		{
			SteamUser.OnDurationControl?.Invoke(new DurationControl
			{
				_inner = x
			});
		});
	}

	public unsafe static int ReadVoiceData(Stream stream)
	{
		if (!HasVoiceData)
		{
			return 0;
		}
		uint nBytesWritten = 0u;
		uint nUncompressBytesWritten_Deprecated = 0u;
		fixed (byte* ptr = readBuffer)
		{
			if (Internal.GetVoice(bWantCompressed: true, (IntPtr)ptr, (uint)readBuffer.Length, ref nBytesWritten, bWantUncompressed_Deprecated: false, IntPtr.Zero, 0u, ref nUncompressBytesWritten_Deprecated, 0u) != 0)
			{
				return 0;
			}
		}
		if (nBytesWritten == 0)
		{
			return 0;
		}
		stream.Write(readBuffer, 0, (int)nBytesWritten);
		return (int)nBytesWritten;
	}

	public unsafe static byte[] ReadVoiceDataBytes()
	{
		if (!HasVoiceData)
		{
			return null;
		}
		uint nBytesWritten = 0u;
		uint nUncompressBytesWritten_Deprecated = 0u;
		fixed (byte* ptr = readBuffer)
		{
			if (Internal.GetVoice(bWantCompressed: true, (IntPtr)ptr, (uint)readBuffer.Length, ref nBytesWritten, bWantUncompressed_Deprecated: false, IntPtr.Zero, 0u, ref nUncompressBytesWritten_Deprecated, 0u) != 0)
			{
				return null;
			}
		}
		if (nBytesWritten == 0)
		{
			return null;
		}
		byte[] array = new byte[nBytesWritten];
		Array.Copy(readBuffer, 0L, array, 0L, nBytesWritten);
		return array;
	}

	public unsafe static int DecompressVoice(Stream input, int length, Stream output)
	{
		byte[] array = Helpers.TakeBuffer(length);
		byte[] array2 = Helpers.TakeBuffer(65536);
		using (MemoryStream destination = new MemoryStream(array))
		{
			input.CopyTo(destination);
		}
		uint nBytesWritten = 0u;
		fixed (byte* ptr = array)
		{
			fixed (byte* ptr2 = array2)
			{
				if (Internal.DecompressVoice((IntPtr)ptr, (uint)length, (IntPtr)ptr2, (uint)array2.Length, ref nBytesWritten, SampleRate) != 0)
				{
					return 0;
				}
			}
		}
		if (nBytesWritten == 0)
		{
			return 0;
		}
		output.Write(array2, 0, (int)nBytesWritten);
		return (int)nBytesWritten;
	}

	public unsafe static int DecompressVoice(byte[] from, Stream output)
	{
		byte[] array = Helpers.TakeBuffer(65536);
		uint nBytesWritten = 0u;
		fixed (byte* ptr = from)
		{
			fixed (byte* ptr2 = array)
			{
				if (Internal.DecompressVoice((IntPtr)ptr, (uint)from.Length, (IntPtr)ptr2, (uint)array.Length, ref nBytesWritten, SampleRate) != 0)
				{
					return 0;
				}
			}
		}
		if (nBytesWritten == 0)
		{
			return 0;
		}
		output.Write(array, 0, (int)nBytesWritten);
		return (int)nBytesWritten;
	}

	public static int DecompressVoice(IntPtr from, int length, IntPtr to, int bufferSize)
	{
		if (length <= 0)
		{
			throw new ArgumentException("length should be > 0 ");
		}
		if (bufferSize <= 0)
		{
			throw new ArgumentException("bufferSize should be > 0 ");
		}
		uint nBytesWritten = 0u;
		if (Internal.DecompressVoice(from, (uint)length, to, (uint)bufferSize, ref nBytesWritten, SampleRate) != 0)
		{
			return 0;
		}
		return (int)nBytesWritten;
	}

	public unsafe static AuthTicket GetAuthSessionTicket(NetIdentity identity)
	{
		byte[] array = Helpers.TakeBuffer(2560);
		fixed (byte* ptr = array)
		{
			uint pcbTicket = 0u;
			uint num = Internal.GetAuthSessionTicket((IntPtr)ptr, array.Length, ref pcbTicket, ref identity);
			if (num == 0)
			{
				return null;
			}
			return new AuthTicket
			{
				Data = array.Take((int)pcbTicket).ToArray(),
				Handle = num
			};
		}
	}

	public static async Task<AuthTicket> GetAuthSessionTicketAsync(NetIdentity identity, double timeoutSeconds = 10.0)
	{
		Result result = Result.Pending;
		AuthTicket ticket = null;
		Stopwatch stopwatch = Stopwatch.StartNew();
		OnGetAuthSessionTicketResponse += f;
		try
		{
			ticket = GetAuthSessionTicket(identity);
			if (ticket == null)
			{
				return null;
			}
			while (result == Result.Pending)
			{
				await Task.Delay(10);
				if (stopwatch.Elapsed.TotalSeconds > timeoutSeconds)
				{
					ticket.Cancel();
					return null;
				}
			}
			if (result == Result.OK)
			{
				return ticket;
			}
			ticket.Cancel();
			return null;
		}
		finally
		{
			OnGetAuthSessionTicketResponse -= f;
		}
		void f(GetAuthSessionTicketResponse_t t)
		{
			if (t.AuthTicket == ticket.Handle)
			{
				result = t.Result;
			}
		}
	}

	private static AuthTicket GetAuthTicketForWebApi(string identity)
	{
		uint num = Internal.GetAuthTicketForWebApi(identity);
		if (num == 0)
		{
			return null;
		}
		return new AuthTicket
		{
			Handle = num
		};
	}

	public static async Task<AuthTicket> GetAuthTicketForWebApiAsync(string identity, double timeoutSeconds = 10.0)
	{
		Result result = Result.Pending;
		AuthTicket ticket = null;
		Stopwatch stopwatch = Stopwatch.StartNew();
		OnGetTicketForWebApiResponse += f;
		try
		{
			ticket = GetAuthTicketForWebApi(identity);
			if (ticket == null)
			{
				return null;
			}
			while (result == Result.Pending)
			{
				await Task.Delay(10);
				if (stopwatch.Elapsed.TotalSeconds > timeoutSeconds)
				{
					ticket.Cancel();
					return null;
				}
			}
			if (result == Result.OK)
			{
				return ticket;
			}
			ticket.Cancel();
			return null;
		}
		finally
		{
			OnGetTicketForWebApiResponse -= f;
		}
		void f(GetTicketForWebApiResponse_t t)
		{
			if (t.AuthTicket == ticket.Handle)
			{
				result = t.Result;
				ticket.Data = t.GubTicket;
			}
		}
	}

	public unsafe static BeginAuthResult BeginAuthSession(byte[] ticketData, SteamId steamid)
	{
		fixed (byte* ptr = ticketData)
		{
			return Internal.BeginAuthSession((IntPtr)ptr, ticketData.Length, steamid);
		}
	}

	public static void EndAuthSession(SteamId steamid)
	{
		Internal.EndAuthSession(steamid);
	}

	public static async Task<string> GetStoreAuthUrlAsync(string url)
	{
		StoreAuthURLResponse_t? storeAuthURLResponse_t = await Internal.RequestStoreAuthURL(url);
		if (!storeAuthURLResponse_t.HasValue)
		{
			return null;
		}
		return storeAuthURLResponse_t.Value.URLUTF8();
	}

	public static async Task<byte[]> RequestEncryptedAppTicketAsync(byte[] dataToInclude)
	{
		IntPtr dataPtr = Marshal.AllocHGlobal(dataToInclude.Length);
		Marshal.Copy(dataToInclude, 0, dataPtr, dataToInclude.Length);
		try
		{
			EncryptedAppTicketResponse_t? encryptedAppTicketResponse_t = await Internal.RequestEncryptedAppTicket(dataPtr, dataToInclude.Length);
			if (!encryptedAppTicketResponse_t.HasValue || encryptedAppTicketResponse_t.Value.Result != Result.OK)
			{
				return null;
			}
			IntPtr intPtr = Marshal.AllocHGlobal(1024);
			uint pcbTicket = 0u;
			byte[] array = null;
			if (Internal.GetEncryptedAppTicket(intPtr, 1024, ref pcbTicket))
			{
				array = new byte[pcbTicket];
				Marshal.Copy(intPtr, array, 0, (int)pcbTicket);
			}
			Marshal.FreeHGlobal(intPtr);
			return array;
		}
		finally
		{
			Marshal.FreeHGlobal(dataPtr);
		}
	}

	public static async Task<byte[]> RequestEncryptedAppTicketAsync()
	{
		EncryptedAppTicketResponse_t? encryptedAppTicketResponse_t = await Internal.RequestEncryptedAppTicket(IntPtr.Zero, 0);
		if (!encryptedAppTicketResponse_t.HasValue || encryptedAppTicketResponse_t.Value.Result != Result.OK)
		{
			return null;
		}
		IntPtr intPtr = Marshal.AllocHGlobal(1024);
		uint pcbTicket = 0u;
		byte[] array = null;
		if (Internal.GetEncryptedAppTicket(intPtr, 1024, ref pcbTicket))
		{
			array = new byte[pcbTicket];
			Marshal.Copy(intPtr, array, 0, (int)pcbTicket);
		}
		Marshal.FreeHGlobal(intPtr);
		return array;
	}

	public static async Task<DurationControl> GetDurationControl()
	{
		DurationControl_t? durationControl_t = await Internal.GetDurationControl();
		if (!durationControl_t.HasValue)
		{
			return default(DurationControl);
		}
		DurationControl result = default(DurationControl);
		result._inner = durationControl_t.Value;
		return result;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;

public class SteamUserStats : SteamClientClass<SteamUserStats>
{
	[CompilerGenerated]
	private sealed class <get_Achievements>d__24 : IEnumerable<Achievement>, IEnumerable, IEnumerator<Achievement>, IDisposable, IEnumerator
	{
		private int <>1__state;

		private Achievement <>2__current;

		private int <>l__initialThreadId;

		private int <i>5__2;

		Achievement IEnumerator<Achievement>.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		object IEnumerator.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		[DebuggerHidden]
		public <get_Achievements>d__24(int <>1__state)
		{
			this.<>1__state = <>1__state;
			<>l__initialThreadId = Environment.CurrentManagedThreadId;
		}

		[DebuggerHidden]
		void IDisposable.Dispose()
		{
			<>1__state = -2;
		}

		private bool MoveNext()
		{
			switch (<>1__state)
			{
			default:
				return false;
			case 0:
				<>1__state = -1;
				<i>5__2 = 0;
				break;
			case 1:
				<>1__state = -1;
				<i>5__2++;
				break;
			}
			if (<i>5__2 < Internal.GetNumAchievements())
			{
				<>2__current = new Achievement(Internal.GetAchievementName((uint)<i>5__2));
				<>1__state = 1;
				return true;
			}
			return false;
		}

		bool IEnumerator.MoveNext()
		{
			//ILSpy generated this explicit interface implementation from .override directive in MoveNext
			return this.MoveNext();
		}

		[DebuggerHidden]
		void IEnumerator.Reset()
		{
			throw new NotSupportedException();
		}

		[DebuggerHidden]
		IEnumerator<Achievement> IEnumerable<Achievement>.GetEnumerator()
		{
			if (<>1__state == -2 && <>l__initialThreadId == Environment.CurrentManagedThreadId)
			{
				<>1__state = 0;
				return this;
			}
			return new <get_Achievements>d__24(0);
		}

		[DebuggerHidden]
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<Achievement>)this).GetEnumerator();
		}
	}

	internal static ISteamUserStats Internal => SteamClientClass<SteamUserStats>.Interface as ISteamUserStats;

	public static bool StatsRecieved { get; internal set; }

	public static IEnumerable<Achievement> Achievements
	{
		[IteratorStateMachine(typeof(<get_Achievements>d__24))]
		get
		{
			//yield-return decompiler failed: Unexpected instruction in Iterator.Dispose()
			return new <get_Achievements>d__24(-2);
		}
	}

	internal static event Action<string, int> OnAchievementIconFetched;

	public static event Action<SteamId, Result> OnUserStatsReceived;

	public static event Action<Result> OnUserStatsStored;

	public static event Action<Achievement, int, int> OnAchievementProgress;

	public static event Action<SteamId> OnUserStatsUnloaded;

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamUserStats(server));
		if (SteamClientClass<SteamUserStats>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		InstallEvents();
		RequestCurrentStats();
		return true;
	}

	internal static void InstallEvents()
	{
		Dispatch.Install(delegate(UserStatsReceived_t x)
		{
			if (x.SteamIDUser == (ulong)SteamClient.SteamId)
			{
				StatsRecieved = true;
			}
			SteamUserStats.OnUserStatsReceived?.Invoke(x.SteamIDUser, x.Result);
		});
		Dispatch.Install(delegate(UserStatsStored_t x)
		{
			SteamUserStats.OnUserStatsStored?.Invoke(x.Result);
		});
		Dispatch.Install(delegate(UserAchievementStored_t x)
		{
			SteamUserStats.OnAchievementProgress?.Invoke(new Achievement(x.AchievementNameUTF8()), (int)x.CurProgress, (int)x.MaxProgress);
		});
		Dispatch.Install(delegate(UserStatsUnloaded_t x)
		{
			SteamUserStats.OnUserStatsUnloaded?.Invoke(x.SteamIDUser);
		});
		Dispatch.Install(delegate(UserAchievementIconFetched_t x)
		{
			SteamUserStats.OnAchievementIconFetched?.Invoke(x.AchievementNameUTF8(), x.IconHandle);
		});
	}

	public static bool IndicateAchievementProgress(string achName, int curProg, int maxProg)
	{
		if (string.IsNullOrEmpty(achName))
		{
			throw new ArgumentNullException("Achievement string is null or empty");
		}
		if (curProg >= maxProg)
		{
			throw new ArgumentException($" Current progress [{curProg}] arguement toward achievement greater than or equal to max [{maxProg}]");
		}
		return Internal.IndicateAchievementProgress(achName, (uint)curProg, (uint)maxProg);
	}

	public static async Task<int> PlayerCountAsync()
	{
		NumberOfCurrentPlayers_t? numberOfCurrentPlayers_t = await Internal.GetNumberOfCurrentPlayers();
		if (!numberOfCurrentPlayers_t.HasValue || numberOfCurrentPlayers_t.Value.Success == 0)
		{
			return -1;
		}
		return numberOfCurrentPlayers_t.Value.CPlayers;
	}

	public static bool StoreStats()
	{
		return Internal.StoreStats();
	}

	[Obsolete("No longer required. Automatically handled by the Steam client.", false)]
	public static bool RequestCurrentStats()
	{
		return true;
	}

	public static async Task<Result> RequestGlobalStatsAsync(int days)
	{
		GlobalStatsReceived_t? globalStatsReceived_t = await Internal.RequestGlobalStats(days);
		if (!globalStatsReceived_t.HasValue)
		{
			return Result.Fail;
		}
		return globalStatsReceived_t.Value.Result;
	}

	public static async Task<Leaderboard?> FindOrCreateLeaderboardAsync(string name, LeaderboardSort sort, LeaderboardDisplay display)
	{
		LeaderboardFindResult_t? leaderboardFindResult_t = await Internal.FindOrCreateLeaderboard(name, sort, display);
		if (!leaderboardFindResult_t.HasValue || leaderboardFindResult_t.Value.LeaderboardFound == 0)
		{
			return null;
		}
		Leaderboard value = default(Leaderboard);
		value.Id = leaderboardFindResult_t.Value.SteamLeaderboard;
		return value;
	}

	public static async Task<Leaderboard?> FindLeaderboardAsync(string name)
	{
		LeaderboardFindResult_t? leaderboardFindResult_t = await Internal.FindLeaderboard(name);
		if (!leaderboardFindResult_t.HasValue || leaderboardFindResult_t.Value.LeaderboardFound == 0)
		{
			return null;
		}
		Leaderboard value = default(Leaderboard);
		value.Id = leaderboardFindResult_t.Value.SteamLeaderboard;
		return value;
	}

	public static bool AddStat(string name, int amount = 1)
	{
		int statInt = GetStatInt(name);
		statInt += amount;
		return SetStat(name, statInt);
	}

	public static bool AddStat(string name, float amount = 1f)
	{
		float statFloat = GetStatFloat(name);
		statFloat += amount;
		return SetStat(name, statFloat);
	}

	public static bool SetStat(string name, int value)
	{
		return Internal.SetStat(name, value);
	}

	public static bool SetStat(string name, float value)
	{
		return Internal.SetStat(name, value);
	}

	public static int GetStatInt(string name)
	{
		int pData = 0;
		Internal.GetStat(name, ref pData);
		return pData;
	}

	public static float GetStatFloat(string name)
	{
		float pData = 0f;
		Internal.GetStat(name, ref pData);
		return pData;
	}

	public static bool ResetAll(bool includeAchievements)
	{
		return Internal.ResetAllStats(includeAchievements);
	}
}


using System;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;

public class SteamUtils : SteamSharedClass<SteamUtils>
{
	private static NotificationPosition overlayNotificationPosition = NotificationPosition.BottomRight;

	internal static ISteamUtils Internal => SteamSharedClass<SteamUtils>.Interface as ISteamUtils;

	public static uint SecondsSinceAppActive => Internal.GetSecondsSinceAppActive();

	public static uint SecondsSinceComputerActive => Internal.GetSecondsSinceComputerActive();

	public static Universe ConnectedUniverse => Internal.GetConnectedUniverse();

	public static DateTime SteamServerTime => Epoch.ToDateTime(Internal.GetServerRealTime());

	public static string IpCountry => Internal.GetIPCountry();

	public static bool UsingBatteryPower => Internal.GetCurrentBatteryPower() != byte.MaxValue;

	public static float CurrentBatteryPower => Math.Min(Internal.GetCurrentBatteryPower() / 100, 1f);

	public static NotificationPosition OverlayNotificationPosition
	{
		get
		{
			return overlayNotificationPosition;
		}
		set
		{
			overlayNotificationPosition = value;
			Internal.SetOverlayNotificationPosition(value);
		}
	}

	public static bool IsOverlayEnabled => Internal.IsOverlayEnabled();

	public static bool DoesOverlayNeedPresent => Internal.BOverlayNeedsPresent();

	public static string SteamUILanguage => Internal.GetSteamUILanguage();

	public static bool IsSteamRunningInVR => Internal.IsSteamRunningInVR();

	public static bool IsSteamInBigPictureMode => Internal.IsSteamInBigPictureMode();

	public static bool VrHeadsetStreaming
	{
		get
		{
			return Internal.IsVRHeadsetStreamingEnabled();
		}
		set
		{
			Internal.SetVRHeadsetStreamingEnabled(value);
		}
	}

	public static bool IsSteamChinaLauncher => Internal.IsSteamChinaLauncher();

	public static bool IsRunningOnSteamDeck => Internal.IsSteamRunningOnSteamDeck();

	public static event Action OnIpCountryChanged;

	public static event Action<int> OnLowBatteryPower;

	public static event Action OnSteamShutdown;

	public static event Action<bool> OnGamepadTextInputDismissed;

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamUtils(server));
		if (SteamSharedClass<SteamUtils>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		InstallEvents(server);
		return true;
	}

	internal static void InstallEvents(bool server)
	{
		Dispatch.Install<IPCountry_t>(delegate
		{
			SteamUtils.OnIpCountryChanged?.Invoke();
		}, server);
		Dispatch.Install(delegate(LowBatteryPower_t x)
		{
			SteamUtils.OnLowBatteryPower?.Invoke(x.MinutesBatteryLeft);
		}, server);
		Dispatch.Install<SteamShutdown_t>(delegate
		{
			SteamClosed();
		}, server);
		Dispatch.Install(delegate(GamepadTextInputDismissed_t x)
		{
			SteamUtils.OnGamepadTextInputDismissed?.Invoke(x.Submitted);
		}, server);
	}

	private static void SteamClosed()
	{
		SteamClient.Cleanup();
		SteamUtils.OnSteamShutdown?.Invoke();
	}

	public static bool GetImageSize(int image, out uint width, out uint height)
	{
		width = 0u;
		height = 0u;
		return Internal.GetImageSize(image, ref width, ref height);
	}

	public static Image? GetImage(int image)
	{
		switch (image)
		{
		case -1:
			return null;
		case 0:
			return null;
		default:
		{
			Image value = default(Image);
			if (!GetImageSize(image, out value.Width, out value.Height))
			{
				return null;
			}
			uint num = value.Width * value.Height * 4;
			byte[] array = Helpers.TakeBuffer((int)num);
			if (!Internal.GetImageRGBA(image, array, (int)num))
			{
				return null;
			}
			value.Data = new byte[num];
			Array.Copy(array, 0L, value.Data, 0L, num);
			return value;
		}
		}
	}

	public static async Task<CheckFileSignature> CheckFileSignatureAsync(string filename)
	{
		CheckFileSignature_t? checkFileSignature_t = await Internal.CheckFileSignature(filename);
		if (!checkFileSignature_t.HasValue)
		{
			throw new Exception("Something went wrong");
		}
		return checkFileSignature_t.Value.CheckFileSignature;
	}

	public static bool ShowGamepadTextInput(GamepadTextInputMode inputMode, GamepadTextInputLineMode lineInputMode, string description, int maxChars, string existingText = "")
	{
		return Internal.ShowGamepadTextInput(inputMode, lineInputMode, description, (uint)maxChars, existingText);
	}

	public static string GetEnteredGamepadText()
	{
		if (Internal.GetEnteredGamepadTextLength() == 0)
		{
			return string.Empty;
		}
		if (!Internal.GetEnteredGamepadTextInput(out var pchText))
		{
			return string.Empty;
		}
		return pchText;
	}

	public static void SetOverlayNotificationInset(int x, int y)
	{
		Internal.SetOverlayNotificationInset(x, y);
	}

	public static void StartVRDashboard()
	{
		Internal.StartVRDashboard();
	}

	internal static bool IsCallComplete(SteamAPICall_t call, out bool failed)
	{
		failed = false;
		return Internal.IsAPICallCompleted(call, ref failed);
	}

	public static bool InitFilterText()
	{
		return Internal.InitFilterText(0u);
	}

	public static string FilterText(TextFilteringContext context, SteamId sourceSteamID, string inputMessage)
	{
		Internal.FilterText(context, sourceSteamID, inputMessage, out var pchOutFilteredText);
		return pchOutFilteredText;
	}

	public static void SetGameLauncherMode(bool mode)
	{
		Internal.SetGameLauncherMode(mode);
	}
}


using System;
using Steamworks;

public class SteamVideo : SteamClientClass<SteamVideo>
{
	internal static ISteamVideo Internal => SteamClientClass<SteamVideo>.Interface as ISteamVideo;

	public static bool IsBroadcasting
	{
		get
		{
			int pnNumViewers = 0;
			return Internal.IsBroadcasting(ref pnNumViewers);
		}
	}

	public static int NumViewers
	{
		get
		{
			int pnNumViewers = 0;
			if (!Internal.IsBroadcasting(ref pnNumViewers))
			{
				return 0;
			}
			return pnNumViewers;
		}
	}

	internal override bool InitializeInterface(bool server)
	{
		SetInterface(server, new ISteamVideo(server));
		if (SteamClientClass<SteamVideo>.Interface.Self == IntPtr.Zero)
		{
			return false;
		}
		InstallEvents();
		return true;
	}

	internal static void InstallEvents()
	{
	}
}


using Steamworks;

public struct AppId
{
	public uint Value;

	public override string ToString()
	{
		return Value.ToString();
	}

	public static implicit operator AppId(uint value)
	{
		AppId result = default(AppId);
		result.Value = value;
		return result;
	}

	public static implicit operator AppId(int value)
	{
		AppId result = default(AppId);
		result.Value = (uint)value;
		return result;
	}

	public static implicit operator uint(AppId value)
	{
		return value.Value;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;

public struct Clan
{
	[CompilerGenerated]
	private sealed class <GetOfficers>d__15 : IEnumerable<Friend>, IEnumerable, IEnumerator<Friend>, IDisposable, IEnumerator
	{
		private int <>1__state;

		private Friend <>2__current;

		private int <>l__initialThreadId;

		public Clan <>4__this;

		public Clan <>3__<>4__this;

		private int <i>5__2;

		Friend IEnumerator<Friend>.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		object IEnumerator.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		[DebuggerHidden]
		public <GetOfficers>d__15(int <>1__state)
		{
			this.<>1__state = <>1__state;
			<>l__initialThreadId = Environment.CurrentManagedThreadId;
		}

		[DebuggerHidden]
		void IDisposable.Dispose()
		{
			<>1__state = -2;
		}

		private bool MoveNext()
		{
			switch (<>1__state)
			{
			default:
				return false;
			case 0:
				<>1__state = -1;
				<i>5__2 = 0;
				break;
			case 1:
				<>1__state = -1;
				<i>5__2++;
				break;
			}
			if (<i>5__2 < SteamFriends.Internal.GetClanOfficerCount(<>4__this.Id))
			{
				<>2__current = new Friend(SteamFriends.Internal.GetClanOfficerByIndex(<>4__this.Id, <i>5__2));
				<>1__state = 1;
				return true;
			}
			return false;
		}

		bool IEnumerator.MoveNext()
		{
			//ILSpy generated this explicit interface implementation from .override directive in MoveNext
			return this.MoveNext();
		}

		[DebuggerHidden]
		void IEnumerator.Reset()
		{
			throw new NotSupportedException();
		}

		[DebuggerHidden]
		IEnumerator<Friend> IEnumerable<Friend>.GetEnumerator()
		{
			<GetOfficers>d__15 <GetOfficers>d__;
			if (<>1__state == -2 && <>l__initialThreadId == Environment.CurrentManagedThreadId)
			{
				<>1__state = 0;
				<GetOfficers>d__ = this;
			}
			else
			{
				<GetOfficers>d__ = new <GetOfficers>d__15(0);
			}
			<GetOfficers>d__.<>4__this = <>3__<>4__this;
			return <GetOfficers>d__;
		}

		[DebuggerHidden]
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<Friend>)this).GetEnumerator();
		}
	}

	public SteamId Id;

	public string Name => SteamFriends.Internal.GetClanName(Id);

	public string Tag => SteamFriends.Internal.GetClanTag(Id);

	public int ChatMemberCount => SteamFriends.Internal.GetClanChatMemberCount(Id);

	public Friend Owner => new Friend(SteamFriends.Internal.GetClanOwner(Id));

	public bool Public => SteamFriends.Internal.IsClanPublic(Id);

	public bool Official => SteamFriends.Internal.IsClanOfficialGameGroup(Id);

	public Clan(SteamId id)
	{
		Id = id;
	}

	public async Task<bool> RequestOfficerList()
	{
		ClanOfficerListResponse_t? clanOfficerListResponse_t = await SteamFriends.Internal.RequestClanOfficerList(Id);
		return clanOfficerListResponse_t.HasValue && clanOfficerListResponse_t.Value.Success != 0;
	}

	[IteratorStateMachine(typeof(<GetOfficers>d__15))]
	public IEnumerable<Friend> GetOfficers()
	{
		//yield-return decompiler failed: Unexpected instruction in Iterator.Dispose()
		return new <GetOfficers>d__15(-2)
		{
			<>3__<>4__this = this
		};
	}
}


using Steamworks;
using Steamworks.Data;

public struct Controller
{
	internal InputHandle_t Handle;

	public ulong Id => Handle.Value;

	public InputType InputType => SteamInput.Internal.GetInputTypeForHandle(Handle);

	public string ActionSet
	{
		set
		{
			SteamInput.Internal.ActivateActionSet(Handle, SteamInput.Internal.GetActionSetHandle(value));
		}
	}

	internal Controller(InputHandle_t inputHandle_t)
	{
		Handle = inputHandle_t;
	}

	public void DeactivateLayer(string layer)
	{
		SteamInput.Internal.DeactivateActionSetLayer(Handle, SteamInput.Internal.GetActionSetHandle(layer));
	}

	public void ActivateLayer(string layer)
	{
		SteamInput.Internal.ActivateActionSetLayer(Handle, SteamInput.Internal.GetActionSetHandle(layer));
	}

	public void ClearLayers()
	{
		SteamInput.Internal.DeactivateAllActionSetLayers(Handle);
	}

	public DigitalState GetDigitalState(string actionName)
	{
		return SteamInput.Internal.GetDigitalActionData(Handle, SteamInput.GetDigitalActionHandle(actionName));
	}

	public AnalogState GetAnalogState(string actionName)
	{
		return SteamInput.Internal.GetAnalogActionData(Handle, SteamInput.GetAnalogActionHandle(actionName));
	}

	public override string ToString()
	{
		return $"{InputType}.{Handle.Value}";
	}

	public static bool operator ==(Controller a, Controller b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(Controller a, Controller b)
	{
		return !(a == b);
	}

	public override bool Equals(object p)
	{
		return Equals((Controller)p);
	}

	public override int GetHashCode()
	{
		return Handle.GetHashCode();
	}

	public bool Equals(Controller p)
	{
		return p.Handle == Handle;
	}
}


using System.Runtime.InteropServices;
using Steamworks;

[StructLayout(LayoutKind.Sequential, Pack = 1)]
public struct AnalogState
{
	public InputSourceMode EMode;

	public float X;

	public float Y;

	internal byte BActive;

	public bool Active => BActive != 0;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Pack = 1)]
internal struct MotionState
{
	public float RotQuatX;

	public float RotQuatY;

	public float RotQuatZ;

	public float RotQuatW;

	public float PosAccelX;

	public float PosAccelY;

	public float PosAccelZ;

	public float RotVelX;

	public float RotVelY;

	public float RotVelZ;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Pack = 1)]
public struct DigitalState
{
	[MarshalAs(UnmanagedType.I1)]
	internal byte BState;

	[MarshalAs(UnmanagedType.I1)]
	internal byte BActive;

	public bool Pressed => BState != 0;

	public bool Active => BActive != 0;
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;

public struct Friend
{
	public struct FriendGameInfo
	{
		internal uint GameIP;

		internal ulong SteamIDLobby;

		public GameId GameID;

		public int ConnectionPort;

		public int QueryPort;

		public uint IpAddressRaw => GameIP;

		public IPAddress IpAddress => Utility.Int32ToIp(GameIP);

		public Lobby? Lobby
		{
			get
			{
				if (SteamIDLobby == 0L)
				{
					return null;
				}
				return new Lobby(SteamIDLobby);
			}
		}

		internal static FriendGameInfo From(FriendGameInfo_t i)
		{
			FriendGameInfo result = default(FriendGameInfo);
			result.GameID = i.GameID;
			result.GameIP = i.GameIP;
			result.ConnectionPort = i.GamePort;
			result.QueryPort = i.QueryPort;
			result.SteamIDLobby = i.SteamIDLobby;
			return result;
		}
	}

	[CompilerGenerated]
	private sealed class <get_NameHistory>d__29 : IEnumerable<string>, IEnumerable, IEnumerator<string>, IDisposable, IEnumerator
	{
		private int <>1__state;

		private string <>2__current;

		private int <>l__initialThreadId;

		public Friend <>4__this;

		public Friend <>3__<>4__this;

		private int <i>5__2;

		string IEnumerator<string>.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		object IEnumerator.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		[DebuggerHidden]
		public <get_NameHistory>d__29(int <>1__state)
		{
			this.<>1__state = <>1__state;
			<>l__initialThreadId = Environment.CurrentManagedThreadId;
		}

		[DebuggerHidden]
		void IDisposable.Dispose()
		{
			<>1__state = -2;
		}

		private bool MoveNext()
		{
			switch (<>1__state)
			{
			default:
				return false;
			case 0:
				<>1__state = -1;
				<i>5__2 = 0;
				break;
			case 1:
				<>1__state = -1;
				<i>5__2++;
				break;
			}
			if (<i>5__2 < 32)
			{
				string friendPersonaNameHistory = SteamFriends.Internal.GetFriendPersonaNameHistory(<>4__this.Id, <i>5__2);
				if (!string.IsNullOrEmpty(friendPersonaNameHistory))
				{
					<>2__current = friendPersonaNameHistory;
					<>1__state = 1;
					return true;
				}
			}
			return false;
		}

		bool IEnumerator.MoveNext()
		{
			//ILSpy generated this explicit interface implementation from .override directive in MoveNext
			return this.MoveNext();
		}

		[DebuggerHidden]
		void IEnumerator.Reset()
		{
			throw new NotSupportedException();
		}

		[DebuggerHidden]
		IEnumerator<string> IEnumerable<string>.GetEnumerator()
		{
			<get_NameHistory>d__29 <get_NameHistory>d__;
			if (<>1__state == -2 && <>l__initialThreadId == Environment.CurrentManagedThreadId)
			{
				<>1__state = 0;
				<get_NameHistory>d__ = this;
			}
			else
			{
				<get_NameHistory>d__ = new <get_NameHistory>d__29(0);
			}
			<get_NameHistory>d__.<>4__this = <>3__<>4__this;
			return <get_NameHistory>d__;
		}

		[DebuggerHidden]
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<string>)this).GetEnumerator();
		}
	}

	public SteamId Id;

	public bool IsMe => (ulong)Id == (ulong)SteamClient.SteamId;

	public bool IsFriend => Relationship == Relationship.Friend;

	public bool IsBlocked => Relationship == Relationship.Blocked;

	public bool IsPlayingThisGame
	{
		get
		{
			GameId? gameId = GameInfo?.GameID;
			if (gameId.HasValue && gameId.GetValueOrDefault().Type == GameIdType.App)
			{
				return GameInfo.Value.GameID.AppId == (uint)SteamClient.AppId;
			}
			return false;
		}
	}

	public bool IsOnline => State != FriendState.Offline;

	public bool IsAway => State == FriendState.Away;

	public bool IsBusy => State == FriendState.Busy;

	public bool IsSnoozing => State == FriendState.Snooze;

	public Relationship Relationship => SteamFriends.Internal.GetFriendRelationship(Id);

	public FriendState State => SteamFriends.Internal.GetFriendPersonaState(Id);

	public string Name => SteamFriends.Internal.GetFriendPersonaName(Id);

	public string Nickname => SteamFriends.Internal.GetPlayerNickname(Id);

	public IEnumerable<string> NameHistory
	{
		[IteratorStateMachine(typeof(<get_NameHistory>d__29))]
		get
		{
			//yield-return decompiler failed: Unexpected instruction in Iterator.Dispose()
			return new <get_NameHistory>d__29(-2)
			{
				<>3__<>4__this = this
			};
		}
	}

	public int SteamLevel => SteamFriends.Internal.GetFriendSteamLevel(Id);

	public FriendGameInfo? GameInfo
	{
		get
		{
			FriendGameInfo_t pFriendGameInfo = default(FriendGameInfo_t);
			if (!SteamFriends.Internal.GetFriendGamePlayed(Id, ref pFriendGameInfo))
			{
				return null;
			}
			return FriendGameInfo.From(pFriendGameInfo);
		}
	}

	public Friend(SteamId steamid)
	{
		Id = steamid;
	}

	public override string ToString()
	{
		return Name + " (" + Id.ToString() + ")";
	}

	public async Task RequestInfoAsync()
	{
		await SteamFriends.CacheUserInformationAsync(Id, nameonly: true);
	}

	public bool IsIn(SteamId group_or_room)
	{
		return SteamFriends.Internal.IsUserInSource(Id, group_or_room);
	}

	public async Task<Image?> GetSmallAvatarAsync()
	{
		return await SteamFriends.GetSmallAvatarAsync(Id);
	}

	public async Task<Image?> GetMediumAvatarAsync()
	{
		return await SteamFriends.GetMediumAvatarAsync(Id);
	}

	public async Task<Image?> GetLargeAvatarAsync()
	{
		return await SteamFriends.GetLargeAvatarAsync(Id);
	}

	public string GetRichPresence(string key)
	{
		string friendRichPresence = SteamFriends.Internal.GetFriendRichPresence(Id, key);
		if (string.IsNullOrEmpty(friendRichPresence))
		{
			return null;
		}
		return friendRichPresence;
	}

	public bool InviteToGame(string Text)
	{
		return SteamFriends.Internal.InviteUserToGame(Id, Text);
	}

	public bool SendMessage(string message)
	{
		return SteamFriends.Internal.ReplyToFriendMessage(Id, message);
	}

	public async Task<bool> RequestUserStatsAsync()
	{
		UserStatsReceived_t? userStatsReceived_t = await SteamUserStats.Internal.RequestUserStats(Id);
		return userStatsReceived_t.HasValue && userStatsReceived_t.Value.Result == Result.OK;
	}

	public float GetStatFloat(string statName, float defult = 0f)
	{
		float pData = defult;
		if (!SteamUserStats.Internal.GetUserStat(Id, statName, ref pData))
		{
			return defult;
		}
		return pData;
	}

	public int GetStatInt(string statName, int defult = 0)
	{
		int pData = defult;
		if (!SteamUserStats.Internal.GetUserStat(Id, statName, ref pData))
		{
			return defult;
		}
		return pData;
	}

	public bool GetAchievement(string statName, bool defult = false)
	{
		bool pbAchieved = defult;
		if (!SteamUserStats.Internal.GetUserAchievement(Id, statName, ref pbAchieved))
		{
			return defult;
		}
		return pbAchieved;
	}

	public DateTime GetAchievementUnlockTime(string statName)
	{
		bool pbAchieved = false;
		uint punUnlockTime = 0u;
		if (!SteamUserStats.Internal.GetUserAchievementAndUnlockTime(Id, statName, ref pbAchieved, ref punUnlockTime) || !pbAchieved)
		{
			return DateTime.MinValue;
		}
		return Epoch.ToDateTime(punUnlockTime);
	}
}


public struct GamePhaseRecordingInfo
{
	public string PhaseId;

	public ulong RecordingMs;

	public ulong LongestClipMs;

	public uint ClipCount;

	public uint ScreenshotCount;
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using Steamworks;
using Steamworks.Data;

public class InventoryDef : IEquatable<InventoryDef>
{
	[CompilerGenerated]
	private sealed class <get_Properties>d__34 : IEnumerable<KeyValuePair<string, string>>, IEnumerable, IEnumerator<KeyValuePair<string, string>>, IDisposable, IEnumerator
	{
		private int <>1__state;

		private KeyValuePair<string, string> <>2__current;

		private int <>l__initialThreadId;

		public InventoryDef <>4__this;

		private string[] <>7__wrap1;

		private int <>7__wrap2;

		KeyValuePair<string, string> IEnumerator<KeyValuePair<string, string>>.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		object IEnumerator.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		[DebuggerHidden]
		public <get_Properties>d__34(int <>1__state)
		{
			this.<>1__state = <>1__state;
			<>l__initialThreadId = Environment.CurrentManagedThreadId;
		}

		[DebuggerHidden]
		void IDisposable.Dispose()
		{
			<>7__wrap1 = null;
			<>1__state = -2;
		}

		private bool MoveNext()
		{
			int num = <>1__state;
			InventoryDef inventoryDef = <>4__this;
			switch (num)
			{
			default:
				return false;
			case 0:
			{
				<>1__state = -1;
				string[] array = inventoryDef.GetProperty(null).Split(new char[1] { ',' });
				<>7__wrap1 = array;
				<>7__wrap2 = 0;
				break;
			}
			case 1:
				<>1__state = -1;
				<>7__wrap2++;
				break;
			}
			if (<>7__wrap2 < <>7__wrap1.Length)
			{
				string text = <>7__wrap1[<>7__wrap2];
				<>2__current = new KeyValuePair<string, string>(text, inventoryDef.GetProperty(text));
				<>1__state = 1;
				return true;
			}
			<>7__wrap1 = null;
			return false;
		}

		bool IEnumerator.MoveNext()
		{
			//ILSpy generated this explicit interface implementation from .override directive in MoveNext
			return this.MoveNext();
		}

		[DebuggerHidden]
		void IEnumerator.Reset()
		{
			throw new NotSupportedException();
		}

		[DebuggerHidden]
		IEnumerator<KeyValuePair<string, string>> IEnumerable<KeyValuePair<string, string>>.GetEnumerator()
		{
			<get_Properties>d__34 result;
			if (<>1__state == -2 && <>l__initialThreadId == Environment.CurrentManagedThreadId)
			{
				<>1__state = 0;
				result = this;
			}
			else
			{
				result = new <get_Properties>d__34(0)
				{
					<>4__this = <>4__this
				};
			}
			return result;
		}

		[DebuggerHidden]
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<KeyValuePair<string, string>>)this).GetEnumerator();
		}
	}

	internal InventoryDefId _id;

	internal Dictionary<string, string> _properties;

	private InventoryRecipe[] _recContaining;

	public int Id => _id.Value;

	public string Name => GetProperty("name");

	public string Description => GetProperty("description");

	public string IconUrl => GetProperty("icon_url");

	public string IconUrlLarge => GetProperty("icon_url_large");

	public string PriceCategory => GetProperty("price_category");

	public string Type => GetProperty("type");

	public bool IsGenerator => Type == "generator";

	public string ExchangeSchema => GetProperty("exchange");

	public bool Marketable => GetBoolProperty("marketable");

	public bool Tradable => GetBoolProperty("tradable");

	public DateTime Created => GetProperty<DateTime>("timestamp");

	public DateTime Modified => GetProperty<DateTime>("modified");

	public IEnumerable<KeyValuePair<string, string>> Properties
	{
		[IteratorStateMachine(typeof(<get_Properties>d__34))]
		get
		{
			//yield-return decompiler failed: Unexpected instruction in Iterator.Dispose()
			return new <get_Properties>d__34(-2)
			{
				<>4__this = this
			};
		}
	}

	public int LocalPrice
	{
		get
		{
			ulong pCurrentPrice = 0uL;
			ulong pBasePrice = 0uL;
			if (!SteamInventory.Internal.GetItemPrice(Id, ref pCurrentPrice, ref pBasePrice))
			{
				return 0;
			}
			return (int)pCurrentPrice;
		}
	}

	public string LocalPriceFormatted => Utility.FormatPrice(SteamInventory.Currency, (double)LocalPrice / 100.0);

	public int LocalBasePrice
	{
		get
		{
			ulong pCurrentPrice = 0uL;
			ulong pBasePrice = 0uL;
			if (!SteamInventory.Internal.GetItemPrice(Id, ref pCurrentPrice, ref pBasePrice))
			{
				return 0;
			}
			return (int)pBasePrice;
		}
	}

	public string LocalBasePriceFormatted => Utility.FormatPrice(SteamInventory.Currency, (double)LocalPrice / 100.0);

	public InventoryDef(InventoryDefId defId)
	{
		_id = defId;
	}

	public InventoryRecipe[] GetRecipes()
	{
		if (string.IsNullOrEmpty(ExchangeSchema))
		{
			return null;
		}
		return (from x in ExchangeSchema.Split(new char[1] { ';' }, StringSplitOptions.RemoveEmptyEntries)
			select InventoryRecipe.FromString(x, this)).ToArray();
	}

	public string GetProperty(string name)
	{
		if (_properties != null && _properties.TryGetValue(name, out var value))
		{
			return value;
		}
		if (!SteamInventory.Internal.GetItemDefinitionProperty(Id, name, out var pchValueBuffer))
		{
			return null;
		}
		if (name == null)
		{
			return pchValueBuffer;
		}
		if (_properties == null)
		{
			_properties = new Dictionary<string, string>();
		}
		_properties[name] = pchValueBuffer;
		return pchValueBuffer;
	}

	public bool GetBoolProperty(string name)
	{
		string property = GetProperty(name);
		if (property.Length == 0)
		{
			return false;
		}
		if (property[0] == '0' || property[0] == 'F' || property[0] == 'f')
		{
			return false;
		}
		return true;
	}

	public T GetProperty<T>(string name)
	{
		string property = GetProperty(name);
		if (string.IsNullOrEmpty(property))
		{
			return default(T);
		}
		try
		{
			return (T)Convert.ChangeType(property, typeof(T));
		}
		catch (Exception)
		{
			return default(T);
		}
	}

	public InventoryRecipe[] GetRecipesContainingThis()
	{
		if (_recContaining != null)
		{
			return _recContaining;
		}
		IEnumerable<InventoryRecipe> source = (from x in SteamInventory.Definitions
			select x.GetRecipes() into x
			where x != null
			select x).SelectMany((InventoryRecipe[] x) => x);
		_recContaining = source.Where((InventoryRecipe x) => x.ContainsIngredient(this)).ToArray();
		return _recContaining;
	}

	public static bool operator ==(InventoryDef a, InventoryDef b)
	{
		return a?.Equals(b) ?? ((object)b == null);
	}

	public static bool operator !=(InventoryDef a, InventoryDef b)
	{
		return !(a == b);
	}

	public override bool Equals(object p)
	{
		return Equals((InventoryDef)p);
	}

	public override int GetHashCode()
	{
		return Id.GetHashCode();
	}

	public bool Equals(InventoryDef p)
	{
		if (p == null)
		{
			return false;
		}
		return p.Id == Id;
	}
}


using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;

public struct InventoryItem : IEquatable<InventoryItem>
{
	public struct Amount
	{
		public InventoryItem Item;

		public int Quantity;
	}

	internal InventoryItemId _id;

	internal InventoryDefId _def;

	internal SteamItemFlags _flags;

	internal ushort _quantity;

	internal Dictionary<string, string> _properties;

	public InventoryItemId Id => _id;

	public InventoryDefId DefId => _def;

	public int Quantity => _quantity;

	public InventoryDef Def => SteamInventory.FindDefinition(DefId);

	public Dictionary<string, string> Properties => _properties;

	public bool IsNoTrade => _flags.HasFlag(SteamItemFlags.NoTrade);

	public bool IsRemoved => _flags.HasFlag(SteamItemFlags.Removed);

	public bool IsConsumed => _flags.HasFlag(SteamItemFlags.Consumed);

	public DateTime Acquired
	{
		get
		{
			if (Properties == null)
			{
				return DateTime.UtcNow;
			}
			if (Properties.TryGetValue("acquired", out var value))
			{
				int year = int.Parse(value.Substring(0, 4));
				int month = int.Parse(value.Substring(4, 2));
				int day = int.Parse(value.Substring(6, 2));
				int hour = int.Parse(value.Substring(9, 2));
				int minute = int.Parse(value.Substring(11, 2));
				int second = int.Parse(value.Substring(13, 2));
				return new DateTime(year, month, day, hour, minute, second, DateTimeKind.Utc);
			}
			return DateTime.UtcNow;
		}
	}

	public string Origin
	{
		get
		{
			if (Properties == null)
			{
				return null;
			}
			if (Properties.TryGetValue("origin", out var value))
			{
				return value;
			}
			return null;
		}
	}

	public async Task<InventoryResult?> ConsumeAsync(int amount = 1)
	{
		SteamInventoryResult_t pResultHandle = Defines.k_SteamInventoryResultInvalid;
		if (!SteamInventory.Internal.ConsumeItem(ref pResultHandle, Id, (uint)amount))
		{
			return null;
		}
		return await InventoryResult.GetAsync(pResultHandle);
	}

	public async Task<InventoryResult?> SplitStackAsync(int quantity = 1)
	{
		SteamInventoryResult_t pResultHandle = Defines.k_SteamInventoryResultInvalid;
		if (!SteamInventory.Internal.TransferItemQuantity(ref pResultHandle, Id, (uint)quantity, ulong.MaxValue))
		{
			return null;
		}
		return await InventoryResult.GetAsync(pResultHandle);
	}

	public async Task<InventoryResult?> AddAsync(InventoryItem add, int quantity = 1)
	{
		SteamInventoryResult_t pResultHandle = Defines.k_SteamInventoryResultInvalid;
		if (!SteamInventory.Internal.TransferItemQuantity(ref pResultHandle, add.Id, (uint)quantity, Id))
		{
			return null;
		}
		return await InventoryResult.GetAsync(pResultHandle);
	}

	internal static InventoryItem From(SteamItemDetails_t details)
	{
		InventoryItem result = default(InventoryItem);
		result._id = details.ItemId;
		result._def = details.Definition;
		result._flags = (SteamItemFlags)details.Flags;
		result._quantity = details.Quantity;
		return result;
	}

	internal static Dictionary<string, string> GetProperties(SteamInventoryResult_t result, int index)
	{
		if (!SteamInventory.Internal.GetResultItemProperty(result, (uint)index, null, out var pchValueBuffer))
		{
			return null;
		}
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		string[] array = pchValueBuffer.Split(new char[1] { ',' });
		foreach (string text in array)
		{
			if (SteamInventory.Internal.GetResultItemProperty(result, (uint)index, text, out var pchValueBuffer2))
			{
				dictionary.Add(text, pchValueBuffer2);
			}
		}
		return dictionary;
	}

	public static bool operator ==(InventoryItem a, InventoryItem b)
	{
		return a._id == b._id;
	}

	public static bool operator !=(InventoryItem a, InventoryItem b)
	{
		return a._id != b._id;
	}

	public override bool Equals(object p)
	{
		return Equals((InventoryItem)p);
	}

	public override int GetHashCode()
	{
		return _id.GetHashCode();
	}

	public bool Equals(InventoryItem p)
	{
		return p._id == _id;
	}
}


using System;
using System.Linq;
using Steamworks;

public struct InventoryRecipe : IEquatable<InventoryRecipe>
{
	public struct Ingredient
	{
		public int DefinitionId;

		public InventoryDef Definition;

		public int Count;

		internal static Ingredient FromString(string part)
		{
			Ingredient result = default(Ingredient);
			result.Count = 1;
			try
			{
				if (part.Contains("x"))
				{
					int num = part.IndexOf('x');
					int result2 = 0;
					if (int.TryParse(part.Substring(num + 1), out result2))
					{
						result.Count = result2;
					}
					part = part.Substring(0, num);
				}
				result.DefinitionId = int.Parse(part);
				result.Definition = SteamInventory.FindDefinition(result.DefinitionId);
				return result;
			}
			catch (Exception)
			{
				return result;
			}
		}
	}

	public InventoryDef Result;

	public Ingredient[] Ingredients;

	public string Source;

	internal static InventoryRecipe FromString(string part, InventoryDef Result)
	{
		InventoryRecipe inventoryRecipe = default(InventoryRecipe);
		inventoryRecipe.Result = Result;
		inventoryRecipe.Source = part;
		InventoryRecipe result = inventoryRecipe;
		string[] source = part.Split(new char[1] { ',' }, StringSplitOptions.RemoveEmptyEntries);
		result.Ingredients = (from x in source
			select Ingredient.FromString(x) into x
			where x.DefinitionId != 0
			select x).ToArray();
		return result;
	}

	internal bool ContainsIngredient(InventoryDef inventoryDef)
	{
		return Ingredients.Any((Ingredient x) => x.DefinitionId == inventoryDef.Id);
	}

	public static bool operator ==(InventoryRecipe a, InventoryRecipe b)
	{
		return a.GetHashCode() == b.GetHashCode();
	}

	public static bool operator !=(InventoryRecipe a, InventoryRecipe b)
	{
		return a.GetHashCode() != b.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((InventoryRecipe)p);
	}

	public override int GetHashCode()
	{
		return Source.GetHashCode();
	}

	public bool Equals(InventoryRecipe p)
	{
		return p.GetHashCode() == GetHashCode();
	}
}


using System;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;

public struct InventoryResult : IDisposable
{
	internal SteamInventoryResult_t _id;

	public bool Expired { get; internal set; }

	public int ItemCount
	{
		get
		{
			uint punOutItemsArraySize = 0u;
			if (!SteamInventory.Internal.GetResultItems(_id, null, ref punOutItemsArraySize))
			{
				return 0;
			}
			return (int)punOutItemsArraySize;
		}
	}

	internal InventoryResult(SteamInventoryResult_t id, bool expired)
	{
		_id = id;
		Expired = expired;
	}

	public bool BelongsTo(SteamId steamId)
	{
		return SteamInventory.Internal.CheckResultSteamID(_id, steamId);
	}

	public InventoryItem[] GetItems(bool includeProperties = false)
	{
		uint punOutItemsArraySize = (uint)ItemCount;
		if (punOutItemsArraySize == 0)
		{
			return null;
		}
		SteamItemDetails_t[] array = new SteamItemDetails_t[punOutItemsArraySize];
		if (!SteamInventory.Internal.GetResultItems(_id, array, ref punOutItemsArraySize))
		{
			return null;
		}
		InventoryItem[] array2 = new InventoryItem[punOutItemsArraySize];
		for (int i = 0; i < punOutItemsArraySize; i++)
		{
			InventoryItem inventoryItem = InventoryItem.From(array[i]);
			if (includeProperties)
			{
				inventoryItem._properties = InventoryItem.GetProperties(_id, i);
			}
			array2[i] = inventoryItem;
		}
		return array2;
	}

	public void Dispose()
	{
		if (_id.Value != -1)
		{
			SteamInventory.Internal.DestroyResult(_id);
		}
	}

	internal static async Task<InventoryResult?> GetAsync(SteamInventoryResult_t sresult)
	{
		Result _result = Result.Pending;
		while (true)
		{
			switch (_result)
			{
			case Result.Pending:
				_result = SteamInventory.Internal.GetResultStatus(sresult);
				await Task.Delay(10);
				break;
			default:
				return null;
			case Result.OK:
			case Result.Expired:
				return new InventoryResult(sresult, _result == Result.Expired);
			}
		}
	}

	public unsafe byte[] Serialize()
	{
		uint punOutBufferSize = 0u;
		if (!SteamInventory.Internal.SerializeResult(_id, IntPtr.Zero, ref punOutBufferSize))
		{
			return null;
		}
		byte[] array = new byte[punOutBufferSize];
		fixed (byte* ptr = array)
		{
			if (!SteamInventory.Internal.SerializeResult(_id, (IntPtr)ptr, ref punOutBufferSize))
			{
				return null;
			}
		}
		return array;
	}
}


using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;

public struct PartyBeacon
{
	internal PartyBeaconID_t Id;

	private static ISteamParties Internal => SteamParties.Internal;

	public SteamId Owner
	{
		get
		{
			SteamId pSteamIDBeaconOwner = default(SteamId);
			SteamPartyBeaconLocation_t pLocation = default(SteamPartyBeaconLocation_t);
			Internal.GetBeaconDetails(Id, ref pSteamIDBeaconOwner, ref pLocation, out var _);
			return pSteamIDBeaconOwner;
		}
	}

	public string MetaData
	{
		get
		{
			SteamId pSteamIDBeaconOwner = default(SteamId);
			SteamPartyBeaconLocation_t pLocation = default(SteamPartyBeaconLocation_t);
			Internal.GetBeaconDetails(Id, ref pSteamIDBeaconOwner, ref pLocation, out var pchMetadata);
			return pchMetadata;
		}
	}

	public async Task<string> JoinAsync()
	{
		JoinPartyCallback_t? joinPartyCallback_t = await Internal.JoinParty(Id);
		if (!joinPartyCallback_t.HasValue || joinPartyCallback_t.Value.Result != Result.OK)
		{
			return null;
		}
		return joinPartyCallback_t.Value.ConnectStringUTF8();
	}

	public void OnReservationCompleted(SteamId steamid)
	{
		Internal.OnReservationCompleted(Id, steamid);
	}

	public void CancelReservation(SteamId steamid)
	{
		Internal.CancelReservation(Id, steamid);
	}

	public bool Destroy()
	{
		return Internal.DestroyBeacon(Id);
	}
}


using System.Net;
using Steamworks;

public struct SteamServerInit
{
	public IPAddress IpAddress;

	public ushort GamePort;

	public ushort QueryPort;

	public bool Secure;

	public string VersionString;

	public string ModDir;

	public string GameDescription;

	public bool DedicatedServer;

	public SteamServerInit(string modDir, string gameDesc)
	{
		DedicatedServer = true;
		ModDir = modDir;
		GameDescription = gameDesc;
		GamePort = 27015;
		QueryPort = 27016;
		Secure = true;
		VersionString = "1.0.0.0";
		IpAddress = null;
	}

	public SteamServerInit WithQueryShareGamePort()
	{
		QueryPort = ushort.MaxValue;
		return this;
	}
}


using Steamworks;

public struct SteamId
{
	public ulong Value;

	public uint AccountId => (uint)(Value & 0xFFFFFFFFu);

	public bool IsValid => Value != 0;

	public static implicit operator SteamId(ulong value)
	{
		SteamId result = default(SteamId);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(SteamId value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}
}


using System;

internal static class Epoch
{
	private static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);

	public static int Current => (int)DateTime.UtcNow.Subtract(epoch).TotalSeconds;

	public static DateTime ToDateTime(decimal unixTime)
	{
		DateTime dateTime = epoch;
		return dateTime.AddSeconds((long)unixTime);
	}

	public static uint FromDateTime(DateTime dt)
	{
		return (uint)dt.Subtract(epoch).TotalSeconds;
	}
}


using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text;
using Steamworks;

internal static class Helpers
{
	internal struct Memory : IDisposable
	{
		private const int MaxBagSize = 4;

		private static readonly Queue<IntPtr> BufferBag = new Queue<IntPtr>();

		public IntPtr Ptr { get; private set; }

		public static implicit operator IntPtr(in Memory m)
		{
			return m.Ptr;
		}

		internal unsafe static Memory Take()
		{
			IntPtr intPtr;
			lock (BufferBag)
			{
				intPtr = ((BufferBag.Count > 0) ? BufferBag.Dequeue() : Marshal.AllocHGlobal(32768));
			}
			*(sbyte*)(void*)intPtr = 0;
			Memory result = default(Memory);
			result.Ptr = intPtr;
			return result;
		}

		public void Dispose()
		{
			if (Ptr == IntPtr.Zero)
			{
				return;
			}
			lock (BufferBag)
			{
				if (BufferBag.Count < 4)
				{
					BufferBag.Enqueue(Ptr);
				}
				else
				{
					Marshal.FreeHGlobal(Ptr);
				}
			}
			Ptr = IntPtr.Zero;
		}
	}

	public const int MemoryBufferSize = 32768;

	private static byte[][] BufferPool = new byte[4][];

	private static int BufferPoolIndex;

	public static Memory TakeMemory()
	{
		return Memory.Take();
	}

	public static byte[] TakeBuffer(int minSize)
	{
		lock (BufferPool)
		{
			BufferPoolIndex++;
			if (BufferPoolIndex >= BufferPool.Length)
			{
				BufferPoolIndex = 0;
			}
			if (BufferPool[BufferPoolIndex] == null)
			{
				BufferPool[BufferPoolIndex] = new byte[262144];
			}
			if (BufferPool[BufferPoolIndex].Length < minSize)
			{
				BufferPool[BufferPoolIndex] = new byte[minSize + 1024];
			}
			return BufferPool[BufferPoolIndex];
		}
	}

	internal unsafe static string MemoryToString(IntPtr ptr)
	{
		int num = 0;
		for (num = 0; num < 32768 && ((byte*)(void*)ptr)[num] != 0; num++)
		{
		}
		if (num == 0)
		{
			return string.Empty;
		}
		return Utility.Utf8NoBom.GetString((byte*)(void*)ptr, num);
	}

	internal static string BuildVersionString(params string[] interfaceVersions)
	{
		StringBuilder stringBuilder = new StringBuilder();
		foreach (string value in interfaceVersions)
		{
			stringBuilder.Append(value).Append('\0');
		}
		stringBuilder.Append('\0');
		return stringBuilder.ToString();
	}
}


using System;

internal class MonoPInvokeCallbackAttribute : Attribute
{
}


using System;

internal class PreserveAttribute : Attribute
{
}


using System.Runtime.InteropServices;

internal static class Platform
{
	public const int StructPlatformPackSize = 4;

	public const string LibraryName = "libsteam_api";

	public const CallingConvention CC = CallingConvention.Cdecl;

	public const int StructPackSize = 4;
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;

internal static class SourceServerQuery
{
	private static readonly byte[] A2S_SERVERQUERY_GETCHALLENGE = new byte[5] { 85, 255, 255, 255, 255 };

	private const byte A2S_RULES = 86;

	private static readonly Dictionary<IPEndPoint, Task<Dictionary<string, string>>> PendingQueries = new Dictionary<IPEndPoint, Task<Dictionary<string, string>>>();

	internal static Task<Dictionary<string, string>> GetRules(ServerInfo server)
	{
		IPEndPoint endpoint = new IPEndPoint(server.Address, server.QueryPort);
		lock (PendingQueries)
		{
			if (PendingQueries.TryGetValue(endpoint, out var value))
			{
				return value;
			}
			Task<Dictionary<string, string>> task = GetRulesImpl(endpoint).ContinueWith(delegate(Task<Dictionary<string, string>> t)
			{
				lock (PendingQueries)
				{
					PendingQueries.Remove(endpoint);
					return t;
				}
			}).Unwrap();
			PendingQueries.Add(endpoint, task);
			return task;
		}
	}

	private static async Task<Dictionary<string, string>> GetRulesImpl(IPEndPoint endpoint)
	{
		try
		{
			using UdpClient client = new UdpClient();
			client.Client.SendTimeout = 3000;
			client.Client.ReceiveTimeout = 3000;
			client.Connect(endpoint);
			return await GetRules(client);
		}
		catch (Exception)
		{
			return null;
		}
	}

	private static async Task<Dictionary<string, string>> GetRules(UdpClient client)
	{
		byte[] array = await GetChallengeData(client);
		array[0] = 86;
		await Send(client, array);
		byte[] buffer = await Receive(client);
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		using BinaryReader binaryReader = new BinaryReader(new MemoryStream(buffer));
		if (binaryReader.ReadByte() != 69)
		{
			throw new Exception("Invalid data received in response to A2S_RULES request");
		}
		ushort num = binaryReader.ReadUInt16();
		for (int i = 0; i < num; i++)
		{
			dictionary.Add(binaryReader.ReadNullTerminatedUTF8String(), binaryReader.ReadNullTerminatedUTF8String());
		}
		return dictionary;
	}

	private static async Task<byte[]> Receive(UdpClient client)
	{
		byte[][] packets = null;
		do
		{
			byte[] buffer = (await client.ReceiveAsync()).Buffer;
			using BinaryReader binaryReader = new BinaryReader(new MemoryStream(buffer));
			switch (binaryReader.ReadInt32())
			{
			case -1:
			{
				byte[] array2 = new byte[buffer.Length - binaryReader.BaseStream.Position];
				Buffer.BlockCopy(buffer, (int)binaryReader.BaseStream.Position, array2, 0, array2.Length);
				return array2;
			}
			case -2:
			{
				binaryReader.ReadInt32();
				byte b = binaryReader.ReadByte();
				byte b2 = binaryReader.ReadByte();
				binaryReader.ReadInt32();
				if (packets == null)
				{
					packets = new byte[b2][];
				}
				byte[] array = new byte[buffer.Length - binaryReader.BaseStream.Position];
				Buffer.BlockCopy(buffer, (int)binaryReader.BaseStream.Position, array, 0, array.Length);
				packets[b] = array;
				break;
			}
			default:
				throw new Exception("Invalid Header");
			}
		}
		while (packets.Any((byte[] p) => p == null));
		return Combine(packets);
	}

	private static async Task<byte[]> GetChallengeData(UdpClient client)
	{
		await Send(client, A2S_SERVERQUERY_GETCHALLENGE);
		byte[] obj = await Receive(client);
		if (obj[0] != 65)
		{
			throw new Exception("Invalid Challenge");
		}
		return obj;
	}

	private static async Task Send(UdpClient client, byte[] message)
	{
		byte[] array = new byte[message.Length + 4];
		array[0] = byte.MaxValue;
		array[1] = byte.MaxValue;
		array[2] = byte.MaxValue;
		array[3] = byte.MaxValue;
		Buffer.BlockCopy(message, 0, array, 4, message.Length);
		await client.SendAsync(array, message.Length + 4);
	}

	private static byte[] Combine(byte[][] arrays)
	{
		byte[] array = new byte[arrays.Sum((byte[] a) => a.Length)];
		int num = 0;
		foreach (byte[] array2 in arrays)
		{
			Buffer.BlockCopy(array2, 0, array, num, array2.Length);
			num += array2.Length;
		}
		return array;
	}
}


using System;

internal abstract class SteamInterface
{
	public IntPtr Self;

	public IntPtr SelfGlobal;

	public IntPtr SelfServer;

	public IntPtr SelfClient;

	public bool IsValid => Self != IntPtr.Zero;

	public bool IsServer { get; private set; }

	public virtual IntPtr GetUserInterfacePointer()
	{
		return IntPtr.Zero;
	}

	public virtual IntPtr GetServerInterfacePointer()
	{
		return IntPtr.Zero;
	}

	public virtual IntPtr GetGlobalInterfacePointer()
	{
		return IntPtr.Zero;
	}

	internal void SetupInterface(bool gameServer)
	{
		if (Self != IntPtr.Zero)
		{
			return;
		}
		IsServer = gameServer;
		SelfGlobal = GetGlobalInterfacePointer();
		Self = SelfGlobal;
		if (!(Self != IntPtr.Zero))
		{
			if (gameServer)
			{
				SelfServer = GetServerInterfacePointer();
				Self = SelfServer;
			}
			else
			{
				SelfClient = GetUserInterfacePointer();
				Self = SelfClient;
			}
		}
	}

	internal void ShutdownInterface()
	{
		Self = IntPtr.Zero;
	}
}


public abstract class SteamClass
{
	internal abstract bool InitializeInterface(bool server);

	internal abstract void DestroyInterface(bool server);
}


using Steamworks;

public class SteamSharedClass<T> : SteamClass
{
	internal static SteamInterface InterfaceClient;

	internal static SteamInterface InterfaceServer;

	internal static SteamInterface Interface => InterfaceClient ?? InterfaceServer;

	internal override bool InitializeInterface(bool server)
	{
		return false;
	}

	internal virtual void SetInterface(bool server, SteamInterface iface)
	{
		if (server)
		{
			InterfaceServer = iface;
		}
		if (!server)
		{
			InterfaceClient = iface;
		}
	}

	internal override void DestroyInterface(bool server)
	{
		if (!server)
		{
			InterfaceClient = null;
		}
		if (server)
		{
			InterfaceServer = null;
		}
	}
}


using System;
using Steamworks;

public class SteamClientClass<T> : SteamClass
{
	internal static SteamInterface Interface;

	internal override bool InitializeInterface(bool server)
	{
		return false;
	}

	internal virtual void SetInterface(bool server, SteamInterface iface)
	{
		if (server)
		{
			throw new NotSupportedException();
		}
		Interface = iface;
	}

	internal override void DestroyInterface(bool server)
	{
		Interface = null;
	}
}


using System;
using Steamworks;

public class SteamServerClass<T> : SteamClass
{
	internal static SteamInterface Interface;

	internal override bool InitializeInterface(bool server)
	{
		return false;
	}

	internal virtual void SetInterface(bool server, SteamInterface iface)
	{
		if (!server)
		{
			throw new NotSupportedException();
		}
		Interface = iface;
	}

	internal override void DestroyInterface(bool server)
	{
		Interface = null;
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;

internal struct Utf8StringToNative : IDisposable
{
	public IntPtr Pointer { get; private set; }

	public unsafe Utf8StringToNative(string value)
	{
		if (value == null)
		{
			Pointer = IntPtr.Zero;
			return;
		}
		fixed (char* chars = value)
		{
			int byteCount = Utility.Utf8NoBom.GetByteCount(value);
			IntPtr intPtr = Marshal.AllocHGlobal(byteCount + 1);
			int bytes = Utility.Utf8NoBom.GetBytes(chars, value.Length, (byte*)(void*)intPtr, byteCount + 1);
			((byte*)(void*)intPtr)[bytes] = 0;
			Pointer = intPtr;
		}
	}

	public void Dispose()
	{
		if (Pointer != IntPtr.Zero)
		{
			Marshal.FreeHGlobal(Pointer);
			Pointer = IntPtr.Zero;
		}
	}
}


using System;
using Steamworks;

internal struct Utf8StringPointer
{
	internal IntPtr ptr;

	public unsafe static implicit operator string(Utf8StringPointer p)
	{
		if (p.ptr == IntPtr.Zero)
		{
			return null;
		}
		byte* ptr = (byte*)(void*)p.ptr;
		int i;
		for (i = 0; i < 67108864 && ptr[i] != 0; i++)
		{
		}
		return Utility.Utf8NoBom.GetString(ptr, i);
	}
}


using System;
using System.IO;
using System.Net;
using System.Runtime.InteropServices;
using System.Text;

public static class Utility
{
	public static readonly Encoding Utf8NoBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false);

	private static readonly byte[] readBuffer = new byte[8192];

	internal static T ToType<T>(this IntPtr ptr)
	{
		if (ptr == IntPtr.Zero)
		{
			return default(T);
		}
		return (T)Marshal.PtrToStructure(ptr, typeof(T));
	}

	internal static object ToType(this IntPtr ptr, Type t)
	{
		if (ptr == IntPtr.Zero)
		{
			return null;
		}
		return Marshal.PtrToStructure(ptr, t);
	}

	internal static uint Swap(uint x)
	{
		return ((x & 0xFF) << 24) + ((x & 0xFF00) << 8) + ((x & 0xFF0000) >> 8) + ((x & 0xFF000000u) >> 24);
	}

	public static uint IpToInt32(this IPAddress ipAddress)
	{
		return Swap((uint)ipAddress.Address);
	}

	public static IPAddress Int32ToIp(uint ipAddress)
	{
		return new IPAddress(Swap(ipAddress));
	}

	public static string FormatPrice(string currency, double price)
	{
		string text = price.ToString("0.00");
		return currency switch
		{
			"AED" => text + ".", 
			"ARS" => "$" + text + " ARS", 
			"AUD" => "A$" + text, 
			"BRL" => "R$" + text, 
			"CAD" => "C$" + text, 
			"CHF" => "Fr. " + text, 
			"CLP" => "$" + text + " CLP", 
			"CNY" => text + "", 
			"COP" => "COL$ " + text, 
			"CRC" => "" + text, 
			"EUR" => "" + text, 
			"SEK" => text + "kr", 
			"GBP" => "" + text, 
			"HKD" => "HK$" + text, 
			"ILS" => "" + text, 
			"IDR" => "Rp" + text, 
			"INR" => "" + text, 
			"JPY" => "" + text, 
			"KRW" => "" + text, 
			"KWD" => "KD " + text, 
			"KZT" => text + "", 
			"MXN" => "Mex$" + text, 
			"MYR" => "RM " + text, 
			"NOK" => text + " kr", 
			"NZD" => "$" + text + " NZD", 
			"PEN" => "S/. " + text, 
			"PHP" => "" + text, 
			"PLN" => text + "z", 
			"QAR" => "QR " + text, 
			"RUB" => text + "", 
			"SAR" => "SR " + text, 
			"SGD" => "S$" + text, 
			"THB" => "" + text, 
			"TRY" => "" + text, 
			"TWD" => "NT$ " + text, 
			"UAH" => "" + text, 
			"USD" => "$" + text, 
			"UYU" => "$U " + text, 
			"VND" => "" + text, 
			"ZAR" => "R " + text, 
			_ => text + " " + currency, 
		};
	}

	public static string ReadNullTerminatedUTF8String(this BinaryReader br)
	{
		lock (readBuffer)
		{
			int num = 0;
			byte b;
			while ((b = br.ReadByte()) != 0 && num < readBuffer.Length)
			{
				readBuffer[num] = b;
				num++;
			}
			return Utf8NoBom.GetString(readBuffer, 0, num);
		}
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks.Data;
using Steamworks.Ugc;

internal struct SteamParamStringArray : IDisposable
{
	public SteamParamStringArray_t Value;

	private IntPtr[] NativeStrings;

	private IntPtr NativeArray;

	public static SteamParamStringArray From(string[] array)
	{
		SteamParamStringArray result = default(SteamParamStringArray);
		result.NativeStrings = new IntPtr[array.Length];
		for (int i = 0; i < result.NativeStrings.Length; i++)
		{
			result.NativeStrings[i] = Marshal.StringToHGlobalAnsi(array[i]);
		}
		int cb = Marshal.SizeOf(typeof(IntPtr)) * result.NativeStrings.Length;
		result.NativeArray = Marshal.AllocHGlobal(cb);
		Marshal.Copy(result.NativeStrings, 0, result.NativeArray, result.NativeStrings.Length);
		result.Value = new SteamParamStringArray_t
		{
			Strings = result.NativeArray,
			NumStrings = array.Length
		};
		return result;
	}

	public void Dispose()
	{
		IntPtr[] nativeStrings = NativeStrings;
		for (int i = 0; i < nativeStrings.Length; i++)
		{
			Marshal.FreeHGlobal(nativeStrings[i]);
		}
		Marshal.FreeHGlobal(NativeArray);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;
using Steamworks.Ugc;

public struct Editor
{
	private PublishedFileId fileId;

	private bool creatingNew;

	private WorkshopFileType creatingType;

	private AppId consumerAppId;

	private string Title;

	private string Description;

	private string MetaData;

	private string ChangeLog;

	private string Language;

	private string PreviewFile;

	private Dictionary<string, ItemPreviewType> AdditionalPreviewFiles;

	private List<int> RemovePreviewFiles;

	private DirectoryInfo ContentFolder;

	private RemoteStoragePublishedFileVisibility? Visibility;

	private List<string> Tags;

	private Dictionary<string, List<string>> KeyValueTags;

	private HashSet<string> KeyValueTagsToRemove;

	public static Editor NewCommunityFile => new Editor(WorkshopFileType.First);

	public static Editor NewCollection => new Editor(WorkshopFileType.Collection);

	public static Editor NewMicrotransactionFile => new Editor(WorkshopFileType.Microtransaction);

	public static Editor NewGameManagedFile => new Editor(WorkshopFileType.GameManagedItem);

	internal Editor(WorkshopFileType filetype)
	{
		this = default(Editor);
		creatingNew = true;
		creatingType = filetype;
	}

	public Editor(PublishedFileId fileId)
	{
		this = default(Editor);
		this.fileId = fileId;
	}

	public Editor ForAppId(AppId id)
	{
		consumerAppId = id;
		return this;
	}

	public Editor WithTitle(string t)
	{
		Title = t;
		return this;
	}

	public Editor WithDescription(string t)
	{
		Description = t;
		return this;
	}

	public Editor WithMetaData(string t)
	{
		MetaData = t;
		return this;
	}

	public Editor WithChangeLog(string t)
	{
		ChangeLog = t;
		return this;
	}

	public Editor InLanguage(string t)
	{
		Language = t;
		return this;
	}

	public Editor WithPreviewFile(string t)
	{
		PreviewFile = t;
		return this;
	}

	public Editor AddAdditionalPreviewFile(string f, ItemPreviewType t)
	{
		if (AdditionalPreviewFiles == null)
		{
			AdditionalPreviewFiles = new Dictionary<string, ItemPreviewType>();
		}
		AdditionalPreviewFiles.Add(f, t);
		return this;
	}

	public Editor RemoveAdditionalPreviewFile(int i)
	{
		if (RemovePreviewFiles == null)
		{
			RemovePreviewFiles = new List<int>();
		}
		RemovePreviewFiles.Add(i);
		return this;
	}

	public Editor WithContent(DirectoryInfo t)
	{
		ContentFolder = t;
		return this;
	}

	public Editor WithContent(string folderName)
	{
		return WithContent(new DirectoryInfo(folderName));
	}

	public Editor WithPublicVisibility()
	{
		Visibility = RemoteStoragePublishedFileVisibility.Public;
		return this;
	}

	public Editor WithFriendsOnlyVisibility()
	{
		Visibility = RemoteStoragePublishedFileVisibility.FriendsOnly;
		return this;
	}

	public Editor WithPrivateVisibility()
	{
		Visibility = RemoteStoragePublishedFileVisibility.Private;
		return this;
	}

	public Editor WithTag(string tag)
	{
		if (Tags == null)
		{
			Tags = new List<string>();
		}
		Tags.Add(tag);
		return this;
	}

	public Editor AddKeyValueTag(string key, string value)
	{
		if (KeyValueTags == null)
		{
			KeyValueTags = new Dictionary<string, List<string>>();
		}
		if (KeyValueTags.TryGetValue(key, out var value2))
		{
			value2.Add(value);
		}
		else
		{
			KeyValueTags[key] = new List<string> { value };
		}
		return this;
	}

	public Editor RemoveKeyValueTags(string key)
	{
		if (KeyValueTagsToRemove == null)
		{
			KeyValueTagsToRemove = new HashSet<string>();
		}
		KeyValueTagsToRemove.Add(key);
		return this;
	}

	public async Task<PublishResult> SubmitAsync(IProgress<float> progress = null, Action<PublishResult> onItemCreated = null)
	{
		PublishResult result = default(PublishResult);
		progress?.Report(0f);
		if ((uint)consumerAppId == 0)
		{
			consumerAppId = SteamClient.AppId;
		}
		if (ContentFolder != null)
		{
			if (!Directory.Exists(ContentFolder.FullName))
			{
				throw new Exception("UgcEditor - Content Folder doesn't exist (" + ContentFolder.FullName + ")");
			}
			if (!ContentFolder.EnumerateFiles("*", SearchOption.AllDirectories).Any())
			{
				throw new Exception("UgcEditor - Content Folder is empty");
			}
		}
		if (creatingNew)
		{
			result.Result = Result.Fail;
			CreateItemResult_t? createItemResult_t = await SteamUGC.Internal.CreateItem(consumerAppId, creatingType);
			if (!createItemResult_t.HasValue)
			{
				return result;
			}
			result.Result = createItemResult_t.Value.Result;
			if (result.Result != Result.OK)
			{
				return result;
			}
			fileId = createItemResult_t.Value.PublishedFileId;
			result.NeedsWorkshopAgreement = createItemResult_t.Value.UserNeedsToAcceptWorkshopLegalAgreement;
			result.FileId = fileId;
			onItemCreated?.Invoke(result);
		}
		result.FileId = fileId;
		UGCUpdateHandle_t handle = SteamUGC.Internal.StartItemUpdate(consumerAppId, fileId);
		if (handle == ulong.MaxValue)
		{
			return result;
		}
		if (Title != null)
		{
			SteamUGC.Internal.SetItemTitle(handle, Title);
		}
		if (Description != null)
		{
			SteamUGC.Internal.SetItemDescription(handle, Description);
		}
		if (MetaData != null)
		{
			SteamUGC.Internal.SetItemMetadata(handle, MetaData);
		}
		if (Language != null)
		{
			SteamUGC.Internal.SetItemUpdateLanguage(handle, Language);
		}
		if (ContentFolder != null)
		{
			SteamUGC.Internal.SetItemContent(handle, ContentFolder.FullName);
		}
		if (PreviewFile != null)
		{
			SteamUGC.Internal.SetItemPreview(handle, PreviewFile);
		}
		if (Visibility.HasValue)
		{
			SteamUGC.Internal.SetItemVisibility(handle, Visibility.Value);
		}
		if (Tags != null && Tags.Count > 0)
		{
			SteamParamStringArray steamParamStringArray = SteamParamStringArray.From(Tags.ToArray());
			try
			{
				SteamParamStringArray_t pTags = steamParamStringArray.Value;
				SteamUGC.Internal.SetItemTags(handle, ref pTags, bAllowAdminTags: false);
			}
			finally
			{
				((IDisposable)steamParamStringArray/*cast due to .constrained prefix*/).Dispose();
			}
		}
		if (KeyValueTagsToRemove != null)
		{
			foreach (string item in KeyValueTagsToRemove)
			{
				SteamUGC.Internal.RemoveItemKeyValueTags(handle, item);
			}
		}
		if (KeyValueTags != null)
		{
			foreach (KeyValuePair<string, List<string>> keyValueTag in KeyValueTags)
			{
				string key = keyValueTag.Key;
				foreach (string item2 in keyValueTag.Value)
				{
					SteamUGC.Internal.AddItemKeyValueTag(handle, key, item2);
				}
			}
		}
		if (AdditionalPreviewFiles != null)
		{
			foreach (KeyValuePair<string, ItemPreviewType> additionalPreviewFile in AdditionalPreviewFiles)
			{
				SteamUGC.Internal.AddItemPreviewFile(handle, additionalPreviewFile.Key, additionalPreviewFile.Value);
			}
		}
		if (RemovePreviewFiles != null)
		{
			foreach (int removePreviewFile in RemovePreviewFiles)
			{
				SteamUGC.Internal.RemoveItemPreview(handle, (uint)removePreviewFile);
			}
		}
		result.Result = Result.Fail;
		if (ChangeLog == null)
		{
			ChangeLog = "";
		}
		CallResult<SubmitItemUpdateResult_t> updating = SteamUGC.Internal.SubmitItemUpdate(handle, ChangeLog);
		while (!updating.IsCompleted)
		{
			if (progress != null)
			{
				ulong punBytesTotal = 0uL;
				ulong punBytesProcessed = 0uL;
				switch (SteamUGC.Internal.GetItemUpdateProgress(handle, ref punBytesProcessed, ref punBytesTotal))
				{
				case ItemUpdateStatus.PreparingConfig:
					progress?.Report(0.1f);
					break;
				case ItemUpdateStatus.PreparingContent:
					progress?.Report(0.2f);
					break;
				case ItemUpdateStatus.UploadingContent:
				{
					float num = ((punBytesTotal != 0) ? ((float)punBytesProcessed / (float)punBytesTotal) : 0f);
					progress?.Report(0.2f + num * 0.6f);
					break;
				}
				case ItemUpdateStatus.UploadingPreviewFile:
					progress?.Report(0.8f);
					break;
				case ItemUpdateStatus.CommittingChanges:
					progress?.Report(1f);
					break;
				}
			}
			await Task.Delay(16);
		}
		progress?.Report(1f);
		SubmitItemUpdateResult_t? result2 = updating.GetResult();
		if (!result2.HasValue)
		{
			return result;
		}
		result.Result = result2.Value.Result;
		if (result.Result != Result.OK)
		{
			return result;
		}
		result.NeedsWorkshopAgreement = result2.Value.UserNeedsToAcceptWorkshopLegalAgreement;
		result.FileId = fileId;
		return result;
	}
}


using Steamworks;
using Steamworks.Data;

public struct PublishResult
{
	public Result Result;

	public PublishedFileId FileId;

	public bool NeedsWorkshopAgreement;

	public bool Success => Result == Result.OK;
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;
using Steamworks.Ugc;

public struct Item
{
	internal SteamUGCDetails_t details;

	internal PublishedFileId _id;

	public PublishedFileId[] Children;

	public PublishedFileId Id => _id;

	public string Title { get; internal set; }

	public string Description { get; internal set; }

	public string[] Tags { get; internal set; }

	public Dictionary<string, string> KeyValueTags { get; internal set; }

	public AppId CreatorApp => details.CreatorAppID;

	public AppId ConsumerApp => details.ConsumerAppID;

	public Friend Owner => new Friend(details.SteamIDOwner);

	public float Score => details.Score;

	public DateTime Created => Epoch.ToDateTime(details.TimeCreated);

	public DateTime Updated => Epoch.ToDateTime(details.TimeUpdated);

	public bool IsPublic => details.Visibility == RemoteStoragePublishedFileVisibility.Public;

	public bool IsFriendsOnly => details.Visibility == RemoteStoragePublishedFileVisibility.FriendsOnly;

	public bool IsPrivate => details.Visibility == RemoteStoragePublishedFileVisibility.Private;

	public bool IsBanned => details.Banned;

	public bool IsAcceptedForUse => details.AcceptedForUse;

	public uint VotesUp => details.VotesUp;

	public uint VotesDown => details.VotesDown;

	public UgcAdditionalPreview[] AdditionalPreviews { get; internal set; }

	public bool IsInstalled => (State & ItemState.Installed) == ItemState.Installed;

	public bool IsDownloading => (State & ItemState.Downloading) == ItemState.Downloading;

	public bool IsDownloadPending => (State & ItemState.DownloadPending) == ItemState.DownloadPending;

	public bool IsSubscribed => (State & ItemState.Subscribed) == ItemState.Subscribed;

	public bool NeedsUpdate => (State & ItemState.NeedsUpdate) == ItemState.NeedsUpdate;

	public string Directory
	{
		get
		{
			ulong punSizeOnDisk = 0uL;
			uint punTimeStamp = 0u;
			if (!SteamUGC.Internal.GetItemInstallInfo(Id, ref punSizeOnDisk, out var pchFolder, ref punTimeStamp))
			{
				return null;
			}
			return pchFolder;
		}
	}

	public long DownloadBytesTotal
	{
		get
		{
			if (!NeedsUpdate)
			{
				return SizeBytes;
			}
			ulong punBytesDownloaded = 0uL;
			ulong punBytesTotal = 0uL;
			if (SteamUGC.Internal.GetItemDownloadInfo(Id, ref punBytesDownloaded, ref punBytesTotal))
			{
				return (long)punBytesTotal;
			}
			return -1L;
		}
	}

	public long DownloadBytesDownloaded
	{
		get
		{
			if (!NeedsUpdate)
			{
				return SizeBytes;
			}
			ulong punBytesDownloaded = 0uL;
			ulong punBytesTotal = 0uL;
			if (SteamUGC.Internal.GetItemDownloadInfo(Id, ref punBytesDownloaded, ref punBytesTotal))
			{
				return (long)punBytesDownloaded;
			}
			return -1L;
		}
	}

	public long SizeBytes
	{
		get
		{
			if (NeedsUpdate)
			{
				return DownloadBytesDownloaded;
			}
			ulong punSizeOnDisk = 0uL;
			uint punTimeStamp = 0u;
			if (!SteamUGC.Internal.GetItemInstallInfo(Id, ref punSizeOnDisk, out var _, ref punTimeStamp))
			{
				return 0L;
			}
			return (long)punSizeOnDisk;
		}
	}

	public float DownloadAmount
	{
		get
		{
			if (!IsDownloading)
			{
				return 1f;
			}
			ulong punBytesDownloaded = 0uL;
			ulong punBytesTotal = 0uL;
			if (SteamUGC.Internal.GetItemDownloadInfo(Id, ref punBytesDownloaded, ref punBytesTotal) && punBytesTotal != 0)
			{
				return (float)((double)punBytesDownloaded / (double)punBytesTotal);
			}
			if (NeedsUpdate || !IsInstalled || IsDownloading)
			{
				return 0f;
			}
			return 1f;
		}
	}

	private ItemState State => (ItemState)SteamUGC.Internal.GetItemState(Id);

	public string Url => $"http://steamcommunity.com/sharedfiles/filedetails/?source=Facepunch.Steamworks&id={Id}";

	public string ChangelogUrl => $"http://steamcommunity.com/sharedfiles/filedetails/changelog/{Id}";

	public string CommentsUrl => $"http://steamcommunity.com/sharedfiles/filedetails/comments/{Id}";

	public string DiscussUrl => $"http://steamcommunity.com/sharedfiles/filedetails/discussions/{Id}";

	public string StatsUrl => $"http://steamcommunity.com/sharedfiles/filedetails/stats/{Id}";

	public ulong NumSubscriptions { get; internal set; }

	public ulong NumFavorites { get; internal set; }

	public ulong NumFollowers { get; internal set; }

	public ulong NumUniqueSubscriptions { get; internal set; }

	public ulong NumUniqueFavorites { get; internal set; }

	public ulong NumUniqueFollowers { get; internal set; }

	public ulong NumUniqueWebsiteViews { get; internal set; }

	public ulong ReportScore { get; internal set; }

	public ulong NumSecondsPlayed { get; internal set; }

	public ulong NumPlaytimeSessions { get; internal set; }

	public ulong NumComments { get; internal set; }

	public ulong NumSecondsPlayedDuringTimePeriod { get; internal set; }

	public ulong NumPlaytimeSessionsDuringTimePeriod { get; internal set; }

	public string PreviewImageUrl { get; internal set; }

	public string Metadata { get; internal set; }

	public Result Result => details.Result;

	public Item(PublishedFileId id)
	{
		this = default(Item);
		_id = id;
	}

	public bool Download(bool highPriority = false)
	{
		return SteamUGC.Download(Id, highPriority);
	}

	public static async Task<Item?> GetAsync(PublishedFileId id, int maxageseconds = 1800)
	{
		ResultPage? resultPage = await Query.All.WithFileId(id).WithLongDescription(b: true).GetPageAsync(1);
		if (!resultPage.HasValue)
		{
			return null;
		}
		using (resultPage.Value)
		{
			if (resultPage.Value.ResultCount == 0)
			{
				return null;
			}
			return resultPage.Value.Entries.First();
		}
	}

	internal static Item From(SteamUGCDetails_t details)
	{
		Item result = default(Item);
		result._id = details.PublishedFileId;
		result.details = details;
		result.Title = details.TitleUTF8();
		result.Description = details.DescriptionUTF8();
		result.Tags = details.TagsUTF8().ToLower().Split(new char[1] { ',' }, StringSplitOptions.RemoveEmptyEntries);
		return result;
	}

	public bool HasTag(string find)
	{
		if (Tags.Length == 0)
		{
			return false;
		}
		return Tags.Contains<string>(find, StringComparer.OrdinalIgnoreCase);
	}

	public async Task<bool> Subscribe()
	{
		RemoteStorageSubscribePublishedFileResult_t? remoteStorageSubscribePublishedFileResult_t = await SteamUGC.Internal.SubscribeItem(_id);
		return remoteStorageSubscribePublishedFileResult_t.HasValue && remoteStorageSubscribePublishedFileResult_t.GetValueOrDefault().Result == Result.OK;
	}

	public async Task<bool> DownloadAsync(Action<float> progress = null, int milisecondsUpdateDelay = 60, CancellationToken ct = default(CancellationToken))
	{
		return await SteamUGC.DownloadAsync(Id, progress, milisecondsUpdateDelay, ct);
	}

	public async Task<bool> Unsubscribe()
	{
		RemoteStorageUnsubscribePublishedFileResult_t? remoteStorageUnsubscribePublishedFileResult_t = await SteamUGC.Internal.UnsubscribeItem(_id);
		return remoteStorageUnsubscribePublishedFileResult_t.HasValue && remoteStorageUnsubscribePublishedFileResult_t.GetValueOrDefault().Result == Result.OK;
	}

	public async Task<bool> AddFavorite()
	{
		UserFavoriteItemsListChanged_t? userFavoriteItemsListChanged_t = await SteamUGC.Internal.AddItemToFavorites(details.ConsumerAppID, _id);
		return userFavoriteItemsListChanged_t.HasValue && userFavoriteItemsListChanged_t.GetValueOrDefault().Result == Result.OK;
	}

	public async Task<bool> RemoveFavorite()
	{
		UserFavoriteItemsListChanged_t? userFavoriteItemsListChanged_t = await SteamUGC.Internal.RemoveItemFromFavorites(details.ConsumerAppID, _id);
		return userFavoriteItemsListChanged_t.HasValue && userFavoriteItemsListChanged_t.GetValueOrDefault().Result == Result.OK;
	}

	public async Task<Result?> Vote(bool up)
	{
		return (await SteamUGC.Internal.SetUserItemVote(Id, up))?.Result;
	}

	public async Task<UserItemVote?> GetUserVote()
	{
		GetUserItemVoteResult_t? getUserItemVoteResult_t = await SteamUGC.Internal.GetUserItemVote(_id);
		if (!getUserItemVoteResult_t.HasValue)
		{
			return null;
		}
		return UserItemVote.From(getUserItemVoteResult_t.Value);
	}

	public Editor Edit()
	{
		return new Editor(Id);
	}

	public async Task<bool> AddDependency(PublishedFileId child)
	{
		AddUGCDependencyResult_t? addUGCDependencyResult_t = await SteamUGC.Internal.AddDependency(Id, child);
		return addUGCDependencyResult_t.HasValue && addUGCDependencyResult_t.GetValueOrDefault().Result == Result.OK;
	}

	public async Task<bool> RemoveDependency(PublishedFileId child)
	{
		RemoveUGCDependencyResult_t? removeUGCDependencyResult_t = await SteamUGC.Internal.RemoveDependency(Id, child);
		return removeUGCDependencyResult_t.HasValue && removeUGCDependencyResult_t.GetValueOrDefault().Result == Result.OK;
	}
}


using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;
using Steamworks.Ugc;

public struct Query
{
	private UgcType matchingType;

	private UGCQuery queryType;

	private AppId consumerApp;

	private AppId creatorApp;

	private string searchText;

	private SteamId? steamid;

	private UserUGCList userType;

	private UserUGCListSortOrder userSort;

	private PublishedFileId[] Files;

	private int? maxCacheAge;

	private string language;

	private int? trendDays;

	private List<string> requiredTags;

	private bool? matchAnyTag;

	private List<string> excludedTags;

	private Dictionary<string, string> requiredKv;

	private bool? WantsReturnOnlyIDs;

	private bool? WantsReturnKeyValueTags;

	private bool? WantsReturnLongDescription;

	private bool? WantsReturnMetadata;

	private bool? WantsReturnChildren;

	private bool? WantsReturnAdditionalPreviews;

	private bool? WantsReturnTotalOnly;

	private uint? WantsReturnPlaytimeStats;

	private bool? WantsDefaultStats;

	public static Query All => new Query(UgcType.All);

	public static Query Items => new Query(UgcType.Items);

	public static Query ItemsMtx => new Query(UgcType.Items_Mtx);

	public static Query ItemsReadyToUse => new Query(UgcType.Items_ReadyToUse);

	public static Query Collections => new Query(UgcType.Collections);

	public static Query Artwork => new Query(UgcType.Artwork);

	public static Query Videos => new Query(UgcType.Videos);

	public static Query Screenshots => new Query(UgcType.Screenshots);

	public static Query AllGuides => new Query(UgcType.AllGuides);

	public static Query WebGuides => new Query(UgcType.WebGuides);

	public static Query IntegratedGuides => new Query(UgcType.IntegratedGuides);

	public static Query UsableInGame => new Query(UgcType.UsableInGame);

	public static Query ControllerBindings => new Query(UgcType.ControllerBindings);

	public static Query GameManagedItems => new Query(UgcType.GameManagedItems);

	public Query(UgcType type)
	{
		this = default(Query);
		matchingType = type;
	}

	public Query RankedByVote()
	{
		queryType = UGCQuery.RankedByVote;
		return this;
	}

	public Query RankedByPublicationDate()
	{
		queryType = UGCQuery.RankedByPublicationDate;
		return this;
	}

	public Query RankedByAcceptanceDate()
	{
		queryType = UGCQuery.AcceptedForGameRankedByAcceptanceDate;
		return this;
	}

	public Query RankedByTrend()
	{
		queryType = UGCQuery.RankedByTrend;
		return this;
	}

	public Query FavoritedByFriends()
	{
		queryType = UGCQuery.FavoritedByFriendsRankedByPublicationDate;
		return this;
	}

	public Query CreatedByFriends()
	{
		queryType = UGCQuery.CreatedByFriendsRankedByPublicationDate;
		return this;
	}

	public Query RankedByNumTimesReported()
	{
		queryType = UGCQuery.RankedByNumTimesReported;
		return this;
	}

	public Query CreatedByFollowedUsers()
	{
		queryType = UGCQuery.CreatedByFollowedUsersRankedByPublicationDate;
		return this;
	}

	public Query NotYetRated()
	{
		queryType = UGCQuery.NotYetRated;
		return this;
	}

	public Query RankedByTotalVotesAsc()
	{
		queryType = UGCQuery.RankedByTotalVotesAsc;
		return this;
	}

	public Query RankedByVotesUp()
	{
		queryType = UGCQuery.RankedByVotesUp;
		return this;
	}

	public Query RankedByTextSearch()
	{
		queryType = UGCQuery.RankedByTextSearch;
		return this;
	}

	public Query RankedByTotalUniqueSubscriptions()
	{
		queryType = UGCQuery.RankedByTotalUniqueSubscriptions;
		return this;
	}

	public Query RankedByPlaytimeTrend()
	{
		queryType = UGCQuery.RankedByPlaytimeTrend;
		return this;
	}

	public Query RankedByTotalPlaytime()
	{
		queryType = UGCQuery.RankedByTotalPlaytime;
		return this;
	}

	public Query RankedByAveragePlaytimeTrend()
	{
		queryType = UGCQuery.RankedByAveragePlaytimeTrend;
		return this;
	}

	public Query RankedByLifetimeAveragePlaytime()
	{
		queryType = UGCQuery.RankedByLifetimeAveragePlaytime;
		return this;
	}

	public Query RankedByPlaytimeSessionsTrend()
	{
		queryType = UGCQuery.RankedByPlaytimeSessionsTrend;
		return this;
	}

	public Query RankedByLifetimePlaytimeSessions()
	{
		queryType = UGCQuery.RankedByLifetimePlaytimeSessions;
		return this;
	}

	internal Query LimitUser(SteamId steamid)
	{
		if (steamid.Value == 0L)
		{
			steamid = SteamClient.SteamId;
		}
		this.steamid = steamid;
		return this;
	}

	public Query WhereUserPublished(SteamId user = default(SteamId))
	{
		userType = UserUGCList.Published;
		LimitUser(user);
		return this;
	}

	public Query WhereUserVotedOn(SteamId user = default(SteamId))
	{
		userType = UserUGCList.VotedOn;
		LimitUser(user);
		return this;
	}

	public Query WhereUserVotedUp(SteamId user = default(SteamId))
	{
		userType = UserUGCList.VotedUp;
		LimitUser(user);
		return this;
	}

	public Query WhereUserVotedDown(SteamId user = default(SteamId))
	{
		userType = UserUGCList.VotedDown;
		LimitUser(user);
		return this;
	}

	public Query WhereUserWillVoteLater(SteamId user = default(SteamId))
	{
		userType = UserUGCList.WillVoteLater;
		LimitUser(user);
		return this;
	}

	public Query WhereUserFavorited(SteamId user = default(SteamId))
	{
		userType = UserUGCList.Favorited;
		LimitUser(user);
		return this;
	}

	public Query WhereUserSubscribed(SteamId user = default(SteamId))
	{
		userType = UserUGCList.Subscribed;
		LimitUser(user);
		return this;
	}

	public Query WhereUserUsedOrPlayed(SteamId user = default(SteamId))
	{
		userType = UserUGCList.UsedOrPlayed;
		LimitUser(user);
		return this;
	}

	public Query WhereUserFollowed(SteamId user = default(SteamId))
	{
		userType = UserUGCList.Followed;
		LimitUser(user);
		return this;
	}

	public Query SortByCreationDate()
	{
		userSort = UserUGCListSortOrder.CreationOrderDesc;
		return this;
	}

	public Query SortByCreationDateAsc()
	{
		userSort = UserUGCListSortOrder.CreationOrderAsc;
		return this;
	}

	public Query SortByTitleAsc()
	{
		userSort = UserUGCListSortOrder.TitleAsc;
		return this;
	}

	public Query SortByUpdateDate()
	{
		userSort = UserUGCListSortOrder.LastUpdatedDesc;
		return this;
	}

	public Query SortBySubscriptionDate()
	{
		userSort = UserUGCListSortOrder.SubscriptionDateDesc;
		return this;
	}

	public Query SortByVoteScore()
	{
		userSort = UserUGCListSortOrder.VoteScoreDesc;
		return this;
	}

	public Query SortByModeration()
	{
		userSort = UserUGCListSortOrder.ForModeration;
		return this;
	}

	public Query WhereSearchText(string searchText)
	{
		this.searchText = searchText;
		return this;
	}

	public Query WithFileId(params PublishedFileId[] files)
	{
		Files = files;
		return this;
	}

	public async Task<ResultPage?> GetPageAsync(int page)
	{
		if (page <= 0)
		{
			throw new Exception("page should be > 0");
		}
		if ((uint)consumerApp == 0)
		{
			consumerApp = SteamClient.AppId;
		}
		if ((uint)creatorApp == 0)
		{
			creatorApp = consumerApp;
		}
		UGCQueryHandle_t handle = ((Files != null) ? SteamUGC.Internal.CreateQueryUGCDetailsRequest(Files, (uint)Files.Length) : ((!steamid.HasValue) ? SteamUGC.Internal.CreateQueryAllUGCRequest(queryType, matchingType, creatorApp.Value, consumerApp.Value, (uint)page) : SteamUGC.Internal.CreateQueryUserUGCRequest(steamid.Value.AccountId, userType, matchingType, userSort, creatorApp.Value, consumerApp.Value, (uint)page)));
		ApplyReturns(handle);
		if (maxCacheAge.HasValue)
		{
			SteamUGC.Internal.SetAllowCachedResponse(handle, (uint)maxCacheAge.Value);
		}
		ApplyConstraints(handle);
		SteamUGCQueryCompleted_t? steamUGCQueryCompleted_t = await SteamUGC.Internal.SendQueryUGCRequest(handle);
		if (!steamUGCQueryCompleted_t.HasValue)
		{
			return null;
		}
		if (steamUGCQueryCompleted_t.Value.Result != Result.OK)
		{
			return null;
		}
		ResultPage value = default(ResultPage);
		value.Handle = steamUGCQueryCompleted_t.Value.Handle;
		value.ResultCount = (int)steamUGCQueryCompleted_t.Value.NumResultsReturned;
		value.TotalCount = (int)steamUGCQueryCompleted_t.Value.TotalMatchingResults;
		value.CachedData = steamUGCQueryCompleted_t.Value.CachedData;
		value.ReturnsKeyValueTags = WantsReturnKeyValueTags == true;
		value.ReturnsDefaultStats = WantsDefaultStats ?? true;
		value.ReturnsMetadata = WantsReturnMetadata == true;
		value.ReturnsChildren = WantsReturnChildren == true;
		value.ReturnsAdditionalPreviews = WantsReturnAdditionalPreviews == true;
		return value;
	}

	public Query WithType(UgcType type)
	{
		matchingType = type;
		return this;
	}

	public Query AllowCachedResponse(int maxSecondsAge)
	{
		maxCacheAge = maxSecondsAge;
		return this;
	}

	public Query InLanguage(string lang)
	{
		language = lang;
		return this;
	}

	public Query WithTrendDays(int days)
	{
		trendDays = days;
		return this;
	}

	public Query MatchAnyTag()
	{
		matchAnyTag = true;
		return this;
	}

	public Query MatchAllTags()
	{
		matchAnyTag = false;
		return this;
	}

	public Query WithTag(string tag)
	{
		if (requiredTags == null)
		{
			requiredTags = new List<string>();
		}
		requiredTags.Add(tag);
		return this;
	}

	public Query AddRequiredKeyValueTag(string key, string value)
	{
		if (requiredKv == null)
		{
			requiredKv = new Dictionary<string, string>();
		}
		requiredKv.Add(key, value);
		return this;
	}

	public Query WithoutTag(string tag)
	{
		if (excludedTags == null)
		{
			excludedTags = new List<string>();
		}
		excludedTags.Add(tag);
		return this;
	}

	private void ApplyConstraints(UGCQueryHandle_t handle)
	{
		if (requiredTags != null)
		{
			foreach (string requiredTag in requiredTags)
			{
				SteamUGC.Internal.AddRequiredTag(handle, requiredTag);
			}
		}
		if (excludedTags != null)
		{
			foreach (string excludedTag in excludedTags)
			{
				SteamUGC.Internal.AddExcludedTag(handle, excludedTag);
			}
		}
		if (requiredKv != null)
		{
			foreach (KeyValuePair<string, string> item in requiredKv)
			{
				SteamUGC.Internal.AddRequiredKeyValueTag(handle, item.Key, item.Value);
			}
		}
		if (matchAnyTag.HasValue)
		{
			SteamUGC.Internal.SetMatchAnyTag(handle, matchAnyTag.Value);
		}
		if (trendDays.HasValue)
		{
			SteamUGC.Internal.SetRankedByTrendDays(handle, (uint)trendDays.Value);
		}
		if (!string.IsNullOrEmpty(searchText))
		{
			SteamUGC.Internal.SetSearchText(handle, searchText);
		}
	}

	public Query WithOnlyIDs(bool b)
	{
		WantsReturnOnlyIDs = b;
		return this;
	}

	public Query WithKeyValueTags(bool b)
	{
		WantsReturnKeyValueTags = b;
		return this;
	}

	[Obsolete("Renamed to WithKeyValueTags")]
	public Query WithKeyValueTag(bool b)
	{
		WantsReturnKeyValueTags = b;
		return this;
	}

	public Query WithLongDescription(bool b)
	{
		WantsReturnLongDescription = b;
		return this;
	}

	public Query WithMetadata(bool b)
	{
		WantsReturnMetadata = b;
		return this;
	}

	public Query WithChildren(bool b)
	{
		WantsReturnChildren = b;
		return this;
	}

	public Query WithAdditionalPreviews(bool b)
	{
		WantsReturnAdditionalPreviews = b;
		return this;
	}

	public Query WithTotalOnly(bool b)
	{
		WantsReturnTotalOnly = b;
		return this;
	}

	public Query WithPlaytimeStats(uint unDays)
	{
		WantsReturnPlaytimeStats = unDays;
		return this;
	}

	private void ApplyReturns(UGCQueryHandle_t handle)
	{
		if (WantsReturnOnlyIDs.HasValue)
		{
			SteamUGC.Internal.SetReturnOnlyIDs(handle, WantsReturnOnlyIDs.Value);
		}
		if (WantsReturnKeyValueTags.HasValue)
		{
			SteamUGC.Internal.SetReturnKeyValueTags(handle, WantsReturnKeyValueTags.Value);
		}
		if (WantsReturnLongDescription.HasValue)
		{
			SteamUGC.Internal.SetReturnLongDescription(handle, WantsReturnLongDescription.Value);
		}
		if (WantsReturnMetadata.HasValue)
		{
			SteamUGC.Internal.SetReturnMetadata(handle, WantsReturnMetadata.Value);
		}
		if (WantsReturnChildren.HasValue)
		{
			SteamUGC.Internal.SetReturnChildren(handle, WantsReturnChildren.Value);
		}
		if (WantsReturnAdditionalPreviews.HasValue)
		{
			SteamUGC.Internal.SetReturnAdditionalPreviews(handle, WantsReturnAdditionalPreviews.Value);
		}
		if (WantsReturnTotalOnly.HasValue)
		{
			SteamUGC.Internal.SetReturnTotalOnly(handle, WantsReturnTotalOnly.Value);
		}
		if (WantsReturnPlaytimeStats.HasValue)
		{
			SteamUGC.Internal.SetReturnPlaytimeStats(handle, WantsReturnPlaytimeStats.Value);
		}
	}

	public Query WithDefaultStats(bool b)
	{
		WantsDefaultStats = b;
		return this;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using Steamworks;
using Steamworks.Data;
using Steamworks.Ugc;

public struct ResultPage : IDisposable
{
	[CompilerGenerated]
	private sealed class <get_Entries>d__10 : IEnumerable<Item>, IEnumerable, IEnumerator<Item>, IDisposable, IEnumerator
	{
		private int <>1__state;

		private Item <>2__current;

		private int <>l__initialThreadId;

		public ResultPage <>4__this;

		public ResultPage <>3__<>4__this;

		private SteamUGCDetails_t <details>5__2;

		private uint <i>5__3;

		Item IEnumerator<Item>.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		object IEnumerator.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		[DebuggerHidden]
		public <get_Entries>d__10(int <>1__state)
		{
			this.<>1__state = <>1__state;
			<>l__initialThreadId = Environment.CurrentManagedThreadId;
		}

		[DebuggerHidden]
		void IDisposable.Dispose()
		{
			<details>5__2 = default(SteamUGCDetails_t);
			<>1__state = -2;
		}

		private bool MoveNext()
		{
			int num = <>1__state;
			if (num != 0)
			{
				if (num != 1)
				{
					return false;
				}
				<>1__state = -1;
				goto IL_038c;
			}
			<>1__state = -1;
			<details>5__2 = default(SteamUGCDetails_t);
			<i>5__3 = 0u;
			goto IL_039e;
			IL_038c:
			<i>5__3++;
			goto IL_039e;
			IL_039e:
			if (<i>5__3 < <>4__this.ResultCount)
			{
				if (SteamUGC.Internal.GetQueryUGCResult(<>4__this.Handle, <i>5__3, ref <details>5__2))
				{
					Item item = Item.From(<details>5__2);
					if (<>4__this.ReturnsDefaultStats)
					{
						item.NumSubscriptions = <>4__this.GetStat(<i>5__3, ItemStatistic.NumSubscriptions);
						item.NumFavorites = <>4__this.GetStat(<i>5__3, ItemStatistic.NumFavorites);
						item.NumFollowers = <>4__this.GetStat(<i>5__3, ItemStatistic.NumFollowers);
						item.NumUniqueSubscriptions = <>4__this.GetStat(<i>5__3, ItemStatistic.NumUniqueSubscriptions);
						item.NumUniqueFavorites = <>4__this.GetStat(<i>5__3, ItemStatistic.NumUniqueFavorites);
						item.NumUniqueFollowers = <>4__this.GetStat(<i>5__3, ItemStatistic.NumUniqueFollowers);
						item.NumUniqueWebsiteViews = <>4__this.GetStat(<i>5__3, ItemStatistic.NumUniqueWebsiteViews);
						item.ReportScore = <>4__this.GetStat(<i>5__3, ItemStatistic.ReportScore);
						item.NumSecondsPlayed = <>4__this.GetStat(<i>5__3, ItemStatistic.NumSecondsPlayed);
						item.NumPlaytimeSessions = <>4__this.GetStat(<i>5__3, ItemStatistic.NumPlaytimeSessions);
						item.NumComments = <>4__this.GetStat(<i>5__3, ItemStatistic.NumComments);
						item.NumSecondsPlayedDuringTimePeriod = <>4__this.GetStat(<i>5__3, ItemStatistic.NumSecondsPlayedDuringTimePeriod);
						item.NumPlaytimeSessionsDuringTimePeriod = <>4__this.GetStat(<i>5__3, ItemStatistic.NumPlaytimeSessionsDuringTimePeriod);
					}
					if (SteamUGC.Internal.GetQueryUGCPreviewURL(<>4__this.Handle, <i>5__3, out var pchURL))
					{
						item.PreviewImageUrl = pchURL;
					}
					if (<>4__this.ReturnsKeyValueTags)
					{
						uint queryUGCNumKeyValueTags = SteamUGC.Internal.GetQueryUGCNumKeyValueTags(<>4__this.Handle, <i>5__3);
						item.KeyValueTags = new Dictionary<string, string>((int)queryUGCNumKeyValueTags);
						for (uint num2 = 0u; num2 < queryUGCNumKeyValueTags; num2++)
						{
							if (SteamUGC.Internal.GetQueryUGCKeyValueTag(<>4__this.Handle, <i>5__3, num2, out var pchKey, out var pchValue))
							{
								item.KeyValueTags[pchKey] = pchValue;
							}
						}
					}
					if (<>4__this.ReturnsMetadata && SteamUGC.Internal.GetQueryUGCMetadata(<>4__this.Handle, <i>5__3, out var pchMetadata))
					{
						item.Metadata = pchMetadata;
					}
					uint numChildren = item.details.NumChildren;
					if (<>4__this.ReturnsChildren && numChildren != 0)
					{
						PublishedFileId[] array = new PublishedFileId[numChildren];
						if (SteamUGC.Internal.GetQueryUGCChildren(<>4__this.Handle, <i>5__3, array, numChildren))
						{
							item.Children = array;
						}
					}
					if (<>4__this.ReturnsAdditionalPreviews)
					{
						uint queryUGCNumAdditionalPreviews = SteamUGC.Internal.GetQueryUGCNumAdditionalPreviews(<>4__this.Handle, <i>5__3);
						if (queryUGCNumAdditionalPreviews != 0)
						{
							item.AdditionalPreviews = new UgcAdditionalPreview[queryUGCNumAdditionalPreviews];
							for (uint num3 = 0u; num3 < queryUGCNumAdditionalPreviews; num3++)
							{
								ItemPreviewType pPreviewType = ItemPreviewType.Image;
								if (SteamUGC.Internal.GetQueryUGCAdditionalPreview(<>4__this.Handle, <i>5__3, num3, out var pchURLOrVideoID, out var pchOriginalFileName, ref pPreviewType))
								{
									item.AdditionalPreviews[num3] = new UgcAdditionalPreview(pchURLOrVideoID, pchOriginalFileName, pPreviewType);
								}
							}
						}
					}
					<>2__current = item;
					<>1__state = 1;
					return true;
				}
				goto IL_038c;
			}
			return false;
		}

		bool IEnumerator.MoveNext()
		{
			//ILSpy generated this explicit interface implementation from .override directive in MoveNext
			return this.MoveNext();
		}

		[DebuggerHidden]
		void IEnumerator.Reset()
		{
			throw new NotSupportedException();
		}

		[DebuggerHidden]
		IEnumerator<Item> IEnumerable<Item>.GetEnumerator()
		{
			<get_Entries>d__10 <get_Entries>d__;
			if (<>1__state == -2 && <>l__initialThreadId == Environment.CurrentManagedThreadId)
			{
				<>1__state = 0;
				<get_Entries>d__ = this;
			}
			else
			{
				<get_Entries>d__ = new <get_Entries>d__10(0);
			}
			<get_Entries>d__.<>4__this = <>3__<>4__this;
			return <get_Entries>d__;
		}

		[DebuggerHidden]
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<Item>)this).GetEnumerator();
		}
	}

	internal UGCQueryHandle_t Handle;

	public int ResultCount;

	public int TotalCount;

	public bool CachedData;

	internal bool ReturnsKeyValueTags;

	internal bool ReturnsDefaultStats;

	internal bool ReturnsMetadata;

	internal bool ReturnsChildren;

	internal bool ReturnsAdditionalPreviews;

	public IEnumerable<Item> Entries
	{
		[IteratorStateMachine(typeof(<get_Entries>d__10))]
		get
		{
			//yield-return decompiler failed: Unexpected instruction in Iterator.Dispose()
			return new <get_Entries>d__10(-2)
			{
				<>3__<>4__this = this
			};
		}
	}

	private ulong GetStat(uint index, ItemStatistic stat)
	{
		ulong pStatValue = 0uL;
		if (!SteamUGC.Internal.GetQueryUGCStatistic(Handle, index, stat, ref pStatValue))
		{
			return 0uL;
		}
		return pStatValue;
	}

	public void Dispose()
	{
		if ((ulong)Handle != 0)
		{
			SteamUGC.Internal.ReleaseQueryUGCRequest(Handle);
			Handle = 0uL;
		}
	}
}


using Steamworks.Data;
using Steamworks.Ugc;

public struct UserItemVote
{
	public bool VotedUp;

	public bool VotedDown;

	public bool VoteSkipped;

	internal static UserItemVote? From(GetUserItemVoteResult_t result)
	{
		UserItemVote value = default(UserItemVote);
		value.VotedUp = result.VotedUp;
		value.VotedDown = result.VotedDown;
		value.VoteSkipped = result.VoteSkipped;
		return value;
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;

public abstract class Base : IDisposable
{
	public List<ServerInfo> Responsive = new List<ServerInfo>();

	public List<ServerInfo> Unresponsive = new List<ServerInfo>();

	public List<ServerInfo> Unqueried = new List<ServerInfo>();

	internal HServerListRequest request;

	internal List<MatchMakingKeyValuePair> filters = new List<MatchMakingKeyValuePair>();

	internal List<int> watchList = new List<int>();

	internal int LastCount;

	internal static ISteamMatchmakingServers Internal => SteamMatchmakingServers.Internal;

	public AppId AppId { get; set; }

	internal int Count => Internal.GetServerCount(request);

	internal bool IsRefreshing
	{
		get
		{
			if (request.Value != IntPtr.Zero)
			{
				return Internal.IsRefreshing(request);
			}
			return false;
		}
	}

	public event Action OnChanges;

	public event Action<ServerInfo> OnResponsiveServer;

	public Base()
	{
		AppId = SteamClient.AppId;
	}

	public virtual async Task<bool> RunQueryAsync(float timeoutSeconds = 10f)
	{
		Stopwatch stopwatch = Stopwatch.StartNew();
		Reset();
		LaunchQuery();
		HServerListRequest thisRequest = request;
		while (IsRefreshing)
		{
			await Task.Delay(33);
			if (request.Value == IntPtr.Zero || thisRequest.Value != request.Value)
			{
				return false;
			}
			if (!SteamClient.IsValid)
			{
				return false;
			}
			int count = Responsive.Count;
			UpdatePending();
			UpdateResponsive();
			if (count != Responsive.Count)
			{
				InvokeChanges();
			}
			if (stopwatch.Elapsed.TotalSeconds > (double)timeoutSeconds)
			{
				break;
			}
		}
		MovePendingToUnresponsive();
		InvokeChanges();
		return true;
	}

	public virtual void Cancel()
	{
		Internal.CancelQuery(request);
	}

	internal abstract void LaunchQuery();

	internal virtual MatchMakingKeyValuePair[] GetFilters()
	{
		return filters.ToArray();
	}

	public void AddFilter(string key, string value)
	{
		filters.Add(new MatchMakingKeyValuePair
		{
			Key = key,
			Value = value
		});
	}

	private void Reset()
	{
		ReleaseQuery();
		LastCount = 0;
		watchList.Clear();
	}

	private void ReleaseQuery()
	{
		if (request.Value != IntPtr.Zero)
		{
			Cancel();
			Internal.ReleaseRequest(request);
			request = IntPtr.Zero;
		}
	}

	public virtual void Dispose()
	{
		ReleaseQuery();
	}

	internal void InvokeChanges()
	{
		this.OnChanges?.Invoke();
	}

	private void UpdatePending()
	{
		int count = Count;
		if (count != LastCount)
		{
			for (int i = LastCount; i < count; i++)
			{
				watchList.Add(i);
			}
			LastCount = count;
		}
	}

	public void UpdateResponsive()
	{
		watchList.RemoveAll(delegate(int x)
		{
			if (Internal.HasServerResponded(request, x))
			{
				gameserveritem_t serverDetails = Internal.GetServerDetails(request, x);
				if (serverDetails.HadSuccessfulResponse)
				{
					OnServer(ServerInfo.From(serverDetails), serverDetails.HadSuccessfulResponse);
					return true;
				}
			}
			return false;
		});
	}

	private void MovePendingToUnresponsive()
	{
		watchList.RemoveAll(delegate(int x)
		{
			ServerInfo item = ServerInfo.From(Internal.GetServerDetails(request, x));
			item.Ping = int.MaxValue;
			Unqueried.Add(item);
			return true;
		});
	}

	private void OnServer(ServerInfo serverInfo, bool responded)
	{
		if (responded)
		{
			Responsive.Add(serverInfo);
			this.OnResponsiveServer?.Invoke(serverInfo);
		}
		else
		{
			Unresponsive.Add(serverInfo);
		}
	}
}


using System;
using Steamworks.ServerList;

public class Favourites : Base
{
	internal override void LaunchQuery()
	{
		using ServerFilterMarshaler serverFilterMarshaler = new ServerFilterMarshaler(GetFilters());
		request = Base.Internal.RequestFavoritesServerList(base.AppId.Value, serverFilterMarshaler.Pointer, (uint)serverFilterMarshaler.Count, IntPtr.Zero);
	}
}


using System;
using Steamworks.ServerList;

public class Friends : Base
{
	internal override void LaunchQuery()
	{
		using ServerFilterMarshaler serverFilterMarshaler = new ServerFilterMarshaler(GetFilters());
		request = Base.Internal.RequestFriendsServerList(base.AppId.Value, serverFilterMarshaler.Pointer, (uint)serverFilterMarshaler.Count, IntPtr.Zero);
	}
}


using System;
using Steamworks.ServerList;

public class History : Base
{
	internal override void LaunchQuery()
	{
		using ServerFilterMarshaler serverFilterMarshaler = new ServerFilterMarshaler(GetFilters());
		request = Base.Internal.RequestHistoryServerList(base.AppId.Value, serverFilterMarshaler.Pointer, (uint)serverFilterMarshaler.Count, IntPtr.Zero);
	}
}


using System;
using Steamworks.ServerList;

public class Internet : Base
{
	internal override void LaunchQuery()
	{
		using ServerFilterMarshaler serverFilterMarshaler = new ServerFilterMarshaler(GetFilters());
		request = Base.Internal.RequestInternetServerList(base.AppId.Value, serverFilterMarshaler.Pointer, (uint)serverFilterMarshaler.Count, IntPtr.Zero);
	}
}


using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Steamworks.ServerList;

public class IpList : Internet
{
	public List<string> Ips = new List<string>();

	private bool wantsCancel;

	public IpList(IEnumerable<string> list)
	{
		Ips.AddRange(list);
	}

	public IpList(params string[] list)
	{
		Ips.AddRange(list);
	}

	public override async Task<bool> RunQueryAsync(float timeoutSeconds = 10f)
	{
		int blockSize = 16;
		int pointer = 0;
		string[] ips = Ips.ToArray();
		wantsCancel = false;
		while (!wantsCancel)
		{
			List<string> sublist = ips.Skip(pointer).Take(blockSize).ToList();
			if (sublist.Count == 0)
			{
				break;
			}
			using (Internet list = new Internet())
			{
				list.AddFilter("or", sublist.Count.ToString());
				foreach (string item in sublist)
				{
					list.AddFilter("gameaddr", item);
				}
				await list.RunQueryAsync(timeoutSeconds);
				Responsive.AddRange(list.Responsive);
				Responsive = Responsive.Distinct().ToList();
				Unresponsive.AddRange(list.Unresponsive);
				Unresponsive = Unresponsive.Distinct().ToList();
			}
			pointer += sublist.Count();
			InvokeChanges();
		}
		return true;
	}

	public override void Cancel()
	{
		wantsCancel = true;
	}

	public override void Dispose()
	{
		base.Dispose();
		wantsCancel = true;
	}
}


using System;
using Steamworks.ServerList;

public class LocalNetwork : Base
{
	internal override void LaunchQuery()
	{
		request = Base.Internal.RequestLANServerList(base.AppId.Value, IntPtr.Zero);
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks.Data;

internal struct ServerFilterMarshaler : IDisposable
{
	private static readonly int SizeOfPointer = Marshal.SizeOf<IntPtr>();

	private static readonly int SizeOfKeyValuePair = Marshal.SizeOf<MatchMakingKeyValuePair>();

	private IntPtr _arrayPtr;

	private IntPtr _itemsPtr;

	public int Count { get; private set; }

	public IntPtr Pointer => _arrayPtr;

	public ServerFilterMarshaler(MatchMakingKeyValuePair[] filters)
	{
		if (filters == null || filters.Length == 0)
		{
			Count = 0;
			_arrayPtr = IntPtr.Zero;
			_itemsPtr = IntPtr.Zero;
			return;
		}
		Count = filters.Length;
		_arrayPtr = Marshal.AllocHGlobal(SizeOfPointer * filters.Length);
		_itemsPtr = Marshal.AllocHGlobal(SizeOfKeyValuePair * filters.Length);
		IntPtr arrayPtr = _arrayPtr;
		IntPtr itemsPtr = _itemsPtr;
		foreach (MatchMakingKeyValuePair structure in filters)
		{
			Marshal.WriteIntPtr(arrayPtr, itemsPtr);
			arrayPtr += SizeOfPointer;
			Marshal.StructureToPtr(structure, itemsPtr, fDeleteOld: false);
			itemsPtr += SizeOfKeyValuePair;
		}
	}

	public void Dispose()
	{
		if (_arrayPtr != IntPtr.Zero)
		{
			Marshal.FreeHGlobal(_arrayPtr);
			_arrayPtr = IntPtr.Zero;
		}
		if (_itemsPtr != IntPtr.Zero)
		{
			Marshal.FreeHGlobal(_itemsPtr);
			_itemsPtr = IntPtr.Zero;
		}
	}
}


public enum LeaderboardDisplay
{
	Numeric = 1,
	TimeSeconds,
	TimeMilliSeconds
}


public enum LeaderboardSort
{
	Ascending = 1,
	Descending
}


using System;

[Flags]
public enum SendType
{
	Unreliable = 0,
	NoNagle = 1,
	NoDelay = 4,
	Reliable = 8
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamServersConnected_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(SteamServersConnected_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamServersConnected;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamServerConnectFailure_t : ICallbackData
{
	internal Result Result;

	[MarshalAs(UnmanagedType.I1)]
	internal bool StillRetrying;

	public static int _datasize = Marshal.SizeOf(typeof(SteamServerConnectFailure_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamServerConnectFailure;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamServersDisconnected_t : ICallbackData
{
	internal Result Result;

	public static int _datasize = Marshal.SizeOf(typeof(SteamServersDisconnected_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamServersDisconnected;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct ClientGameServerDeny_t : ICallbackData
{
	internal uint AppID;

	internal uint GameServerIP;

	internal ushort GameServerPort;

	internal ushort Secure;

	internal uint Reason;

	public static int _datasize = Marshal.SizeOf(typeof(ClientGameServerDeny_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.ClientGameServerDeny;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct IPCFailure_t : ICallbackData
{
	internal enum EFailureType
	{
		FlushedCallbackQueue,
		PipeFail
	}

	internal byte FailureType;

	public static int _datasize = Marshal.SizeOf(typeof(IPCFailure_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.IPCFailure;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct LicensesUpdated_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(LicensesUpdated_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.LicensesUpdated;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct ValidateAuthTicketResponse_t : ICallbackData
{
	internal ulong SteamID;

	internal AuthResponse AuthSessionResponse;

	internal ulong OwnerSteamID;

	public static int _datasize = Marshal.SizeOf(typeof(ValidateAuthTicketResponse_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.ValidateAuthTicketResponse;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct MicroTxnAuthorizationResponse_t : ICallbackData
{
	internal uint AppID;

	internal ulong OrderID;

	internal byte Authorized;

	public static int _datasize = Marshal.SizeOf(typeof(MicroTxnAuthorizationResponse_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.MicroTxnAuthorizationResponse;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct EncryptedAppTicketResponse_t : ICallbackData
{
	internal Result Result;

	public static int _datasize = Marshal.SizeOf(typeof(EncryptedAppTicketResponse_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.EncryptedAppTicketResponse;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GetAuthSessionTicketResponse_t : ICallbackData
{
	internal uint AuthTicket;

	internal Result Result;

	public static int _datasize = Marshal.SizeOf(typeof(GetAuthSessionTicketResponse_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GetAuthSessionTicketResponse;
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GameWebCallback_t : ICallbackData
{
	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
	internal byte[] URL;

	public static int _datasize = Marshal.SizeOf(typeof(GameWebCallback_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GameWebCallback;

	internal string URLUTF8()
	{
		return Utility.Utf8NoBom.GetString(URL, 0, Array.IndexOf(URL, (byte)0));
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct StoreAuthURLResponse_t : ICallbackData
{
	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 512)]
	internal byte[] URL;

	public static int _datasize = Marshal.SizeOf(typeof(StoreAuthURLResponse_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.StoreAuthURLResponse;

	internal string URLUTF8()
	{
		return Utility.Utf8NoBom.GetString(URL, 0, Array.IndexOf(URL, (byte)0));
	}
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct MarketEligibilityResponse_t : ICallbackData
{
	[MarshalAs(UnmanagedType.I1)]
	internal bool Allowed;

	internal MarketNotAllowedReasonFlags NotAllowedReason;

	internal uint TAllowedAtTime;

	internal int CdaySteamGuardRequiredDays;

	internal int CdayNewDeviceCooldown;

	public static int _datasize = Marshal.SizeOf(typeof(MarketEligibilityResponse_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.MarketEligibilityResponse;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct DurationControl_t : ICallbackData
{
	internal Result Result;

	internal AppId Appid;

	[MarshalAs(UnmanagedType.I1)]
	internal bool Applicable;

	internal int CsecsLast5h;

	internal DurationControlProgress Progress;

	internal DurationControlNotification Otification;

	internal int CsecsToday;

	internal int CsecsRemaining;

	public static int _datasize = Marshal.SizeOf(typeof(DurationControl_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.DurationControl;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GetTicketForWebApiResponse_t : ICallbackData
{
	internal uint AuthTicket;

	internal Result Result;

	internal int Ticket;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 2560)]
	internal byte[] GubTicket;

	public static int _datasize = Marshal.SizeOf(typeof(GetTicketForWebApiResponse_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GetTicketForWebApiResponse;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct PersonaStateChange_t : ICallbackData
{
	internal ulong SteamID;

	internal int ChangeFlags;

	public static int _datasize = Marshal.SizeOf(typeof(PersonaStateChange_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.PersonaStateChange;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GameOverlayActivated_t : ICallbackData
{
	internal byte Active;

	[MarshalAs(UnmanagedType.I1)]
	internal bool UserInitiated;

	internal AppId AppID;

	internal uint DwOverlayPID;

	public static int _datasize = Marshal.SizeOf(typeof(GameOverlayActivated_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GameOverlayActivated;
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GameServerChangeRequested_t : ICallbackData
{
	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	internal byte[] Server;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	internal byte[] Password;

	public static int _datasize = Marshal.SizeOf(typeof(GameServerChangeRequested_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GameServerChangeRequested;

	internal string ServerUTF8()
	{
		return Utility.Utf8NoBom.GetString(Server, 0, Array.IndexOf(Server, (byte)0));
	}

	internal string PasswordUTF8()
	{
		return Utility.Utf8NoBom.GetString(Password, 0, Array.IndexOf(Password, (byte)0));
	}
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GameLobbyJoinRequested_t : ICallbackData
{
	internal ulong SteamIDLobby;

	internal ulong SteamIDFriend;

	public static int _datasize = Marshal.SizeOf(typeof(GameLobbyJoinRequested_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GameLobbyJoinRequested;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct AvatarImageLoaded_t : ICallbackData
{
	internal ulong SteamID;

	internal int Image;

	internal int Wide;

	internal int Tall;

	public static int _datasize = Marshal.SizeOf(typeof(AvatarImageLoaded_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.AvatarImageLoaded;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct ClanOfficerListResponse_t : ICallbackData
{
	internal ulong SteamIDClan;

	internal int COfficers;

	internal byte Success;

	public static int _datasize = Marshal.SizeOf(typeof(ClanOfficerListResponse_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.ClanOfficerListResponse;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct FriendRichPresenceUpdate_t : ICallbackData
{
	internal ulong SteamIDFriend;

	internal AppId AppID;

	public static int _datasize = Marshal.SizeOf(typeof(FriendRichPresenceUpdate_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.FriendRichPresenceUpdate;
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GameRichPresenceJoinRequested_t : ICallbackData
{
	internal ulong SteamIDFriend;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
	internal byte[] Connect;

	public static int _datasize = Marshal.SizeOf(typeof(GameRichPresenceJoinRequested_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GameRichPresenceJoinRequested;

	internal string ConnectUTF8()
	{
		return Utility.Utf8NoBom.GetString(Connect, 0, Array.IndexOf(Connect, (byte)0));
	}
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GameConnectedClanChatMsg_t : ICallbackData
{
	internal ulong SteamIDClanChat;

	internal ulong SteamIDUser;

	internal int MessageID;

	public static int _datasize = Marshal.SizeOf(typeof(GameConnectedClanChatMsg_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GameConnectedClanChatMsg;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GameConnectedChatJoin_t : ICallbackData
{
	internal ulong SteamIDClanChat;

	internal ulong SteamIDUser;

	public static int _datasize = Marshal.SizeOf(typeof(GameConnectedChatJoin_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GameConnectedChatJoin;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GameConnectedChatLeave_t : ICallbackData
{
	internal ulong SteamIDClanChat;

	internal ulong SteamIDUser;

	[MarshalAs(UnmanagedType.I1)]
	internal bool Kicked;

	[MarshalAs(UnmanagedType.I1)]
	internal bool Dropped;

	public static int _datasize = Marshal.SizeOf(typeof(GameConnectedChatLeave_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GameConnectedChatLeave;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct DownloadClanActivityCountsResult_t : ICallbackData
{
	[MarshalAs(UnmanagedType.I1)]
	internal bool Success;

	public static int _datasize = Marshal.SizeOf(typeof(DownloadClanActivityCountsResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.DownloadClanActivityCountsResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct JoinClanChatRoomCompletionResult_t : ICallbackData
{
	internal ulong SteamIDClanChat;

	internal RoomEnter ChatRoomEnterResponse;

	public static int _datasize = Marshal.SizeOf(typeof(JoinClanChatRoomCompletionResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.JoinClanChatRoomCompletionResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GameConnectedFriendChatMsg_t : ICallbackData
{
	internal ulong SteamIDUser;

	internal int MessageID;

	public static int _datasize = Marshal.SizeOf(typeof(GameConnectedFriendChatMsg_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GameConnectedFriendChatMsg;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct FriendsGetFollowerCount_t : ICallbackData
{
	internal Result Result;

	internal ulong SteamID;

	internal int Count;

	public static int _datasize = Marshal.SizeOf(typeof(FriendsGetFollowerCount_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.FriendsGetFollowerCount;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct FriendsIsFollowing_t : ICallbackData
{
	internal Result Result;

	internal ulong SteamID;

	[MarshalAs(UnmanagedType.I1)]
	internal bool IsFollowing;

	public static int _datasize = Marshal.SizeOf(typeof(FriendsIsFollowing_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.FriendsIsFollowing;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct FriendsEnumerateFollowingList_t : ICallbackData
{
	internal Result Result;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 50, ArraySubType = UnmanagedType.U8)]
	internal ulong[] GSteamID;

	internal int ResultsReturned;

	internal int TotalResultCount;

	public static int _datasize = Marshal.SizeOf(typeof(FriendsEnumerateFollowingList_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.FriendsEnumerateFollowingList;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SetPersonaNameResponse_t : ICallbackData
{
	[MarshalAs(UnmanagedType.I1)]
	internal bool Success;

	[MarshalAs(UnmanagedType.I1)]
	internal bool LocalSuccess;

	internal Result Result;

	public static int _datasize = Marshal.SizeOf(typeof(SetPersonaNameResponse_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SetPersonaNameResponse;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct UnreadChatMessagesChanged_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(UnreadChatMessagesChanged_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.UnreadChatMessagesChanged;
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct OverlayBrowserProtocolNavigation_t : ICallbackData
{
	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 1024)]
	internal byte[] RgchURI;

	public static int _datasize = Marshal.SizeOf(typeof(OverlayBrowserProtocolNavigation_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.OverlayBrowserProtocolNavigation;

	internal string RgchURIUTF8()
	{
		return Utility.Utf8NoBom.GetString(RgchURI, 0, Array.IndexOf(RgchURI, (byte)0));
	}
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct EquippedProfileItemsChanged_t : ICallbackData
{
	internal ulong SteamID;

	public static int _datasize = Marshal.SizeOf(typeof(EquippedProfileItemsChanged_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.EquippedProfileItemsChanged;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct EquippedProfileItems_t : ICallbackData
{
	internal Result Result;

	internal ulong SteamID;

	[MarshalAs(UnmanagedType.I1)]
	internal bool HasAnimatedAvatar;

	[MarshalAs(UnmanagedType.I1)]
	internal bool HasAvatarFrame;

	[MarshalAs(UnmanagedType.I1)]
	internal bool HasProfileModifier;

	[MarshalAs(UnmanagedType.I1)]
	internal bool HasProfileBackground;

	[MarshalAs(UnmanagedType.I1)]
	internal bool HasMiniProfileBackground;

	[MarshalAs(UnmanagedType.I1)]
	internal bool FromCache;

	public static int _datasize = Marshal.SizeOf(typeof(EquippedProfileItems_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.EquippedProfileItems;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct IPCountry_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(IPCountry_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.IPCountry;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct LowBatteryPower_t : ICallbackData
{
	internal byte MinutesBatteryLeft;

	public static int _datasize = Marshal.SizeOf(typeof(LowBatteryPower_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.LowBatteryPower;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamAPICallCompleted_t : ICallbackData
{
	internal ulong AsyncCall;

	internal int Callback;

	internal uint ParamCount;

	public static int _datasize = Marshal.SizeOf(typeof(SteamAPICallCompleted_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamAPICallCompleted;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamShutdown_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(SteamShutdown_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamShutdown;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct CheckFileSignature_t : ICallbackData
{
	internal CheckFileSignature CheckFileSignature;

	public static int _datasize = Marshal.SizeOf(typeof(CheckFileSignature_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.CheckFileSignature;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GamepadTextInputDismissed_t : ICallbackData
{
	[MarshalAs(UnmanagedType.I1)]
	internal bool Submitted;

	internal uint SubmittedText;

	internal AppId AppID;

	public static int _datasize = Marshal.SizeOf(typeof(GamepadTextInputDismissed_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GamepadTextInputDismissed;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct AppResumingFromSuspend_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(AppResumingFromSuspend_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.AppResumingFromSuspend;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct FloatingGamepadTextInputDismissed_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(FloatingGamepadTextInputDismissed_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.FloatingGamepadTextInputDismissed;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct FilterTextDictionaryChanged_t : ICallbackData
{
	internal int Language;

	public static int _datasize = Marshal.SizeOf(typeof(FilterTextDictionaryChanged_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.FilterTextDictionaryChanged;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct FavoritesListChanged_t : ICallbackData
{
	internal uint IP;

	internal uint QueryPort;

	internal uint ConnPort;

	internal uint AppID;

	internal uint Flags;

	[MarshalAs(UnmanagedType.I1)]
	internal bool Add;

	internal uint AccountId;

	public static int _datasize = Marshal.SizeOf(typeof(FavoritesListChanged_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.FavoritesListChanged;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct LobbyInvite_t : ICallbackData
{
	internal ulong SteamIDUser;

	internal ulong SteamIDLobby;

	internal ulong GameID;

	public static int _datasize = Marshal.SizeOf(typeof(LobbyInvite_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.LobbyInvite;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct LobbyEnter_t : ICallbackData
{
	internal ulong SteamIDLobby;

	internal uint GfChatPermissions;

	[MarshalAs(UnmanagedType.I1)]
	internal bool Locked;

	internal uint EChatRoomEnterResponse;

	public static int _datasize = Marshal.SizeOf(typeof(LobbyEnter_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.LobbyEnter;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct LobbyDataUpdate_t : ICallbackData
{
	internal ulong SteamIDLobby;

	internal ulong SteamIDMember;

	internal byte Success;

	public static int _datasize = Marshal.SizeOf(typeof(LobbyDataUpdate_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.LobbyDataUpdate;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct LobbyChatUpdate_t : ICallbackData
{
	internal ulong SteamIDLobby;

	internal ulong SteamIDUserChanged;

	internal ulong SteamIDMakingChange;

	internal uint GfChatMemberStateChange;

	public static int _datasize = Marshal.SizeOf(typeof(LobbyChatUpdate_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.LobbyChatUpdate;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct LobbyChatMsg_t : ICallbackData
{
	internal ulong SteamIDLobby;

	internal ulong SteamIDUser;

	internal byte ChatEntryType;

	internal uint ChatID;

	public static int _datasize = Marshal.SizeOf(typeof(LobbyChatMsg_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.LobbyChatMsg;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct LobbyGameCreated_t : ICallbackData
{
	internal ulong SteamIDLobby;

	internal ulong SteamIDGameServer;

	internal uint IP;

	internal ushort Port;

	public static int _datasize = Marshal.SizeOf(typeof(LobbyGameCreated_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.LobbyGameCreated;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct LobbyMatchList_t : ICallbackData
{
	internal uint LobbiesMatching;

	public static int _datasize = Marshal.SizeOf(typeof(LobbyMatchList_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.LobbyMatchList;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct LobbyKicked_t : ICallbackData
{
	internal ulong SteamIDLobby;

	internal ulong SteamIDAdmin;

	internal byte KickedDueToDisconnect;

	public static int _datasize = Marshal.SizeOf(typeof(LobbyKicked_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.LobbyKicked;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct LobbyCreated_t : ICallbackData
{
	internal Result Result;

	internal ulong SteamIDLobby;

	public static int _datasize = Marshal.SizeOf(typeof(LobbyCreated_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.LobbyCreated;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct PSNGameBootInviteResult_t : ICallbackData
{
	[MarshalAs(UnmanagedType.I1)]
	internal bool GameBootInviteExists;

	internal ulong SteamIDLobby;

	public static int _datasize = Marshal.SizeOf(typeof(PSNGameBootInviteResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.PSNGameBootInviteResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct FavoritesListAccountsUpdated_t : ICallbackData
{
	internal Result Result;

	public static int _datasize = Marshal.SizeOf(typeof(FavoritesListAccountsUpdated_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.FavoritesListAccountsUpdated;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SearchForGameProgressCallback_t : ICallbackData
{
	internal ulong LSearchID;

	internal Result Result;

	internal ulong LobbyID;

	internal ulong SteamIDEndedSearch;

	internal int SecondsRemainingEstimate;

	internal int CPlayersSearching;

	public static int _datasize = Marshal.SizeOf(typeof(SearchForGameProgressCallback_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SearchForGameProgressCallback;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SearchForGameResultCallback_t : ICallbackData
{
	internal ulong LSearchID;

	internal Result Result;

	internal int CountPlayersInGame;

	internal int CountAcceptedGame;

	internal ulong SteamIDHost;

	[MarshalAs(UnmanagedType.I1)]
	internal bool FinalCallback;

	public static int _datasize = Marshal.SizeOf(typeof(SearchForGameResultCallback_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SearchForGameResultCallback;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RequestPlayersForGameProgressCallback_t : ICallbackData
{
	internal Result Result;

	internal ulong LSearchID;

	public static int _datasize = Marshal.SizeOf(typeof(RequestPlayersForGameProgressCallback_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RequestPlayersForGameProgressCallback;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RequestPlayersForGameResultCallback_t : ICallbackData
{
	internal enum PlayerAcceptState_t
	{
		Unknown,
		PlayerAccepted,
		PlayerDeclined
	}

	internal Result Result;

	internal ulong LSearchID;

	internal ulong SteamIDPlayerFound;

	internal ulong SteamIDLobby;

	internal PlayerAcceptState_t PlayerAcceptState;

	internal int PlayerIndex;

	internal int TotalPlayersFound;

	internal int TotalPlayersAcceptedGame;

	internal int SuggestedTeamIndex;

	internal ulong LUniqueGameID;

	public static int _datasize = Marshal.SizeOf(typeof(RequestPlayersForGameResultCallback_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RequestPlayersForGameResultCallback;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RequestPlayersForGameFinalResultCallback_t : ICallbackData
{
	internal Result Result;

	internal ulong LSearchID;

	internal ulong LUniqueGameID;

	public static int _datasize = Marshal.SizeOf(typeof(RequestPlayersForGameFinalResultCallback_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RequestPlayersForGameFinalResultCallback;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SubmitPlayerResultResultCallback_t : ICallbackData
{
	internal Result Result;

	internal ulong UllUniqueGameID;

	internal ulong SteamIDPlayer;

	public static int _datasize = Marshal.SizeOf(typeof(SubmitPlayerResultResultCallback_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SubmitPlayerResultResultCallback;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct EndGameResultCallback_t : ICallbackData
{
	internal Result Result;

	internal ulong UllUniqueGameID;

	public static int _datasize = Marshal.SizeOf(typeof(EndGameResultCallback_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.EndGameResultCallback;
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct JoinPartyCallback_t : ICallbackData
{
	internal Result Result;

	internal ulong BeaconID;

	internal ulong SteamIDBeaconOwner;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
	internal byte[] ConnectString;

	public static int _datasize = Marshal.SizeOf(typeof(JoinPartyCallback_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.JoinPartyCallback;

	internal string ConnectStringUTF8()
	{
		return Utility.Utf8NoBom.GetString(ConnectString, 0, Array.IndexOf(ConnectString, (byte)0));
	}
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct CreateBeaconCallback_t : ICallbackData
{
	internal Result Result;

	internal ulong BeaconID;

	public static int _datasize = Marshal.SizeOf(typeof(CreateBeaconCallback_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.CreateBeaconCallback;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct ReservationNotificationCallback_t : ICallbackData
{
	internal ulong BeaconID;

	internal ulong SteamIDJoiner;

	public static int _datasize = Marshal.SizeOf(typeof(ReservationNotificationCallback_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.ReservationNotificationCallback;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct ChangeNumOpenSlotsCallback_t : ICallbackData
{
	internal Result Result;

	public static int _datasize = Marshal.SizeOf(typeof(ChangeNumOpenSlotsCallback_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.ChangeNumOpenSlotsCallback;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct AvailableBeaconLocationsUpdated_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(AvailableBeaconLocationsUpdated_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.AvailableBeaconLocationsUpdated;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct ActiveBeaconsUpdated_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(ActiveBeaconsUpdated_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.ActiveBeaconsUpdated;
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStorageFileShareResult_t : ICallbackData
{
	internal Result Result;

	internal ulong File;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 260)]
	internal byte[] Filename;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStorageFileShareResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStorageFileShareResult;

	internal string FilenameUTF8()
	{
		return Utility.Utf8NoBom.GetString(Filename, 0, Array.IndexOf(Filename, (byte)0));
	}
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStoragePublishFileResult_t : ICallbackData
{
	internal Result Result;

	internal PublishedFileId PublishedFileId;

	[MarshalAs(UnmanagedType.I1)]
	internal bool UserNeedsToAcceptWorkshopLegalAgreement;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStoragePublishFileResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStoragePublishFileResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStorageDeletePublishedFileResult_t : ICallbackData
{
	internal Result Result;

	internal PublishedFileId PublishedFileId;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStorageDeletePublishedFileResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStorageDeletePublishedFileResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStorageEnumerateUserPublishedFilesResult_t : ICallbackData
{
	internal Result Result;

	internal int ResultsReturned;

	internal int TotalResultCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 50, ArraySubType = UnmanagedType.U8)]
	internal PublishedFileId[] GPublishedFileId;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStorageEnumerateUserPublishedFilesResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStorageEnumerateUserPublishedFilesResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStorageSubscribePublishedFileResult_t : ICallbackData
{
	internal Result Result;

	internal PublishedFileId PublishedFileId;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStorageSubscribePublishedFileResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStorageSubscribePublishedFileResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStorageEnumerateUserSubscribedFilesResult_t : ICallbackData
{
	internal Result Result;

	internal int ResultsReturned;

	internal int TotalResultCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 50, ArraySubType = UnmanagedType.U8)]
	internal PublishedFileId[] GPublishedFileId;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 50, ArraySubType = UnmanagedType.U4)]
	internal uint[] GRTimeSubscribed;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStorageEnumerateUserSubscribedFilesResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStorageEnumerateUserSubscribedFilesResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStorageUnsubscribePublishedFileResult_t : ICallbackData
{
	internal Result Result;

	internal PublishedFileId PublishedFileId;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStorageUnsubscribePublishedFileResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStorageUnsubscribePublishedFileResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStorageUpdatePublishedFileResult_t : ICallbackData
{
	internal Result Result;

	internal PublishedFileId PublishedFileId;

	[MarshalAs(UnmanagedType.I1)]
	internal bool UserNeedsToAcceptWorkshopLegalAgreement;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStorageUpdatePublishedFileResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStorageUpdatePublishedFileResult;
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStorageDownloadUGCResult_t : ICallbackData
{
	internal Result Result;

	internal ulong File;

	internal AppId AppID;

	internal int SizeInBytes;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 260)]
	internal byte[] PchFileName;

	internal ulong SteamIDOwner;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStorageDownloadUGCResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStorageDownloadUGCResult;

	internal string PchFileNameUTF8()
	{
		return Utility.Utf8NoBom.GetString(PchFileName, 0, Array.IndexOf(PchFileName, (byte)0));
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStorageGetPublishedFileDetailsResult_t : ICallbackData
{
	internal Result Result;

	internal PublishedFileId PublishedFileId;

	internal AppId CreatorAppID;

	internal AppId ConsumerAppID;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 129)]
	internal byte[] Title;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8000)]
	internal byte[] Description;

	internal ulong File;

	internal ulong PreviewFile;

	internal ulong SteamIDOwner;

	internal uint TimeCreated;

	internal uint TimeUpdated;

	internal RemoteStoragePublishedFileVisibility Visibility;

	[MarshalAs(UnmanagedType.I1)]
	internal bool Banned;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 1025)]
	internal byte[] Tags;

	[MarshalAs(UnmanagedType.I1)]
	internal bool TagsTruncated;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 260)]
	internal byte[] PchFileName;

	internal int FileSize;

	internal int PreviewFileSize;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
	internal byte[] URL;

	internal WorkshopFileType FileType;

	[MarshalAs(UnmanagedType.I1)]
	internal bool AcceptedForUse;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStorageGetPublishedFileDetailsResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStorageGetPublishedFileDetailsResult;

	internal string TitleUTF8()
	{
		return Utility.Utf8NoBom.GetString(Title, 0, Array.IndexOf(Title, (byte)0));
	}

	internal string DescriptionUTF8()
	{
		return Utility.Utf8NoBom.GetString(Description, 0, Array.IndexOf(Description, (byte)0));
	}

	internal string TagsUTF8()
	{
		return Utility.Utf8NoBom.GetString(Tags, 0, Array.IndexOf(Tags, (byte)0));
	}

	internal string PchFileNameUTF8()
	{
		return Utility.Utf8NoBom.GetString(PchFileName, 0, Array.IndexOf(PchFileName, (byte)0));
	}

	internal string URLUTF8()
	{
		return Utility.Utf8NoBom.GetString(URL, 0, Array.IndexOf(URL, (byte)0));
	}
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStorageEnumerateWorkshopFilesResult_t : ICallbackData
{
	internal Result Result;

	internal int ResultsReturned;

	internal int TotalResultCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 50, ArraySubType = UnmanagedType.U8)]
	internal PublishedFileId[] GPublishedFileId;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 50, ArraySubType = UnmanagedType.R4)]
	internal float[] GScore;

	internal AppId AppId;

	internal uint StartIndex;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStorageEnumerateWorkshopFilesResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStorageEnumerateWorkshopFilesResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStorageGetPublishedItemVoteDetailsResult_t : ICallbackData
{
	internal Result Result;

	internal PublishedFileId PublishedFileId;

	internal int VotesFor;

	internal int VotesAgainst;

	internal int Reports;

	internal float FScore;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStorageGetPublishedItemVoteDetailsResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStorageGetPublishedItemVoteDetailsResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStoragePublishedFileSubscribed_t : ICallbackData
{
	internal PublishedFileId PublishedFileId;

	internal AppId AppID;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStoragePublishedFileSubscribed_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStoragePublishedFileSubscribed;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStoragePublishedFileUnsubscribed_t : ICallbackData
{
	internal PublishedFileId PublishedFileId;

	internal AppId AppID;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStoragePublishedFileUnsubscribed_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStoragePublishedFileUnsubscribed;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStoragePublishedFileDeleted_t : ICallbackData
{
	internal PublishedFileId PublishedFileId;

	internal AppId AppID;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStoragePublishedFileDeleted_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStoragePublishedFileDeleted;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStorageUpdateUserPublishedItemVoteResult_t : ICallbackData
{
	internal Result Result;

	internal PublishedFileId PublishedFileId;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStorageUpdateUserPublishedItemVoteResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStorageUpdateUserPublishedItemVoteResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStorageUserVoteDetails_t : ICallbackData
{
	internal Result Result;

	internal PublishedFileId PublishedFileId;

	internal WorkshopVote Vote;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStorageUserVoteDetails_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStorageUserVoteDetails;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStorageEnumerateUserSharedWorkshopFilesResult_t : ICallbackData
{
	internal Result Result;

	internal int ResultsReturned;

	internal int TotalResultCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 50, ArraySubType = UnmanagedType.U8)]
	internal PublishedFileId[] GPublishedFileId;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStorageEnumerateUserSharedWorkshopFilesResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStorageEnumerateUserSharedWorkshopFilesResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStorageSetUserPublishedFileActionResult_t : ICallbackData
{
	internal Result Result;

	internal PublishedFileId PublishedFileId;

	internal WorkshopFileAction Action;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStorageSetUserPublishedFileActionResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStorageSetUserPublishedFileActionResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStorageEnumeratePublishedFilesByUserActionResult_t : ICallbackData
{
	internal Result Result;

	internal WorkshopFileAction Action;

	internal int ResultsReturned;

	internal int TotalResultCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 50, ArraySubType = UnmanagedType.U8)]
	internal PublishedFileId[] GPublishedFileId;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 50, ArraySubType = UnmanagedType.U4)]
	internal uint[] GRTimeUpdated;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStorageEnumeratePublishedFilesByUserActionResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStorageEnumeratePublishedFilesByUserActionResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStoragePublishFileProgress_t : ICallbackData
{
	internal double DPercentFile;

	[MarshalAs(UnmanagedType.I1)]
	internal bool Preview;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStoragePublishFileProgress_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStoragePublishFileProgress;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStoragePublishedFileUpdated_t : ICallbackData
{
	internal PublishedFileId PublishedFileId;

	internal AppId AppID;

	internal ulong Unused;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStoragePublishedFileUpdated_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStoragePublishedFileUpdated;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStorageFileWriteAsyncComplete_t : ICallbackData
{
	internal Result Result;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStorageFileWriteAsyncComplete_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStorageFileWriteAsyncComplete;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStorageFileReadAsyncComplete_t : ICallbackData
{
	internal ulong FileReadAsync;

	internal Result Result;

	internal uint Offset;

	internal uint Read;

	public static int _datasize = Marshal.SizeOf(typeof(RemoteStorageFileReadAsyncComplete_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStorageFileReadAsyncComplete;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoteStorageLocalFileChange_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(RemoteStorageLocalFileChange_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoteStorageLocalFileChange;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct UserStatsReceived_t : ICallbackData
{
	internal ulong GameID;

	internal Result Result;

	internal ulong SteamIDUser;

	public static int _datasize = Marshal.SizeOf(typeof(UserStatsReceived_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.UserStatsReceived;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct UserStatsStored_t : ICallbackData
{
	internal ulong GameID;

	internal Result Result;

	public static int _datasize = Marshal.SizeOf(typeof(UserStatsStored_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.UserStatsStored;
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct UserAchievementStored_t : ICallbackData
{
	internal ulong GameID;

	[MarshalAs(UnmanagedType.I1)]
	internal bool GroupAchievement;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]
	internal byte[] AchievementName;

	internal uint CurProgress;

	internal uint MaxProgress;

	public static int _datasize = Marshal.SizeOf(typeof(UserAchievementStored_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.UserAchievementStored;

	internal string AchievementNameUTF8()
	{
		return Utility.Utf8NoBom.GetString(AchievementName, 0, Array.IndexOf(AchievementName, (byte)0));
	}
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct LeaderboardFindResult_t : ICallbackData
{
	internal ulong SteamLeaderboard;

	internal byte LeaderboardFound;

	public static int _datasize = Marshal.SizeOf(typeof(LeaderboardFindResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.LeaderboardFindResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct LeaderboardScoresDownloaded_t : ICallbackData
{
	internal ulong SteamLeaderboard;

	internal ulong SteamLeaderboardEntries;

	internal int CEntryCount;

	public static int _datasize = Marshal.SizeOf(typeof(LeaderboardScoresDownloaded_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.LeaderboardScoresDownloaded;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct LeaderboardScoreUploaded_t : ICallbackData
{
	internal byte Success;

	internal ulong SteamLeaderboard;

	internal int Score;

	internal byte ScoreChanged;

	internal int GlobalRankNew;

	internal int GlobalRankPrevious;

	public static int _datasize = Marshal.SizeOf(typeof(LeaderboardScoreUploaded_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.LeaderboardScoreUploaded;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct NumberOfCurrentPlayers_t : ICallbackData
{
	internal byte Success;

	internal int CPlayers;

	public static int _datasize = Marshal.SizeOf(typeof(NumberOfCurrentPlayers_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.NumberOfCurrentPlayers;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct UserStatsUnloaded_t : ICallbackData
{
	internal ulong SteamIDUser;

	public static int _datasize = Marshal.SizeOf(typeof(UserStatsUnloaded_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.UserStatsUnloaded;
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct UserAchievementIconFetched_t : ICallbackData
{
	internal GameId GameID;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]
	internal byte[] AchievementName;

	[MarshalAs(UnmanagedType.I1)]
	internal bool Achieved;

	internal int IconHandle;

	public static int _datasize = Marshal.SizeOf(typeof(UserAchievementIconFetched_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.UserAchievementIconFetched;

	internal string AchievementNameUTF8()
	{
		return Utility.Utf8NoBom.GetString(AchievementName, 0, Array.IndexOf(AchievementName, (byte)0));
	}
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GlobalAchievementPercentagesReady_t : ICallbackData
{
	internal ulong GameID;

	internal Result Result;

	public static int _datasize = Marshal.SizeOf(typeof(GlobalAchievementPercentagesReady_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GlobalAchievementPercentagesReady;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct LeaderboardUGCSet_t : ICallbackData
{
	internal Result Result;

	internal ulong SteamLeaderboard;

	public static int _datasize = Marshal.SizeOf(typeof(LeaderboardUGCSet_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.LeaderboardUGCSet;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GlobalStatsReceived_t : ICallbackData
{
	internal ulong GameID;

	internal Result Result;

	public static int _datasize = Marshal.SizeOf(typeof(GlobalStatsReceived_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GlobalStatsReceived;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct DlcInstalled_t : ICallbackData
{
	internal AppId AppID;

	public static int _datasize = Marshal.SizeOf(typeof(DlcInstalled_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.DlcInstalled;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct NewUrlLaunchParameters_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(NewUrlLaunchParameters_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.NewUrlLaunchParameters;
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct AppProofOfPurchaseKeyResponse_t : ICallbackData
{
	internal Result Result;

	internal uint AppID;

	internal uint CchKeyLength;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 240)]
	internal byte[] Key;

	public static int _datasize = Marshal.SizeOf(typeof(AppProofOfPurchaseKeyResponse_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.AppProofOfPurchaseKeyResponse;

	internal string KeyUTF8()
	{
		return Utility.Utf8NoBom.GetString(Key, 0, Array.IndexOf(Key, (byte)0));
	}
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct FileDetailsResult_t : ICallbackData
{
	internal Result Result;

	internal ulong FileSize;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 20)]
	internal byte[] FileSHA;

	internal uint Flags;

	public static int _datasize = Marshal.SizeOf(typeof(FileDetailsResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.FileDetailsResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct TimedTrialStatus_t : ICallbackData
{
	internal AppId AppID;

	[MarshalAs(UnmanagedType.I1)]
	internal bool IsOffline;

	internal uint SecondsAllowed;

	internal uint SecondsPlayed;

	public static int _datasize = Marshal.SizeOf(typeof(TimedTrialStatus_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.TimedTrialStatus;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct P2PSessionRequest_t : ICallbackData
{
	internal ulong SteamIDRemote;

	public static int _datasize = Marshal.SizeOf(typeof(P2PSessionRequest_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.P2PSessionRequest;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct P2PSessionConnectFail_t : ICallbackData
{
	internal ulong SteamIDRemote;

	internal byte P2PSessionError;

	public static int _datasize = Marshal.SizeOf(typeof(P2PSessionConnectFail_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.P2PSessionConnectFail;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct ScreenshotReady_t : ICallbackData
{
	internal uint Local;

	internal Result Result;

	public static int _datasize = Marshal.SizeOf(typeof(ScreenshotReady_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.ScreenshotReady;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct ScreenshotRequested_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(ScreenshotRequested_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.ScreenshotRequested;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct PlaybackStatusHasChanged_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(PlaybackStatusHasChanged_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.PlaybackStatusHasChanged;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct VolumeHasChanged_t : ICallbackData
{
	internal float NewVolume;

	public static int _datasize = Marshal.SizeOf(typeof(VolumeHasChanged_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.VolumeHasChanged;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct MusicPlayerRemoteWillActivate_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(MusicPlayerRemoteWillActivate_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.MusicPlayerRemoteWillActivate;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct MusicPlayerRemoteWillDeactivate_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(MusicPlayerRemoteWillDeactivate_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.MusicPlayerRemoteWillDeactivate;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct MusicPlayerRemoteToFront_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(MusicPlayerRemoteToFront_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.MusicPlayerRemoteToFront;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct MusicPlayerWillQuit_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(MusicPlayerWillQuit_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.MusicPlayerWillQuit;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct MusicPlayerWantsPlay_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(MusicPlayerWantsPlay_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.MusicPlayerWantsPlay;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct MusicPlayerWantsPause_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(MusicPlayerWantsPause_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.MusicPlayerWantsPause;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct MusicPlayerWantsPlayPrevious_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(MusicPlayerWantsPlayPrevious_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.MusicPlayerWantsPlayPrevious;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct MusicPlayerWantsPlayNext_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(MusicPlayerWantsPlayNext_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.MusicPlayerWantsPlayNext;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct MusicPlayerWantsShuffled_t : ICallbackData
{
	[MarshalAs(UnmanagedType.I1)]
	internal bool Shuffled;

	public static int _datasize = Marshal.SizeOf(typeof(MusicPlayerWantsShuffled_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.MusicPlayerWantsShuffled;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct MusicPlayerWantsLooped_t : ICallbackData
{
	[MarshalAs(UnmanagedType.I1)]
	internal bool Looped;

	public static int _datasize = Marshal.SizeOf(typeof(MusicPlayerWantsLooped_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.MusicPlayerWantsLooped;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct MusicPlayerWantsVolume_t : ICallbackData
{
	internal float NewVolume;

	public static int _datasize = Marshal.SizeOf(typeof(MusicPlayerWantsVolume_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.MusicPlayerWantsVolume;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct MusicPlayerSelectsQueueEntry_t : ICallbackData
{
	internal int NID;

	public static int _datasize = Marshal.SizeOf(typeof(MusicPlayerSelectsQueueEntry_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.MusicPlayerSelectsQueueEntry;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct MusicPlayerSelectsPlaylistEntry_t : ICallbackData
{
	internal int NID;

	public static int _datasize = Marshal.SizeOf(typeof(MusicPlayerSelectsPlaylistEntry_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.MusicPlayerSelectsPlaylistEntry;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct MusicPlayerWantsPlayingRepeatStatus_t : ICallbackData
{
	internal int PlayingRepeatStatus;

	public static int _datasize = Marshal.SizeOf(typeof(MusicPlayerWantsPlayingRepeatStatus_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.MusicPlayerWantsPlayingRepeatStatus;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTTPRequestCompleted_t : ICallbackData
{
	internal uint Request;

	internal ulong ContextValue;

	[MarshalAs(UnmanagedType.I1)]
	internal bool RequestSuccessful;

	internal HTTPStatusCode StatusCode;

	internal uint BodySize;

	public static int _datasize = Marshal.SizeOf(typeof(HTTPRequestCompleted_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTTPRequestCompleted;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTTPRequestHeadersReceived_t : ICallbackData
{
	internal uint Request;

	internal ulong ContextValue;

	public static int _datasize = Marshal.SizeOf(typeof(HTTPRequestHeadersReceived_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTTPRequestHeadersReceived;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTTPRequestDataReceived_t : ICallbackData
{
	internal uint Request;

	internal ulong ContextValue;

	internal uint COffset;

	internal uint CBytesReceived;

	public static int _datasize = Marshal.SizeOf(typeof(HTTPRequestDataReceived_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTTPRequestDataReceived;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamInputDeviceConnected_t : ICallbackData
{
	internal ulong ConnectedDeviceHandle;

	public static int _datasize = Marshal.SizeOf(typeof(SteamInputDeviceConnected_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamInputDeviceConnected;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamInputDeviceDisconnected_t : ICallbackData
{
	internal ulong DisconnectedDeviceHandle;

	public static int _datasize = Marshal.SizeOf(typeof(SteamInputDeviceDisconnected_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamInputDeviceDisconnected;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamInputConfigurationLoaded_t : ICallbackData
{
	internal AppId AppID;

	internal ulong DeviceHandle;

	internal ulong MappingCreator;

	internal uint MajorRevision;

	internal uint MinorRevision;

	[MarshalAs(UnmanagedType.I1)]
	internal bool UsesSteamInputAPI;

	[MarshalAs(UnmanagedType.I1)]
	internal bool UsesGamepadAPI;

	public static int _datasize = Marshal.SizeOf(typeof(SteamInputConfigurationLoaded_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamInputConfigurationLoaded;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamInputGamepadSlotChange_t : ICallbackData
{
	internal AppId AppID;

	internal ulong DeviceHandle;

	internal InputType DeviceType;

	internal int OldGamepadSlot;

	internal int NewGamepadSlot;

	public static int _datasize = Marshal.SizeOf(typeof(SteamInputGamepadSlotChange_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamInputGamepadSlotChange;
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamUGCQueryCompleted_t : ICallbackData
{
	internal ulong Handle;

	internal Result Result;

	internal uint NumResultsReturned;

	internal uint TotalMatchingResults;

	[MarshalAs(UnmanagedType.I1)]
	internal bool CachedData;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
	internal byte[] NextCursor;

	public static int _datasize = Marshal.SizeOf(typeof(SteamUGCQueryCompleted_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamUGCQueryCompleted;

	internal string NextCursorUTF8()
	{
		return Utility.Utf8NoBom.GetString(NextCursor, 0, Array.IndexOf(NextCursor, (byte)0));
	}
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamUGCRequestUGCDetailsResult_t : ICallbackData
{
	internal SteamUGCDetails_t Details;

	[MarshalAs(UnmanagedType.I1)]
	internal bool CachedData;

	public static int _datasize = Marshal.SizeOf(typeof(SteamUGCRequestUGCDetailsResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamUGCRequestUGCDetailsResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct CreateItemResult_t : ICallbackData
{
	internal Result Result;

	internal PublishedFileId PublishedFileId;

	[MarshalAs(UnmanagedType.I1)]
	internal bool UserNeedsToAcceptWorkshopLegalAgreement;

	public static int _datasize = Marshal.SizeOf(typeof(CreateItemResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.CreateItemResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SubmitItemUpdateResult_t : ICallbackData
{
	internal Result Result;

	[MarshalAs(UnmanagedType.I1)]
	internal bool UserNeedsToAcceptWorkshopLegalAgreement;

	internal PublishedFileId PublishedFileId;

	public static int _datasize = Marshal.SizeOf(typeof(SubmitItemUpdateResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SubmitItemUpdateResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct ItemInstalled_t : ICallbackData
{
	internal AppId AppID;

	internal PublishedFileId PublishedFileId;

	internal ulong LegacyContent;

	internal ulong ManifestID;

	public static int _datasize = Marshal.SizeOf(typeof(ItemInstalled_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.ItemInstalled;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct DownloadItemResult_t : ICallbackData
{
	internal AppId AppID;

	internal PublishedFileId PublishedFileId;

	internal Result Result;

	public static int _datasize = Marshal.SizeOf(typeof(DownloadItemResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.DownloadItemResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct UserFavoriteItemsListChanged_t : ICallbackData
{
	internal PublishedFileId PublishedFileId;

	internal Result Result;

	[MarshalAs(UnmanagedType.I1)]
	internal bool WasAddRequest;

	public static int _datasize = Marshal.SizeOf(typeof(UserFavoriteItemsListChanged_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.UserFavoriteItemsListChanged;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SetUserItemVoteResult_t : ICallbackData
{
	internal PublishedFileId PublishedFileId;

	internal Result Result;

	[MarshalAs(UnmanagedType.I1)]
	internal bool VoteUp;

	public static int _datasize = Marshal.SizeOf(typeof(SetUserItemVoteResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SetUserItemVoteResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GetUserItemVoteResult_t : ICallbackData
{
	internal PublishedFileId PublishedFileId;

	internal Result Result;

	[MarshalAs(UnmanagedType.I1)]
	internal bool VotedUp;

	[MarshalAs(UnmanagedType.I1)]
	internal bool VotedDown;

	[MarshalAs(UnmanagedType.I1)]
	internal bool VoteSkipped;

	public static int _datasize = Marshal.SizeOf(typeof(GetUserItemVoteResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GetUserItemVoteResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct StartPlaytimeTrackingResult_t : ICallbackData
{
	internal Result Result;

	public static int _datasize = Marshal.SizeOf(typeof(StartPlaytimeTrackingResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.StartPlaytimeTrackingResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct StopPlaytimeTrackingResult_t : ICallbackData
{
	internal Result Result;

	public static int _datasize = Marshal.SizeOf(typeof(StopPlaytimeTrackingResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.StopPlaytimeTrackingResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct AddUGCDependencyResult_t : ICallbackData
{
	internal Result Result;

	internal PublishedFileId PublishedFileId;

	internal PublishedFileId ChildPublishedFileId;

	public static int _datasize = Marshal.SizeOf(typeof(AddUGCDependencyResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.AddUGCDependencyResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoveUGCDependencyResult_t : ICallbackData
{
	internal Result Result;

	internal PublishedFileId PublishedFileId;

	internal PublishedFileId ChildPublishedFileId;

	public static int _datasize = Marshal.SizeOf(typeof(RemoveUGCDependencyResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoveUGCDependencyResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct AddAppDependencyResult_t : ICallbackData
{
	internal Result Result;

	internal PublishedFileId PublishedFileId;

	internal AppId AppID;

	public static int _datasize = Marshal.SizeOf(typeof(AddAppDependencyResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.AddAppDependencyResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct RemoveAppDependencyResult_t : ICallbackData
{
	internal Result Result;

	internal PublishedFileId PublishedFileId;

	internal AppId AppID;

	public static int _datasize = Marshal.SizeOf(typeof(RemoveAppDependencyResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.RemoveAppDependencyResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GetAppDependenciesResult_t : ICallbackData
{
	internal Result Result;

	internal PublishedFileId PublishedFileId;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.U4)]
	internal AppId[] GAppIDs;

	internal uint NumAppDependencies;

	internal uint TotalNumAppDependencies;

	public static int _datasize = Marshal.SizeOf(typeof(GetAppDependenciesResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GetAppDependenciesResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct DeleteItemResult_t : ICallbackData
{
	internal Result Result;

	internal PublishedFileId PublishedFileId;

	public static int _datasize = Marshal.SizeOf(typeof(DeleteItemResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.DeleteItemResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct UserSubscribedItemsListChanged_t : ICallbackData
{
	internal AppId AppID;

	public static int _datasize = Marshal.SizeOf(typeof(UserSubscribedItemsListChanged_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.UserSubscribedItemsListChanged;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct WorkshopEULAStatus_t : ICallbackData
{
	internal Result Result;

	internal AppId AppID;

	internal uint Version;

	internal uint TAction;

	[MarshalAs(UnmanagedType.I1)]
	internal bool Accepted;

	[MarshalAs(UnmanagedType.I1)]
	internal bool NeedsAction;

	public static int _datasize = Marshal.SizeOf(typeof(WorkshopEULAStatus_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.WorkshopEULAStatus;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_BrowserReady_t : ICallbackData
{
	internal uint UnBrowserHandle;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_BrowserReady_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_BrowserReady;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_NeedsPaint_t : ICallbackData
{
	internal uint UnBrowserHandle;

	internal string PBGRA;

	internal uint UnWide;

	internal uint UnTall;

	internal uint UnUpdateX;

	internal uint UnUpdateY;

	internal uint UnUpdateWide;

	internal uint UnUpdateTall;

	internal uint UnScrollX;

	internal uint UnScrollY;

	internal float FlPageScale;

	internal uint UnPageSerial;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_NeedsPaint_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_NeedsPaint;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_StartRequest_t : ICallbackData
{
	internal uint UnBrowserHandle;

	internal string PchURL;

	internal string PchTarget;

	internal string PchPostData;

	[MarshalAs(UnmanagedType.I1)]
	internal bool BIsRedirect;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_StartRequest_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_StartRequest;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_CloseBrowser_t : ICallbackData
{
	internal uint UnBrowserHandle;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_CloseBrowser_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_CloseBrowser;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_URLChanged_t : ICallbackData
{
	internal uint UnBrowserHandle;

	internal string PchURL;

	internal string PchPostData;

	[MarshalAs(UnmanagedType.I1)]
	internal bool BIsRedirect;

	internal string PchPageTitle;

	[MarshalAs(UnmanagedType.I1)]
	internal bool BNewNavigation;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_URLChanged_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_URLChanged;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_FinishedRequest_t : ICallbackData
{
	internal uint UnBrowserHandle;

	internal string PchURL;

	internal string PchPageTitle;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_FinishedRequest_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_FinishedRequest;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_OpenLinkInNewTab_t : ICallbackData
{
	internal uint UnBrowserHandle;

	internal string PchURL;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_OpenLinkInNewTab_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_OpenLinkInNewTab;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_ChangedTitle_t : ICallbackData
{
	internal uint UnBrowserHandle;

	internal string PchTitle;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_ChangedTitle_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_ChangedTitle;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_SearchResults_t : ICallbackData
{
	internal uint UnBrowserHandle;

	internal uint UnResults;

	internal uint UnCurrentMatch;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_SearchResults_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_SearchResults;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_CanGoBackAndForward_t : ICallbackData
{
	internal uint UnBrowserHandle;

	[MarshalAs(UnmanagedType.I1)]
	internal bool BCanGoBack;

	[MarshalAs(UnmanagedType.I1)]
	internal bool BCanGoForward;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_CanGoBackAndForward_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_CanGoBackAndForward;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_HorizontalScroll_t : ICallbackData
{
	internal uint UnBrowserHandle;

	internal uint UnScrollMax;

	internal uint UnScrollCurrent;

	internal float FlPageScale;

	[MarshalAs(UnmanagedType.I1)]
	internal bool BVisible;

	internal uint UnPageSize;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_HorizontalScroll_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_HorizontalScroll;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_VerticalScroll_t : ICallbackData
{
	internal uint UnBrowserHandle;

	internal uint UnScrollMax;

	internal uint UnScrollCurrent;

	internal float FlPageScale;

	[MarshalAs(UnmanagedType.I1)]
	internal bool BVisible;

	internal uint UnPageSize;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_VerticalScroll_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_VerticalScroll;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_LinkAtPosition_t : ICallbackData
{
	internal uint UnBrowserHandle;

	internal uint X;

	internal uint Y;

	internal string PchURL;

	[MarshalAs(UnmanagedType.I1)]
	internal bool BInput;

	[MarshalAs(UnmanagedType.I1)]
	internal bool BLiveLink;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_LinkAtPosition_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_LinkAtPosition;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_JSAlert_t : ICallbackData
{
	internal uint UnBrowserHandle;

	internal string PchMessage;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_JSAlert_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_JSAlert;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_JSConfirm_t : ICallbackData
{
	internal uint UnBrowserHandle;

	internal string PchMessage;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_JSConfirm_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_JSConfirm;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_FileOpenDialog_t : ICallbackData
{
	internal uint UnBrowserHandle;

	internal string PchTitle;

	internal string PchInitialFile;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_FileOpenDialog_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_FileOpenDialog;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_NewWindow_t : ICallbackData
{
	internal uint UnBrowserHandle;

	internal string PchURL;

	internal uint UnX;

	internal uint UnY;

	internal uint UnWide;

	internal uint UnTall;

	internal uint UnNewWindow_BrowserHandle_IGNORE;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_NewWindow_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_NewWindow;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_SetCursor_t : ICallbackData
{
	internal uint UnBrowserHandle;

	internal uint EMouseCursor;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_SetCursor_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_SetCursor;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_StatusText_t : ICallbackData
{
	internal uint UnBrowserHandle;

	internal string PchMsg;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_StatusText_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_StatusText;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_ShowToolTip_t : ICallbackData
{
	internal uint UnBrowserHandle;

	internal string PchMsg;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_ShowToolTip_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_ShowToolTip;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_UpdateToolTip_t : ICallbackData
{
	internal uint UnBrowserHandle;

	internal string PchMsg;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_UpdateToolTip_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_UpdateToolTip;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_HideToolTip_t : ICallbackData
{
	internal uint UnBrowserHandle;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_HideToolTip_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_HideToolTip;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct HTML_BrowserRestarted_t : ICallbackData
{
	internal uint UnBrowserHandle;

	internal uint UnOldBrowserHandle;

	public static int _datasize = Marshal.SizeOf(typeof(HTML_BrowserRestarted_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.HTML_BrowserRestarted;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamInventoryResultReady_t : ICallbackData
{
	internal int Handle;

	internal Result Result;

	public static int _datasize = Marshal.SizeOf(typeof(SteamInventoryResultReady_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamInventoryResultReady;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamInventoryFullUpdate_t : ICallbackData
{
	internal int Handle;

	public static int _datasize = Marshal.SizeOf(typeof(SteamInventoryFullUpdate_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamInventoryFullUpdate;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamInventoryDefinitionUpdate_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(SteamInventoryDefinitionUpdate_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamInventoryDefinitionUpdate;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamInventoryEligiblePromoItemDefIDs_t : ICallbackData
{
	internal Result Result;

	internal ulong SteamID;

	internal int UmEligiblePromoItemDefs;

	[MarshalAs(UnmanagedType.I1)]
	internal bool CachedData;

	public static int _datasize = Marshal.SizeOf(typeof(SteamInventoryEligiblePromoItemDefIDs_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamInventoryEligiblePromoItemDefIDs;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamInventoryStartPurchaseResult_t : ICallbackData
{
	internal Result Result;

	internal ulong OrderID;

	internal ulong TransID;

	public static int _datasize = Marshal.SizeOf(typeof(SteamInventoryStartPurchaseResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamInventoryStartPurchaseResult;
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamInventoryRequestPricesResult_t : ICallbackData
{
	internal Result Result;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	internal byte[] Currency;

	public static int _datasize = Marshal.SizeOf(typeof(SteamInventoryRequestPricesResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamInventoryRequestPricesResult;

	internal string CurrencyUTF8()
	{
		return Utility.Utf8NoBom.GetString(Currency, 0, Array.IndexOf(Currency, (byte)0));
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamTimelineGamePhaseRecordingExists_t : ICallbackData
{
	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	internal byte[] PhaseID;

	internal ulong RecordingMS;

	internal ulong LongestClipMS;

	internal uint ClipCount;

	internal uint ScreenshotCount;

	public static int _datasize = Marshal.SizeOf(typeof(SteamTimelineGamePhaseRecordingExists_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamTimelineGamePhaseRecordingExists;

	internal string PhaseIDUTF8()
	{
		return Utility.Utf8NoBom.GetString(PhaseID, 0, Array.IndexOf(PhaseID, (byte)0));
	}
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamTimelineEventRecordingExists_t : ICallbackData
{
	internal ulong EventID;

	[MarshalAs(UnmanagedType.I1)]
	internal bool RecordingExists;

	public static int _datasize = Marshal.SizeOf(typeof(SteamTimelineEventRecordingExists_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamTimelineEventRecordingExists;
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GetVideoURLResult_t : ICallbackData
{
	internal Result Result;

	internal AppId VideoAppID;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
	internal byte[] URL;

	public static int _datasize = Marshal.SizeOf(typeof(GetVideoURLResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GetVideoURLResult;

	internal string URLUTF8()
	{
		return Utility.Utf8NoBom.GetString(URL, 0, Array.IndexOf(URL, (byte)0));
	}
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GetOPFSettingsResult_t : ICallbackData
{
	internal Result Result;

	internal AppId VideoAppID;

	public static int _datasize = Marshal.SizeOf(typeof(GetOPFSettingsResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GetOPFSettingsResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct BroadcastUploadStart_t : ICallbackData
{
	[MarshalAs(UnmanagedType.I1)]
	internal bool IsRTMP;

	public static int _datasize = Marshal.SizeOf(typeof(BroadcastUploadStart_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.BroadcastUploadStart;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct BroadcastUploadStop_t : ICallbackData
{
	internal BroadcastUploadResult Result;

	public static int _datasize = Marshal.SizeOf(typeof(BroadcastUploadStop_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.BroadcastUploadStop;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamParentalSettingsChanged_t : ICallbackData
{
	public static int _datasize = Marshal.SizeOf(typeof(SteamParentalSettingsChanged_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamParentalSettingsChanged;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamRemotePlaySessionConnected_t : ICallbackData
{
	internal uint SessionID;

	public static int _datasize = Marshal.SizeOf(typeof(SteamRemotePlaySessionConnected_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamRemotePlaySessionConnected;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamRemotePlaySessionDisconnected_t : ICallbackData
{
	internal uint SessionID;

	public static int _datasize = Marshal.SizeOf(typeof(SteamRemotePlaySessionDisconnected_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamRemotePlaySessionDisconnected;
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamRemotePlayTogetherGuestInvite_t : ICallbackData
{
	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 1024)]
	internal byte[] ConnectURL;

	public static int _datasize = Marshal.SizeOf(typeof(SteamRemotePlayTogetherGuestInvite_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamRemotePlayTogetherGuestInvite;

	internal string ConnectURLUTF8()
	{
		return Utility.Utf8NoBom.GetString(ConnectURL, 0, Array.IndexOf(ConnectURL, (byte)0));
	}
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamNetworkingMessagesSessionRequest_t : ICallbackData
{
	internal NetIdentity DentityRemote;

	public static int _datasize = Marshal.SizeOf(typeof(SteamNetworkingMessagesSessionRequest_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamNetworkingMessagesSessionRequest;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamNetworkingMessagesSessionFailed_t : ICallbackData
{
	internal ConnectionInfo Nfo;

	public static int _datasize = Marshal.SizeOf(typeof(SteamNetworkingMessagesSessionFailed_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamNetworkingMessagesSessionFailed;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamNetConnectionStatusChangedCallback_t : ICallbackData
{
	internal Connection Conn;

	internal ConnectionInfo Nfo;

	internal ConnectionState OldState;

	public static int _datasize = Marshal.SizeOf(typeof(SteamNetConnectionStatusChangedCallback_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamNetConnectionStatusChangedCallback;
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamNetAuthenticationStatus_t : ICallbackData
{
	internal SteamNetworkingAvailability Avail;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
	internal byte[] DebugMsg;

	public static int _datasize = Marshal.SizeOf(typeof(SteamNetAuthenticationStatus_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamNetAuthenticationStatus;

	internal string DebugMsgUTF8()
	{
		return Utility.Utf8NoBom.GetString(DebugMsg, 0, Array.IndexOf(DebugMsg, (byte)0));
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamRelayNetworkStatus_t : ICallbackData
{
	internal SteamNetworkingAvailability Avail;

	internal int PingMeasurementInProgress;

	internal SteamNetworkingAvailability AvailNetworkConfig;

	internal SteamNetworkingAvailability AvailAnyRelay;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
	internal byte[] DebugMsg;

	public static int _datasize = Marshal.SizeOf(typeof(SteamRelayNetworkStatus_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamRelayNetworkStatus;

	internal string DebugMsgUTF8()
	{
		return Utility.Utf8NoBom.GetString(DebugMsg, 0, Array.IndexOf(DebugMsg, (byte)0));
	}
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GSClientApprove_t : ICallbackData
{
	internal ulong SteamID;

	internal ulong OwnerSteamID;

	public static int _datasize = Marshal.SizeOf(typeof(GSClientApprove_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GSClientApprove;
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GSClientDeny_t : ICallbackData
{
	internal ulong SteamID;

	internal DenyReason DenyReason;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]
	internal byte[] OptionalText;

	public static int _datasize = Marshal.SizeOf(typeof(GSClientDeny_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GSClientDeny;

	internal string OptionalTextUTF8()
	{
		return Utility.Utf8NoBom.GetString(OptionalText, 0, Array.IndexOf(OptionalText, (byte)0));
	}
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GSClientKick_t : ICallbackData
{
	internal ulong SteamID;

	internal DenyReason DenyReason;

	public static int _datasize = Marshal.SizeOf(typeof(GSClientKick_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GSClientKick;
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GSClientAchievementStatus_t : ICallbackData
{
	internal ulong SteamID;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]
	internal byte[] PchAchievement;

	[MarshalAs(UnmanagedType.I1)]
	internal bool Unlocked;

	public static int _datasize = Marshal.SizeOf(typeof(GSClientAchievementStatus_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GSClientAchievementStatus;

	internal string PchAchievementUTF8()
	{
		return Utility.Utf8NoBom.GetString(PchAchievement, 0, Array.IndexOf(PchAchievement, (byte)0));
	}
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GSPolicyResponse_t : ICallbackData
{
	internal byte Secure;

	public static int _datasize = Marshal.SizeOf(typeof(GSPolicyResponse_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GSPolicyResponse;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GSGameplayStats_t : ICallbackData
{
	internal Result Result;

	internal int Rank;

	internal uint TotalConnects;

	internal uint TotalMinutesPlayed;

	public static int _datasize = Marshal.SizeOf(typeof(GSGameplayStats_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GSGameplayStats;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GSClientGroupStatus_t : ICallbackData
{
	internal ulong SteamIDUser;

	internal ulong SteamIDGroup;

	[MarshalAs(UnmanagedType.I1)]
	internal bool Member;

	[MarshalAs(UnmanagedType.I1)]
	internal bool Officer;

	public static int _datasize = Marshal.SizeOf(typeof(GSClientGroupStatus_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GSClientGroupStatus;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GSReputation_t : ICallbackData
{
	internal Result Result;

	internal uint ReputationScore;

	[MarshalAs(UnmanagedType.I1)]
	internal bool Banned;

	internal uint BannedIP;

	internal ushort BannedPort;

	internal ulong BannedGameID;

	internal uint BanExpires;

	public static int _datasize = Marshal.SizeOf(typeof(GSReputation_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GSReputation;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct AssociateWithClanResult_t : ICallbackData
{
	internal Result Result;

	public static int _datasize = Marshal.SizeOf(typeof(AssociateWithClanResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.AssociateWithClanResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct ComputeNewPlayerCompatibilityResult_t : ICallbackData
{
	internal Result Result;

	internal int CPlayersThatDontLikeCandidate;

	internal int CPlayersThatCandidateDoesntLike;

	internal int CClanPlayersThatDontLikeCandidate;

	internal ulong SteamIDCandidate;

	public static int _datasize = Marshal.SizeOf(typeof(ComputeNewPlayerCompatibilityResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.ComputeNewPlayerCompatibilityResult;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GSStatsReceived_t : ICallbackData
{
	internal Result Result;

	internal ulong SteamIDUser;

	public static int _datasize = Marshal.SizeOf(typeof(GSStatsReceived_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GSStatsReceived;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GSStatsStored_t : ICallbackData
{
	internal Result Result;

	internal ulong SteamIDUser;

	public static int _datasize = Marshal.SizeOf(typeof(GSStatsStored_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.GSStatsStored;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct GSStatsUnloaded_t : ICallbackData
{
	internal ulong SteamIDUser;

	public static int _datasize = Marshal.SizeOf(typeof(GSStatsUnloaded_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.UserStatsUnloaded;
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamNetworkingFakeIPResult_t : ICallbackData
{
	internal Result Result;

	internal NetIdentity Dentity;

	internal uint IP;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.U2)]
	internal ushort[] Ports;

	public static int _datasize = Marshal.SizeOf(typeof(SteamNetworkingFakeIPResult_t));

	public int DataSize => _datasize;

	public CallbackType CallbackType => CallbackType.SteamNetworkingFakeIPResult;
}


using Steamworks;
using Steamworks.Data;

internal static class Defines
{
	internal static readonly AppId k_uAppIdInvalid = 0;

	internal static readonly DepotId_t k_uDepotIdInvalid = 0u;

	internal static readonly SteamAPICall_t k_uAPICallInvalid = 0uL;

	internal static readonly AccountID_t k_uAccountIdInvalid = 0u;

	internal static readonly PartyBeaconID_t k_ulPartyBeaconIdInvalid = 0uL;

	internal static readonly HAuthTicket k_HAuthTicketInvalid = 0u;

	internal static readonly uint k_unSteamAccountIDMask = uint.MaxValue;

	internal static readonly uint k_unSteamAccountInstanceMask = 1048575u;

	internal static readonly uint k_unSteamUserDefaultInstance = 1u;

	internal static readonly int k_cchGameExtraInfoMax = 64;

	internal static readonly int k_cchMaxSteamErrMsg = 1024;

	internal static readonly int k_cchMaxFriendsGroupName = 64;

	internal static readonly int k_cFriendsGroupLimit = 100;

	internal static readonly FriendsGroupID_t k_FriendsGroupID_Invalid = (short)(-1);

	internal static readonly int k_cEnumerateFollowersMax = 50;

	internal static readonly ushort k_usFriendGameInfoQueryPort_NotInitialized = ushort.MaxValue;

	internal static readonly ushort k_usFriendGameInfoQueryPort_Error = 65534;

	internal static readonly uint k_cubChatMetadataMax = 8192u;

	internal static readonly int k_cbMaxGameServerGameDir = 32;

	internal static readonly int k_cbMaxGameServerMapName = 32;

	internal static readonly int k_cbMaxGameServerGameDescription = 64;

	internal static readonly int k_cbMaxGameServerName = 64;

	internal static readonly int k_cbMaxGameServerTags = 128;

	internal static readonly int k_cbMaxGameServerGameData = 2048;

	internal static readonly int HSERVERQUERY_INVALID = -1;

	internal static readonly uint k_unFavoriteFlagNone = 0u;

	internal static readonly uint k_unFavoriteFlagFavorite = 1u;

	internal static readonly uint k_unFavoriteFlagHistory = 2u;

	internal static readonly uint k_unMaxCloudFileChunkSize = 104857600u;

	internal static readonly PublishedFileId k_PublishedFileIdInvalid = 0uL;

	internal static readonly UGCHandle_t k_UGCHandleInvalid = ulong.MaxValue;

	internal static readonly PublishedFileUpdateHandle_t k_PublishedFileUpdateHandleInvalid = ulong.MaxValue;

	internal static readonly UGCFileWriteStreamHandle_t k_UGCFileStreamHandleInvalid = ulong.MaxValue;

	internal static readonly uint k_cchPublishedDocumentTitleMax = 129u;

	internal static readonly uint k_cchPublishedDocumentDescriptionMax = 8000u;

	internal static readonly uint k_cchPublishedDocumentChangeDescriptionMax = 8000u;

	internal static readonly uint k_unEnumeratePublishedFilesMaxResults = 50u;

	internal static readonly uint k_cchTagListMax = 1025u;

	internal static readonly uint k_cchFilenameMax = 260u;

	internal static readonly uint k_cchPublishedFileURLMax = 256u;

	internal static readonly int k_cubAppProofOfPurchaseKeyMax = 240;

	internal static readonly uint k_nScreenshotMaxTaggedUsers = 32u;

	internal static readonly uint k_nScreenshotMaxTaggedPublishedFiles = 32u;

	internal static readonly int k_cubUFSTagTypeMax = 255;

	internal static readonly int k_cubUFSTagValueMax = 255;

	internal static readonly int k_ScreenshotThumbWidth = 200;

	internal static readonly UGCQueryHandle_t k_UGCQueryHandleInvalid = ulong.MaxValue;

	internal static readonly UGCUpdateHandle_t k_UGCUpdateHandleInvalid = ulong.MaxValue;

	internal static readonly uint kNumUGCResultsPerPage = 50u;

	internal static readonly uint k_cchDeveloperMetadataMax = 5000u;

	internal static readonly uint INVALID_HTMLBROWSER = 0u;

	internal static readonly InventoryItemId k_SteamItemInstanceIDInvalid = ulong.MaxValue;

	internal static readonly SteamInventoryResult_t k_SteamInventoryResultInvalid = -1;

	internal static readonly SteamInventoryUpdateHandle_t k_SteamInventoryUpdateHandleInvalid = ulong.MaxValue;

	internal static readonly uint k_unMaxTimelinePriority = 1000u;

	internal static readonly uint k_unTimelinePriority_KeepCurrentValue = 1000000u;

	internal static readonly float k_flMaxTimelineEventDuration = 600f;

	internal static readonly uint k_cchMaxPhaseIDLength = 64u;

	internal static readonly Connection k_HSteamNetConnection_Invalid = 0u;

	internal static readonly Socket k_HSteamListenSocket_Invalid = 0u;

	internal static readonly HSteamNetPollGroup k_HSteamNetPollGroup_Invalid = 0u;

	internal static readonly int k_cchMaxSteamNetworkingErrMsg = 1024;

	internal static readonly int k_cchSteamNetworkingMaxConnectionCloseReason = 128;

	internal static readonly int k_cchSteamNetworkingMaxConnectionDescription = 128;

	internal static readonly int k_cchSteamNetworkingMaxConnectionAppName = 32;

	internal static readonly int k_nSteamNetworkConnectionInfoFlags_Unauthenticated = 1;

	internal static readonly int k_nSteamNetworkConnectionInfoFlags_Unencrypted = 2;

	internal static readonly int k_nSteamNetworkConnectionInfoFlags_LoopbackBuffers = 4;

	internal static readonly int k_nSteamNetworkConnectionInfoFlags_Fast = 8;

	internal static readonly int k_nSteamNetworkConnectionInfoFlags_Relayed = 16;

	internal static readonly int k_nSteamNetworkConnectionInfoFlags_DualWifi = 32;

	internal static readonly int k_cbMaxSteamNetworkingSocketsMessageSizeSend = 524288;

	internal static readonly int k_nSteamNetworkingSend_Unreliable = 0;

	internal static readonly int k_nSteamNetworkingSend_NoNagle = 1;

	internal static readonly int k_nSteamNetworkingSend_UnreliableNoNagle = k_nSteamNetworkingSend_Unreliable | k_nSteamNetworkingSend_NoNagle;

	internal static readonly int k_nSteamNetworkingSend_NoDelay = 4;

	internal static readonly int k_nSteamNetworkingSend_UnreliableNoDelay = k_nSteamNetworkingSend_Unreliable | k_nSteamNetworkingSend_NoDelay | k_nSteamNetworkingSend_NoNagle;

	internal static readonly int k_nSteamNetworkingSend_Reliable = 8;

	internal static readonly int k_nSteamNetworkingSend_ReliableNoNagle = k_nSteamNetworkingSend_Reliable | k_nSteamNetworkingSend_NoNagle;

	internal static readonly int k_nSteamNetworkingSend_UseCurrentThread = 16;

	internal static readonly int k_nSteamNetworkingSend_AutoRestartBrokenSession = 32;

	internal static readonly int k_cchMaxSteamNetworkingPingLocationString = 1024;

	internal static readonly int k_nSteamNetworkingPing_Failed = -1;

	internal static readonly int k_nSteamNetworkingPing_Unknown = -2;

	internal static readonly int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Default = -1;

	internal static readonly int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Disable = 0;

	internal static readonly int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Relay = 1;

	internal static readonly int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Private = 2;

	internal static readonly int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Public = 4;

	internal static readonly int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_All = int.MaxValue;

	internal static readonly SteamNetworkingPOPID k_SteamDatagramPOPID_dev = 6579574u;

	internal static readonly ushort STEAMGAMESERVER_QUERY_PORT_SHARED = ushort.MaxValue;

	internal static readonly ushort MASTERSERVERUPDATERPORT_USEGAMESOCKETSHARE = STEAMGAMESERVER_QUERY_PORT_SHARED;

	internal static readonly uint k_cbSteamDatagramMaxSerializedTicket = 512u;

	internal static readonly uint k_cbMaxSteamDatagramGameCoordinatorServerLoginAppData = 2048u;

	internal static readonly uint k_cbMaxSteamDatagramGameCoordinatorServerLoginSerialized = 4096u;

	internal static readonly int k_cbSteamNetworkingSocketsFakeUDPPortRecommendedMTU = 1200;

	internal static readonly int k_cbSteamNetworkingSocketsFakeUDPPortMaxMessageSize = 4096;
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct gameserveritem_t
{
	internal servernetadr_t NetAdr;

	internal int Ping;

	[MarshalAs(UnmanagedType.I1)]
	internal bool HadSuccessfulResponse;

	[MarshalAs(UnmanagedType.I1)]
	internal bool DoNotRefresh;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
	internal byte[] GameDir;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
	internal byte[] Map;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	internal byte[] GameDescription;

	internal uint AppID;

	internal int Players;

	internal int MaxPlayers;

	internal int BotPlayers;

	[MarshalAs(UnmanagedType.I1)]
	internal bool Password;

	[MarshalAs(UnmanagedType.I1)]
	internal bool Secure;

	internal uint TimeLastPlayed;

	internal int ServerVersion;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	internal byte[] ServerName;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]
	internal byte[] GameTags;

	internal ulong SteamID;

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_gameserveritem_t_Construct")]
	internal static extern void InternalConstruct(ref gameserveritem_t self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_gameserveritem_t_GetName")]
	internal static extern Utf8StringPointer InternalGetName(ref gameserveritem_t self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_gameserveritem_t_SetName")]
	internal static extern void InternalSetName(ref gameserveritem_t self, IntPtr pName);

	internal string GameDirUTF8()
	{
		return Utility.Utf8NoBom.GetString(GameDir, 0, Array.IndexOf(GameDir, (byte)0));
	}

	internal string MapUTF8()
	{
		return Utility.Utf8NoBom.GetString(Map, 0, Array.IndexOf(Map, (byte)0));
	}

	internal string GameDescriptionUTF8()
	{
		return Utility.Utf8NoBom.GetString(GameDescription, 0, Array.IndexOf(GameDescription, (byte)0));
	}

	internal string ServerNameUTF8()
	{
		return Utility.Utf8NoBom.GetString(ServerName, 0, Array.IndexOf(ServerName, (byte)0));
	}

	internal string GameTagsUTF8()
	{
		return Utility.Utf8NoBom.GetString(GameTags, 0, Array.IndexOf(GameTags, (byte)0));
	}
}


using System.Runtime.InteropServices;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct MatchMakingKeyValuePair
{
	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
	internal string Key;

	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
	internal string Value;

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_MatchMakingKeyValuePair_t_Construct")]
	internal static extern void InternalConstruct(ref MatchMakingKeyValuePair self);
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct servernetadr_t
{
	internal ushort ConnectionPort;

	internal ushort QueryPort;

	internal uint IP;

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_servernetadr_t_Construct")]
	internal static extern void InternalConstruct(ref servernetadr_t self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_servernetadr_t_Init")]
	internal static extern void InternalInit(ref servernetadr_t self, uint ip, ushort usQueryPort, ushort usConnectionPort);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_servernetadr_t_GetQueryPort")]
	internal static extern ushort InternalGetQueryPort(ref servernetadr_t self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_servernetadr_t_SetQueryPort")]
	internal static extern void InternalSetQueryPort(ref servernetadr_t self, ushort usPort);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_servernetadr_t_GetConnectionPort")]
	internal static extern ushort InternalGetConnectionPort(ref servernetadr_t self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_servernetadr_t_SetConnectionPort")]
	internal static extern void InternalSetConnectionPort(ref servernetadr_t self, ushort usPort);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_servernetadr_t_GetIP")]
	internal static extern uint InternalGetIP(ref servernetadr_t self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_servernetadr_t_SetIP")]
	internal static extern void InternalSetIP(ref servernetadr_t self, uint unIP);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_servernetadr_t_GetConnectionAddressString")]
	internal static extern Utf8StringPointer InternalGetConnectionAddressString(ref servernetadr_t self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_servernetadr_t_GetQueryAddressString")]
	internal static extern Utf8StringPointer InternalGetQueryAddressString(ref servernetadr_t self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_servernetadr_t_IsLessThan")]
	[return: MarshalAs(UnmanagedType.I1)]
	internal static extern bool InternalIsLessThan(ref servernetadr_t self, ref servernetadr_t netadr);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_servernetadr_t_Assign")]
	internal static extern void InternalAssign(ref servernetadr_t self, ref servernetadr_t that);
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamDatagramHostedAddress
{
	internal int CbSize;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]
	internal byte[] Data;

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamDatagramHostedAddress_Clear")]
	internal static extern void InternalClear(ref SteamDatagramHostedAddress self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamDatagramHostedAddress_GetPopID")]
	internal static extern SteamNetworkingPOPID InternalGetPopID(ref SteamDatagramHostedAddress self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamDatagramHostedAddress_SetDevAddress")]
	internal static extern void InternalSetDevAddress(ref SteamDatagramHostedAddress self, uint nIP, ushort nPort, SteamNetworkingPOPID popid);

	internal string DataUTF8()
	{
		return Utility.Utf8NoBom.GetString(Data, 0, Array.IndexOf(Data, (byte)0));
	}
}


using System;
using System.Net;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Explicit, Pack = 4)]
internal struct SteamIPAddress
{
	[FieldOffset(0)]
	public uint Ip4Address;

	[FieldOffset(16)]
	internal SteamIPType Type;

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamIPAddress_t_IsSet")]
	[return: MarshalAs(UnmanagedType.I1)]
	internal static extern bool InternalIsSet(ref SteamIPAddress self);

	public static implicit operator IPAddress(SteamIPAddress value)
	{
		if (value.Type == SteamIPType.Type4)
		{
			return Utility.Int32ToIp(value.Ip4Address);
		}
		throw new Exception($"Oops - can't convert SteamIPAddress to System.Net.IPAddress because no-one coded support for {value.Type} yet");
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Explicit, Pack = 4)]
internal struct NetKeyValue
{
	[FieldOffset(0)]
	internal NetConfig Value;

	[FieldOffset(4)]
	internal NetConfigType DataType;

	[FieldOffset(8)]
	internal long Int64Value;

	[FieldOffset(8)]
	internal int Int32Value;

	[FieldOffset(8)]
	internal float FloatValue;

	[FieldOffset(8)]
	internal IntPtr PointerValue;

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingConfigValue_t_SetInt32")]
	internal static extern void InternalSetInt32(ref NetKeyValue self, NetConfig eVal, int data);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingConfigValue_t_SetInt64")]
	internal static extern void InternalSetInt64(ref NetKeyValue self, NetConfig eVal, long data);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingConfigValue_t_SetFloat")]
	internal static extern void InternalSetFloat(ref NetKeyValue self, NetConfig eVal, float data);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingConfigValue_t_SetPtr")]
	internal static extern void InternalSetPtr(ref NetKeyValue self, NetConfig eVal, IntPtr data);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingConfigValue_t_SetString")]
	internal static extern void InternalSetString(ref NetKeyValue self, NetConfig eVal, IntPtr data);
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Explicit, Pack = 1, Size = 136)]
public struct NetIdentity
{
	internal enum IdentityType
	{
		Invalid = 0,
		IPAddress = 1,
		GenericString = 2,
		GenericBytes = 3,
		SteamID = 16
	}

	[FieldOffset(0)]
	internal IdentityType type;

	[FieldOffset(4)]
	internal int size;

	[FieldOffset(8)]
	internal ulong steamid;

	[FieldOffset(8)]
	internal NetAddress netaddress;

	public static NetIdentity LocalHost
	{
		get
		{
			NetIdentity self = default(NetIdentity);
			InternalSetLocalHost(ref self);
			return self;
		}
	}

	public bool IsSteamId => type == IdentityType.SteamID;

	public bool IsIpAddress => type == IdentityType.IPAddress;

	public bool IsLocalHost
	{
		get
		{
			NetIdentity self = default(NetIdentity);
			return InternalIsLocalHost(ref self);
		}
	}

	public SteamId SteamId
	{
		get
		{
			if (type != IdentityType.SteamID)
			{
				return default(SteamId);
			}
			NetIdentity self = this;
			return InternalGetSteamID(ref self);
		}
	}

	public NetAddress Address
	{
		get
		{
			if (type != IdentityType.IPAddress)
			{
				return default(NetAddress);
			}
			NetIdentity self = this;
			return InternalGetIPAddr(ref self).ToType<NetAddress>();
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_Clear")]
	internal static extern void InternalClear(ref NetIdentity self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_IsInvalid")]
	[return: MarshalAs(UnmanagedType.I1)]
	internal static extern bool InternalIsInvalid(ref NetIdentity self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_SetSteamID")]
	internal static extern void InternalSetSteamID(ref NetIdentity self, SteamId steamID);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_GetSteamID")]
	internal static extern SteamId InternalGetSteamID(ref NetIdentity self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_SetSteamID64")]
	internal static extern void InternalSetSteamID64(ref NetIdentity self, ulong steamID);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_GetSteamID64")]
	internal static extern ulong InternalGetSteamID64(ref NetIdentity self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_SetXboxPairwiseID")]
	[return: MarshalAs(UnmanagedType.I1)]
	internal static extern bool InternalSetXboxPairwiseID(ref NetIdentity self, IntPtr pszString);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_GetXboxPairwiseID")]
	internal static extern Utf8StringPointer InternalGetXboxPairwiseID(ref NetIdentity self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_SetPSNID")]
	internal static extern void InternalSetPSNID(ref NetIdentity self, ulong id);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_GetPSNID")]
	internal static extern ulong InternalGetPSNID(ref NetIdentity self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_SetIPAddr")]
	internal static extern void InternalSetIPAddr(ref NetIdentity self, ref NetAddress addr);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_GetIPAddr")]
	internal static extern IntPtr InternalGetIPAddr(ref NetIdentity self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_SetIPv4Addr")]
	internal static extern void InternalSetIPv4Addr(ref NetIdentity self, uint nIPv4, ushort nPort);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_GetIPv4")]
	internal static extern uint InternalGetIPv4(ref NetIdentity self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_GetFakeIPType")]
	internal static extern SteamNetworkingFakeIPType InternalGetFakeIPType(ref NetIdentity self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_IsFakeIP")]
	[return: MarshalAs(UnmanagedType.I1)]
	internal static extern bool InternalIsFakeIP(ref NetIdentity self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_SetLocalHost")]
	internal static extern void InternalSetLocalHost(ref NetIdentity self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_IsLocalHost")]
	[return: MarshalAs(UnmanagedType.I1)]
	internal static extern bool InternalIsLocalHost(ref NetIdentity self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_SetGenericString")]
	[return: MarshalAs(UnmanagedType.I1)]
	internal static extern bool InternalSetGenericString(ref NetIdentity self, IntPtr pszString);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_GetGenericString")]
	internal static extern Utf8StringPointer InternalGetGenericString(ref NetIdentity self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_SetGenericBytes")]
	[return: MarshalAs(UnmanagedType.I1)]
	internal static extern bool InternalSetGenericBytes(ref NetIdentity self, IntPtr data, uint cbLen);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_GetGenericBytes")]
	internal static extern byte InternalGetGenericBytes(ref NetIdentity self, ref int cbLen);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_IsEqualTo")]
	[return: MarshalAs(UnmanagedType.I1)]
	internal static extern bool InternalIsEqualTo(ref NetIdentity self, ref NetIdentity x);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_ToString")]
	internal static extern void InternalToString(ref NetIdentity self, IntPtr buf, uint cbBuf);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIdentity_ParseString")]
	[return: MarshalAs(UnmanagedType.I1)]
	internal static extern bool InternalParseString(ref NetIdentity self, IntPtr pszStr);

	public static implicit operator NetIdentity(SteamId value)
	{
		NetIdentity self = default(NetIdentity);
		InternalSetSteamID(ref self, value);
		return self;
	}

	public static implicit operator NetIdentity(NetAddress address)
	{
		NetIdentity self = default(NetIdentity);
		InternalSetIPAddr(ref self, ref address);
		return self;
	}

	public static implicit operator SteamId(NetIdentity value)
	{
		return value.SteamId;
	}

	public override string ToString()
	{
		NetIdentity identity = this;
		SteamNetworkingUtils.Internal.SteamNetworkingIdentity_ToString(ref identity, out var buf);
		return buf;
	}
}


using System;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Explicit, Pack = 1, Size = 18)]
public struct NetAddress
{
	internal struct IPV4
	{
		internal ulong m_8zeros;

		internal ushort m_0000;

		internal ushort m_ffff;

		internal byte ip0;

		internal byte ip1;

		internal byte ip2;

		internal byte ip3;
	}

	[FieldOffset(0)]
	internal IPV4 ip;

	[FieldOffset(16)]
	internal ushort port;

	public ushort Port => port;

	public static NetAddress Cleared
	{
		get
		{
			NetAddress self = default(NetAddress);
			InternalClear(ref self);
			return self;
		}
	}

	public bool IsIPv6AllZeros
	{
		get
		{
			NetAddress self = this;
			return InternalIsIPv6AllZeros(ref self);
		}
	}

	public bool IsIPv4
	{
		get
		{
			NetAddress self = this;
			return InternalIsIPv4(ref self);
		}
	}

	public bool IsFakeIPv4
	{
		get
		{
			NetAddress self = this;
			return SteamNetworkingUtils.Internal.IsFakeIPv4(InternalGetIPv4(ref self));
		}
	}

	public bool IsLocalHost
	{
		get
		{
			NetAddress self = this;
			return InternalIsLocalHost(ref self);
		}
	}

	public IPAddress Address
	{
		get
		{
			if (IsIPv4)
			{
				NetAddress self = this;
				return Utility.Int32ToIp(InternalGetIPv4(ref self));
			}
			if (IsIPv6AllZeros)
			{
				return IPAddress.IPv6Loopback;
			}
			throw new NotImplementedException("Oops - no IPV6 support yet?");
		}
	}

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIPAddr_Clear")]
	internal static extern void InternalClear(ref NetAddress self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIPAddr_IsIPv6AllZeros")]
	[return: MarshalAs(UnmanagedType.I1)]
	internal static extern bool InternalIsIPv6AllZeros(ref NetAddress self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIPAddr_SetIPv6")]
	internal static extern void InternalSetIPv6(ref NetAddress self, ref byte ipv6, ushort nPort);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIPAddr_SetIPv4")]
	internal static extern void InternalSetIPv4(ref NetAddress self, uint nIP, ushort nPort);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIPAddr_IsIPv4")]
	[return: MarshalAs(UnmanagedType.I1)]
	internal static extern bool InternalIsIPv4(ref NetAddress self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIPAddr_GetIPv4")]
	internal static extern uint InternalGetIPv4(ref NetAddress self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIPAddr_SetIPv6LocalHost")]
	internal static extern void InternalSetIPv6LocalHost(ref NetAddress self, ushort nPort);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIPAddr_IsLocalHost")]
	[return: MarshalAs(UnmanagedType.I1)]
	internal static extern bool InternalIsLocalHost(ref NetAddress self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIPAddr_ToString")]
	internal static extern void InternalToString(ref NetAddress self, IntPtr buf, uint cbBuf, [MarshalAs(UnmanagedType.U1)] bool bWithPort);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIPAddr_ParseString")]
	[return: MarshalAs(UnmanagedType.I1)]
	internal static extern bool InternalParseString(ref NetAddress self, IntPtr pszStr);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIPAddr_IsEqualTo")]
	[return: MarshalAs(UnmanagedType.I1)]
	internal static extern bool InternalIsEqualTo(ref NetAddress self, ref NetAddress x);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIPAddr_GetFakeIPType")]
	internal static extern SteamNetworkingFakeIPType InternalGetFakeIPType(ref NetAddress self);

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingIPAddr_IsFakeIP")]
	[return: MarshalAs(UnmanagedType.I1)]
	internal static extern bool InternalIsFakeIP(ref NetAddress self);

	public static NetAddress AnyIp(ushort port)
	{
		NetAddress cleared = Cleared;
		cleared.port = port;
		return cleared;
	}

	public static NetAddress LocalHost(ushort port)
	{
		NetAddress self = Cleared;
		InternalSetIPv6LocalHost(ref self, port);
		return self;
	}

	public static NetAddress From(string addrStr, ushort port)
	{
		return From(IPAddress.Parse(addrStr), port);
	}

	public static NetAddress From(IPAddress address, ushort port)
	{
		address.GetAddressBytes();
		if (address.AddressFamily == AddressFamily.InterNetwork)
		{
			NetAddress self = Cleared;
			InternalSetIPv4(ref self, address.IpToInt32(), port);
			return self;
		}
		throw new NotImplementedException("Oops - no IPV6 support yet?");
	}

	public override string ToString()
	{
		Helpers.Memory m = Helpers.TakeMemory();
		try
		{
			NetAddress self = this;
			InternalToString(ref self, m, 32768u, bWithPort: true);
			return Helpers.MemoryToString(m);
		}
		finally
		{
			((IDisposable)m/*cast due to .constrained prefix*/).Dispose();
		}
	}
}


using System;
using System.Runtime.InteropServices;
using Steamworks.Data;

internal struct NetMsg
{
	internal IntPtr DataPtr;

	internal int DataSize;

	internal Connection Connection;

	internal NetIdentity Identity;

	internal long ConnectionUserData;

	internal long RecvTime;

	internal long MessageNumber;

	internal IntPtr FreeDataPtr;

	internal IntPtr ReleasePtr;

	internal int Channel;

	internal SendType Flags;

	internal long UserData;

	internal ushort IdxLane;

	internal ushort _pad1__;

	[DllImport("libsteam_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "SteamAPI_SteamNetworkingMessage_t_Release")]
	internal unsafe static extern void InternalRelease(NetMsg* self);
}


using System.Runtime.InteropServices;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct FriendGameInfo_t
{
	internal GameId GameID;

	internal uint GameIP;

	internal ushort GamePort;

	internal ushort QueryPort;

	internal ulong SteamIDLobby;
}


using System.Runtime.InteropServices;
using Steamworks;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamPartyBeaconLocation_t
{
	internal SteamPartyBeaconLocationType Type;

	internal ulong LocationID;
}


using System;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamParamStringArray_t
{
	internal IntPtr Strings;

	internal int NumStrings;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct LeaderboardEntry_t
{
	internal ulong SteamIDUser;

	internal int GlobalRank;

	internal int Score;

	internal int CDetails;

	internal ulong UGC;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct P2PSessionState_t
{
	internal byte ConnectionActive;

	internal byte Connecting;

	internal byte P2PSessionError;

	internal byte UsingRelay;

	internal int BytesQueuedForSend;

	internal int PacketsQueuedForSend;

	internal uint RemoteIP;

	internal ushort RemotePort;
}


using System.Runtime.InteropServices;
using Steamworks;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamInputActionEvent_t
{
	internal ulong ControllerHandle;

	internal SteamInputActionEventType EEventType;
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamUGCDetails_t
{
	internal PublishedFileId PublishedFileId;

	internal Result Result;

	internal WorkshopFileType FileType;

	internal AppId CreatorAppID;

	internal AppId ConsumerAppID;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 129)]
	internal byte[] Title;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8000)]
	internal byte[] Description;

	internal ulong SteamIDOwner;

	internal uint TimeCreated;

	internal uint TimeUpdated;

	internal uint TimeAddedToUserList;

	internal RemoteStoragePublishedFileVisibility Visibility;

	[MarshalAs(UnmanagedType.I1)]
	internal bool Banned;

	[MarshalAs(UnmanagedType.I1)]
	internal bool AcceptedForUse;

	[MarshalAs(UnmanagedType.I1)]
	internal bool TagsTruncated;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 1025)]
	internal byte[] Tags;

	internal ulong File;

	internal ulong PreviewFile;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 260)]
	internal byte[] PchFileName;

	internal int FileSize;

	internal int PreviewFileSize;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
	internal byte[] URL;

	internal uint VotesUp;

	internal uint VotesDown;

	internal float Score;

	internal uint NumChildren;

	internal ulong TotalFilesSize;

	internal string TitleUTF8()
	{
		return Utility.Utf8NoBom.GetString(Title, 0, Array.IndexOf(Title, (byte)0));
	}

	internal string DescriptionUTF8()
	{
		return Utility.Utf8NoBom.GetString(Description, 0, Array.IndexOf(Description, (byte)0));
	}

	internal string TagsUTF8()
	{
		return Utility.Utf8NoBom.GetString(Tags, 0, Array.IndexOf(Tags, (byte)0));
	}

	internal string PchFileNameUTF8()
	{
		return Utility.Utf8NoBom.GetString(PchFileName, 0, Array.IndexOf(PchFileName, (byte)0));
	}

	internal string URLUTF8()
	{
		return Utility.Utf8NoBom.GetString(URL, 0, Array.IndexOf(URL, (byte)0));
	}
}


using System.Runtime.InteropServices;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamItemDetails_t
{
	internal InventoryItemId ItemId;

	internal InventoryDefId Definition;

	internal ushort Quantity;

	internal ushort Flags;
}


using System;
using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
internal struct SteamDatagramGameCoordinatorServerLogin
{
	internal NetIdentity Dentity;

	internal SteamDatagramHostedAddress Outing;

	internal AppId AppID;

	internal uint Time;

	internal int CbAppData;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 2048)]
	internal byte[] AppData;

	internal string AppDataUTF8()
	{
		return Utility.Utf8NoBom.GetString(AppData, 0, Array.IndexOf(AppData, (byte)0));
	}
}


using System;
using Steamworks.Data;

internal struct DepotId_t : IEquatable<DepotId_t>, IComparable<DepotId_t>
{
	public uint Value;

	public static implicit operator DepotId_t(uint value)
	{
		DepotId_t result = default(DepotId_t);
		result.Value = value;
		return result;
	}

	public static implicit operator uint(DepotId_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((DepotId_t)p);
	}

	public bool Equals(DepotId_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(DepotId_t a, DepotId_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(DepotId_t a, DepotId_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(DepotId_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct RTime32 : IEquatable<RTime32>, IComparable<RTime32>
{
	public uint Value;

	public static implicit operator RTime32(uint value)
	{
		RTime32 result = default(RTime32);
		result.Value = value;
		return result;
	}

	public static implicit operator uint(RTime32 value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((RTime32)p);
	}

	public bool Equals(RTime32 p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(RTime32 a, RTime32 b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(RTime32 a, RTime32 b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(RTime32 other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct SteamAPICall_t : IEquatable<SteamAPICall_t>, IComparable<SteamAPICall_t>
{
	public ulong Value;

	public static implicit operator SteamAPICall_t(ulong value)
	{
		SteamAPICall_t result = default(SteamAPICall_t);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(SteamAPICall_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((SteamAPICall_t)p);
	}

	public bool Equals(SteamAPICall_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(SteamAPICall_t a, SteamAPICall_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(SteamAPICall_t a, SteamAPICall_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(SteamAPICall_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct AccountID_t : IEquatable<AccountID_t>, IComparable<AccountID_t>
{
	public uint Value;

	public static implicit operator AccountID_t(uint value)
	{
		AccountID_t result = default(AccountID_t);
		result.Value = value;
		return result;
	}

	public static implicit operator uint(AccountID_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((AccountID_t)p);
	}

	public bool Equals(AccountID_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(AccountID_t a, AccountID_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(AccountID_t a, AccountID_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(AccountID_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct PartyBeaconID_t : IEquatable<PartyBeaconID_t>, IComparable<PartyBeaconID_t>
{
	public ulong Value;

	public static implicit operator PartyBeaconID_t(ulong value)
	{
		PartyBeaconID_t result = default(PartyBeaconID_t);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(PartyBeaconID_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((PartyBeaconID_t)p);
	}

	public bool Equals(PartyBeaconID_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(PartyBeaconID_t a, PartyBeaconID_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(PartyBeaconID_t a, PartyBeaconID_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(PartyBeaconID_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct HAuthTicket : IEquatable<HAuthTicket>, IComparable<HAuthTicket>
{
	public uint Value;

	public static implicit operator HAuthTicket(uint value)
	{
		HAuthTicket result = default(HAuthTicket);
		result.Value = value;
		return result;
	}

	public static implicit operator uint(HAuthTicket value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((HAuthTicket)p);
	}

	public bool Equals(HAuthTicket p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(HAuthTicket a, HAuthTicket b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(HAuthTicket a, HAuthTicket b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(HAuthTicket other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct HSteamPipe : IEquatable<HSteamPipe>, IComparable<HSteamPipe>
{
	public int Value;

	public static implicit operator HSteamPipe(int value)
	{
		HSteamPipe result = default(HSteamPipe);
		result.Value = value;
		return result;
	}

	public static implicit operator int(HSteamPipe value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((HSteamPipe)p);
	}

	public bool Equals(HSteamPipe p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(HSteamPipe a, HSteamPipe b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(HSteamPipe a, HSteamPipe b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(HSteamPipe other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct HSteamUser : IEquatable<HSteamUser>, IComparable<HSteamUser>
{
	public int Value;

	public static implicit operator HSteamUser(int value)
	{
		HSteamUser result = default(HSteamUser);
		result.Value = value;
		return result;
	}

	public static implicit operator int(HSteamUser value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((HSteamUser)p);
	}

	public bool Equals(HSteamUser p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(HSteamUser a, HSteamUser b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(HSteamUser a, HSteamUser b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(HSteamUser other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct FriendsGroupID_t : IEquatable<FriendsGroupID_t>, IComparable<FriendsGroupID_t>
{
	public short Value;

	public static implicit operator FriendsGroupID_t(short value)
	{
		FriendsGroupID_t result = default(FriendsGroupID_t);
		result.Value = value;
		return result;
	}

	public static implicit operator short(FriendsGroupID_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((FriendsGroupID_t)p);
	}

	public bool Equals(FriendsGroupID_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(FriendsGroupID_t a, FriendsGroupID_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(FriendsGroupID_t a, FriendsGroupID_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(FriendsGroupID_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct HServerListRequest : IEquatable<HServerListRequest>, IComparable<HServerListRequest>
{
	public IntPtr Value;

	public static implicit operator HServerListRequest(IntPtr value)
	{
		HServerListRequest result = default(HServerListRequest);
		result.Value = value;
		return result;
	}

	public static implicit operator IntPtr(HServerListRequest value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((HServerListRequest)p);
	}

	public bool Equals(HServerListRequest p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(HServerListRequest a, HServerListRequest b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(HServerListRequest a, HServerListRequest b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(HServerListRequest other)
	{
		return Value.ToInt64().CompareTo(other.Value.ToInt64());
	}
}


using System;
using Steamworks.Data;

internal struct HServerQuery : IEquatable<HServerQuery>, IComparable<HServerQuery>
{
	public int Value;

	public static implicit operator HServerQuery(int value)
	{
		HServerQuery result = default(HServerQuery);
		result.Value = value;
		return result;
	}

	public static implicit operator int(HServerQuery value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((HServerQuery)p);
	}

	public bool Equals(HServerQuery p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(HServerQuery a, HServerQuery b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(HServerQuery a, HServerQuery b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(HServerQuery other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct UGCHandle_t : IEquatable<UGCHandle_t>, IComparable<UGCHandle_t>
{
	public ulong Value;

	public static implicit operator UGCHandle_t(ulong value)
	{
		UGCHandle_t result = default(UGCHandle_t);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(UGCHandle_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((UGCHandle_t)p);
	}

	public bool Equals(UGCHandle_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(UGCHandle_t a, UGCHandle_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(UGCHandle_t a, UGCHandle_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(UGCHandle_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct PublishedFileUpdateHandle_t : IEquatable<PublishedFileUpdateHandle_t>, IComparable<PublishedFileUpdateHandle_t>
{
	public ulong Value;

	public static implicit operator PublishedFileUpdateHandle_t(ulong value)
	{
		PublishedFileUpdateHandle_t result = default(PublishedFileUpdateHandle_t);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(PublishedFileUpdateHandle_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((PublishedFileUpdateHandle_t)p);
	}

	public bool Equals(PublishedFileUpdateHandle_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(PublishedFileUpdateHandle_t a, PublishedFileUpdateHandle_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(PublishedFileUpdateHandle_t a, PublishedFileUpdateHandle_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(PublishedFileUpdateHandle_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

public struct PublishedFileId : IEquatable<PublishedFileId>, IComparable<PublishedFileId>
{
	public ulong Value;

	public static implicit operator PublishedFileId(ulong value)
	{
		PublishedFileId result = default(PublishedFileId);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(PublishedFileId value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((PublishedFileId)p);
	}

	public bool Equals(PublishedFileId p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(PublishedFileId a, PublishedFileId b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(PublishedFileId a, PublishedFileId b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(PublishedFileId other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct UGCFileWriteStreamHandle_t : IEquatable<UGCFileWriteStreamHandle_t>, IComparable<UGCFileWriteStreamHandle_t>
{
	public ulong Value;

	public static implicit operator UGCFileWriteStreamHandle_t(ulong value)
	{
		UGCFileWriteStreamHandle_t result = default(UGCFileWriteStreamHandle_t);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(UGCFileWriteStreamHandle_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((UGCFileWriteStreamHandle_t)p);
	}

	public bool Equals(UGCFileWriteStreamHandle_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(UGCFileWriteStreamHandle_t a, UGCFileWriteStreamHandle_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(UGCFileWriteStreamHandle_t a, UGCFileWriteStreamHandle_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(UGCFileWriteStreamHandle_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct SteamLeaderboard_t : IEquatable<SteamLeaderboard_t>, IComparable<SteamLeaderboard_t>
{
	public ulong Value;

	public static implicit operator SteamLeaderboard_t(ulong value)
	{
		SteamLeaderboard_t result = default(SteamLeaderboard_t);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(SteamLeaderboard_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((SteamLeaderboard_t)p);
	}

	public bool Equals(SteamLeaderboard_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(SteamLeaderboard_t a, SteamLeaderboard_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(SteamLeaderboard_t a, SteamLeaderboard_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(SteamLeaderboard_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct SteamLeaderboardEntries_t : IEquatable<SteamLeaderboardEntries_t>, IComparable<SteamLeaderboardEntries_t>
{
	public ulong Value;

	public static implicit operator SteamLeaderboardEntries_t(ulong value)
	{
		SteamLeaderboardEntries_t result = default(SteamLeaderboardEntries_t);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(SteamLeaderboardEntries_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((SteamLeaderboardEntries_t)p);
	}

	public bool Equals(SteamLeaderboardEntries_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(SteamLeaderboardEntries_t a, SteamLeaderboardEntries_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(SteamLeaderboardEntries_t a, SteamLeaderboardEntries_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(SteamLeaderboardEntries_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct SNetSocket_t : IEquatable<SNetSocket_t>, IComparable<SNetSocket_t>
{
	public uint Value;

	public static implicit operator SNetSocket_t(uint value)
	{
		SNetSocket_t result = default(SNetSocket_t);
		result.Value = value;
		return result;
	}

	public static implicit operator uint(SNetSocket_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((SNetSocket_t)p);
	}

	public bool Equals(SNetSocket_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(SNetSocket_t a, SNetSocket_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(SNetSocket_t a, SNetSocket_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(SNetSocket_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct SNetListenSocket_t : IEquatable<SNetListenSocket_t>, IComparable<SNetListenSocket_t>
{
	public uint Value;

	public static implicit operator SNetListenSocket_t(uint value)
	{
		SNetListenSocket_t result = default(SNetListenSocket_t);
		result.Value = value;
		return result;
	}

	public static implicit operator uint(SNetListenSocket_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((SNetListenSocket_t)p);
	}

	public bool Equals(SNetListenSocket_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(SNetListenSocket_t a, SNetListenSocket_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(SNetListenSocket_t a, SNetListenSocket_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(SNetListenSocket_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct ScreenshotHandle : IEquatable<ScreenshotHandle>, IComparable<ScreenshotHandle>
{
	public uint Value;

	public static implicit operator ScreenshotHandle(uint value)
	{
		ScreenshotHandle result = default(ScreenshotHandle);
		result.Value = value;
		return result;
	}

	public static implicit operator uint(ScreenshotHandle value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((ScreenshotHandle)p);
	}

	public bool Equals(ScreenshotHandle p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(ScreenshotHandle a, ScreenshotHandle b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(ScreenshotHandle a, ScreenshotHandle b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(ScreenshotHandle other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct HTTPRequestHandle : IEquatable<HTTPRequestHandle>, IComparable<HTTPRequestHandle>
{
	public uint Value;

	public static implicit operator HTTPRequestHandle(uint value)
	{
		HTTPRequestHandle result = default(HTTPRequestHandle);
		result.Value = value;
		return result;
	}

	public static implicit operator uint(HTTPRequestHandle value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((HTTPRequestHandle)p);
	}

	public bool Equals(HTTPRequestHandle p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(HTTPRequestHandle a, HTTPRequestHandle b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(HTTPRequestHandle a, HTTPRequestHandle b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(HTTPRequestHandle other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct HTTPCookieContainerHandle : IEquatable<HTTPCookieContainerHandle>, IComparable<HTTPCookieContainerHandle>
{
	public uint Value;

	public static implicit operator HTTPCookieContainerHandle(uint value)
	{
		HTTPCookieContainerHandle result = default(HTTPCookieContainerHandle);
		result.Value = value;
		return result;
	}

	public static implicit operator uint(HTTPCookieContainerHandle value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((HTTPCookieContainerHandle)p);
	}

	public bool Equals(HTTPCookieContainerHandle p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(HTTPCookieContainerHandle a, HTTPCookieContainerHandle b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(HTTPCookieContainerHandle a, HTTPCookieContainerHandle b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(HTTPCookieContainerHandle other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct InputHandle_t : IEquatable<InputHandle_t>, IComparable<InputHandle_t>
{
	public ulong Value;

	public static implicit operator InputHandle_t(ulong value)
	{
		InputHandle_t result = default(InputHandle_t);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(InputHandle_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((InputHandle_t)p);
	}

	public bool Equals(InputHandle_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(InputHandle_t a, InputHandle_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(InputHandle_t a, InputHandle_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(InputHandle_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct InputActionSetHandle_t : IEquatable<InputActionSetHandle_t>, IComparable<InputActionSetHandle_t>
{
	public ulong Value;

	public static implicit operator InputActionSetHandle_t(ulong value)
	{
		InputActionSetHandle_t result = default(InputActionSetHandle_t);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(InputActionSetHandle_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((InputActionSetHandle_t)p);
	}

	public bool Equals(InputActionSetHandle_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(InputActionSetHandle_t a, InputActionSetHandle_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(InputActionSetHandle_t a, InputActionSetHandle_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(InputActionSetHandle_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct InputDigitalActionHandle_t : IEquatable<InputDigitalActionHandle_t>, IComparable<InputDigitalActionHandle_t>
{
	public ulong Value;

	public static implicit operator InputDigitalActionHandle_t(ulong value)
	{
		InputDigitalActionHandle_t result = default(InputDigitalActionHandle_t);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(InputDigitalActionHandle_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((InputDigitalActionHandle_t)p);
	}

	public bool Equals(InputDigitalActionHandle_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(InputDigitalActionHandle_t a, InputDigitalActionHandle_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(InputDigitalActionHandle_t a, InputDigitalActionHandle_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(InputDigitalActionHandle_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct InputAnalogActionHandle_t : IEquatable<InputAnalogActionHandle_t>, IComparable<InputAnalogActionHandle_t>
{
	public ulong Value;

	public static implicit operator InputAnalogActionHandle_t(ulong value)
	{
		InputAnalogActionHandle_t result = default(InputAnalogActionHandle_t);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(InputAnalogActionHandle_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((InputAnalogActionHandle_t)p);
	}

	public bool Equals(InputAnalogActionHandle_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(InputAnalogActionHandle_t a, InputAnalogActionHandle_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(InputAnalogActionHandle_t a, InputAnalogActionHandle_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(InputAnalogActionHandle_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct ControllerHandle_t : IEquatable<ControllerHandle_t>, IComparable<ControllerHandle_t>
{
	public ulong Value;

	public static implicit operator ControllerHandle_t(ulong value)
	{
		ControllerHandle_t result = default(ControllerHandle_t);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(ControllerHandle_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((ControllerHandle_t)p);
	}

	public bool Equals(ControllerHandle_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(ControllerHandle_t a, ControllerHandle_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(ControllerHandle_t a, ControllerHandle_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(ControllerHandle_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct ControllerActionSetHandle_t : IEquatable<ControllerActionSetHandle_t>, IComparable<ControllerActionSetHandle_t>
{
	public ulong Value;

	public static implicit operator ControllerActionSetHandle_t(ulong value)
	{
		ControllerActionSetHandle_t result = default(ControllerActionSetHandle_t);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(ControllerActionSetHandle_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((ControllerActionSetHandle_t)p);
	}

	public bool Equals(ControllerActionSetHandle_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(ControllerActionSetHandle_t a, ControllerActionSetHandle_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(ControllerActionSetHandle_t a, ControllerActionSetHandle_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(ControllerActionSetHandle_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct ControllerDigitalActionHandle_t : IEquatable<ControllerDigitalActionHandle_t>, IComparable<ControllerDigitalActionHandle_t>
{
	public ulong Value;

	public static implicit operator ControllerDigitalActionHandle_t(ulong value)
	{
		ControllerDigitalActionHandle_t result = default(ControllerDigitalActionHandle_t);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(ControllerDigitalActionHandle_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((ControllerDigitalActionHandle_t)p);
	}

	public bool Equals(ControllerDigitalActionHandle_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(ControllerDigitalActionHandle_t a, ControllerDigitalActionHandle_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(ControllerDigitalActionHandle_t a, ControllerDigitalActionHandle_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(ControllerDigitalActionHandle_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct ControllerAnalogActionHandle_t : IEquatable<ControllerAnalogActionHandle_t>, IComparable<ControllerAnalogActionHandle_t>
{
	public ulong Value;

	public static implicit operator ControllerAnalogActionHandle_t(ulong value)
	{
		ControllerAnalogActionHandle_t result = default(ControllerAnalogActionHandle_t);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(ControllerAnalogActionHandle_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((ControllerAnalogActionHandle_t)p);
	}

	public bool Equals(ControllerAnalogActionHandle_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(ControllerAnalogActionHandle_t a, ControllerAnalogActionHandle_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(ControllerAnalogActionHandle_t a, ControllerAnalogActionHandle_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(ControllerAnalogActionHandle_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct UGCQueryHandle_t : IEquatable<UGCQueryHandle_t>, IComparable<UGCQueryHandle_t>
{
	public ulong Value;

	public static implicit operator UGCQueryHandle_t(ulong value)
	{
		UGCQueryHandle_t result = default(UGCQueryHandle_t);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(UGCQueryHandle_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((UGCQueryHandle_t)p);
	}

	public bool Equals(UGCQueryHandle_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(UGCQueryHandle_t a, UGCQueryHandle_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(UGCQueryHandle_t a, UGCQueryHandle_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(UGCQueryHandle_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct UGCUpdateHandle_t : IEquatable<UGCUpdateHandle_t>, IComparable<UGCUpdateHandle_t>
{
	public ulong Value;

	public static implicit operator UGCUpdateHandle_t(ulong value)
	{
		UGCUpdateHandle_t result = default(UGCUpdateHandle_t);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(UGCUpdateHandle_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((UGCUpdateHandle_t)p);
	}

	public bool Equals(UGCUpdateHandle_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(UGCUpdateHandle_t a, UGCUpdateHandle_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(UGCUpdateHandle_t a, UGCUpdateHandle_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(UGCUpdateHandle_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct HHTMLBrowser : IEquatable<HHTMLBrowser>, IComparable<HHTMLBrowser>
{
	public uint Value;

	public static implicit operator HHTMLBrowser(uint value)
	{
		HHTMLBrowser result = default(HHTMLBrowser);
		result.Value = value;
		return result;
	}

	public static implicit operator uint(HHTMLBrowser value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((HHTMLBrowser)p);
	}

	public bool Equals(HHTMLBrowser p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(HHTMLBrowser a, HHTMLBrowser b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(HHTMLBrowser a, HHTMLBrowser b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(HHTMLBrowser other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

public struct InventoryItemId : IEquatable<InventoryItemId>, IComparable<InventoryItemId>
{
	public ulong Value;

	public static implicit operator InventoryItemId(ulong value)
	{
		InventoryItemId result = default(InventoryItemId);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(InventoryItemId value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((InventoryItemId)p);
	}

	public bool Equals(InventoryItemId p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(InventoryItemId a, InventoryItemId b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(InventoryItemId a, InventoryItemId b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(InventoryItemId other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

public struct InventoryDefId : IEquatable<InventoryDefId>, IComparable<InventoryDefId>
{
	public int Value;

	public static implicit operator InventoryDefId(int value)
	{
		InventoryDefId result = default(InventoryDefId);
		result.Value = value;
		return result;
	}

	public static implicit operator int(InventoryDefId value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((InventoryDefId)p);
	}

	public bool Equals(InventoryDefId p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(InventoryDefId a, InventoryDefId b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(InventoryDefId a, InventoryDefId b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(InventoryDefId other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct SteamInventoryResult_t : IEquatable<SteamInventoryResult_t>, IComparable<SteamInventoryResult_t>
{
	public int Value;

	public static implicit operator SteamInventoryResult_t(int value)
	{
		SteamInventoryResult_t result = default(SteamInventoryResult_t);
		result.Value = value;
		return result;
	}

	public static implicit operator int(SteamInventoryResult_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((SteamInventoryResult_t)p);
	}

	public bool Equals(SteamInventoryResult_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(SteamInventoryResult_t a, SteamInventoryResult_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(SteamInventoryResult_t a, SteamInventoryResult_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(SteamInventoryResult_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct SteamInventoryUpdateHandle_t : IEquatable<SteamInventoryUpdateHandle_t>, IComparable<SteamInventoryUpdateHandle_t>
{
	public ulong Value;

	public static implicit operator SteamInventoryUpdateHandle_t(ulong value)
	{
		SteamInventoryUpdateHandle_t result = default(SteamInventoryUpdateHandle_t);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(SteamInventoryUpdateHandle_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((SteamInventoryUpdateHandle_t)p);
	}

	public bool Equals(SteamInventoryUpdateHandle_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(SteamInventoryUpdateHandle_t a, SteamInventoryUpdateHandle_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(SteamInventoryUpdateHandle_t a, SteamInventoryUpdateHandle_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(SteamInventoryUpdateHandle_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

public struct TimelineEventHandle : IEquatable<TimelineEventHandle>, IComparable<TimelineEventHandle>
{
	public ulong Value;

	public static implicit operator TimelineEventHandle(ulong value)
	{
		TimelineEventHandle result = default(TimelineEventHandle);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(TimelineEventHandle value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((TimelineEventHandle)p);
	}

	public bool Equals(TimelineEventHandle p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(TimelineEventHandle a, TimelineEventHandle b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(TimelineEventHandle a, TimelineEventHandle b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(TimelineEventHandle other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct RemotePlaySessionID_t : IEquatable<RemotePlaySessionID_t>, IComparable<RemotePlaySessionID_t>
{
	public uint Value;

	public static implicit operator RemotePlaySessionID_t(uint value)
	{
		RemotePlaySessionID_t result = default(RemotePlaySessionID_t);
		result.Value = value;
		return result;
	}

	public static implicit operator uint(RemotePlaySessionID_t value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((RemotePlaySessionID_t)p);
	}

	public bool Equals(RemotePlaySessionID_t p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(RemotePlaySessionID_t a, RemotePlaySessionID_t b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(RemotePlaySessionID_t a, RemotePlaySessionID_t b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(RemotePlaySessionID_t other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct HSteamNetPollGroup : IEquatable<HSteamNetPollGroup>, IComparable<HSteamNetPollGroup>
{
	public uint Value;

	public static implicit operator HSteamNetPollGroup(uint value)
	{
		HSteamNetPollGroup result = default(HSteamNetPollGroup);
		result.Value = value;
		return result;
	}

	public static implicit operator uint(HSteamNetPollGroup value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((HSteamNetPollGroup)p);
	}

	public bool Equals(HSteamNetPollGroup p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(HSteamNetPollGroup a, HSteamNetPollGroup b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(HSteamNetPollGroup a, HSteamNetPollGroup b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(HSteamNetPollGroup other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks.Data;

internal struct SteamNetworkingPOPID : IEquatable<SteamNetworkingPOPID>, IComparable<SteamNetworkingPOPID>
{
	public uint Value;

	public static implicit operator SteamNetworkingPOPID(uint value)
	{
		SteamNetworkingPOPID result = default(SteamNetworkingPOPID);
		result.Value = value;
		return result;
	}

	public static implicit operator uint(SteamNetworkingPOPID value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public override bool Equals(object p)
	{
		return Equals((SteamNetworkingPOPID)p);
	}

	public bool Equals(SteamNetworkingPOPID p)
	{
		return p.Value == Value;
	}

	public static bool operator ==(SteamNetworkingPOPID a, SteamNetworkingPOPID b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(SteamNetworkingPOPID a, SteamNetworkingPOPID b)
	{
		return !a.Equals(b);
	}

	public int CompareTo(SteamNetworkingPOPID other)
	{
		return Value.CompareTo(other.Value);
	}
}


using System;
using Steamworks;
using Steamworks.Data;

public struct Connection : IEquatable<Connection>
{
	public uint Id { get; set; }

	public long UserData
	{
		get
		{
			return SteamNetworkingSockets.Internal.GetConnectionUserData(this);
		}
		set
		{
			SteamNetworkingSockets.Internal.SetConnectionUserData(this, value);
		}
	}

	public string ConnectionName
	{
		get
		{
			if (!SteamNetworkingSockets.Internal.GetConnectionName(this, out var pszName))
			{
				return "ERROR";
			}
			return pszName;
		}
		set
		{
			SteamNetworkingSockets.Internal.SetConnectionName(this, value);
		}
	}

	public bool Equals(Connection other)
	{
		return Id == other.Id;
	}

	public override bool Equals(object obj)
	{
		if (obj is Connection connection)
		{
			return Id == connection.Id;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return Id.GetHashCode();
	}

	public override string ToString()
	{
		return Id.ToString();
	}

	public static implicit operator Connection(uint value)
	{
		Connection result = default(Connection);
		result.Id = value;
		return result;
	}

	public static implicit operator uint(Connection value)
	{
		return value.Id;
	}

	public static bool operator ==(Connection value1, Connection value2)
	{
		return value1.Equals(value2);
	}

	public static bool operator !=(Connection value1, Connection value2)
	{
		return !value1.Equals(value2);
	}

	public Result Accept()
	{
		return SteamNetworkingSockets.Internal.AcceptConnection(this);
	}

	public bool Close(bool linger = false, int reasonCode = 0, string debugString = "Closing Connection")
	{
		return SteamNetworkingSockets.Internal.CloseConnection(this, reasonCode, debugString, linger);
	}

	public unsafe Result SendMessage(IntPtr ptr, int size, SendType sendType = SendType.Reliable, ushort laneIndex = 0)
	{
		if (ptr == IntPtr.Zero)
		{
			throw new ArgumentNullException("ptr");
		}
		if (size == 0)
		{
			throw new ArgumentException("`size` cannot be zero", "size");
		}
		IntPtr intPtr = BufferManager.Get(size, 1);
		Buffer.MemoryCopy((void*)ptr, (void*)intPtr, size, size);
		NetMsg* ptr2 = SteamNetworkingUtils.AllocateMessage();
		ptr2->Connection = this;
		ptr2->Flags = sendType;
		ptr2->DataPtr = intPtr;
		ptr2->DataSize = size;
		ptr2->FreeDataPtr = BufferManager.FreeFunctionPointer;
		ptr2->IdxLane = laneIndex;
		long num = 0L;
		SteamNetworkingSockets.Internal.SendMessages(1, &ptr2, &num);
		if (num < 0)
		{
			return (Result)(-num);
		}
		return Result.OK;
	}

	public unsafe Result SendMessage(byte[] data, SendType sendType = SendType.Reliable, ushort laneIndex = 0)
	{
		fixed (byte* ptr = data)
		{
			return SendMessage((IntPtr)ptr, data.Length, sendType, laneIndex);
		}
	}

	public unsafe Result SendMessage(byte[] data, int offset, int length, SendType sendType = SendType.Reliable, ushort laneIndex = 0)
	{
		fixed (byte* ptr = data)
		{
			return SendMessage((IntPtr)ptr + offset, length, sendType, laneIndex);
		}
	}

	public Result SendMessage(string str, SendType sendType = SendType.Reliable, ushort laneIndex = 0)
	{
		byte[] bytes = Utility.Utf8NoBom.GetBytes(str);
		return SendMessage(bytes, sendType, laneIndex);
	}

	public Result Flush()
	{
		return SteamNetworkingSockets.Internal.FlushMessagesOnConnection(this);
	}

	public string DetailedStatus()
	{
		if (SteamNetworkingSockets.Internal.GetDetailedConnectionStatus(this, out var pszBuf) != 0)
		{
			return null;
		}
		return pszBuf;
	}

	public ConnectionStatus QuickStatus()
	{
		ConnectionStatus pStatus = default(ConnectionStatus);
		SteamNetworkingSockets.Internal.GetConnectionRealTimeStatus(this, ref pStatus, 0, null);
		return pStatus;
	}

	public Result ConfigureConnectionLanes(int[] lanePriorities, ushort[] laneWeights)
	{
		return SteamNetworkingSockets.Internal.ConfigureConnectionLanes(this, lanePriorities.Length, lanePriorities, laneWeights);
	}
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Sequential, Size = 696)]
public struct ConnectionInfo
{
	internal NetIdentity identity;

	internal long userData;

	internal Socket listenSocket;

	internal NetAddress address;

	internal ushort pad;

	internal SteamNetworkingPOPID popRemote;

	internal SteamNetworkingPOPID popRelay;

	internal ConnectionState state;

	internal int endReason;

	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
	internal string endDebug;

	[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
	internal string connectionDescription;

	public ConnectionState State => state;

	public NetAddress Address => address;

	public NetIdentity Identity => identity;

	public NetConnectionEnd EndReason => (NetConnectionEnd)endReason;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
public struct ConnectionLaneStatus
{
	internal int cbPendingUnreliable;

	internal int cbPendingReliable;

	internal int cbSentUnackedReliable;

	internal int _reservePad1;

	internal long ecQueueTime;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 10, ArraySubType = UnmanagedType.U4)]
	internal uint[] reserved;

	public int PendingUnreliable => cbPendingUnreliable;

	public int PendingReliable => cbPendingReliable;

	public int SentUnackedReliable => cbSentUnackedReliable;
}


using System.Runtime.InteropServices;
using Steamworks;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
public struct ConnectionStatus
{
	internal ConnectionState state;

	internal int ping;

	internal float connectionQualityLocal;

	internal float connectionQualityRemote;

	internal float outPacketsPerSec;

	internal float outBytesPerSec;

	internal float inPacketsPerSec;

	internal float inBytesPerSec;

	internal int sendRateBytesPerSecond;

	internal int cbPendingUnreliable;

	internal int cbPendingReliable;

	internal int cbSentUnackedReliable;

	internal long ecQueueTime;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.U4)]
	internal uint[] reserved;

	public int Ping => ping;

	public float OutPacketsPerSec => outPacketsPerSec;

	public float OutBytesPerSec => outBytesPerSec;

	public float InPacketsPerSec => inPacketsPerSec;

	public float InBytesPerSec => inBytesPerSec;

	public float ConnectionQualityLocal => connectionQualityLocal;

	public float ConnectionQualityRemote => connectionQualityRemote;

	public int PendingUnreliable => cbPendingUnreliable;

	public int PendingReliable => cbPendingReliable;

	public int SentUnackedReliable => cbSentUnackedReliable;
}


internal struct NetErrorMessage
{
	public unsafe fixed char Value[1024];
}


using System.Runtime.InteropServices;
using Steamworks;
using Steamworks.Data;

[StructLayout(LayoutKind.Explicit, Size = 512)]
public struct NetPingLocation
{
	public static NetPingLocation? TryParseFromString(string str)
	{
		NetPingLocation result = default(NetPingLocation);
		if (!SteamNetworkingUtils.Internal.ParsePingLocationString(str, ref result))
		{
			return null;
		}
		return result;
	}

	public override string ToString()
	{
		SteamNetworkingUtils.Internal.ConvertPingLocationToString(ref this, out var pszBuf);
		return pszBuf;
	}

	public int EstimatePingTo(NetPingLocation target)
	{
		return SteamNetworkingUtils.Internal.EstimatePingTimeBetweenTwoLocations(ref this, ref target);
	}
}


using Steamworks;
using Steamworks.Data;

public struct Socket
{
	internal uint Id;

	public SocketManager Manager
	{
		get
		{
			return SteamNetworkingSockets.GetSocketManager(Id);
		}
		set
		{
			SteamNetworkingSockets.SetSocketManager(Id, value);
		}
	}

	public override string ToString()
	{
		return Id.ToString();
	}

	public static implicit operator Socket(uint value)
	{
		Socket result = default(Socket);
		result.Id = value;
		return result;
	}

	public static implicit operator uint(Socket value)
	{
		return value.Id;
	}

	public bool Close()
	{
		return SteamNetworkingSockets.Internal.CloseListenSocket(Id);
	}
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct SteamDatagramRelayAuthTicket
{
}


using System;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;

public struct Achievement
{
	internal string Value;

	public bool State
	{
		get
		{
			bool pbAchieved = false;
			SteamUserStats.Internal.GetAchievement(Value, ref pbAchieved);
			return pbAchieved;
		}
	}

	public string Identifier => Value;

	public string Name => SteamUserStats.Internal.GetAchievementDisplayAttribute(Value, "name");

	public string Description => SteamUserStats.Internal.GetAchievementDisplayAttribute(Value, "desc");

	public DateTime? UnlockTime
	{
		get
		{
			bool pbAchieved = false;
			uint punUnlockTime = 0u;
			if (!SteamUserStats.Internal.GetAchievementAndUnlockTime(Value, ref pbAchieved, ref punUnlockTime) || !pbAchieved)
			{
				return null;
			}
			return Epoch.ToDateTime(punUnlockTime);
		}
	}

	public float GlobalUnlocked
	{
		get
		{
			float pflPercent = 0f;
			if (!SteamUserStats.Internal.GetAchievementAchievedPercent(Value, ref pflPercent))
			{
				return -1f;
			}
			return pflPercent / 100f;
		}
	}

	public Achievement(string name)
	{
		Value = name;
	}

	public override string ToString()
	{
		return Value;
	}

	public Image? GetIcon()
	{
		return SteamUtils.GetImage(SteamUserStats.Internal.GetAchievementIcon(Value));
	}

	public async Task<Image?> GetIconAsync(int timeout = 5000)
	{
		int i = SteamUserStats.Internal.GetAchievementIcon(Value);
		if (i != 0)
		{
			return SteamUtils.GetImage(i);
		}
		string ident = Identifier;
		bool gotCallback = false;
		try
		{
			SteamUserStats.OnAchievementIconFetched += f;
			int waited = 0;
			while (!gotCallback)
			{
				await Task.Delay(10);
				waited += 10;
				if (waited > timeout)
				{
					return null;
				}
			}
			if (i == 0)
			{
				return null;
			}
			return SteamUtils.GetImage(i);
		}
		finally
		{
			SteamUserStats.OnAchievementIconFetched -= f;
		}
		void f(string x, int icon)
		{
			if (!(x != ident))
			{
				i = icon;
				gotCallback = true;
			}
		}
	}

	public bool Trigger(bool apply = true)
	{
		bool flag = SteamUserStats.Internal.SetAchievement(Value);
		if (apply && flag)
		{
			SteamUserStats.Internal.StoreStats();
		}
		return flag;
	}

	public bool Clear()
	{
		return SteamUserStats.Internal.ClearAchievement(Value);
	}
}


using Steamworks.Data;

public struct DepotId
{
	public uint Value;

	public static implicit operator DepotId(uint value)
	{
		DepotId result = default(DepotId);
		result.Value = value;
		return result;
	}

	public static implicit operator DepotId(int value)
	{
		DepotId result = default(DepotId);
		result.Value = (uint)value;
		return result;
	}

	public static implicit operator uint(DepotId value)
	{
		return value.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}
}


using Steamworks;

public struct DlcInformation
{
	public AppId AppId { get; internal set; }

	public string Name { get; internal set; }

	public bool Available { get; internal set; }
}


public struct DownloadProgress
{
	public bool Active;

	public ulong BytesDownloaded;

	public ulong BytesTotal;

	public ulong BytesRemaining => BytesTotal - BytesDownloaded;
}


using System;
using Steamworks;
using Steamworks.Data;

public struct DurationControl
{
	internal DurationControl_t _inner;

	public AppId Appid => _inner.Appid;

	public bool Applicable => _inner.Applicable;

	internal TimeSpan PlaytimeInLastFiveHours => TimeSpan.FromSeconds(_inner.CsecsLast5h);

	internal TimeSpan PlaytimeToday => TimeSpan.FromSeconds(_inner.CsecsLast5h);

	internal DurationControlProgress Progress => _inner.Progress;
}


public struct FileDetails
{
	public ulong SizeInBytes;

	public string Sha1;

	public uint Flags;
}


public enum GameIdType : byte
{
	App,
	GameMod,
	Shortcut,
	P2P
}


using System;
using Steamworks.Data;

public struct GameId : IEquatable<GameId>
{
	public ulong Value;

	public GameIdType Type
	{
		get
		{
			return (GameIdType)(Value >> 24);
		}
		set
		{
			Value = (Value & 0xFFFFFFFF00FFFFFFuL) | ((ulong)value << 24);
		}
	}

	public uint AppId
	{
		get
		{
			return (uint)(Value & 0xFFFFFF);
		}
		set
		{
			Value = (Value & 0xFFFFFFFFFF000000uL) | (value & 0xFFFFFF);
		}
	}

	public uint ModId
	{
		get
		{
			return (uint)(Value >> 32);
		}
		set
		{
			Value = (Value & 0xFFFFFFFFu) | ((ulong)value << 32);
		}
	}

	public static implicit operator GameId(ulong value)
	{
		GameId result = default(GameId);
		result.Value = value;
		return result;
	}

	public static implicit operator ulong(GameId value)
	{
		return value.Value;
	}

	public bool Equals(GameId other)
	{
		return Value == other.Value;
	}

	public override bool Equals(object obj)
	{
		if (obj is GameId other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return Value.GetHashCode();
	}

	public static bool operator ==(GameId left, GameId right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(GameId left, GameId right)
	{
		return !left.Equals(right);
	}
}


using System;
using Steamworks.Data;

public struct Image
{
	public uint Width;

	public uint Height;

	public byte[] Data;

	public Color GetPixel(int x, int y)
	{
		if (x < 0 || x >= Width)
		{
			throw new ArgumentException("x out of bounds");
		}
		if (y < 0 || y >= Height)
		{
			throw new ArgumentException("y out of bounds");
		}
		Color result = default(Color);
		long num = (y * Width + x) * 4;
		result.r = Data[num];
		result.g = Data[num + 1];
		result.b = Data[num + 2];
		result.a = Data[num + 3];
		return result;
	}

	public override string ToString()
	{
		return $"{Width}x{Height} ({Data.Length}bytes)";
	}
}


public struct Color
{
	public byte r;

	public byte g;

	public byte b;

	public byte a;
}


using Steamworks;

public struct InventoryPurchaseResult
{
	public Result Result;

	public ulong OrderID;

	public ulong TransID;
}


using System;
using System.Threading.Tasks;
using Steamworks;
using Steamworks.Data;

public struct Leaderboard
{
	internal SteamLeaderboard_t Id;

	private static int[] detailsBuffer = new int[64];

	private static int[] noDetails = Array.Empty<int>();

	public string Name => SteamUserStats.Internal.GetLeaderboardName(Id);

	public LeaderboardSort Sort => SteamUserStats.Internal.GetLeaderboardSortMethod(Id);

	public LeaderboardDisplay Display => SteamUserStats.Internal.GetLeaderboardDisplayType(Id);

	public int EntryCount => SteamUserStats.Internal.GetLeaderboardEntryCount(Id);

	public async Task<LeaderboardUpdate?> ReplaceScore(int score, int[] details = null)
	{
		if (details == null)
		{
			details = noDetails;
		}
		LeaderboardScoreUploaded_t? leaderboardScoreUploaded_t = await SteamUserStats.Internal.UploadLeaderboardScore(Id, LeaderboardUploadScoreMethod.ForceUpdate, score, details, details.Length);
		if (!leaderboardScoreUploaded_t.HasValue)
		{
			return null;
		}
		return LeaderboardUpdate.From(leaderboardScoreUploaded_t.Value);
	}

	public async Task<LeaderboardUpdate?> SubmitScoreAsync(int score, int[] details = null)
	{
		if (details == null)
		{
			details = noDetails;
		}
		LeaderboardScoreUploaded_t? leaderboardScoreUploaded_t = await SteamUserStats.Internal.UploadLeaderboardScore(Id, LeaderboardUploadScoreMethod.KeepBest, score, details, details.Length);
		if (!leaderboardScoreUploaded_t.HasValue)
		{
			return null;
		}
		return LeaderboardUpdate.From(leaderboardScoreUploaded_t.Value);
	}

	public async Task<Result> AttachUgc(Ugc file)
	{
		LeaderboardUGCSet_t? leaderboardUGCSet_t = await SteamUserStats.Internal.AttachLeaderboardUGC(Id, file.Handle);
		if (!leaderboardUGCSet_t.HasValue)
		{
			return Result.Fail;
		}
		return leaderboardUGCSet_t.Value.Result;
	}

	public async Task<LeaderboardEntry[]> GetScoresForUsersAsync(SteamId[] users)
	{
		if (users == null || users.Length == 0)
		{
			return null;
		}
		LeaderboardScoresDownloaded_t? leaderboardScoresDownloaded_t = await SteamUserStats.Internal.DownloadLeaderboardEntriesForUsers(Id, users, users.Length);
		if (!leaderboardScoresDownloaded_t.HasValue)
		{
			return null;
		}
		return await LeaderboardResultToEntries(leaderboardScoresDownloaded_t.Value);
	}

	public async Task<LeaderboardEntry[]> GetScoresAsync(int count, int offset = 1)
	{
		if (offset <= 0)
		{
			throw new ArgumentException("Should be 1+", "offset");
		}
		LeaderboardScoresDownloaded_t? leaderboardScoresDownloaded_t = await SteamUserStats.Internal.DownloadLeaderboardEntries(Id, LeaderboardDataRequest.Global, offset, offset + count - 1);
		if (!leaderboardScoresDownloaded_t.HasValue)
		{
			return null;
		}
		return await LeaderboardResultToEntries(leaderboardScoresDownloaded_t.Value);
	}

	public async Task<LeaderboardEntry[]> GetScoresAroundUserAsync(int start = -10, int end = 10)
	{
		LeaderboardScoresDownloaded_t? leaderboardScoresDownloaded_t = await SteamUserStats.Internal.DownloadLeaderboardEntries(Id, LeaderboardDataRequest.GlobalAroundUser, start, end);
		if (!leaderboardScoresDownloaded_t.HasValue)
		{
			return null;
		}
		return await LeaderboardResultToEntries(leaderboardScoresDownloaded_t.Value);
	}

	public async Task<LeaderboardEntry[]> GetScoresFromFriendsAsync()
	{
		LeaderboardScoresDownloaded_t? leaderboardScoresDownloaded_t = await SteamUserStats.Internal.DownloadLeaderboardEntries(Id, LeaderboardDataRequest.Friends, 0, 0);
		if (!leaderboardScoresDownloaded_t.HasValue)
		{
			return null;
		}
		return await LeaderboardResultToEntries(leaderboardScoresDownloaded_t.Value);
	}

	internal async Task<LeaderboardEntry[]> LeaderboardResultToEntries(LeaderboardScoresDownloaded_t r)
	{
		if (r.CEntryCount <= 0)
		{
			return null;
		}
		LeaderboardEntry[] output = new LeaderboardEntry[r.CEntryCount];
		LeaderboardEntry_t pLeaderboardEntry = default(LeaderboardEntry_t);
		for (int i = 0; i < output.Length; i++)
		{
			if (SteamUserStats.Internal.GetDownloadedLeaderboardEntry(r.SteamLeaderboardEntries, i, ref pLeaderboardEntry, detailsBuffer, detailsBuffer.Length))
			{
				output[i] = LeaderboardEntry.From(pLeaderboardEntry, detailsBuffer);
			}
		}
		await WaitForUserNames(output);
		return output;
	}

	internal static async Task WaitForUserNames(LeaderboardEntry[] entries)
	{
		bool gotAll = false;
		while (!gotAll)
		{
			gotAll = true;
			for (int i = 0; i < entries.Length; i++)
			{
				LeaderboardEntry leaderboardEntry = entries[i];
				if ((ulong)leaderboardEntry.User.Id != 0L && SteamFriends.Internal.RequestUserInformation(leaderboardEntry.User.Id, bRequireNameOnly: true))
				{
					gotAll = false;
				}
			}
			await Task.Delay(1);
		}
	}
}


using System.Linq;
using Steamworks;
using Steamworks.Data;

public struct LeaderboardEntry
{
	public Friend User;

	public int GlobalRank;

	public int Score;

	public int[] Details;

	internal static LeaderboardEntry From(LeaderboardEntry_t e, int[] detailsBuffer)
	{
		LeaderboardEntry leaderboardEntry = default(LeaderboardEntry);
		leaderboardEntry.User = new Friend(e.SteamIDUser);
		leaderboardEntry.GlobalRank = e.GlobalRank;
		leaderboardEntry.Score = e.Score;
		leaderboardEntry.Details = null;
		LeaderboardEntry result = leaderboardEntry;
		if (e.CDetails > 0)
		{
			result.Details = detailsBuffer.Take(e.CDetails).ToArray();
		}
		return result;
	}
}


using Steamworks.Data;

public struct LeaderboardUpdate
{
	public int Score;

	public bool Changed;

	public int NewGlobalRank;

	public int OldGlobalRank;

	public int RankChange => NewGlobalRank - OldGlobalRank;

	internal static LeaderboardUpdate From(LeaderboardScoreUploaded_t e)
	{
		LeaderboardUpdate result = default(LeaderboardUpdate);
		result.Score = e.Score;
		result.Changed = e.ScoreChanged == 1;
		result.NewGlobalRank = e.GlobalRankNew;
		result.OldGlobalRank = e.GlobalRankPrevious;
		return result;
	}
}


