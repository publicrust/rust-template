using System;
using System.IO;
using Epic.OnlineServices;
using Epic.OnlineServices.Connect;
using Epic.OnlineServices.Logging;
using Epic.OnlineServices.Platform;
using Epic.OnlineServices.Sanctions;
using UnityEngine;

public class EOS
{
	private static string productName = "Rust";

	private static string productVersion = "1.0";

	private static string productId = "429c2212ad284866aee071454c2125b5";

	private static string sandboxId = "ec47bae0651a4765a063c1e83ec41b34";

	private static string deploymentId = "76796531e86443548754600511f42e9e";

	public static PlatformInterface Interface;

	public static LogLevel LogLevel = LogLevel.Warning;

	private static StreamWriter logWriter = null;

	private static void OnLogMessage(ref LogMessage logMessage)
	{
		if (logWriter != null)
		{
			logWriter.Write(DateTime.Now.TimeOfDay.ToString("hh\\:mm\\:ss"));
			logWriter.Write(' ');
			logWriter.WriteLine(logMessage.Message);
		}
		else
		{
			DebugEx.Log((object)logMessage.Message, (StackTraceLogType)0);
		}
	}

	public static void Initialize(bool isServer, string clientId, string clientSecret, string logFile = null)
	{
		if (Interface != null)
		{
			throw new Exception("[EOS] Duplicate initialize");
		}
		InitializeOptions initializeOptions = default(InitializeOptions);
		initializeOptions.ProductName = productName;
		initializeOptions.ProductVersion = productVersion;
		InitializeOptions options = initializeOptions;
		Result result = PlatformInterface.Initialize(ref options);
		if (result != 0)
		{
			throw new Exception("[EOS] Failed to initialize platform: " + result);
		}
		if (logFile != null)
		{
			logWriter = new StreamWriter(logFile, append: false);
			logWriter.AutoFlush = true;
		}
		LoggingInterface.SetLogLevel(LogCategory.AllCategories, LogLevel);
		LoggingInterface.SetCallback(OnLogMessage);
		Options options2 = default(Options);
		options2.IsServer = isServer;
		options2.ProductId = productId;
		options2.SandboxId = sandboxId;
		options2.DeploymentId = deploymentId;
		options2.ClientCredentials = new ClientCredentials
		{
			ClientId = clientId,
			ClientSecret = clientSecret
		};
		options2.Flags = PlatformFlags.DisableOverlay;
		Options options3 = options2;
		Interface = PlatformInterface.Create(ref options3);
		if (Interface == null)
		{
			throw new Exception("[EOS] Failed to create platform");
		}
	}

	public static void AddAuthExpirationCallback(OnAuthExpirationCallback callback)
	{
		if (Interface == null)
		{
			throw new Exception("[EOS] Attempting to add auth expiration callback without initialization");
		}
		AddNotifyAuthExpirationOptions options = default(AddNotifyAuthExpirationOptions);
		ConnectInterface connectInterface = Interface.GetConnectInterface();
		if (connectInterface == null)
		{
			throw new Exception("[EOS] Failed to get connect interface");
		}
		connectInterface.AddNotifyAuthExpiration(ref options, null, callback);
	}

	public static void Login(string steamLoginCredentialToken, OnLoginCallback callback)
	{
		if (Interface == null)
		{
			throw new Exception("[EOS] Attempting to login without initialization");
		}
		ExternalCredentialType type = ExternalCredentialType.SteamAppTicket;
		LoginOptions loginOptions = default(LoginOptions);
		loginOptions.Credentials = new Credentials
		{
			Type = type,
			Token = steamLoginCredentialToken
		};
		LoginOptions options = loginOptions;
		ConnectInterface connectInterface = Interface.GetConnectInterface();
		if (connectInterface == null)
		{
			throw new Exception("[EOS] Failed to get connect interface");
		}
		connectInterface.Login(ref options, null, callback);
	}

	public static void CreateUser(ContinuanceToken token, OnCreateUserCallback callback)
	{
		if (Interface == null)
		{
			throw new Exception("[EOS] Attempting to create user without initialization");
		}
		CreateUserOptions createUserOptions = default(CreateUserOptions);
		createUserOptions.ContinuanceToken = token;
		CreateUserOptions options = createUserOptions;
		ConnectInterface connectInterface = Interface.GetConnectInterface();
		if (connectInterface == null)
		{
			throw new Exception("[EOS] Failed to get connect interface");
		}
		connectInterface.CreateUser(ref options, null, callback);
	}

	public static void QuerySanctions(ProductUserId user, OnQueryActivePlayerSanctionsCallback callback)
	{
		if (Interface == null)
		{
			throw new Exception("[EOS] Attempting to query active sanctions without initialization");
		}
		QueryActivePlayerSanctionsOptions queryActivePlayerSanctionsOptions = default(QueryActivePlayerSanctionsOptions);
		queryActivePlayerSanctionsOptions.LocalUserId = user;
		queryActivePlayerSanctionsOptions.TargetUserId = user;
		QueryActivePlayerSanctionsOptions options = queryActivePlayerSanctionsOptions;
		SanctionsInterface sanctionsInterface = Interface.GetSanctionsInterface();
		if (sanctionsInterface == null)
		{
			throw new Exception("[EOS] Failed to get sanctions interface");
		}
		sanctionsInterface.QueryActivePlayerSanctions(ref options, null, callback);
	}

	public static int GetSanctionCount(ProductUserId user)
	{
		if (Interface == null)
		{
			throw new Exception("[EOS] Attempting to get sanction count without initialization");
		}
		GetPlayerSanctionCountOptions getPlayerSanctionCountOptions = default(GetPlayerSanctionCountOptions);
		getPlayerSanctionCountOptions.TargetUserId = user;
		GetPlayerSanctionCountOptions options = getPlayerSanctionCountOptions;
		SanctionsInterface sanctionsInterface = Interface.GetSanctionsInterface();
		if (sanctionsInterface == null)
		{
			throw new Exception("[EOS] Failed to get sanctions interface");
		}
		return (int)sanctionsInterface.GetPlayerSanctionCount(ref options);
	}

	public static PlayerSanction GetSanctionData(ProductUserId user, int index)
	{
		if (Interface == null)
		{
			throw new Exception("[EOS] Attempting to get sanction data without initialization");
		}
		CopyPlayerSanctionByIndexOptions copyPlayerSanctionByIndexOptions = default(CopyPlayerSanctionByIndexOptions);
		copyPlayerSanctionByIndexOptions.TargetUserId = user;
		copyPlayerSanctionByIndexOptions.SanctionIndex = (uint)index;
		CopyPlayerSanctionByIndexOptions options = copyPlayerSanctionByIndexOptions;
		SanctionsInterface sanctionsInterface = Interface.GetSanctionsInterface();
		if (sanctionsInterface == null)
		{
			throw new Exception("[EOS] Failed to get sanctions interface");
		}
		sanctionsInterface.CopyPlayerSanctionByIndex(ref options, out var outSanction);
		return outSanction.GetValueOrDefault();
	}

	public static Result CopyIdToken(ProductUserId account, out IdToken? token)
	{
		if (Interface == null)
		{
			throw new Exception("[EOS] Attempting to create user without initialization");
		}
		CopyIdTokenOptions copyIdTokenOptions = default(CopyIdTokenOptions);
		copyIdTokenOptions.LocalUserId = account;
		CopyIdTokenOptions options = copyIdTokenOptions;
		ConnectInterface connectInterface = Interface.GetConnectInterface();
		if (connectInterface == null)
		{
			throw new Exception("[EOS] Failed to get connect interface");
		}
		return connectInterface.CopyIdToken(ref options, out token);
	}

	public static void VerifyIdToken(IntPtr client, IdToken token, OnVerifyIdTokenCallback callback)
	{
		if (Interface == null)
		{
			throw new Exception("[EOS] Attempting to create user without initialization");
		}
		VerifyIdTokenOptions verifyIdTokenOptions = default(VerifyIdTokenOptions);
		verifyIdTokenOptions.IdToken = token;
		VerifyIdTokenOptions options = verifyIdTokenOptions;
		ConnectInterface connectInterface = Interface.GetConnectInterface();
		if (connectInterface == null)
		{
			throw new Exception("[EOS] Failed to get connect interface");
		}
		connectInterface.VerifyIdToken(ref options, client, callback);
	}

	public static void Shutdown()
	{
		if (Interface != null)
		{
			Interface.Release();
			Interface = null;
			PlatformInterface.Shutdown();
		}
	}

	public static void Tick()
	{
		if (Interface != null)
		{
			Interface.Tick();
		}
	}
}


using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class HudMenuInput : ListComponent<HudMenuInput>
{
	private InputField inputField;

	private RustInput rustInput;

	private TMP_InputField tmpInputField;

	public static bool AnyActive()
	{
		for (int i = 0; i < ListComponent<HudMenuInput>.InstanceList.Count; i++)
		{
			if (ListComponent<HudMenuInput>.InstanceList[i].IsCurrentlyActive())
			{
				return true;
			}
		}
		return false;
	}

	private void Start()
	{
		inputField = ((Component)this).GetComponent<InputField>();
		rustInput = ((Component)this).GetComponent<RustInput>();
		tmpInputField = ((Component)this).GetComponent<TMP_InputField>();
	}

	private bool IsCurrentlyActive()
	{
		if (!((Behaviour)this).enabled)
		{
			return false;
		}
		if ((Object)(object)tmpInputField != (Object)null)
		{
			return tmpInputField.isFocused;
		}
		if ((Object)(object)rustInput != (Object)null)
		{
			return rustInput.IsFocused;
		}
		if ((Object)(object)inputField == (Object)null)
		{
			return false;
		}
		return inputField.isFocused;
	}
}


using UnityEngine;

public class KeyBinding : ListComponent<KeyBinding>
{
	public static bool IsOpen
	{
		get
		{
			for (int i = 0; i < ListComponent<KeyBinding>.InstanceList.Count; i++)
			{
				if (((Behaviour)ListComponent<KeyBinding>.InstanceList[i]).isActiveAndEnabled)
				{
					return true;
				}
			}
			return false;
		}
	}
}


public class NeedsBeltBarSlotInput : ListComponent<NeedsBeltBarSlotInput>
{
	public static bool AnyActive()
	{
		return ListComponent<NeedsBeltBarSlotInput>.InstanceList.Count > 0;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class NeedsKeyboard : ListComponent<NeedsKeyboard>
{
	[Flags]
	public enum BypassOption
	{
		Voice = 1,
		Chat = 4,
		Gesture = 8,
		CardGames = 0x10,
		Movement = 0x20,
		Ping = 0x40,
		Inventory = 0x80,
		Crafting = 0x100,
		Clan = 0x200,
		Contacts = 0x400,
		Attack = 0x800,
		Reload = 0x1000,
		Painting = 0x2000,
		Duck = 0x4000,
		Autorun = 0x8000
	}

	public UnityEvent onNoKeysDown;

	public bool ShowEscapeUI;

	public bool blockUnspecifiedInput = true;

	public BypassOption AllowedBinds;

	private List<string> binds = new List<string>();

	private bool watchForNoKeys;

	public static bool ShouldShowUI
	{
		get
		{
			if (ListComponent<NeedsKeyboard>.InstanceList.Count > 0)
			{
				return ListComponent<NeedsKeyboard>.InstanceList[0].ShowEscapeUI;
			}
			return false;
		}
	}

	private static void GetBindString(BypassOption bypassOption, List<string> resultBinds)
	{
		if ((bypassOption & BypassOption.Voice) == BypassOption.Voice)
		{
			resultBinds.Add("+voice");
		}
		if ((bypassOption & BypassOption.Chat) == BypassOption.Chat)
		{
			resultBinds.Add("chat.open");
		}
		if ((bypassOption & BypassOption.Gesture) == BypassOption.Gesture)
		{
			resultBinds.Add("+gestures");
		}
		if ((bypassOption & BypassOption.Movement) == BypassOption.Movement)
		{
			resultBinds.Add("+left");
			resultBinds.Add("+right");
			resultBinds.Add("+backward");
			resultBinds.Add("+forward");
			resultBinds.Add("+sprint");
			resultBinds.Add("+duck");
			resultBinds.Add("+jump");
		}
		if ((bypassOption & BypassOption.Ping) == BypassOption.Ping)
		{
			resultBinds.Add("+ping");
		}
		if ((bypassOption & BypassOption.Inventory) == BypassOption.Inventory)
		{
			resultBinds.Add("inventory.toggle");
		}
		if ((bypassOption & BypassOption.Crafting) == BypassOption.Crafting)
		{
			resultBinds.Add("inventory.togglecrafting");
		}
		if ((bypassOption & BypassOption.Clan) == BypassOption.Clan)
		{
			resultBinds.Add("clan.toggleclan");
		}
		if ((bypassOption & BypassOption.Contacts) == BypassOption.Contacts)
		{
			resultBinds.Add("uicontacts.togglecontacts");
		}
		if ((bypassOption & BypassOption.Attack) == BypassOption.Attack)
		{
			resultBinds.Add("+attack");
			resultBinds.Add("+attack2");
			resultBinds.Add("+attack3");
		}
		if ((bypassOption & BypassOption.Reload) == BypassOption.Reload)
		{
			resultBinds.Add("+reload");
		}
		if ((bypassOption & BypassOption.Painting) == BypassOption.Painting)
		{
			resultBinds.Add("paint.selectedtool");
			resultBinds.Add("paint.selectedbrush");
			resultBinds.Add("paint.brushsize");
			resultBinds.Add("paint.brushopacity");
		}
	}

	public static bool AnyActive(BypassOption forBypass)
	{
		return AnyActive((KeyCode)0, forBypass);
	}

	public static bool AnyActive(KeyCode key = 0, BypassOption forBypass = (BypassOption)0)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (ListComponent<NeedsKeyboard>.InstanceList.Count == 0)
		{
			return false;
		}
		if ((forBypass & BypassOption.Duck) != BypassOption.Duck && (forBypass & BypassOption.Autorun) != BypassOption.Autorun && AnyTextboxFocused())
		{
			return true;
		}
		Enumerator<NeedsKeyboard> enumerator;
		if ((int)key != 0 || forBypass != 0)
		{
			enumerator = ListComponent<NeedsKeyboard>.InstanceList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					NeedsKeyboard current = enumerator.Current;
					if (current.ShouldBlockInput() && !current.AllowKeyInput(key, forBypass))
					{
						return true;
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
			return false;
		}
		enumerator = ListComponent<NeedsKeyboard>.InstanceList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				NeedsKeyboard current2 = enumerator.Current;
				if (current2.blockUnspecifiedInput && current2.ShouldBlockInput())
				{
					return true;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return false;
	}

	protected override void OnEnable()
	{
		((ListComponent)this).OnEnable();
		watchForNoKeys = true;
		if (AllowedBinds == (BypassOption)0)
		{
			return;
		}
		binds.Clear();
		List<string> list = Pool.Get<List<string>>();
		GetBindString(AllowedBinds, list);
		foreach (string item in list)
		{
			binds.AddRange(Input.GetButtonsWithBind(item, false));
		}
		Pool.FreeUnmanaged<string>(ref list);
	}

	public void Update()
	{
		if (watchForNoKeys && !Input.anyKey)
		{
			watchForNoKeys = false;
			UnityEvent obj = onNoKeysDown;
			if (obj != null)
			{
				obj.Invoke();
			}
		}
	}

	private bool AllowKeyInput(KeyCode k, BypassOption forBypass)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if (AllowedBinds == (BypassOption)0)
		{
			return false;
		}
		if (forBypass != 0 && (forBypass & AllowedBinds) == forBypass)
		{
			return true;
		}
		if (forBypass == (BypassOption)0 && (int)k == 0)
		{
			return false;
		}
		string b = Memoized.KeyCodeToString.Get(k);
		foreach (string bind in binds)
		{
			if (string.Equals(bind, b, StringComparison.OrdinalIgnoreCase))
			{
				return true;
			}
		}
		return false;
	}

	protected virtual bool ShouldBlockInput()
	{
		return true;
	}

	private static bool AnyTextboxFocused()
	{
		EventSystem current = EventSystem.current;
		if ((Object)(object)current != (Object)null)
		{
			GameObject currentSelectedGameObject = current.currentSelectedGameObject;
			if ((Object)(object)currentSelectedGameObject != (Object)null)
			{
				InputField val = default(InputField);
				if (currentSelectedGameObject.TryGetComponent<InputField>(ref val) && !val.readOnly && val.isFocused)
				{
					return true;
				}
				TMP_InputField val2 = default(TMP_InputField);
				if (currentSelectedGameObject.TryGetComponent<TMP_InputField>(ref val2) && !val2.readOnly && val2.isFocused)
				{
					return true;
				}
			}
		}
		return false;
	}
}


public class NeedsKeyboardInputField : NeedsKeyboard
{
}


public class NeedsMouseButtons : ListComponent<NeedsMouseButtons>
{
	public static bool AnyActive()
	{
		return ListComponent<NeedsMouseButtons>.InstanceList.Count > 0;
	}
}


using UnityEngine;

public abstract class BaseEditorExAttribute : PropertyAttribute
{
	public string isTrue;

	public string isFalse;
}


using System;

[AttributeUsage(AttributeTargets.Method)]
public class ButtonAttribute : BaseEditorExAttribute
{
	public string Label;

	public ButtonAttribute(string name)
	{
		Label = name;
	}
}


using System;

[AttributeUsage(AttributeTargets.All)]
public class ComponentHelpAttribute : BaseEditorExAttribute
{
	public string help;

	public ComponentHelpAttribute(string help)
	{
		this.help = help;
	}
}


using UnityEngine;

public class ReadOnlyAttribute : PropertyAttribute
{
}


using System;
using System.Runtime.InteropServices;

public static class FreeImage
{
	public enum Format
	{
		Unknown = -1,
		BMP = 0,
		JPEG = 2,
		PNG = 13,
		TARGA = 17,
		TIFF = 18,
		PSD = 20,
		DDS = 24,
		HDR = 26,
		EXR = 29,
		J2K = 30,
		JP2 = 31,
		WEBP = 35,
		JXR = 36
	}

	public enum SaveFlags
	{
		DEFAULT = 0,
		BMP_SAVE_RLE = 1,
		EXR_FLOAT = 1,
		EXR_NONE = 2,
		EXR_ZIP = 4,
		EXR_PIZ = 8,
		EXR_PXR24 = 16,
		EXR_B44 = 32,
		EXR_LC = 64,
		JPEG_QUALITYSUPERB = 128,
		JPEG_QUALITYGOOD = 256,
		JPEG_QUALITYNORMAL = 512,
		JPEG_QUALITYAVERAGE = 1024,
		JPEG_QUALITYBAD = 2048,
		JPEG_PROGRESSIVE = 8192,
		JPEG_SUBSAMPLING_411 = 4096,
		JPEG_SUBSAMPLING_420 = 16384,
		JPEG_SUBSAMPLING_422 = 32768,
		JPEG_SUBSAMPLING_444 = 65536,
		JPEG_OPTIMIZE = 131072,
		JPEG_BASELINE = 262144,
		PNG_Z_BEST_SPEED = 1,
		PNG_Z_DEFAULT_COMPRESSION = 6,
		PNG_Z_BEST_COMPRESSION = 9,
		PNG_Z_NO_COMPRESSION = 256,
		PNG_INTERLACED = 512,
		PNM_SAVE_ASCII = 1,
		TIFF_CMYK = 1,
		TIFF_PACKBITS = 256,
		TIFF_DEFLATE = 512,
		TIFF_ADOBE_DEFLATE = 1024,
		TIFF_NONE = 2048,
		TIFF_CCITTFAX3 = 4096,
		TIFF_CCITTFAX4 = 8192,
		TIFF_LZW = 16384,
		TIFF_JPEG = 32768
	}

	public enum LoadFlags
	{
		DEFAULT = 0,
		GIF_LOAD256 = 1,
		GIF_PLAYBACK = 2,
		ICO_MAKEALPHA = 1,
		JPEG_FAST = 1,
		JPEG_ACCURATE = 2,
		JPEG_CMYK = 4,
		JPEG_EXIFROTATE = 8,
		PCD_BASE = 1,
		PCD_BASEDIV4 = 2,
		PCD_BASEDIV16 = 3,
		PNG_IGNOREGAMMA = 1,
		TARGA_LOAD_RGB888 = 1,
		TIFF_CMYK = 1,
		RAW_PREVIEW = 1,
		RAW_DISPLAY = 2
	}

	[Serializable]
	public struct Header
	{
		public uint size;

		public int width;

		public int height;

		public ushort planes;

		public ushort bitCount;

		public uint compression;

		public uint sizeImage;

		public int xPelsPerMeter;

		public int yPelsPerMeter;

		public uint clrUsed;

		public uint clrImportant;
	}

	[Serializable]
	public struct Bitmap
	{
		public IntPtr data;

		public static Bitmap Null = new Bitmap
		{
			data = IntPtr.Zero
		};

		public bool IsNull => data == IntPtr.Zero;

		public void Unload()
		{
			FreeImage.Unload(this);
			data = IntPtr.Zero;
		}
	}

	[StructLayout(LayoutKind.Explicit)]
	public struct RGBQuad
	{
		[FieldOffset(0)]
		public byte rgbBlue;

		[FieldOffset(1)]
		public byte rgbGreen;

		[FieldOffset(2)]
		public byte rgbRed;

		[FieldOffset(3)]
		public byte rgbReserved;

		[FieldOffset(0)]
		public uint uintValue;
	}

	public enum Filter
	{
		Box,
		Bicubic,
		Bilinear,
		Bspline,
		CatmullRom,
		Lanczos3
	}

	public const uint FI_RGBA_RED_MASK = 16711680u;

	public const uint FI_RGBA_GREEN_MASK = 65280u;

	public const uint FI_RGBA_BLUE_MASK = 255u;

	public const string FreeImageLibrary = "FreeImage";

	[DllImport("FreeImage", CharSet = CharSet.Ansi, EntryPoint = "FreeImage_GetFIFFromFilename")]
	public static extern Format GetFIFFromFilename(string filename);

	[DllImport("FreeImage", CharSet = CharSet.Ansi, EntryPoint = "FreeImage_Load")]
	public static extern Bitmap Load(Format fif, string filename, LoadFlags flags = LoadFlags.DEFAULT);

	[DllImport("FreeImage", CharSet = CharSet.Ansi, EntryPoint = "FreeImage_Save")]
	public static extern bool Save(Format fif, Bitmap bitmap, string filename, SaveFlags flags = SaveFlags.DEFAULT);

	[DllImport("FreeImage", EntryPoint = "FreeImage_Allocate")]
	public static extern Bitmap Allocate(int width, int height, int bpp, uint red_mask = 16711680u, uint green_mask = 65280u, uint blue_mask = 255u);

	[DllImport("FreeImage", EntryPoint = "FreeImage_Unload")]
	public static extern void Unload(Bitmap bitmap);

	[DllImport("FreeImage", EntryPoint = "FreeImage_GetBits")]
	public static extern IntPtr GetBits(Bitmap bitmap);

	[DllImport("FreeImage", EntryPoint = "FreeImage_GetBPP")]
	public static extern uint GetBPP(Bitmap bitmap);

	[DllImport("FreeImage", EntryPoint = "FreeImage_GetWidth")]
	public static extern uint GetWidth(Bitmap bitmap);

	[DllImport("FreeImage", EntryPoint = "FreeImage_GetHeight")]
	public static extern uint GetHeight(Bitmap bitmap);

	[DllImport("FreeImage", EntryPoint = "FreeImage_GetLine")]
	public static extern uint GetLine(Bitmap bitmap);

	[DllImport("FreeImage", EntryPoint = "FreeImage_GetPitch")]
	public static extern uint GetPitch(Bitmap bitmap);

	[DllImport("FreeImage", EntryPoint = "FreeImage_GetPixelColor")]
	public static extern bool GetPixelColor(Bitmap bitmap, uint x, uint y, out RGBQuad value);

	[DllImport("FreeImage", EntryPoint = "FreeImage_Rescale")]
	public static extern Bitmap Rescale(Bitmap bitmap, int dst_width, int dst_height, Filter filter);

	[DllImport("FreeImage", EntryPoint = "FreeImage_ConvertTo24Bits")]
	public static extern Bitmap ConvertTo24Bits(Bitmap bitmap);

	[DllImport("FreeImage", EntryPoint = "FreeImage_ConvertTo32Bits")]
	public static extern Bitmap ConvertTo32Bits(Bitmap bitmap);
}


using UnityEngine;
using UnityStandardAssets.ImageEffects;

[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("Image Effects/Noise/IsoNoise")]
public class ISONoise : PostEffectsBase
{
	public float monochromeTiling = 64f;

	public FilterMode filterMode = (FilterMode)1;

	public Texture2D noiseTexture;

	public Shader noiseShader;

	private Material noiseMaterial;

	public override bool CheckResources()
	{
		CheckSupport(needDepth: false);
		noiseMaterial = CheckShaderAndCreateMaterial(noiseShader, noiseMaterial);
		if (!isSupported)
		{
			ReportAutoDisable();
		}
		return isSupported;
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (!CheckResources() || (Object)null == (Object)(object)noiseTexture)
		{
			Graphics.Blit((Texture)(object)source, destination);
			if ((Object)null == (Object)(object)noiseTexture)
			{
				Debug.LogWarning((object)"Noise & Grain effect failing as noise texture is not assigned. please assign.", (Object)(object)((Component)this).transform);
			}
			return;
		}
		if (Object.op_Implicit((Object)(object)noiseTexture))
		{
			((Texture)noiseTexture).wrapMode = (TextureWrapMode)0;
			((Texture)noiseTexture).filterMode = filterMode;
		}
		noiseMaterial.SetTexture("_NoiseTex", (Texture)(object)noiseTexture);
		noiseMaterial.SetVector("_NoiseTilingPerChannel", Vector4.op_Implicit(Vector3.one * monochromeTiling));
		DrawNoiseQuadGrid(source, destination, noiseMaterial, noiseTexture, 0);
	}

	private static void DrawNoiseQuadGrid(RenderTexture source, RenderTexture dest, Material fxMaterial, Texture2D noise, int passNr)
	{
		RenderTexture.active = dest;
		float num = (float)((Texture)noise).width * 1f;
		fxMaterial.SetTexture("_MainTex", (Texture)(object)source);
		GL.PushMatrix();
		GL.LoadOrtho();
		float num2 = 1f;
		float num3 = 1f;
		float num4 = (float)((Texture)source).width / 256f;
		fxMaterial.SetPass(passNr);
		GL.Begin(7);
		for (float num5 = 0f; num5 < 1f; num5 += num2)
		{
			for (float num6 = 0f; num6 < 1f; num6 += num3)
			{
				float num7 = Random.Range(0f, 1f);
				float num8 = Random.Range(0f, 1f);
				num7 = Mathf.Floor(num7 * num) / num;
				num8 = Mathf.Floor(num8 * num) / num;
				GL.MultiTexCoord2(0, num7, num8);
				GL.MultiTexCoord2(1, 0f, 0f);
				GL.Vertex3(num5, num6, 0.1f);
				GL.MultiTexCoord2(0, num7 + num4, num8);
				GL.MultiTexCoord2(1, 1f, 0f);
				GL.Vertex3(num5 + num2, num6, 0.1f);
				GL.MultiTexCoord2(0, num7 + num4, num8 + num4);
				GL.MultiTexCoord2(1, 1f, 1f);
				GL.Vertex3(num5 + num2, num6 + num3, 0.1f);
				GL.MultiTexCoord2(0, num7, num8 + num4);
				GL.MultiTexCoord2(1, 0f, 1f);
				GL.Vertex3(num5, num6 + num3, 0.1f);
			}
		}
		GL.End();
		GL.PopMatrix();
	}
}


using UnityEngine;

public interface IImageEffect
{
	bool IsActive();

	void OnRenderImage(RenderTexture source, RenderTexture destination);
}


using UnityEngine;

public class ImageEffectComposite : MonoBehaviour
{
	public RenderTextureFormat format;

	public RenderTextureReadWrite readWrite = (RenderTextureReadWrite)2;
}


public class ImageEffectLayer : FacepunchBehaviour
{
}


using System;
using UnityEngine;

public class ImageEffectRedirect : MonoBehaviour
{
	[NonSerialized]
	public IImageEffect target;

	private void OnRenderImage(RenderTexture src, RenderTexture dst)
	{
		IImageEffect imageEffect = target;
		if (((Behaviour)((imageEffect is Behaviour) ? imageEffect : null)).enabled)
		{
			target.OnRenderImage(src, dst);
		}
		else
		{
			Graphics.Blit((Texture)(object)src, dst);
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Analog TV")]
public class CC_AnalogTV : CC_Base
{
	public float phase = 0.5f;

	public bool grayscale;

	public float noiseIntensity = 0.5f;

	public float scanlinesIntensity = 2f;

	public float scanlinesCount = 768f;

	public float distortion = 0.2f;

	public float cubicDistortion = 0.6f;

	public float scale = 0.8f;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		base.material.SetFloat("_phase", phase);
		base.material.SetFloat("_noiseIntensity", noiseIntensity);
		base.material.SetFloat("_scanlinesIntensity", scanlinesIntensity);
		base.material.SetFloat("_scanlinesCount", (float)(int)scanlinesCount);
		base.material.SetFloat("_distortion", distortion);
		base.material.SetFloat("_cubicDistortion", cubicDistortion);
		base.material.SetFloat("_scale", scale);
		Graphics.Blit((Texture)(object)source, destination, base.material, grayscale ? 1 : 0);
	}
}


using UnityEngine;

[AddComponentMenu("")]
public class CC_Base : MonoBehaviour
{
	public Shader shader;

	protected Material _material;

	protected Material material
	{
		get
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Expected O, but got Unknown
			if ((Object)(object)_material == (Object)null)
			{
				_material = new Material(shader);
				((Object)_material).hideFlags = (HideFlags)61;
			}
			return _material;
		}
	}

	protected virtual void Start()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			((Behaviour)this).enabled = false;
		}
		else if (!Object.op_Implicit((Object)(object)shader) || !shader.isSupported)
		{
			((Behaviour)this).enabled = false;
		}
	}

	protected virtual void OnDisable()
	{
		if (Object.op_Implicit((Object)(object)_material))
		{
			Object.DestroyImmediate((Object)(object)_material);
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Bleach Bypass")]
public class CC_BleachBypass : CC_Base
{
	public float amount = 1f;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (amount == 0f)
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		base.material.SetFloat("_amount", amount);
		Graphics.Blit((Texture)(object)source, destination, base.material);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Blend")]
public class CC_Blend : CC_Base
{
	public Texture texture;

	public float amount = 1f;

	public int mode;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if ((Object)(object)texture == (Object)null || amount == 0f)
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		base.material.SetTexture("_overlayTex", texture);
		base.material.SetFloat("_amount", amount);
		Graphics.Blit((Texture)(object)source, destination, base.material, mode);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Brightness, Contrast, Gamma")]
public class CC_BrightnessContrastGamma : CC_Base
{
	public float redCoeff = 0.5f;

	public float greenCoeff = 0.5f;

	public float blueCoeff = 0.5f;

	public float brightness;

	public float contrast;

	public float gamma = 1f;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (brightness == 0f && contrast == 0f && gamma == 1f)
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		base.material.SetFloat("_rCoeff", redCoeff);
		base.material.SetFloat("_gCoeff", greenCoeff);
		base.material.SetFloat("_bCoeff", blueCoeff);
		base.material.SetFloat("_brightness", (brightness + 100f) * 0.01f);
		base.material.SetFloat("_contrast", (contrast + 100f) * 0.01f);
		base.material.SetFloat("_gamma", 1f / gamma);
		Graphics.Blit((Texture)(object)source, destination, base.material);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Channel Mixer")]
public class CC_ChannelMixer : CC_Base
{
	public float redR = 100f;

	public float redG;

	public float redB;

	public float greenR;

	public float greenG = 100f;

	public float greenB;

	public float blueR;

	public float blueG;

	public float blueB = 100f;

	public float constantR;

	public float constantG;

	public float constantB;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		base.material.SetVector("_red", new Vector4(redR * 0.01f, greenR * 0.01f, blueR * 0.01f));
		base.material.SetVector("_green", new Vector4(redG * 0.01f, greenG * 0.01f, blueG * 0.01f));
		base.material.SetVector("_blue", new Vector4(redB * 0.01f, greenB * 0.01f, blueB * 0.01f));
		base.material.SetVector("_constant", new Vector4(constantR * 0.01f, constantG * 0.01f, constantB * 0.01f));
		Graphics.Blit((Texture)(object)source, destination, base.material);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Convolution Matrix 3x3")]
public class CC_Convolution3x3 : CC_Base
{
	public Vector3 kernelTop = Vector3.zero;

	public Vector3 kernelMiddle = Vector3.up;

	public Vector3 kernelBottom = Vector3.zero;

	public float divisor = 1f;

	public float amount = 1f;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		base.material.SetFloat("_px", 1f / (float)Screen.width);
		base.material.SetFloat("_py", 1f / (float)Screen.height);
		base.material.SetFloat("_amount", amount);
		base.material.SetVector("_kernelT", Vector4.op_Implicit(kernelTop / divisor));
		base.material.SetVector("_kernelM", Vector4.op_Implicit(kernelMiddle / divisor));
		base.material.SetVector("_kernelB", Vector4.op_Implicit(kernelBottom / divisor));
		Graphics.Blit((Texture)(object)source, destination, base.material);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Cross Stitch")]
public class CC_CrossStitch : CC_Base
{
	public int size = 8;

	public float brightness = 1.5f;

	public bool invert;

	public bool pixelize = true;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		base.material.SetFloat("_stitchSize", (float)size);
		base.material.SetFloat("_brightness", brightness);
		int num = (invert ? 1 : 0);
		if (pixelize)
		{
			num += 2;
			base.material.SetFloat("_scale", (float)(((Component)this).GetComponent<Camera>().pixelWidth / size));
			base.material.SetFloat("_ratio", (float)(((Component)this).GetComponent<Camera>().pixelWidth / ((Component)this).GetComponent<Camera>().pixelHeight));
		}
		Graphics.Blit((Texture)(object)source, destination, base.material, num);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Double Vision")]
public class CC_DoubleVision : CC_Base, IImageEffect
{
	public Vector2 displace = new Vector2(0.7f, 0f);

	public float amount = 1f;

	public bool IsActive()
	{
		if (((Behaviour)this).enabled)
		{
			return amount != 0f;
		}
		return false;
	}

	public void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		if (amount == 0f)
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		base.material.SetVector("_displace", Vector4.op_Implicit(new Vector2(displace.x / (float)Screen.width, displace.y / (float)Screen.height)));
		base.material.SetFloat("_amount", amount);
		Graphics.Blit((Texture)(object)source, destination, base.material);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Fast Vignette")]
public class CC_FastVignette : CC_Base
{
	public float sharpness = 10f;

	public float darkness = 30f;

	public bool desaturate;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		base.material.SetFloat("_sharpness", sharpness * 0.01f);
		base.material.SetFloat("_darkness", darkness * 0.02f);
		Graphics.Blit((Texture)(object)source, destination, base.material, desaturate ? 1 : 0);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Frost")]
public class CC_Frost : CC_Base, IImageEffect
{
	public float scale = 1.2f;

	public float sharpness = 40f;

	public float darkness = 35f;

	public bool enableVignette = true;

	public bool IsActive()
	{
		if (((Behaviour)this).enabled)
		{
			return scale != 0f;
		}
		return false;
	}

	public void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (scale == 0f)
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		base.material.SetFloat("_scale", scale);
		base.material.SetFloat("_sharpness", sharpness * 0.01f);
		base.material.SetFloat("_darkness", darkness * 0.02f);
		Graphics.Blit((Texture)(object)source, destination, base.material, enableVignette ? 1 : 0);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Gradient Ramp")]
public class CC_GradientRamp : CC_Base
{
	public Texture rampTexture;

	public float amount = 1f;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if ((Object)(object)rampTexture == (Object)null || amount == 0f)
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		base.material.SetTexture("_RampTex", rampTexture);
		base.material.SetFloat("_amount", amount);
		Graphics.Blit((Texture)(object)source, destination, base.material);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Grayscale")]
public class CC_Grayscale : CC_Base, IImageEffect
{
	public float redLuminance = 0.3f;

	public float greenLuminance = 0.59f;

	public float blueLuminance = 0.11f;

	public float amount = 1f;

	public bool IsActive()
	{
		if (((Behaviour)this).enabled)
		{
			return amount != 0f;
		}
		return false;
	}

	public void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		if (amount == 0f)
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		base.material.SetVector("_data", new Vector4(redLuminance, greenLuminance, blueLuminance, amount));
		Graphics.Blit((Texture)(object)source, destination, base.material);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Halftone")]
public class CC_Halftone : CC_Base
{
	public float density = 64f;

	public int mode = 1;

	public bool antialiasing = true;

	public bool showOriginal;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		base.material.SetFloat("_density", density);
		int num = 0;
		if (mode == 0)
		{
			if (antialiasing && showOriginal)
			{
				num = 3;
			}
			else if (antialiasing)
			{
				num = 1;
			}
			else if (showOriginal)
			{
				num = 2;
			}
		}
		else if (mode == 1)
		{
			num = (antialiasing ? 5 : 4);
		}
		Graphics.Blit((Texture)(object)source, destination, base.material, num);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Hue, Saturation, Value")]
public class CC_HueSaturationValue : CC_Base
{
	public float hue;

	public float saturation;

	public float value;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (hue == 0f && saturation == 0f && value == 0f)
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		base.material.SetFloat("_hue", hue / 360f);
		base.material.SetFloat("_saturation", saturation * 0.01f);
		base.material.SetFloat("_value", value * 0.01f);
		Graphics.Blit((Texture)(object)source, destination, base.material);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/LED")]
public class CC_Led : CC_Base
{
	public float scale = 80f;

	public bool automaticRatio;

	public float ratio = 1f;

	public float brightness = 1f;

	public int mode;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		switch (mode)
		{
		case 0:
			base.material.SetFloat("_scale", scale);
			break;
		default:
			base.material.SetFloat("_scale", (float)((Component)this).GetComponent<Camera>().pixelWidth / scale);
			break;
		}
		base.material.SetFloat("_ratio", automaticRatio ? ((float)(((Component)this).GetComponent<Camera>().pixelWidth / ((Component)this).GetComponent<Camera>().pixelHeight)) : ratio);
		base.material.SetFloat("_brightness", brightness);
		Graphics.Blit((Texture)(object)source, destination, base.material);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Levels")]
public class CC_Levels : CC_Base
{
	public int mode;

	public float inputMinL;

	public float inputMaxL = 255f;

	public float inputGammaL = 1f;

	public float inputMinR;

	public float inputMaxR = 255f;

	public float inputGammaR = 1f;

	public float inputMinG;

	public float inputMaxG = 255f;

	public float inputGammaG = 1f;

	public float inputMinB;

	public float inputMaxB = 255f;

	public float inputGammaB = 1f;

	public float outputMinL;

	public float outputMaxL = 255f;

	public float outputMinR;

	public float outputMaxR = 255f;

	public float outputMinG;

	public float outputMaxG = 255f;

	public float outputMinB;

	public float outputMaxB = 255f;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		if (mode == 0)
		{
			base.material.SetVector("_inputMin", new Vector4(inputMinL / 255f, inputMinL / 255f, inputMinL / 255f, 1f));
			base.material.SetVector("_inputMax", new Vector4(inputMaxL / 255f, inputMaxL / 255f, inputMaxL / 255f, 1f));
			base.material.SetVector("_inputGamma", new Vector4(inputGammaL, inputGammaL, inputGammaL, 1f));
			base.material.SetVector("_outputMin", new Vector4(outputMinL / 255f, outputMinL / 255f, outputMinL / 255f, 1f));
			base.material.SetVector("_outputMax", new Vector4(outputMaxL / 255f, outputMaxL / 255f, outputMaxL / 255f, 1f));
		}
		else
		{
			base.material.SetVector("_inputMin", new Vector4(inputMinR / 255f, inputMinG / 255f, inputMinB / 255f, 1f));
			base.material.SetVector("_inputMax", new Vector4(inputMaxR / 255f, inputMaxG / 255f, inputMaxB / 255f, 1f));
			base.material.SetVector("_inputGamma", new Vector4(inputGammaR, inputGammaG, inputGammaB, 1f));
			base.material.SetVector("_outputMin", new Vector4(outputMinR / 255f, outputMinG / 255f, outputMinB / 255f, 1f));
			base.material.SetVector("_outputMax", new Vector4(outputMaxR / 255f, outputMaxG / 255f, outputMaxB / 255f, 1f));
		}
		Graphics.Blit((Texture)(object)source, destination, base.material);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Lookup Filter (Color Grading)")]
public class CC_LookupFilter : CC_Base
{
	public Texture lookupTexture;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if ((Object)(object)lookupTexture == (Object)null)
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		base.material.SetTexture("_LookupTex", lookupTexture);
		Graphics.Blit((Texture)(object)source, destination, base.material);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Negative")]
public class CC_Negative : CC_Base
{
	public float amount = 1f;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (amount == 0f)
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		base.material.SetFloat("_amount", amount);
		Graphics.Blit((Texture)(object)source, destination, base.material);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Photo Filter")]
public class CC_PhotoFilter : CC_Base, IImageEffect
{
	public Color color = new Color(1f, 0.5f, 0.2f, 1f);

	public float density = 0.35f;

	public bool IsActive()
	{
		if (((Behaviour)this).enabled)
		{
			return density != 0f;
		}
		return false;
	}

	public void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (density == 0f)
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		base.material.SetColor("_rgb", color);
		base.material.SetFloat("_density", density);
		Graphics.Blit((Texture)(object)source, destination, base.material);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Pixelate")]
public class CC_Pixelate : CC_Base
{
	public float scale = 80f;

	public bool automaticRatio;

	public float ratio = 1f;

	public int mode;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		switch (mode)
		{
		case 0:
			base.material.SetFloat("_scale", scale);
			break;
		default:
			base.material.SetFloat("_scale", (float)((Component)this).GetComponent<Camera>().pixelWidth / scale);
			break;
		}
		base.material.SetFloat("_ratio", automaticRatio ? ((float)(((Component)this).GetComponent<Camera>().pixelWidth / ((Component)this).GetComponent<Camera>().pixelHeight)) : ratio);
		Graphics.Blit((Texture)(object)source, destination, base.material);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Posterize")]
public class CC_Posterize : CC_Base
{
	public int levels = 4;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		base.material.SetFloat("_levels", (float)levels);
		Graphics.Blit((Texture)(object)source, destination, base.material);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Radial Blur")]
public class CC_RadialBlur : CC_Base
{
	public float amount = 0.1f;

	public Vector2 center = new Vector2(0.5f, 0.5f);

	public int quality = 1;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		base.material.SetFloat("amount", amount);
		base.material.SetVector("center", Vector4.op_Implicit(center));
		if (amount == 0f)
		{
			Graphics.Blit((Texture)(object)source, destination);
		}
		else
		{
			Graphics.Blit((Texture)(object)source, destination, base.material, quality);
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/RGB Split")]
public class CC_RGBSplit : CC_Base
{
	public float amount;

	public float angle;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (amount == 0f)
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		base.material.SetFloat("_rgbShiftAmount", amount * 0.001f);
		base.material.SetFloat("_rgbShiftAngleCos", Mathf.Cos(angle));
		base.material.SetFloat("_rgbShiftAngleSin", Mathf.Sin(angle));
		Graphics.Blit((Texture)(object)source, destination, base.material);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Sharpen")]
public class CC_Sharpen : CC_Base
{
	public float strength = 0.6f;

	public float clamp = 0.05f;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (strength == 0f)
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		base.material.SetFloat("_px", 1f / (float)Screen.width);
		base.material.SetFloat("_py", 1f / (float)Screen.height);
		base.material.SetFloat("_strength", strength);
		base.material.SetFloat("_clamp", clamp);
		Graphics.Blit((Texture)(object)source, destination, base.material);
	}
}


using UnityEngine;

[AddComponentMenu("Colorful/Sharpen And Vignette")]
public class CC_SharpenAndVignette : CC_Base, IImageEffect
{
	[Header("Sharpen")]
	public bool applySharpen = true;

	[Range(0f, 5f)]
	public float strength = 1f;

	[Range(0f, 1f)]
	public float clamp = 1f;

	[Header("Vignette")]
	public bool applyVignette = true;

	[Range(-100f, 100f)]
	public float sharpness = 45f;

	[Range(0f, 100f)]
	public float darkness = 24f;

	public bool IsActive()
	{
		return ((Behaviour)this).enabled;
	}

	public void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (applySharpen)
		{
			base.material.SetFloat("_px", 1f / (float)Screen.width);
			base.material.SetFloat("_py", 1f / (float)Screen.height);
			base.material.SetFloat("_strength", strength);
			base.material.SetFloat("_clamp", clamp);
		}
		if (applyVignette)
		{
			base.material.SetFloat("_sharpness", sharpness * 0.01f);
			base.material.SetFloat("_darkness", darkness * 0.02f);
		}
		if (applySharpen && !applyVignette)
		{
			Graphics.Blit((Texture)(object)source, destination, base.material, 0);
		}
		else if (applySharpen && applyVignette)
		{
			Graphics.Blit((Texture)(object)source, destination, base.material, 1);
		}
		else if (!applySharpen && applyVignette)
		{
			Graphics.Blit((Texture)(object)source, destination, base.material, 2);
		}
		else
		{
			Graphics.Blit((Texture)(object)source, destination);
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Threshold")]
public class CC_Threshold : CC_Base
{
	public float threshold = 128f;

	public bool useNoise;

	public float noiseRange = 48f;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		base.material.SetFloat("_threshold", threshold / 255f);
		base.material.SetFloat("_range", noiseRange / 255f);
		Graphics.Blit((Texture)(object)source, destination, base.material, useNoise ? 1 : 0);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Vibrance")]
public class CC_Vibrance : CC_Base
{
	public float amount;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (amount == 0f)
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		base.material.SetFloat("_amount", amount * 0.02f);
		Graphics.Blit((Texture)(object)source, destination, base.material);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Colorful/Wiggle")]
public class CC_Wiggle : CC_Base, IImageEffect
{
	public float timer;

	public float speed = 1f;

	public float scale = 12f;

	private void Update()
	{
		timer += speed * Time.deltaTime;
	}

	public bool IsActive()
	{
		if (((Behaviour)this).enabled)
		{
			return scale != 0f;
		}
		return false;
	}

	public void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (scale == 0f)
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		base.material.SetFloat("_timer", timer);
		base.material.SetFloat("_scale", scale);
		Graphics.Blit((Texture)(object)source, destination, base.material);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Lens Dirtiness")]
public class LensDirtiness : MonoBehaviour, IImageEffect
{
	private enum Pass
	{
		Threshold,
		Kawase,
		Compose
	}

	private Shader Shader_Dirtiness;

	private Material Material_Dirtiness;

	private RenderTexture RTT_BloomThreshold;

	private RenderTexture RTT_1;

	private RenderTexture RTT_2;

	private RenderTexture RTT_3;

	private RenderTexture RTT_4;

	private RenderTexture RTT_Bloom_1;

	private RenderTexture RTT_Bloom_2;

	private int ScreenX = 1280;

	private int ScreenY = 720;

	public bool ShowScreenControls;

	public bool SceneTintsBloom = true;

	public Texture2D DirtinessTexture;

	public float gain = 1f;

	public float threshold = 1f;

	public float BloomSize = 5f;

	public float Dirtiness = 1f;

	public Color BloomColor = Color.white;

	private void OnEnable()
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Expected O, but got Unknown
		Shader_Dirtiness = Shader.Find("Hidden/LensDirtiness");
		if ((Object)(object)Shader_Dirtiness == (Object)null)
		{
			Debug.Log((object)"#ERROR# Hidden/LensDirtiness Shader not found");
		}
		Material_Dirtiness = new Material(Shader_Dirtiness);
		((Object)Material_Dirtiness).hideFlags = (HideFlags)61;
		SetKeyword();
	}

	private void SetKeyword()
	{
		if (Object.op_Implicit((Object)(object)Material_Dirtiness))
		{
			KeywordUtil.EnsureKeywordState(Material_Dirtiness, "_SCENE_TINTS_BLOOM", SceneTintsBloom);
		}
	}

	public bool IsActive()
	{
		return ((Behaviour)this).enabled;
	}

	public void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0359: Unknown result type (might be due to invalid IL or missing references)
		RenderTextureFormat format = source.format;
		ScreenX = ((Texture)source).width;
		ScreenY = ((Texture)source).height;
		Material_Dirtiness.SetFloat("_Gain", gain);
		Material_Dirtiness.SetFloat("_Threshold", threshold);
		RTT_BloomThreshold = RenderTexture.GetTemporary(ScreenX / 2, ScreenY / 2, 0, format);
		((Object)RTT_BloomThreshold).name = "RTT_BloomThreshold";
		Graphics.Blit((Texture)(object)source, RTT_BloomThreshold, Material_Dirtiness, 0);
		Material_Dirtiness.SetVector("_Offset", new Vector4(1f / (float)ScreenX, 1f / (float)ScreenY, 0f, 0f) * 2f);
		RTT_1 = RenderTexture.GetTemporary(ScreenX / 2, ScreenY / 2, 0, format);
		Graphics.Blit((Texture)(object)RTT_BloomThreshold, RTT_1, Material_Dirtiness, 1);
		RenderTexture.ReleaseTemporary(RTT_BloomThreshold);
		RTT_2 = RenderTexture.GetTemporary(ScreenX / 4, ScreenY / 4, 0, format);
		Graphics.Blit((Texture)(object)RTT_1, RTT_2, Material_Dirtiness, 1);
		RenderTexture.ReleaseTemporary(RTT_1);
		RTT_3 = RenderTexture.GetTemporary(ScreenX / 8, ScreenY / 8, 0, format);
		Graphics.Blit((Texture)(object)RTT_2, RTT_3, Material_Dirtiness, 1);
		RenderTexture.ReleaseTemporary(RTT_2);
		RTT_4 = RenderTexture.GetTemporary(ScreenX / 16, ScreenY / 16, 0, format);
		Graphics.Blit((Texture)(object)RTT_3, RTT_4, Material_Dirtiness, 1);
		RenderTexture.ReleaseTemporary(RTT_3);
		((Object)RTT_1).name = "RTT_1";
		((Object)RTT_2).name = "RTT_2";
		((Object)RTT_3).name = "RTT_3";
		((Object)RTT_4).name = "RTT_4";
		RTT_Bloom_1 = RenderTexture.GetTemporary(ScreenX / 16, ScreenY / 16, 0, format);
		((Object)RTT_Bloom_1).name = "RTT_Bloom_1";
		RTT_Bloom_2 = RenderTexture.GetTemporary(ScreenX / 16, ScreenY / 16, 0, format);
		((Object)RTT_Bloom_2).name = "RTT_Bloom_2";
		Graphics.Blit((Texture)(object)RTT_4, RTT_Bloom_1);
		RenderTexture.ReleaseTemporary(RTT_4);
		for (int i = 1; i <= 8; i++)
		{
			float num = BloomSize * (float)i / (float)ScreenX;
			float num2 = BloomSize * (float)i / (float)ScreenY;
			Material_Dirtiness.SetVector("_Offset", new Vector4(num, num2, 0f, 0f));
			Graphics.Blit((Texture)(object)RTT_Bloom_1, RTT_Bloom_2, Material_Dirtiness, 1);
			Graphics.Blit((Texture)(object)RTT_Bloom_2, RTT_Bloom_1, Material_Dirtiness, 1);
		}
		RenderTexture.ReleaseTemporary(RTT_Bloom_1);
		RenderTexture.ReleaseTemporary(RTT_Bloom_2);
		Material_Dirtiness.SetTexture("_Bloom", (Texture)(object)RTT_Bloom_2);
		Material_Dirtiness.SetFloat("_Dirtiness", Dirtiness);
		Material_Dirtiness.SetColor("_BloomColor", BloomColor);
		Material_Dirtiness.SetTexture("_DirtinessTexture", (Texture)(object)DirtinessTexture);
		Graphics.Blit((Texture)(object)source, destination, Material_Dirtiness, 2);
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class ParticleScaler : MonoBehaviour
{
	public float particleScale = 1f;

	public bool alsoScaleGameobject = true;

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void ScaleShurikenSystems(float scaleFactor)
	{
	}

	private void ScaleLegacySystems(float scaleFactor)
	{
	}

	private void ScaleTrailRenderers(float scaleFactor)
	{
		TrailRenderer[] componentsInChildren = ((Component)this).GetComponentsInChildren<TrailRenderer>();
		foreach (TrailRenderer obj in componentsInChildren)
		{
			obj.startWidth *= scaleFactor;
			obj.endWidth *= scaleFactor;
		}
	}
}


using UnityEngine;
using UnityStandardAssets.ImageEffects;

[ExecuteInEditMode]
public class ScreenOverlayEx : PostEffectsBase, IImageEffect
{
	public enum OverlayBlendMode
	{
		Additive,
		ScreenBlend,
		Multiply,
		Overlay,
		AlphaBlend
	}

	public OverlayBlendMode blendMode = OverlayBlendMode.Overlay;

	public float intensity = 1f;

	public Texture texture;

	public Texture normals;

	public Shader overlayShader;

	private Material overlayMaterial;

	public override bool CheckResources()
	{
		CheckSupport(needDepth: false);
		overlayMaterial = CheckShaderAndCreateMaterial(overlayShader, overlayMaterial);
		if (!isSupported)
		{
			ReportAutoDisable();
		}
		return isSupported;
	}

	public bool IsActive()
	{
		if (((Behaviour)this).enabled)
		{
			return CheckResources();
		}
		return false;
	}

	public void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		if (!CheckResources())
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		Vector4 val = default(Vector4);
		((Vector4)(ref val))..ctor(1f, 0f, 0f, 1f);
		overlayMaterial.SetVector("_UV_Transform", val);
		overlayMaterial.SetFloat("_Intensity", intensity);
		if (Object.op_Implicit((Object)(object)TOD_Sky.Instance))
		{
			overlayMaterial.SetVector("_LightDir", Vector4.op_Implicit(((Component)this).transform.InverseTransformDirection(TOD_Sky.Instance.LightDirection)));
			overlayMaterial.SetColor("_LightCol", TOD_Sky.Instance.LightColor * TOD_Sky.Instance.LightIntensity);
		}
		if (Object.op_Implicit((Object)(object)texture))
		{
			overlayMaterial.SetTexture("_Overlay", texture);
		}
		if (Object.op_Implicit((Object)(object)normals))
		{
			overlayMaterial.SetTexture("_Normals", normals);
		}
		Graphics.Blit((Texture)(object)source, destination, overlayMaterial, (int)blendMode);
	}
}


using System;
using UnityEngine;

public class TOD_Animation : MonoBehaviour
{
	[Tooltip("How much to move the clouds when the camera moves.")]
	[TOD_Min(0f)]
	public float CameraMovement = 1f;

	[Tooltip("Wind direction in degrees.")]
	[TOD_Range(0f, 360f)]
	public float WindDegrees;

	[Tooltip("Speed of the wind that is acting on the clouds.")]
	[TOD_Min(0f)]
	public float WindSpeed = 1f;

	private TOD_Sky sky;

	public Vector3 CloudUV { get; set; }

	public Vector3 OffsetUV
	{
		get
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = ((Component)this).transform.position * (CameraMovement * 0.0001f);
			Quaternion rotation = ((Component)this).transform.rotation;
			return Quaternion.Euler(0f, 0f - ((Quaternion)(ref rotation)).eulerAngles.y, 0f) * val;
		}
	}

	protected void Start()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		sky = ((Component)this).GetComponent<TOD_Sky>();
		CloudUV = new Vector3(Random.value, Random.value, Random.value);
	}

	public void Update()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Sin((float)Math.PI / 180f * WindDegrees);
		float num2 = Mathf.Cos((float)Math.PI / 180f * WindDegrees);
		float num3 = 0.001f * Time.deltaTime;
		float num4 = WindSpeed * num3;
		float x = CloudUV.x;
		float y = CloudUV.y;
		float z = CloudUV.z;
		y += num3 * 0.1f;
		x -= num4 * num;
		z -= num4 * num2;
		x -= Mathf.Floor(x);
		y -= Mathf.Floor(y);
		z -= Mathf.Floor(z);
		CloudUV = new Vector3(x, y, z);
		sky.Components.BillboardTransform.localRotation = Quaternion.Euler(0f, y * 360f, 0f);
	}
}


using System;
using UnityEngine;

[AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
public class TOD_MinAttribute : PropertyAttribute
{
	public float min;

	public TOD_MinAttribute(float min)
	{
		this.min = min;
	}
}


using System;
using UnityEngine;

[AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
public class TOD_MaxAttribute : PropertyAttribute
{
	public float max;

	public TOD_MaxAttribute(float max)
	{
		this.max = max;
	}
}


using System;
using UnityEngine;

[AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
public class TOD_RangeAttribute : PropertyAttribute
{
	public float min;

	public float max;

	public TOD_RangeAttribute(float min, float max)
	{
		this.min = min;
		this.max = max;
	}
}


using UnityEngine;

public class TOD_Billboard : MonoBehaviour
{
	public float Altitude;

	public float Azimuth;

	public float Distance = 1f;

	public float Size = 1f;

	private T GetComponentInParents<T>() where T : Component
	{
		Transform val = ((Component)this).transform;
		T component = ((Component)val).GetComponent<T>();
		while ((Object)(object)component == (Object)null && (Object)(object)val.parent != (Object)null)
		{
			val = val.parent;
			component = ((Component)val).GetComponent<T>();
		}
		return component;
	}
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("Time of Day/Camera Main Script")]
public class TOD_Camera : MonoBehaviour
{
	public TOD_Sky sky;

	public bool DomePosToCamera = true;

	public Vector3 DomePosOffset = Vector3.zero;

	public bool DomeScaleToFarClip = true;

	public float DomeScaleFactor = 0.95f;

	private Camera cameraComponent;

	private Transform cameraTransform;

	public bool HDR
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)cameraComponent))
			{
				return false;
			}
			return cameraComponent.allowHDR;
		}
	}

	public float NearClipPlane
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)cameraComponent))
			{
				return 0.1f;
			}
			return cameraComponent.nearClipPlane;
		}
	}

	public float FarClipPlane
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)cameraComponent))
			{
				return 1000f;
			}
			return cameraComponent.farClipPlane;
		}
	}

	public Color BackgroundColor
	{
		get
		{
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			if (!Object.op_Implicit((Object)(object)cameraComponent))
			{
				return Color.black;
			}
			return cameraComponent.backgroundColor;
		}
	}

	protected void OnValidate()
	{
		DomeScaleFactor = Mathf.Clamp(DomeScaleFactor, 0.01f, 1f);
	}

	protected void OnEnable()
	{
		cameraComponent = ((Component)this).GetComponent<Camera>();
		cameraTransform = ((Component)this).GetComponent<Transform>();
		if (!Object.op_Implicit((Object)(object)sky))
		{
			sky = FindSky(fallback: true);
		}
	}

	protected void Update()
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Invalid comparison between Unknown and I4
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)sky))
		{
			sky = FindSky();
		}
		if (Object.op_Implicit((Object)(object)sky) && sky.Initialized)
		{
			sky.Components.Camera = this;
			if ((int)cameraComponent.clearFlags != 2)
			{
				cameraComponent.clearFlags = (CameraClearFlags)2;
			}
			if (cameraComponent.backgroundColor != Color.clear)
			{
				cameraComponent.backgroundColor = Color.clear;
			}
			if ((Object)(object)RenderSettings.skybox != (Object)(object)sky.Resources.Skybox)
			{
				RenderSettings.skybox = sky.Resources.Skybox;
				DynamicGI.UpdateEnvironment();
			}
		}
	}

	protected void OnPreCull()
	{
		if (!Object.op_Implicit((Object)(object)sky))
		{
			sky = FindSky();
		}
		if (Object.op_Implicit((Object)(object)sky) && sky.Initialized)
		{
			if (DomeScaleToFarClip)
			{
				DoDomeScaleToFarClip();
			}
			if (DomePosToCamera)
			{
				DoDomePosToCamera();
			}
		}
	}

	private TOD_Sky FindSky(bool fallback = false)
	{
		if (Object.op_Implicit((Object)(object)TOD_Sky.Instance))
		{
			return TOD_Sky.Instance;
		}
		if (fallback)
		{
			return Object.FindObjectOfType(typeof(TOD_Sky)) as TOD_Sky;
		}
		return null;
	}

	public void DoDomeScaleToFarClip()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		float num = DomeScaleFactor * cameraComponent.farClipPlane;
		Vector3 localScale = default(Vector3);
		((Vector3)(ref localScale))..ctor(num, num, num);
		sky.Components.DomeTransform.localScale = localScale;
	}

	public void DoDomePosToCamera()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = cameraTransform.position + cameraTransform.rotation * DomePosOffset;
		sky.Components.DomeTransform.position = position;
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class TOD_Components : MonoBehaviour
{
	public GameObject Space;

	public GameObject Stars;

	public GameObject Sun;

	public GameObject Moon;

	public GameObject Atmosphere;

	public GameObject Clear;

	public GameObject Clouds;

	public GameObject VClouds;

	public GameObject ForegroundFog;

	public GameObject Billboards;

	public GameObject Light;

	public Transform DomeTransform { get; set; }

	public Transform SpaceTransform { get; set; }

	public Transform StarTransform { get; set; }

	public Transform SunTransform { get; set; }

	public Transform MoonTransform { get; set; }

	public Transform AtmosphereTransform { get; set; }

	public Transform ClearTransform { get; set; }

	public Transform CloudTransform { get; set; }

	public Transform BillboardTransform { get; set; }

	public Transform LightTransform { get; set; }

	public Renderer SpaceRenderer { get; set; }

	public Renderer StarRenderer { get; set; }

	public Renderer SunRenderer { get; set; }

	public Renderer MoonRenderer { get; set; }

	public Renderer AtmosphereRenderer { get; set; }

	public Renderer ClearRenderer { get; set; }

	public Renderer CloudRenderer { get; set; }

	public Renderer VCloudsRenderer { get; set; }

	public Renderer ForegroundFogRenderer { get; set; }

	public Renderer[] BillboardRenderers { get; set; }

	public MeshFilter SpaceMeshFilter { get; set; }

	public MeshFilter StarMeshFilter { get; set; }

	public MeshFilter SunMeshFilter { get; set; }

	public MeshFilter MoonMeshFilter { get; set; }

	public MeshFilter AtmosphereMeshFilter { get; set; }

	public MeshFilter ClearMeshFilter { get; set; }

	public MeshFilter CloudMeshFilter { get; set; }

	public MeshFilter VCloudsMeshFilter { get; set; }

	public MeshFilter[] BillboardMeshFilters { get; set; }

	public Material SpaceMaterial { get; set; }

	public Material StarMaterial { get; set; }

	public Material SunMaterial { get; set; }

	public Material MoonMaterial { get; set; }

	public Material AtmosphereMaterial { get; set; }

	public Material ClearMaterial { get; set; }

	public Material CloudMaterial { get; set; }

	public Material VCloudsMaterial { get; set; }

	public Material[] BillboardMaterials { get; set; }

	public Light LightSource { get; set; }

	public TOD_Sky Sky { get; set; }

	public TOD_Animation Animation { get; set; }

	public TOD_Time Time { get; set; }

	public TOD_Camera Camera { get; set; }

	public TOD_Rays Rays { get; set; }

	public TOD_Scattering Scattering { get; set; }

	public TOD_Shadows Shadows { get; set; }

	public void Initialize()
	{
		DomeTransform = ((Component)this).GetComponent<Transform>();
		Sky = ((Component)this).GetComponent<TOD_Sky>();
		Animation = ((Component)this).GetComponent<TOD_Animation>();
		Time = ((Component)this).GetComponent<TOD_Time>();
		if (Object.op_Implicit((Object)(object)Space))
		{
			SpaceTransform = Space.GetComponent<Transform>();
			SpaceRenderer = Space.GetComponent<Renderer>();
			SpaceMeshFilter = Space.GetComponent<MeshFilter>();
			SpaceMaterial = SpaceRenderer.sharedMaterial;
		}
		if (Object.op_Implicit((Object)(object)Stars))
		{
			StarTransform = Stars.GetComponent<Transform>();
			StarRenderer = Stars.GetComponent<Renderer>();
			StarMeshFilter = Stars.GetComponent<MeshFilter>();
			StarMaterial = StarRenderer.sharedMaterial;
		}
		if (Object.op_Implicit((Object)(object)Sun))
		{
			SunTransform = Sun.GetComponent<Transform>();
			SunRenderer = Sun.GetComponent<Renderer>();
			SunMeshFilter = Sun.GetComponent<MeshFilter>();
			SunMaterial = SunRenderer.sharedMaterial;
		}
		if (Object.op_Implicit((Object)(object)Moon))
		{
			MoonTransform = Moon.GetComponent<Transform>();
			MoonRenderer = Moon.GetComponent<Renderer>();
			MoonMeshFilter = Moon.GetComponent<MeshFilter>();
			MoonMaterial = MoonRenderer.sharedMaterial;
		}
		if (Object.op_Implicit((Object)(object)Atmosphere))
		{
			AtmosphereTransform = Atmosphere.GetComponent<Transform>();
			AtmosphereRenderer = Atmosphere.GetComponent<Renderer>();
			AtmosphereMeshFilter = Atmosphere.GetComponent<MeshFilter>();
			AtmosphereMaterial = AtmosphereRenderer.sharedMaterial;
		}
		if (Object.op_Implicit((Object)(object)Clear))
		{
			ClearTransform = Clear.GetComponent<Transform>();
			ClearRenderer = Clear.GetComponent<Renderer>();
			ClearMeshFilter = Clear.GetComponent<MeshFilter>();
			ClearMaterial = ClearRenderer.sharedMaterial;
		}
		if (Object.op_Implicit((Object)(object)Clouds))
		{
			CloudTransform = Clouds.GetComponent<Transform>();
			CloudRenderer = Clouds.GetComponent<Renderer>();
			CloudMeshFilter = Clouds.GetComponent<MeshFilter>();
			CloudMaterial = CloudRenderer.sharedMaterial;
		}
		if (Object.op_Implicit((Object)(object)VClouds))
		{
			VCloudsMeshFilter = VClouds.GetComponent<MeshFilter>();
			VCloudsRenderer = (Renderer)(object)VClouds.GetComponent<MeshRenderer>();
			VCloudsMaterial = VCloudsRenderer.sharedMaterial;
		}
		if (Object.op_Implicit((Object)(object)ForegroundFog))
		{
			ForegroundFogRenderer = (Renderer)(object)ForegroundFog.GetComponent<MeshRenderer>();
		}
		if (Object.op_Implicit((Object)(object)Billboards))
		{
			BillboardTransform = Billboards.GetComponent<Transform>();
			BillboardRenderers = Billboards.GetComponentsInChildren<Renderer>();
			BillboardMeshFilters = Billboards.GetComponentsInChildren<MeshFilter>();
			BillboardMaterials = (Material[])(object)new Material[BillboardRenderers.Length];
			for (int i = 0; i < BillboardRenderers.Length; i++)
			{
				BillboardMaterials[i] = BillboardRenderers[i].sharedMaterial;
			}
		}
		if (Object.op_Implicit((Object)(object)Light))
		{
			LightTransform = Light.GetComponent<Transform>();
			LightSource = Light.GetComponent<Light>();
		}
	}
}


public enum TOD_MoonPositionType
{
	OppositeToSun,
	Realistic
}


public enum TOD_StarsPositionType
{
	Static,
	Rotating
}


public enum TOD_FogType
{
	None,
	Atmosphere,
	Directional,
	Gradient
}


public enum TOD_AmbientType
{
	None,
	Color,
	Gradient,
	Spherical
}


public enum TOD_ReflectionType
{
	None,
	Cubemap
}


public enum TOD_ColorSpaceType
{
	Auto,
	Linear,
	Gamma
}


public enum TOD_ColorRangeType
{
	Auto,
	HDR,
	LDR
}


public enum TOD_ColorOutputType
{
	Raw,
	Dithered
}


public enum TOD_CloudQualityType
{
	Low,
	Medium,
	High
}


public enum TOD_MeshQualityType
{
	Low,
	Medium,
	High
}


public enum TOD_StarQualityType
{
	Low,
	Medium,
	High
}


public enum TOD_SkyQualityType
{
	PerVertex,
	PerPixel
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
public abstract class TOD_ImageEffect : MonoBehaviour
{
	public enum ResolutionType
	{
		Low,
		Normal,
		High
	}

	public TOD_Sky sky;

	protected Camera cam;

	private bool supportsDepth;

	private bool supportsHdr;

	private static Vector3[] frustumCornersArray = (Vector3[])(object)new Vector3[4];

	protected Material CreateMaterial(Shader shader)
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Expected O, but got Unknown
		if (!Object.op_Implicit((Object)(object)shader))
		{
			Debug.Log((object)("Missing shader in " + ((object)this).ToString()));
			((Behaviour)this).enabled = false;
			return null;
		}
		if (!shader.isSupported)
		{
			Debug.LogError((object)("The shader " + ((object)shader).ToString() + " on effect " + ((object)this).ToString() + " is not supported on this platform!"));
			((Behaviour)this).enabled = false;
			return null;
		}
		return new Material(shader)
		{
			hideFlags = (HideFlags)52
		};
	}

	private TOD_Sky FindSky(bool fallback = false)
	{
		if (Object.op_Implicit((Object)(object)TOD_Sky.Instance))
		{
			return TOD_Sky.Instance;
		}
		if (fallback)
		{
			return Object.FindObjectOfType(typeof(TOD_Sky)) as TOD_Sky;
		}
		return null;
	}

	protected void Awake()
	{
		if (!Object.op_Implicit((Object)(object)cam))
		{
			cam = ((Component)this).GetComponent<Camera>();
		}
		if (!Object.op_Implicit((Object)(object)sky))
		{
			sky = FindSky(fallback: true);
		}
		supportsDepth = SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)1);
		supportsHdr = SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)2);
	}

	protected bool CheckSupport(bool needDepth = false, bool needHdr = false)
	{
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)cam))
		{
			cam = ((Component)this).GetComponent<Camera>();
		}
		if (!Object.op_Implicit((Object)(object)cam))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)sky))
		{
			sky = FindSky();
		}
		if (!Object.op_Implicit((Object)(object)sky) || !sky.Initialized)
		{
			return false;
		}
		if (!SystemInfo.supportsImageEffects)
		{
			Debug.LogWarning((object)("The image effect " + ((object)this).ToString() + " has been disabled as it's not supported on the current platform."));
			((Behaviour)this).enabled = false;
			return false;
		}
		if (needDepth && !supportsDepth)
		{
			Debug.LogWarning((object)("The image effect " + ((object)this).ToString() + " has been disabled as it requires a depth texture."));
			((Behaviour)this).enabled = false;
			return false;
		}
		if (needHdr && !supportsHdr)
		{
			Debug.LogWarning((object)("The image effect " + ((object)this).ToString() + " has been disabled as it requires HDR."));
			((Behaviour)this).enabled = false;
			return false;
		}
		if (needDepth)
		{
			Camera obj = cam;
			obj.depthTextureMode = (DepthTextureMode)(obj.depthTextureMode | 1);
		}
		if (needHdr)
		{
			cam.allowHDR = true;
		}
		return true;
	}

	protected void DrawBorder(RenderTexture dest, Material material)
	{
		RenderTexture.active = dest;
		bool flag = true;
		GL.PushMatrix();
		GL.LoadOrtho();
		for (int i = 0; i < material.passCount; i++)
		{
			material.SetPass(i);
			float num;
			float num2;
			if (flag)
			{
				num = 1f;
				num2 = 0f;
			}
			else
			{
				num = 0f;
				num2 = 1f;
			}
			float num3 = 0f + 1f / ((float)((Texture)dest).width * 1f);
			float num4 = 0f;
			float num5 = 1f;
			GL.Begin(7);
			GL.TexCoord2(0f, num);
			GL.Vertex3(0f, num4, 0.1f);
			GL.TexCoord2(1f, num);
			GL.Vertex3(num3, num4, 0.1f);
			GL.TexCoord2(1f, num2);
			GL.Vertex3(num3, num5, 0.1f);
			GL.TexCoord2(0f, num2);
			GL.Vertex3(0f, num5, 0.1f);
			float num6 = 1f - 1f / ((float)((Texture)dest).width * 1f);
			num3 = 1f;
			num4 = 0f;
			num5 = 1f;
			GL.TexCoord2(0f, num);
			GL.Vertex3(num6, num4, 0.1f);
			GL.TexCoord2(1f, num);
			GL.Vertex3(num3, num4, 0.1f);
			GL.TexCoord2(1f, num2);
			GL.Vertex3(num3, num5, 0.1f);
			GL.TexCoord2(0f, num2);
			GL.Vertex3(num6, num5, 0.1f);
			num3 = 1f;
			num4 = 0f;
			num5 = 0f + 1f / ((float)((Texture)dest).height * 1f);
			GL.TexCoord2(0f, num);
			GL.Vertex3(0f, num4, 0.1f);
			GL.TexCoord2(1f, num);
			GL.Vertex3(num3, num4, 0.1f);
			GL.TexCoord2(1f, num2);
			GL.Vertex3(num3, num5, 0.1f);
			GL.TexCoord2(0f, num2);
			GL.Vertex3(0f, num5, 0.1f);
			num3 = 1f;
			num4 = 1f - 1f / ((float)((Texture)dest).height * 1f);
			num5 = 1f;
			GL.TexCoord2(0f, num);
			GL.Vertex3(0f, num4, 0.1f);
			GL.TexCoord2(1f, num);
			GL.Vertex3(num3, num4, 0.1f);
			GL.TexCoord2(1f, num2);
			GL.Vertex3(num3, num5, 0.1f);
			GL.TexCoord2(0f, num2);
			GL.Vertex3(0f, num5, 0.1f);
			GL.End();
		}
		GL.PopMatrix();
	}

	protected Matrix4x4 FrustumCorners()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		cam.CalculateFrustumCorners(new Rect(0f, 0f, 1f, 1f), cam.farClipPlane, cam.stereoActiveEye, frustumCornersArray);
		Vector3 val = ((Component)cam).transform.TransformVector(frustumCornersArray[0]);
		Vector3 val2 = ((Component)cam).transform.TransformVector(frustumCornersArray[1]);
		Vector3 val3 = ((Component)cam).transform.TransformVector(frustumCornersArray[2]);
		Vector3 val4 = ((Component)cam).transform.TransformVector(frustumCornersArray[3]);
		Matrix4x4 identity = Matrix4x4.identity;
		((Matrix4x4)(ref identity)).SetRow(0, Vector4.op_Implicit(val));
		((Matrix4x4)(ref identity)).SetRow(1, Vector4.op_Implicit(val4));
		((Matrix4x4)(ref identity)).SetRow(2, Vector4.op_Implicit(val2));
		((Matrix4x4)(ref identity)).SetRow(3, Vector4.op_Implicit(val3));
		return identity;
	}

	protected Vector3i GetSkyMaskSize(RenderTexture source, ResolutionType resolution)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		int num;
		int num2;
		int num3;
		switch (resolution)
		{
		case ResolutionType.High:
			num = ((Texture)source).width;
			num2 = ((Texture)source).height;
			num3 = 0;
			break;
		case ResolutionType.Normal:
			num = ((Texture)source).width / 2;
			num2 = ((Texture)source).height / 2;
			num3 = 0;
			break;
		default:
			num = ((Texture)source).width / 4;
			num2 = ((Texture)source).height / 4;
			num3 = 0;
			break;
		}
		return new Vector3i(num, num2, num3);
	}

	protected RenderTexture GetSkyMask(RenderTexture source, Material skyMaskMaterial, Material screenClearMaterial, ResolutionType resolution, Vector3 lightPos, int blurIterations, float blurRadius, float maxRadius)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Invalid comparison between Unknown and I4
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		Vector3i skyMaskSize = GetSkyMaskSize(source, resolution);
		int x = skyMaskSize.x;
		int y = skyMaskSize.y;
		int z = skyMaskSize.z;
		RenderTexture temporary = RenderTexture.GetTemporary(x, y, z);
		RenderTexture val = null;
		skyMaskMaterial.SetVector("_BlurRadius4", new Vector4(1f, 1f, 0f, 0f) * blurRadius);
		skyMaskMaterial.SetVector("_LightPosition", new Vector4(lightPos.x, lightPos.y, lightPos.z, maxRadius));
		if ((cam.depthTextureMode & 1) != 0)
		{
			Graphics.Blit((Texture)(object)source, temporary, skyMaskMaterial, 1);
		}
		else
		{
			Graphics.Blit((Texture)(object)source, temporary, skyMaskMaterial, 2);
		}
		if ((int)cam.stereoActiveEye == 2)
		{
			DrawBorder(temporary, screenClearMaterial);
		}
		float num = blurRadius * 0.0013020834f;
		skyMaskMaterial.SetVector("_BlurRadius4", new Vector4(num, num, 0f, 0f));
		skyMaskMaterial.SetVector("_LightPosition", new Vector4(lightPos.x, lightPos.y, lightPos.z, maxRadius));
		for (int i = 0; i < blurIterations; i++)
		{
			val = RenderTexture.GetTemporary(x, y, z);
			Graphics.Blit((Texture)(object)temporary, val, skyMaskMaterial, 0);
			RenderTexture.ReleaseTemporary(temporary);
			num = blurRadius * (((float)i * 2f + 1f) * 6f) / 768f;
			skyMaskMaterial.SetVector("_BlurRadius4", new Vector4(num, num, 0f, 0f));
			temporary = RenderTexture.GetTemporary(x, y, z);
			Graphics.Blit((Texture)(object)val, temporary, skyMaskMaterial, 0);
			RenderTexture.ReleaseTemporary(val);
			num = blurRadius * (((float)i * 2f + 2f) * 6f) / 768f;
			skyMaskMaterial.SetVector("_BlurRadius4", new Vector4(num, num, 0f, 0f));
		}
		return temporary;
	}
}


using System;

[Serializable]
public class TOD_Parameters
{
	public TOD_CycleParameters Cycle;

	public TOD_WorldParameters World;

	public TOD_AtmosphereParameters Atmosphere;

	public TOD_DayParameters Day;

	public TOD_NightParameters Night;

	public TOD_SunParameters Sun;

	public TOD_MoonParameters Moon;

	public TOD_LightParameters Light;

	public TOD_StarParameters Stars;

	public TOD_CloudParameters Clouds;

	public TOD_FogParameters Fog;

	public TOD_AmbientParameters Ambient;

	public TOD_ReflectionParameters Reflection;

	public TOD_Parameters()
	{
	}

	public TOD_Parameters(TOD_Sky sky)
	{
		Cycle = sky.Cycle;
		World = sky.World;
		Atmosphere = sky.Atmosphere;
		Day = sky.Day;
		Night = sky.Night;
		Sun = sky.Sun;
		Moon = sky.Moon;
		Light = sky.Light;
		Stars = sky.Stars;
		Clouds = sky.Clouds;
		Fog = sky.Fog;
		Ambient = sky.Ambient;
		Reflection = sky.Reflection;
	}

	public void ToSky(TOD_Sky sky)
	{
		sky.Cycle = Cycle;
		sky.World = World;
		sky.Atmosphere = Atmosphere;
		sky.Day = Day;
		sky.Night = Night;
		sky.Sun = Sun;
		sky.Moon = Moon;
		sky.Light = Light;
		sky.Stars = Stars;
		sky.Clouds = Clouds;
		sky.Fog = Fog;
		sky.Ambient = Ambient;
		sky.Reflection = Reflection;
	}
}


using System;
using UnityEngine;

[Serializable]
public class TOD_CycleParameters
{
	[Tooltip("Current hour of the day.")]
	public float Hour = 12f;

	[Tooltip("Current day of the month.")]
	public int Day = 15;

	[Tooltip("Current month of the year.")]
	public int Month = 6;

	[Tooltip("Current year.")]
	[TOD_Range(1f, 9999f)]
	public int Year = 2000;

	public float RedMoonLerp;

	public DateTime DateTime
	{
		get
		{
			DateTime result = new DateTime(0L, DateTimeKind.Utc);
			if (Year > 0)
			{
				result = result.AddYears(Year - 1);
			}
			if (Month > 0)
			{
				result = result.AddMonths(Month - 1);
			}
			if (Day > 0)
			{
				result = result.AddDays(Day - 1);
			}
			if (Hour > 0f)
			{
				result = result.AddHours(Hour);
			}
			return result;
		}
		set
		{
			Year = value.Year;
			Month = value.Month;
			Day = value.Day;
			Hour = (float)value.Hour + (float)value.Minute / 60f + (float)value.Second / 3600f + (float)value.Millisecond / 3600000f;
		}
	}

	public long Ticks
	{
		get
		{
			return DateTime.Ticks;
		}
		set
		{
			DateTime = new DateTime(value, DateTimeKind.Utc);
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class TOD_WorldParameters
{
	[Tooltip("Latitude of the current location in degrees.")]
	[Range(-90f, 90f)]
	public float Latitude;

	[Tooltip("Longitude of the current location in degrees.")]
	[Range(-180f, 180f)]
	public float Longitude;

	[Tooltip("UTC/GMT time zone of the current location in hours.")]
	[Range(-14f, 14f)]
	public float UTC;
}


using System;
using UnityEngine;

[Serializable]
public class TOD_AtmosphereParameters
{
	[Tooltip("Intensity of the atmospheric Rayleigh scattering.")]
	[TOD_Min(0f)]
	public float RayleighMultiplier = 1f;

	[Tooltip("Intensity of the atmospheric Mie scattering.")]
	[TOD_Min(0f)]
	public float MieMultiplier = 1f;

	[Tooltip("Overall brightness of the atmosphere.")]
	[TOD_Min(0f)]
	public float Brightness = 1.5f;

	[Tooltip("Overall contrast of the atmosphere.")]
	[TOD_Min(0f)]
	public float Contrast = 1.5f;

	[Tooltip("Overall brightness of the nighttime atmosphere.")]
	[TOD_Min(0f)]
	public float NightBrightness = 1f;

	[Tooltip("Overall contrast of the nighttime atmosphere.")]
	[TOD_Min(0f)]
	public float NightContrast = 1f;

	[Tooltip("Directionality factor that determines the size of the glow around the sun.")]
	[TOD_Range(0f, 1f)]
	public float Directionality = 0.7f;

	[Tooltip("Density of the fog covering the sky.")]
	[TOD_Range(0f, 1f)]
	public float Fogginess;
}


using System;
using UnityEngine;

[Serializable]
public class TOD_DayParameters
{
	[Tooltip("Color of the sun spot.\nLeft value: Sun at zenith.\nRight value: Sun at horizon.")]
	public Gradient SunColor;

	[Tooltip("Color of the light that hits the ground.\nLeft value: Sun at zenith.\nRight value: Sun at horizon.")]
	public Gradient LightColor;

	[Tooltip("Color of the god rays.\nLeft value: Sun at zenith.\nRight value: Sun at horizon.")]
	public Gradient RayColor;

	[Tooltip("Color of the light that hits the atmosphere.\nLeft value: Sun at zenith.\nRight value: Sun at horizon.")]
	public Gradient SkyColor;

	[Tooltip("Color of the clouds.\nLeft value: Sun at zenith.\nRight value: Sun at horizon.")]
	public Gradient CloudColor;

	[Tooltip("Color of the atmosphere fog.\nLeft value: Sun at zenith.\nRight value: Sun at horizon.")]
	public Gradient FogColor;

	[Tooltip("Color of the ambient light.\nLeft value: Sun at zenith.\nRight value: Sun at horizon.")]
	public Gradient AmbientColor;

	[Tooltip("Intensity of the light source.")]
	[TOD_Min(0f)]
	public float LightIntensity = 1f;

	[Tooltip("Opacity of the shadows dropped by the light source.")]
	[Range(0f, 1f)]
	public float ShadowStrength = 1f;

	[Tooltip("Brightness multiplier of the ambient light.")]
	[Range(0f, 8f)]
	public float AmbientMultiplier = 1f;

	[Tooltip("Brightness multiplier of the reflection probe.")]
	[Range(0f, 1f)]
	public float ReflectionMultiplier = 1f;

	[Tooltip("Max reflection multiplier")]
	[Range(0f, 1f)]
	public float ReflectionMaxClamp = 1f;
}


using System;
using UnityEngine;

[Serializable]
public class TOD_NightParameters
{
	[Tooltip("Color of the moon mesh.\nLeft value: Sun at horizon.\nRight value: Sun opposite to zenith.")]
	public Gradient MoonColor;

	[Tooltip("Color of the moon mesh when red night mode is active.\nLeft value: Sun at horizon.\nRight value: Sun opposite to zenith.")]
	public Gradient MoonColorRed;

	[Tooltip("Color of the light that hits the ground.\nLeft value: Sun at horizon.\nRight value: Sun opposite to zenith.")]
	public Gradient LightColor;

	[Tooltip("Color of the god rays.\nLeft value: Sun at horizon.\nRight value: Sun opposite to zenith.")]
	public Gradient RayColor;

	[Tooltip("Color of the light that hits the atmosphere.\nLeft value: Sun at horizon.\nRight value: Sun opposite to zenith.")]
	public Gradient SkyColor;

	[Tooltip("Color of the clouds.\nLeft value: Sun at horizon.\nRight value: Sun opposite to zenith.")]
	public Gradient CloudColor;

	[Tooltip("Color of the atmosphere fog.\nLeft value: Sun at horizon.\nRight value: Sun opposite to zenith.")]
	public Gradient FogColor;

	[Tooltip("Color of the ambient light.\nLeft value: Sun at horizon.\nRight value: Sun opposite to zenith.")]
	public Gradient AmbientColor;

	[Tooltip("Intensity of the light source.")]
	[TOD_Min(0f)]
	public float LightIntensity = 0.1f;

	[Tooltip("Opacity of the shadows dropped by the light source.")]
	[Range(0f, 1f)]
	public float ShadowStrength = 1f;

	[Tooltip("Brightness multiplier of the ambient light.")]
	[Range(0f, 8f)]
	public float AmbientMultiplier = 1f;

	[Tooltip("Brightness multiplier of the reflection probe.")]
	[Range(0f, 1f)]
	public float ReflectionMultiplier = 1f;

	[Tooltip("Max reflection multiplier")]
	[Range(0f, 1f)]
	public float ReflectionMaxClamp = 1f;
}


using System;
using UnityEngine;

[Serializable]
public class TOD_SunParameters
{
	[Tooltip("Diameter of the sun in degrees.\nThe diameter as seen from earth is 0.5 degrees.")]
	[TOD_Min(0f)]
	public float MeshSize = 1f;

	[Tooltip("Brightness of the sun.")]
	[TOD_Min(0f)]
	public float MeshBrightness = 2f;

	[Tooltip("Default brightness of sun.")]
	[TOD_Min(0f)]
	public float MeshBrightnessDefault = 2f;

	[Tooltip("Contrast of the sun.")]
	[TOD_Min(0f)]
	public float MeshContrast = 1f;
}


using System;
using UnityEngine;

[Serializable]
public class TOD_MoonParameters
{
	[Tooltip("Diameter of the moon in degrees.\nThe diameter as seen from earth is 0.5 degrees.")]
	[TOD_Min(0f)]
	public float MeshSize = 1f;

	[Tooltip("Diameter of the moon in degrees when in red mode.\nThe diameter as seen from earth is 0.5 degrees.")]
	[TOD_Min(0f)]
	public float MeshSizeRed = 2.4f;

	[Tooltip("Brightness of the moon.")]
	[TOD_Min(0f)]
	public float MeshBrightness = 2f;

	[Tooltip("Default brightness of moon.")]
	[TOD_Min(0f)]
	public float MeshBrightnessDefault = 2f;

	[Tooltip("Contrast of the moon.")]
	[TOD_Min(0f)]
	public float MeshContrast = 1f;

	[Tooltip("Size of the moon halo.")]
	[TOD_Min(0f)]
	public float HaloSize = 0.1f;

	[Tooltip("Brightness of the moon halo.")]
	[TOD_Min(0f)]
	public float HaloBrightness = 1f;

	[Tooltip("Type of the moon position calculation.")]
	public TOD_MoonPositionType Position = TOD_MoonPositionType.Realistic;
}


using System;
using UnityEngine;

[Serializable]
public class TOD_StarParameters
{
	[Tooltip("Size of the stars.")]
	[TOD_Min(0f)]
	public float Size = 1f;

	[Tooltip("Brightness of the stars.")]
	[TOD_Min(0f)]
	public float Brightness = 1f;

	[Tooltip("Type of the stars position calculation.")]
	public TOD_StarsPositionType Position = TOD_StarsPositionType.Rotating;

	[Tooltip("Tint of the stars.")]
	public Color ColorScale = Color.white;
}


using System;
using UnityEngine;

[Serializable]
public class TOD_CloudParameters
{
	[Tooltip("Size of the clouds.")]
	[TOD_Min(1f)]
	public float Size = 2f;

	[Tooltip("Opacity of the clouds.")]
	[TOD_Range(0f, 1f)]
	public float Opacity = 1f;

	[Tooltip("How much sky is covered by clouds.")]
	[TOD_Range(0f, 1f)]
	public float Coverage = 0.5f;

	[Tooltip("Sharpness of the cloud to sky transition.")]
	[TOD_Range(0f, 1f)]
	public float Sharpness = 0.5f;

	[Tooltip("Coloring of the clouds.")]
	[TOD_Range(0f, 1f)]
	public float Coloring = 0.5f;

	[Tooltip("Amount of skylight that is blocked.")]
	[TOD_Range(0f, 1f)]
	public float Attenuation = 0.5f;

	[Tooltip("Amount of sunlight that is blocked.\nOnly affects the highest cloud quality setting.")]
	[TOD_Range(0f, 1f)]
	public float Saturation = 0.5f;

	[Tooltip("Intensity of the cloud translucency glow.\nOnly affects the highest cloud quality setting.")]
	[TOD_Min(0f)]
	public float Scattering = 1f;

	[Tooltip("Brightness of the clouds.")]
	[TOD_Min(0f)]
	public float Brightness = 1.5f;
}


using System;
using UnityEngine;

[Serializable]
public class TOD_LightParameters
{
	[Tooltip("Refresh interval of the light source position in seconds.")]
	[TOD_Min(0f)]
	public float UpdateInterval;

	[Tooltip("Controls how low the light source is allowed to go.\n = -1 light source can go as low as it wants.\n = 0 light source will never go below the horizon.\n = +1 light source will never leave zenith.")]
	[TOD_Range(-1f, 1f)]
	public float MinimumHeight;
}


using System;
using UnityEngine;

[Serializable]
public class TOD_FogParameters
{
	[Tooltip("Fog color mode.")]
	public TOD_FogType Mode = TOD_FogType.Atmosphere;

	[Tooltip("Fog color sampling height.\n = 0 fog is atmosphere color at horizon.\n = 1 fog is atmosphere color at zenith.")]
	[TOD_Range(0f, 1f)]
	public float HeightBias;
}


using System;
using UnityEngine;

[Serializable]
public class TOD_AmbientParameters
{
	[Tooltip("Ambient light mode.")]
	public TOD_AmbientType Mode = TOD_AmbientType.Color;

	[Tooltip("Saturation of the ambient light.")]
	[TOD_Min(0f)]
	public float Saturation = 1f;

	[Tooltip("Refresh interval of the ambient light probe in seconds.")]
	[TOD_Min(0f)]
	public float UpdateInterval = 1f;
}


using System;
using UnityEngine;
using UnityEngine.Rendering;

[Serializable]
public class TOD_ReflectionParameters
{
	[Tooltip("Reflection probe mode.")]
	public TOD_ReflectionType Mode;

	[Tooltip("Clear flags to use for the reflection.")]
	public ReflectionProbeClearFlags ClearFlags = (ReflectionProbeClearFlags)1;

	[Tooltip("Layers to include in the reflection.")]
	public LayerMask CullingMask = LayerMask.op_Implicit(0);

	[Tooltip("Temporary reflection probe prefab")]
	public GameObject ProbePrefab;
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("Time of Day/Camera God Rays")]
public class TOD_Rays : TOD_ImageEffect
{
	public enum BlendModeType
	{
		Screen,
		Add
	}

	public Shader GodRayShader;

	public Shader ScreenClearShader;

	public Shader SkyMaskShader;

	[Tooltip("Whether or not to use the depth buffer.")]
	public bool UseDepthTexture = true;

	[Header("Rays")]
	[Tooltip("The god ray rendering blend mode.")]
	public BlendModeType BlendMode;

	[Tooltip("The intensity of the god rays.")]
	[TOD_Min(0f)]
	public float Intensity = 1f;

	[Header("Blur")]
	[Tooltip("The god ray rendering resolution.")]
	public ResolutionType Resolution = ResolutionType.Normal;

	[Tooltip("The number of blur iterations to be performed.")]
	[TOD_Range(0f, 4f)]
	public int BlurIterations = 2;

	[Tooltip("The radius to blur filter applied to the god rays.")]
	[TOD_Min(0f)]
	public float BlurRadius = 2f;

	[Tooltip("The maximum radius of the god rays.")]
	[TOD_Min(0f)]
	public float MaxRadius = 0.5f;

	private Material godRayMaterial;

	private Material screenClearMaterial;

	private Material skyMaskMaterial;

	private const int PASS_SCREEN = 0;

	private const int PASS_ADD = 1;

	protected void OnEnable()
	{
		if (!Object.op_Implicit((Object)(object)GodRayShader))
		{
			GodRayShader = Shader.Find("Hidden/Time of Day/God Rays");
		}
		if (!Object.op_Implicit((Object)(object)ScreenClearShader))
		{
			ScreenClearShader = Shader.Find("Hidden/Time of Day/Screen Clear");
		}
		if (!Object.op_Implicit((Object)(object)SkyMaskShader))
		{
			SkyMaskShader = Shader.Find("Hidden/Time of Day/Sky Mask");
		}
		godRayMaterial = CreateMaterial(GodRayShader);
		screenClearMaterial = CreateMaterial(ScreenClearShader);
		skyMaskMaterial = CreateMaterial(SkyMaskShader);
	}

	protected void OnDisable()
	{
		if (Object.op_Implicit((Object)(object)godRayMaterial))
		{
			Object.DestroyImmediate((Object)(object)godRayMaterial);
		}
		if (Object.op_Implicit((Object)(object)screenClearMaterial))
		{
			Object.DestroyImmediate((Object)(object)screenClearMaterial);
		}
		if (Object.op_Implicit((Object)(object)skyMaskMaterial))
		{
			Object.DestroyImmediate((Object)(object)skyMaskMaterial);
		}
	}

	protected void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		if (!CheckSupport(UseDepthTexture))
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		sky.Components.Rays = this;
		Vector3 val = cam.WorldToViewportPoint(sky.Components.LightTransform.position);
		RenderTexture skyMask = GetSkyMask(source, skyMaskMaterial, screenClearMaterial, Resolution, val, BlurIterations, BlurRadius, MaxRadius);
		Color val2 = Color.black;
		if ((double)val.z >= 0.0)
		{
			val2 = ((!sky.IsDay) ? (Intensity * sky.MoonVisibility * sky.MoonRayColor) : (Intensity * sky.SunVisibility * sky.SunRayColor));
		}
		godRayMaterial.SetColor("_LightColor", val2);
		godRayMaterial.SetTexture("_SkyMask", (Texture)(object)skyMask);
		if (BlendMode == BlendModeType.Screen)
		{
			Graphics.Blit((Texture)(object)source, destination, godRayMaterial, 0);
		}
		else
		{
			Graphics.Blit((Texture)(object)source, destination, godRayMaterial, 1);
		}
		RenderTexture.ReleaseTemporary(skyMask);
	}
}


using UnityEngine;

public class TOD_Resources : MonoBehaviour
{
	public Material Skybox;

	public Mesh MoonLOD0;

	public Mesh MoonLOD1;

	public Mesh MoonLOD2;

	public Mesh SkyLOD0;

	public Mesh SkyLOD1;

	public Mesh SkyLOD2;

	public Mesh CloudsLOD0;

	public Mesh CloudsLOD1;

	public Mesh CloudsLOD2;

	public Mesh StarsLOD0;

	public Mesh StarsLOD1;

	public Mesh StarsLOD2;

	public int ID_SunLightColor { get; private set; }

	public int ID_MoonLightColor { get; private set; }

	public int ID_SunSkyColor { get; private set; }

	public int ID_MoonSkyColor { get; private set; }

	public int ID_SunMeshColor { get; private set; }

	public int ID_MoonMeshColor { get; private set; }

	public int ID_SunCloudColor { get; private set; }

	public int ID_MoonCloudColor { get; private set; }

	public int ID_FogColor { get; private set; }

	public int ID_GroundColor { get; private set; }

	public int ID_AmbientColor { get; private set; }

	public int ID_SunDirection { get; private set; }

	public int ID_MoonDirection { get; private set; }

	public int ID_LightDirection { get; private set; }

	public int ID_LocalSunDirection { get; private set; }

	public int ID_LocalMoonDirection { get; private set; }

	public int ID_LocalLightDirection { get; private set; }

	public int ID_Contrast { get; private set; }

	public int ID_Brightness { get; private set; }

	public int ID_Fogginess { get; private set; }

	public int ID_Directionality { get; private set; }

	public int ID_NightBrightness { get; private set; }

	public int ID_NightContrast { get; private set; }

	public int ID_MoonHaloPower { get; private set; }

	public int ID_MoonHaloColor { get; private set; }

	public int ID_CloudSize { get; private set; }

	public int ID_CloudOpacity { get; private set; }

	public int ID_CloudCoverage { get; private set; }

	public int ID_CloudSharpness { get; private set; }

	public int ID_CloudDensity { get; private set; }

	public int ID_CloudColoring { get; private set; }

	public int ID_CloudAttenuation { get; private set; }

	public int ID_CloudSaturation { get; private set; }

	public int ID_CloudScattering { get; private set; }

	public int ID_CloudBrightness { get; private set; }

	public int ID_CloudMultiplier { get; private set; }

	public int ID_CloudOffset { get; private set; }

	public int ID_CloudWind { get; private set; }

	public int ID_StarSize { get; private set; }

	public int ID_StarBrightness { get; private set; }

	public int ID_StarVisibility { get; private set; }

	public int ID_StarColorScale { get; private set; }

	public int ID_SunMeshContrast { get; private set; }

	public int ID_SunMeshBrightness { get; private set; }

	public int ID_MoonMeshContrast { get; private set; }

	public int ID_MoonMeshBrightness { get; private set; }

	public int ID_kBetaMie { get; private set; }

	public int ID_kSun { get; private set; }

	public int ID_k4PI { get; private set; }

	public int ID_kRadius { get; private set; }

	public int ID_kScale { get; private set; }

	public int ID_World2Sky { get; private set; }

	public int ID_Sky2World { get; private set; }

	public void Initialize()
	{
		ID_SunLightColor = Shader.PropertyToID("TOD_SunLightColor");
		ID_MoonLightColor = Shader.PropertyToID("TOD_MoonLightColor");
		ID_SunSkyColor = Shader.PropertyToID("TOD_SunSkyColor");
		ID_MoonSkyColor = Shader.PropertyToID("TOD_MoonSkyColor");
		ID_SunMeshColor = Shader.PropertyToID("TOD_SunMeshColor");
		ID_MoonMeshColor = Shader.PropertyToID("TOD_MoonMeshColor");
		ID_SunCloudColor = Shader.PropertyToID("TOD_SunCloudColor");
		ID_MoonCloudColor = Shader.PropertyToID("TOD_MoonCloudColor");
		ID_FogColor = Shader.PropertyToID("TOD_FogColor");
		ID_GroundColor = Shader.PropertyToID("TOD_GroundColor");
		ID_AmbientColor = Shader.PropertyToID("TOD_AmbientColor");
		ID_SunDirection = Shader.PropertyToID("TOD_SunDirection");
		ID_MoonDirection = Shader.PropertyToID("TOD_MoonDirection");
		ID_LightDirection = Shader.PropertyToID("TOD_LightDirection");
		ID_LocalSunDirection = Shader.PropertyToID("TOD_LocalSunDirection");
		ID_LocalMoonDirection = Shader.PropertyToID("TOD_LocalMoonDirection");
		ID_LocalLightDirection = Shader.PropertyToID("TOD_LocalLightDirection");
		ID_Contrast = Shader.PropertyToID("TOD_Contrast");
		ID_Brightness = Shader.PropertyToID("TOD_Brightness");
		ID_Fogginess = Shader.PropertyToID("TOD_Fogginess");
		ID_Directionality = Shader.PropertyToID("TOD_Directionality");
		ID_NightContrast = Shader.PropertyToID("TOD_NightContrast");
		ID_NightBrightness = Shader.PropertyToID("TOD_NightBrightness");
		ID_MoonHaloPower = Shader.PropertyToID("TOD_MoonHaloPower");
		ID_MoonHaloColor = Shader.PropertyToID("TOD_MoonHaloColor");
		ID_CloudSize = Shader.PropertyToID("TOD_CloudSize");
		ID_CloudOpacity = Shader.PropertyToID("TOD_CloudOpacity");
		ID_CloudCoverage = Shader.PropertyToID("TOD_CloudCoverage");
		ID_CloudSharpness = Shader.PropertyToID("TOD_CloudSharpness");
		ID_CloudDensity = Shader.PropertyToID("TOD_CloudDensity");
		ID_CloudColoring = Shader.PropertyToID("TOD_CloudColoring");
		ID_CloudAttenuation = Shader.PropertyToID("TOD_CloudAttenuation");
		ID_CloudSaturation = Shader.PropertyToID("TOD_CloudSaturation");
		ID_CloudScattering = Shader.PropertyToID("TOD_CloudScattering");
		ID_CloudBrightness = Shader.PropertyToID("TOD_CloudBrightness");
		ID_CloudOffset = Shader.PropertyToID("TOD_CloudOffset");
		ID_CloudWind = Shader.PropertyToID("TOD_CloudWind");
		ID_StarSize = Shader.PropertyToID("TOD_StarSize");
		ID_StarBrightness = Shader.PropertyToID("TOD_StarBrightness");
		ID_StarVisibility = Shader.PropertyToID("TOD_StarVisibility");
		ID_StarColorScale = Shader.PropertyToID("TOD_StarColorScale");
		ID_SunMeshContrast = Shader.PropertyToID("TOD_SunMeshContrast");
		ID_SunMeshBrightness = Shader.PropertyToID("TOD_SunMeshBrightness");
		ID_MoonMeshContrast = Shader.PropertyToID("TOD_MoonMeshContrast");
		ID_MoonMeshBrightness = Shader.PropertyToID("TOD_MoonMeshBrightness");
		ID_kBetaMie = Shader.PropertyToID("TOD_kBetaMie");
		ID_kSun = Shader.PropertyToID("TOD_kSun");
		ID_k4PI = Shader.PropertyToID("TOD_k4PI");
		ID_kRadius = Shader.PropertyToID("TOD_kRadius");
		ID_kScale = Shader.PropertyToID("TOD_kScale");
		ID_World2Sky = Shader.PropertyToID("TOD_World2Sky");
		ID_Sky2World = Shader.PropertyToID("TOD_Sky2World");
	}
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[ImageEffectAllowedInSceneView]
[AddComponentMenu("Time of Day/Camera Atmospheric Scattering")]
public class TOD_Scattering : TOD_ImageEffect
{
	public Shader ScatteringShader;

	public Shader ScreenClearShader;

	public Shader SkyMaskShader;

	public Texture2D DitheringTexture;

	[Tooltip("Whether to render atmosphere and fog in a single pass or two separate passes. Disable when using anti-aliasing in forward rendering or when your manual reflection scripts need the sky dome to be present before the image effects are rendered.")]
	public bool SinglePass = true;

	[Header("Fog")]
	[Tooltip("How quickly the fog thickens with increasing distance.")]
	[Range(0f, 1f)]
	public float GlobalDensity = 0.01f;

	[Tooltip("How quickly the fog falls off with increasing altitude.")]
	[Range(0f, 1f)]
	public float HeightFalloff = 0.01f;

	[Tooltip("The distance the fog starts at.")]
	public float StartDistance;

	[Tooltip("The height where the fog reaches its maximum density.")]
	public float ZeroLevel;

	[Header("Blur")]
	[Tooltip("The scattering resolution.")]
	public ResolutionType Resolution = ResolutionType.Normal;

	[Tooltip("The number of blur iterations to be performed.")]
	[TOD_Range(0f, 4f)]
	public int BlurIterations = 2;

	[Tooltip("The radius to blur filter applied to the directional scattering.")]
	[TOD_Min(0f)]
	public float BlurRadius = 2f;

	[Tooltip("The maximum radius of the directional scattering.")]
	[TOD_Min(0f)]
	public float MaxRadius = 1f;

	private Material scatteringMaterial;

	private Material screenClearMaterial;

	private Material skyMaskMaterial;

	private RenderTexture skyMaskTexture;

	protected void OnEnable()
	{
		if (!Object.op_Implicit((Object)(object)ScatteringShader))
		{
			ScatteringShader = Shader.Find("Hidden/Time of Day/Scattering");
		}
		if (!Object.op_Implicit((Object)(object)ScreenClearShader))
		{
			ScreenClearShader = Shader.Find("Hidden/Time of Day/Screen Clear");
		}
		if (!Object.op_Implicit((Object)(object)SkyMaskShader))
		{
			SkyMaskShader = Shader.Find("Hidden/Time of Day/Sky Mask");
		}
		scatteringMaterial = CreateMaterial(ScatteringShader);
		screenClearMaterial = CreateMaterial(ScreenClearShader);
		skyMaskMaterial = CreateMaterial(SkyMaskShader);
	}

	protected void OnDisable()
	{
		if (Object.op_Implicit((Object)(object)scatteringMaterial))
		{
			Object.DestroyImmediate((Object)(object)scatteringMaterial);
		}
		if (Object.op_Implicit((Object)(object)screenClearMaterial))
		{
			Object.DestroyImmediate((Object)(object)screenClearMaterial);
		}
		if (Object.op_Implicit((Object)(object)skyMaskMaterial))
		{
			Object.DestroyImmediate((Object)(object)skyMaskMaterial);
		}
		if ((Object)(object)skyMaskTexture != (Object)null)
		{
			skyMaskTexture.Release();
			skyMaskTexture = null;
		}
	}

	protected void OnPreCull()
	{
		if (SinglePass && Object.op_Implicit((Object)(object)sky) && sky.Initialized)
		{
			sky.Components.AtmosphereRenderer.enabled = false;
		}
	}

	protected void OnPostRender()
	{
		if (SinglePass && Object.op_Implicit((Object)(object)sky) && sky.Initialized)
		{
			sky.Components.AtmosphereRenderer.enabled = true;
		}
	}

	private void MakeSkyMaskTexture(RenderTexture source)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Expected O, but got Unknown
		Vector3i skyMaskSize = GetSkyMaskSize(source, Resolution);
		int x = skyMaskSize.x;
		int y = skyMaskSize.y;
		int z = skyMaskSize.z;
		skyMaskTexture = new RenderTexture(x, y, z);
		((Texture)skyMaskTexture).wrapMode = (TextureWrapMode)1;
		((Texture)skyMaskTexture).filterMode = (FilterMode)1;
		skyMaskTexture.Create();
		Shader.SetGlobalTexture("_TOD_SkyMask", (Texture)(object)skyMaskTexture);
	}

	private void ResizeSkyMask(RenderTexture source)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)skyMaskTexture == (Object)null)
		{
			MakeSkyMaskTexture(source);
			return;
		}
		Vector3i skyMaskSize = GetSkyMaskSize(source, Resolution);
		if (skyMaskSize.x != ((Texture)skyMaskTexture).width || skyMaskSize.y != ((Texture)skyMaskTexture).height)
		{
			skyMaskTexture.Release();
			((Texture)skyMaskTexture).width = skyMaskSize.x;
			((Texture)skyMaskTexture).height = skyMaskSize.y;
			skyMaskTexture.Create();
		}
	}

	[ImageEffectOpaque]
	protected void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		if (!CheckSupport(needDepth: true))
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		ResizeSkyMask(source);
		sky.Components.Scattering = this;
		Vector3 lightPos = cam.WorldToViewportPoint(sky.Components.SunTransform.position);
		RenderTexture skyMask = GetSkyMask(source, skyMaskMaterial, screenClearMaterial, Resolution, lightPos, BlurIterations, BlurRadius, MaxRadius);
		scatteringMaterial.SetMatrix("_FrustumCornersWS", FrustumCorners());
		scatteringMaterial.SetTexture("_SkyMask", (Texture)(object)skyMask);
		if (SinglePass)
		{
			scatteringMaterial.EnableKeyword("TOD_SCATTERING_SINGLE_PASS");
		}
		else
		{
			scatteringMaterial.DisableKeyword("TOD_SCATTERING_SINGLE_PASS");
		}
		Shader.SetGlobalTexture("TOD_BayerTexture", (Texture)(object)DitheringTexture);
		Shader.SetGlobalVector("TOD_ScatterDensity", new Vector4(HeightFalloff, ZeroLevel, GlobalDensity, StartDistance));
		Graphics.Blit((Texture)(object)skyMask, skyMaskTexture);
		Graphics.Blit((Texture)(object)source, destination, scatteringMaterial);
		RenderTexture.ReleaseTemporary(skyMask);
	}
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("Time of Day/Camera Cloud Shadows")]
public class TOD_Shadows : TOD_ImageEffect
{
	public Shader ShadowShader;

	public Texture2D CloudTexture;

	[Header("Shadows")]
	[Range(0f, 1f)]
	public float Cutoff;

	[Range(0f, 1f)]
	public float Fade;

	[Range(0f, 1f)]
	public float Intensity = 0.5f;

	private Material shadowMaterial;

	protected void OnEnable()
	{
		if (!Object.op_Implicit((Object)(object)ShadowShader))
		{
			ShadowShader = Shader.Find("Hidden/Time of Day/Cloud Shadows");
		}
		shadowMaterial = CreateMaterial(ShadowShader);
	}

	protected void OnDisable()
	{
		if (Object.op_Implicit((Object)(object)shadowMaterial))
		{
			Object.DestroyImmediate((Object)(object)shadowMaterial);
		}
	}

	[ImageEffectOpaque]
	protected void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (!CheckSupport(needDepth: true))
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		sky.Components.Shadows = this;
		shadowMaterial.SetMatrix("_FrustumCornersWS", FrustumCorners());
		Shader.SetGlobalTexture("TOD_CloudTexture", (Texture)(object)CloudTexture);
		Shader.SetGlobalFloat("TOD_CloudShadowCutoff", Cutoff);
		Shader.SetGlobalFloat("TOD_CloudShadowFade", Fade);
		Shader.SetGlobalFloat("TOD_CloudShadowIntensity", Intensity * Mathf.Clamp01(1f - sky.SunZenith / 90f));
		Graphics.Blit((Texture)(object)source, destination, shadowMaterial);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Serialization;
using UnityEngine;
using UnityEngine.Rendering;

[ExecuteInEditMode]
[RequireComponent(typeof(TOD_Resources))]
[RequireComponent(typeof(TOD_Components))]
public class TOD_Sky : MonoBehaviour
{
	public class ReflectionProbeState
	{
		public ReflectionProbe Probe;

		public GameObject ProbeInstance;

		public int ProbeRenderID = -1;

		public void InitializePrimary(Vector3 position, GameObject prefab)
		{
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Expected O, but got Unknown
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			if (!Object.op_Implicit((Object)(object)ProbeInstance))
			{
				if (!Object.op_Implicit((Object)(object)prefab))
				{
					ProbeInstance = new GameObject();
					((Object)ProbeInstance).name = "Primary Reflection Probe";
					ProbeInstance.transform.position = position;
					Probe = ProbeInstance.AddComponent<ReflectionProbe>();
					Probe.size = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
				}
				else
				{
					ProbeInstance = Object.Instantiate<GameObject>(prefab);
					((Object)ProbeInstance).name = "Primary Reflection Probe";
					ProbeInstance.transform.position = position;
					Probe = ProbeInstance.GetComponent<ReflectionProbe>();
					Probe.size = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
				}
			}
		}

		public void InitializeSecondary(Vector3 position, GameObject prefab)
		{
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Expected O, but got Unknown
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			if (!Object.op_Implicit((Object)(object)ProbeInstance))
			{
				if (!Object.op_Implicit((Object)(object)prefab))
				{
					ProbeInstance = new GameObject();
					((Object)ProbeInstance).name = "Secondary Reflection Probe";
					ProbeInstance.transform.position = position;
					Probe = ProbeInstance.AddComponent<ReflectionProbe>();
					Probe.size = new Vector3(0f, 0f, 0f);
					Probe.importance = 0;
				}
				else
				{
					ProbeInstance = Object.Instantiate<GameObject>(prefab);
					((Object)ProbeInstance).name = "Secondary Reflection Probe";
					ProbeInstance.transform.position = position;
					Probe = ProbeInstance.GetComponent<ReflectionProbe>();
					Probe.size = new Vector3(0f, 0f, 0f);
					Probe.importance = 0;
				}
			}
		}
	}

	private static List<TOD_Sky> instances = new List<TOD_Sky>();

	[Tooltip("Auto: Use the player settings.\nLinear: Force linear color space.\nGamma: Force gamma color space.")]
	public TOD_ColorSpaceType ColorSpace;

	[Tooltip("Auto: Use the camera settings.\nHDR: Force high dynamic range.\nLDR: Force low dynamic range.")]
	public TOD_ColorRangeType ColorRange;

	[Tooltip("Raw: Write color without modifications.\nDithered: Add dithering to reduce banding.")]
	public TOD_ColorOutputType ColorOutput = TOD_ColorOutputType.Dithered;

	[Tooltip("Per Vertex: Calculate sky color per vertex.\nPer Pixel: Calculate sky color per pixel.")]
	public TOD_SkyQualityType SkyQuality;

	[Tooltip("Low: Only recommended for very old mobile devices.\nMedium: Simplified cloud shading.\nHigh: Physically based cloud shading.")]
	public TOD_CloudQualityType CloudQuality = TOD_CloudQualityType.High;

	[Tooltip("Low: Only recommended for very old mobile devices.\nMedium: Simplified mesh geometry.\nHigh: Detailed mesh geometry.")]
	public TOD_MeshQualityType MeshQuality = TOD_MeshQualityType.High;

	[Tooltip("Low: Recommended for most mobile devices.\nMedium: Includes most visible stars.\nHigh: Includes all visible stars.")]
	public TOD_StarQualityType StarQuality = TOD_StarQualityType.High;

	public TOD_CycleParameters Cycle;

	public TOD_WorldParameters World;

	public TOD_AtmosphereParameters Atmosphere;

	public TOD_DayParameters Day;

	public TOD_NightParameters Night;

	public TOD_SunParameters Sun;

	public TOD_MoonParameters Moon;

	public TOD_StarParameters Stars;

	public TOD_CloudParameters Clouds;

	public TOD_LightParameters Light;

	public TOD_FogParameters Fog;

	public TOD_AmbientParameters Ambient;

	public TOD_ReflectionParameters Reflection;

	private ReflectionProbeState ReflectionCur = new ReflectionProbeState();

	private ReflectionProbeState ReflectionSrc = new ReflectionProbeState();

	private ReflectionProbeState ReflectionDst = new ReflectionProbeState();

	public static float ReflectionUpdateSpeed = 1f;

	public static int ReflectionResolution = 64;

	public static float ReflectionUpdateInterval = 1f;

	public static ReflectionProbeTimeSlicingMode ReflectionTimeSlicing = (ReflectionProbeTimeSlicingMode)1;

	private float timeSinceLightUpdate = float.MaxValue;

	private float timeSinceAmbientUpdate = float.MaxValue;

	private float timeSinceReflectionUpdate = float.MaxValue;

	private bool drawVClouds;

	private const int TOD_SAMPLES = 2;

	private Vector3 kBetaMie;

	private Vector4 kSun;

	private Vector4 k4PI;

	private Vector4 kRadius;

	private Vector4 kScale;

	private const float pi = (float)Math.PI;

	private const float tau = (float)Math.PI * 2f;

	public static List<TOD_Sky> Instances => instances;

	public static TOD_Sky Instance
	{
		get
		{
			if (instances.Count != 0)
			{
				return instances[instances.Count - 1];
			}
			return null;
		}
	}

	public bool Initialized { get; private set; }

	public bool Headless => Camera.allCamerasCount == 0;

	public TOD_Components Components { get; private set; }

	public TOD_Resources Resources { get; private set; }

	public bool IsDay { get; private set; }

	public bool IsNight { get; private set; }

	public float Radius => Components.DomeTransform.lossyScale.y;

	public float Diameter => Components.DomeTransform.lossyScale.y * 2f;

	public float LerpValue { get; private set; }

	public float SunZenith { get; private set; }

	public float SunAltitude { get; private set; }

	public float SunAzimuth { get; private set; }

	public float MoonZenith { get; private set; }

	public float MoonAltitude { get; private set; }

	public float MoonAzimuth { get; private set; }

	public float SunsetTime { get; private set; }

	public float SunriseTime { get; private set; }

	public float LocalSiderealTime { get; private set; }

	public float LightZenith => Mathf.Min(SunZenith, MoonZenith);

	public float LightIntensity
	{
		get
		{
			return Components.LightSource.intensity;
		}
		set
		{
			Components.LightSource.intensity = value;
		}
	}

	public float SunVisibility { get; private set; }

	public float MoonVisibility { get; private set; }

	public Vector3 SunDirection { get; private set; }

	public Vector3 MoonDirection { get; private set; }

	public Vector3 LightDirection { get; private set; }

	public Vector3 LocalSunDirection { get; private set; }

	public Vector3 LocalMoonDirection { get; private set; }

	public Vector3 LocalLightDirection { get; private set; }

	public Color SunLightColor { get; private set; }

	public Color MoonLightColor { get; private set; }

	public Color LightColor
	{
		get
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			return Components.LightSource.color;
		}
		set
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			Components.LightSource.color = value;
		}
	}

	public Color SunRayColor { get; set; }

	public Color MoonRayColor { get; set; }

	public Color SunSkyColor { get; private set; }

	public Color MoonSkyColor { get; private set; }

	public Color SunMeshColor { get; private set; }

	public Color MoonMeshColor { get; private set; }

	public Color SunCloudColor { get; private set; }

	public Color MoonCloudColor { get; private set; }

	public Color FogColor { get; private set; }

	public Color GroundColor { get; private set; }

	public Color AmbientColor { get; private set; }

	public Color MoonHaloColor { get; private set; }

	public ReflectionProbe Probe => ReflectionCur.Probe;

	public GameObject ProbeInstance => ReflectionCur.ProbeInstance;

	public Vector3 OrbitalToUnity(float radius, float theta, float phi)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Sin(theta);
		float num2 = Mathf.Cos(theta);
		float num3 = Mathf.Sin(phi);
		float num4 = Mathf.Cos(phi);
		Vector3 result = default(Vector3);
		result.z = radius * num * num4;
		result.y = radius * num2;
		result.x = radius * num * num3;
		return result;
	}

	public Vector3 OrbitalToLocal(float theta, float phi)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Sin(theta);
		float y = Mathf.Cos(theta);
		float num2 = Mathf.Sin(phi);
		float num3 = Mathf.Cos(phi);
		Vector3 result = default(Vector3);
		result.z = num * num3;
		result.y = y;
		result.x = num * num2;
		return result;
	}

	public Color SampleAtmosphere(Vector3 direction, bool directLight = true)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 dir = Components.DomeTransform.InverseTransformDirection(direction);
		Color color = ShaderScatteringColor(dir, directLight);
		color = TOD_HDR2LDR(color);
		return TOD_LINEAR2GAMMA(color);
	}

	public SphericalHarmonicsL2 RenderToSphericalHarmonics()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		float saturation = Ambient.Saturation;
		float intensity = Mathf.Lerp(Night.AmbientMultiplier, Day.AmbientMultiplier, LerpValue);
		return RenderToSphericalHarmonics(intensity, saturation);
	}

	public SphericalHarmonicsL2 RenderToSphericalHarmonics(float intensity, float saturation)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		SphericalHarmonicsL2 result = default(SphericalHarmonicsL2);
		bool directLight = false;
		Color val = AmbientColor;
		Color val2 = TOD_Util.AdjustRGB(((Color)(ref val)).linear, intensity, saturation);
		Vector3 val3 = default(Vector3);
		((Vector3)(ref val3))..ctor(0.61237246f, 0.5f, 0.61237246f);
		Vector3 up = Vector3.up;
		val = SampleAtmosphere(up, directLight);
		Color val4 = TOD_Util.AdjustRGB(((Color)(ref val)).linear, intensity, saturation);
		((SphericalHarmonicsL2)(ref result)).AddDirectionalLight(up, val4, 0.42857143f);
		Vector3 val5 = default(Vector3);
		((Vector3)(ref val5))..ctor(0f - val3.x, val3.y, 0f - val3.z);
		val = SampleAtmosphere(val5, directLight);
		Color val6 = TOD_Util.AdjustRGB(((Color)(ref val)).linear, intensity, saturation);
		((SphericalHarmonicsL2)(ref result)).AddDirectionalLight(val5, val6, 0.2857143f);
		Vector3 val7 = default(Vector3);
		((Vector3)(ref val7))..ctor(val3.x, val3.y, 0f - val3.z);
		val = SampleAtmosphere(val7, directLight);
		Color val8 = TOD_Util.AdjustRGB(((Color)(ref val)).linear, intensity, saturation);
		((SphericalHarmonicsL2)(ref result)).AddDirectionalLight(val7, val8, 0.2857143f);
		Vector3 val9 = default(Vector3);
		((Vector3)(ref val9))..ctor(0f - val3.x, val3.y, val3.z);
		val = SampleAtmosphere(val9, directLight);
		Color val10 = TOD_Util.AdjustRGB(((Color)(ref val)).linear, intensity, saturation);
		((SphericalHarmonicsL2)(ref result)).AddDirectionalLight(val9, val10, 0.2857143f);
		Vector3 val11 = default(Vector3);
		((Vector3)(ref val11))..ctor(val3.x, val3.y, val3.z);
		val = SampleAtmosphere(val11, directLight);
		Color val12 = TOD_Util.AdjustRGB(((Color)(ref val)).linear, intensity, saturation);
		((SphericalHarmonicsL2)(ref result)).AddDirectionalLight(val11, val12, 0.2857143f);
		Vector3 left = Vector3.left;
		val = SampleAtmosphere(left, directLight);
		Color val13 = TOD_Util.AdjustRGB(((Color)(ref val)).linear, intensity, saturation);
		((SphericalHarmonicsL2)(ref result)).AddDirectionalLight(left, val13, 1f / 7f);
		Vector3 right = Vector3.right;
		val = SampleAtmosphere(right, directLight);
		Color val14 = TOD_Util.AdjustRGB(((Color)(ref val)).linear, intensity, saturation);
		((SphericalHarmonicsL2)(ref result)).AddDirectionalLight(right, val14, 1f / 7f);
		Vector3 back = Vector3.back;
		val = SampleAtmosphere(back, directLight);
		Color val15 = TOD_Util.AdjustRGB(((Color)(ref val)).linear, intensity, saturation);
		((SphericalHarmonicsL2)(ref result)).AddDirectionalLight(back, val15, 1f / 7f);
		Vector3 forward = Vector3.forward;
		val = SampleAtmosphere(forward, directLight);
		Color val16 = TOD_Util.AdjustRGB(((Color)(ref val)).linear, intensity, saturation);
		((SphericalHarmonicsL2)(ref result)).AddDirectionalLight(forward, val16, 1f / 7f);
		Vector3 val17 = default(Vector3);
		((Vector3)(ref val17))..ctor(0f - val3.x, 0f - val3.y, 0f - val3.z);
		((SphericalHarmonicsL2)(ref result)).AddDirectionalLight(val17, val2, 0.2857143f);
		Vector3 val18 = default(Vector3);
		((Vector3)(ref val18))..ctor(val3.x, 0f - val3.y, 0f - val3.z);
		((SphericalHarmonicsL2)(ref result)).AddDirectionalLight(val18, val2, 0.2857143f);
		Vector3 val19 = default(Vector3);
		((Vector3)(ref val19))..ctor(0f - val3.x, 0f - val3.y, val3.z);
		((SphericalHarmonicsL2)(ref result)).AddDirectionalLight(val19, val2, 0.2857143f);
		Vector3 val20 = default(Vector3);
		((Vector3)(ref val20))..ctor(val3.x, 0f - val3.y, val3.z);
		((SphericalHarmonicsL2)(ref result)).AddDirectionalLight(val20, val2, 0.2857143f);
		Vector3 down = Vector3.down;
		((SphericalHarmonicsL2)(ref result)).AddDirectionalLight(down, val2, 0.42857143f);
		return result;
	}

	public void RenderToCubemap(RenderTexture targetTexture = null)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		ReflectionCur.InitializePrimary(Components.DomeTransform.position, Reflection.ProbePrefab);
		if (ReflectionCur.ProbeRenderID < 0 || ReflectionCur.Probe.IsFinishedRendering(ReflectionCur.ProbeRenderID))
		{
			UpdateProbeProperties(ReflectionCur.Probe);
			ReflectionCur.ProbeRenderID = ReflectionCur.Probe.RenderProbe(targetTexture);
		}
		else
		{
			UpdateProbeProperties(ReflectionCur.Probe);
		}
	}

	public void RenderToProbe()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		ReflectionCur.InitializePrimary(Components.DomeTransform.position, Reflection.ProbePrefab);
		if (ReflectionCur.ProbeRenderID < 0 || ReflectionUpdateInterval == 0f)
		{
			UpdateProbeProperties(ReflectionCur.Probe);
			ReflectionCur.ProbeRenderID = ReflectionCur.Probe.RenderProbe();
		}
		else if (ReflectionDst.ProbeRenderID < 0 || ReflectionDst.Probe.IsFinishedRendering(ReflectionDst.ProbeRenderID))
		{
			ReflectionSrc.InitializeSecondary(Components.DomeTransform.position, Reflection.ProbePrefab);
			ReflectionDst.InitializeSecondary(Components.DomeTransform.position, Reflection.ProbePrefab);
			UpdateProbeProperties(ReflectionCur.Probe);
			UpdateProbeProperties(ReflectionSrc.Probe);
			UpdateProbeProperties(ReflectionDst.Probe);
			TOD_Util.Swap(ref ReflectionSrc, ref ReflectionDst);
			ReflectionDst.ProbeRenderID = ReflectionDst.Probe.RenderProbe();
		}
	}

	public bool ReflectionIsUpdating()
	{
		if (ReflectionDst.ProbeRenderID > 0)
		{
			return !ReflectionDst.Probe.IsFinishedRendering(ReflectionDst.ProbeRenderID);
		}
		return false;
	}

	private void UpdateProbeBlending(float lerp)
	{
		if (ReflectionCur.ProbeRenderID >= 0 && ReflectionSrc.ProbeRenderID >= 0 && ReflectionDst.ProbeRenderID >= 0)
		{
			ReflectionProbe.BlendCubemap((Texture)(object)ReflectionSrc.Probe.realtimeTexture, (Texture)(object)ReflectionDst.Probe.realtimeTexture, lerp, ReflectionCur.Probe.realtimeTexture);
		}
	}

	private void UpdateProbeProperties(ReflectionProbe probe)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		probe.mode = (ReflectionProbeMode)1;
		((Component)probe).transform.position = Components.DomeTransform.position;
		probe.intensity = RenderSettings.reflectionIntensity;
		probe.clearFlags = Reflection.ClearFlags;
		probe.cullingMask = LayerMask.op_Implicit(Reflection.CullingMask);
		probe.refreshMode = (ReflectionProbeRefreshMode)2;
		probe.timeSlicingMode = ReflectionTimeSlicing;
		probe.resolution = Mathf.ClosestPowerOfTwo(ReflectionResolution);
		if ((Object)(object)Components.Camera != (Object)null)
		{
			probe.backgroundColor = Components.Camera.BackgroundColor;
			if (!Object.op_Implicit((Object)(object)Reflection.ProbePrefab))
			{
				probe.nearClipPlane = Components.Camera.NearClipPlane;
				probe.farClipPlane = Components.Camera.FarClipPlane;
			}
		}
	}

	public Color SampleFogColor(bool directLight = true)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.forward;
		if ((Object)(object)Components.Camera != (Object)null)
		{
			Quaternion rotation = ((Component)Components.Camera).transform.rotation;
			val = Quaternion.Euler(0f, ((Quaternion)(ref rotation)).eulerAngles.y, 0f) * val;
		}
		Vector3 val2 = Vector3.Lerp(val, Vector3.up, Fog.HeightBias);
		Color val3 = SampleAtmosphere(((Vector3)(ref val2)).normalized, directLight);
		return new Color(val3.r, val3.g, val3.b, 1f);
	}

	public Color SampleSkyColor()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 sunDirection = SunDirection;
		sunDirection.y = Mathf.Abs(sunDirection.y);
		Color val = SampleAtmosphere(((Vector3)(ref sunDirection)).normalized, directLight: false);
		return new Color(val.r, val.g, val.b, 1f);
	}

	public Color SampleEquatorColor()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		Vector3 sunDirection = SunDirection;
		sunDirection.y = 0f;
		Color val = SampleAtmosphere(((Vector3)(ref sunDirection)).normalized, directLight: false);
		return new Color(val.r, val.g, val.b, 1f);
	}

	public void UpdateFog()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		switch (Fog.Mode)
		{
		case TOD_FogType.Atmosphere:
			RenderSettings.fogColor = SampleFogColor(directLight: false);
			break;
		case TOD_FogType.Directional:
			RenderSettings.fogColor = SampleFogColor();
			break;
		case TOD_FogType.Gradient:
			RenderSettings.fogColor = FogColor;
			break;
		case TOD_FogType.None:
			break;
		}
	}

	public void UpdateAmbient()
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		float saturation = Ambient.Saturation;
		float num = Mathf.Lerp(Night.AmbientMultiplier, Day.AmbientMultiplier, LerpValue);
		switch (Ambient.Mode)
		{
		case TOD_AmbientType.Color:
		{
			Color ambientLight2 = TOD_Util.AdjustRGB(AmbientColor, num, saturation);
			RenderSettings.ambientMode = (AmbientMode)3;
			RenderSettings.ambientLight = ambientLight2;
			RenderSettings.ambientIntensity = num;
			break;
		}
		case TOD_AmbientType.Gradient:
		{
			Color ambientGroundColor = TOD_Util.AdjustRGB(AmbientColor, num, saturation);
			Color ambientEquatorColor = TOD_Util.AdjustRGB(SampleEquatorColor(), num, saturation);
			Color ambientSkyColor = TOD_Util.AdjustRGB(SampleSkyColor(), num, saturation);
			RenderSettings.ambientMode = (AmbientMode)1;
			RenderSettings.ambientSkyColor = ambientSkyColor;
			RenderSettings.ambientEquatorColor = ambientEquatorColor;
			RenderSettings.ambientGroundColor = ambientGroundColor;
			RenderSettings.ambientIntensity = num;
			break;
		}
		case TOD_AmbientType.Spherical:
		{
			Color ambientLight = TOD_Util.AdjustRGB(AmbientColor, num, saturation);
			RenderSettings.ambientMode = (AmbientMode)0;
			RenderSettings.ambientLight = ambientLight;
			RenderSettings.ambientIntensity = num;
			RenderSettings.ambientProbe = RenderToSphericalHarmonics(num, saturation);
			break;
		}
		}
	}

	public void UpdateReflection()
	{
		if (Reflection.Mode == TOD_ReflectionType.Cubemap)
		{
			float reflectionIntensity = Mathf.Lerp(Night.ReflectionMultiplier, Day.ReflectionMultiplier, LerpValue);
			RenderSettings.defaultReflectionMode = (DefaultReflectionMode)0;
			RenderSettings.reflectionIntensity = reflectionIntensity;
			if (Application.isPlaying)
			{
				RenderToProbe();
			}
		}
	}

	public void DelayReflectionUpdate()
	{
		timeSinceReflectionUpdate = 0f;
	}

	public void LoadParameters(string xml)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Expected O, but got Unknown
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		using StringReader stringReader = new StringReader(xml);
		XmlTextReader val = new XmlTextReader((TextReader)stringReader);
		try
		{
			(new XmlSerializer(typeof(TOD_Parameters)).Deserialize((XmlReader)(object)val) as TOD_Parameters).ToSky(this);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public string SaveParameters()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Expected O, but got Unknown
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		using (StringWriter stringWriter = new StringWriter(stringBuilder))
		{
			XmlTextWriter val = new XmlTextWriter((TextWriter)stringWriter);
			try
			{
				val.Formatting = (Formatting)1;
				XmlSerializer val2 = new XmlSerializer(typeof(TOD_Parameters));
				TOD_Parameters tOD_Parameters = new TOD_Parameters(this);
				val2.Serialize((XmlWriter)(object)val, (object)tOD_Parameters);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		return stringBuilder.ToString();
	}

	public void SetClouds(bool state)
	{
		Components.Billboards.SetActive(state);
	}

	public void SetVClouds(bool state)
	{
		drawVClouds = state;
		Components.VCloudsRenderer.enabled = state;
		bool enabled = !state;
		for (int i = 0; i < Components.BillboardRenderers.Length; i++)
		{
			Components.BillboardRenderers[i].enabled = enabled;
		}
	}

	private void UpdateQualitySettings()
	{
		if (!Headless)
		{
			Mesh val = null;
			Mesh val2 = null;
			Mesh val3 = null;
			Mesh val4 = null;
			Mesh val5 = null;
			Mesh val6 = null;
			switch (MeshQuality)
			{
			case TOD_MeshQualityType.Low:
				val = Resources.SkyLOD2;
				val2 = Resources.SkyLOD2;
				val3 = Resources.SkyLOD2;
				val4 = Resources.CloudsLOD2;
				val5 = Resources.MoonLOD2;
				break;
			case TOD_MeshQualityType.Medium:
				val = Resources.SkyLOD1;
				val2 = Resources.SkyLOD1;
				val3 = Resources.SkyLOD2;
				val4 = Resources.CloudsLOD1;
				val5 = Resources.MoonLOD1;
				break;
			case TOD_MeshQualityType.High:
				val = Resources.SkyLOD0;
				val2 = Resources.SkyLOD0;
				val3 = Resources.SkyLOD2;
				val4 = Resources.CloudsLOD0;
				val5 = Resources.MoonLOD0;
				break;
			}
			switch (StarQuality)
			{
			case TOD_StarQualityType.Low:
				val6 = Resources.StarsLOD2;
				break;
			case TOD_StarQualityType.Medium:
				val6 = Resources.StarsLOD1;
				break;
			case TOD_StarQualityType.High:
				val6 = Resources.StarsLOD0;
				break;
			}
			if (Object.op_Implicit((Object)(object)Components.SpaceMeshFilter) && (Object)(object)Components.SpaceMeshFilter.sharedMesh != (Object)(object)val)
			{
				Components.SpaceMeshFilter.mesh = val;
			}
			if (Object.op_Implicit((Object)(object)Components.MoonMeshFilter) && (Object)(object)Components.MoonMeshFilter.sharedMesh != (Object)(object)val5)
			{
				Components.MoonMeshFilter.mesh = val5;
			}
			if (Object.op_Implicit((Object)(object)Components.AtmosphereMeshFilter) && (Object)(object)Components.AtmosphereMeshFilter.sharedMesh != (Object)(object)val2)
			{
				Components.AtmosphereMeshFilter.mesh = val2;
			}
			if (Object.op_Implicit((Object)(object)Components.ClearMeshFilter) && (Object)(object)Components.ClearMeshFilter.sharedMesh != (Object)(object)val3)
			{
				Components.ClearMeshFilter.mesh = val3;
			}
			if (Object.op_Implicit((Object)(object)Components.CloudMeshFilter) && (Object)(object)Components.CloudMeshFilter.sharedMesh != (Object)(object)val4)
			{
				Components.CloudMeshFilter.mesh = val4;
			}
			if (Object.op_Implicit((Object)(object)Components.StarMeshFilter) && (Object)(object)Components.StarMeshFilter.sharedMesh != (Object)(object)val6)
			{
				Components.StarMeshFilter.mesh = val6;
			}
		}
	}

	private void UpdateRenderSettings()
	{
		if (Headless)
		{
			return;
		}
		UpdateFog();
		if (!Application.isPlaying || timeSinceAmbientUpdate >= Ambient.UpdateInterval)
		{
			timeSinceAmbientUpdate = 0f;
			UpdateAmbient();
		}
		else
		{
			timeSinceAmbientUpdate += Time.deltaTime;
		}
		if (!Application.isPlaying || timeSinceReflectionUpdate >= ReflectionUpdateInterval)
		{
			timeSinceReflectionUpdate = 0f;
			UpdateReflection();
		}
		else if (!ReflectionIsUpdating())
		{
			timeSinceReflectionUpdate += Time.deltaTime * ReflectionUpdateSpeed;
			if (Application.isPlaying)
			{
				UpdateProbeBlending((ReflectionUpdateInterval > 0f) ? (timeSinceReflectionUpdate / ReflectionUpdateInterval) : 1f);
			}
		}
	}

	private void UpdateShaderKeywords()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Invalid comparison between Unknown and I4
		if (Headless)
		{
			return;
		}
		switch (ColorSpace)
		{
		case TOD_ColorSpaceType.Auto:
			if ((int)QualitySettings.activeColorSpace == 1)
			{
				Shader.EnableKeyword("TOD_OUTPUT_LINEAR");
			}
			else
			{
				Shader.DisableKeyword("TOD_OUTPUT_LINEAR");
			}
			break;
		case TOD_ColorSpaceType.Linear:
			Shader.EnableKeyword("TOD_OUTPUT_LINEAR");
			break;
		case TOD_ColorSpaceType.Gamma:
			Shader.DisableKeyword("TOD_OUTPUT_LINEAR");
			break;
		}
		switch (ColorRange)
		{
		case TOD_ColorRangeType.Auto:
			if (Object.op_Implicit((Object)(object)Components.Camera) && Components.Camera.HDR)
			{
				Shader.EnableKeyword("TOD_OUTPUT_HDR");
			}
			else
			{
				Shader.DisableKeyword("TOD_OUTPUT_HDR");
			}
			break;
		case TOD_ColorRangeType.HDR:
			Shader.EnableKeyword("TOD_OUTPUT_HDR");
			break;
		case TOD_ColorRangeType.LDR:
			Shader.DisableKeyword("TOD_OUTPUT_HDR");
			break;
		}
		switch (ColorOutput)
		{
		case TOD_ColorOutputType.Raw:
			Shader.DisableKeyword("TOD_OUTPUT_DITHERING");
			break;
		case TOD_ColorOutputType.Dithered:
			Shader.EnableKeyword("TOD_OUTPUT_DITHERING");
			break;
		}
		switch (SkyQuality)
		{
		case TOD_SkyQualityType.PerVertex:
			Shader.DisableKeyword("TOD_SCATTERING_PER_PIXEL");
			break;
		case TOD_SkyQualityType.PerPixel:
			Shader.EnableKeyword("TOD_SCATTERING_PER_PIXEL");
			break;
		}
		switch (CloudQuality)
		{
		case TOD_CloudQualityType.Low:
			Shader.DisableKeyword("TOD_CLOUDS_DENSITY");
			Shader.DisableKeyword("TOD_CLOUDS_BUMPED");
			break;
		case TOD_CloudQualityType.Medium:
			Shader.EnableKeyword("TOD_CLOUDS_DENSITY");
			Shader.DisableKeyword("TOD_CLOUDS_BUMPED");
			break;
		case TOD_CloudQualityType.High:
			Shader.EnableKeyword("TOD_CLOUDS_DENSITY");
			Shader.EnableKeyword("TOD_CLOUDS_BUMPED");
			break;
		}
	}

	private void UpdateShaderProperties()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0430: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_057a: Unknown result type (might be due to invalid IL or missing references)
		//IL_057f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0595: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0617: Unknown result type (might be due to invalid IL or missing references)
		if (!Headless)
		{
			Shader.SetGlobalColor(Resources.ID_SunLightColor, SunLightColor);
			Shader.SetGlobalColor(Resources.ID_MoonLightColor, MoonLightColor);
			Shader.SetGlobalColor(Resources.ID_SunSkyColor, SunSkyColor);
			Shader.SetGlobalColor(Resources.ID_MoonSkyColor, MoonSkyColor);
			Shader.SetGlobalColor(Resources.ID_SunMeshColor, SunMeshColor);
			Shader.SetGlobalColor(Resources.ID_MoonMeshColor, MoonMeshColor);
			Shader.SetGlobalColor(Resources.ID_SunCloudColor, SunCloudColor);
			Shader.SetGlobalColor(Resources.ID_MoonCloudColor, MoonCloudColor);
			Shader.SetGlobalColor(Resources.ID_FogColor, FogColor);
			Shader.SetGlobalColor(Resources.ID_GroundColor, GroundColor);
			Shader.SetGlobalColor(Resources.ID_AmbientColor, AmbientColor);
			Shader.SetGlobalVector(Resources.ID_SunDirection, Vector4.op_Implicit(SunDirection));
			Shader.SetGlobalVector(Resources.ID_MoonDirection, Vector4.op_Implicit(MoonDirection));
			Shader.SetGlobalVector(Resources.ID_LightDirection, Vector4.op_Implicit(LightDirection));
			Shader.SetGlobalVector(Resources.ID_LocalSunDirection, Vector4.op_Implicit(LocalSunDirection));
			Shader.SetGlobalVector(Resources.ID_LocalMoonDirection, Vector4.op_Implicit(LocalMoonDirection));
			Shader.SetGlobalVector(Resources.ID_LocalLightDirection, Vector4.op_Implicit(LocalLightDirection));
			Shader.SetGlobalFloat(Resources.ID_Contrast, Atmosphere.Contrast);
			Shader.SetGlobalFloat(Resources.ID_Brightness, Atmosphere.Brightness);
			Shader.SetGlobalFloat(Resources.ID_Fogginess, Atmosphere.Fogginess);
			Shader.SetGlobalFloat(Resources.ID_Directionality, Atmosphere.Directionality);
			Shader.SetGlobalFloat(Resources.ID_NightBrightness, Atmosphere.NightBrightness);
			Shader.SetGlobalFloat(Resources.ID_NightContrast, Atmosphere.NightContrast);
			Shader.SetGlobalFloat(Resources.ID_MoonHaloPower, 1f / Moon.HaloSize);
			Shader.SetGlobalColor(Resources.ID_MoonHaloColor, MoonHaloColor);
			float num = Mathf.Lerp(0.8f, 0f, Clouds.Coverage);
			float num2 = Mathf.Lerp(3f, 9f, Clouds.Sharpness);
			float num3 = Mathf.Lerp(0f, 1f, Clouds.Attenuation);
			float num4 = Mathf.Lerp(0f, 2f, Clouds.Saturation);
			Shader.SetGlobalFloat(Resources.ID_CloudOpacity, Clouds.Opacity);
			Shader.SetGlobalFloat(Resources.ID_CloudCoverage, num);
			Shader.SetGlobalFloat(Resources.ID_CloudSharpness, 1f / num2);
			Shader.SetGlobalFloat(Resources.ID_CloudDensity, num2);
			Shader.SetGlobalFloat(Resources.ID_CloudColoring, Clouds.Coloring);
			Shader.SetGlobalFloat(Resources.ID_CloudAttenuation, num3);
			Shader.SetGlobalFloat(Resources.ID_CloudSaturation, num4);
			Shader.SetGlobalFloat(Resources.ID_CloudScattering, Clouds.Scattering);
			Shader.SetGlobalFloat(Resources.ID_CloudBrightness, Clouds.Brightness);
			Shader.SetGlobalVector(Resources.ID_CloudOffset, Vector4.op_Implicit(Components.Animation.OffsetUV));
			Shader.SetGlobalVector(Resources.ID_CloudWind, Vector4.op_Implicit(Components.Animation.CloudUV));
			Shader.SetGlobalVector(Resources.ID_CloudSize, Vector4.op_Implicit(new Vector3(Clouds.Size * 4f, Clouds.Size, Clouds.Size * 4f)));
			Shader.SetGlobalFloat(Resources.ID_StarSize, Stars.Size);
			Shader.SetGlobalFloat(Resources.ID_StarBrightness, Stars.Brightness);
			Shader.SetGlobalFloat(Resources.ID_StarVisibility, (1f - Atmosphere.Fogginess) * (1f - LerpValue));
			Shader.SetGlobalColor(Resources.ID_StarColorScale, ((Color)(ref Stars.ColorScale)).linear);
			Shader.SetGlobalFloat(Resources.ID_SunMeshContrast, 1f / Mathf.Max(0.001f, Sun.MeshContrast));
			Shader.SetGlobalFloat(Resources.ID_SunMeshBrightness, Sun.MeshBrightness * (1f - Atmosphere.Fogginess));
			Shader.SetGlobalFloat(Resources.ID_MoonMeshContrast, 1f / Mathf.Max(0.001f, Moon.MeshContrast));
			Shader.SetGlobalFloat(Resources.ID_MoonMeshBrightness, Moon.MeshBrightness * (1f - Atmosphere.Fogginess));
			Shader.SetGlobalVector(Resources.ID_kBetaMie, Vector4.op_Implicit(kBetaMie));
			Shader.SetGlobalVector(Resources.ID_kSun, kSun);
			Shader.SetGlobalVector(Resources.ID_k4PI, k4PI);
			Shader.SetGlobalVector(Resources.ID_kRadius, kRadius);
			Shader.SetGlobalVector(Resources.ID_kScale, kScale);
			Shader.SetGlobalMatrix(Resources.ID_World2Sky, Components.DomeTransform.worldToLocalMatrix);
			Shader.SetGlobalMatrix(Resources.ID_Sky2World, Components.DomeTransform.localToWorldMatrix);
		}
	}

	private float ShaderScale(float inCos)
	{
		float num = 1f - inCos;
		return 0.25f * Mathf.Exp(-0.00287f + num * (0.459f + num * (3.83f + num * (-6.8f + num * 5.25f))));
	}

	private float ShaderMiePhase(float eyeCos, float eyeCos2)
	{
		return kBetaMie.x * (1f + eyeCos2) / Mathf.Pow(kBetaMie.y + kBetaMie.z * eyeCos, 1.5f);
	}

	private float ShaderRayleighPhase(float eyeCos2)
	{
		return 0.75f + 0.75f * eyeCos2;
	}

	private Color ShaderNightSkyColor(Vector3 dir)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		dir.y = Mathf.Max(0f, dir.y);
		return MoonSkyColor * (1f - 0.75f * dir.y);
	}

	private Color ShaderMoonHaloColor(Vector3 dir)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		return MoonHaloColor * Mathf.Pow(Mathf.Max(0f, Vector3.Dot(dir, LocalMoonDirection)), 1f / Mathf.Lerp(Moon.MeshSize, Moon.MeshSizeRed, Cycle.RedMoonLerp));
	}

	private Color TOD_HDR2LDR(Color color)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		return new Color(1f - Mathf.Pow(2f, (0f - Atmosphere.Brightness) * color.r), 1f - Mathf.Pow(2f, (0f - Atmosphere.Brightness) * color.g), 1f - Mathf.Pow(2f, (0f - Atmosphere.Brightness) * color.b), color.a);
	}

	private Color TOD_GAMMA2LINEAR(Color color)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		return new Color(color.r * color.r, color.g * color.g, color.b * color.b, color.a);
	}

	private Color TOD_LINEAR2GAMMA(Color color)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		return new Color(Mathf.Sqrt(color.r), Mathf.Sqrt(color.g), Mathf.Sqrt(color.b), color.a);
	}

	private Color ShaderScatteringColor(Vector3 dir, bool directLight = true)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_031d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		//IL_033e: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_039a: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0440: Unknown result type (might be due to invalid IL or missing references)
		//IL_034c: Unknown result type (might be due to invalid IL or missing references)
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_0356: Unknown result type (might be due to invalid IL or missing references)
		//IL_0362: Unknown result type (might be due to invalid IL or missing references)
		//IL_036e: Unknown result type (might be due to invalid IL or missing references)
		dir.y = Mathf.Max(0f, dir.y);
		float x = kRadius.x;
		float y = kRadius.y;
		float w = kRadius.w;
		float x2 = kScale.x;
		float z = kScale.z;
		float w2 = kScale.w;
		float x3 = k4PI.x;
		float y2 = k4PI.y;
		float z2 = k4PI.z;
		float w3 = k4PI.w;
		float x4 = kSun.x;
		float y3 = kSun.y;
		float z3 = kSun.z;
		float w4 = kSun.w;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(0f, x + w2, 0f);
		float num = Mathf.Sqrt(w + y * dir.y * dir.y - y) - x * dir.y;
		float num2 = Mathf.Exp(z * (0f - w2));
		float inCos = Vector3.Dot(dir, val) / (x + w2);
		float num3 = num2 * ShaderScale(inCos);
		float num4 = num / 2f;
		float num5 = num4 * x2;
		Vector3 val2 = dir * num4;
		Vector3 val3 = val + val2 * 0.5f;
		float num6 = 0f;
		float num7 = 0f;
		float num8 = 0f;
		for (int i = 0; i < 2; i++)
		{
			float magnitude = ((Vector3)(ref val3)).magnitude;
			float num9 = 1f / magnitude;
			float num10 = Mathf.Exp(z * (x - magnitude));
			float num11 = num10 * num5;
			float inCos2 = Vector3.Dot(dir, val3) * num9;
			float inCos3 = Vector3.Dot(LocalSunDirection, val3) * num9;
			float num12 = num3 + num10 * (ShaderScale(inCos3) - ShaderScale(inCos2));
			float num13 = Mathf.Exp((0f - num12) * (x3 + w3));
			float num14 = Mathf.Exp((0f - num12) * (y2 + w3));
			float num15 = Mathf.Exp((0f - num12) * (z2 + w3));
			num6 += num13 * num11;
			num7 += num14 * num11;
			num8 += num15 * num11;
			val3 += val2;
		}
		float num16 = SunSkyColor.r * num6 * x4;
		float num17 = SunSkyColor.g * num7 * y3;
		float num18 = SunSkyColor.b * num8 * z3;
		float num19 = SunSkyColor.r * num6 * w4;
		float num20 = SunSkyColor.g * num7 * w4;
		float num21 = SunSkyColor.b * num8 * w4;
		float num22 = 0f;
		float num23 = 0f;
		float num24 = 0f;
		float num25 = Vector3.Dot(LocalSunDirection, dir);
		float eyeCos = num25 * num25;
		float num26 = ShaderRayleighPhase(eyeCos);
		num22 += num26 * num16;
		num23 += num26 * num17;
		num24 += num26 * num18;
		if (directLight)
		{
			float num27 = ShaderMiePhase(num25, eyeCos);
			num22 += num27 * num19;
			num23 += num27 * num20;
			num24 += num27 * num21;
		}
		Color val4 = ShaderNightSkyColor(dir);
		num22 += val4.r;
		num23 += val4.g;
		num24 += val4.b;
		if (directLight)
		{
			Color val5 = ShaderMoonHaloColor(dir);
			num22 += val5.r;
			num23 += val5.g;
			num24 += val5.b;
		}
		num22 = Mathf.Lerp(num22, FogColor.r, Atmosphere.Fogginess);
		num23 = Mathf.Lerp(num23, FogColor.g, Atmosphere.Fogginess);
		num24 = Mathf.Lerp(num24, FogColor.b, Atmosphere.Fogginess);
		num22 = Mathf.Pow(num22 * Atmosphere.Brightness, Atmosphere.Contrast);
		num23 = Mathf.Pow(num23 * Atmosphere.Brightness, Atmosphere.Contrast);
		num24 = Mathf.Pow(num24 * Atmosphere.Brightness, Atmosphere.Contrast);
		return new Color(num22, num23, num24, 1f);
	}

	private void Initialize()
	{
		Components = ((Component)this).GetComponent<TOD_Components>();
		Components.Initialize();
		Resources = ((Component)this).GetComponent<TOD_Resources>();
		Resources.Initialize();
		instances.Add(this);
		Initialized = true;
	}

	private void Cleanup()
	{
		if (Object.op_Implicit((Object)(object)Probe))
		{
			Object.Destroy((Object)(object)((Component)Probe).gameObject);
		}
		instances.Remove(this);
		Initialized = false;
	}

	protected void OnEnable()
	{
		LateUpdate();
	}

	protected void OnDisable()
	{
		Cleanup();
	}

	protected void LateUpdate()
	{
		if (!Initialized)
		{
			Initialize();
		}
		UpdateScattering();
		UpdateCelestials();
		UpdateQualitySettings();
		UpdateRenderSettings();
		UpdateShaderKeywords();
		UpdateShaderProperties();
	}

	protected void OnValidate()
	{
		Cycle.DateTime = Cycle.DateTime;
	}

	public float GetDayTime()
	{
		return Mathf.Clamp01(SunZenith / 90f);
	}

	public float GetNightTime()
	{
		return Mathf.Clamp01((SunZenith - 90f) / 90f);
	}

	private void UpdateScattering()
	{
		float num = 0f - Atmosphere.Directionality;
		float num2 = num * num;
		kBetaMie.x = 1.5f * ((1f - num2) / (2f + num2));
		kBetaMie.y = 1f + num2;
		kBetaMie.z = 2f * num;
		float num3 = 0.002f * Atmosphere.MieMultiplier;
		float num4 = 0.002f * Atmosphere.RayleighMultiplier;
		float x = num4 * 40f * 5.2701645f;
		float y = num4 * 40f * 9.473284f;
		float z = num4 * 40f * 19.643803f;
		float w = num3 * 40f;
		kSun.x = x;
		kSun.y = y;
		kSun.z = z;
		kSun.w = w;
		float x2 = num4 * 4f * (float)Math.PI * 5.2701645f;
		float y2 = num4 * 4f * (float)Math.PI * 9.473284f;
		float z2 = num4 * 4f * (float)Math.PI * 19.643803f;
		float w2 = num3 * 4f * (float)Math.PI;
		k4PI.x = x2;
		k4PI.y = y2;
		k4PI.z = z2;
		k4PI.w = w2;
		kRadius.x = 1f;
		kRadius.y = 1f;
		kRadius.z = 1.025f;
		kRadius.w = 1.050625f;
		kScale.x = 40.00004f;
		kScale.y = 0.25f;
		kScale.z = 160.00015f;
		kScale.w = 0.0001f;
	}

	private void UpdateCelestials()
	{
		//IL_06d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_073e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0753: Unknown result type (might be due to invalid IL or missing references)
		//IL_0718: Unknown result type (might be due to invalid IL or missing references)
		//IL_072a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0760: Unknown result type (might be due to invalid IL or missing references)
		//IL_0765: Unknown result type (might be due to invalid IL or missing references)
		//IL_0772: Unknown result type (might be due to invalid IL or missing references)
		//IL_078f: Unknown result type (might be due to invalid IL or missing references)
		//IL_079f: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0832: Unknown result type (might be due to invalid IL or missing references)
		//IL_088a: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0915: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a79: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a7e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a96: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a9b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ab3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ab8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ad0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ad5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aed: Unknown result type (might be due to invalid IL or missing references)
		//IL_0af2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b0a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b0f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b27: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b2c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b43: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b48: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b57: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b5c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b5f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b61: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b6e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b73: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b8b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b90: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ba8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bc4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bc9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bdd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0be2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0be7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bf4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c0b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c10: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c15: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c24: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c29: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c2e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c31: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c33: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c3b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c45: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c47: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c49: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c4b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c4e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c50: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c58: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c64: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c77: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d09: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d0e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cc7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ccc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d1b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dc9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d9b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ddb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0df8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e22: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e27: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e3e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e43: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e59: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e5e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e75: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e7a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e90: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e95: Unknown result type (might be due to invalid IL or missing references)
		//IL_0eac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0eb1: Unknown result type (might be due to invalid IL or missing references)
		float num = (float)Math.PI / 180f * World.Latitude;
		float num2 = Mathf.Sin(num);
		float num3 = Mathf.Cos(num);
		float longitude = World.Longitude;
		float num4 = (float)Math.PI / 2f;
		int year = Cycle.Year;
		int month = Cycle.Month;
		int day = Cycle.Day;
		float num5 = Cycle.Hour - World.UTC;
		float num6 = (float)(367 * year - 7 * (year + (month + 9) / 12) / 4 + 275 * month / 9 + day - 730530) + num5 / 24f;
		float num7 = (float)(367 * year - 7 * (year + (month + 9) / 12) / 4 + 275 * month / 9 + day - 730530) + 0.5f;
		float num8 = 23.4393f - 3.563E-07f * num6;
		float num9 = (float)Math.PI / 180f * num8;
		float num10 = Mathf.Sin(num9);
		float num11 = Mathf.Cos(num9);
		float num12 = 282.9404f + 4.70935E-05f * num7;
		float num13 = 0.016709f - 1.151E-09f * num7;
		float num14 = 356.047f + 0.98560023f * num7;
		float num15 = (float)Math.PI / 180f * num14;
		float num16 = Mathf.Sin(num15);
		float num17 = Mathf.Cos(num15);
		float num18 = num15 + num13 * num16 * (1f + num13 * num17);
		float num19 = Mathf.Sin(num18);
		float num20 = Mathf.Cos(num18) - num13;
		float num21 = Mathf.Sqrt(1f - num13 * num13) * num19;
		float num22 = 57.29578f * Mathf.Atan2(num21, num20);
		float num23 = Mathf.Sqrt(num20 * num20 + num21 * num21);
		float num24 = num22 + num12;
		float num25 = (float)Math.PI / 180f * num24;
		float num26 = Mathf.Sin(num25);
		float num27 = Mathf.Cos(num25);
		float num28 = num23 * num27;
		float num29 = num23 * num26;
		float num30 = num28;
		float num31 = num29 * num11;
		float num32 = num29 * num10;
		float num33 = Mathf.Atan2(num31, num30);
		float num34 = 57.29578f * num33;
		float num35 = Mathf.Atan2(num32, Mathf.Sqrt(num30 * num30 + num31 * num31));
		float num36 = Mathf.Sin(num35);
		float num37 = Mathf.Cos(num35);
		float num38 = num22 + num12 + 180f;
		float num39 = num34 - num38 - longitude;
		float num40 = -6f;
		float num41 = Mathf.Acos((Mathf.Sin((float)Math.PI / 180f * num40) - num2 * num36) / (num3 * num37));
		float num42 = 57.29578f * num41;
		SunsetTime = (24f + (num39 + num42) / 15f % 24f) % 24f;
		SunriseTime = (24f + (num39 - num42) / 15f % 24f) % 24f;
		float num43 = 282.9404f + 4.70935E-05f * num6;
		float num44 = 0.016709f - 1.151E-09f * num6;
		float num45 = 356.047f + 0.98560023f * num6;
		float num46 = (float)Math.PI / 180f * num45;
		float num47 = Mathf.Sin(num46);
		float num48 = Mathf.Cos(num46);
		float num49 = num46 + num44 * num47 * (1f + num44 * num48);
		float num50 = Mathf.Sin(num49);
		float num51 = Mathf.Cos(num49) - num44;
		float num52 = Mathf.Sqrt(1f - num44 * num44) * num50;
		float num53 = 57.29578f * Mathf.Atan2(num52, num51);
		float num54 = Mathf.Sqrt(num51 * num51 + num52 * num52);
		float num55 = num53 + num43;
		float num56 = (float)Math.PI / 180f * num55;
		float num57 = Mathf.Sin(num56);
		float num58 = Mathf.Cos(num56);
		float num59 = num54 * num58;
		float num60 = num54 * num57;
		float num61 = num59;
		float num62 = num60 * num11;
		float num63 = num60 * num10;
		float num64 = Mathf.Atan2(num62, num61);
		float num65 = Mathf.Atan2(num63, Mathf.Sqrt(num61 * num61 + num62 * num62));
		float num66 = Mathf.Sin(num65);
		float num67 = Mathf.Cos(num65);
		float num68 = num53 + num43 + 180f + 15f * num5;
		float num69 = (float)Math.PI / 180f * (num68 + longitude);
		LocalSiderealTime = (num68 + longitude) / 15f;
		float num70 = num69 - num64;
		float num71 = Mathf.Sin(num70);
		float num72 = Mathf.Cos(num70) * num67;
		float num73 = num71 * num67;
		float num74 = num66;
		float num75 = num72 * num2 - num74 * num3;
		float num76 = num73;
		float num77 = num72 * num3 + num74 * num2;
		float num78 = Mathf.Atan2(num76, num75) + (float)Math.PI;
		float num79 = Mathf.Atan2(num77, Mathf.Sqrt(num75 * num75 + num76 * num76));
		float num80 = num4 - num79;
		float num81 = num79;
		float num82 = num78;
		SunZenith = 57.29578f * num80;
		SunAltitude = 57.29578f * num81;
		SunAzimuth = 57.29578f * num82;
		float num131;
		float num132;
		float num133;
		if (Moon.Position == TOD_MoonPositionType.Realistic)
		{
			float num83 = 125.1228f - 0.05295381f * num6;
			float num84 = 5.1454f;
			float num85 = 318.0634f + 0.16435732f * num6;
			float num86 = 0.0549f;
			float num87 = 115.3654f + 13.064993f * num6;
			float num88 = (float)Math.PI / 180f * num83;
			float num89 = Mathf.Sin(num88);
			float num90 = Mathf.Cos(num88);
			float num91 = (float)Math.PI / 180f * num84;
			float num92 = Mathf.Sin(num91);
			float num93 = Mathf.Cos(num91);
			float num94 = (float)Math.PI / 180f * num87;
			float num95 = Mathf.Sin(num94);
			float num96 = Mathf.Cos(num94);
			float num97 = num94 + num86 * num95 * (1f + num86 * num96);
			float num98 = Mathf.Sin(num97);
			float num99 = Mathf.Cos(num97);
			float num100 = 60.2666f * (num99 - num86);
			float num101 = 60.2666f * (Mathf.Sqrt(1f - num86 * num86) * num98);
			float num102 = 57.29578f * Mathf.Atan2(num101, num100);
			float num103 = Mathf.Sqrt(num100 * num100 + num101 * num101);
			float num104 = num102 + num85;
			float num105 = (float)Math.PI / 180f * num104;
			float num106 = Mathf.Sin(num105);
			float num107 = Mathf.Cos(num105);
			float num108 = num103 * (num90 * num107 - num89 * num106 * num93);
			float num109 = num103 * (num89 * num107 + num90 * num106 * num93);
			float num110 = num103 * (num106 * num92);
			float num111 = num108;
			float num112 = num109;
			float num113 = num110;
			float num114 = num111;
			float num115 = num112 * num11 - num113 * num10;
			float num116 = num112 * num10 + num113 * num11;
			float num117 = Mathf.Atan2(num115, num114);
			float num118 = Mathf.Atan2(num116, Mathf.Sqrt(num114 * num114 + num115 * num115));
			float num119 = Mathf.Sin(num118);
			float num120 = Mathf.Cos(num118);
			float num121 = num69 - num117;
			float num122 = Mathf.Sin(num121);
			float num123 = Mathf.Cos(num121) * num120;
			float num124 = num122 * num120;
			float num125 = num119;
			float num126 = num123 * num2 - num125 * num3;
			float num127 = num124;
			float num128 = num123 * num3 + num125 * num2;
			float num129 = Mathf.Atan2(num127, num126) + (float)Math.PI;
			float num130 = Mathf.Atan2(num128, Mathf.Sqrt(num126 * num126 + num127 * num127));
			num131 = num4 - num130;
			num132 = num130;
			num133 = num129;
		}
		else
		{
			num131 = num80 - (float)Math.PI;
			num132 = num81 - (float)Math.PI;
			num133 = num82;
		}
		MoonZenith = 57.29578f * num131;
		MoonAltitude = 57.29578f * num132;
		MoonAzimuth = 57.29578f * num133;
		Quaternion val = Quaternion.Euler(90f - World.Latitude, 0f, 0f) * Quaternion.Euler(0f, 180f + num69 * 57.29578f, 0f);
		if (Stars.Position == TOD_StarsPositionType.Rotating)
		{
			Components.SpaceTransform.localRotation = val;
			Components.StarTransform.localRotation = val;
		}
		else
		{
			Components.SpaceTransform.localRotation = Quaternion.identity;
			Components.StarTransform.localRotation = Quaternion.identity;
		}
		Vector3 localPosition = OrbitalToLocal(num80, num82);
		Components.SunTransform.localPosition = localPosition;
		Components.SunTransform.LookAt(Components.DomeTransform.position, Components.SunTransform.up);
		Vector3 localPosition2 = OrbitalToLocal(num131, num133);
		Vector3 val2 = val * -Vector3.right;
		Components.MoonTransform.localPosition = localPosition2;
		Components.MoonTransform.LookAt(Components.DomeTransform.position, val2);
		float num134 = 8f * Mathf.Tan((float)Math.PI / 360f * Sun.MeshSize);
		Vector3 localScale = default(Vector3);
		((Vector3)(ref localScale))..ctor(num134, num134, num134);
		Components.SunTransform.localScale = localScale;
		float num135 = 4f * Mathf.Tan((float)Math.PI / 360f * Mathf.Lerp(Moon.MeshSize, Moon.MeshSizeRed, Cycle.RedMoonLerp));
		Vector3 localScale2 = default(Vector3);
		((Vector3)(ref localScale2))..ctor(num135, num135, num135);
		Components.MoonTransform.localScale = localScale2;
		bool enabled = (1f - Atmosphere.Fogginess) * (1f - LerpValue) > 0f;
		Components.SpaceRenderer.enabled = enabled;
		Components.StarRenderer.enabled = enabled;
		bool enabled2 = Components.SunTransform.localPosition.y > 0f - num134;
		Components.SunRenderer.enabled = enabled2;
		bool enabled3 = Components.MoonTransform.localPosition.y > 0f - num135;
		Components.MoonRenderer.enabled = enabled3;
		bool enabled4 = true;
		Components.AtmosphereRenderer.enabled = enabled4;
		bool enabled5 = false;
		Components.ClearRenderer.enabled = enabled5;
		bool enabled6 = Clouds.Coverage > 0f && Clouds.Opacity > 0f && !drawVClouds;
		Components.CloudRenderer.enabled = enabled6;
		Components.VCloudsRenderer.enabled = drawVClouds;
		LerpValue = Mathf.InverseLerp(105f, 90f, SunZenith);
		float dayTime = GetDayTime();
		float nightTime = GetNightTime();
		float num136 = Mathf.Clamp01((LerpValue - 0.1f) / 0.9f);
		float num137 = Mathf.Clamp01((0.1f - LerpValue) / 0.1f);
		float num138 = Mathf.Clamp01((90f - num131 * 57.29578f) / 5f);
		SunVisibility = (1f - Atmosphere.Fogginess) * num136;
		MoonVisibility = (1f - Atmosphere.Fogginess) * num137 * num138;
		SunLightColor = TOD_Util.ApplyAlpha(Day.LightColor.Evaluate(dayTime));
		MoonLightColor = TOD_Util.ApplyAlpha(Night.LightColor.Evaluate(nightTime));
		SunRayColor = TOD_Util.ApplyAlpha(Day.RayColor.Evaluate(dayTime));
		MoonRayColor = TOD_Util.ApplyAlpha(Night.RayColor.Evaluate(nightTime));
		SunSkyColor = TOD_Util.ApplyAlpha(Day.SkyColor.Evaluate(dayTime));
		MoonSkyColor = TOD_Util.ApplyAlpha(Night.SkyColor.Evaluate(nightTime));
		SunMeshColor = TOD_Util.ApplyAlpha(Day.SunColor.Evaluate(dayTime));
		Color val3 = Night.MoonColor.Evaluate(nightTime);
		Color val4 = Night.MoonColorRed.Evaluate(nightTime);
		MoonMeshColor = TOD_Util.ApplyAlpha(Color.Lerp(val3, val4, Cycle.RedMoonLerp));
		SunCloudColor = TOD_Util.ApplyAlpha(Day.CloudColor.Evaluate(dayTime));
		MoonCloudColor = TOD_Util.ApplyAlpha(Night.CloudColor.Evaluate(nightTime));
		Color val5 = TOD_Util.ApplyAlpha(Day.FogColor.Evaluate(dayTime));
		Color val6 = TOD_Util.ApplyAlpha(Night.FogColor.Evaluate(nightTime));
		FogColor = Color.Lerp(val6, val5, LerpValue);
		Color val7 = TOD_Util.ApplyAlpha(Day.AmbientColor.Evaluate(dayTime));
		Color val8 = TOD_Util.ApplyAlpha(Night.AmbientColor.Evaluate(nightTime));
		AmbientColor = Color.Lerp(val8, val7, LerpValue);
		Color val9 = val7;
		Color val10 = val8;
		GroundColor = Color.Lerp(val10, val9, LerpValue);
		MoonHaloColor = TOD_Util.MulRGB(MoonSkyColor, Moon.HaloBrightness * num138);
		float shadowStrength;
		float intensity;
		Color color;
		if (LerpValue > 0.1f)
		{
			IsDay = true;
			IsNight = false;
			shadowStrength = Day.ShadowStrength;
			intensity = Mathf.Lerp(0f, Day.LightIntensity, SunVisibility);
			color = SunLightColor;
		}
		else
		{
			IsDay = false;
			IsNight = true;
			shadowStrength = Night.ShadowStrength;
			intensity = Mathf.Lerp(0f, Night.LightIntensity, MoonVisibility);
			color = MoonLightColor;
		}
		Components.LightSource.color = color;
		Components.LightSource.intensity = intensity;
		Components.LightSource.shadowStrength = shadowStrength;
		if (!Application.isPlaying || timeSinceLightUpdate >= Light.UpdateInterval)
		{
			timeSinceLightUpdate = 0f;
			Vector3 localPosition3 = (IsNight ? OrbitalToLocal(Mathf.Min(num131, (1f - Light.MinimumHeight) * (float)Math.PI / 2f), num133) : OrbitalToLocal(Mathf.Min(num80, (1f - Light.MinimumHeight) * (float)Math.PI / 2f), num82));
			Components.LightTransform.localPosition = localPosition3;
			Components.LightTransform.LookAt(Components.DomeTransform.position);
		}
		else
		{
			timeSinceLightUpdate += Time.deltaTime;
		}
		SunDirection = -Components.SunTransform.forward;
		LocalSunDirection = Components.DomeTransform.InverseTransformDirection(SunDirection);
		MoonDirection = -Components.MoonTransform.forward;
		LocalMoonDirection = Components.DomeTransform.InverseTransformDirection(MoonDirection);
		LightDirection = -Components.LightTransform.forward;
		LocalLightDirection = Components.DomeTransform.InverseTransformDirection(LightDirection);
	}
}


using System;
using UnityEngine;

public class TOD_Time : MonoBehaviour
{
	[Tooltip("Length of one day in minutes.")]
	[TOD_Min(0f)]
	public float DayLengthInMinutes = 30f;

	[Tooltip("Progress time at runtime.")]
	public bool ProgressTime = true;

	[Tooltip("Set the date to the current device date on start.")]
	public bool UseDeviceDate;

	[Tooltip("Set the time to the current device time on start.")]
	public bool UseDeviceTime;

	[Tooltip("Apply the time curve when progressing time.")]
	public bool UseTimeCurve;

	[Tooltip("Time progression curve.")]
	public AnimationCurve TimeCurve = AnimationCurve.Linear(0f, 0f, 24f, 24f);

	private TOD_Sky sky;

	private AnimationCurve timeCurve;

	private AnimationCurve timeCurveInverse;

	private float timeFraction;

	public event Action OnSecond;

	public event Action OnMinute;

	public event Action OnHour;

	public event Action OnDay;

	public event Action OnMonth;

	public event Action OnYear;

	public event Action OnSunrise;

	public event Action OnSunset;

	public void RefreshTimeCurve()
	{
		TimeCurve.preWrapMode = (WrapMode)1;
		TimeCurve.postWrapMode = (WrapMode)1;
		ApproximateCurve(TimeCurve, out timeCurve, out timeCurveInverse);
		timeCurve.preWrapMode = (WrapMode)2;
		timeCurve.postWrapMode = (WrapMode)2;
		timeCurveInverse.preWrapMode = (WrapMode)2;
		timeCurveInverse.postWrapMode = (WrapMode)2;
	}

	public float ApplyTimeCurve(float deltaTime)
	{
		float num = timeCurveInverse.Evaluate(sky.Cycle.Hour) + deltaTime;
		deltaTime = timeCurve.Evaluate(num) - sky.Cycle.Hour;
		if (num >= 24f)
		{
			deltaTime += (float)((int)num / 24 * 24);
		}
		else if (num < 0f)
		{
			deltaTime += (float)(((int)num / 24 - 1) * 24);
		}
		return deltaTime;
	}

	public float EvaulateTimeCurve(float hour)
	{
		return timeCurve.Evaluate(hour);
	}

	public void AddHours(float hours, bool adjust = true)
	{
		if (UseTimeCurve && adjust)
		{
			hours = ApplyTimeCurve(hours);
		}
		DateTime dateTime = sky.Cycle.DateTime;
		DateTime dateTime2 = dateTime.AddHours(hours);
		sky.Cycle.DateTime = dateTime2;
		if (dateTime2.Year > dateTime.Year)
		{
			if (this.OnYear != null)
			{
				this.OnYear();
			}
			if (this.OnMonth != null)
			{
				this.OnMonth();
			}
			if (this.OnDay != null)
			{
				this.OnDay();
			}
			if (this.OnHour != null)
			{
				this.OnHour();
			}
			if (this.OnMinute != null)
			{
				this.OnMinute();
			}
			if (this.OnSecond != null)
			{
				this.OnSecond();
			}
		}
		else if (dateTime2.Month > dateTime.Month)
		{
			if (this.OnMonth != null)
			{
				this.OnMonth();
			}
			if (this.OnDay != null)
			{
				this.OnDay();
			}
			if (this.OnHour != null)
			{
				this.OnHour();
			}
			if (this.OnMinute != null)
			{
				this.OnMinute();
			}
			if (this.OnSecond != null)
			{
				this.OnSecond();
			}
		}
		else if (dateTime2.Day > dateTime.Day)
		{
			if (this.OnDay != null)
			{
				this.OnDay();
			}
			if (this.OnHour != null)
			{
				this.OnHour();
			}
			if (this.OnMinute != null)
			{
				this.OnMinute();
			}
			if (this.OnSecond != null)
			{
				this.OnSecond();
			}
		}
		else if (dateTime2.Hour > dateTime.Hour)
		{
			if (this.OnHour != null)
			{
				this.OnHour();
			}
			if (this.OnMinute != null)
			{
				this.OnMinute();
			}
			if (this.OnSecond != null)
			{
				this.OnSecond();
			}
		}
		else if (dateTime2.Minute > dateTime.Minute)
		{
			if (this.OnMinute != null)
			{
				this.OnMinute();
			}
			if (this.OnSecond != null)
			{
				this.OnSecond();
			}
		}
		else if (dateTime2.Second > dateTime.Second && this.OnSecond != null)
		{
			this.OnSecond();
		}
		double totalHours = dateTime.TimeOfDay.TotalHours;
		double totalHours2 = dateTime2.TimeOfDay.TotalHours;
		if (totalHours < (double)sky.SunriseTime && totalHours2 >= (double)sky.SunriseTime && this.OnSunrise != null)
		{
			this.OnSunrise();
		}
		if (totalHours < (double)sky.SunsetTime && totalHours2 >= (double)sky.SunsetTime && this.OnSunset != null)
		{
			this.OnSunset();
		}
	}

	public void AddSeconds(float seconds, bool adjust = true)
	{
		AddHours(seconds / 3600f);
	}

	private void CalculateLinearTangents(Keyframe[] keys)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < keys.Length; i++)
		{
			Keyframe val = keys[i];
			if (i > 0)
			{
				Keyframe val2 = keys[i - 1];
				((Keyframe)(ref val)).inTangent = (((Keyframe)(ref val)).value - ((Keyframe)(ref val2)).value) / (((Keyframe)(ref val)).time - ((Keyframe)(ref val2)).time);
			}
			if (i < keys.Length - 1)
			{
				Keyframe val3 = keys[i + 1];
				((Keyframe)(ref val)).outTangent = (((Keyframe)(ref val3)).value - ((Keyframe)(ref val)).value) / (((Keyframe)(ref val3)).time - ((Keyframe)(ref val)).time);
			}
			keys[i] = val;
		}
	}

	private void ApproximateCurve(AnimationCurve source, out AnimationCurve approxCurve, out AnimationCurve approxInverse)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Expected O, but got Unknown
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Expected O, but got Unknown
		Keyframe[] array = (Keyframe[])(object)new Keyframe[25];
		Keyframe[] array2 = (Keyframe[])(object)new Keyframe[25];
		float num = -0.01f;
		for (int i = 0; i < 25; i++)
		{
			num = Mathf.Max(num + 0.01f, source.Evaluate((float)i));
			array[i] = new Keyframe((float)i, num);
			array2[i] = new Keyframe(num, (float)i);
		}
		CalculateLinearTangents(array);
		CalculateLinearTangents(array2);
		approxCurve = new AnimationCurve(array);
		approxInverse = new AnimationCurve(array2);
	}

	protected void Awake()
	{
		sky = ((Component)this).GetComponent<TOD_Sky>();
		if (UseDeviceDate)
		{
			sky.Cycle.Year = DateTime.Now.Year;
			sky.Cycle.Month = DateTime.Now.Month;
			sky.Cycle.Day = DateTime.Now.Day;
		}
		if (UseDeviceTime)
		{
			sky.Cycle.Hour = (float)DateTime.Now.TimeOfDay.TotalHours;
		}
		RefreshTimeCurve();
	}

	protected void Update()
	{
		if (ProgressTime && DayLengthInMinutes > 0f)
		{
			float num = 1440f / DayLengthInMinutes;
			float num2 = timeFraction + Time.deltaTime;
			int num3 = Mathf.FloorToInt(num2 / (1f / 30f)) + 1;
			for (int i = 0; i < num3; i++)
			{
				float num4 = ((num2 >= 1f / 30f) ? (1f / 30f) : 0f);
				AddSeconds(num4 * num);
				num2 -= num4;
			}
			timeFraction = num2;
		}
	}
}


using UnityEngine;

public static class TOD_Util
{
	public static Color MulRGB(Color color, float multiplier)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		if (multiplier == 1f)
		{
			return color;
		}
		return new Color(color.r * multiplier, color.g * multiplier, color.b * multiplier, color.a);
	}

	public static Color MulRGBA(Color color, float multiplier)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		if (multiplier == 1f)
		{
			return color;
		}
		return new Color(color.r * multiplier, color.g * multiplier, color.b * multiplier, color.a * multiplier);
	}

	public static Color PowRGB(Color color, float power)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		if (power == 1f)
		{
			return color;
		}
		return new Color(Mathf.Pow(color.r, power), Mathf.Pow(color.g, power), Mathf.Pow(color.b, power), color.a);
	}

	public static Color PowRGBA(Color color, float power)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		if (power == 1f)
		{
			return color;
		}
		return new Color(Mathf.Pow(color.r, power), Mathf.Pow(color.g, power), Mathf.Pow(color.b, power), Mathf.Pow(color.a, power));
	}

	public static Color SatRGB(Color color, float saturation)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		float grayscale = ((Color)(ref color)).grayscale;
		color.r = grayscale + (color.r - grayscale) * saturation;
		color.g = grayscale + (color.g - grayscale) * saturation;
		color.b = grayscale + (color.b - grayscale) * saturation;
		return color;
	}

	public static Color SatRGBA(Color color, float saturation)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		float grayscale = ((Color)(ref color)).grayscale;
		color.r = grayscale + (color.r - grayscale) * saturation;
		color.g = grayscale + (color.g - grayscale) * saturation;
		color.b = grayscale + (color.b - grayscale) * saturation;
		color.a = grayscale + (color.a - grayscale) * saturation;
		return color;
	}

	public static Color AdjustRGB(Color color, float intensity, float saturation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return MulRGB(SatRGB(color, saturation), intensity);
	}

	public static Color AdjustRGBA(Color color, float intensity, float saturation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return MulRGBA(SatRGBA(color, saturation), intensity);
	}

	public static Color ApplyAlpha(Color color)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		return new Color(color.r * color.a, color.g * color.a, color.b * color.a, 1f);
	}

	public static void Swap<T>(ref T a, ref T b)
	{
		T val = a;
		a = b;
		b = val;
	}
}


using UnityEngine;

public abstract class TOD_Audio : MonoBehaviour
{
	private AudioSource audioComponent;

	protected float GetVolume()
	{
		if (Object.op_Implicit((Object)(object)audioComponent))
		{
			return audioComponent.volume;
		}
		return 0f;
	}

	protected void SetVolume(float value)
	{
		if (Object.op_Implicit((Object)(object)audioComponent))
		{
			audioComponent.volume = value;
			((Behaviour)audioComponent).enabled = value > 0f;
		}
	}

	protected void Awake()
	{
		audioComponent = ((Component)this).GetComponent<AudioSource>();
	}
}


using UnityEngine;

public class TOD_AudioAtDay : TOD_Audio
{
	public float fadeTime = 1f;

	private float lerpTime;

	private float maxVolume;

	protected void Start()
	{
		maxVolume = GetVolume();
		SetVolume(TOD_Sky.Instance.IsDay ? maxVolume : 0f);
	}

	protected void Update()
	{
		int num = (TOD_Sky.Instance.IsDay ? 1 : (-1));
		lerpTime = Mathf.Clamp01(lerpTime + (float)num * Time.deltaTime / fadeTime);
		SetVolume(Mathf.Lerp(0f, maxVolume, lerpTime));
	}
}


using UnityEngine;

public class TOD_AudioAtNight : TOD_Audio
{
	public float fadeTime = 1f;

	private float lerpTime;

	private float maxVolume;

	protected void Start()
	{
		maxVolume = GetVolume();
		SetVolume(TOD_Sky.Instance.IsDay ? maxVolume : 0f);
	}

	protected void Update()
	{
		int num = (TOD_Sky.Instance.IsDay ? 1 : (-1));
		lerpTime = Mathf.Clamp01(lerpTime + (float)num * Time.deltaTime / fadeTime);
		SetVolume(Mathf.Lerp(0f, maxVolume, lerpTime));
	}
}


using UnityEngine;

public class TOD_AudioAtTime : TOD_Audio
{
	public AnimationCurve Volume;

	protected void Update()
	{
		SetVolume(Volume.Evaluate(TOD_Sky.Instance.Cycle.Hour));
	}

	public TOD_AudioAtTime()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected O, but got Unknown
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		AnimationCurve val = new AnimationCurve();
		val.keys = (Keyframe[])(object)new Keyframe[3]
		{
			new Keyframe(0f, 0f),
			new Keyframe(12f, 1f),
			new Keyframe(24f, 0f)
		};
		Volume = val;
		base..ctor();
	}
}


using UnityEngine;

public abstract class TOD_Light : MonoBehaviour
{
	private Light lightComponent;

	protected float GetIntensity()
	{
		if (Object.op_Implicit((Object)(object)lightComponent))
		{
			return lightComponent.intensity;
		}
		return 0f;
	}

	protected void SetIntensity(float value)
	{
		if (Object.op_Implicit((Object)(object)lightComponent))
		{
			lightComponent.intensity = value;
			((Behaviour)lightComponent).enabled = value > 0f;
		}
	}

	protected void Awake()
	{
		lightComponent = ((Component)this).GetComponent<Light>();
	}
}


using UnityEngine;

public class TOD_LightAtDay : TOD_Light
{
	public float fadeTime = 1f;

	private float lerpTime;

	private float maxIntensity;

	protected void Start()
	{
		maxIntensity = GetIntensity();
		SetIntensity(TOD_Sky.Instance.IsDay ? maxIntensity : 0f);
	}

	protected void Update()
	{
		int num = (TOD_Sky.Instance.IsDay ? 1 : (-1));
		lerpTime = Mathf.Clamp01(lerpTime + (float)num * Time.deltaTime / fadeTime);
		SetIntensity(Mathf.Lerp(0f, maxIntensity, lerpTime));
	}
}


using UnityEngine;

public class TOD_LightAtNight : TOD_Light
{
	public float fadeTime = 1f;

	private float lerpTime;

	private float maxIntensity;

	protected void Start()
	{
		maxIntensity = GetIntensity();
		SetIntensity(TOD_Sky.Instance.IsNight ? maxIntensity : 0f);
	}

	protected void Update()
	{
		int num = (TOD_Sky.Instance.IsNight ? 1 : (-1));
		lerpTime = Mathf.Clamp01(lerpTime + (float)num * Time.deltaTime / fadeTime);
		SetIntensity(Mathf.Lerp(0f, maxIntensity, lerpTime));
	}
}


using UnityEngine;

public class TOD_LightAtTime : TOD_Light
{
	public AnimationCurve Intensity;

	protected void Update()
	{
		SetIntensity(Intensity.Evaluate(TOD_Sky.Instance.Cycle.Hour));
	}

	public TOD_LightAtTime()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected O, but got Unknown
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		AnimationCurve val = new AnimationCurve();
		val.keys = (Keyframe[])(object)new Keyframe[3]
		{
			new Keyframe(0f, 0f),
			new Keyframe(12f, 1f),
			new Keyframe(24f, 0f)
		};
		Intensity = val;
		base..ctor();
	}
}


using UnityEngine;

public class TOD_LoadSkyFromFile : MonoBehaviour
{
	public TOD_Sky sky;

	public TextAsset textAsset;

	protected void Start()
	{
		if (!Object.op_Implicit((Object)(object)sky))
		{
			sky = TOD_Sky.Instance;
		}
		if (Object.op_Implicit((Object)(object)textAsset))
		{
			sky.LoadParameters(textAsset.text);
		}
	}
}


using UnityEngine;

public abstract class TOD_Particle : MonoBehaviour
{
	private ParticleSystem particleComponent;

	protected float GetEmission()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)particleComponent))
		{
			EmissionModule emission = particleComponent.emission;
			return ((EmissionModule)(ref emission)).rateOverTimeMultiplier;
		}
		return 0f;
	}

	protected void SetEmission(float value)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)particleComponent))
		{
			EmissionModule emission = particleComponent.emission;
			((EmissionModule)(ref emission)).rateOverTimeMultiplier = value;
		}
	}

	protected void Awake()
	{
		particleComponent = ((Component)this).GetComponent<ParticleSystem>();
	}
}


using UnityEngine;

public class TOD_ParticleAtDay : TOD_Particle
{
	public float fadeTime = 1f;

	private float lerpTime;

	private float maxEmission;

	protected void Start()
	{
		maxEmission = GetEmission();
		SetEmission(TOD_Sky.Instance.IsDay ? maxEmission : 0f);
	}

	protected void Update()
	{
		int num = (TOD_Sky.Instance.IsDay ? 1 : (-1));
		lerpTime = Mathf.Clamp01(lerpTime + (float)num * Time.deltaTime / fadeTime);
		SetEmission(Mathf.Lerp(0f, maxEmission, lerpTime));
	}
}


using UnityEngine;

public class TOD_ParticleAtNight : TOD_Particle
{
	public float fadeTime = 1f;

	private float lerpTime;

	private float maxEmission;

	protected void Start()
	{
		maxEmission = GetEmission();
		SetEmission(TOD_Sky.Instance.IsNight ? maxEmission : 0f);
	}

	protected void Update()
	{
		int num = (TOD_Sky.Instance.IsNight ? 1 : (-1));
		lerpTime = Mathf.Clamp01(lerpTime + (float)num * Time.deltaTime / fadeTime);
		SetEmission(Mathf.Lerp(0f, maxEmission, lerpTime));
	}
}


using UnityEngine;

public class TOD_ParticleAtTime : TOD_Particle
{
	public AnimationCurve Emission;

	protected void Update()
	{
		SetEmission(Emission.Evaluate(TOD_Sky.Instance.Cycle.Hour));
	}

	public TOD_ParticleAtTime()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected O, but got Unknown
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		AnimationCurve val = new AnimationCurve();
		val.keys = (Keyframe[])(object)new Keyframe[3]
		{
			new Keyframe(0f, 0f),
			new Keyframe(12f, 1f),
			new Keyframe(24f, 0f)
		};
		Emission = val;
		base..ctor();
	}
}


using UnityEngine;

public abstract class TOD_Render : MonoBehaviour
{
	private Renderer rendererComponent;

	protected void SetState(bool value)
	{
		if (Object.op_Implicit((Object)(object)rendererComponent))
		{
			rendererComponent.enabled = value;
		}
	}

	protected void Awake()
	{
		rendererComponent = ((Component)this).GetComponent<Renderer>();
	}
}


public class TOD_RenderAtDay : TOD_Render
{
	protected void Start()
	{
		SetState(TOD_Sky.Instance.IsDay);
	}

	protected void Update()
	{
		SetState(TOD_Sky.Instance.IsDay);
	}
}


public class TOD_RenderAtNight : TOD_Render
{
	protected void Start()
	{
		SetState(TOD_Sky.Instance.IsNight);
	}

	protected void Update()
	{
		SetState(TOD_Sky.Instance.IsNight);
	}
}


using UnityEngine;

public class TOD_WeatherManager : MonoBehaviour
{
	public enum RainType
	{
		None,
		Light,
		Heavy
	}

	public enum CloudType
	{
		None,
		Few,
		Scattered,
		Broken,
		Overcast
	}

	public enum AtmosphereType
	{
		Clear,
		Storm,
		Dust,
		Fog
	}

	public ParticleSystem RainParticleSystem;

	public float FadeTime = 10f;

	public RainType Rain;

	public CloudType Clouds;

	public AtmosphereType Atmosphere;

	private float cloudOpacityMax;

	private float cloudBrightnessMax;

	private float atmosphereBrightnessMax;

	private float rainEmissionMax;

	private float cloudOpacity;

	private float cloudCoverage;

	private float cloudBrightness;

	private float atmosphereFog;

	private float atmosphereBrightness;

	private float rainEmission;

	private float GetRainEmission()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)RainParticleSystem))
		{
			EmissionModule emission = RainParticleSystem.emission;
			return ((EmissionModule)(ref emission)).rateOverTimeMultiplier;
		}
		return 0f;
	}

	private void SetRainEmission(float value)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)RainParticleSystem))
		{
			EmissionModule emission = RainParticleSystem.emission;
			((EmissionModule)(ref emission)).rateOverTimeMultiplier = value;
		}
	}

	protected void Start()
	{
		TOD_Sky instance = TOD_Sky.Instance;
		cloudOpacity = instance.Clouds.Opacity;
		cloudCoverage = instance.Clouds.Coverage;
		cloudBrightness = instance.Clouds.Brightness;
		atmosphereFog = instance.Atmosphere.Fogginess;
		atmosphereBrightness = instance.Atmosphere.Brightness;
		rainEmission = GetRainEmission();
		cloudOpacityMax = cloudOpacity;
		cloudBrightnessMax = cloudBrightness;
		atmosphereBrightnessMax = atmosphereBrightness;
		rainEmissionMax = rainEmission;
	}

	protected void Update()
	{
		TOD_Sky instance = TOD_Sky.Instance;
		switch (Rain)
		{
		case RainType.None:
			rainEmission = 0f;
			break;
		case RainType.Light:
			rainEmission = rainEmissionMax * 0.5f;
			break;
		case RainType.Heavy:
			rainEmission = rainEmissionMax;
			break;
		}
		switch (Clouds)
		{
		case CloudType.None:
			cloudOpacity = 0f;
			cloudCoverage = 0f;
			break;
		case CloudType.Few:
			cloudOpacity = cloudOpacityMax;
			cloudCoverage = 0.1f;
			break;
		case CloudType.Scattered:
			cloudOpacity = cloudOpacityMax;
			cloudCoverage = 0.3f;
			break;
		case CloudType.Broken:
			cloudOpacity = cloudOpacityMax;
			cloudCoverage = 0.6f;
			break;
		case CloudType.Overcast:
			cloudOpacity = cloudOpacityMax;
			cloudCoverage = 1f;
			break;
		}
		switch (Atmosphere)
		{
		case AtmosphereType.Clear:
			cloudBrightness = cloudBrightnessMax;
			atmosphereBrightness = atmosphereBrightnessMax;
			atmosphereFog = 0f;
			break;
		case AtmosphereType.Storm:
			cloudBrightness = cloudBrightnessMax * 0.3f;
			atmosphereBrightness = atmosphereBrightnessMax * 0.5f;
			atmosphereFog = 1f;
			break;
		case AtmosphereType.Dust:
			cloudBrightness = cloudBrightnessMax;
			atmosphereBrightness = atmosphereBrightnessMax;
			atmosphereFog = 0.5f;
			break;
		case AtmosphereType.Fog:
			cloudBrightness = cloudBrightnessMax;
			atmosphereBrightness = atmosphereBrightnessMax;
			atmosphereFog = 1f;
			break;
		}
		float num = ((FadeTime > 0f) ? Mathf.Clamp01(Time.deltaTime / FadeTime) : 1f);
		instance.Clouds.Opacity = Mathf.Lerp(instance.Clouds.Opacity, cloudOpacity, num);
		instance.Clouds.Coverage = Mathf.Lerp(instance.Clouds.Coverage, cloudCoverage, num);
		instance.Clouds.Brightness = Mathf.Lerp(instance.Clouds.Brightness, cloudBrightness, num);
		instance.Atmosphere.Fogginess = Mathf.Lerp(instance.Atmosphere.Fogginess, atmosphereFog, num);
		instance.Atmosphere.Brightness = Mathf.Lerp(instance.Atmosphere.Brightness, atmosphereBrightness, num);
		SetRainEmission(Mathf.Lerp(GetRainEmission(), rainEmission, num));
	}
}


using UnityEngine;

public static class KeywordUtil
{
	public static void EnsureKeywordState(string keyword, bool state)
	{
		bool flag = Shader.IsKeywordEnabled(keyword);
		if (state && !flag)
		{
			Shader.EnableKeyword(keyword);
		}
		else if (!state && flag)
		{
			Shader.DisableKeyword(keyword);
		}
	}

	public static void EnsureKeywordState(Material mat, string keyword, bool state)
	{
		if ((Object)(object)mat != (Object)null)
		{
			bool flag = mat.IsKeywordEnabled(keyword);
			if (state && !flag)
			{
				mat.EnableKeyword(keyword);
			}
			else if (!state && flag)
			{
				mat.DisableKeyword(keyword);
			}
		}
	}

	public static void EnsureCSKeywordState(ComputeShader cs, string keyword, bool state)
	{
		bool flag = cs.IsKeywordEnabled(keyword);
		if (state && !flag)
		{
			cs.EnableKeyword(keyword);
		}
		else if (!state && flag)
		{
			cs.DisableKeyword(keyword);
		}
	}
}


