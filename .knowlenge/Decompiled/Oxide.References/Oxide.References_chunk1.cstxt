internal static class Empty<T>
{
	public static readonly T[] Array = new T[0];
}


using System;
using System.Security.Cryptography;

internal static class CryptoConvert
{
	private static int ToInt32LE(byte[] bytes, int offset)
	{
		return (bytes[offset + 3] << 24) | (bytes[offset + 2] << 16) | (bytes[offset + 1] << 8) | bytes[offset];
	}

	private static uint ToUInt32LE(byte[] bytes, int offset)
	{
		return (uint)((bytes[offset + 3] << 24) | (bytes[offset + 2] << 16) | (bytes[offset + 1] << 8) | bytes[offset]);
	}

	private static byte[] Trim(byte[] array)
	{
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] != 0)
			{
				byte[] array2 = new byte[array.Length - i];
				Buffer.BlockCopy(array, i, array2, 0, array2.Length);
				return array2;
			}
		}
		return null;
	}

	private static RSA FromCapiPrivateKeyBlob(byte[] blob, int offset)
	{
		RSAParameters parameters = default(RSAParameters);
		try
		{
			if (blob[offset] != 7 || blob[offset + 1] != 2 || blob[offset + 2] != 0 || blob[offset + 3] != 0 || ToUInt32LE(blob, offset + 8) != 843141970)
			{
				throw new CryptographicException("Invalid blob header");
			}
			int num = ToInt32LE(blob, offset + 12);
			byte[] array = new byte[4];
			Buffer.BlockCopy(blob, offset + 16, array, 0, 4);
			Array.Reverse((Array)array);
			parameters.Exponent = Trim(array);
			int num2 = offset + 20;
			int num3 = num >> 3;
			parameters.Modulus = new byte[num3];
			Buffer.BlockCopy(blob, num2, parameters.Modulus, 0, num3);
			Array.Reverse((Array)parameters.Modulus);
			num2 += num3;
			int num4 = num3 >> 1;
			parameters.P = new byte[num4];
			Buffer.BlockCopy(blob, num2, parameters.P, 0, num4);
			Array.Reverse((Array)parameters.P);
			num2 += num4;
			parameters.Q = new byte[num4];
			Buffer.BlockCopy(blob, num2, parameters.Q, 0, num4);
			Array.Reverse((Array)parameters.Q);
			num2 += num4;
			parameters.DP = new byte[num4];
			Buffer.BlockCopy(blob, num2, parameters.DP, 0, num4);
			Array.Reverse((Array)parameters.DP);
			num2 += num4;
			parameters.DQ = new byte[num4];
			Buffer.BlockCopy(blob, num2, parameters.DQ, 0, num4);
			Array.Reverse((Array)parameters.DQ);
			num2 += num4;
			parameters.InverseQ = new byte[num4];
			Buffer.BlockCopy(blob, num2, parameters.InverseQ, 0, num4);
			Array.Reverse((Array)parameters.InverseQ);
			num2 += num4;
			parameters.D = new byte[num3];
			if (num2 + num3 + offset <= blob.Length)
			{
				Buffer.BlockCopy(blob, num2, parameters.D, 0, num3);
				Array.Reverse((Array)parameters.D);
			}
		}
		catch (Exception inner)
		{
			throw new CryptographicException("Invalid blob.", inner);
		}
		RSA rSA = null;
		try
		{
			rSA = RSA.Create();
			rSA.ImportParameters(parameters);
		}
		catch (CryptographicException)
		{
			bool flag = false;
			try
			{
				rSA = new RSACryptoServiceProvider(new CspParameters
				{
					Flags = CspProviderFlags.UseMachineKeyStore
				});
				rSA.ImportParameters(parameters);
			}
			catch
			{
				flag = true;
			}
			if (flag)
			{
				throw;
			}
		}
		return rSA;
	}

	private static RSA FromCapiPublicKeyBlob(byte[] blob, int offset)
	{
		try
		{
			if (blob[offset] != 6 || blob[offset + 1] != 2 || blob[offset + 2] != 0 || blob[offset + 3] != 0 || ToUInt32LE(blob, offset + 8) != 826364754)
			{
				throw new CryptographicException("Invalid blob header");
			}
			int num = ToInt32LE(blob, offset + 12);
			RSAParameters parameters = new RSAParameters
			{
				Exponent = new byte[3]
			};
			parameters.Exponent[0] = blob[offset + 18];
			parameters.Exponent[1] = blob[offset + 17];
			parameters.Exponent[2] = blob[offset + 16];
			int srcOffset = offset + 20;
			int num2 = num >> 3;
			parameters.Modulus = new byte[num2];
			Buffer.BlockCopy(blob, srcOffset, parameters.Modulus, 0, num2);
			Array.Reverse((Array)parameters.Modulus);
			RSA rSA = null;
			try
			{
				rSA = RSA.Create();
				rSA.ImportParameters(parameters);
			}
			catch (CryptographicException)
			{
				rSA = new RSACryptoServiceProvider(new CspParameters
				{
					Flags = CspProviderFlags.UseMachineKeyStore
				});
				rSA.ImportParameters(parameters);
			}
			return rSA;
		}
		catch (Exception inner)
		{
			throw new CryptographicException("Invalid blob.", inner);
		}
	}

	public static RSA FromCapiKeyBlob(byte[] blob)
	{
		return FromCapiKeyBlob(blob, 0);
	}

	public static RSA FromCapiKeyBlob(byte[] blob, int offset)
	{
		if (blob == null)
		{
			throw new ArgumentNullException("blob");
		}
		if (offset >= blob.Length)
		{
			throw new ArgumentException("blob is too small.");
		}
		switch (blob[offset])
		{
		case 0:
			if (blob[offset + 12] == 6)
			{
				return FromCapiPublicKeyBlob(blob, offset + 12);
			}
			break;
		case 6:
			return FromCapiPublicKeyBlob(blob, offset);
		case 7:
			return FromCapiPrivateKeyBlob(blob, offset);
		}
		throw new CryptographicException("Unknown blob format.");
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using Mono;
using Mono.Cecil;
using Mono.Collections.Generic;

public class Collection<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable, IList, ICollection
{
	public struct Enumerator : IEnumerator<T>, IDisposable, IEnumerator
	{
		private Collection<T> collection;

		private T current;

		private int next;

		private readonly int version;

		public T Current => current;

		object IEnumerator.Current
		{
			get
			{
				CheckState();
				if (next <= 0)
				{
					throw new InvalidOperationException();
				}
				return current;
			}
		}

		internal Enumerator(Collection<T> collection)
		{
			this = default(Enumerator);
			this.collection = collection;
			version = collection.version;
		}

		public bool MoveNext()
		{
			CheckState();
			if (next < 0)
			{
				return false;
			}
			if (next < collection.size)
			{
				current = collection.items[next++];
				return true;
			}
			next = -1;
			return false;
		}

		public void Reset()
		{
			CheckState();
			next = 0;
		}

		private void CheckState()
		{
			if (collection == null)
			{
				throw new ObjectDisposedException(GetType().FullName);
			}
			if (version != collection.version)
			{
				throw new InvalidOperationException();
			}
		}

		public void Dispose()
		{
			collection = null;
		}
	}

	internal T[] items;

	internal int size;

	private int version;

	public int Count => size;

	public T this[int index]
	{
		get
		{
			if (index >= size)
			{
				throw new ArgumentOutOfRangeException();
			}
			return items[index];
		}
		set
		{
			CheckIndex(index);
			if (index == size)
			{
				throw new ArgumentOutOfRangeException();
			}
			OnSet(value, index);
			items[index] = value;
		}
	}

	public int Capacity
	{
		get
		{
			return items.Length;
		}
		set
		{
			if (value < 0 || value < size)
			{
				throw new ArgumentOutOfRangeException();
			}
			Resize(value);
		}
	}

	bool ICollection<T>.IsReadOnly => false;

	bool IList.IsFixedSize => false;

	bool IList.IsReadOnly => false;

	object IList.this[int index]
	{
		get
		{
			return this[index];
		}
		set
		{
			CheckIndex(index);
			try
			{
				this[index] = (T)value;
				return;
			}
			catch (InvalidCastException)
			{
			}
			catch (NullReferenceException)
			{
			}
			throw new ArgumentException();
		}
	}

	int ICollection.Count => Count;

	bool ICollection.IsSynchronized => false;

	object ICollection.SyncRoot => this;

	public Collection()
	{
		items = Empty<T>.Array;
	}

	public Collection(int capacity)
	{
		if (capacity < 0)
		{
			throw new ArgumentOutOfRangeException();
		}
		items = new T[capacity];
	}

	public Collection(ICollection<T> items)
	{
		if (items == null)
		{
			throw new ArgumentNullException("items");
		}
		this.items = new T[items.Count];
		items.CopyTo(this.items, 0);
		size = this.items.Length;
	}

	public void Add(T item)
	{
		if (size == items.Length)
		{
			Grow(1);
		}
		OnAdd(item, size);
		items[size++] = item;
		version++;
	}

	public bool Contains(T item)
	{
		return IndexOf(item) != -1;
	}

	public int IndexOf(T item)
	{
		return Array.IndexOf(items, item, 0, size);
	}

	public void Insert(int index, T item)
	{
		CheckIndex(index);
		if (size == items.Length)
		{
			Grow(1);
		}
		OnInsert(item, index);
		Shift(index, 1);
		items[index] = item;
		version++;
	}

	public void RemoveAt(int index)
	{
		if (index < 0 || index >= size)
		{
			throw new ArgumentOutOfRangeException();
		}
		T item = items[index];
		OnRemove(item, index);
		Shift(index, -1);
		Array.Clear(items, size, 1);
		version++;
	}

	public bool Remove(T item)
	{
		int num = IndexOf(item);
		if (num == -1)
		{
			return false;
		}
		OnRemove(item, num);
		Shift(num, -1);
		Array.Clear(items, size, 1);
		version++;
		return true;
	}

	public void Clear()
	{
		OnClear();
		Array.Clear(items, 0, size);
		size = 0;
		version++;
	}

	public void CopyTo(T[] array, int arrayIndex)
	{
		Array.Copy(items, 0, array, arrayIndex, size);
	}

	public T[] ToArray()
	{
		T[] array = new T[size];
		Array.Copy(items, 0, array, 0, size);
		return array;
	}

	private void CheckIndex(int index)
	{
		if (index < 0 || index > size)
		{
			throw new ArgumentOutOfRangeException();
		}
	}

	private void Shift(int start, int delta)
	{
		if (delta < 0)
		{
			start -= delta;
		}
		if (start < size)
		{
			Array.Copy(items, start, items, start + delta, size - start);
		}
		size += delta;
		if (delta < 0)
		{
			Array.Clear(items, size, -delta);
		}
	}

	protected virtual void OnAdd(T item, int index)
	{
	}

	protected virtual void OnInsert(T item, int index)
	{
	}

	protected virtual void OnSet(T item, int index)
	{
	}

	protected virtual void OnRemove(T item, int index)
	{
	}

	protected virtual void OnClear()
	{
	}

	internal virtual void Grow(int desired)
	{
		int num = size + desired;
		if (num > items.Length)
		{
			num = Math.Max(Math.Max(items.Length * 2, 4), num);
			Resize(num);
		}
	}

	protected void Resize(int new_size)
	{
		if (new_size != size)
		{
			if (new_size < size)
			{
				throw new ArgumentOutOfRangeException();
			}
			items = items.Resize(new_size);
		}
	}

	int IList.Add(object value)
	{
		try
		{
			Add((T)value);
			return size - 1;
		}
		catch (InvalidCastException)
		{
		}
		catch (NullReferenceException)
		{
		}
		throw new ArgumentException();
	}

	void IList.Clear()
	{
		Clear();
	}

	bool IList.Contains(object value)
	{
		return ((IList)this).IndexOf(value) > -1;
	}

	int IList.IndexOf(object value)
	{
		try
		{
			return IndexOf((T)value);
		}
		catch (InvalidCastException)
		{
		}
		catch (NullReferenceException)
		{
		}
		return -1;
	}

	void IList.Insert(int index, object value)
	{
		CheckIndex(index);
		try
		{
			Insert(index, (T)value);
			return;
		}
		catch (InvalidCastException)
		{
		}
		catch (NullReferenceException)
		{
		}
		throw new ArgumentException();
	}

	void IList.Remove(object value)
	{
		try
		{
			Remove((T)value);
		}
		catch (InvalidCastException)
		{
		}
		catch (NullReferenceException)
		{
		}
	}

	void IList.RemoveAt(int index)
	{
		RemoveAt(index);
	}

	void ICollection.CopyTo(Array array, int index)
	{
		Array.Copy(items, 0, array, index, size);
	}

	public Enumerator GetEnumerator()
	{
		return new Enumerator(this);
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return new Enumerator(this);
	}

	IEnumerator<T> IEnumerable<T>.GetEnumerator()
	{
		return new Enumerator(this);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;

public struct Enumerator : IEnumerator<T>, IDisposable, IEnumerator
{
	private Collection<T> collection;

	private T current;

	private int next;

	private readonly int version;

	public T Current => current;

	object IEnumerator.Current
	{
		get
		{
			CheckState();
			if (next <= 0)
			{
				throw new InvalidOperationException();
			}
			return current;
		}
	}

	internal Enumerator(Collection<T> collection)
	{
		this = default(Enumerator);
		this.collection = collection;
		version = collection.version;
	}

	public bool MoveNext()
	{
		CheckState();
		if (next < 0)
		{
			return false;
		}
		if (next < collection.size)
		{
			current = collection.items[next++];
			return true;
		}
		next = -1;
		return false;
	}

	public void Reset()
	{
		CheckState();
		next = 0;
	}

	private void CheckState()
	{
		if (collection == null)
		{
			throw new ObjectDisposedException(GetType().FullName);
		}
		if (version != collection.version)
		{
			throw new InvalidOperationException();
		}
	}

	public void Dispose()
	{
		collection = null;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using Mono.Collections.Generic;

public sealed class ReadOnlyCollection<T> : Collection<T>, ICollection<T>, IEnumerable<T>, IEnumerable, IList, ICollection
{
	private static ReadOnlyCollection<T> empty;

	public static ReadOnlyCollection<T> Empty => empty ?? (empty = new ReadOnlyCollection<T>());

	bool ICollection<T>.IsReadOnly => true;

	bool IList.IsFixedSize => true;

	bool IList.IsReadOnly => true;

	private ReadOnlyCollection()
	{
	}

	public ReadOnlyCollection(T[] array)
	{
		if (array == null)
		{
			throw new ArgumentNullException();
		}
		Initialize(array, array.Length);
	}

	public ReadOnlyCollection(Collection<T> collection)
	{
		if (collection == null)
		{
			throw new ArgumentNullException();
		}
		Initialize(collection.items, collection.size);
	}

	private void Initialize(T[] items, int size)
	{
		base.items = new T[size];
		Array.Copy(items, 0, base.items, 0, size);
		base.size = size;
	}

	internal override void Grow(int desired)
	{
		throw new InvalidOperationException();
	}

	protected override void OnAdd(T item, int index)
	{
		throw new InvalidOperationException();
	}

	protected override void OnClear()
	{
		throw new InvalidOperationException();
	}

	protected override void OnInsert(T item, int index)
	{
		throw new InvalidOperationException();
	}

	protected override void OnRemove(T item, int index)
	{
		throw new InvalidOperationException();
	}

	protected override void OnSet(T item, int index)
	{
		throw new InvalidOperationException();
	}
}


using Mono.Cecil;

public struct MetadataToken
{
	private readonly uint token;

	public static readonly MetadataToken Zero = new MetadataToken(0u);

	public uint RID => token & 0xFFFFFF;

	public TokenType TokenType => (TokenType)(token & 0xFF000000u);

	public MetadataToken(uint token)
	{
		this.token = token;
	}

	public MetadataToken(TokenType type)
		: this(type, 0)
	{
	}

	public MetadataToken(TokenType type, uint rid)
	{
		token = (uint)type | rid;
	}

	public MetadataToken(TokenType type, int rid)
	{
		token = (uint)type | (uint)rid;
	}

	public int ToInt32()
	{
		return (int)token;
	}

	public uint ToUInt32()
	{
		return token;
	}

	public override int GetHashCode()
	{
		return (int)token;
	}

	public override bool Equals(object obj)
	{
		if (obj is MetadataToken)
		{
			return ((MetadataToken)obj).token == token;
		}
		return false;
	}

	public static bool operator ==(MetadataToken one, MetadataToken other)
	{
		return one.token == other.token;
	}

	public static bool operator !=(MetadataToken one, MetadataToken other)
	{
		return one.token != other.token;
	}

	public override string ToString()
	{
		return string.Format("[{0}:0x{1}]", TokenType, RID.ToString("x4"));
	}
}


public enum TokenType : uint
{
	Module = 0u,
	TypeRef = 16777216u,
	TypeDef = 33554432u,
	Field = 67108864u,
	Method = 100663296u,
	Param = 134217728u,
	InterfaceImpl = 150994944u,
	MemberRef = 167772160u,
	CustomAttribute = 201326592u,
	Permission = 234881024u,
	Signature = 285212672u,
	Event = 335544320u,
	Property = 385875968u,
	ModuleRef = 436207616u,
	TypeSpec = 452984832u,
	Assembly = 536870912u,
	AssemblyRef = 587202560u,
	File = 637534208u,
	ExportedType = 654311424u,
	ManifestResource = 671088640u,
	GenericParam = 704643072u,
	MethodSpec = 721420288u,
	String = 1879048192u
}


using System;
using System.IO;
using System.Reflection;
using System.Runtime.Serialization;
using System.Security.Cryptography;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;
using Mono.Security.Cryptography;

internal static class Mixin
{
	internal static object NoValue = new object();

	internal static object NotResolved = new object();

	public const int NotResolvedMarker = -2;

	public const int NoDataMarker = -1;

	public static uint ReadCompressedUInt32(this byte[] data, ref int position)
	{
		uint result;
		if ((data[position] & 0x80) == 0)
		{
			result = data[position];
			position++;
		}
		else if ((data[position] & 0x40) == 0)
		{
			result = (uint)((data[position] & -129) << 8);
			result |= data[position + 1];
			position += 2;
		}
		else
		{
			result = (uint)((data[position] & -193) << 24);
			result |= (uint)(data[position + 1] << 16);
			result |= (uint)(data[position + 2] << 8);
			result |= data[position + 3];
			position += 4;
		}
		return result;
	}

	public static MetadataToken GetMetadataToken(this CodedIndex self, uint data)
	{
		uint rid;
		TokenType type;
		switch (self)
		{
		case CodedIndex.TypeDefOrRef:
			rid = data >> 2;
			switch (data & 3)
			{
			case 0u:
				break;
			case 1u:
				goto IL_0069;
			case 2u:
				goto IL_0074;
			default:
				goto end_IL_0001;
			}
			type = TokenType.TypeDef;
			goto IL_03fb;
		case CodedIndex.HasConstant:
			rid = data >> 2;
			switch (data & 3)
			{
			case 0u:
				break;
			case 1u:
				goto IL_00a9;
			case 2u:
				goto IL_00b4;
			default:
				goto end_IL_0001;
			}
			type = TokenType.Field;
			goto IL_03fb;
		case CodedIndex.HasCustomAttribute:
			rid = data >> 5;
			switch (data & 0x1F)
			{
			case 0u:
				break;
			case 1u:
				goto IL_012e;
			case 2u:
				goto IL_0139;
			case 3u:
				goto IL_0144;
			case 4u:
				goto IL_014f;
			case 5u:
				goto IL_015a;
			case 6u:
				goto IL_0165;
			case 7u:
				goto IL_0170;
			case 8u:
				goto IL_0177;
			case 9u:
				goto IL_0182;
			case 10u:
				goto IL_018d;
			case 11u:
				goto IL_0198;
			case 12u:
				goto IL_01a3;
			case 13u:
				goto IL_01ae;
			case 14u:
				goto IL_01b9;
			case 15u:
				goto IL_01c4;
			case 16u:
				goto IL_01cf;
			case 17u:
				goto IL_01da;
			case 18u:
				goto IL_01e5;
			case 19u:
				goto IL_01f0;
			default:
				goto end_IL_0001;
			}
			type = TokenType.Method;
			goto IL_03fb;
		case CodedIndex.HasFieldMarshal:
		{
			rid = data >> 1;
			uint num = data & 1;
			if (num != 0)
			{
				if (num != 1)
				{
					break;
				}
				type = TokenType.Param;
			}
			else
			{
				type = TokenType.Field;
			}
			goto IL_03fb;
		}
		case CodedIndex.HasDeclSecurity:
			rid = data >> 2;
			switch (data & 3)
			{
			case 0u:
				break;
			case 1u:
				goto IL_024f;
			case 2u:
				goto IL_025a;
			default:
				goto end_IL_0001;
			}
			type = TokenType.TypeDef;
			goto IL_03fb;
		case CodedIndex.MemberRefParent:
			rid = data >> 3;
			switch (data & 7)
			{
			case 0u:
				break;
			case 1u:
				goto IL_0297;
			case 2u:
				goto IL_02a2;
			case 3u:
				goto IL_02ad;
			case 4u:
				goto IL_02b8;
			default:
				goto end_IL_0001;
			}
			type = TokenType.TypeDef;
			goto IL_03fb;
		case CodedIndex.HasSemantics:
		{
			rid = data >> 1;
			uint num = data & 1;
			if (num != 0)
			{
				if (num != 1)
				{
					break;
				}
				type = TokenType.Property;
			}
			else
			{
				type = TokenType.Event;
			}
			goto IL_03fb;
		}
		case CodedIndex.MethodDefOrRef:
		{
			rid = data >> 1;
			uint num = data & 1;
			if (num != 0)
			{
				if (num != 1)
				{
					break;
				}
				type = TokenType.MemberRef;
			}
			else
			{
				type = TokenType.Method;
			}
			goto IL_03fb;
		}
		case CodedIndex.MemberForwarded:
		{
			rid = data >> 1;
			uint num = data & 1;
			if (num != 0)
			{
				if (num != 1)
				{
					break;
				}
				type = TokenType.Method;
			}
			else
			{
				type = TokenType.Field;
			}
			goto IL_03fb;
		}
		case CodedIndex.Implementation:
			rid = data >> 2;
			switch (data & 3)
			{
			case 0u:
				break;
			case 1u:
				goto IL_036b;
			case 2u:
				goto IL_0376;
			default:
				goto end_IL_0001;
			}
			type = TokenType.File;
			goto IL_03fb;
		case CodedIndex.CustomAttributeType:
		{
			rid = data >> 3;
			uint num = data & 7;
			if (num != 2)
			{
				if (num != 3)
				{
					break;
				}
				type = TokenType.MemberRef;
			}
			else
			{
				type = TokenType.Method;
			}
			goto IL_03fb;
		}
		case CodedIndex.ResolutionScope:
			rid = data >> 2;
			switch (data & 3)
			{
			case 0u:
				break;
			case 1u:
				goto IL_03c4;
			case 2u:
				goto IL_03cc;
			case 3u:
				goto IL_03d4;
			default:
				goto end_IL_0001;
			}
			type = TokenType.Module;
			goto IL_03fb;
		case CodedIndex.TypeOrMethodDef:
			{
				rid = data >> 1;
				uint num = data & 1;
				if (num != 0)
				{
					if (num != 1)
					{
						break;
					}
					type = TokenType.Method;
				}
				else
				{
					type = TokenType.TypeDef;
				}
				goto IL_03fb;
			}
			IL_01c4:
			type = TokenType.AssemblyRef;
			goto IL_03fb;
			IL_01ae:
			type = TokenType.TypeSpec;
			goto IL_03fb;
			IL_01b9:
			type = TokenType.Assembly;
			goto IL_03fb;
			IL_03d4:
			type = TokenType.TypeRef;
			goto IL_03fb;
			IL_03cc:
			type = TokenType.AssemblyRef;
			goto IL_03fb;
			IL_03c4:
			type = TokenType.ModuleRef;
			goto IL_03fb;
			IL_01a3:
			type = TokenType.ModuleRef;
			goto IL_03fb;
			IL_0198:
			type = TokenType.Signature;
			goto IL_03fb;
			IL_0182:
			type = TokenType.Property;
			goto IL_03fb;
			IL_018d:
			type = TokenType.Event;
			goto IL_03fb;
			IL_0376:
			type = TokenType.ExportedType;
			goto IL_03fb;
			IL_036b:
			type = TokenType.AssemblyRef;
			goto IL_03fb;
			IL_0177:
			type = TokenType.Permission;
			goto IL_03fb;
			IL_0170:
			type = TokenType.Module;
			goto IL_03fb;
			IL_015a:
			type = TokenType.InterfaceImpl;
			goto IL_03fb;
			IL_0165:
			type = TokenType.MemberRef;
			goto IL_03fb;
			IL_014f:
			type = TokenType.Param;
			goto IL_03fb;
			IL_0139:
			type = TokenType.TypeRef;
			goto IL_03fb;
			IL_0144:
			type = TokenType.TypeDef;
			goto IL_03fb;
			IL_012e:
			type = TokenType.Field;
			goto IL_03fb;
			IL_0069:
			type = TokenType.TypeRef;
			goto IL_03fb;
			IL_02b8:
			type = TokenType.TypeSpec;
			goto IL_03fb;
			IL_02ad:
			type = TokenType.Method;
			goto IL_03fb;
			IL_02a2:
			type = TokenType.ModuleRef;
			goto IL_03fb;
			IL_0297:
			type = TokenType.TypeRef;
			goto IL_03fb;
			IL_00b4:
			type = TokenType.Property;
			goto IL_03fb;
			IL_025a:
			type = TokenType.Assembly;
			goto IL_03fb;
			IL_024f:
			type = TokenType.Method;
			goto IL_03fb;
			IL_00a9:
			type = TokenType.Param;
			goto IL_03fb;
			IL_03fb:
			return new MetadataToken(type, rid);
			IL_0074:
			type = TokenType.TypeSpec;
			goto IL_03fb;
			IL_01f0:
			type = TokenType.GenericParam;
			goto IL_03fb;
			IL_01e5:
			type = TokenType.ManifestResource;
			goto IL_03fb;
			IL_01da:
			type = TokenType.ExportedType;
			goto IL_03fb;
			IL_01cf:
			type = TokenType.File;
			goto IL_03fb;
			end_IL_0001:
			break;
		}
		return MetadataToken.Zero;
	}

	public static uint CompressMetadataToken(this CodedIndex self, MetadataToken token)
	{
		uint result = 0u;
		if (token.RID == 0)
		{
			return result;
		}
		switch (self)
		{
		case CodedIndex.TypeDefOrRef:
			result = token.RID << 2;
			switch (token.TokenType)
			{
			case TokenType.TypeDef:
				return result | 0;
			case TokenType.TypeRef:
				return result | 1;
			case TokenType.TypeSpec:
				return result | 2;
			}
			break;
		case CodedIndex.HasConstant:
			result = token.RID << 2;
			switch (token.TokenType)
			{
			case TokenType.Field:
				return result | 0;
			case TokenType.Param:
				return result | 1;
			case TokenType.Property:
				return result | 2;
			}
			break;
		case CodedIndex.HasCustomAttribute:
			result = token.RID << 5;
			switch (token.TokenType)
			{
			case TokenType.Method:
				return result | 0;
			case TokenType.Field:
				return result | 1;
			case TokenType.TypeRef:
				return result | 2;
			case TokenType.TypeDef:
				return result | 3;
			case TokenType.Param:
				return result | 4;
			case TokenType.InterfaceImpl:
				return result | 5;
			case TokenType.MemberRef:
				return result | 6;
			case TokenType.Module:
				return result | 7;
			case TokenType.Permission:
				return result | 8;
			case TokenType.Property:
				return result | 9;
			case TokenType.Event:
				return result | 0xA;
			case TokenType.Signature:
				return result | 0xB;
			case TokenType.ModuleRef:
				return result | 0xC;
			case TokenType.TypeSpec:
				return result | 0xD;
			case TokenType.Assembly:
				return result | 0xE;
			case TokenType.AssemblyRef:
				return result | 0xF;
			case TokenType.File:
				return result | 0x10;
			case TokenType.ExportedType:
				return result | 0x11;
			case TokenType.ManifestResource:
				return result | 0x12;
			case TokenType.GenericParam:
				return result | 0x13;
			}
			break;
		case CodedIndex.HasFieldMarshal:
			result = token.RID << 1;
			switch (token.TokenType)
			{
			case TokenType.Field:
				return result | 0;
			case TokenType.Param:
				return result | 1;
			}
			break;
		case CodedIndex.HasDeclSecurity:
			result = token.RID << 2;
			switch (token.TokenType)
			{
			case TokenType.TypeDef:
				return result | 0;
			case TokenType.Method:
				return result | 1;
			case TokenType.Assembly:
				return result | 2;
			}
			break;
		case CodedIndex.MemberRefParent:
			result = token.RID << 3;
			switch (token.TokenType)
			{
			case TokenType.TypeDef:
				return result | 0;
			case TokenType.TypeRef:
				return result | 1;
			case TokenType.ModuleRef:
				return result | 2;
			case TokenType.Method:
				return result | 3;
			case TokenType.TypeSpec:
				return result | 4;
			}
			break;
		case CodedIndex.HasSemantics:
			result = token.RID << 1;
			switch (token.TokenType)
			{
			case TokenType.Event:
				return result | 0;
			case TokenType.Property:
				return result | 1;
			}
			break;
		case CodedIndex.MethodDefOrRef:
			result = token.RID << 1;
			switch (token.TokenType)
			{
			case TokenType.Method:
				return result | 0;
			case TokenType.MemberRef:
				return result | 1;
			}
			break;
		case CodedIndex.MemberForwarded:
			result = token.RID << 1;
			switch (token.TokenType)
			{
			case TokenType.Field:
				return result | 0;
			case TokenType.Method:
				return result | 1;
			}
			break;
		case CodedIndex.Implementation:
			result = token.RID << 2;
			switch (token.TokenType)
			{
			case TokenType.File:
				return result | 0;
			case TokenType.AssemblyRef:
				return result | 1;
			case TokenType.ExportedType:
				return result | 2;
			}
			break;
		case CodedIndex.CustomAttributeType:
			result = token.RID << 3;
			switch (token.TokenType)
			{
			case TokenType.Method:
				return result | 2;
			case TokenType.MemberRef:
				return result | 3;
			}
			break;
		case CodedIndex.ResolutionScope:
			result = token.RID << 2;
			switch (token.TokenType)
			{
			case TokenType.Module:
				return result | 0;
			case TokenType.ModuleRef:
				return result | 1;
			case TokenType.AssemblyRef:
				return result | 2;
			case TokenType.TypeRef:
				return result | 3;
			}
			break;
		case CodedIndex.TypeOrMethodDef:
			result = token.RID << 1;
			switch (token.TokenType)
			{
			case TokenType.TypeDef:
				return result | 0;
			case TokenType.Method:
				return result | 1;
			}
			break;
		}
		throw new ArgumentException();
	}

	public static int GetSize(this CodedIndex self, Func<Table, int> counter)
	{
		int num;
		Table[] array;
		switch (self)
		{
		case CodedIndex.TypeDefOrRef:
			num = 2;
			array = new Table[3]
			{
				Table.TypeDef,
				Table.TypeRef,
				Table.TypeSpec
			};
			break;
		case CodedIndex.HasConstant:
			num = 2;
			array = new Table[3]
			{
				Table.Field,
				Table.Param,
				Table.Property
			};
			break;
		case CodedIndex.HasCustomAttribute:
			num = 5;
			array = new Table[20]
			{
				Table.Method,
				Table.Field,
				Table.TypeRef,
				Table.TypeDef,
				Table.Param,
				Table.InterfaceImpl,
				Table.MemberRef,
				Table.Module,
				Table.DeclSecurity,
				Table.Property,
				Table.Event,
				Table.StandAloneSig,
				Table.ModuleRef,
				Table.TypeSpec,
				Table.Assembly,
				Table.AssemblyRef,
				Table.File,
				Table.ExportedType,
				Table.ManifestResource,
				Table.GenericParam
			};
			break;
		case CodedIndex.HasFieldMarshal:
			num = 1;
			array = new Table[2]
			{
				Table.Field,
				Table.Param
			};
			break;
		case CodedIndex.HasDeclSecurity:
			num = 2;
			array = new Table[3]
			{
				Table.TypeDef,
				Table.Method,
				Table.Assembly
			};
			break;
		case CodedIndex.MemberRefParent:
			num = 3;
			array = new Table[5]
			{
				Table.TypeDef,
				Table.TypeRef,
				Table.ModuleRef,
				Table.Method,
				Table.TypeSpec
			};
			break;
		case CodedIndex.HasSemantics:
			num = 1;
			array = new Table[2]
			{
				Table.Event,
				Table.Property
			};
			break;
		case CodedIndex.MethodDefOrRef:
			num = 1;
			array = new Table[2]
			{
				Table.Method,
				Table.MemberRef
			};
			break;
		case CodedIndex.MemberForwarded:
			num = 1;
			array = new Table[2]
			{
				Table.Field,
				Table.Method
			};
			break;
		case CodedIndex.Implementation:
			num = 2;
			array = new Table[3]
			{
				Table.File,
				Table.AssemblyRef,
				Table.ExportedType
			};
			break;
		case CodedIndex.CustomAttributeType:
			num = 3;
			array = new Table[2]
			{
				Table.Method,
				Table.MemberRef
			};
			break;
		case CodedIndex.ResolutionScope:
			num = 2;
			array = new Table[4]
			{
				Table.Module,
				Table.ModuleRef,
				Table.AssemblyRef,
				Table.TypeRef
			};
			break;
		case CodedIndex.TypeOrMethodDef:
			num = 1;
			array = new Table[2]
			{
				Table.TypeDef,
				Table.Method
			};
			break;
		default:
			throw new ArgumentException();
		}
		int num2 = 0;
		for (int i = 0; i < array.Length; i++)
		{
			num2 = Math.Max(counter(array[i]), num2);
		}
		if (num2 >= 1 << 16 - num)
		{
			return 4;
		}
		return 2;
	}

	public static bool GetHasSecurityDeclarations(this ISecurityDeclarationProvider self, ModuleDefinition module)
	{
		if (module.HasImage())
		{
			return module.Read(self, (ISecurityDeclarationProvider provider, MetadataReader reader) => reader.HasSecurityDeclarations(provider));
		}
		return false;
	}

	public static Collection<SecurityDeclaration> GetSecurityDeclarations(this ISecurityDeclarationProvider self, ref Collection<SecurityDeclaration> variable, ModuleDefinition module)
	{
		if (!module.HasImage())
		{
			return variable = new Collection<SecurityDeclaration>();
		}
		return module.Read(ref variable, self, (ISecurityDeclarationProvider provider, MetadataReader reader) => reader.ReadSecurityDeclarations(provider));
	}

	public static void CheckName(string name)
	{
		if (name == null)
		{
			throw new ArgumentNullException("name");
		}
		if (name.Length == 0)
		{
			throw new ArgumentException("Empty name");
		}
	}

	public static void ResolveConstant(this IConstantProvider self, ref object constant, ModuleDefinition module)
	{
		if (module == null)
		{
			constant = NoValue;
			return;
		}
		lock (module.SyncRoot)
		{
			if (constant != NotResolved)
			{
				return;
			}
			if (module.HasImage())
			{
				constant = module.Read(self, (IConstantProvider provider, MetadataReader reader) => reader.ReadConstant(provider));
			}
			else
			{
				constant = NoValue;
			}
		}
	}

	public static bool GetHasCustomAttributes(this Mono.Cecil.ICustomAttributeProvider self, ModuleDefinition module)
	{
		if (module.HasImage())
		{
			return module.Read(self, (Mono.Cecil.ICustomAttributeProvider provider, MetadataReader reader) => reader.HasCustomAttributes(provider));
		}
		return false;
	}

	public static Collection<CustomAttribute> GetCustomAttributes(this Mono.Cecil.ICustomAttributeProvider self, ref Collection<CustomAttribute> variable, ModuleDefinition module)
	{
		if (!module.HasImage())
		{
			return variable = new Collection<CustomAttribute>();
		}
		return module.Read(ref variable, self, (Mono.Cecil.ICustomAttributeProvider provider, MetadataReader reader) => reader.ReadCustomAttributes(provider));
	}

	public static bool ContainsGenericParameter(this IGenericInstance self)
	{
		Collection<TypeReference> genericArguments = self.GenericArguments;
		for (int i = 0; i < genericArguments.Count; i++)
		{
			if (genericArguments[i].ContainsGenericParameter)
			{
				return true;
			}
		}
		return false;
	}

	public static void GenericInstanceFullName(this IGenericInstance self, StringBuilder builder)
	{
		builder.Append("<");
		Collection<TypeReference> genericArguments = self.GenericArguments;
		for (int i = 0; i < genericArguments.Count; i++)
		{
			if (i > 0)
			{
				builder.Append(",");
			}
			builder.Append(genericArguments[i].FullName);
		}
		builder.Append(">");
	}

	public static bool GetHasGenericParameters(this IGenericParameterProvider self, ModuleDefinition module)
	{
		if (module.HasImage())
		{
			return module.Read(self, (IGenericParameterProvider provider, MetadataReader reader) => reader.HasGenericParameters(provider));
		}
		return false;
	}

	public static Collection<GenericParameter> GetGenericParameters(this IGenericParameterProvider self, ref Collection<GenericParameter> collection, ModuleDefinition module)
	{
		if (!module.HasImage())
		{
			return collection = new GenericParameterCollection(self);
		}
		return module.Read(ref collection, self, (IGenericParameterProvider provider, MetadataReader reader) => reader.ReadGenericParameters(provider));
	}

	public static bool GetHasMarshalInfo(this IMarshalInfoProvider self, ModuleDefinition module)
	{
		if (module.HasImage())
		{
			return module.Read(self, (IMarshalInfoProvider provider, MetadataReader reader) => reader.HasMarshalInfo(provider));
		}
		return false;
	}

	public static MarshalInfo GetMarshalInfo(this IMarshalInfoProvider self, ref MarshalInfo variable, ModuleDefinition module)
	{
		if (!module.HasImage())
		{
			return null;
		}
		return module.Read(ref variable, self, (IMarshalInfoProvider provider, MetadataReader reader) => reader.ReadMarshalInfo(provider));
	}

	public static void CheckModifier(TypeReference modifierType, TypeReference type)
	{
		if (modifierType == null)
		{
			throw new ArgumentNullException("modifierType");
		}
		if (type == null)
		{
			throw new ArgumentNullException("type");
		}
	}

	public static bool HasImplicitThis(this IMethodSignature self)
	{
		if (self.HasThis)
		{
			return !self.ExplicitThis;
		}
		return false;
	}

	public static void MethodSignatureFullName(this IMethodSignature self, StringBuilder builder)
	{
		builder.Append("(");
		if (self.HasParameters)
		{
			Collection<ParameterDefinition> parameters = self.Parameters;
			for (int i = 0; i < parameters.Count; i++)
			{
				ParameterDefinition parameterDefinition = parameters[i];
				if (i > 0)
				{
					builder.Append(",");
				}
				if (parameterDefinition.ParameterType.IsSentinel)
				{
					builder.Append("...,");
				}
				builder.Append(parameterDefinition.ParameterType.FullName);
			}
		}
		builder.Append(")");
	}

	public static bool GetAttributes(this uint self, uint attributes)
	{
		return (self & attributes) != 0;
	}

	public static uint SetAttributes(this uint self, uint attributes, bool value)
	{
		if (value)
		{
			return self | attributes;
		}
		return self & ~attributes;
	}

	public static bool GetMaskedAttributes(this uint self, uint mask, uint attributes)
	{
		return (self & mask) == attributes;
	}

	public static uint SetMaskedAttributes(this uint self, uint mask, uint attributes, bool value)
	{
		if (value)
		{
			self &= ~mask;
			return self | attributes;
		}
		return self & ~(mask & attributes);
	}

	public static bool GetAttributes(this ushort self, ushort attributes)
	{
		return (self & attributes) != 0;
	}

	public static ushort SetAttributes(this ushort self, ushort attributes, bool value)
	{
		if (value)
		{
			return (ushort)(self | attributes);
		}
		return (ushort)(self & ~attributes);
	}

	public static bool GetMaskedAttributes(this ushort self, ushort mask, uint attributes)
	{
		return (self & mask) == attributes;
	}

	public static ushort SetMaskedAttributes(this ushort self, ushort mask, uint attributes, bool value)
	{
		if (value)
		{
			self = (ushort)(self & ~mask);
			return (ushort)(self | attributes);
		}
		return (ushort)(self & ~(mask & attributes));
	}

	public static ParameterDefinition GetParameter(this Mono.Cecil.Cil.MethodBody self, int index)
	{
		MethodDefinition method = self.method;
		if (method.HasThis)
		{
			if (index == 0)
			{
				return self.ThisParameter;
			}
			index--;
		}
		Collection<ParameterDefinition> parameters = method.Parameters;
		if (index < 0 || index >= parameters.size)
		{
			return null;
		}
		return parameters[index];
	}

	public static VariableDefinition GetVariable(this Mono.Cecil.Cil.MethodBody self, int index)
	{
		Collection<VariableDefinition> variables = self.Variables;
		if (index < 0 || index >= variables.size)
		{
			return null;
		}
		return variables[index];
	}

	public static bool GetSemantics(this MethodDefinition self, MethodSemanticsAttributes semantics)
	{
		return (self.SemanticsAttributes & semantics) != 0;
	}

	public static void SetSemantics(this MethodDefinition self, MethodSemanticsAttributes semantics, bool value)
	{
		if (value)
		{
			self.SemanticsAttributes |= semantics;
		}
		else
		{
			self.SemanticsAttributes &= (MethodSemanticsAttributes)(ushort)(~(int)semantics);
		}
	}

	public static bool IsVarArg(this IMethodSignature self)
	{
		return (self.CallingConvention & MethodCallingConvention.VarArg) != 0;
	}

	public static int GetSentinelPosition(this IMethodSignature self)
	{
		if (!self.HasParameters)
		{
			return -1;
		}
		Collection<ParameterDefinition> parameters = self.Parameters;
		for (int i = 0; i < parameters.Count; i++)
		{
			if (parameters[i].ParameterType.IsSentinel)
			{
				return i;
			}
		}
		return -1;
	}

	public static void CheckParameters(object parameters)
	{
		if (parameters == null)
		{
			throw new ArgumentNullException("parameters");
		}
	}

	public static bool HasImage(this ModuleDefinition self)
	{
		return self?.HasImage ?? false;
	}

	public static bool IsCorlib(this ModuleDefinition module)
	{
		if (module.Assembly == null)
		{
			return false;
		}
		return module.Assembly.Name.Name == "mscorlib";
	}

	public static string GetFullyQualifiedName(this Stream self)
	{
		if (!(self is FileStream fileStream))
		{
			return string.Empty;
		}
		return Path.GetFullPath(fileStream.Name);
	}

	public static TargetRuntime ParseRuntime(this string self)
	{
		switch (self[1])
		{
		case '1':
			if (self[3] != '0')
			{
				return TargetRuntime.Net_1_1;
			}
			return TargetRuntime.Net_1_0;
		case '2':
			return TargetRuntime.Net_2_0;
		default:
			return TargetRuntime.Net_4_0;
		}
	}

	public static string RuntimeVersionString(this TargetRuntime runtime)
	{
		return runtime switch
		{
			TargetRuntime.Net_1_0 => "v1.0.3705", 
			TargetRuntime.Net_1_1 => "v1.1.4322", 
			TargetRuntime.Net_2_0 => "v2.0.50727", 
			_ => "v4.0.30319", 
		};
	}

	public static TypeReference GetEnumUnderlyingType(this TypeDefinition self)
	{
		Collection<FieldDefinition> fields = self.Fields;
		for (int i = 0; i < fields.Count; i++)
		{
			FieldDefinition fieldDefinition = fields[i];
			if (!fieldDefinition.IsStatic)
			{
				return fieldDefinition.FieldType;
			}
		}
		throw new ArgumentException();
	}

	public static TypeDefinition GetNestedType(this TypeDefinition self, string fullname)
	{
		if (!self.HasNestedTypes)
		{
			return null;
		}
		Collection<TypeDefinition> nestedTypes = self.NestedTypes;
		for (int i = 0; i < nestedTypes.Count; i++)
		{
			TypeDefinition typeDefinition = nestedTypes[i];
			if (typeDefinition.TypeFullName() == fullname)
			{
				return typeDefinition;
			}
		}
		return null;
	}

	public static bool IsPrimitive(this ElementType self)
	{
		switch (self)
		{
		case ElementType.Boolean:
		case ElementType.Char:
		case ElementType.I1:
		case ElementType.U1:
		case ElementType.I2:
		case ElementType.U2:
		case ElementType.I4:
		case ElementType.U4:
		case ElementType.I8:
		case ElementType.U8:
		case ElementType.R4:
		case ElementType.R8:
		case ElementType.I:
		case ElementType.U:
			return true;
		default:
			return false;
		}
	}

	public static string TypeFullName(this TypeReference self)
	{
		if (!string.IsNullOrEmpty(self.Namespace))
		{
			return self.Namespace + "." + self.Name;
		}
		return self.Name;
	}

	public static bool IsTypeOf(this TypeReference self, string @namespace, string name)
	{
		if (self.Name == name)
		{
			return self.Namespace == @namespace;
		}
		return false;
	}

	public static bool IsTypeSpecification(this TypeReference type)
	{
		switch (type.etype)
		{
		case ElementType.Ptr:
		case ElementType.ByRef:
		case ElementType.Var:
		case ElementType.Array:
		case ElementType.GenericInst:
		case ElementType.FnPtr:
		case ElementType.SzArray:
		case ElementType.MVar:
		case ElementType.CModReqD:
		case ElementType.CModOpt:
		case ElementType.Sentinel:
		case ElementType.Pinned:
			return true;
		default:
			return false;
		}
	}

	public static TypeDefinition CheckedResolve(this TypeReference self)
	{
		return self.Resolve() ?? throw new ResolutionException(self);
	}

	public static void CheckType(TypeReference type)
	{
		if (type == null)
		{
			throw new ArgumentNullException("type");
		}
	}

	public static RSA CreateRSA(this StrongNameKeyPair key_pair)
	{
		if (!TryGetKeyContainer(key_pair, out var key, out var key_container))
		{
			return CryptoConvert.FromCapiKeyBlob(key);
		}
		return new RSACryptoServiceProvider(new CspParameters
		{
			Flags = CspProviderFlags.UseMachineKeyStore,
			KeyContainerName = key_container,
			KeyNumber = 2
		});
	}

	private static bool TryGetKeyContainer(ISerializable key_pair, out byte[] key, out string key_container)
	{
		SerializationInfo serializationInfo = new SerializationInfo(typeof(StrongNameKeyPair), new FormatterConverter());
		key_pair.GetObjectData(serializationInfo, default(StreamingContext));
		key = (byte[])serializationInfo.GetValue("_keyPairArray", typeof(byte[]));
		key_container = serializationInfo.GetString("_keyPairContainer");
		return key_container != null;
	}

	public static bool IsNullOrEmpty<T>(this T[] self)
	{
		if (self != null)
		{
			return self.Length == 0;
		}
		return true;
	}

	public static bool IsNullOrEmpty<T>(this Collection<T> self)
	{
		if (self != null)
		{
			return self.size == 0;
		}
		return true;
	}

	public static T[] Resize<T>(this T[] self, int length)
	{
		Array.Resize(ref self, length);
		return self;
	}
}


public struct ArrayDimension
{
	private int? lower_bound;

	private int? upper_bound;

	public int? LowerBound
	{
		get
		{
			return lower_bound;
		}
		set
		{
			lower_bound = value;
		}
	}

	public int? UpperBound
	{
		get
		{
			return upper_bound;
		}
		set
		{
			upper_bound = value;
		}
	}

	public bool IsSized
	{
		get
		{
			if (!lower_bound.HasValue)
			{
				return upper_bound.HasValue;
			}
			return true;
		}
	}

	public ArrayDimension(int? lowerBound, int? upperBound)
	{
		lower_bound = lowerBound;
		upper_bound = upperBound;
	}

	public override string ToString()
	{
		if (IsSized)
		{
			return lower_bound + "..." + upper_bound;
		}
		return string.Empty;
	}
}


using System;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

public sealed class ArrayType : TypeSpecification
{
	private Collection<ArrayDimension> dimensions;

	public Collection<ArrayDimension> Dimensions
	{
		get
		{
			if (dimensions != null)
			{
				return dimensions;
			}
			dimensions = new Collection<ArrayDimension>();
			dimensions.Add(default(ArrayDimension));
			return dimensions;
		}
	}

	public int Rank
	{
		get
		{
			if (dimensions != null)
			{
				return dimensions.Count;
			}
			return 1;
		}
	}

	public bool IsVector
	{
		get
		{
			if (dimensions == null)
			{
				return true;
			}
			if (dimensions.Count > 1)
			{
				return false;
			}
			return !dimensions[0].IsSized;
		}
	}

	public override bool IsValueType
	{
		get
		{
			return false;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override string Name => base.Name + Suffix;

	public override string FullName => base.FullName + Suffix;

	private string Suffix
	{
		get
		{
			if (IsVector)
			{
				return "[]";
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("[");
			for (int i = 0; i < dimensions.Count; i++)
			{
				if (i > 0)
				{
					stringBuilder.Append(",");
				}
				stringBuilder.Append(dimensions[i].ToString());
			}
			stringBuilder.Append("]");
			return stringBuilder.ToString();
		}
	}

	public override bool IsArray => true;

	public ArrayType(TypeReference type)
		: base(type)
	{
		Mixin.CheckType(type);
		etype = Mono.Cecil.Metadata.ElementType.Array;
	}

	public ArrayType(TypeReference type, int rank)
		: this(type)
	{
		Mixin.CheckType(type);
		if (rank != 1)
		{
			dimensions = new Collection<ArrayDimension>(rank);
			for (int i = 0; i < rank; i++)
			{
				dimensions.Add(default(ArrayDimension));
			}
			etype = Mono.Cecil.Metadata.ElementType.Array;
		}
	}
}


using System;
using System.IO;
using Mono.Cecil;
using Mono.Collections.Generic;

public sealed class AssemblyDefinition : ICustomAttributeProvider, IMetadataTokenProvider, ISecurityDeclarationProvider
{
	private AssemblyNameDefinition name;

	internal ModuleDefinition main_module;

	private Collection<ModuleDefinition> modules;

	private Collection<CustomAttribute> custom_attributes;

	private Collection<SecurityDeclaration> security_declarations;

	public AssemblyNameDefinition Name
	{
		get
		{
			return name;
		}
		set
		{
			name = value;
		}
	}

	public string FullName
	{
		get
		{
			if (name == null)
			{
				return string.Empty;
			}
			return name.FullName;
		}
	}

	public MetadataToken MetadataToken
	{
		get
		{
			return new MetadataToken(TokenType.Assembly, 1);
		}
		set
		{
		}
	}

	public Collection<ModuleDefinition> Modules
	{
		get
		{
			if (modules != null)
			{
				return modules;
			}
			if (main_module.HasImage)
			{
				return main_module.Read(ref modules, this, (AssemblyDefinition _, MetadataReader reader) => reader.ReadModules());
			}
			return modules = new Collection<ModuleDefinition>(1) { main_module };
		}
	}

	public ModuleDefinition MainModule => main_module;

	public MethodDefinition EntryPoint
	{
		get
		{
			return main_module.EntryPoint;
		}
		set
		{
			main_module.EntryPoint = value;
		}
	}

	public bool HasCustomAttributes
	{
		get
		{
			if (custom_attributes != null)
			{
				return custom_attributes.Count > 0;
			}
			return this.GetHasCustomAttributes(main_module);
		}
	}

	public Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, main_module);

	public bool HasSecurityDeclarations
	{
		get
		{
			if (security_declarations != null)
			{
				return security_declarations.Count > 0;
			}
			return this.GetHasSecurityDeclarations(main_module);
		}
	}

	public Collection<SecurityDeclaration> SecurityDeclarations => security_declarations ?? this.GetSecurityDeclarations(ref security_declarations, main_module);

	internal AssemblyDefinition()
	{
	}

	public static AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleKind kind)
	{
		return CreateAssembly(assemblyName, moduleName, new ModuleParameters
		{
			Kind = kind
		});
	}

	public static AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleParameters parameters)
	{
		if (assemblyName == null)
		{
			throw new ArgumentNullException("assemblyName");
		}
		if (moduleName == null)
		{
			throw new ArgumentNullException("moduleName");
		}
		Mixin.CheckParameters(parameters);
		if (parameters.Kind == ModuleKind.NetModule)
		{
			throw new ArgumentException("kind");
		}
		AssemblyDefinition assembly = ModuleDefinition.CreateModule(moduleName, parameters).Assembly;
		assembly.Name = assemblyName;
		return assembly;
	}

	public static AssemblyDefinition ReadAssembly(string fileName)
	{
		return ReadAssembly(ModuleDefinition.ReadModule(fileName));
	}

	public static AssemblyDefinition ReadAssembly(string fileName, ReaderParameters parameters)
	{
		return ReadAssembly(ModuleDefinition.ReadModule(fileName, parameters));
	}

	public static AssemblyDefinition ReadAssembly(Stream stream)
	{
		return ReadAssembly(ModuleDefinition.ReadModule(stream));
	}

	public static AssemblyDefinition ReadAssembly(Stream stream, ReaderParameters parameters)
	{
		return ReadAssembly(ModuleDefinition.ReadModule(stream, parameters));
	}

	private static AssemblyDefinition ReadAssembly(ModuleDefinition module)
	{
		return module.Assembly ?? throw new ArgumentException();
	}

	public void Write(string fileName)
	{
		Write(fileName, new WriterParameters());
	}

	public void Write(Stream stream)
	{
		Write(stream, new WriterParameters());
	}

	public void Write(string fileName, WriterParameters parameters)
	{
		main_module.Write(fileName, parameters);
	}

	public void Write(Stream stream, WriterParameters parameters)
	{
		main_module.Write(stream, parameters);
	}

	public override string ToString()
	{
		return FullName;
	}
}


using System;

[Flags]
public enum AssemblyAttributes : uint
{
	PublicKey = 1u,
	SideBySideCompatible = 0u,
	Retargetable = 0x100u,
	WindowsRuntime = 0x200u,
	DisableJITCompileOptimizer = 0x4000u,
	EnableJITCompileTracking = 0x8000u
}


public enum AssemblyHashAlgorithm : uint
{
	None = 0u,
	Reserved = 32771u,
	SHA1 = 32772u
}


using Mono.Cecil;

public sealed class AssemblyLinkedResource : Resource
{
	private AssemblyNameReference reference;

	public AssemblyNameReference Assembly
	{
		get
		{
			return reference;
		}
		set
		{
			reference = value;
		}
	}

	public override ResourceType ResourceType => ResourceType.AssemblyLinked;

	public AssemblyLinkedResource(string name, ManifestResourceAttributes flags)
		: base(name, flags)
	{
	}

	public AssemblyLinkedResource(string name, ManifestResourceAttributes flags, AssemblyNameReference reference)
		: base(name, flags)
	{
		this.reference = reference;
	}
}


using System;
using Mono;
using Mono.Cecil;

public sealed class AssemblyNameDefinition : AssemblyNameReference
{
	public override byte[] Hash => Empty<byte>.Array;

	internal AssemblyNameDefinition()
	{
		token = new MetadataToken(TokenType.Assembly, 1);
	}

	public AssemblyNameDefinition(string name, Version version)
		: base(name, version)
	{
		token = new MetadataToken(TokenType.Assembly, 1);
	}
}


using System;
using System.Globalization;
using System.Security.Cryptography;
using System.Text;
using Mono;
using Mono.Cecil;

public class AssemblyNameReference : IMetadataScope, IMetadataTokenProvider
{
	private string name;

	private string culture;

	private Version version;

	private uint attributes;

	private byte[] public_key;

	private byte[] public_key_token;

	private AssemblyHashAlgorithm hash_algorithm;

	private byte[] hash;

	internal MetadataToken token;

	private string full_name;

	public string Name
	{
		get
		{
			return name;
		}
		set
		{
			name = value;
			full_name = null;
		}
	}

	public string Culture
	{
		get
		{
			return culture;
		}
		set
		{
			culture = value;
			full_name = null;
		}
	}

	public Version Version
	{
		get
		{
			return version;
		}
		set
		{
			version = value;
			full_name = null;
		}
	}

	public AssemblyAttributes Attributes
	{
		get
		{
			return (AssemblyAttributes)attributes;
		}
		set
		{
			attributes = (uint)value;
		}
	}

	public bool HasPublicKey
	{
		get
		{
			return attributes.GetAttributes(1u);
		}
		set
		{
			attributes = attributes.SetAttributes(1u, value);
		}
	}

	public bool IsSideBySideCompatible
	{
		get
		{
			return attributes.GetAttributes(0u);
		}
		set
		{
			attributes = attributes.SetAttributes(0u, value);
		}
	}

	public bool IsRetargetable
	{
		get
		{
			return attributes.GetAttributes(256u);
		}
		set
		{
			attributes = attributes.SetAttributes(256u, value);
		}
	}

	public bool IsWindowsRuntime
	{
		get
		{
			return attributes.GetAttributes(512u);
		}
		set
		{
			attributes = attributes.SetAttributes(512u, value);
		}
	}

	public byte[] PublicKey
	{
		get
		{
			return public_key ?? Empty<byte>.Array;
		}
		set
		{
			public_key = value;
			HasPublicKey = !public_key.IsNullOrEmpty();
			public_key_token = Empty<byte>.Array;
			full_name = null;
		}
	}

	public byte[] PublicKeyToken
	{
		get
		{
			if (public_key_token.IsNullOrEmpty() && !public_key.IsNullOrEmpty())
			{
				byte[] array = HashPublicKey();
				byte[] array2 = new byte[8];
				Array.Copy(array, array.Length - 8, array2, 0, 8);
				Array.Reverse((Array)array2, 0, 8);
				public_key_token = array2;
			}
			return public_key_token ?? Empty<byte>.Array;
		}
		set
		{
			public_key_token = value;
			full_name = null;
		}
	}

	public virtual MetadataScopeType MetadataScopeType => MetadataScopeType.AssemblyNameReference;

	public string FullName
	{
		get
		{
			if (full_name != null)
			{
				return full_name;
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(name);
			if (version != null)
			{
				stringBuilder.Append(", ");
				stringBuilder.Append("Version=");
				stringBuilder.Append(version.ToString());
			}
			stringBuilder.Append(", ");
			stringBuilder.Append("Culture=");
			stringBuilder.Append(string.IsNullOrEmpty(culture) ? "neutral" : culture);
			stringBuilder.Append(", ");
			stringBuilder.Append("PublicKeyToken=");
			byte[] publicKeyToken = PublicKeyToken;
			if (!publicKeyToken.IsNullOrEmpty() && publicKeyToken.Length != 0)
			{
				for (int i = 0; i < publicKeyToken.Length; i++)
				{
					stringBuilder.Append(publicKeyToken[i].ToString("x2"));
				}
			}
			else
			{
				stringBuilder.Append("null");
			}
			return full_name = stringBuilder.ToString();
		}
	}

	public AssemblyHashAlgorithm HashAlgorithm
	{
		get
		{
			return hash_algorithm;
		}
		set
		{
			hash_algorithm = value;
		}
	}

	public virtual byte[] Hash
	{
		get
		{
			return hash;
		}
		set
		{
			hash = value;
		}
	}

	public MetadataToken MetadataToken
	{
		get
		{
			return token;
		}
		set
		{
			token = value;
		}
	}

	private byte[] HashPublicKey()
	{
		AssemblyHashAlgorithm assemblyHashAlgorithm = hash_algorithm;
		HashAlgorithm hashAlgorithm = ((assemblyHashAlgorithm != AssemblyHashAlgorithm.Reserved) ? ((HashAlgorithm)SHA1.Create()) : ((HashAlgorithm)MD5.Create()));
		using (hashAlgorithm)
		{
			return hashAlgorithm.ComputeHash(public_key);
		}
	}

	public static AssemblyNameReference Parse(string fullName)
	{
		if (fullName == null)
		{
			throw new ArgumentNullException("fullName");
		}
		if (fullName.Length == 0)
		{
			throw new ArgumentException("Name can not be empty");
		}
		AssemblyNameReference assemblyNameReference = new AssemblyNameReference();
		string[] array = fullName.Split(new char[1] { ',' });
		for (int i = 0; i < array.Length; i++)
		{
			string text = array[i].Trim();
			if (i == 0)
			{
				assemblyNameReference.Name = text;
				continue;
			}
			string[] array2 = text.Split(new char[1] { '=' });
			if (array2.Length != 2)
			{
				throw new ArgumentException("Malformed name");
			}
			switch (array2[0].ToLowerInvariant())
			{
			case "version":
				assemblyNameReference.Version = new Version(array2[1]);
				break;
			case "culture":
				assemblyNameReference.Culture = array2[1];
				break;
			case "publickeytoken":
			{
				string text2 = array2[1];
				if (!(text2 == "null"))
				{
					assemblyNameReference.PublicKeyToken = new byte[text2.Length / 2];
					for (int j = 0; j < assemblyNameReference.PublicKeyToken.Length; j++)
					{
						assemblyNameReference.PublicKeyToken[j] = byte.Parse(text2.Substring(j * 2, 2), NumberStyles.HexNumber);
					}
				}
				break;
			}
			}
		}
		return assemblyNameReference;
	}

	internal AssemblyNameReference()
	{
	}

	public AssemblyNameReference(string name, Version version)
	{
		if (name == null)
		{
			throw new ArgumentNullException("name");
		}
		this.name = name;
		this.version = version;
		hash_algorithm = AssemblyHashAlgorithm.None;
		token = new MetadataToken(TokenType.AssemblyRef);
	}

	public override string ToString()
	{
		return FullName;
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.PE;

internal abstract class ModuleReader
{
	protected readonly Image image;

	protected readonly ModuleDefinition module;

	protected ModuleReader(Image image, ReadingMode mode)
	{
		this.image = image;
		module = new ModuleDefinition(image);
		module.ReadingMode = mode;
	}

	protected abstract void ReadModule();

	protected void ReadModuleManifest(MetadataReader reader)
	{
		reader.Populate(module);
		ReadAssembly(reader);
	}

	private void ReadAssembly(MetadataReader reader)
	{
		AssemblyNameDefinition assemblyNameDefinition = reader.ReadAssemblyNameDefinition();
		if (assemblyNameDefinition == null)
		{
			module.kind = ModuleKind.NetModule;
			return;
		}
		AssemblyDefinition assemblyDefinition = new AssemblyDefinition();
		assemblyDefinition.Name = assemblyNameDefinition;
		module.assembly = assemblyDefinition;
		assemblyDefinition.main_module = module;
	}

	public static ModuleDefinition CreateModuleFrom(Image image, ReaderParameters parameters)
	{
		ModuleReader moduleReader = CreateModuleReader(image, parameters.ReadingMode);
		ModuleDefinition moduleDefinition = moduleReader.module;
		if (parameters.AssemblyResolver != null)
		{
			moduleDefinition.assembly_resolver = parameters.AssemblyResolver;
		}
		if (parameters.MetadataResolver != null)
		{
			moduleDefinition.metadata_resolver = parameters.MetadataResolver;
		}
		moduleReader.ReadModule();
		ReadSymbols(moduleDefinition, parameters);
		return moduleDefinition;
	}

	private static void ReadSymbols(ModuleDefinition module, ReaderParameters parameters)
	{
		ISymbolReaderProvider symbolReaderProvider = parameters.SymbolReaderProvider;
		if (symbolReaderProvider == null && parameters.ReadSymbols)
		{
			symbolReaderProvider = SymbolProvider.GetPlatformReaderProvider();
		}
		if (symbolReaderProvider != null)
		{
			module.SymbolReaderProvider = symbolReaderProvider;
			ISymbolReader reader = ((parameters.SymbolStream != null) ? symbolReaderProvider.GetSymbolReader(module, parameters.SymbolStream) : symbolReaderProvider.GetSymbolReader(module, module.FullyQualifiedName));
			module.ReadSymbols(reader);
		}
	}

	private static ModuleReader CreateModuleReader(Image image, ReadingMode mode)
	{
		return mode switch
		{
			ReadingMode.Immediate => new ImmediateModuleReader(image), 
			ReadingMode.Deferred => new DeferredModuleReader(image), 
			_ => throw new ArgumentException(), 
		};
	}
}


using Mono.Cecil;
using Mono.Cecil.PE;
using Mono.Collections.Generic;

internal sealed class ImmediateModuleReader : ModuleReader
{
	public ImmediateModuleReader(Image image)
		: base(image, ReadingMode.Immediate)
	{
	}

	protected override void ReadModule()
	{
		module.Read(module, delegate(ModuleDefinition module, MetadataReader reader)
		{
			ReadModuleManifest(reader);
			ReadModule(module);
			return module;
		});
	}

	public static void ReadModule(ModuleDefinition module)
	{
		if (module.HasAssemblyReferences)
		{
			Read(module.AssemblyReferences);
		}
		if (module.HasResources)
		{
			Read(module.Resources);
		}
		if (module.HasModuleReferences)
		{
			Read(module.ModuleReferences);
		}
		if (module.HasTypes)
		{
			ReadTypes(module.Types);
		}
		if (module.HasExportedTypes)
		{
			Read(module.ExportedTypes);
		}
		if (module.HasCustomAttributes)
		{
			Read(module.CustomAttributes);
		}
		AssemblyDefinition assembly = module.Assembly;
		if (assembly != null)
		{
			if (assembly.HasCustomAttributes)
			{
				ReadCustomAttributes(assembly);
			}
			if (assembly.HasSecurityDeclarations)
			{
				Read(assembly.SecurityDeclarations);
			}
		}
	}

	private static void ReadTypes(Collection<TypeDefinition> types)
	{
		for (int i = 0; i < types.Count; i++)
		{
			ReadType(types[i]);
		}
	}

	private static void ReadType(TypeDefinition type)
	{
		ReadGenericParameters(type);
		if (type.HasInterfaces)
		{
			Read(type.Interfaces);
		}
		if (type.HasNestedTypes)
		{
			ReadTypes(type.NestedTypes);
		}
		if (type.HasLayoutInfo)
		{
			Read(type.ClassSize);
		}
		if (type.HasFields)
		{
			ReadFields(type);
		}
		if (type.HasMethods)
		{
			ReadMethods(type);
		}
		if (type.HasProperties)
		{
			ReadProperties(type);
		}
		if (type.HasEvents)
		{
			ReadEvents(type);
		}
		ReadSecurityDeclarations(type);
		ReadCustomAttributes(type);
	}

	private static void ReadGenericParameters(IGenericParameterProvider provider)
	{
		if (!provider.HasGenericParameters)
		{
			return;
		}
		Collection<GenericParameter> genericParameters = provider.GenericParameters;
		for (int i = 0; i < genericParameters.Count; i++)
		{
			GenericParameter genericParameter = genericParameters[i];
			if (genericParameter.HasConstraints)
			{
				Read(genericParameter.Constraints);
			}
			ReadCustomAttributes(genericParameter);
		}
	}

	private static void ReadSecurityDeclarations(ISecurityDeclarationProvider provider)
	{
		if (provider.HasSecurityDeclarations)
		{
			Collection<SecurityDeclaration> securityDeclarations = provider.SecurityDeclarations;
			for (int i = 0; i < securityDeclarations.Count; i++)
			{
				Read(securityDeclarations[i].SecurityAttributes);
			}
		}
	}

	private static void ReadCustomAttributes(ICustomAttributeProvider provider)
	{
		if (provider.HasCustomAttributes)
		{
			Collection<CustomAttribute> customAttributes = provider.CustomAttributes;
			for (int i = 0; i < customAttributes.Count; i++)
			{
				Read(customAttributes[i].ConstructorArguments);
			}
		}
	}

	private static void ReadFields(TypeDefinition type)
	{
		Collection<FieldDefinition> fields = type.Fields;
		for (int i = 0; i < fields.Count; i++)
		{
			FieldDefinition fieldDefinition = fields[i];
			if (fieldDefinition.HasConstant)
			{
				Read(fieldDefinition.Constant);
			}
			if (fieldDefinition.HasLayoutInfo)
			{
				Read(fieldDefinition.Offset);
			}
			if (fieldDefinition.RVA > 0)
			{
				Read(fieldDefinition.InitialValue);
			}
			if (fieldDefinition.HasMarshalInfo)
			{
				Read(fieldDefinition.MarshalInfo);
			}
			ReadCustomAttributes(fieldDefinition);
		}
	}

	private static void ReadMethods(TypeDefinition type)
	{
		Collection<MethodDefinition> methods = type.Methods;
		for (int i = 0; i < methods.Count; i++)
		{
			MethodDefinition methodDefinition = methods[i];
			ReadGenericParameters(methodDefinition);
			if (methodDefinition.HasParameters)
			{
				ReadParameters(methodDefinition);
			}
			if (methodDefinition.HasOverrides)
			{
				Read(methodDefinition.Overrides);
			}
			if (methodDefinition.IsPInvokeImpl)
			{
				Read(methodDefinition.PInvokeInfo);
			}
			ReadSecurityDeclarations(methodDefinition);
			ReadCustomAttributes(methodDefinition);
			MethodReturnType methodReturnType = methodDefinition.MethodReturnType;
			if (methodReturnType.HasConstant)
			{
				Read(methodReturnType.Constant);
			}
			if (methodReturnType.HasMarshalInfo)
			{
				Read(methodReturnType.MarshalInfo);
			}
			ReadCustomAttributes(methodReturnType);
		}
	}

	private static void ReadParameters(MethodDefinition method)
	{
		Collection<ParameterDefinition> parameters = method.Parameters;
		for (int i = 0; i < parameters.Count; i++)
		{
			ParameterDefinition parameterDefinition = parameters[i];
			if (parameterDefinition.HasConstant)
			{
				Read(parameterDefinition.Constant);
			}
			if (parameterDefinition.HasMarshalInfo)
			{
				Read(parameterDefinition.MarshalInfo);
			}
			ReadCustomAttributes(parameterDefinition);
		}
	}

	private static void ReadProperties(TypeDefinition type)
	{
		Collection<PropertyDefinition> properties = type.Properties;
		for (int i = 0; i < properties.Count; i++)
		{
			PropertyDefinition propertyDefinition = properties[i];
			Read(propertyDefinition.GetMethod);
			if (propertyDefinition.HasConstant)
			{
				Read(propertyDefinition.Constant);
			}
			ReadCustomAttributes(propertyDefinition);
		}
	}

	private static void ReadEvents(TypeDefinition type)
	{
		Collection<EventDefinition> events = type.Events;
		for (int i = 0; i < events.Count; i++)
		{
			EventDefinition eventDefinition = events[i];
			Read(eventDefinition.AddMethod);
			ReadCustomAttributes(eventDefinition);
		}
	}

	private static void Read(object collection)
	{
	}
}


using Mono.Cecil;
using Mono.Cecil.PE;

internal sealed class DeferredModuleReader : ModuleReader
{
	public DeferredModuleReader(Image image)
		: base(image, ReadingMode.Deferred)
	{
	}

	protected override void ReadModule()
	{
		module.Read(module, delegate(ModuleDefinition module, MetadataReader reader)
		{
			ReadModuleManifest(reader);
			return module;
		});
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;
using Mono.Collections.Generic;

internal sealed class MetadataReader : ByteBuffer
{
	internal readonly Image image;

	internal readonly ModuleDefinition module;

	internal readonly MetadataSystem metadata;

	internal IGenericContext context;

	internal CodeReader code;

	private uint Position
	{
		get
		{
			return (uint)position;
		}
		set
		{
			position = (int)value;
		}
	}

	public MetadataReader(ModuleDefinition module)
		: base(module.Image.MetadataSection.Data)
	{
		image = module.Image;
		this.module = module;
		metadata = module.MetadataSystem;
		code = new CodeReader(image.MetadataSection, this);
	}

	private int GetCodedIndexSize(CodedIndex index)
	{
		return image.GetCodedIndexSize(index);
	}

	private uint ReadByIndexSize(int size)
	{
		if (size == 4)
		{
			return ReadUInt32();
		}
		return ReadUInt16();
	}

	private byte[] ReadBlob()
	{
		BlobHeap blobHeap = image.BlobHeap;
		if (blobHeap == null)
		{
			position += 2;
			return Empty<byte>.Array;
		}
		return blobHeap.Read(ReadBlobIndex());
	}

	private byte[] ReadBlob(uint signature)
	{
		BlobHeap blobHeap = image.BlobHeap;
		if (blobHeap == null)
		{
			return Empty<byte>.Array;
		}
		return blobHeap.Read(signature);
	}

	private uint ReadBlobIndex()
	{
		return ReadByIndexSize(image.BlobHeap?.IndexSize ?? 2);
	}

	private string ReadString()
	{
		return image.StringHeap.Read(ReadByIndexSize(image.StringHeap.IndexSize));
	}

	private uint ReadStringIndex()
	{
		return ReadByIndexSize(image.StringHeap.IndexSize);
	}

	private uint ReadTableIndex(Table table)
	{
		return ReadByIndexSize(image.GetTableIndexSize(table));
	}

	private MetadataToken ReadMetadataToken(CodedIndex index)
	{
		return index.GetMetadataToken(ReadByIndexSize(GetCodedIndexSize(index)));
	}

	private int MoveTo(Table table)
	{
		TableInformation tableInformation = image.TableHeap[table];
		if (tableInformation.Length != 0)
		{
			Position = tableInformation.Offset;
		}
		return (int)tableInformation.Length;
	}

	private bool MoveTo(Table table, uint row)
	{
		TableInformation tableInformation = image.TableHeap[table];
		uint num = tableInformation.Length;
		if (num == 0 || row > num)
		{
			return false;
		}
		Position = tableInformation.Offset + tableInformation.RowSize * (row - 1);
		return true;
	}

	public AssemblyNameDefinition ReadAssemblyNameDefinition()
	{
		if (MoveTo(Table.Assembly) == 0)
		{
			return null;
		}
		AssemblyNameDefinition assemblyNameDefinition = new AssemblyNameDefinition();
		assemblyNameDefinition.HashAlgorithm = (AssemblyHashAlgorithm)ReadUInt32();
		PopulateVersionAndFlags(assemblyNameDefinition);
		assemblyNameDefinition.PublicKey = ReadBlob();
		PopulateNameAndCulture(assemblyNameDefinition);
		return assemblyNameDefinition;
	}

	public ModuleDefinition Populate(ModuleDefinition module)
	{
		if (MoveTo(Table.Module) == 0)
		{
			return module;
		}
		Advance(2);
		module.Name = ReadString();
		module.Mvid = image.GuidHeap.Read(ReadByIndexSize(image.GuidHeap.IndexSize));
		return module;
	}

	private void InitializeAssemblyReferences()
	{
		if (metadata.AssemblyReferences != null)
		{
			return;
		}
		int num = MoveTo(Table.AssemblyRef);
		AssemblyNameReference[] array = (metadata.AssemblyReferences = new AssemblyNameReference[num]);
		for (uint num2 = 0u; num2 < num; num2++)
		{
			AssemblyNameReference assemblyNameReference = new AssemblyNameReference();
			assemblyNameReference.token = new MetadataToken(TokenType.AssemblyRef, num2 + 1);
			PopulateVersionAndFlags(assemblyNameReference);
			byte[] array2 = ReadBlob();
			if (assemblyNameReference.HasPublicKey)
			{
				assemblyNameReference.PublicKey = array2;
			}
			else
			{
				assemblyNameReference.PublicKeyToken = array2;
			}
			PopulateNameAndCulture(assemblyNameReference);
			assemblyNameReference.Hash = ReadBlob();
			array[num2] = assemblyNameReference;
		}
	}

	public Collection<AssemblyNameReference> ReadAssemblyReferences()
	{
		InitializeAssemblyReferences();
		return new Collection<AssemblyNameReference>(metadata.AssemblyReferences);
	}

	public MethodDefinition ReadEntryPoint()
	{
		if (module.Image.EntryPointToken == 0)
		{
			return null;
		}
		return GetMethodDefinition(new MetadataToken(module.Image.EntryPointToken).RID);
	}

	public Collection<ModuleDefinition> ReadModules()
	{
		Collection<ModuleDefinition> collection = new Collection<ModuleDefinition>(1);
		collection.Add(module);
		int num = MoveTo(Table.File);
		for (uint num2 = 1u; num2 <= num; num2++)
		{
			uint num3 = ReadUInt32();
			string name = ReadString();
			ReadBlobIndex();
			if (num3 == 0)
			{
				ReaderParameters parameters = new ReaderParameters
				{
					ReadingMode = module.ReadingMode,
					SymbolReaderProvider = module.SymbolReaderProvider,
					AssemblyResolver = module.AssemblyResolver
				};
				collection.Add(ModuleDefinition.ReadModule(GetModuleFileName(name), parameters));
			}
		}
		return collection;
	}

	private string GetModuleFileName(string name)
	{
		if (module.FullyQualifiedName == null)
		{
			throw new NotSupportedException();
		}
		return Path.Combine(Path.GetDirectoryName(module.FullyQualifiedName), name);
	}

	private void InitializeModuleReferences()
	{
		if (metadata.ModuleReferences == null)
		{
			int num = MoveTo(Table.ModuleRef);
			ModuleReference[] array = (metadata.ModuleReferences = new ModuleReference[num]);
			for (uint num2 = 0u; num2 < num; num2++)
			{
				ModuleReference moduleReference = new ModuleReference(ReadString());
				moduleReference.token = new MetadataToken(TokenType.ModuleRef, num2 + 1);
				array[num2] = moduleReference;
			}
		}
	}

	public Collection<ModuleReference> ReadModuleReferences()
	{
		InitializeModuleReferences();
		return new Collection<ModuleReference>(metadata.ModuleReferences);
	}

	public bool HasFileResource()
	{
		int num = MoveTo(Table.File);
		if (num == 0)
		{
			return false;
		}
		for (uint num2 = 1u; num2 <= num; num2++)
		{
			if (ReadFileRecord(num2).Col1 == Mono.Cecil.FileAttributes.ContainsNoMetaData)
			{
				return true;
			}
		}
		return false;
	}

	public Collection<Resource> ReadResources()
	{
		int num = MoveTo(Table.ManifestResource);
		Collection<Resource> collection = new Collection<Resource>(num);
		for (int i = 1; i <= num; i++)
		{
			uint offset = ReadUInt32();
			ManifestResourceAttributes manifestResourceAttributes = (ManifestResourceAttributes)ReadUInt32();
			string name = ReadString();
			MetadataToken scope = ReadMetadataToken(CodedIndex.Implementation);
			Resource item;
			if (scope.RID == 0)
			{
				item = new EmbeddedResource(name, manifestResourceAttributes, offset, this);
			}
			else if (scope.TokenType == TokenType.AssemblyRef)
			{
				item = new AssemblyLinkedResource(name, manifestResourceAttributes)
				{
					Assembly = (AssemblyNameReference)GetTypeReferenceScope(scope)
				};
			}
			else
			{
				if (scope.TokenType != TokenType.File)
				{
					throw new NotSupportedException();
				}
				Row<Mono.Cecil.FileAttributes, string, uint> row = ReadFileRecord(scope.RID);
				item = new LinkedResource(name, manifestResourceAttributes)
				{
					File = row.Col2,
					hash = ReadBlob(row.Col3)
				};
			}
			collection.Add(item);
		}
		return collection;
	}

	private Row<Mono.Cecil.FileAttributes, string, uint> ReadFileRecord(uint rid)
	{
		int num = position;
		if (!MoveTo(Table.File, rid))
		{
			throw new ArgumentException();
		}
		Row<Mono.Cecil.FileAttributes, string, uint> result = new Row<Mono.Cecil.FileAttributes, string, uint>((Mono.Cecil.FileAttributes)ReadUInt32(), ReadString(), ReadBlobIndex());
		position = num;
		return result;
	}

	public MemoryStream GetManagedResourceStream(uint offset)
	{
		uint virtualAddress = image.Resources.VirtualAddress;
		Section sectionAtVirtualAddress = image.GetSectionAtVirtualAddress(virtualAddress);
		uint num = virtualAddress - sectionAtVirtualAddress.VirtualAddress + offset;
		byte[] data = sectionAtVirtualAddress.Data;
		int count = data[num] | (data[num + 1] << 8) | (data[num + 2] << 16) | (data[num + 3] << 24);
		return new MemoryStream(data, (int)(num + 4), count);
	}

	private void PopulateVersionAndFlags(AssemblyNameReference name)
	{
		name.Version = new Version(ReadUInt16(), ReadUInt16(), ReadUInt16(), ReadUInt16());
		name.Attributes = (AssemblyAttributes)ReadUInt32();
	}

	private void PopulateNameAndCulture(AssemblyNameReference name)
	{
		name.Name = ReadString();
		name.Culture = ReadString();
	}

	public TypeDefinitionCollection ReadTypes()
	{
		InitializeTypeDefinitions();
		TypeDefinition[] types = metadata.Types;
		int capacity = types.Length - metadata.NestedTypes.Count;
		TypeDefinitionCollection typeDefinitionCollection = new TypeDefinitionCollection(module, capacity);
		foreach (TypeDefinition typeDefinition in types)
		{
			if (!IsNested(typeDefinition.Attributes))
			{
				typeDefinitionCollection.Add(typeDefinition);
			}
		}
		if (image.HasTable(Table.MethodPtr) || image.HasTable(Table.FieldPtr))
		{
			CompleteTypes();
		}
		return typeDefinitionCollection;
	}

	private void CompleteTypes()
	{
		TypeDefinition[] types = metadata.Types;
		foreach (TypeDefinition obj in types)
		{
			InitializeCollection(obj.Fields);
			InitializeCollection(obj.Methods);
		}
	}

	private void InitializeTypeDefinitions()
	{
		if (metadata.Types != null)
		{
			return;
		}
		InitializeNestedTypes();
		InitializeFields();
		InitializeMethods();
		int num = MoveTo(Table.TypeDef);
		TypeDefinition[] array = (metadata.Types = new TypeDefinition[num]);
		for (uint num2 = 0u; num2 < num; num2++)
		{
			if (array[num2] == null)
			{
				array[num2] = ReadType(num2 + 1);
			}
		}
	}

	private static bool IsNested(TypeAttributes attributes)
	{
		switch (attributes & TypeAttributes.VisibilityMask)
		{
		case TypeAttributes.NestedPublic:
		case TypeAttributes.NestedPrivate:
		case TypeAttributes.NestedFamily:
		case TypeAttributes.NestedAssembly:
		case TypeAttributes.NestedFamANDAssem:
		case TypeAttributes.VisibilityMask:
			return true;
		default:
			return false;
		}
	}

	public bool HasNestedTypes(TypeDefinition type)
	{
		InitializeNestedTypes();
		if (!metadata.TryGetNestedTypeMapping(type, out var mapping))
		{
			return false;
		}
		return mapping.Length != 0;
	}

	public Collection<TypeDefinition> ReadNestedTypes(TypeDefinition type)
	{
		InitializeNestedTypes();
		if (!metadata.TryGetNestedTypeMapping(type, out var mapping))
		{
			return new MemberDefinitionCollection<TypeDefinition>(type);
		}
		MemberDefinitionCollection<TypeDefinition> memberDefinitionCollection = new MemberDefinitionCollection<TypeDefinition>(type, mapping.Length);
		for (int i = 0; i < mapping.Length; i++)
		{
			TypeDefinition typeDefinition = GetTypeDefinition(mapping[i]);
			if (typeDefinition != null)
			{
				memberDefinitionCollection.Add(typeDefinition);
			}
		}
		metadata.RemoveNestedTypeMapping(type);
		return memberDefinitionCollection;
	}

	private void InitializeNestedTypes()
	{
		if (metadata.NestedTypes != null)
		{
			return;
		}
		int num = MoveTo(Table.NestedClass);
		metadata.NestedTypes = new Dictionary<uint, uint[]>(num);
		metadata.ReverseNestedTypes = new Dictionary<uint, uint>(num);
		if (num != 0)
		{
			for (int i = 1; i <= num; i++)
			{
				uint nested = ReadTableIndex(Table.TypeDef);
				uint declaring = ReadTableIndex(Table.TypeDef);
				AddNestedMapping(declaring, nested);
			}
		}
	}

	private void AddNestedMapping(uint declaring, uint nested)
	{
		metadata.SetNestedTypeMapping(declaring, AddMapping(metadata.NestedTypes, declaring, nested));
		metadata.SetReverseNestedTypeMapping(nested, declaring);
	}

	private static TValue[] AddMapping<TKey, TValue>(Dictionary<TKey, TValue[]> cache, TKey key, TValue value)
	{
		if (!cache.TryGetValue(key, out var value2))
		{
			return new TValue[1] { value };
		}
		TValue[] array = new TValue[value2.Length + 1];
		Array.Copy(value2, array, value2.Length);
		array[value2.Length] = value;
		return array;
	}

	private TypeDefinition ReadType(uint rid)
	{
		if (!MoveTo(Table.TypeDef, rid))
		{
			return null;
		}
		TypeAttributes attributes = (TypeAttributes)ReadUInt32();
		string name = ReadString();
		TypeDefinition typeDefinition = new TypeDefinition(ReadString(), name, attributes);
		typeDefinition.token = new MetadataToken(TokenType.TypeDef, rid);
		typeDefinition.scope = module;
		typeDefinition.module = module;
		metadata.AddTypeDefinition(typeDefinition);
		context = typeDefinition;
		typeDefinition.BaseType = GetTypeDefOrRef(ReadMetadataToken(CodedIndex.TypeDefOrRef));
		typeDefinition.fields_range = ReadFieldsRange(rid);
		typeDefinition.methods_range = ReadMethodsRange(rid);
		if (IsNested(attributes))
		{
			typeDefinition.DeclaringType = GetNestedTypeDeclaringType(typeDefinition);
		}
		return typeDefinition;
	}

	private TypeDefinition GetNestedTypeDeclaringType(TypeDefinition type)
	{
		if (!metadata.TryGetReverseNestedTypeMapping(type, out var declaring))
		{
			return null;
		}
		metadata.RemoveReverseNestedTypeMapping(type);
		return GetTypeDefinition(declaring);
	}

	private Mono.Cecil.Range ReadFieldsRange(uint type_index)
	{
		return ReadListRange(type_index, Table.TypeDef, Table.Field);
	}

	private Mono.Cecil.Range ReadMethodsRange(uint type_index)
	{
		return ReadListRange(type_index, Table.TypeDef, Table.Method);
	}

	private Mono.Cecil.Range ReadListRange(uint current_index, Table current, Table target)
	{
		Mono.Cecil.Range result = default(Mono.Cecil.Range);
		result.Start = ReadTableIndex(target);
		TableInformation tableInformation = image.TableHeap[current];
		uint num;
		if (current_index == tableInformation.Length)
		{
			num = image.TableHeap[target].Length + 1;
		}
		else
		{
			uint num2 = Position;
			Position += (uint)(int)(tableInformation.RowSize - image.GetTableIndexSize(target));
			num = ReadTableIndex(target);
			Position = num2;
		}
		result.Length = num - result.Start;
		return result;
	}

	public Row<short, int> ReadTypeLayout(TypeDefinition type)
	{
		InitializeTypeLayouts();
		uint rID = type.token.RID;
		if (!metadata.ClassLayouts.TryGetValue(rID, out var value))
		{
			return new Row<short, int>(-1, -1);
		}
		type.PackingSize = (short)value.Col1;
		type.ClassSize = (int)value.Col2;
		metadata.ClassLayouts.Remove(rID);
		return new Row<short, int>((short)value.Col1, (int)value.Col2);
	}

	private void InitializeTypeLayouts()
	{
		if (metadata.ClassLayouts == null)
		{
			int num = MoveTo(Table.ClassLayout);
			Dictionary<uint, Row<ushort, uint>> dictionary = (metadata.ClassLayouts = new Dictionary<uint, Row<ushort, uint>>(num));
			for (uint num2 = 0u; num2 < num; num2++)
			{
				ushort col = ReadUInt16();
				uint col2 = ReadUInt32();
				uint key = ReadTableIndex(Table.TypeDef);
				dictionary.Add(key, new Row<ushort, uint>(col, col2));
			}
		}
	}

	public TypeReference GetTypeDefOrRef(MetadataToken token)
	{
		return (TypeReference)LookupToken(token);
	}

	public TypeDefinition GetTypeDefinition(uint rid)
	{
		InitializeTypeDefinitions();
		TypeDefinition typeDefinition = metadata.GetTypeDefinition(rid);
		if (typeDefinition != null)
		{
			return typeDefinition;
		}
		return ReadTypeDefinition(rid);
	}

	private TypeDefinition ReadTypeDefinition(uint rid)
	{
		if (!MoveTo(Table.TypeDef, rid))
		{
			return null;
		}
		return ReadType(rid);
	}

	private void InitializeTypeReferences()
	{
		if (metadata.TypeReferences == null)
		{
			metadata.TypeReferences = new TypeReference[image.GetTableLength(Table.TypeRef)];
		}
	}

	public TypeReference GetTypeReference(string scope, string full_name)
	{
		InitializeTypeReferences();
		int num = metadata.TypeReferences.Length;
		for (uint num2 = 1u; num2 <= num; num2++)
		{
			TypeReference typeReference = GetTypeReference(num2);
			if (!(typeReference.FullName != full_name))
			{
				if (string.IsNullOrEmpty(scope))
				{
					return typeReference;
				}
				if (typeReference.Scope.Name == scope)
				{
					return typeReference;
				}
			}
		}
		return null;
	}

	private TypeReference GetTypeReference(uint rid)
	{
		InitializeTypeReferences();
		TypeReference typeReference = metadata.GetTypeReference(rid);
		if (typeReference != null)
		{
			return typeReference;
		}
		return ReadTypeReference(rid);
	}

	private TypeReference ReadTypeReference(uint rid)
	{
		if (!MoveTo(Table.TypeRef, rid))
		{
			return null;
		}
		TypeReference typeReference = null;
		MetadataToken metadataToken = ReadMetadataToken(CodedIndex.ResolutionScope);
		string name = ReadString();
		TypeReference typeReference2 = new TypeReference(ReadString(), name, module, null);
		typeReference2.token = new MetadataToken(TokenType.TypeRef, rid);
		metadata.AddTypeReference(typeReference2);
		IMetadataScope scope;
		if (metadataToken.TokenType == TokenType.TypeRef)
		{
			typeReference = GetTypeDefOrRef(metadataToken);
			IMetadataScope metadataScope2;
			if (typeReference == null)
			{
				IMetadataScope metadataScope = module;
				metadataScope2 = metadataScope;
			}
			else
			{
				metadataScope2 = typeReference.Scope;
			}
			scope = metadataScope2;
		}
		else
		{
			scope = GetTypeReferenceScope(metadataToken);
		}
		typeReference2.scope = scope;
		typeReference2.DeclaringType = typeReference;
		MetadataSystem.TryProcessPrimitiveTypeReference(typeReference2);
		return typeReference2;
	}

	private IMetadataScope GetTypeReferenceScope(MetadataToken scope)
	{
		if (scope.TokenType == TokenType.Module)
		{
			return module;
		}
		IMetadataScope[] array;
		switch (scope.TokenType)
		{
		case TokenType.AssemblyRef:
			InitializeAssemblyReferences();
			array = metadata.AssemblyReferences;
			break;
		case TokenType.ModuleRef:
			InitializeModuleReferences();
			array = metadata.ModuleReferences;
			break;
		default:
			throw new NotSupportedException();
		}
		uint num = scope.RID - 1;
		if (num < 0 || num >= array.Length)
		{
			return null;
		}
		return array[num];
	}

	public IEnumerable<TypeReference> GetTypeReferences()
	{
		InitializeTypeReferences();
		int tableLength = image.GetTableLength(Table.TypeRef);
		TypeReference[] array = new TypeReference[tableLength];
		for (uint num = 1u; num <= tableLength; num++)
		{
			array[num - 1] = GetTypeReference(num);
		}
		return array;
	}

	private TypeReference GetTypeSpecification(uint rid)
	{
		if (!MoveTo(Table.TypeSpec, rid))
		{
			return null;
		}
		TypeReference typeReference = ReadSignature(ReadBlobIndex()).ReadTypeSignature();
		if (typeReference.token.RID == 0)
		{
			typeReference.token = new MetadataToken(TokenType.TypeSpec, rid);
		}
		return typeReference;
	}

	private SignatureReader ReadSignature(uint signature)
	{
		return new SignatureReader(signature, this);
	}

	public bool HasInterfaces(TypeDefinition type)
	{
		InitializeInterfaces();
		MetadataToken[] mapping;
		return metadata.TryGetInterfaceMapping(type, out mapping);
	}

	public Collection<TypeReference> ReadInterfaces(TypeDefinition type)
	{
		InitializeInterfaces();
		if (!metadata.TryGetInterfaceMapping(type, out var mapping))
		{
			return new Collection<TypeReference>();
		}
		Collection<TypeReference> collection = new Collection<TypeReference>(mapping.Length);
		context = type;
		for (int i = 0; i < mapping.Length; i++)
		{
			collection.Add(GetTypeDefOrRef(mapping[i]));
		}
		metadata.RemoveInterfaceMapping(type);
		return collection;
	}

	private void InitializeInterfaces()
	{
		if (metadata.Interfaces == null)
		{
			int num = MoveTo(Table.InterfaceImpl);
			metadata.Interfaces = new Dictionary<uint, MetadataToken[]>(num);
			for (int i = 0; i < num; i++)
			{
				uint type = ReadTableIndex(Table.TypeDef);
				MetadataToken @interface = ReadMetadataToken(CodedIndex.TypeDefOrRef);
				AddInterfaceMapping(type, @interface);
			}
		}
	}

	private void AddInterfaceMapping(uint type, MetadataToken @interface)
	{
		metadata.SetInterfaceMapping(type, AddMapping(metadata.Interfaces, type, @interface));
	}

	public Collection<FieldDefinition> ReadFields(TypeDefinition type)
	{
		Mono.Cecil.Range fields_range = type.fields_range;
		if (fields_range.Length == 0)
		{
			return new MemberDefinitionCollection<FieldDefinition>(type);
		}
		MemberDefinitionCollection<FieldDefinition> memberDefinitionCollection = new MemberDefinitionCollection<FieldDefinition>(type, (int)fields_range.Length);
		context = type;
		if (!MoveTo(Table.FieldPtr, fields_range.Start))
		{
			if (!MoveTo(Table.Field, fields_range.Start))
			{
				return memberDefinitionCollection;
			}
			for (uint num = 0u; num < fields_range.Length; num++)
			{
				ReadField(fields_range.Start + num, memberDefinitionCollection);
			}
		}
		else
		{
			ReadPointers(Table.FieldPtr, Table.Field, fields_range, memberDefinitionCollection, ReadField);
		}
		return memberDefinitionCollection;
	}

	private void ReadField(uint field_rid, Collection<FieldDefinition> fields)
	{
		FieldAttributes attributes = (FieldAttributes)ReadUInt16();
		string name = ReadString();
		uint signature = ReadBlobIndex();
		FieldDefinition fieldDefinition = new FieldDefinition(name, attributes, ReadFieldType(signature));
		fieldDefinition.token = new MetadataToken(TokenType.Field, field_rid);
		metadata.AddFieldDefinition(fieldDefinition);
		if (!IsDeleted(fieldDefinition))
		{
			fields.Add(fieldDefinition);
		}
	}

	private void InitializeFields()
	{
		if (metadata.Fields == null)
		{
			metadata.Fields = new FieldDefinition[image.GetTableLength(Table.Field)];
		}
	}

	private TypeReference ReadFieldType(uint signature)
	{
		SignatureReader signatureReader = ReadSignature(signature);
		if (signatureReader.ReadByte() != 6)
		{
			throw new NotSupportedException();
		}
		return signatureReader.ReadTypeSignature();
	}

	public int ReadFieldRVA(FieldDefinition field)
	{
		InitializeFieldRVAs();
		uint rID = field.token.RID;
		if (!metadata.FieldRVAs.TryGetValue(rID, out var value))
		{
			return 0;
		}
		int fieldTypeSize = GetFieldTypeSize(field.FieldType);
		if (fieldTypeSize == 0 || value == 0)
		{
			return 0;
		}
		metadata.FieldRVAs.Remove(rID);
		field.InitialValue = GetFieldInitializeValue(fieldTypeSize, value);
		return (int)value;
	}

	private byte[] GetFieldInitializeValue(int size, uint rva)
	{
		Section sectionAtVirtualAddress = image.GetSectionAtVirtualAddress(rva);
		if (sectionAtVirtualAddress == null)
		{
			return Empty<byte>.Array;
		}
		byte[] array = new byte[size];
		Buffer.BlockCopy(sectionAtVirtualAddress.Data, (int)(rva - sectionAtVirtualAddress.VirtualAddress), array, 0, size);
		return array;
	}

	private static int GetFieldTypeSize(TypeReference type)
	{
		int result = 0;
		switch (type.etype)
		{
		case ElementType.Boolean:
		case ElementType.I1:
		case ElementType.U1:
			result = 1;
			break;
		case ElementType.Char:
		case ElementType.I2:
		case ElementType.U2:
			result = 2;
			break;
		case ElementType.I4:
		case ElementType.U4:
		case ElementType.R4:
			result = 4;
			break;
		case ElementType.I8:
		case ElementType.U8:
		case ElementType.R8:
			result = 8;
			break;
		case ElementType.Ptr:
		case ElementType.FnPtr:
			result = IntPtr.Size;
			break;
		case ElementType.CModReqD:
		case ElementType.CModOpt:
			return GetFieldTypeSize(((IModifierType)type).ElementType);
		default:
		{
			TypeDefinition typeDefinition = type.Resolve();
			if (typeDefinition != null && typeDefinition.HasLayoutInfo)
			{
				result = typeDefinition.ClassSize;
			}
			break;
		}
		}
		return result;
	}

	private void InitializeFieldRVAs()
	{
		if (metadata.FieldRVAs == null)
		{
			int num = MoveTo(Table.FieldRVA);
			Dictionary<uint, uint> dictionary = (metadata.FieldRVAs = new Dictionary<uint, uint>(num));
			for (int i = 0; i < num; i++)
			{
				uint value = ReadUInt32();
				uint key = ReadTableIndex(Table.Field);
				dictionary.Add(key, value);
			}
		}
	}

	public int ReadFieldLayout(FieldDefinition field)
	{
		InitializeFieldLayouts();
		uint rID = field.token.RID;
		if (!metadata.FieldLayouts.TryGetValue(rID, out var value))
		{
			return -1;
		}
		metadata.FieldLayouts.Remove(rID);
		return (int)value;
	}

	private void InitializeFieldLayouts()
	{
		if (metadata.FieldLayouts == null)
		{
			int num = MoveTo(Table.FieldLayout);
			Dictionary<uint, uint> dictionary = (metadata.FieldLayouts = new Dictionary<uint, uint>(num));
			for (int i = 0; i < num; i++)
			{
				uint value = ReadUInt32();
				uint key = ReadTableIndex(Table.Field);
				dictionary.Add(key, value);
			}
		}
	}

	public bool HasEvents(TypeDefinition type)
	{
		InitializeEvents();
		if (!metadata.TryGetEventsRange(type, out var range))
		{
			return false;
		}
		return range.Length != 0;
	}

	public Collection<EventDefinition> ReadEvents(TypeDefinition type)
	{
		InitializeEvents();
		if (!metadata.TryGetEventsRange(type, out var range))
		{
			return new MemberDefinitionCollection<EventDefinition>(type);
		}
		MemberDefinitionCollection<EventDefinition> memberDefinitionCollection = new MemberDefinitionCollection<EventDefinition>(type, (int)range.Length);
		metadata.RemoveEventsRange(type);
		if (range.Length == 0)
		{
			return memberDefinitionCollection;
		}
		context = type;
		if (!MoveTo(Table.EventPtr, range.Start))
		{
			if (!MoveTo(Table.Event, range.Start))
			{
				return memberDefinitionCollection;
			}
			for (uint num = 0u; num < range.Length; num++)
			{
				ReadEvent(range.Start + num, memberDefinitionCollection);
			}
		}
		else
		{
			ReadPointers(Table.EventPtr, Table.Event, range, memberDefinitionCollection, ReadEvent);
		}
		return memberDefinitionCollection;
	}

	private void ReadEvent(uint event_rid, Collection<EventDefinition> events)
	{
		EventAttributes attributes = (EventAttributes)ReadUInt16();
		string name = ReadString();
		TypeReference typeDefOrRef = GetTypeDefOrRef(ReadMetadataToken(CodedIndex.TypeDefOrRef));
		EventDefinition eventDefinition = new EventDefinition(name, attributes, typeDefOrRef);
		eventDefinition.token = new MetadataToken(TokenType.Event, event_rid);
		if (!IsDeleted(eventDefinition))
		{
			events.Add(eventDefinition);
		}
	}

	private void InitializeEvents()
	{
		if (metadata.Events == null)
		{
			int num = MoveTo(Table.EventMap);
			metadata.Events = new Dictionary<uint, Mono.Cecil.Range>(num);
			for (uint num2 = 1u; num2 <= num; num2++)
			{
				uint type_rid = ReadTableIndex(Table.TypeDef);
				Mono.Cecil.Range range = ReadEventsRange(num2);
				metadata.AddEventsRange(type_rid, range);
			}
		}
	}

	private Mono.Cecil.Range ReadEventsRange(uint rid)
	{
		return ReadListRange(rid, Table.EventMap, Table.Event);
	}

	public bool HasProperties(TypeDefinition type)
	{
		InitializeProperties();
		if (!metadata.TryGetPropertiesRange(type, out var range))
		{
			return false;
		}
		return range.Length != 0;
	}

	public Collection<PropertyDefinition> ReadProperties(TypeDefinition type)
	{
		InitializeProperties();
		if (!metadata.TryGetPropertiesRange(type, out var range))
		{
			return new MemberDefinitionCollection<PropertyDefinition>(type);
		}
		metadata.RemovePropertiesRange(type);
		MemberDefinitionCollection<PropertyDefinition> memberDefinitionCollection = new MemberDefinitionCollection<PropertyDefinition>(type, (int)range.Length);
		if (range.Length == 0)
		{
			return memberDefinitionCollection;
		}
		context = type;
		if (!MoveTo(Table.PropertyPtr, range.Start))
		{
			if (!MoveTo(Table.Property, range.Start))
			{
				return memberDefinitionCollection;
			}
			for (uint num = 0u; num < range.Length; num++)
			{
				ReadProperty(range.Start + num, memberDefinitionCollection);
			}
		}
		else
		{
			ReadPointers(Table.PropertyPtr, Table.Property, range, memberDefinitionCollection, ReadProperty);
		}
		return memberDefinitionCollection;
	}

	private void ReadProperty(uint property_rid, Collection<PropertyDefinition> properties)
	{
		PropertyAttributes attributes = (PropertyAttributes)ReadUInt16();
		string name = ReadString();
		uint signature = ReadBlobIndex();
		SignatureReader signatureReader = ReadSignature(signature);
		byte num = signatureReader.ReadByte();
		if ((num & 8) == 0)
		{
			throw new NotSupportedException();
		}
		bool hasThis = (num & 0x20) != 0;
		signatureReader.ReadCompressedUInt32();
		PropertyDefinition propertyDefinition = new PropertyDefinition(name, attributes, signatureReader.ReadTypeSignature());
		propertyDefinition.HasThis = hasThis;
		propertyDefinition.token = new MetadataToken(TokenType.Property, property_rid);
		if (!IsDeleted(propertyDefinition))
		{
			properties.Add(propertyDefinition);
		}
	}

	private void InitializeProperties()
	{
		if (metadata.Properties == null)
		{
			int num = MoveTo(Table.PropertyMap);
			metadata.Properties = new Dictionary<uint, Mono.Cecil.Range>(num);
			for (uint num2 = 1u; num2 <= num; num2++)
			{
				uint type_rid = ReadTableIndex(Table.TypeDef);
				Mono.Cecil.Range range = ReadPropertiesRange(num2);
				metadata.AddPropertiesRange(type_rid, range);
			}
		}
	}

	private Mono.Cecil.Range ReadPropertiesRange(uint rid)
	{
		return ReadListRange(rid, Table.PropertyMap, Table.Property);
	}

	private MethodSemanticsAttributes ReadMethodSemantics(MethodDefinition method)
	{
		InitializeMethodSemantics();
		if (!metadata.Semantics.TryGetValue(method.token.RID, out var value))
		{
			return MethodSemanticsAttributes.None;
		}
		TypeDefinition declaringType = method.DeclaringType;
		switch (value.Col1)
		{
		case MethodSemanticsAttributes.AddOn:
			GetEvent(declaringType, value.Col2).add_method = method;
			break;
		case MethodSemanticsAttributes.Fire:
			GetEvent(declaringType, value.Col2).invoke_method = method;
			break;
		case MethodSemanticsAttributes.RemoveOn:
			GetEvent(declaringType, value.Col2).remove_method = method;
			break;
		case MethodSemanticsAttributes.Getter:
			GetProperty(declaringType, value.Col2).get_method = method;
			break;
		case MethodSemanticsAttributes.Setter:
			GetProperty(declaringType, value.Col2).set_method = method;
			break;
		case MethodSemanticsAttributes.Other:
			switch (value.Col2.TokenType)
			{
			case TokenType.Event:
			{
				EventDefinition @event = GetEvent(declaringType, value.Col2);
				if (@event.other_methods == null)
				{
					@event.other_methods = new Collection<MethodDefinition>();
				}
				@event.other_methods.Add(method);
				break;
			}
			case TokenType.Property:
			{
				PropertyDefinition property = GetProperty(declaringType, value.Col2);
				if (property.other_methods == null)
				{
					property.other_methods = new Collection<MethodDefinition>();
				}
				property.other_methods.Add(method);
				break;
			}
			default:
				throw new NotSupportedException();
			}
			break;
		default:
			throw new NotSupportedException();
		}
		metadata.Semantics.Remove(method.token.RID);
		return value.Col1;
	}

	private static EventDefinition GetEvent(TypeDefinition type, MetadataToken token)
	{
		if (token.TokenType != TokenType.Event)
		{
			throw new ArgumentException();
		}
		return GetMember(type.Events, token);
	}

	private static PropertyDefinition GetProperty(TypeDefinition type, MetadataToken token)
	{
		if (token.TokenType != TokenType.Property)
		{
			throw new ArgumentException();
		}
		return GetMember(type.Properties, token);
	}

	private static TMember GetMember<TMember>(Collection<TMember> members, MetadataToken token) where TMember : IMemberDefinition
	{
		for (int i = 0; i < members.Count; i++)
		{
			TMember result = members[i];
			if (result.MetadataToken == token)
			{
				return result;
			}
		}
		throw new ArgumentException();
	}

	private void InitializeMethodSemantics()
	{
		if (metadata.Semantics == null)
		{
			int num = MoveTo(Table.MethodSemantics);
			Dictionary<uint, Row<MethodSemanticsAttributes, MetadataToken>> dictionary = (metadata.Semantics = new Dictionary<uint, Row<MethodSemanticsAttributes, MetadataToken>>(0));
			for (uint num2 = 0u; num2 < num; num2++)
			{
				MethodSemanticsAttributes col = (MethodSemanticsAttributes)ReadUInt16();
				uint key = ReadTableIndex(Table.Method);
				MetadataToken col2 = ReadMetadataToken(CodedIndex.HasSemantics);
				dictionary[key] = new Row<MethodSemanticsAttributes, MetadataToken>(col, col2);
			}
		}
	}

	public PropertyDefinition ReadMethods(PropertyDefinition property)
	{
		ReadAllSemantics(property.DeclaringType);
		return property;
	}

	public EventDefinition ReadMethods(EventDefinition @event)
	{
		ReadAllSemantics(@event.DeclaringType);
		return @event;
	}

	public MethodSemanticsAttributes ReadAllSemantics(MethodDefinition method)
	{
		ReadAllSemantics(method.DeclaringType);
		return method.SemanticsAttributes;
	}

	private void ReadAllSemantics(TypeDefinition type)
	{
		Collection<MethodDefinition> methods = type.Methods;
		for (int i = 0; i < methods.Count; i++)
		{
			MethodDefinition methodDefinition = methods[i];
			if (!methodDefinition.sem_attrs_ready)
			{
				methodDefinition.sem_attrs = ReadMethodSemantics(methodDefinition);
				methodDefinition.sem_attrs_ready = true;
			}
		}
	}

	private Mono.Cecil.Range ReadParametersRange(uint method_rid)
	{
		return ReadListRange(method_rid, Table.Method, Table.Param);
	}

	public Collection<MethodDefinition> ReadMethods(TypeDefinition type)
	{
		Mono.Cecil.Range methods_range = type.methods_range;
		if (methods_range.Length == 0)
		{
			return new MemberDefinitionCollection<MethodDefinition>(type);
		}
		MemberDefinitionCollection<MethodDefinition> memberDefinitionCollection = new MemberDefinitionCollection<MethodDefinition>(type, (int)methods_range.Length);
		if (!MoveTo(Table.MethodPtr, methods_range.Start))
		{
			if (!MoveTo(Table.Method, methods_range.Start))
			{
				return memberDefinitionCollection;
			}
			for (uint num = 0u; num < methods_range.Length; num++)
			{
				ReadMethod(methods_range.Start + num, memberDefinitionCollection);
			}
		}
		else
		{
			ReadPointers(Table.MethodPtr, Table.Method, methods_range, memberDefinitionCollection, ReadMethod);
		}
		return memberDefinitionCollection;
	}

	private void ReadPointers<TMember>(Table ptr, Table table, Mono.Cecil.Range range, Collection<TMember> members, Action<uint, Collection<TMember>> reader) where TMember : IMemberDefinition
	{
		for (uint num = 0u; num < range.Length; num++)
		{
			MoveTo(ptr, range.Start + num);
			uint num2 = ReadTableIndex(table);
			MoveTo(table, num2);
			reader(num2, members);
		}
	}

	private static bool IsDeleted(IMemberDefinition member)
	{
		if (member.IsSpecialName)
		{
			return member.Name == "_Deleted";
		}
		return false;
	}

	private void InitializeMethods()
	{
		if (metadata.Methods == null)
		{
			metadata.Methods = new MethodDefinition[image.GetTableLength(Table.Method)];
		}
	}

	private void ReadMethod(uint method_rid, Collection<MethodDefinition> methods)
	{
		MethodDefinition methodDefinition = new MethodDefinition();
		methodDefinition.rva = ReadUInt32();
		methodDefinition.ImplAttributes = (MethodImplAttributes)ReadUInt16();
		methodDefinition.Attributes = (MethodAttributes)ReadUInt16();
		methodDefinition.Name = ReadString();
		methodDefinition.token = new MetadataToken(TokenType.Method, method_rid);
		if (!IsDeleted(methodDefinition))
		{
			methods.Add(methodDefinition);
			uint signature = ReadBlobIndex();
			Mono.Cecil.Range param_range = ReadParametersRange(method_rid);
			context = methodDefinition;
			ReadMethodSignature(signature, methodDefinition);
			metadata.AddMethodDefinition(methodDefinition);
			if (param_range.Length != 0)
			{
				int num = position;
				ReadParameters(methodDefinition, param_range);
				position = num;
			}
		}
	}

	private void ReadParameters(MethodDefinition method, Mono.Cecil.Range param_range)
	{
		if (!MoveTo(Table.ParamPtr, param_range.Start))
		{
			if (MoveTo(Table.Param, param_range.Start))
			{
				for (uint num = 0u; num < param_range.Length; num++)
				{
					ReadParameter(param_range.Start + num, method);
				}
			}
		}
		else
		{
			ReadParameterPointers(method, param_range);
		}
	}

	private void ReadParameterPointers(MethodDefinition method, Mono.Cecil.Range range)
	{
		for (uint num = 0u; num < range.Length; num++)
		{
			MoveTo(Table.ParamPtr, range.Start + num);
			uint num2 = ReadTableIndex(Table.Param);
			MoveTo(Table.Param, num2);
			ReadParameter(num2, method);
		}
	}

	private void ReadParameter(uint param_rid, MethodDefinition method)
	{
		ParameterAttributes attributes = (ParameterAttributes)ReadUInt16();
		ushort num = ReadUInt16();
		string name = ReadString();
		ParameterDefinition obj = ((num == 0) ? method.MethodReturnType.Parameter : method.Parameters[num - 1]);
		obj.token = new MetadataToken(TokenType.Param, param_rid);
		obj.Name = name;
		obj.Attributes = attributes;
	}

	private void ReadMethodSignature(uint signature, IMethodSignature method)
	{
		ReadSignature(signature).ReadMethodSignature(method);
	}

	public PInvokeInfo ReadPInvokeInfo(MethodDefinition method)
	{
		InitializePInvokes();
		uint rID = method.token.RID;
		if (!metadata.PInvokes.TryGetValue(rID, out var value))
		{
			return null;
		}
		metadata.PInvokes.Remove(rID);
		return new PInvokeInfo(value.Col1, image.StringHeap.Read(value.Col2), module.ModuleReferences[(int)(value.Col3 - 1)]);
	}

	private void InitializePInvokes()
	{
		if (metadata.PInvokes != null)
		{
			return;
		}
		int num = MoveTo(Table.ImplMap);
		Dictionary<uint, Row<PInvokeAttributes, uint, uint>> dictionary = (metadata.PInvokes = new Dictionary<uint, Row<PInvokeAttributes, uint, uint>>(num));
		for (int i = 1; i <= num; i++)
		{
			PInvokeAttributes col = (PInvokeAttributes)ReadUInt16();
			MetadataToken metadataToken = ReadMetadataToken(CodedIndex.MemberForwarded);
			uint col2 = ReadStringIndex();
			uint col3 = ReadTableIndex(Table.File);
			if (metadataToken.TokenType == TokenType.Method)
			{
				dictionary.Add(metadataToken.RID, new Row<PInvokeAttributes, uint, uint>(col, col2, col3));
			}
		}
	}

	public bool HasGenericParameters(IGenericParameterProvider provider)
	{
		InitializeGenericParameters();
		if (!metadata.TryGetGenericParameterRanges(provider, out var ranges))
		{
			return false;
		}
		return RangesSize(ranges) > 0;
	}

	public Collection<GenericParameter> ReadGenericParameters(IGenericParameterProvider provider)
	{
		InitializeGenericParameters();
		if (!metadata.TryGetGenericParameterRanges(provider, out var ranges))
		{
			return new GenericParameterCollection(provider);
		}
		metadata.RemoveGenericParameterRange(provider);
		GenericParameterCollection genericParameterCollection = new GenericParameterCollection(provider, RangesSize(ranges));
		for (int i = 0; i < ranges.Length; i++)
		{
			ReadGenericParametersRange(ranges[i], provider, genericParameterCollection);
		}
		return genericParameterCollection;
	}

	private void ReadGenericParametersRange(Mono.Cecil.Range range, IGenericParameterProvider provider, GenericParameterCollection generic_parameters)
	{
		if (MoveTo(Table.GenericParam, range.Start))
		{
			for (uint num = 0u; num < range.Length; num++)
			{
				ReadUInt16();
				GenericParameterAttributes attributes = (GenericParameterAttributes)ReadUInt16();
				ReadMetadataToken(CodedIndex.TypeOrMethodDef);
				GenericParameter genericParameter = new GenericParameter(ReadString(), provider);
				genericParameter.token = new MetadataToken(TokenType.GenericParam, range.Start + num);
				genericParameter.Attributes = attributes;
				generic_parameters.Add(genericParameter);
			}
		}
	}

	private void InitializeGenericParameters()
	{
		if (metadata.GenericParameters == null)
		{
			metadata.GenericParameters = InitializeRanges(Table.GenericParam, delegate
			{
				Advance(4);
				MetadataToken result = ReadMetadataToken(CodedIndex.TypeOrMethodDef);
				ReadStringIndex();
				return result;
			});
		}
	}

	private Dictionary<MetadataToken, Mono.Cecil.Range[]> InitializeRanges(Table table, Func<MetadataToken> get_next)
	{
		int num = MoveTo(table);
		Dictionary<MetadataToken, Mono.Cecil.Range[]> dictionary = new Dictionary<MetadataToken, Mono.Cecil.Range[]>(num);
		if (num == 0)
		{
			return dictionary;
		}
		MetadataToken metadataToken = MetadataToken.Zero;
		Mono.Cecil.Range range = new Mono.Cecil.Range(1u, 0u);
		for (uint num2 = 1u; num2 <= num; num2++)
		{
			MetadataToken metadataToken2 = get_next();
			if (num2 == 1)
			{
				metadataToken = metadataToken2;
				range.Length++;
			}
			else if (metadataToken2 != metadataToken)
			{
				AddRange(dictionary, metadataToken, range);
				range = new Mono.Cecil.Range(num2, 1u);
				metadataToken = metadataToken2;
			}
			else
			{
				range.Length++;
			}
		}
		AddRange(dictionary, metadataToken, range);
		return dictionary;
	}

	private static void AddRange(Dictionary<MetadataToken, Mono.Cecil.Range[]> ranges, MetadataToken owner, Mono.Cecil.Range range)
	{
		if (owner.RID != 0)
		{
			if (!ranges.TryGetValue(owner, out var value))
			{
				ranges.Add(owner, new Mono.Cecil.Range[1] { range });
			}
			else
			{
				value = value.Resize(value.Length + 1);
				value[^1] = range;
				ranges[owner] = value;
			}
		}
	}

	public bool HasGenericConstraints(GenericParameter generic_parameter)
	{
		InitializeGenericConstraints();
		if (!metadata.TryGetGenericConstraintMapping(generic_parameter, out var mapping))
		{
			return false;
		}
		return mapping.Length != 0;
	}

	public Collection<TypeReference> ReadGenericConstraints(GenericParameter generic_parameter)
	{
		InitializeGenericConstraints();
		if (!metadata.TryGetGenericConstraintMapping(generic_parameter, out var mapping))
		{
			return new Collection<TypeReference>();
		}
		Collection<TypeReference> collection = new Collection<TypeReference>(mapping.Length);
		context = (IGenericContext)generic_parameter.Owner;
		for (int i = 0; i < mapping.Length; i++)
		{
			collection.Add(GetTypeDefOrRef(mapping[i]));
		}
		metadata.RemoveGenericConstraintMapping(generic_parameter);
		return collection;
	}

	private void InitializeGenericConstraints()
	{
		if (metadata.GenericConstraints == null)
		{
			int num = MoveTo(Table.GenericParamConstraint);
			metadata.GenericConstraints = new Dictionary<uint, MetadataToken[]>(num);
			for (int i = 1; i <= num; i++)
			{
				AddGenericConstraintMapping(ReadTableIndex(Table.GenericParam), ReadMetadataToken(CodedIndex.TypeDefOrRef));
			}
		}
	}

	private void AddGenericConstraintMapping(uint generic_parameter, MetadataToken constraint)
	{
		metadata.SetGenericConstraintMapping(generic_parameter, AddMapping(metadata.GenericConstraints, generic_parameter, constraint));
	}

	public bool HasOverrides(MethodDefinition method)
	{
		InitializeOverrides();
		if (!metadata.TryGetOverrideMapping(method, out var mapping))
		{
			return false;
		}
		return mapping.Length != 0;
	}

	public Collection<MethodReference> ReadOverrides(MethodDefinition method)
	{
		InitializeOverrides();
		if (!metadata.TryGetOverrideMapping(method, out var mapping))
		{
			return new Collection<MethodReference>();
		}
		Collection<MethodReference> collection = new Collection<MethodReference>(mapping.Length);
		context = method;
		for (int i = 0; i < mapping.Length; i++)
		{
			collection.Add((MethodReference)LookupToken(mapping[i]));
		}
		metadata.RemoveOverrideMapping(method);
		return collection;
	}

	private void InitializeOverrides()
	{
		if (metadata.Overrides != null)
		{
			return;
		}
		int num = MoveTo(Table.MethodImpl);
		metadata.Overrides = new Dictionary<uint, MetadataToken[]>(num);
		for (int i = 1; i <= num; i++)
		{
			ReadTableIndex(Table.TypeDef);
			MetadataToken metadataToken = ReadMetadataToken(CodedIndex.MethodDefOrRef);
			if (metadataToken.TokenType != TokenType.Method)
			{
				throw new NotSupportedException();
			}
			MetadataToken @override = ReadMetadataToken(CodedIndex.MethodDefOrRef);
			AddOverrideMapping(metadataToken.RID, @override);
		}
	}

	private void AddOverrideMapping(uint method_rid, MetadataToken @override)
	{
		metadata.SetOverrideMapping(method_rid, AddMapping(metadata.Overrides, method_rid, @override));
	}

	public MethodBody ReadMethodBody(MethodDefinition method)
	{
		return code.ReadMethodBody(method);
	}

	public CallSite ReadCallSite(MetadataToken token)
	{
		if (!MoveTo(Table.StandAloneSig, token.RID))
		{
			return null;
		}
		uint signature = ReadBlobIndex();
		CallSite callSite = new CallSite();
		ReadMethodSignature(signature, callSite);
		callSite.MetadataToken = token;
		return callSite;
	}

	public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token)
	{
		if (!MoveTo(Table.StandAloneSig, local_var_token.RID))
		{
			return null;
		}
		SignatureReader signatureReader = ReadSignature(ReadBlobIndex());
		if (signatureReader.ReadByte() != 7)
		{
			throw new NotSupportedException();
		}
		uint num = signatureReader.ReadCompressedUInt32();
		if (num == 0)
		{
			return null;
		}
		VariableDefinitionCollection variableDefinitionCollection = new VariableDefinitionCollection((int)num);
		for (int i = 0; i < num; i++)
		{
			variableDefinitionCollection.Add(new VariableDefinition(signatureReader.ReadTypeSignature()));
		}
		return variableDefinitionCollection;
	}

	public IMetadataTokenProvider LookupToken(MetadataToken token)
	{
		uint rID = token.RID;
		if (rID == 0)
		{
			return null;
		}
		int num = position;
		IGenericContext genericContext = context;
		IMetadataTokenProvider result;
		switch (token.TokenType)
		{
		case TokenType.TypeDef:
			result = GetTypeDefinition(rID);
			break;
		case TokenType.TypeRef:
			result = GetTypeReference(rID);
			break;
		case TokenType.TypeSpec:
			result = GetTypeSpecification(rID);
			break;
		case TokenType.Field:
			result = GetFieldDefinition(rID);
			break;
		case TokenType.Method:
			result = GetMethodDefinition(rID);
			break;
		case TokenType.MemberRef:
			result = GetMemberReference(rID);
			break;
		case TokenType.MethodSpec:
			result = GetMethodSpecification(rID);
			break;
		default:
			return null;
		}
		position = num;
		context = genericContext;
		return result;
	}

	public FieldDefinition GetFieldDefinition(uint rid)
	{
		InitializeTypeDefinitions();
		FieldDefinition fieldDefinition = metadata.GetFieldDefinition(rid);
		if (fieldDefinition != null)
		{
			return fieldDefinition;
		}
		return LookupField(rid);
	}

	private FieldDefinition LookupField(uint rid)
	{
		TypeDefinition fieldDeclaringType = metadata.GetFieldDeclaringType(rid);
		if (fieldDeclaringType == null)
		{
			return null;
		}
		InitializeCollection(fieldDeclaringType.Fields);
		return metadata.GetFieldDefinition(rid);
	}

	public MethodDefinition GetMethodDefinition(uint rid)
	{
		InitializeTypeDefinitions();
		MethodDefinition methodDefinition = metadata.GetMethodDefinition(rid);
		if (methodDefinition != null)
		{
			return methodDefinition;
		}
		return LookupMethod(rid);
	}

	private MethodDefinition LookupMethod(uint rid)
	{
		TypeDefinition methodDeclaringType = metadata.GetMethodDeclaringType(rid);
		if (methodDeclaringType == null)
		{
			return null;
		}
		InitializeCollection(methodDeclaringType.Methods);
		return metadata.GetMethodDefinition(rid);
	}

	private MethodSpecification GetMethodSpecification(uint rid)
	{
		if (!MoveTo(Table.MethodSpec, rid))
		{
			return null;
		}
		MethodReference method = (MethodReference)LookupToken(ReadMetadataToken(CodedIndex.MethodDefOrRef));
		uint signature = ReadBlobIndex();
		MethodSpecification methodSpecification = ReadMethodSpecSignature(signature, method);
		methodSpecification.token = new MetadataToken(TokenType.MethodSpec, rid);
		return methodSpecification;
	}

	private MethodSpecification ReadMethodSpecSignature(uint signature, MethodReference method)
	{
		SignatureReader signatureReader = ReadSignature(signature);
		if (signatureReader.ReadByte() != 10)
		{
			throw new NotSupportedException();
		}
		GenericInstanceMethod genericInstanceMethod = new GenericInstanceMethod(method);
		signatureReader.ReadGenericInstanceSignature(method, genericInstanceMethod);
		return genericInstanceMethod;
	}

	private MemberReference GetMemberReference(uint rid)
	{
		InitializeMemberReferences();
		MemberReference memberReference = metadata.GetMemberReference(rid);
		if (memberReference != null)
		{
			return memberReference;
		}
		memberReference = ReadMemberReference(rid);
		if (memberReference != null && !memberReference.ContainsGenericParameter)
		{
			metadata.AddMemberReference(memberReference);
		}
		return memberReference;
	}

	private MemberReference ReadMemberReference(uint rid)
	{
		if (!MoveTo(Table.MemberRef, rid))
		{
			return null;
		}
		MetadataToken metadataToken = ReadMetadataToken(CodedIndex.MemberRefParent);
		string name = ReadString();
		uint signature = ReadBlobIndex();
		MemberReference memberReference;
		switch (metadataToken.TokenType)
		{
		case TokenType.TypeRef:
		case TokenType.TypeDef:
		case TokenType.TypeSpec:
			memberReference = ReadTypeMemberReference(metadataToken, name, signature);
			break;
		case TokenType.Method:
			memberReference = ReadMethodMemberReference(metadataToken, name, signature);
			break;
		default:
			throw new NotSupportedException();
		}
		memberReference.token = new MetadataToken(TokenType.MemberRef, rid);
		return memberReference;
	}

	private MemberReference ReadTypeMemberReference(MetadataToken type, string name, uint signature)
	{
		TypeReference typeDefOrRef = GetTypeDefOrRef(type);
		if (!typeDefOrRef.IsArray)
		{
			context = typeDefOrRef;
		}
		MemberReference memberReference = ReadMemberReferenceSignature(signature, typeDefOrRef);
		memberReference.Name = name;
		return memberReference;
	}

	private MemberReference ReadMemberReferenceSignature(uint signature, TypeReference declaring_type)
	{
		SignatureReader signatureReader = ReadSignature(signature);
		if (signatureReader.buffer[signatureReader.position] == 6)
		{
			signatureReader.position++;
			return new FieldReference
			{
				DeclaringType = declaring_type,
				FieldType = signatureReader.ReadTypeSignature()
			};
		}
		MethodReference methodReference = new MethodReference();
		methodReference.DeclaringType = declaring_type;
		signatureReader.ReadMethodSignature(methodReference);
		return methodReference;
	}

	private MemberReference ReadMethodMemberReference(MetadataToken token, string name, uint signature)
	{
		MemberReference memberReference = ReadMemberReferenceSignature(signature, ((MethodDefinition)(context = GetMethodDefinition(token.RID))).DeclaringType);
		memberReference.Name = name;
		return memberReference;
	}

	private void InitializeMemberReferences()
	{
		if (metadata.MemberReferences == null)
		{
			metadata.MemberReferences = new MemberReference[image.GetTableLength(Table.MemberRef)];
		}
	}

	public IEnumerable<MemberReference> GetMemberReferences()
	{
		InitializeMemberReferences();
		int tableLength = image.GetTableLength(Table.MemberRef);
		TypeSystem typeSystem = module.TypeSystem;
		MethodReference methodReference = new MethodReference(string.Empty, typeSystem.Void);
		methodReference.DeclaringType = new TypeReference(string.Empty, string.Empty, module, typeSystem.Corlib);
		MemberReference[] array = new MemberReference[tableLength];
		for (uint num = 1u; num <= tableLength; num++)
		{
			context = methodReference;
			array[num - 1] = GetMemberReference(num);
		}
		return array;
	}

	private void InitializeConstants()
	{
		if (metadata.Constants == null)
		{
			int num = MoveTo(Table.Constant);
			Dictionary<MetadataToken, Row<ElementType, uint>> dictionary = (metadata.Constants = new Dictionary<MetadataToken, Row<ElementType, uint>>(num));
			for (uint num2 = 1u; num2 <= num; num2++)
			{
				ElementType col = (ElementType)ReadUInt16();
				MetadataToken key = ReadMetadataToken(CodedIndex.HasConstant);
				uint col2 = ReadBlobIndex();
				dictionary.Add(key, new Row<ElementType, uint>(col, col2));
			}
		}
	}

	public object ReadConstant(IConstantProvider owner)
	{
		InitializeConstants();
		if (!metadata.Constants.TryGetValue(owner.MetadataToken, out var value))
		{
			return Mixin.NoValue;
		}
		metadata.Constants.Remove(owner.MetadataToken);
		switch (value.Col1)
		{
		case ElementType.Class:
		case ElementType.Object:
			return null;
		case ElementType.String:
			return ReadConstantString(ReadBlob(value.Col2));
		default:
			return ReadConstantPrimitive(value.Col1, value.Col2);
		}
	}

	private static string ReadConstantString(byte[] blob)
	{
		int num = blob.Length;
		if ((num & 1) == 1)
		{
			num--;
		}
		return Encoding.Unicode.GetString(blob, 0, num);
	}

	private object ReadConstantPrimitive(ElementType type, uint signature)
	{
		return ReadSignature(signature).ReadConstantSignature(type);
	}

	private void InitializeCustomAttributes()
	{
		if (metadata.CustomAttributes == null)
		{
			metadata.CustomAttributes = InitializeRanges(Table.CustomAttribute, delegate
			{
				MetadataToken result = ReadMetadataToken(CodedIndex.HasCustomAttribute);
				ReadMetadataToken(CodedIndex.CustomAttributeType);
				ReadBlobIndex();
				return result;
			});
		}
	}

	public bool HasCustomAttributes(ICustomAttributeProvider owner)
	{
		InitializeCustomAttributes();
		if (!metadata.TryGetCustomAttributeRanges(owner, out var ranges))
		{
			return false;
		}
		return RangesSize(ranges) > 0;
	}

	public Collection<CustomAttribute> ReadCustomAttributes(ICustomAttributeProvider owner)
	{
		InitializeCustomAttributes();
		if (!metadata.TryGetCustomAttributeRanges(owner, out var ranges))
		{
			return new Collection<CustomAttribute>();
		}
		Collection<CustomAttribute> collection = new Collection<CustomAttribute>(RangesSize(ranges));
		for (int i = 0; i < ranges.Length; i++)
		{
			ReadCustomAttributeRange(ranges[i], collection);
		}
		metadata.RemoveCustomAttributeRange(owner);
		return collection;
	}

	private void ReadCustomAttributeRange(Mono.Cecil.Range range, Collection<CustomAttribute> custom_attributes)
	{
		if (MoveTo(Table.CustomAttribute, range.Start))
		{
			for (int i = 0; i < range.Length; i++)
			{
				ReadMetadataToken(CodedIndex.HasCustomAttribute);
				MethodReference constructor = (MethodReference)LookupToken(ReadMetadataToken(CodedIndex.CustomAttributeType));
				uint signature = ReadBlobIndex();
				custom_attributes.Add(new CustomAttribute(signature, constructor));
			}
		}
	}

	private static int RangesSize(Mono.Cecil.Range[] ranges)
	{
		uint num = 0u;
		for (int i = 0; i < ranges.Length; i++)
		{
			num += ranges[i].Length;
		}
		return (int)num;
	}

	public byte[] ReadCustomAttributeBlob(uint signature)
	{
		return ReadBlob(signature);
	}

	public void ReadCustomAttributeSignature(CustomAttribute attribute)
	{
		SignatureReader signatureReader = ReadSignature(attribute.signature);
		if (!signatureReader.CanReadMore())
		{
			return;
		}
		if (signatureReader.ReadUInt16() != 1)
		{
			throw new InvalidOperationException();
		}
		MethodReference constructor = attribute.Constructor;
		if (constructor.HasParameters)
		{
			signatureReader.ReadCustomAttributeConstructorArguments(attribute, constructor.Parameters);
		}
		if (signatureReader.CanReadMore())
		{
			ushort num = signatureReader.ReadUInt16();
			if (num != 0)
			{
				signatureReader.ReadCustomAttributeNamedArguments(num, ref attribute.fields, ref attribute.properties);
			}
		}
	}

	private void InitializeMarshalInfos()
	{
		if (metadata.FieldMarshals != null)
		{
			return;
		}
		int num = MoveTo(Table.FieldMarshal);
		Dictionary<MetadataToken, uint> dictionary = (metadata.FieldMarshals = new Dictionary<MetadataToken, uint>(num));
		for (int i = 0; i < num; i++)
		{
			MetadataToken key = ReadMetadataToken(CodedIndex.HasFieldMarshal);
			uint value = ReadBlobIndex();
			if (key.RID != 0)
			{
				dictionary.Add(key, value);
			}
		}
	}

	public bool HasMarshalInfo(IMarshalInfoProvider owner)
	{
		InitializeMarshalInfos();
		return metadata.FieldMarshals.ContainsKey(owner.MetadataToken);
	}

	public MarshalInfo ReadMarshalInfo(IMarshalInfoProvider owner)
	{
		InitializeMarshalInfos();
		if (!metadata.FieldMarshals.TryGetValue(owner.MetadataToken, out var value))
		{
			return null;
		}
		SignatureReader signatureReader = ReadSignature(value);
		metadata.FieldMarshals.Remove(owner.MetadataToken);
		return signatureReader.ReadMarshalInfo();
	}

	private void InitializeSecurityDeclarations()
	{
		if (metadata.SecurityDeclarations == null)
		{
			metadata.SecurityDeclarations = InitializeRanges(Table.DeclSecurity, delegate
			{
				ReadUInt16();
				MetadataToken result = ReadMetadataToken(CodedIndex.HasDeclSecurity);
				ReadBlobIndex();
				return result;
			});
		}
	}

	public bool HasSecurityDeclarations(ISecurityDeclarationProvider owner)
	{
		InitializeSecurityDeclarations();
		if (!metadata.TryGetSecurityDeclarationRanges(owner, out var ranges))
		{
			return false;
		}
		return RangesSize(ranges) > 0;
	}

	public Collection<SecurityDeclaration> ReadSecurityDeclarations(ISecurityDeclarationProvider owner)
	{
		InitializeSecurityDeclarations();
		if (!metadata.TryGetSecurityDeclarationRanges(owner, out var ranges))
		{
			return new Collection<SecurityDeclaration>();
		}
		Collection<SecurityDeclaration> collection = new Collection<SecurityDeclaration>(RangesSize(ranges));
		for (int i = 0; i < ranges.Length; i++)
		{
			ReadSecurityDeclarationRange(ranges[i], collection);
		}
		metadata.RemoveSecurityDeclarationRange(owner);
		return collection;
	}

	private void ReadSecurityDeclarationRange(Mono.Cecil.Range range, Collection<SecurityDeclaration> security_declarations)
	{
		if (MoveTo(Table.DeclSecurity, range.Start))
		{
			for (int i = 0; i < range.Length; i++)
			{
				SecurityAction action = (SecurityAction)ReadUInt16();
				ReadMetadataToken(CodedIndex.HasDeclSecurity);
				uint signature = ReadBlobIndex();
				security_declarations.Add(new SecurityDeclaration(action, signature, module));
			}
		}
	}

	public byte[] ReadSecurityDeclarationBlob(uint signature)
	{
		return ReadBlob(signature);
	}

	public void ReadSecurityDeclarationSignature(SecurityDeclaration declaration)
	{
		uint signature = declaration.signature;
		SignatureReader signatureReader = ReadSignature(signature);
		if (signatureReader.buffer[signatureReader.position] != 46)
		{
			ReadXmlSecurityDeclaration(signature, declaration);
			return;
		}
		signatureReader.position++;
		uint num = signatureReader.ReadCompressedUInt32();
		Collection<SecurityAttribute> collection = new Collection<SecurityAttribute>((int)num);
		for (int i = 0; i < num; i++)
		{
			collection.Add(signatureReader.ReadSecurityAttribute());
		}
		declaration.security_attributes = collection;
	}

	private void ReadXmlSecurityDeclaration(uint signature, SecurityDeclaration declaration)
	{
		byte[] array = ReadBlob(signature);
		Collection<SecurityAttribute> collection = new Collection<SecurityAttribute>(1);
		SecurityAttribute securityAttribute = new SecurityAttribute(module.TypeSystem.LookupType("System.Security.Permissions", "PermissionSetAttribute"));
		securityAttribute.properties = new Collection<CustomAttributeNamedArgument>(1);
		securityAttribute.properties.Add(new CustomAttributeNamedArgument("XML", new CustomAttributeArgument(module.TypeSystem.String, Encoding.Unicode.GetString(array, 0, array.Length))));
		collection.Add(securityAttribute);
		declaration.security_attributes = collection;
	}

	public Collection<ExportedType> ReadExportedTypes()
	{
		int num = MoveTo(Table.ExportedType);
		if (num == 0)
		{
			return new Collection<ExportedType>();
		}
		Collection<ExportedType> collection = new Collection<ExportedType>(num);
		for (int i = 1; i <= num; i++)
		{
			TypeAttributes attributes = (TypeAttributes)ReadUInt32();
			uint identifier = ReadUInt32();
			string name = ReadString();
			string @namespace = ReadString();
			MetadataToken token = ReadMetadataToken(CodedIndex.Implementation);
			ExportedType declaringType = null;
			IMetadataScope scope = null;
			switch (token.TokenType)
			{
			case TokenType.AssemblyRef:
			case TokenType.File:
				scope = GetExportedTypeScope(token);
				break;
			case TokenType.ExportedType:
				declaringType = collection[(int)(token.RID - 1)];
				break;
			}
			ExportedType exportedType = new ExportedType(@namespace, name, module, scope)
			{
				Attributes = attributes,
				Identifier = (int)identifier,
				DeclaringType = declaringType
			};
			exportedType.token = new MetadataToken(TokenType.ExportedType, i);
			collection.Add(exportedType);
		}
		return collection;
	}

	private IMetadataScope GetExportedTypeScope(MetadataToken token)
	{
		int num = position;
		IMetadataScope result;
		switch (token.TokenType)
		{
		case TokenType.AssemblyRef:
			InitializeAssemblyReferences();
			result = metadata.AssemblyReferences[token.RID - 1];
			break;
		case TokenType.File:
			InitializeModuleReferences();
			result = GetModuleReferenceFromFile(token);
			break;
		default:
			throw new NotSupportedException();
		}
		position = num;
		return result;
	}

	private ModuleReference GetModuleReferenceFromFile(MetadataToken token)
	{
		if (!MoveTo(Table.File, token.RID))
		{
			return null;
		}
		ReadUInt32();
		string text = ReadString();
		Collection<ModuleReference> moduleReferences = module.ModuleReferences;
		ModuleReference moduleReference;
		for (int i = 0; i < moduleReferences.Count; i++)
		{
			moduleReference = moduleReferences[i];
			if (moduleReference.Name == text)
			{
				return moduleReference;
			}
		}
		moduleReference = new ModuleReference(text);
		moduleReferences.Add(moduleReference);
		return moduleReference;
	}

	private static void InitializeCollection(object o)
	{
	}
}


using System;
using System.Text;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;
using Mono.Collections.Generic;

internal sealed class SignatureReader : ByteBuffer
{
	private readonly MetadataReader reader;

	private readonly uint start;

	private readonly uint sig_length;

	private TypeSystem TypeSystem => reader.module.TypeSystem;

	public SignatureReader(uint blob, MetadataReader reader)
		: base(reader.buffer)
	{
		this.reader = reader;
		MoveToBlob(blob);
		sig_length = ReadCompressedUInt32();
		start = (uint)position;
	}

	private void MoveToBlob(uint blob)
	{
		position = (int)(reader.image.BlobHeap.Offset + blob);
	}

	private MetadataToken ReadTypeTokenSignature()
	{
		return CodedIndex.TypeDefOrRef.GetMetadataToken(ReadCompressedUInt32());
	}

	private GenericParameter GetGenericParameter(GenericParameterType type, uint var)
	{
		IGenericContext context = reader.context;
		if (context == null)
		{
			return GetUnboundGenericParameter(type, (int)var);
		}
		IGenericParameterProvider genericParameterProvider = type switch
		{
			GenericParameterType.Type => context.Type, 
			GenericParameterType.Method => context.Method, 
			_ => throw new NotSupportedException(), 
		};
		if (!context.IsDefinition)
		{
			CheckGenericContext(genericParameterProvider, (int)var);
		}
		if ((int)var >= genericParameterProvider.GenericParameters.Count)
		{
			return GetUnboundGenericParameter(type, (int)var);
		}
		return genericParameterProvider.GenericParameters[(int)var];
	}

	private GenericParameter GetUnboundGenericParameter(GenericParameterType type, int index)
	{
		return new GenericParameter(index, type, reader.module);
	}

	private static void CheckGenericContext(IGenericParameterProvider owner, int index)
	{
		Collection<GenericParameter> genericParameters = owner.GenericParameters;
		for (int i = genericParameters.Count; i <= index; i++)
		{
			genericParameters.Add(new GenericParameter(owner));
		}
	}

	public void ReadGenericInstanceSignature(IGenericParameterProvider provider, IGenericInstance instance)
	{
		uint num = ReadCompressedUInt32();
		if (!provider.IsDefinition)
		{
			CheckGenericContext(provider, (int)(num - 1));
		}
		Collection<TypeReference> genericArguments = instance.GenericArguments;
		for (int i = 0; i < num; i++)
		{
			genericArguments.Add(ReadTypeSignature());
		}
	}

	private ArrayType ReadArrayTypeSignature()
	{
		ArrayType arrayType = new ArrayType(ReadTypeSignature());
		uint num = ReadCompressedUInt32();
		uint[] array = new uint[ReadCompressedUInt32()];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = ReadCompressedUInt32();
		}
		int[] array2 = new int[ReadCompressedUInt32()];
		for (int j = 0; j < array2.Length; j++)
		{
			array2[j] = ReadCompressedInt32();
		}
		arrayType.Dimensions.Clear();
		for (int k = 0; k < num; k++)
		{
			int? num2 = null;
			int? upperBound = null;
			if (k < array2.Length)
			{
				num2 = array2[k];
			}
			if (k < array.Length)
			{
				upperBound = num2 + (int)array[k] - 1;
			}
			arrayType.Dimensions.Add(new ArrayDimension(num2, upperBound));
		}
		return arrayType;
	}

	private TypeReference GetTypeDefOrRef(MetadataToken token)
	{
		return reader.GetTypeDefOrRef(token);
	}

	public TypeReference ReadTypeSignature()
	{
		return ReadTypeSignature((ElementType)ReadByte());
	}

	private TypeReference ReadTypeSignature(ElementType etype)
	{
		switch (etype)
		{
		case ElementType.ValueType:
		{
			TypeReference typeDefOrRef2 = GetTypeDefOrRef(ReadTypeTokenSignature());
			typeDefOrRef2.IsValueType = true;
			return typeDefOrRef2;
		}
		case ElementType.Class:
			return GetTypeDefOrRef(ReadTypeTokenSignature());
		case ElementType.Ptr:
			return new PointerType(ReadTypeSignature());
		case ElementType.FnPtr:
		{
			FunctionPointerType functionPointerType = new FunctionPointerType();
			ReadMethodSignature(functionPointerType);
			return functionPointerType;
		}
		case ElementType.ByRef:
			return new ByReferenceType(ReadTypeSignature());
		case ElementType.Pinned:
			return new PinnedType(ReadTypeSignature());
		case ElementType.SzArray:
			return new ArrayType(ReadTypeSignature());
		case ElementType.Array:
			return ReadArrayTypeSignature();
		case ElementType.CModOpt:
			return new OptionalModifierType(GetTypeDefOrRef(ReadTypeTokenSignature()), ReadTypeSignature());
		case ElementType.CModReqD:
			return new RequiredModifierType(GetTypeDefOrRef(ReadTypeTokenSignature()), ReadTypeSignature());
		case ElementType.Sentinel:
			return new SentinelType(ReadTypeSignature());
		case ElementType.Var:
			return GetGenericParameter(GenericParameterType.Type, ReadCompressedUInt32());
		case ElementType.MVar:
			return GetGenericParameter(GenericParameterType.Method, ReadCompressedUInt32());
		case ElementType.GenericInst:
		{
			bool num = ReadByte() == 17;
			TypeReference typeDefOrRef = GetTypeDefOrRef(ReadTypeTokenSignature());
			GenericInstanceType genericInstanceType = new GenericInstanceType(typeDefOrRef);
			ReadGenericInstanceSignature(typeDefOrRef, genericInstanceType);
			if (num)
			{
				genericInstanceType.IsValueType = true;
				typeDefOrRef.GetElementType().IsValueType = true;
			}
			return genericInstanceType;
		}
		case ElementType.Object:
			return TypeSystem.Object;
		case ElementType.Void:
			return TypeSystem.Void;
		case ElementType.TypedByRef:
			return TypeSystem.TypedReference;
		case ElementType.I:
			return TypeSystem.IntPtr;
		case ElementType.U:
			return TypeSystem.UIntPtr;
		default:
			return GetPrimitiveType(etype);
		}
	}

	public void ReadMethodSignature(IMethodSignature method)
	{
		byte b = ReadByte();
		if ((b & 0x20) != 0)
		{
			method.HasThis = true;
			b = (byte)(b & -33);
		}
		if ((b & 0x40) != 0)
		{
			method.ExplicitThis = true;
			b = (byte)(b & -65);
		}
		method.CallingConvention = (MethodCallingConvention)b;
		MethodReference methodReference = method as MethodReference;
		if (methodReference != null && !methodReference.DeclaringType.IsArray)
		{
			reader.context = methodReference;
		}
		if ((b & 0x10) != 0)
		{
			uint num = ReadCompressedUInt32();
			if (methodReference != null && !methodReference.IsDefinition)
			{
				CheckGenericContext(methodReference, (int)(num - 1));
			}
		}
		uint num2 = ReadCompressedUInt32();
		method.MethodReturnType.ReturnType = ReadTypeSignature();
		if (num2 != 0)
		{
			Collection<ParameterDefinition> collection = ((!(method is MethodReference methodReference2)) ? method.Parameters : (methodReference2.parameters = new ParameterDefinitionCollection(method, (int)num2)));
			for (int i = 0; i < num2; i++)
			{
				collection.Add(new ParameterDefinition(ReadTypeSignature()));
			}
		}
	}

	public object ReadConstantSignature(ElementType type)
	{
		return ReadPrimitiveValue(type);
	}

	public void ReadCustomAttributeConstructorArguments(CustomAttribute attribute, Collection<ParameterDefinition> parameters)
	{
		int count = parameters.Count;
		if (count != 0)
		{
			attribute.arguments = new Collection<CustomAttributeArgument>(count);
			for (int i = 0; i < count; i++)
			{
				attribute.arguments.Add(ReadCustomAttributeFixedArgument(parameters[i].ParameterType));
			}
		}
	}

	private CustomAttributeArgument ReadCustomAttributeFixedArgument(TypeReference type)
	{
		if (type.IsArray)
		{
			return ReadCustomAttributeFixedArrayArgument((ArrayType)type);
		}
		return ReadCustomAttributeElement(type);
	}

	public void ReadCustomAttributeNamedArguments(ushort count, ref Collection<CustomAttributeNamedArgument> fields, ref Collection<CustomAttributeNamedArgument> properties)
	{
		for (int i = 0; i < count; i++)
		{
			ReadCustomAttributeNamedArgument(ref fields, ref properties);
		}
	}

	private void ReadCustomAttributeNamedArgument(ref Collection<CustomAttributeNamedArgument> fields, ref Collection<CustomAttributeNamedArgument> properties)
	{
		byte b = ReadByte();
		TypeReference type = ReadCustomAttributeFieldOrPropType();
		string name = ReadUTF8String();
		(b switch
		{
			83 => GetCustomAttributeNamedArgumentCollection(ref fields), 
			84 => GetCustomAttributeNamedArgumentCollection(ref properties), 
			_ => throw new NotSupportedException(), 
		}).Add(new CustomAttributeNamedArgument(name, ReadCustomAttributeFixedArgument(type)));
	}

	private static Collection<CustomAttributeNamedArgument> GetCustomAttributeNamedArgumentCollection(ref Collection<CustomAttributeNamedArgument> collection)
	{
		if (collection != null)
		{
			return collection;
		}
		return collection = new Collection<CustomAttributeNamedArgument>();
	}

	private CustomAttributeArgument ReadCustomAttributeFixedArrayArgument(ArrayType type)
	{
		uint num = ReadUInt32();
		switch (num)
		{
		case uint.MaxValue:
			return new CustomAttributeArgument(type, null);
		case 0u:
			return new CustomAttributeArgument(type, Empty<CustomAttributeArgument>.Array);
		default:
		{
			CustomAttributeArgument[] array = new CustomAttributeArgument[num];
			TypeReference elementType = type.ElementType;
			for (int i = 0; i < num; i++)
			{
				array[i] = ReadCustomAttributeElement(elementType);
			}
			return new CustomAttributeArgument(type, array);
		}
		}
	}

	private CustomAttributeArgument ReadCustomAttributeElement(TypeReference type)
	{
		if (type.IsArray)
		{
			return ReadCustomAttributeFixedArrayArgument((ArrayType)type);
		}
		return new CustomAttributeArgument(type, (type.etype == ElementType.Object) ? ((object)ReadCustomAttributeElement(ReadCustomAttributeFieldOrPropType())) : ReadCustomAttributeElementValue(type));
	}

	private object ReadCustomAttributeElementValue(TypeReference type)
	{
		ElementType etype = type.etype;
		switch (etype)
		{
		case ElementType.String:
			return ReadUTF8String();
		case ElementType.None:
			if (type.IsTypeOf("System", "Type"))
			{
				return ReadTypeReference();
			}
			return ReadCustomAttributeEnum(type);
		default:
			return ReadPrimitiveValue(etype);
		}
	}

	private object ReadPrimitiveValue(ElementType type)
	{
		return type switch
		{
			ElementType.Boolean => ReadByte() == 1, 
			ElementType.I1 => (sbyte)ReadByte(), 
			ElementType.U1 => ReadByte(), 
			ElementType.Char => (char)ReadUInt16(), 
			ElementType.I2 => ReadInt16(), 
			ElementType.U2 => ReadUInt16(), 
			ElementType.I4 => ReadInt32(), 
			ElementType.U4 => ReadUInt32(), 
			ElementType.I8 => ReadInt64(), 
			ElementType.U8 => ReadUInt64(), 
			ElementType.R4 => ReadSingle(), 
			ElementType.R8 => ReadDouble(), 
			_ => throw new NotImplementedException(type.ToString()), 
		};
	}

	private TypeReference GetPrimitiveType(ElementType etype)
	{
		return etype switch
		{
			ElementType.Boolean => TypeSystem.Boolean, 
			ElementType.Char => TypeSystem.Char, 
			ElementType.I1 => TypeSystem.SByte, 
			ElementType.U1 => TypeSystem.Byte, 
			ElementType.I2 => TypeSystem.Int16, 
			ElementType.U2 => TypeSystem.UInt16, 
			ElementType.I4 => TypeSystem.Int32, 
			ElementType.U4 => TypeSystem.UInt32, 
			ElementType.I8 => TypeSystem.Int64, 
			ElementType.U8 => TypeSystem.UInt64, 
			ElementType.R4 => TypeSystem.Single, 
			ElementType.R8 => TypeSystem.Double, 
			ElementType.String => TypeSystem.String, 
			_ => throw new NotImplementedException(etype.ToString()), 
		};
	}

	private TypeReference ReadCustomAttributeFieldOrPropType()
	{
		ElementType elementType = (ElementType)ReadByte();
		return elementType switch
		{
			ElementType.Boxed => TypeSystem.Object, 
			ElementType.SzArray => new ArrayType(ReadCustomAttributeFieldOrPropType()), 
			ElementType.Enum => ReadTypeReference(), 
			ElementType.Type => TypeSystem.LookupType("System", "Type"), 
			_ => GetPrimitiveType(elementType), 
		};
	}

	public TypeReference ReadTypeReference()
	{
		return TypeParser.ParseType(reader.module, ReadUTF8String());
	}

	private object ReadCustomAttributeEnum(TypeReference enum_type)
	{
		TypeDefinition typeDefinition = enum_type.CheckedResolve();
		if (!typeDefinition.IsEnum)
		{
			throw new ArgumentException();
		}
		return ReadCustomAttributeElementValue(typeDefinition.GetEnumUnderlyingType());
	}

	public SecurityAttribute ReadSecurityAttribute()
	{
		SecurityAttribute securityAttribute = new SecurityAttribute(ReadTypeReference());
		ReadCompressedUInt32();
		ReadCustomAttributeNamedArguments((ushort)ReadCompressedUInt32(), ref securityAttribute.fields, ref securityAttribute.properties);
		return securityAttribute;
	}

	public MarshalInfo ReadMarshalInfo()
	{
		NativeType nativeType = ReadNativeType();
		switch (nativeType)
		{
		case NativeType.Array:
		{
			ArrayMarshalInfo arrayMarshalInfo = new ArrayMarshalInfo();
			if (CanReadMore())
			{
				arrayMarshalInfo.element_type = ReadNativeType();
			}
			if (CanReadMore())
			{
				arrayMarshalInfo.size_parameter_index = (int)ReadCompressedUInt32();
			}
			if (CanReadMore())
			{
				arrayMarshalInfo.size = (int)ReadCompressedUInt32();
			}
			if (CanReadMore())
			{
				arrayMarshalInfo.size_parameter_multiplier = (int)ReadCompressedUInt32();
			}
			return arrayMarshalInfo;
		}
		case NativeType.SafeArray:
		{
			SafeArrayMarshalInfo safeArrayMarshalInfo = new SafeArrayMarshalInfo();
			if (CanReadMore())
			{
				safeArrayMarshalInfo.element_type = ReadVariantType();
			}
			return safeArrayMarshalInfo;
		}
		case NativeType.FixedArray:
		{
			FixedArrayMarshalInfo fixedArrayMarshalInfo = new FixedArrayMarshalInfo();
			if (CanReadMore())
			{
				fixedArrayMarshalInfo.size = (int)ReadCompressedUInt32();
			}
			if (CanReadMore())
			{
				fixedArrayMarshalInfo.element_type = ReadNativeType();
			}
			return fixedArrayMarshalInfo;
		}
		case NativeType.FixedSysString:
		{
			FixedSysStringMarshalInfo fixedSysStringMarshalInfo = new FixedSysStringMarshalInfo();
			if (CanReadMore())
			{
				fixedSysStringMarshalInfo.size = (int)ReadCompressedUInt32();
			}
			return fixedSysStringMarshalInfo;
		}
		case NativeType.CustomMarshaler:
		{
			CustomMarshalInfo customMarshalInfo = new CustomMarshalInfo();
			string text = ReadUTF8String();
			customMarshalInfo.guid = ((!string.IsNullOrEmpty(text)) ? new Guid(text) : Guid.Empty);
			customMarshalInfo.unmanaged_type = ReadUTF8String();
			customMarshalInfo.managed_type = ReadTypeReference();
			customMarshalInfo.cookie = ReadUTF8String();
			return customMarshalInfo;
		}
		default:
			return new MarshalInfo(nativeType);
		}
	}

	private NativeType ReadNativeType()
	{
		return (NativeType)ReadByte();
	}

	private VariantType ReadVariantType()
	{
		return (VariantType)ReadByte();
	}

	private string ReadUTF8String()
	{
		if (buffer[position] == byte.MaxValue)
		{
			position++;
			return null;
		}
		int num = (int)ReadCompressedUInt32();
		if (num == 0)
		{
			return string.Empty;
		}
		string @string = Encoding.UTF8.GetString(buffer, position, (buffer[position + num - 1] == 0) ? (num - 1) : num);
		position += num;
		return @string;
	}

	public bool CanReadMore()
	{
		return position - start < sig_length;
	}
}


using System;
using System.IO;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.PE;

internal static class ModuleWriter
{
	public static void WriteModuleTo(ModuleDefinition module, Stream stream, WriterParameters parameters)
	{
		if ((module.Attributes & ModuleAttributes.ILOnly) == 0)
		{
			throw new NotSupportedException("Writing mixed-mode assemblies is not supported");
		}
		if (module.HasImage && module.ReadingMode == ReadingMode.Deferred)
		{
			ImmediateModuleReader.ReadModule(module);
		}
		module.MetadataSystem.Clear();
		AssemblyNameDefinition assemblyNameDefinition = ((module.assembly != null) ? module.assembly.Name : null);
		string fullyQualifiedName = stream.GetFullyQualifiedName();
		ISymbolWriterProvider symbolWriterProvider = parameters.SymbolWriterProvider;
		if (symbolWriterProvider == null && parameters.WriteSymbols)
		{
			symbolWriterProvider = SymbolProvider.GetPlatformWriterProvider();
		}
		ISymbolWriter symbolWriter = GetSymbolWriter(module, fullyQualifiedName, symbolWriterProvider);
		if (parameters.StrongNameKeyPair != null && assemblyNameDefinition != null)
		{
			assemblyNameDefinition.PublicKey = parameters.StrongNameKeyPair.PublicKey;
			module.Attributes |= ModuleAttributes.StrongNameSigned;
		}
		MetadataBuilder metadata = new MetadataBuilder(module, fullyQualifiedName, symbolWriterProvider, symbolWriter);
		BuildMetadata(module, metadata);
		if (module.symbol_reader != null)
		{
			module.symbol_reader.Dispose();
		}
		ImageWriter imageWriter = ImageWriter.CreateWriter(module, metadata, stream);
		imageWriter.WriteImage();
		if (parameters.StrongNameKeyPair != null)
		{
			CryptoService.StrongName(stream, imageWriter, parameters.StrongNameKeyPair);
		}
		symbolWriter?.Dispose();
	}

	private static void BuildMetadata(ModuleDefinition module, MetadataBuilder metadata)
	{
		if (!module.HasImage)
		{
			metadata.BuildMetadata();
			return;
		}
		module.Read(metadata, delegate(MetadataBuilder builder, MetadataReader _)
		{
			builder.BuildMetadata();
			return builder;
		});
	}

	private static ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fq_name, ISymbolWriterProvider symbol_writer_provider)
	{
		return symbol_writer_provider?.GetSymbolWriter(module, fq_name);
	}
}


using Mono.Cecil.Metadata;

internal abstract class MetadataTable
{
	public abstract int Length { get; }

	public bool IsLarge => Length > 65535;

	public abstract void Write(TableHeapBuffer buffer);

	public abstract void Sort();
}


using Mono.Cecil;

internal abstract class OneRowTable<TRow> : MetadataTable where TRow : struct
{
	internal TRow row;

	public sealed override int Length => 1;

	public sealed override void Sort()
	{
	}
}


using System;
using Mono.Cecil;

internal abstract class MetadataTable<TRow> : MetadataTable where TRow : struct
{
	internal TRow[] rows = new TRow[2];

	internal int length;

	public sealed override int Length => length;

	public int AddRow(TRow row)
	{
		if (rows.Length == length)
		{
			Grow();
		}
		rows[length++] = row;
		return length;
	}

	private void Grow()
	{
		TRow[] destinationArray = new TRow[rows.Length * 2];
		Array.Copy(rows, destinationArray, rows.Length);
		rows = destinationArray;
	}

	public override void Sort()
	{
	}
}


using System;
using System.Collections.Generic;
using Mono.Cecil;

internal abstract class SortedTable<TRow> : MetadataTable<TRow>, IComparer<TRow> where TRow : struct
{
	public sealed override void Sort()
	{
		Array.Sort(rows, 0, length, this);
	}

	protected int Compare(uint x, uint y)
	{
		if (x != y)
		{
			if (x <= y)
			{
				return -1;
			}
			return 1;
		}
		return 0;
	}

	public abstract int Compare(TRow x, TRow y);
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class ModuleTable : OneRowTable<uint>
{
	public override void Write(TableHeapBuffer buffer)
	{
		buffer.WriteUInt16(0);
		buffer.WriteString(row);
		buffer.WriteUInt16(1);
		buffer.WriteUInt16(0);
		buffer.WriteUInt16(0);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class TypeRefTable : MetadataTable<Row<uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteCodedRID(rows[i].Col1, CodedIndex.ResolutionScope);
			buffer.WriteString(rows[i].Col2);
			buffer.WriteString(rows[i].Col3);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class TypeDefTable : MetadataTable<Row<TypeAttributes, uint, uint, uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt32((uint)rows[i].Col1);
			buffer.WriteString(rows[i].Col2);
			buffer.WriteString(rows[i].Col3);
			buffer.WriteCodedRID(rows[i].Col4, CodedIndex.TypeDefOrRef);
			buffer.WriteRID(rows[i].Col5, Table.Field);
			buffer.WriteRID(rows[i].Col6, Table.Method);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class FieldTable : MetadataTable<Row<FieldAttributes, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16((ushort)rows[i].Col1);
			buffer.WriteString(rows[i].Col2);
			buffer.WriteBlob(rows[i].Col3);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class MethodTable : MetadataTable<Row<uint, MethodImplAttributes, MethodAttributes, uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt32(rows[i].Col1);
			buffer.WriteUInt16((ushort)rows[i].Col2);
			buffer.WriteUInt16((ushort)rows[i].Col3);
			buffer.WriteString(rows[i].Col4);
			buffer.WriteBlob(rows[i].Col5);
			buffer.WriteRID(rows[i].Col6, Table.Param);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class ParamTable : MetadataTable<Row<ParameterAttributes, ushort, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16((ushort)rows[i].Col1);
			buffer.WriteUInt16(rows[i].Col2);
			buffer.WriteString(rows[i].Col3);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class InterfaceImplTable : MetadataTable<Row<uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteRID(rows[i].Col1, Table.TypeDef);
			buffer.WriteCodedRID(rows[i].Col2, CodedIndex.TypeDefOrRef);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class MemberRefTable : MetadataTable<Row<uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteCodedRID(rows[i].Col1, CodedIndex.MemberRefParent);
			buffer.WriteString(rows[i].Col2);
			buffer.WriteBlob(rows[i].Col3);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class ConstantTable : SortedTable<Row<ElementType, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16((ushort)rows[i].Col1);
			buffer.WriteCodedRID(rows[i].Col2, CodedIndex.HasConstant);
			buffer.WriteBlob(rows[i].Col3);
		}
	}

	public override int Compare(Row<ElementType, uint, uint> x, Row<ElementType, uint, uint> y)
	{
		return Compare(x.Col2, y.Col2);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class CustomAttributeTable : SortedTable<Row<uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteCodedRID(rows[i].Col1, CodedIndex.HasCustomAttribute);
			buffer.WriteCodedRID(rows[i].Col2, CodedIndex.CustomAttributeType);
			buffer.WriteBlob(rows[i].Col3);
		}
	}

	public override int Compare(Row<uint, uint, uint> x, Row<uint, uint, uint> y)
	{
		return Compare(x.Col1, y.Col1);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class FieldMarshalTable : SortedTable<Row<uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteCodedRID(rows[i].Col1, CodedIndex.HasFieldMarshal);
			buffer.WriteBlob(rows[i].Col2);
		}
	}

	public override int Compare(Row<uint, uint> x, Row<uint, uint> y)
	{
		return Compare(x.Col1, y.Col1);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class DeclSecurityTable : SortedTable<Row<SecurityAction, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16((ushort)rows[i].Col1);
			buffer.WriteCodedRID(rows[i].Col2, CodedIndex.HasDeclSecurity);
			buffer.WriteBlob(rows[i].Col3);
		}
	}

	public override int Compare(Row<SecurityAction, uint, uint> x, Row<SecurityAction, uint, uint> y)
	{
		return Compare(x.Col2, y.Col2);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class ClassLayoutTable : SortedTable<Row<ushort, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16(rows[i].Col1);
			buffer.WriteUInt32(rows[i].Col2);
			buffer.WriteRID(rows[i].Col3, Table.TypeDef);
		}
	}

	public override int Compare(Row<ushort, uint, uint> x, Row<ushort, uint, uint> y)
	{
		return Compare(x.Col3, y.Col3);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class FieldLayoutTable : SortedTable<Row<uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt32(rows[i].Col1);
			buffer.WriteRID(rows[i].Col2, Table.Field);
		}
	}

	public override int Compare(Row<uint, uint> x, Row<uint, uint> y)
	{
		return Compare(x.Col2, y.Col2);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class StandAloneSigTable : MetadataTable<uint>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteBlob(rows[i]);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class EventMapTable : MetadataTable<Row<uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteRID(rows[i].Col1, Table.TypeDef);
			buffer.WriteRID(rows[i].Col2, Table.Event);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class EventTable : MetadataTable<Row<EventAttributes, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16((ushort)rows[i].Col1);
			buffer.WriteString(rows[i].Col2);
			buffer.WriteCodedRID(rows[i].Col3, CodedIndex.TypeDefOrRef);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class PropertyMapTable : MetadataTable<Row<uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteRID(rows[i].Col1, Table.TypeDef);
			buffer.WriteRID(rows[i].Col2, Table.Property);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class PropertyTable : MetadataTable<Row<PropertyAttributes, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16((ushort)rows[i].Col1);
			buffer.WriteString(rows[i].Col2);
			buffer.WriteBlob(rows[i].Col3);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class MethodSemanticsTable : SortedTable<Row<MethodSemanticsAttributes, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16((ushort)rows[i].Col1);
			buffer.WriteRID(rows[i].Col2, Table.Method);
			buffer.WriteCodedRID(rows[i].Col3, CodedIndex.HasSemantics);
		}
	}

	public override int Compare(Row<MethodSemanticsAttributes, uint, uint> x, Row<MethodSemanticsAttributes, uint, uint> y)
	{
		return Compare(x.Col3, y.Col3);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class MethodImplTable : MetadataTable<Row<uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteRID(rows[i].Col1, Table.TypeDef);
			buffer.WriteCodedRID(rows[i].Col2, CodedIndex.MethodDefOrRef);
			buffer.WriteCodedRID(rows[i].Col3, CodedIndex.MethodDefOrRef);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class ModuleRefTable : MetadataTable<uint>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteString(rows[i]);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class TypeSpecTable : MetadataTable<uint>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteBlob(rows[i]);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class ImplMapTable : SortedTable<Row<PInvokeAttributes, uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16((ushort)rows[i].Col1);
			buffer.WriteCodedRID(rows[i].Col2, CodedIndex.MemberForwarded);
			buffer.WriteString(rows[i].Col3);
			buffer.WriteRID(rows[i].Col4, Table.ModuleRef);
		}
	}

	public override int Compare(Row<PInvokeAttributes, uint, uint, uint> x, Row<PInvokeAttributes, uint, uint, uint> y)
	{
		return Compare(x.Col2, y.Col2);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class FieldRVATable : SortedTable<Row<uint, uint>>
{
	internal int position;

	public override void Write(TableHeapBuffer buffer)
	{
		position = buffer.position;
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt32(rows[i].Col1);
			buffer.WriteRID(rows[i].Col2, Table.Field);
		}
	}

	public override int Compare(Row<uint, uint> x, Row<uint, uint> y)
	{
		return Compare(x.Col2, y.Col2);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class AssemblyTable : OneRowTable<Row<AssemblyHashAlgorithm, ushort, ushort, ushort, ushort, AssemblyAttributes, uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		buffer.WriteUInt32((uint)row.Col1);
		buffer.WriteUInt16(row.Col2);
		buffer.WriteUInt16(row.Col3);
		buffer.WriteUInt16(row.Col4);
		buffer.WriteUInt16(row.Col5);
		buffer.WriteUInt32((uint)row.Col6);
		buffer.WriteBlob(row.Col7);
		buffer.WriteString(row.Col8);
		buffer.WriteString(row.Col9);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class AssemblyRefTable : MetadataTable<Row<ushort, ushort, ushort, ushort, AssemblyAttributes, uint, uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16(rows[i].Col1);
			buffer.WriteUInt16(rows[i].Col2);
			buffer.WriteUInt16(rows[i].Col3);
			buffer.WriteUInt16(rows[i].Col4);
			buffer.WriteUInt32((uint)rows[i].Col5);
			buffer.WriteBlob(rows[i].Col6);
			buffer.WriteString(rows[i].Col7);
			buffer.WriteString(rows[i].Col8);
			buffer.WriteBlob(rows[i].Col9);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class FileTable : MetadataTable<Row<FileAttributes, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt32((uint)rows[i].Col1);
			buffer.WriteString(rows[i].Col2);
			buffer.WriteBlob(rows[i].Col3);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class ExportedTypeTable : MetadataTable<Row<TypeAttributes, uint, uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt32((uint)rows[i].Col1);
			buffer.WriteUInt32(rows[i].Col2);
			buffer.WriteString(rows[i].Col3);
			buffer.WriteString(rows[i].Col4);
			buffer.WriteCodedRID(rows[i].Col5, CodedIndex.Implementation);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class ManifestResourceTable : MetadataTable<Row<uint, ManifestResourceAttributes, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt32(rows[i].Col1);
			buffer.WriteUInt32((uint)rows[i].Col2);
			buffer.WriteString(rows[i].Col3);
			buffer.WriteCodedRID(rows[i].Col4, CodedIndex.Implementation);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class NestedClassTable : SortedTable<Row<uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteRID(rows[i].Col1, Table.TypeDef);
			buffer.WriteRID(rows[i].Col2, Table.TypeDef);
		}
	}

	public override int Compare(Row<uint, uint> x, Row<uint, uint> y)
	{
		return Compare(x.Col1, y.Col1);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class GenericParamTable : MetadataTable<Row<ushort, GenericParameterAttributes, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16(rows[i].Col1);
			buffer.WriteUInt16((ushort)rows[i].Col2);
			buffer.WriteCodedRID(rows[i].Col3, CodedIndex.TypeOrMethodDef);
			buffer.WriteString(rows[i].Col4);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class MethodSpecTable : MetadataTable<Row<uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteCodedRID(rows[i].Col1, CodedIndex.MethodDefOrRef);
			buffer.WriteBlob(rows[i].Col2);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class GenericParamConstraintTable : MetadataTable<Row<uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteRID(rows[i].Col1, Table.GenericParam);
			buffer.WriteCodedRID(rows[i].Col2, CodedIndex.TypeDefOrRef);
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;
using Mono.Collections.Generic;

internal sealed class MetadataBuilder
{
	private sealed class GenericParameterComparer : IComparer<GenericParameter>
	{
		public int Compare(GenericParameter a, GenericParameter b)
		{
			uint num = MakeCodedRID(a.Owner, CodedIndex.TypeOrMethodDef);
			uint num2 = MakeCodedRID(b.Owner, CodedIndex.TypeOrMethodDef);
			if (num == num2)
			{
				int position = a.Position;
				int position2 = b.Position;
				if (position != position2)
				{
					if (position <= position2)
					{
						return -1;
					}
					return 1;
				}
				return 0;
			}
			if (num <= num2)
			{
				return -1;
			}
			return 1;
		}
	}

	internal readonly ModuleDefinition module;

	internal readonly ISymbolWriterProvider symbol_writer_provider;

	internal readonly ISymbolWriter symbol_writer;

	internal readonly TextMap text_map;

	internal readonly string fq_name;

	private readonly Dictionary<Row<uint, uint, uint>, MetadataToken> type_ref_map;

	private readonly Dictionary<uint, MetadataToken> type_spec_map;

	private readonly Dictionary<Row<uint, uint, uint>, MetadataToken> member_ref_map;

	private readonly Dictionary<Row<uint, uint>, MetadataToken> method_spec_map;

	private readonly Collection<GenericParameter> generic_parameters;

	private readonly Dictionary<MetadataToken, MetadataToken> method_def_map;

	internal readonly CodeWriter code;

	internal readonly DataBuffer data;

	internal readonly ResourceBuffer resources;

	internal readonly StringHeapBuffer string_heap;

	internal readonly UserStringHeapBuffer user_string_heap;

	internal readonly BlobHeapBuffer blob_heap;

	internal readonly TableHeapBuffer table_heap;

	internal MetadataToken entry_point;

	private uint type_rid = 1u;

	private uint field_rid = 1u;

	private uint method_rid = 1u;

	private uint param_rid = 1u;

	private uint property_rid = 1u;

	private uint event_rid = 1u;

	private readonly TypeRefTable type_ref_table;

	private readonly TypeDefTable type_def_table;

	private readonly FieldTable field_table;

	private readonly MethodTable method_table;

	private readonly ParamTable param_table;

	private readonly InterfaceImplTable iface_impl_table;

	private readonly MemberRefTable member_ref_table;

	private readonly ConstantTable constant_table;

	private readonly CustomAttributeTable custom_attribute_table;

	private readonly DeclSecurityTable declsec_table;

	private readonly StandAloneSigTable standalone_sig_table;

	private readonly EventMapTable event_map_table;

	private readonly EventTable event_table;

	private readonly PropertyMapTable property_map_table;

	private readonly PropertyTable property_table;

	private readonly TypeSpecTable typespec_table;

	private readonly MethodSpecTable method_spec_table;

	internal readonly bool write_symbols;

	public MetadataBuilder(ModuleDefinition module, string fq_name, ISymbolWriterProvider symbol_writer_provider, ISymbolWriter symbol_writer)
	{
		this.module = module;
		text_map = CreateTextMap();
		this.fq_name = fq_name;
		this.symbol_writer_provider = symbol_writer_provider;
		this.symbol_writer = symbol_writer;
		write_symbols = symbol_writer != null;
		code = new CodeWriter(this);
		data = new DataBuffer();
		resources = new ResourceBuffer();
		string_heap = new StringHeapBuffer();
		user_string_heap = new UserStringHeapBuffer();
		blob_heap = new BlobHeapBuffer();
		table_heap = new TableHeapBuffer(module, this);
		type_ref_table = GetTable<TypeRefTable>(Table.TypeRef);
		type_def_table = GetTable<TypeDefTable>(Table.TypeDef);
		field_table = GetTable<FieldTable>(Table.Field);
		method_table = GetTable<MethodTable>(Table.Method);
		param_table = GetTable<ParamTable>(Table.Param);
		iface_impl_table = GetTable<InterfaceImplTable>(Table.InterfaceImpl);
		member_ref_table = GetTable<MemberRefTable>(Table.MemberRef);
		constant_table = GetTable<ConstantTable>(Table.Constant);
		custom_attribute_table = GetTable<CustomAttributeTable>(Table.CustomAttribute);
		declsec_table = GetTable<DeclSecurityTable>(Table.DeclSecurity);
		standalone_sig_table = GetTable<StandAloneSigTable>(Table.StandAloneSig);
		event_map_table = GetTable<EventMapTable>(Table.EventMap);
		event_table = GetTable<EventTable>(Table.Event);
		property_map_table = GetTable<PropertyMapTable>(Table.PropertyMap);
		property_table = GetTable<PropertyTable>(Table.Property);
		typespec_table = GetTable<TypeSpecTable>(Table.TypeSpec);
		method_spec_table = GetTable<MethodSpecTable>(Table.MethodSpec);
		RowEqualityComparer comparer = new RowEqualityComparer();
		type_ref_map = new Dictionary<Row<uint, uint, uint>, MetadataToken>(comparer);
		type_spec_map = new Dictionary<uint, MetadataToken>();
		member_ref_map = new Dictionary<Row<uint, uint, uint>, MetadataToken>(comparer);
		method_spec_map = new Dictionary<Row<uint, uint>, MetadataToken>(comparer);
		generic_parameters = new Collection<GenericParameter>();
		if (write_symbols)
		{
			method_def_map = new Dictionary<MetadataToken, MetadataToken>();
		}
	}

	private TextMap CreateTextMap()
	{
		TextMap textMap = new TextMap();
		textMap.AddMap(TextSegment.ImportAddressTable, (module.Architecture == TargetArchitecture.I386) ? 8 : 0);
		textMap.AddMap(TextSegment.CLIHeader, 72, 8);
		return textMap;
	}

	private TTable GetTable<TTable>(Table table) where TTable : MetadataTable, new()
	{
		return table_heap.GetTable<TTable>(table);
	}

	private uint GetStringIndex(string @string)
	{
		if (string.IsNullOrEmpty(@string))
		{
			return 0u;
		}
		return string_heap.GetStringIndex(@string);
	}

	private uint GetBlobIndex(ByteBuffer blob)
	{
		if (blob.length == 0)
		{
			return 0u;
		}
		return blob_heap.GetBlobIndex(blob);
	}

	private uint GetBlobIndex(byte[] blob)
	{
		if (blob.IsNullOrEmpty())
		{
			return 0u;
		}
		return GetBlobIndex(new ByteBuffer(blob));
	}

	public void BuildMetadata()
	{
		BuildModule();
		table_heap.WriteTableHeap();
	}

	private void BuildModule()
	{
		GetTable<ModuleTable>(Table.Module).row = GetStringIndex(module.Name);
		AssemblyDefinition assembly = module.Assembly;
		if (assembly != null)
		{
			BuildAssembly();
		}
		if (module.HasAssemblyReferences)
		{
			AddAssemblyReferences();
		}
		if (module.HasModuleReferences)
		{
			AddModuleReferences();
		}
		if (module.HasResources)
		{
			AddResources();
		}
		if (module.HasExportedTypes)
		{
			AddExportedTypes();
		}
		BuildTypes();
		if (assembly != null)
		{
			if (assembly.HasCustomAttributes)
			{
				AddCustomAttributes(assembly);
			}
			if (assembly.HasSecurityDeclarations)
			{
				AddSecurityDeclarations(assembly);
			}
		}
		if (module.HasCustomAttributes)
		{
			AddCustomAttributes(module);
		}
		if (module.EntryPoint != null)
		{
			entry_point = LookupToken(module.EntryPoint);
		}
	}

	private void BuildAssembly()
	{
		AssemblyDefinition assembly = module.Assembly;
		AssemblyNameDefinition name = assembly.Name;
		GetTable<AssemblyTable>(Table.Assembly).row = new Row<AssemblyHashAlgorithm, ushort, ushort, ushort, ushort, AssemblyAttributes, uint, uint, uint>(name.HashAlgorithm, (ushort)name.Version.Major, (ushort)name.Version.Minor, (ushort)name.Version.Build, (ushort)name.Version.Revision, name.Attributes, GetBlobIndex(name.PublicKey), GetStringIndex(name.Name), GetStringIndex(name.Culture));
		if (assembly.Modules.Count > 1)
		{
			BuildModules();
		}
	}

	private void BuildModules()
	{
		Collection<ModuleDefinition> modules = module.Assembly.Modules;
		FileTable table = GetTable<FileTable>(Table.File);
		for (int i = 0; i < modules.Count; i++)
		{
			ModuleDefinition moduleDefinition = modules[i];
			if (!moduleDefinition.IsMain)
			{
				WriterParameters parameters = new WriterParameters
				{
					SymbolWriterProvider = symbol_writer_provider
				};
				string moduleFileName = GetModuleFileName(moduleDefinition.Name);
				moduleDefinition.Write(moduleFileName, parameters);
				byte[] blob = CryptoService.ComputeHash(moduleFileName);
				table.AddRow(new Row<Mono.Cecil.FileAttributes, uint, uint>(Mono.Cecil.FileAttributes.ContainsMetaData, GetStringIndex(moduleDefinition.Name), GetBlobIndex(blob)));
			}
		}
	}

	private string GetModuleFileName(string name)
	{
		if (string.IsNullOrEmpty(name))
		{
			throw new NotSupportedException();
		}
		return Path.Combine(Path.GetDirectoryName(fq_name), name);
	}

	private void AddAssemblyReferences()
	{
		Collection<AssemblyNameReference> assemblyReferences = module.AssemblyReferences;
		AssemblyRefTable table = GetTable<AssemblyRefTable>(Table.AssemblyRef);
		for (int i = 0; i < assemblyReferences.Count; i++)
		{
			AssemblyNameReference assemblyNameReference = assemblyReferences[i];
			byte[] blob = (assemblyNameReference.PublicKey.IsNullOrEmpty() ? assemblyNameReference.PublicKeyToken : assemblyNameReference.PublicKey);
			Version version = assemblyNameReference.Version;
			int rid = table.AddRow(new Row<ushort, ushort, ushort, ushort, AssemblyAttributes, uint, uint, uint, uint>((ushort)version.Major, (ushort)version.Minor, (ushort)version.Build, (ushort)version.Revision, assemblyNameReference.Attributes, GetBlobIndex(blob), GetStringIndex(assemblyNameReference.Name), GetStringIndex(assemblyNameReference.Culture), GetBlobIndex(assemblyNameReference.Hash)));
			assemblyNameReference.token = new MetadataToken(TokenType.AssemblyRef, rid);
		}
	}

	private void AddModuleReferences()
	{
		Collection<ModuleReference> moduleReferences = module.ModuleReferences;
		ModuleRefTable table = GetTable<ModuleRefTable>(Table.ModuleRef);
		for (int i = 0; i < moduleReferences.Count; i++)
		{
			ModuleReference moduleReference = moduleReferences[i];
			moduleReference.token = new MetadataToken(TokenType.ModuleRef, table.AddRow(GetStringIndex(moduleReference.Name)));
		}
	}

	private void AddResources()
	{
		Collection<Resource> collection = module.Resources;
		ManifestResourceTable table = GetTable<ManifestResourceTable>(Table.ManifestResource);
		for (int i = 0; i < collection.Count; i++)
		{
			Resource resource = collection[i];
			Row<uint, ManifestResourceAttributes, uint, uint> row = new Row<uint, ManifestResourceAttributes, uint, uint>(0u, resource.Attributes, GetStringIndex(resource.Name), 0u);
			switch (resource.ResourceType)
			{
			case ResourceType.Embedded:
				row.Col1 = AddEmbeddedResource((EmbeddedResource)resource);
				break;
			case ResourceType.Linked:
				row.Col4 = CodedIndex.Implementation.CompressMetadataToken(new MetadataToken(TokenType.File, AddLinkedResource((LinkedResource)resource)));
				break;
			case ResourceType.AssemblyLinked:
				row.Col4 = CodedIndex.Implementation.CompressMetadataToken(((AssemblyLinkedResource)resource).Assembly.MetadataToken);
				break;
			default:
				throw new NotSupportedException();
			}
			table.AddRow(row);
		}
	}

	private uint AddLinkedResource(LinkedResource resource)
	{
		return (uint)GetTable<FileTable>(Table.File).AddRow(new Row<Mono.Cecil.FileAttributes, uint, uint>(col3: GetBlobIndex(resource.Hash.IsNullOrEmpty() ? CryptoService.ComputeHash(resource.File) : resource.Hash), col1: Mono.Cecil.FileAttributes.ContainsNoMetaData, col2: GetStringIndex(resource.File)));
	}

	private uint AddEmbeddedResource(EmbeddedResource resource)
	{
		return resources.AddResource(resource.GetResourceData());
	}

	private void AddExportedTypes()
	{
		Collection<ExportedType> exportedTypes = module.ExportedTypes;
		ExportedTypeTable table = GetTable<ExportedTypeTable>(Table.ExportedType);
		for (int i = 0; i < exportedTypes.Count; i++)
		{
			ExportedType exportedType = exportedTypes[i];
			int rid = table.AddRow(new Row<TypeAttributes, uint, uint, uint, uint>(exportedType.Attributes, (uint)exportedType.Identifier, GetStringIndex(exportedType.Name), GetStringIndex(exportedType.Namespace), MakeCodedRID(GetExportedTypeScope(exportedType), CodedIndex.Implementation)));
			exportedType.token = new MetadataToken(TokenType.ExportedType, rid);
		}
	}

	private MetadataToken GetExportedTypeScope(ExportedType exported_type)
	{
		if (exported_type.DeclaringType != null)
		{
			return exported_type.DeclaringType.MetadataToken;
		}
		IMetadataScope scope = exported_type.Scope;
		switch (scope.MetadataToken.TokenType)
		{
		case TokenType.AssemblyRef:
			return scope.MetadataToken;
		case TokenType.ModuleRef:
		{
			FileTable table = GetTable<FileTable>(Table.File);
			for (int i = 0; i < table.length; i++)
			{
				if (table.rows[i].Col2 == GetStringIndex(scope.Name))
				{
					return new MetadataToken(TokenType.File, i + 1);
				}
			}
			break;
		}
		}
		throw new NotSupportedException();
	}

	private void BuildTypes()
	{
		if (module.HasTypes)
		{
			AttachTokens();
			AddTypeDefs();
			AddGenericParameters();
		}
	}

	private void AttachTokens()
	{
		Collection<TypeDefinition> types = module.Types;
		for (int i = 0; i < types.Count; i++)
		{
			AttachTypeDefToken(types[i]);
		}
	}

	private void AttachTypeDefToken(TypeDefinition type)
	{
		type.token = new MetadataToken(TokenType.TypeDef, type_rid++);
		type.fields_range.Start = field_rid;
		type.methods_range.Start = method_rid;
		if (type.HasFields)
		{
			AttachFieldsDefToken(type);
		}
		if (type.HasMethods)
		{
			AttachMethodsDefToken(type);
		}
		if (type.HasNestedTypes)
		{
			AttachNestedTypesDefToken(type);
		}
	}

	private void AttachNestedTypesDefToken(TypeDefinition type)
	{
		Collection<TypeDefinition> nestedTypes = type.NestedTypes;
		for (int i = 0; i < nestedTypes.Count; i++)
		{
			AttachTypeDefToken(nestedTypes[i]);
		}
	}

	private void AttachFieldsDefToken(TypeDefinition type)
	{
		Collection<FieldDefinition> fields = type.Fields;
		type.fields_range.Length = (uint)fields.Count;
		for (int i = 0; i < fields.Count; i++)
		{
			fields[i].token = new MetadataToken(TokenType.Field, field_rid++);
		}
	}

	private void AttachMethodsDefToken(TypeDefinition type)
	{
		Collection<MethodDefinition> methods = type.Methods;
		type.methods_range.Length = (uint)methods.Count;
		for (int i = 0; i < methods.Count; i++)
		{
			MethodDefinition methodDefinition = methods[i];
			MetadataToken metadataToken = new MetadataToken(TokenType.Method, method_rid++);
			if (write_symbols && methodDefinition.token != MetadataToken.Zero)
			{
				method_def_map.Add(metadataToken, methodDefinition.token);
			}
			methodDefinition.token = metadataToken;
		}
	}

	public bool TryGetOriginalMethodToken(MetadataToken new_token, out MetadataToken original)
	{
		return method_def_map.TryGetValue(new_token, out original);
	}

	private MetadataToken GetTypeToken(TypeReference type)
	{
		if (type == null)
		{
			return MetadataToken.Zero;
		}
		if (type.IsDefinition)
		{
			return type.token;
		}
		if (type.IsTypeSpecification())
		{
			return GetTypeSpecToken(type);
		}
		return GetTypeRefToken(type);
	}

	private MetadataToken GetTypeSpecToken(TypeReference type)
	{
		uint blobIndex = GetBlobIndex(GetTypeSpecSignature(type));
		if (type_spec_map.TryGetValue(blobIndex, out var value))
		{
			return value;
		}
		return AddTypeSpecification(type, blobIndex);
	}

	private MetadataToken AddTypeSpecification(TypeReference type, uint row)
	{
		type.token = new MetadataToken(TokenType.TypeSpec, typespec_table.AddRow(row));
		MetadataToken token = type.token;
		type_spec_map.Add(row, token);
		return token;
	}

	private MetadataToken GetTypeRefToken(TypeReference type)
	{
		Row<uint, uint, uint> row = CreateTypeRefRow(type);
		if (type_ref_map.TryGetValue(row, out var value))
		{
			return value;
		}
		return AddTypeReference(type, row);
	}

	private Row<uint, uint, uint> CreateTypeRefRow(TypeReference type)
	{
		return new Row<uint, uint, uint>(MakeCodedRID(GetScopeToken(type), CodedIndex.ResolutionScope), GetStringIndex(type.Name), GetStringIndex(type.Namespace));
	}

	private MetadataToken GetScopeToken(TypeReference type)
	{
		if (type.IsNested)
		{
			return GetTypeRefToken(type.DeclaringType);
		}
		return type.Scope?.MetadataToken ?? MetadataToken.Zero;
	}

	private static uint MakeCodedRID(IMetadataTokenProvider provider, CodedIndex index)
	{
		return MakeCodedRID(provider.MetadataToken, index);
	}

	private static uint MakeCodedRID(MetadataToken token, CodedIndex index)
	{
		return index.CompressMetadataToken(token);
	}

	private MetadataToken AddTypeReference(TypeReference type, Row<uint, uint, uint> row)
	{
		type.token = new MetadataToken(TokenType.TypeRef, type_ref_table.AddRow(row));
		MetadataToken token = type.token;
		type_ref_map.Add(row, token);
		return token;
	}

	private void AddTypeDefs()
	{
		Collection<TypeDefinition> types = module.Types;
		for (int i = 0; i < types.Count; i++)
		{
			AddType(types[i]);
		}
	}

	private void AddType(TypeDefinition type)
	{
		type_def_table.AddRow(new Row<TypeAttributes, uint, uint, uint, uint, uint>(type.Attributes, GetStringIndex(type.Name), GetStringIndex(type.Namespace), MakeCodedRID(GetTypeToken(type.BaseType), CodedIndex.TypeDefOrRef), type.fields_range.Start, type.methods_range.Start));
		if (type.HasGenericParameters)
		{
			AddGenericParameters(type);
		}
		if (type.HasInterfaces)
		{
			AddInterfaces(type);
		}
		if (type.HasLayoutInfo)
		{
			AddLayoutInfo(type);
		}
		if (type.HasFields)
		{
			AddFields(type);
		}
		if (type.HasMethods)
		{
			AddMethods(type);
		}
		if (type.HasProperties)
		{
			AddProperties(type);
		}
		if (type.HasEvents)
		{
			AddEvents(type);
		}
		if (type.HasCustomAttributes)
		{
			AddCustomAttributes(type);
		}
		if (type.HasSecurityDeclarations)
		{
			AddSecurityDeclarations(type);
		}
		if (type.HasNestedTypes)
		{
			AddNestedTypes(type);
		}
	}

	private void AddGenericParameters(IGenericParameterProvider owner)
	{
		Collection<GenericParameter> genericParameters = owner.GenericParameters;
		for (int i = 0; i < genericParameters.Count; i++)
		{
			generic_parameters.Add(genericParameters[i]);
		}
	}

	private void AddGenericParameters()
	{
		GenericParameter[] items = generic_parameters.items;
		int size = generic_parameters.size;
		Array.Sort(items, 0, size, new GenericParameterComparer());
		GenericParamTable table = GetTable<GenericParamTable>(Table.GenericParam);
		GenericParamConstraintTable table2 = GetTable<GenericParamConstraintTable>(Table.GenericParamConstraint);
		for (int i = 0; i < size; i++)
		{
			GenericParameter genericParameter = items[i];
			int rid = table.AddRow(new Row<ushort, GenericParameterAttributes, uint, uint>((ushort)genericParameter.Position, genericParameter.Attributes, MakeCodedRID(genericParameter.Owner, CodedIndex.TypeOrMethodDef), GetStringIndex(genericParameter.Name)));
			genericParameter.token = new MetadataToken(TokenType.GenericParam, rid);
			if (genericParameter.HasConstraints)
			{
				AddConstraints(genericParameter, table2);
			}
			if (genericParameter.HasCustomAttributes)
			{
				AddCustomAttributes(genericParameter);
			}
		}
	}

	private void AddConstraints(GenericParameter generic_parameter, GenericParamConstraintTable table)
	{
		Collection<TypeReference> constraints = generic_parameter.Constraints;
		uint rID = generic_parameter.token.RID;
		for (int i = 0; i < constraints.Count; i++)
		{
			table.AddRow(new Row<uint, uint>(rID, MakeCodedRID(GetTypeToken(constraints[i]), CodedIndex.TypeDefOrRef)));
		}
	}

	private void AddInterfaces(TypeDefinition type)
	{
		Collection<TypeReference> interfaces = type.Interfaces;
		uint rID = type.token.RID;
		for (int i = 0; i < interfaces.Count; i++)
		{
			iface_impl_table.AddRow(new Row<uint, uint>(rID, MakeCodedRID(GetTypeToken(interfaces[i]), CodedIndex.TypeDefOrRef)));
		}
	}

	private void AddLayoutInfo(TypeDefinition type)
	{
		GetTable<ClassLayoutTable>(Table.ClassLayout).AddRow(new Row<ushort, uint, uint>((ushort)type.PackingSize, (uint)type.ClassSize, type.token.RID));
	}

	private void AddNestedTypes(TypeDefinition type)
	{
		Collection<TypeDefinition> nestedTypes = type.NestedTypes;
		NestedClassTable table = GetTable<NestedClassTable>(Table.NestedClass);
		for (int i = 0; i < nestedTypes.Count; i++)
		{
			TypeDefinition typeDefinition = nestedTypes[i];
			AddType(typeDefinition);
			table.AddRow(new Row<uint, uint>(typeDefinition.token.RID, type.token.RID));
		}
	}

	private void AddFields(TypeDefinition type)
	{
		Collection<FieldDefinition> fields = type.Fields;
		for (int i = 0; i < fields.Count; i++)
		{
			AddField(fields[i]);
		}
	}

	private void AddField(FieldDefinition field)
	{
		field_table.AddRow(new Row<FieldAttributes, uint, uint>(field.Attributes, GetStringIndex(field.Name), GetBlobIndex(GetFieldSignature(field))));
		if (!field.InitialValue.IsNullOrEmpty())
		{
			AddFieldRVA(field);
		}
		if (field.HasLayoutInfo)
		{
			AddFieldLayout(field);
		}
		if (field.HasCustomAttributes)
		{
			AddCustomAttributes(field);
		}
		if (field.HasConstant)
		{
			AddConstant(field, field.FieldType);
		}
		if (field.HasMarshalInfo)
		{
			AddMarshalInfo(field);
		}
	}

	private void AddFieldRVA(FieldDefinition field)
	{
		GetTable<FieldRVATable>(Table.FieldRVA).AddRow(new Row<uint, uint>(data.AddData(field.InitialValue), field.token.RID));
	}

	private void AddFieldLayout(FieldDefinition field)
	{
		GetTable<FieldLayoutTable>(Table.FieldLayout).AddRow(new Row<uint, uint>((uint)field.Offset, field.token.RID));
	}

	private void AddMethods(TypeDefinition type)
	{
		Collection<MethodDefinition> methods = type.Methods;
		for (int i = 0; i < methods.Count; i++)
		{
			AddMethod(methods[i]);
		}
	}

	private void AddMethod(MethodDefinition method)
	{
		method_table.AddRow(new Row<uint, MethodImplAttributes, MethodAttributes, uint, uint, uint>(method.HasBody ? code.WriteMethodBody(method) : 0u, method.ImplAttributes, method.Attributes, GetStringIndex(method.Name), GetBlobIndex(GetMethodSignature(method)), param_rid));
		AddParameters(method);
		if (method.HasGenericParameters)
		{
			AddGenericParameters(method);
		}
		if (method.IsPInvokeImpl)
		{
			AddPInvokeInfo(method);
		}
		if (method.HasCustomAttributes)
		{
			AddCustomAttributes(method);
		}
		if (method.HasSecurityDeclarations)
		{
			AddSecurityDeclarations(method);
		}
		if (method.HasOverrides)
		{
			AddOverrides(method);
		}
	}

	private void AddParameters(MethodDefinition method)
	{
		ParameterDefinition parameter = method.MethodReturnType.parameter;
		if (parameter != null && RequiresParameterRow(parameter))
		{
			AddParameter(0, parameter, param_table);
		}
		if (!method.HasParameters)
		{
			return;
		}
		Collection<ParameterDefinition> parameters = method.Parameters;
		for (int i = 0; i < parameters.Count; i++)
		{
			ParameterDefinition parameter2 = parameters[i];
			if (RequiresParameterRow(parameter2))
			{
				AddParameter((ushort)(i + 1), parameter2, param_table);
			}
		}
	}

	private void AddPInvokeInfo(MethodDefinition method)
	{
		PInvokeInfo pInvokeInfo = method.PInvokeInfo;
		if (pInvokeInfo != null)
		{
			GetTable<ImplMapTable>(Table.ImplMap).AddRow(new Row<PInvokeAttributes, uint, uint, uint>(pInvokeInfo.Attributes, MakeCodedRID(method, CodedIndex.MemberForwarded), GetStringIndex(pInvokeInfo.EntryPoint), pInvokeInfo.Module.MetadataToken.RID));
		}
	}

	private void AddOverrides(MethodDefinition method)
	{
		Collection<MethodReference> overrides = method.Overrides;
		MethodImplTable table = GetTable<MethodImplTable>(Table.MethodImpl);
		for (int i = 0; i < overrides.Count; i++)
		{
			table.AddRow(new Row<uint, uint, uint>(method.DeclaringType.token.RID, MakeCodedRID(method, CodedIndex.MethodDefOrRef), MakeCodedRID(LookupToken(overrides[i]), CodedIndex.MethodDefOrRef)));
		}
	}

	private static bool RequiresParameterRow(ParameterDefinition parameter)
	{
		if (string.IsNullOrEmpty(parameter.Name) && parameter.Attributes == ParameterAttributes.None && !parameter.HasMarshalInfo && !parameter.HasConstant)
		{
			return parameter.HasCustomAttributes;
		}
		return true;
	}

	private void AddParameter(ushort sequence, ParameterDefinition parameter, ParamTable table)
	{
		table.AddRow(new Row<ParameterAttributes, ushort, uint>(parameter.Attributes, sequence, GetStringIndex(parameter.Name)));
		parameter.token = new MetadataToken(TokenType.Param, param_rid++);
		if (parameter.HasCustomAttributes)
		{
			AddCustomAttributes(parameter);
		}
		if (parameter.HasConstant)
		{
			AddConstant(parameter, parameter.ParameterType);
		}
		if (parameter.HasMarshalInfo)
		{
			AddMarshalInfo(parameter);
		}
	}

	private void AddMarshalInfo(IMarshalInfoProvider owner)
	{
		GetTable<FieldMarshalTable>(Table.FieldMarshal).AddRow(new Row<uint, uint>(MakeCodedRID(owner, CodedIndex.HasFieldMarshal), GetBlobIndex(GetMarshalInfoSignature(owner))));
	}

	private void AddProperties(TypeDefinition type)
	{
		Collection<PropertyDefinition> properties = type.Properties;
		property_map_table.AddRow(new Row<uint, uint>(type.token.RID, property_rid));
		for (int i = 0; i < properties.Count; i++)
		{
			AddProperty(properties[i]);
		}
	}

	private void AddProperty(PropertyDefinition property)
	{
		property_table.AddRow(new Row<PropertyAttributes, uint, uint>(property.Attributes, GetStringIndex(property.Name), GetBlobIndex(GetPropertySignature(property))));
		property.token = new MetadataToken(TokenType.Property, property_rid++);
		MethodDefinition getMethod = property.GetMethod;
		if (getMethod != null)
		{
			AddSemantic(MethodSemanticsAttributes.Getter, property, getMethod);
		}
		getMethod = property.SetMethod;
		if (getMethod != null)
		{
			AddSemantic(MethodSemanticsAttributes.Setter, property, getMethod);
		}
		if (property.HasOtherMethods)
		{
			AddOtherSemantic(property, property.OtherMethods);
		}
		if (property.HasCustomAttributes)
		{
			AddCustomAttributes(property);
		}
		if (property.HasConstant)
		{
			AddConstant(property, property.PropertyType);
		}
	}

	private void AddOtherSemantic(IMetadataTokenProvider owner, Collection<MethodDefinition> others)
	{
		for (int i = 0; i < others.Count; i++)
		{
			AddSemantic(MethodSemanticsAttributes.Other, owner, others[i]);
		}
	}

	private void AddEvents(TypeDefinition type)
	{
		Collection<EventDefinition> events = type.Events;
		event_map_table.AddRow(new Row<uint, uint>(type.token.RID, event_rid));
		for (int i = 0; i < events.Count; i++)
		{
			AddEvent(events[i]);
		}
	}

	private void AddEvent(EventDefinition @event)
	{
		event_table.AddRow(new Row<EventAttributes, uint, uint>(@event.Attributes, GetStringIndex(@event.Name), MakeCodedRID(GetTypeToken(@event.EventType), CodedIndex.TypeDefOrRef)));
		@event.token = new MetadataToken(TokenType.Event, event_rid++);
		MethodDefinition addMethod = @event.AddMethod;
		if (addMethod != null)
		{
			AddSemantic(MethodSemanticsAttributes.AddOn, @event, addMethod);
		}
		addMethod = @event.InvokeMethod;
		if (addMethod != null)
		{
			AddSemantic(MethodSemanticsAttributes.Fire, @event, addMethod);
		}
		addMethod = @event.RemoveMethod;
		if (addMethod != null)
		{
			AddSemantic(MethodSemanticsAttributes.RemoveOn, @event, addMethod);
		}
		if (@event.HasOtherMethods)
		{
			AddOtherSemantic(@event, @event.OtherMethods);
		}
		if (@event.HasCustomAttributes)
		{
			AddCustomAttributes(@event);
		}
	}

	private void AddSemantic(MethodSemanticsAttributes semantics, IMetadataTokenProvider provider, MethodDefinition method)
	{
		method.SemanticsAttributes = semantics;
		GetTable<MethodSemanticsTable>(Table.MethodSemantics).AddRow(new Row<MethodSemanticsAttributes, uint, uint>(semantics, method.token.RID, MakeCodedRID(provider, CodedIndex.HasSemantics)));
	}

	private void AddConstant(IConstantProvider owner, TypeReference type)
	{
		object constant = owner.Constant;
		ElementType constantType = GetConstantType(type, constant);
		constant_table.AddRow(new Row<ElementType, uint, uint>(constantType, MakeCodedRID(owner.MetadataToken, CodedIndex.HasConstant), GetBlobIndex(GetConstantSignature(constantType, constant))));
	}

	private static ElementType GetConstantType(TypeReference constant_type, object constant)
	{
		if (constant == null)
		{
			return ElementType.Class;
		}
		ElementType etype = constant_type.etype;
		switch (etype)
		{
		case ElementType.None:
		{
			TypeDefinition typeDefinition = constant_type.CheckedResolve();
			if (typeDefinition.IsEnum)
			{
				return GetConstantType(typeDefinition.GetEnumUnderlyingType(), constant);
			}
			return ElementType.Class;
		}
		case ElementType.String:
			return ElementType.String;
		case ElementType.Object:
			return GetConstantType(constant.GetType());
		case ElementType.Var:
		case ElementType.Array:
		case ElementType.SzArray:
		case ElementType.MVar:
			return ElementType.Class;
		case ElementType.GenericInst:
		{
			GenericInstanceType genericInstanceType = (GenericInstanceType)constant_type;
			if (genericInstanceType.ElementType.IsTypeOf("System", "Nullable`1"))
			{
				return GetConstantType(genericInstanceType.GenericArguments[0], constant);
			}
			return GetConstantType(((TypeSpecification)constant_type).ElementType, constant);
		}
		case ElementType.ByRef:
		case ElementType.CModReqD:
		case ElementType.CModOpt:
		case ElementType.Sentinel:
			return GetConstantType(((TypeSpecification)constant_type).ElementType, constant);
		case ElementType.Boolean:
		case ElementType.Char:
		case ElementType.I1:
		case ElementType.U1:
		case ElementType.I2:
		case ElementType.U2:
		case ElementType.I4:
		case ElementType.U4:
		case ElementType.I8:
		case ElementType.U8:
		case ElementType.R4:
		case ElementType.R8:
		case ElementType.I:
		case ElementType.U:
			return GetConstantType(constant.GetType());
		default:
			return etype;
		}
	}

	private static ElementType GetConstantType(Type type)
	{
		return Type.GetTypeCode(type) switch
		{
			TypeCode.Boolean => ElementType.Boolean, 
			TypeCode.Byte => ElementType.U1, 
			TypeCode.SByte => ElementType.I1, 
			TypeCode.Char => ElementType.Char, 
			TypeCode.Int16 => ElementType.I2, 
			TypeCode.UInt16 => ElementType.U2, 
			TypeCode.Int32 => ElementType.I4, 
			TypeCode.UInt32 => ElementType.U4, 
			TypeCode.Int64 => ElementType.I8, 
			TypeCode.UInt64 => ElementType.U8, 
			TypeCode.Single => ElementType.R4, 
			TypeCode.Double => ElementType.R8, 
			TypeCode.String => ElementType.String, 
			_ => throw new NotSupportedException(type.FullName), 
		};
	}

	private void AddCustomAttributes(ICustomAttributeProvider owner)
	{
		Collection<CustomAttribute> customAttributes = owner.CustomAttributes;
		for (int i = 0; i < customAttributes.Count; i++)
		{
			CustomAttribute customAttribute = customAttributes[i];
			custom_attribute_table.AddRow(new Row<uint, uint, uint>(MakeCodedRID(owner, CodedIndex.HasCustomAttribute), MakeCodedRID(LookupToken(customAttribute.Constructor), CodedIndex.CustomAttributeType), GetBlobIndex(GetCustomAttributeSignature(customAttribute))));
		}
	}

	private void AddSecurityDeclarations(ISecurityDeclarationProvider owner)
	{
		Collection<SecurityDeclaration> securityDeclarations = owner.SecurityDeclarations;
		for (int i = 0; i < securityDeclarations.Count; i++)
		{
			SecurityDeclaration securityDeclaration = securityDeclarations[i];
			declsec_table.AddRow(new Row<SecurityAction, uint, uint>(securityDeclaration.Action, MakeCodedRID(owner, CodedIndex.HasDeclSecurity), GetBlobIndex(GetSecurityDeclarationSignature(securityDeclaration))));
		}
	}

	private MetadataToken GetMemberRefToken(MemberReference member)
	{
		Row<uint, uint, uint> row = CreateMemberRefRow(member);
		if (member_ref_map.TryGetValue(row, out var value))
		{
			return value;
		}
		AddMemberReference(member, row);
		return member.token;
	}

	private Row<uint, uint, uint> CreateMemberRefRow(MemberReference member)
	{
		return new Row<uint, uint, uint>(MakeCodedRID(GetTypeToken(member.DeclaringType), CodedIndex.MemberRefParent), GetStringIndex(member.Name), GetBlobIndex(GetMemberRefSignature(member)));
	}

	private void AddMemberReference(MemberReference member, Row<uint, uint, uint> row)
	{
		member.token = new MetadataToken(TokenType.MemberRef, member_ref_table.AddRow(row));
		member_ref_map.Add(row, member.token);
	}

	private MetadataToken GetMethodSpecToken(MethodSpecification method_spec)
	{
		Row<uint, uint> row = CreateMethodSpecRow(method_spec);
		if (method_spec_map.TryGetValue(row, out var value))
		{
			return value;
		}
		AddMethodSpecification(method_spec, row);
		return method_spec.token;
	}

	private void AddMethodSpecification(MethodSpecification method_spec, Row<uint, uint> row)
	{
		method_spec.token = new MetadataToken(TokenType.MethodSpec, method_spec_table.AddRow(row));
		method_spec_map.Add(row, method_spec.token);
	}

	private Row<uint, uint> CreateMethodSpecRow(MethodSpecification method_spec)
	{
		return new Row<uint, uint>(MakeCodedRID(LookupToken(method_spec.ElementMethod), CodedIndex.MethodDefOrRef), GetBlobIndex(GetMethodSpecSignature(method_spec)));
	}

	private SignatureWriter CreateSignatureWriter()
	{
		return new SignatureWriter(this);
	}

	private SignatureWriter GetMethodSpecSignature(MethodSpecification method_spec)
	{
		if (!method_spec.IsGenericInstance)
		{
			throw new NotSupportedException();
		}
		GenericInstanceMethod instance = (GenericInstanceMethod)method_spec;
		SignatureWriter signatureWriter = CreateSignatureWriter();
		signatureWriter.WriteByte(10);
		signatureWriter.WriteGenericInstanceSignature(instance);
		return signatureWriter;
	}

	public uint AddStandAloneSignature(uint signature)
	{
		return (uint)standalone_sig_table.AddRow(signature);
	}

	public uint GetLocalVariableBlobIndex(Collection<VariableDefinition> variables)
	{
		return GetBlobIndex(GetVariablesSignature(variables));
	}

	public uint GetCallSiteBlobIndex(CallSite call_site)
	{
		return GetBlobIndex(GetMethodSignature(call_site));
	}

	private SignatureWriter GetVariablesSignature(Collection<VariableDefinition> variables)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		signatureWriter.WriteByte(7);
		signatureWriter.WriteCompressedUInt32((uint)variables.Count);
		for (int i = 0; i < variables.Count; i++)
		{
			signatureWriter.WriteTypeSignature(variables[i].VariableType);
		}
		return signatureWriter;
	}

	private SignatureWriter GetFieldSignature(FieldReference field)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		signatureWriter.WriteByte(6);
		signatureWriter.WriteTypeSignature(field.FieldType);
		return signatureWriter;
	}

	private SignatureWriter GetMethodSignature(IMethodSignature method)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		signatureWriter.WriteMethodSignature(method);
		return signatureWriter;
	}

	private SignatureWriter GetMemberRefSignature(MemberReference member)
	{
		if (member is FieldReference field)
		{
			return GetFieldSignature(field);
		}
		if (member is MethodReference method)
		{
			return GetMethodSignature(method);
		}
		throw new NotSupportedException();
	}

	private SignatureWriter GetPropertySignature(PropertyDefinition property)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		byte b = 8;
		if (property.HasThis)
		{
			b |= 0x20;
		}
		uint num = 0u;
		Collection<ParameterDefinition> collection = null;
		if (property.HasParameters)
		{
			collection = property.Parameters;
			num = (uint)collection.Count;
		}
		signatureWriter.WriteByte(b);
		signatureWriter.WriteCompressedUInt32(num);
		signatureWriter.WriteTypeSignature(property.PropertyType);
		if (num == 0)
		{
			return signatureWriter;
		}
		for (int i = 0; i < num; i++)
		{
			signatureWriter.WriteTypeSignature(collection[i].ParameterType);
		}
		return signatureWriter;
	}

	private SignatureWriter GetTypeSpecSignature(TypeReference type)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		signatureWriter.WriteTypeSignature(type);
		return signatureWriter;
	}

	private SignatureWriter GetConstantSignature(ElementType type, object value)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		switch (type)
		{
		case ElementType.Class:
		case ElementType.Var:
		case ElementType.Array:
		case ElementType.Object:
		case ElementType.SzArray:
		case ElementType.MVar:
			signatureWriter.WriteInt32(0);
			break;
		case ElementType.String:
			signatureWriter.WriteConstantString((string)value);
			break;
		default:
			signatureWriter.WriteConstantPrimitive(value);
			break;
		}
		return signatureWriter;
	}

	private SignatureWriter GetCustomAttributeSignature(CustomAttribute attribute)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		if (!attribute.resolved)
		{
			signatureWriter.WriteBytes(attribute.GetBlob());
			return signatureWriter;
		}
		signatureWriter.WriteUInt16(1);
		signatureWriter.WriteCustomAttributeConstructorArguments(attribute);
		signatureWriter.WriteCustomAttributeNamedArguments(attribute);
		return signatureWriter;
	}

	private SignatureWriter GetSecurityDeclarationSignature(SecurityDeclaration declaration)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		if (!declaration.resolved)
		{
			signatureWriter.WriteBytes(declaration.GetBlob());
		}
		else if (module.Runtime < TargetRuntime.Net_2_0)
		{
			signatureWriter.WriteXmlSecurityDeclaration(declaration);
		}
		else
		{
			signatureWriter.WriteSecurityDeclaration(declaration);
		}
		return signatureWriter;
	}

	private SignatureWriter GetMarshalInfoSignature(IMarshalInfoProvider owner)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		signatureWriter.WriteMarshalInfo(owner.MarshalInfo);
		return signatureWriter;
	}

	private static Exception CreateForeignMemberException(MemberReference member)
	{
		return new ArgumentException($"Member '{member}' is declared in another module and needs to be imported");
	}

	public MetadataToken LookupToken(IMetadataTokenProvider provider)
	{
		if (provider == null)
		{
			throw new ArgumentNullException();
		}
		MemberReference memberReference = provider as MemberReference;
		if (memberReference == null || memberReference.Module != module)
		{
			throw CreateForeignMemberException(memberReference);
		}
		MetadataToken metadataToken = provider.MetadataToken;
		switch (metadataToken.TokenType)
		{
		case TokenType.TypeDef:
		case TokenType.Field:
		case TokenType.Method:
		case TokenType.Event:
		case TokenType.Property:
			return metadataToken;
		case TokenType.TypeRef:
		case TokenType.TypeSpec:
		case TokenType.GenericParam:
			return GetTypeToken((TypeReference)provider);
		case TokenType.MethodSpec:
			return GetMethodSpecToken((MethodSpecification)provider);
		case TokenType.MemberRef:
			return GetMemberRefToken(memberReference);
		default:
			throw new NotSupportedException();
		}
	}
}


using System.Collections.Generic;
using Mono.Cecil.Metadata;

private sealed class GenericParameterComparer : IComparer<GenericParameter>
{
	public int Compare(GenericParameter a, GenericParameter b)
	{
		uint num = MakeCodedRID(a.Owner, CodedIndex.TypeOrMethodDef);
		uint num2 = MakeCodedRID(b.Owner, CodedIndex.TypeOrMethodDef);
		if (num == num2)
		{
			int position = a.Position;
			int position2 = b.Position;
			if (position != position2)
			{
				if (position <= position2)
				{
					return -1;
				}
				return 1;
			}
			return 0;
		}
		if (num <= num2)
		{
			return -1;
		}
		return 1;
	}
}


using System;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;
using Mono.Collections.Generic;

internal sealed class SignatureWriter : ByteBuffer
{
	private readonly MetadataBuilder metadata;

	public SignatureWriter(MetadataBuilder metadata)
		: base(6)
	{
		this.metadata = metadata;
	}

	public void WriteElementType(ElementType element_type)
	{
		WriteByte((byte)element_type);
	}

	public void WriteUTF8String(string @string)
	{
		if (@string == null)
		{
			WriteByte(byte.MaxValue);
			return;
		}
		byte[] bytes = Encoding.UTF8.GetBytes(@string);
		WriteCompressedUInt32((uint)bytes.Length);
		WriteBytes(bytes);
	}

	public void WriteMethodSignature(IMethodSignature method)
	{
		byte b = (byte)method.CallingConvention;
		if (method.HasThis)
		{
			b |= 0x20;
		}
		if (method.ExplicitThis)
		{
			b |= 0x40;
		}
		int num = ((method is IGenericParameterProvider { HasGenericParameters: not false } genericParameterProvider) ? genericParameterProvider.GenericParameters.Count : 0);
		if (num > 0)
		{
			b |= 0x10;
		}
		int num2 = (method.HasParameters ? method.Parameters.Count : 0);
		WriteByte(b);
		if (num > 0)
		{
			WriteCompressedUInt32((uint)num);
		}
		WriteCompressedUInt32((uint)num2);
		WriteTypeSignature(method.ReturnType);
		if (num2 != 0)
		{
			Collection<ParameterDefinition> parameters = method.Parameters;
			for (int i = 0; i < num2; i++)
			{
				WriteTypeSignature(parameters[i].ParameterType);
			}
		}
	}

	private uint MakeTypeDefOrRefCodedRID(TypeReference type)
	{
		return CodedIndex.TypeDefOrRef.CompressMetadataToken(metadata.LookupToken(type));
	}

	public void WriteTypeSignature(TypeReference type)
	{
		if (type == null)
		{
			throw new ArgumentNullException();
		}
		ElementType etype = type.etype;
		switch (etype)
		{
		case ElementType.Var:
		case ElementType.MVar:
		{
			GenericParameter obj = (GenericParameter)type;
			WriteElementType(etype);
			int num = obj.Position;
			if (num == -1)
			{
				throw new NotSupportedException();
			}
			WriteCompressedUInt32((uint)num);
			break;
		}
		case ElementType.GenericInst:
		{
			GenericInstanceType genericInstanceType = (GenericInstanceType)type;
			WriteElementType(ElementType.GenericInst);
			WriteElementType(genericInstanceType.IsValueType ? ElementType.ValueType : ElementType.Class);
			WriteCompressedUInt32(MakeTypeDefOrRefCodedRID(genericInstanceType.ElementType));
			WriteGenericInstanceSignature(genericInstanceType);
			break;
		}
		case ElementType.Ptr:
		case ElementType.ByRef:
		case ElementType.Sentinel:
		case ElementType.Pinned:
		{
			TypeSpecification typeSpecification = (TypeSpecification)type;
			WriteElementType(etype);
			WriteTypeSignature(typeSpecification.ElementType);
			break;
		}
		case ElementType.FnPtr:
		{
			FunctionPointerType method = (FunctionPointerType)type;
			WriteElementType(ElementType.FnPtr);
			WriteMethodSignature(method);
			break;
		}
		case ElementType.CModReqD:
		case ElementType.CModOpt:
		{
			IModifierType type2 = (IModifierType)type;
			WriteModifierSignature(etype, type2);
			break;
		}
		case ElementType.Array:
		{
			ArrayType arrayType = (ArrayType)type;
			if (!arrayType.IsVector)
			{
				WriteArrayTypeSignature(arrayType);
				break;
			}
			WriteElementType(ElementType.SzArray);
			WriteTypeSignature(arrayType.ElementType);
			break;
		}
		case ElementType.None:
			WriteElementType(type.IsValueType ? ElementType.ValueType : ElementType.Class);
			WriteCompressedUInt32(MakeTypeDefOrRefCodedRID(type));
			break;
		default:
			if (!TryWriteElementType(type))
			{
				throw new NotSupportedException();
			}
			break;
		}
	}

	private void WriteArrayTypeSignature(ArrayType array)
	{
		WriteElementType(ElementType.Array);
		WriteTypeSignature(array.ElementType);
		Collection<ArrayDimension> dimensions = array.Dimensions;
		int count = dimensions.Count;
		WriteCompressedUInt32((uint)count);
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < count; i++)
		{
			ArrayDimension arrayDimension = dimensions[i];
			if (arrayDimension.UpperBound.HasValue)
			{
				num++;
				num2++;
			}
			else if (arrayDimension.LowerBound.HasValue)
			{
				num2++;
			}
		}
		int[] array2 = new int[num];
		int[] array3 = new int[num2];
		for (int j = 0; j < num2; j++)
		{
			ArrayDimension arrayDimension2 = dimensions[j];
			array3[j] = arrayDimension2.LowerBound.GetValueOrDefault();
			if (arrayDimension2.UpperBound.HasValue)
			{
				array2[j] = arrayDimension2.UpperBound.Value - array3[j] + 1;
			}
		}
		WriteCompressedUInt32((uint)num);
		for (int k = 0; k < num; k++)
		{
			WriteCompressedUInt32((uint)array2[k]);
		}
		WriteCompressedUInt32((uint)num2);
		for (int l = 0; l < num2; l++)
		{
			WriteCompressedInt32(array3[l]);
		}
	}

	public void WriteGenericInstanceSignature(IGenericInstance instance)
	{
		Collection<TypeReference> genericArguments = instance.GenericArguments;
		int count = genericArguments.Count;
		WriteCompressedUInt32((uint)count);
		for (int i = 0; i < count; i++)
		{
			WriteTypeSignature(genericArguments[i]);
		}
	}

	private void WriteModifierSignature(ElementType element_type, IModifierType type)
	{
		WriteElementType(element_type);
		WriteCompressedUInt32(MakeTypeDefOrRefCodedRID(type.ModifierType));
		WriteTypeSignature(type.ElementType);
	}

	private bool TryWriteElementType(TypeReference type)
	{
		ElementType etype = type.etype;
		if (etype == ElementType.None)
		{
			return false;
		}
		WriteElementType(etype);
		return true;
	}

	public void WriteConstantString(string value)
	{
		WriteBytes(Encoding.Unicode.GetBytes(value));
	}

	public void WriteConstantPrimitive(object value)
	{
		WritePrimitiveValue(value);
	}

	public void WriteCustomAttributeConstructorArguments(CustomAttribute attribute)
	{
		if (attribute.HasConstructorArguments)
		{
			Collection<CustomAttributeArgument> constructorArguments = attribute.ConstructorArguments;
			Collection<ParameterDefinition> parameters = attribute.Constructor.Parameters;
			if (parameters.Count != constructorArguments.Count)
			{
				throw new InvalidOperationException();
			}
			for (int i = 0; i < constructorArguments.Count; i++)
			{
				WriteCustomAttributeFixedArgument(parameters[i].ParameterType, constructorArguments[i]);
			}
		}
	}

	private void WriteCustomAttributeFixedArgument(TypeReference type, CustomAttributeArgument argument)
	{
		if (type.IsArray)
		{
			WriteCustomAttributeFixedArrayArgument((ArrayType)type, argument);
		}
		else
		{
			WriteCustomAttributeElement(type, argument);
		}
	}

	private void WriteCustomAttributeFixedArrayArgument(ArrayType type, CustomAttributeArgument argument)
	{
		if (!(argument.Value is CustomAttributeArgument[] array))
		{
			WriteUInt32(uint.MaxValue);
			return;
		}
		WriteInt32(array.Length);
		if (array.Length != 0)
		{
			TypeReference elementType = type.ElementType;
			for (int i = 0; i < array.Length; i++)
			{
				WriteCustomAttributeElement(elementType, array[i]);
			}
		}
	}

	private void WriteCustomAttributeElement(TypeReference type, CustomAttributeArgument argument)
	{
		if (type.IsArray)
		{
			WriteCustomAttributeFixedArrayArgument((ArrayType)type, argument);
		}
		else if (type.etype == ElementType.Object)
		{
			argument = (CustomAttributeArgument)argument.Value;
			type = argument.Type;
			WriteCustomAttributeFieldOrPropType(type);
			WriteCustomAttributeElement(type, argument);
		}
		else
		{
			WriteCustomAttributeValue(type, argument.Value);
		}
	}

	private void WriteCustomAttributeValue(TypeReference type, object value)
	{
		switch (type.etype)
		{
		case ElementType.String:
		{
			string text = (string)value;
			if (text == null)
			{
				WriteByte(byte.MaxValue);
			}
			else
			{
				WriteUTF8String(text);
			}
			break;
		}
		case ElementType.None:
			if (type.IsTypeOf("System", "Type"))
			{
				WriteTypeReference((TypeReference)value);
			}
			else
			{
				WriteCustomAttributeEnumValue(type, value);
			}
			break;
		default:
			WritePrimitiveValue(value);
			break;
		}
	}

	private void WritePrimitiveValue(object value)
	{
		if (value == null)
		{
			throw new ArgumentNullException();
		}
		switch (Type.GetTypeCode(value.GetType()))
		{
		case TypeCode.Boolean:
			WriteByte((byte)(((bool)value) ? 1u : 0u));
			break;
		case TypeCode.Byte:
			WriteByte((byte)value);
			break;
		case TypeCode.SByte:
			WriteSByte((sbyte)value);
			break;
		case TypeCode.Int16:
			WriteInt16((short)value);
			break;
		case TypeCode.UInt16:
			WriteUInt16((ushort)value);
			break;
		case TypeCode.Char:
			WriteInt16((short)(char)value);
			break;
		case TypeCode.Int32:
			WriteInt32((int)value);
			break;
		case TypeCode.UInt32:
			WriteUInt32((uint)value);
			break;
		case TypeCode.Single:
			WriteSingle((float)value);
			break;
		case TypeCode.Int64:
			WriteInt64((long)value);
			break;
		case TypeCode.UInt64:
			WriteUInt64((ulong)value);
			break;
		case TypeCode.Double:
			WriteDouble((double)value);
			break;
		default:
			throw new NotSupportedException(value.GetType().FullName);
		}
	}

	private void WriteCustomAttributeEnumValue(TypeReference enum_type, object value)
	{
		TypeDefinition typeDefinition = enum_type.CheckedResolve();
		if (!typeDefinition.IsEnum)
		{
			throw new ArgumentException();
		}
		WriteCustomAttributeValue(typeDefinition.GetEnumUnderlyingType(), value);
	}

	private void WriteCustomAttributeFieldOrPropType(TypeReference type)
	{
		if (type.IsArray)
		{
			ArrayType arrayType = (ArrayType)type;
			WriteElementType(ElementType.SzArray);
			WriteCustomAttributeFieldOrPropType(arrayType.ElementType);
			return;
		}
		ElementType etype = type.etype;
		switch (etype)
		{
		case ElementType.Object:
			WriteElementType(ElementType.Boxed);
			break;
		case ElementType.None:
			if (type.IsTypeOf("System", "Type"))
			{
				WriteElementType(ElementType.Type);
				break;
			}
			WriteElementType(ElementType.Enum);
			WriteTypeReference(type);
			break;
		default:
			WriteElementType(etype);
			break;
		}
	}

	public void WriteCustomAttributeNamedArguments(CustomAttribute attribute)
	{
		int namedArgumentCount = GetNamedArgumentCount(attribute);
		WriteUInt16((ushort)namedArgumentCount);
		if (namedArgumentCount != 0)
		{
			WriteICustomAttributeNamedArguments(attribute);
		}
	}

	private static int GetNamedArgumentCount(ICustomAttribute attribute)
	{
		int num = 0;
		if (attribute.HasFields)
		{
			num += attribute.Fields.Count;
		}
		if (attribute.HasProperties)
		{
			num += attribute.Properties.Count;
		}
		return num;
	}

	private void WriteICustomAttributeNamedArguments(ICustomAttribute attribute)
	{
		if (attribute.HasFields)
		{
			WriteCustomAttributeNamedArguments(83, attribute.Fields);
		}
		if (attribute.HasProperties)
		{
			WriteCustomAttributeNamedArguments(84, attribute.Properties);
		}
	}

	private void WriteCustomAttributeNamedArguments(byte kind, Collection<CustomAttributeNamedArgument> named_arguments)
	{
		for (int i = 0; i < named_arguments.Count; i++)
		{
			WriteCustomAttributeNamedArgument(kind, named_arguments[i]);
		}
	}

	private void WriteCustomAttributeNamedArgument(byte kind, CustomAttributeNamedArgument named_argument)
	{
		CustomAttributeArgument argument = named_argument.Argument;
		WriteByte(kind);
		WriteCustomAttributeFieldOrPropType(argument.Type);
		WriteUTF8String(named_argument.Name);
		WriteCustomAttributeFixedArgument(argument.Type, argument);
	}

	private void WriteSecurityAttribute(SecurityAttribute attribute)
	{
		WriteTypeReference(attribute.AttributeType);
		int namedArgumentCount = GetNamedArgumentCount(attribute);
		if (namedArgumentCount == 0)
		{
			WriteCompressedUInt32(1u);
			WriteCompressedUInt32(0u);
			return;
		}
		SignatureWriter signatureWriter = new SignatureWriter(metadata);
		signatureWriter.WriteCompressedUInt32((uint)namedArgumentCount);
		signatureWriter.WriteICustomAttributeNamedArguments(attribute);
		WriteCompressedUInt32((uint)signatureWriter.length);
		WriteBytes(signatureWriter);
	}

	public void WriteSecurityDeclaration(SecurityDeclaration declaration)
	{
		WriteByte(46);
		Collection<SecurityAttribute> security_attributes = declaration.security_attributes;
		if (security_attributes == null)
		{
			throw new NotSupportedException();
		}
		WriteCompressedUInt32((uint)security_attributes.Count);
		for (int i = 0; i < security_attributes.Count; i++)
		{
			WriteSecurityAttribute(security_attributes[i]);
		}
	}

	public void WriteXmlSecurityDeclaration(SecurityDeclaration declaration)
	{
		string xmlSecurityDeclaration = GetXmlSecurityDeclaration(declaration);
		if (xmlSecurityDeclaration == null)
		{
			throw new NotSupportedException();
		}
		WriteBytes(Encoding.Unicode.GetBytes(xmlSecurityDeclaration));
	}

	private static string GetXmlSecurityDeclaration(SecurityDeclaration declaration)
	{
		if (declaration.security_attributes == null || declaration.security_attributes.Count != 1)
		{
			return null;
		}
		SecurityAttribute securityAttribute = declaration.security_attributes[0];
		if (!securityAttribute.AttributeType.IsTypeOf("System.Security.Permissions", "PermissionSetAttribute"))
		{
			return null;
		}
		if (securityAttribute.properties == null || securityAttribute.properties.Count != 1)
		{
			return null;
		}
		CustomAttributeNamedArgument customAttributeNamedArgument = securityAttribute.properties[0];
		if (customAttributeNamedArgument.Name != "XML")
		{
			return null;
		}
		return (string)customAttributeNamedArgument.Argument.Value;
	}

	private void WriteTypeReference(TypeReference type)
	{
		WriteUTF8String(TypeParser.ToParseable(type));
	}

	public void WriteMarshalInfo(MarshalInfo marshal_info)
	{
		WriteNativeType(marshal_info.native);
		switch (marshal_info.native)
		{
		case NativeType.Array:
		{
			ArrayMarshalInfo arrayMarshalInfo = (ArrayMarshalInfo)marshal_info;
			if (arrayMarshalInfo.element_type != NativeType.None)
			{
				WriteNativeType(arrayMarshalInfo.element_type);
			}
			if (arrayMarshalInfo.size_parameter_index > -1)
			{
				WriteCompressedUInt32((uint)arrayMarshalInfo.size_parameter_index);
			}
			if (arrayMarshalInfo.size > -1)
			{
				WriteCompressedUInt32((uint)arrayMarshalInfo.size);
			}
			if (arrayMarshalInfo.size_parameter_multiplier > -1)
			{
				WriteCompressedUInt32((uint)arrayMarshalInfo.size_parameter_multiplier);
			}
			break;
		}
		case NativeType.SafeArray:
		{
			SafeArrayMarshalInfo safeArrayMarshalInfo = (SafeArrayMarshalInfo)marshal_info;
			if (safeArrayMarshalInfo.element_type != 0)
			{
				WriteVariantType(safeArrayMarshalInfo.element_type);
			}
			break;
		}
		case NativeType.FixedArray:
		{
			FixedArrayMarshalInfo fixedArrayMarshalInfo = (FixedArrayMarshalInfo)marshal_info;
			if (fixedArrayMarshalInfo.size > -1)
			{
				WriteCompressedUInt32((uint)fixedArrayMarshalInfo.size);
			}
			if (fixedArrayMarshalInfo.element_type != NativeType.None)
			{
				WriteNativeType(fixedArrayMarshalInfo.element_type);
			}
			break;
		}
		case NativeType.FixedSysString:
		{
			FixedSysStringMarshalInfo fixedSysStringMarshalInfo = (FixedSysStringMarshalInfo)marshal_info;
			if (fixedSysStringMarshalInfo.size > -1)
			{
				WriteCompressedUInt32((uint)fixedSysStringMarshalInfo.size);
			}
			break;
		}
		case NativeType.CustomMarshaler:
		{
			CustomMarshalInfo customMarshalInfo = (CustomMarshalInfo)marshal_info;
			WriteUTF8String((customMarshalInfo.guid != Guid.Empty) ? customMarshalInfo.guid.ToString() : string.Empty);
			WriteUTF8String(customMarshalInfo.unmanaged_type);
			WriteTypeReference(customMarshalInfo.managed_type);
			WriteUTF8String(customMarshalInfo.cookie);
			break;
		}
		}
	}

	private void WriteNativeType(NativeType native)
	{
		WriteByte((byte)native);
	}

	private void WriteVariantType(VariantType variant)
	{
		WriteByte((byte)variant);
	}
}


using Mono.Cecil;

public delegate AssemblyDefinition AssemblyResolveEventHandler(object sender, AssemblyNameReference reference);


using System;
using Mono.Cecil;

public sealed class AssemblyResolveEventArgs : EventArgs
{
	private readonly AssemblyNameReference reference;

	public AssemblyNameReference AssemblyReference => reference;

	public AssemblyResolveEventArgs(AssemblyNameReference reference)
	{
		this.reference = reference;
	}
}


using System;
using System.IO;
using System.Runtime.Serialization;
using Mono.Cecil;

[Serializable]
public class AssemblyResolutionException : FileNotFoundException
{
	private readonly AssemblyNameReference reference;

	public AssemblyNameReference AssemblyReference => reference;

	public AssemblyResolutionException(AssemblyNameReference reference)
		: base($"Failed to resolve assembly: '{reference}'")
	{
		this.reference = reference;
	}

	protected AssemblyResolutionException(SerializationInfo info, StreamingContext context)
		: base(info, context)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Mono;
using Mono.Cecil;
using Mono.Collections.Generic;

public abstract class BaseAssemblyResolver : IAssemblyResolver
{
	private static readonly bool on_mono = Type.GetType("Mono.Runtime") != null;

	private readonly Collection<string> directories;

	private Collection<string> gac_paths;

	public event AssemblyResolveEventHandler ResolveFailure;

	public void AddSearchDirectory(string directory)
	{
		directories.Add(directory);
	}

	public void RemoveSearchDirectory(string directory)
	{
		directories.Remove(directory);
	}

	public string[] GetSearchDirectories()
	{
		string[] array = new string[directories.size];
		Array.Copy(directories.items, array, array.Length);
		return array;
	}

	public virtual AssemblyDefinition Resolve(string fullName)
	{
		return Resolve(fullName, new ReaderParameters());
	}

	public virtual AssemblyDefinition Resolve(string fullName, ReaderParameters parameters)
	{
		if (fullName == null)
		{
			throw new ArgumentNullException("fullName");
		}
		return Resolve(AssemblyNameReference.Parse(fullName), parameters);
	}

	protected BaseAssemblyResolver()
	{
		directories = new Collection<string>(2) { ".", "bin" };
	}

	private AssemblyDefinition GetAssembly(string file, ReaderParameters parameters)
	{
		if (parameters.AssemblyResolver == null)
		{
			parameters.AssemblyResolver = this;
		}
		return ModuleDefinition.ReadModule(file, parameters).Assembly;
	}

	public virtual AssemblyDefinition Resolve(AssemblyNameReference name)
	{
		return Resolve(name, new ReaderParameters());
	}

	public virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters)
	{
		if (name == null)
		{
			throw new ArgumentNullException("name");
		}
		if (parameters == null)
		{
			parameters = new ReaderParameters();
		}
		AssemblyDefinition assemblyDefinition = SearchDirectory(name, directories, parameters);
		if (assemblyDefinition != null)
		{
			return assemblyDefinition;
		}
		if (name.IsRetargetable)
		{
			name = new AssemblyNameReference(name.Name, new Version(0, 0, 0, 0))
			{
				PublicKeyToken = Empty<byte>.Array
			};
		}
		string directoryName = Path.GetDirectoryName(typeof(object).Module.FullyQualifiedName);
		if (IsZero(name.Version))
		{
			assemblyDefinition = SearchDirectory(name, new string[1] { directoryName }, parameters);
			if (assemblyDefinition != null)
			{
				return assemblyDefinition;
			}
		}
		if (name.Name == "mscorlib")
		{
			assemblyDefinition = GetCorlib(name, parameters);
			if (assemblyDefinition != null)
			{
				return assemblyDefinition;
			}
		}
		assemblyDefinition = GetAssemblyInGac(name, parameters);
		if (assemblyDefinition != null)
		{
			return assemblyDefinition;
		}
		assemblyDefinition = SearchDirectory(name, new string[1] { directoryName }, parameters);
		if (assemblyDefinition != null)
		{
			return assemblyDefinition;
		}
		if (this.ResolveFailure != null)
		{
			assemblyDefinition = this.ResolveFailure(this, name);
			if (assemblyDefinition != null)
			{
				return assemblyDefinition;
			}
		}
		throw new AssemblyResolutionException(name);
	}

	private AssemblyDefinition SearchDirectory(AssemblyNameReference name, IEnumerable<string> directories, ReaderParameters parameters)
	{
		string[] array = new string[2] { ".exe", ".dll" };
		foreach (string directory in directories)
		{
			string[] array2 = array;
			foreach (string text in array2)
			{
				string text2 = Path.Combine(directory, name.Name + text);
				if (File.Exists(text2))
				{
					return GetAssembly(text2, parameters);
				}
			}
		}
		return null;
	}

	private static bool IsZero(Version version)
	{
		if (!(version == null))
		{
			if (version.Major == 0 && version.Minor == 0 && version.Build == 0)
			{
				return version.Revision == 0;
			}
			return false;
		}
		return true;
	}

	private AssemblyDefinition GetCorlib(AssemblyNameReference reference, ReaderParameters parameters)
	{
		Version version = reference.Version;
		if (typeof(object).Assembly.GetName().Version == version || IsZero(version))
		{
			return GetAssembly(typeof(object).Module.FullyQualifiedName, parameters);
		}
		string fullName = Directory.GetParent(Directory.GetParent(typeof(object).Module.FullyQualifiedName).FullName).FullName;
		if (!on_mono)
		{
			fullName = version.Major switch
			{
				1 => (version.MajorRevision != 3300) ? Path.Combine(fullName, "v1.0.5000.0") : Path.Combine(fullName, "v1.0.3705"), 
				2 => Path.Combine(fullName, "v2.0.50727"), 
				4 => Path.Combine(fullName, "v4.0.30319"), 
				_ => throw new NotSupportedException("Version not supported: " + version), 
			};
		}
		else if (version.Major == 1)
		{
			fullName = Path.Combine(fullName, "1.0");
		}
		else if (version.Major == 2)
		{
			fullName = ((version.MajorRevision != 5) ? Path.Combine(fullName, "2.0") : Path.Combine(fullName, "2.1"));
		}
		else
		{
			if (version.Major != 4)
			{
				throw new NotSupportedException("Version not supported: " + version);
			}
			fullName = Path.Combine(fullName, "4.0");
		}
		string text = Path.Combine(fullName, "mscorlib.dll");
		if (File.Exists(text))
		{
			return GetAssembly(text, parameters);
		}
		return null;
	}

	private static Collection<string> GetGacPaths()
	{
		if (on_mono)
		{
			return GetDefaultMonoGacPaths();
		}
		Collection<string> collection = new Collection<string>(2);
		string environmentVariable = Environment.GetEnvironmentVariable("WINDIR");
		if (environmentVariable == null)
		{
			return collection;
		}
		collection.Add(Path.Combine(environmentVariable, "assembly"));
		collection.Add(Path.Combine(environmentVariable, Path.Combine("Microsoft.NET", "assembly")));
		return collection;
	}

	private static Collection<string> GetDefaultMonoGacPaths()
	{
		Collection<string> collection = new Collection<string>(1);
		string currentMonoGac = GetCurrentMonoGac();
		if (currentMonoGac != null)
		{
			collection.Add(currentMonoGac);
		}
		string environmentVariable = Environment.GetEnvironmentVariable("MONO_GAC_PREFIX");
		if (string.IsNullOrEmpty(environmentVariable))
		{
			return collection;
		}
		string[] array = environmentVariable.Split(new char[1] { Path.PathSeparator });
		foreach (string text in array)
		{
			if (!string.IsNullOrEmpty(text))
			{
				string text2 = Path.Combine(Path.Combine(Path.Combine(text, "lib"), "mono"), "gac");
				if (Directory.Exists(text2) && !collection.Contains(currentMonoGac))
				{
					collection.Add(text2);
				}
			}
		}
		return collection;
	}

	private static string GetCurrentMonoGac()
	{
		return Path.Combine(Directory.GetParent(Path.GetDirectoryName(typeof(object).Module.FullyQualifiedName)).FullName, "gac");
	}

	private AssemblyDefinition GetAssemblyInGac(AssemblyNameReference reference, ReaderParameters parameters)
	{
		if (reference.PublicKeyToken == null || reference.PublicKeyToken.Length == 0)
		{
			return null;
		}
		if (gac_paths == null)
		{
			gac_paths = GetGacPaths();
		}
		if (on_mono)
		{
			return GetAssemblyInMonoGac(reference, parameters);
		}
		return GetAssemblyInNetGac(reference, parameters);
	}

	private AssemblyDefinition GetAssemblyInMonoGac(AssemblyNameReference reference, ReaderParameters parameters)
	{
		for (int i = 0; i < gac_paths.Count; i++)
		{
			string gac = gac_paths[i];
			string assemblyFile = GetAssemblyFile(reference, string.Empty, gac);
			if (File.Exists(assemblyFile))
			{
				return GetAssembly(assemblyFile, parameters);
			}
		}
		return null;
	}

	private AssemblyDefinition GetAssemblyInNetGac(AssemblyNameReference reference, ReaderParameters parameters)
	{
		string[] array = new string[4] { "GAC_MSIL", "GAC_32", "GAC_64", "GAC" };
		string[] array2 = new string[2]
		{
			string.Empty,
			"v4.0_"
		};
		for (int i = 0; i < 2; i++)
		{
			for (int j = 0; j < array.Length; j++)
			{
				string text = Path.Combine(gac_paths[i], array[j]);
				string assemblyFile = GetAssemblyFile(reference, array2[i], text);
				if (Directory.Exists(text) && File.Exists(assemblyFile))
				{
					return GetAssembly(assemblyFile, parameters);
				}
			}
		}
		return null;
	}

	private static string GetAssemblyFile(AssemblyNameReference reference, string prefix, string gac)
	{
		StringBuilder stringBuilder = new StringBuilder().Append(prefix).Append(reference.Version).Append("__");
		for (int i = 0; i < reference.PublicKeyToken.Length; i++)
		{
			stringBuilder.Append(reference.PublicKeyToken[i].ToString("x2"));
		}
		return Path.Combine(Path.Combine(Path.Combine(gac, reference.Name), stringBuilder.ToString()), reference.Name + ".dll");
	}
}


using System;
using System.Text;
using Mono.Cecil;
using Mono.Collections.Generic;

public sealed class CallSite : IMethodSignature, IMetadataTokenProvider
{
	private readonly MethodReference signature;

	public bool HasThis
	{
		get
		{
			return signature.HasThis;
		}
		set
		{
			signature.HasThis = value;
		}
	}

	public bool ExplicitThis
	{
		get
		{
			return signature.ExplicitThis;
		}
		set
		{
			signature.ExplicitThis = value;
		}
	}

	public MethodCallingConvention CallingConvention
	{
		get
		{
			return signature.CallingConvention;
		}
		set
		{
			signature.CallingConvention = value;
		}
	}

	public bool HasParameters => signature.HasParameters;

	public Collection<ParameterDefinition> Parameters => signature.Parameters;

	public TypeReference ReturnType
	{
		get
		{
			return signature.MethodReturnType.ReturnType;
		}
		set
		{
			signature.MethodReturnType.ReturnType = value;
		}
	}

	public MethodReturnType MethodReturnType => signature.MethodReturnType;

	public string Name
	{
		get
		{
			return string.Empty;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public string Namespace
	{
		get
		{
			return string.Empty;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public ModuleDefinition Module => ReturnType.Module;

	public IMetadataScope Scope => signature.ReturnType.Scope;

	public MetadataToken MetadataToken
	{
		get
		{
			return signature.token;
		}
		set
		{
			signature.token = value;
		}
	}

	public string FullName
	{
		get
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(ReturnType.FullName);
			this.MethodSignatureFullName(stringBuilder);
			return stringBuilder.ToString();
		}
	}

	internal CallSite()
	{
		signature = new MethodReference();
		signature.token = new MetadataToken(TokenType.Signature, 0);
	}

	public CallSite(TypeReference returnType)
		: this()
	{
		if (returnType == null)
		{
			throw new ArgumentNullException("returnType");
		}
		signature.ReturnType = returnType;
	}

	public override string ToString()
	{
		return FullName;
	}
}


using System;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

internal class TypeParser
{
	private class Type
	{
		public const int Ptr = -1;

		public const int ByRef = -2;

		public const int SzArray = -3;

		public string type_fullname;

		public string[] nested_names;

		public int arity;

		public int[] specs;

		public Type[] generic_arguments;

		public string assembly;
	}

	private readonly string fullname;

	private readonly int length;

	private int position;

	private TypeParser(string fullname)
	{
		this.fullname = fullname;
		length = fullname.Length;
	}

	private Type ParseType(bool fq_name)
	{
		Type type = new Type();
		type.type_fullname = ParsePart();
		type.nested_names = ParseNestedNames();
		if (TryGetArity(type))
		{
			type.generic_arguments = ParseGenericArguments(type.arity);
		}
		type.specs = ParseSpecs();
		if (fq_name)
		{
			type.assembly = ParseAssemblyName();
		}
		return type;
	}

	private static bool TryGetArity(Type type)
	{
		int arity = 0;
		TryAddArity(type.type_fullname, ref arity);
		string[] nested_names = type.nested_names;
		if (!nested_names.IsNullOrEmpty())
		{
			for (int i = 0; i < nested_names.Length; i++)
			{
				TryAddArity(nested_names[i], ref arity);
			}
		}
		type.arity = arity;
		return arity > 0;
	}

	private static bool TryGetArity(string name, out int arity)
	{
		arity = 0;
		int num = name.LastIndexOf('`');
		if (num == -1)
		{
			return false;
		}
		return ParseInt32(name.Substring(num + 1), out arity);
	}

	private static bool ParseInt32(string value, out int result)
	{
		return int.TryParse(value, out result);
	}

	private static void TryAddArity(string name, ref int arity)
	{
		if (TryGetArity(name, out var arity2))
		{
			arity += arity2;
		}
	}

	private string ParsePart()
	{
		StringBuilder stringBuilder = new StringBuilder();
		while (position < length && !IsDelimiter(fullname[position]))
		{
			if (fullname[position] == '\\')
			{
				position++;
			}
			stringBuilder.Append(fullname[position++]);
		}
		return stringBuilder.ToString();
	}

	private static bool IsDelimiter(char chr)
	{
		return "+,[]*&".IndexOf(chr) != -1;
	}

	private void TryParseWhiteSpace()
	{
		while (position < length && char.IsWhiteSpace(fullname[position]))
		{
			position++;
		}
	}

	private string[] ParseNestedNames()
	{
		string[] array = null;
		while (TryParse('+'))
		{
			Add(ref array, ParsePart());
		}
		return array;
	}

	private bool TryParse(char chr)
	{
		if (position < length && fullname[position] == chr)
		{
			position++;
			return true;
		}
		return false;
	}

	private static void Add<T>(ref T[] array, T item)
	{
		if (array == null)
		{
			array = new T[1] { item };
		}
		else
		{
			array = array.Resize(array.Length + 1);
			array[array.Length - 1] = item;
		}
	}

	private int[] ParseSpecs()
	{
		int[] array = null;
		while (position < length)
		{
			switch (fullname[position])
			{
			case '*':
				position++;
				Add(ref array, -1);
				break;
			case '&':
				position++;
				Add(ref array, -2);
				break;
			case '[':
				position++;
				switch (fullname[position])
				{
				case ']':
					position++;
					Add(ref array, -3);
					break;
				case '*':
					position++;
					Add(ref array, 1);
					break;
				default:
				{
					int num = 1;
					while (TryParse(','))
					{
						num++;
					}
					Add(ref array, num);
					TryParse(']');
					break;
				}
				}
				break;
			default:
				return array;
			}
		}
		return array;
	}

	private Type[] ParseGenericArguments(int arity)
	{
		Type[] array = null;
		if (position == length || fullname[position] != '[')
		{
			return array;
		}
		TryParse('[');
		for (int i = 0; i < arity; i++)
		{
			bool flag = TryParse('[');
			Add(ref array, ParseType(flag));
			if (flag)
			{
				TryParse(']');
			}
			TryParse(',');
			TryParseWhiteSpace();
		}
		TryParse(']');
		return array;
	}

	private string ParseAssemblyName()
	{
		if (!TryParse(','))
		{
			return string.Empty;
		}
		TryParseWhiteSpace();
		int num = position;
		while (position < length)
		{
			char c = fullname[position];
			if (c == '[' || c == ']')
			{
				break;
			}
			position++;
		}
		return fullname.Substring(num, position - num);
	}

	public static TypeReference ParseType(ModuleDefinition module, string fullname)
	{
		if (string.IsNullOrEmpty(fullname))
		{
			return null;
		}
		TypeParser typeParser = new TypeParser(fullname);
		return GetTypeReference(module, typeParser.ParseType(fq_name: true));
	}

	private static TypeReference GetTypeReference(ModuleDefinition module, Type type_info)
	{
		if (!TryGetDefinition(module, type_info, out var type))
		{
			type = CreateReference(type_info, module, GetMetadataScope(module, type_info));
		}
		return CreateSpecs(type, type_info);
	}

	private static TypeReference CreateSpecs(TypeReference type, Type type_info)
	{
		type = TryCreateGenericInstanceType(type, type_info);
		int[] specs = type_info.specs;
		if (specs.IsNullOrEmpty())
		{
			return type;
		}
		for (int i = 0; i < specs.Length; i++)
		{
			switch (specs[i])
			{
			case -1:
				type = new PointerType(type);
				continue;
			case -2:
				type = new ByReferenceType(type);
				continue;
			case -3:
				type = new ArrayType(type);
				continue;
			}
			ArrayType arrayType = new ArrayType(type);
			arrayType.Dimensions.Clear();
			for (int j = 0; j < specs[i]; j++)
			{
				arrayType.Dimensions.Add(default(ArrayDimension));
			}
			type = arrayType;
		}
		return type;
	}

	private static TypeReference TryCreateGenericInstanceType(TypeReference type, Type type_info)
	{
		Type[] generic_arguments = type_info.generic_arguments;
		if (generic_arguments.IsNullOrEmpty())
		{
			return type;
		}
		GenericInstanceType genericInstanceType = new GenericInstanceType(type);
		Collection<TypeReference> genericArguments = genericInstanceType.GenericArguments;
		for (int i = 0; i < generic_arguments.Length; i++)
		{
			genericArguments.Add(GetTypeReference(type.Module, generic_arguments[i]));
		}
		return genericInstanceType;
	}

	public static void SplitFullName(string fullname, out string @namespace, out string name)
	{
		int num = fullname.LastIndexOf('.');
		if (num == -1)
		{
			@namespace = string.Empty;
			name = fullname;
		}
		else
		{
			@namespace = fullname.Substring(0, num);
			name = fullname.Substring(num + 1);
		}
	}

	private static TypeReference CreateReference(Type type_info, ModuleDefinition module, IMetadataScope scope)
	{
		SplitFullName(type_info.type_fullname, out var @namespace, out var name);
		TypeReference typeReference = new TypeReference(@namespace, name, module, scope);
		MetadataSystem.TryProcessPrimitiveTypeReference(typeReference);
		AdjustGenericParameters(typeReference);
		string[] nested_names = type_info.nested_names;
		if (nested_names.IsNullOrEmpty())
		{
			return typeReference;
		}
		for (int i = 0; i < nested_names.Length; i++)
		{
			typeReference = new TypeReference(string.Empty, nested_names[i], module, null)
			{
				DeclaringType = typeReference
			};
			AdjustGenericParameters(typeReference);
		}
		return typeReference;
	}

	private static void AdjustGenericParameters(TypeReference type)
	{
		if (TryGetArity(type.Name, out var arity))
		{
			for (int i = 0; i < arity; i++)
			{
				type.GenericParameters.Add(new GenericParameter(type));
			}
		}
	}

	private static IMetadataScope GetMetadataScope(ModuleDefinition module, Type type_info)
	{
		if (string.IsNullOrEmpty(type_info.assembly))
		{
			return module.TypeSystem.Corlib;
		}
		return MatchReference(module, AssemblyNameReference.Parse(type_info.assembly));
	}

	private static AssemblyNameReference MatchReference(ModuleDefinition module, AssemblyNameReference pattern)
	{
		Collection<AssemblyNameReference> assemblyReferences = module.AssemblyReferences;
		for (int i = 0; i < assemblyReferences.Count; i++)
		{
			AssemblyNameReference assemblyNameReference = assemblyReferences[i];
			if (assemblyNameReference.FullName == pattern.FullName)
			{
				return assemblyNameReference;
			}
		}
		return pattern;
	}

	private static bool TryGetDefinition(ModuleDefinition module, Type type_info, out TypeReference type)
	{
		type = null;
		if (!TryCurrentModule(module, type_info))
		{
			return false;
		}
		TypeDefinition typeDefinition = module.GetType(type_info.type_fullname);
		if (typeDefinition == null)
		{
			return false;
		}
		string[] nested_names = type_info.nested_names;
		if (!nested_names.IsNullOrEmpty())
		{
			for (int i = 0; i < nested_names.Length; i++)
			{
				typeDefinition = typeDefinition.GetNestedType(nested_names[i]);
			}
		}
		type = typeDefinition;
		return true;
	}

	private static bool TryCurrentModule(ModuleDefinition module, Type type_info)
	{
		if (string.IsNullOrEmpty(type_info.assembly))
		{
			return true;
		}
		if (module.assembly != null && module.assembly.Name.FullName == type_info.assembly)
		{
			return true;
		}
		return false;
	}

	public static string ToParseable(TypeReference type)
	{
		if (type == null)
		{
			return null;
		}
		StringBuilder stringBuilder = new StringBuilder();
		AppendType(type, stringBuilder, fq_name: true, top_level: true);
		return stringBuilder.ToString();
	}

	private static void AppendNamePart(string part, StringBuilder name)
	{
		foreach (char c in part)
		{
			if (IsDelimiter(c))
			{
				name.Append('\\');
			}
			name.Append(c);
		}
	}

	private static void AppendType(TypeReference type, StringBuilder name, bool fq_name, bool top_level)
	{
		TypeReference declaringType = type.DeclaringType;
		if (declaringType != null)
		{
			AppendType(declaringType, name, fq_name: false, top_level);
			name.Append('+');
		}
		string @namespace = type.Namespace;
		if (!string.IsNullOrEmpty(@namespace))
		{
			AppendNamePart(@namespace, name);
			name.Append('.');
		}
		AppendNamePart(type.GetElementType().Name, name);
		if (fq_name)
		{
			if (type.IsTypeSpecification())
			{
				AppendTypeSpecification((TypeSpecification)type, name);
			}
			if (RequiresFullyQualifiedName(type, top_level))
			{
				name.Append(", ");
				name.Append(GetScopeFullName(type));
			}
		}
	}

	private static string GetScopeFullName(TypeReference type)
	{
		IMetadataScope scope = type.Scope;
		return scope.MetadataScopeType switch
		{
			MetadataScopeType.AssemblyNameReference => ((AssemblyNameReference)scope).FullName, 
			MetadataScopeType.ModuleDefinition => ((ModuleDefinition)scope).Assembly.Name.FullName, 
			_ => throw new ArgumentException(), 
		};
	}

	private static void AppendTypeSpecification(TypeSpecification type, StringBuilder name)
	{
		if (type.ElementType.IsTypeSpecification())
		{
			AppendTypeSpecification((TypeSpecification)type.ElementType, name);
		}
		switch (type.etype)
		{
		case ElementType.Ptr:
			name.Append('*');
			break;
		case ElementType.ByRef:
			name.Append('&');
			break;
		case ElementType.Array:
		case ElementType.SzArray:
		{
			ArrayType arrayType = (ArrayType)type;
			if (arrayType.IsVector)
			{
				name.Append("[]");
				break;
			}
			name.Append('[');
			for (int j = 1; j < arrayType.Rank; j++)
			{
				name.Append(',');
			}
			name.Append(']');
			break;
		}
		case ElementType.GenericInst:
		{
			Collection<TypeReference> genericArguments = ((GenericInstanceType)type).GenericArguments;
			name.Append('[');
			for (int i = 0; i < genericArguments.Count; i++)
			{
				if (i > 0)
				{
					name.Append(',');
				}
				TypeReference typeReference = genericArguments[i];
				bool num = typeReference.Scope != typeReference.Module;
				if (num)
				{
					name.Append('[');
				}
				AppendType(typeReference, name, fq_name: true, top_level: false);
				if (num)
				{
					name.Append(']');
				}
			}
			name.Append(']');
			break;
		}
		}
	}

	private static bool RequiresFullyQualifiedName(TypeReference type, bool top_level)
	{
		if (type.Scope == type.Module)
		{
			return false;
		}
		if (type.Scope.Name == "mscorlib" && top_level)
		{
			return false;
		}
		return true;
	}
}


private class Type
{
	public const int Ptr = -1;

	public const int ByRef = -2;

	public const int SzArray = -3;

	public string type_fullname;

	public string[] nested_names;

	public int arity;

	public int[] specs;

	public Type[] generic_arguments;

	public string assembly;
}


internal enum ImportGenericKind
{
	Definition,
	Open
}


using System;
using Mono.Cecil;
using Mono.Collections.Generic;

internal struct ImportGenericContext
{
	private Collection<IGenericParameterProvider> stack;

	public bool IsEmpty => stack == null;

	public ImportGenericContext(IGenericParameterProvider provider)
	{
		stack = null;
		Push(provider);
	}

	public void Push(IGenericParameterProvider provider)
	{
		if (stack == null)
		{
			stack = new Collection<IGenericParameterProvider>(1) { provider };
		}
		else
		{
			stack.Add(provider);
		}
	}

	public void Pop()
	{
		stack.RemoveAt(stack.Count - 1);
	}

	public TypeReference MethodParameter(string method, int position)
	{
		for (int num = stack.Count - 1; num >= 0; num--)
		{
			if (stack[num] is MethodReference methodReference && !(method != NormalizeMethodName(methodReference)))
			{
				return methodReference.GenericParameters[position];
			}
		}
		throw new InvalidOperationException();
	}

	public string NormalizeMethodName(MethodReference method)
	{
		return method.DeclaringType.GetElementType().FullName + "." + method.Name;
	}

	public TypeReference TypeParameter(string type, int position)
	{
		for (int num = stack.Count - 1; num >= 0; num--)
		{
			TypeReference typeReference = GenericTypeFor(stack[num]);
			if (!(typeReference.FullName != type))
			{
				return typeReference.GenericParameters[position];
			}
		}
		throw new InvalidOperationException();
	}

	private static TypeReference GenericTypeFor(IGenericParameterProvider context)
	{
		if (context is TypeReference typeReference)
		{
			return typeReference.GetElementType();
		}
		if (context is MethodReference methodReference)
		{
			return methodReference.DeclaringType.GetElementType();
		}
		throw new InvalidOperationException();
	}
}


using System;
using System.Collections.Generic;
using System.Reflection;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

internal class MetadataImporter
{
	private readonly ModuleDefinition module;

	private static readonly Dictionary<Type, ElementType> type_etype_mapping = new Dictionary<Type, ElementType>(18)
	{
		{
			typeof(void),
			ElementType.Void
		},
		{
			typeof(bool),
			ElementType.Boolean
		},
		{
			typeof(char),
			ElementType.Char
		},
		{
			typeof(sbyte),
			ElementType.I1
		},
		{
			typeof(byte),
			ElementType.U1
		},
		{
			typeof(short),
			ElementType.I2
		},
		{
			typeof(ushort),
			ElementType.U2
		},
		{
			typeof(int),
			ElementType.I4
		},
		{
			typeof(uint),
			ElementType.U4
		},
		{
			typeof(long),
			ElementType.I8
		},
		{
			typeof(ulong),
			ElementType.U8
		},
		{
			typeof(float),
			ElementType.R4
		},
		{
			typeof(double),
			ElementType.R8
		},
		{
			typeof(string),
			ElementType.String
		},
		{
			typeof(TypedReference),
			ElementType.TypedByRef
		},
		{
			typeof(IntPtr),
			ElementType.I
		},
		{
			typeof(UIntPtr),
			ElementType.U
		},
		{
			typeof(object),
			ElementType.Object
		}
	};

	public MetadataImporter(ModuleDefinition module)
	{
		this.module = module;
	}

	public TypeReference ImportType(Type type, ImportGenericContext context)
	{
		return ImportType(type, context, ImportGenericKind.Open);
	}

	public TypeReference ImportType(Type type, ImportGenericContext context, ImportGenericKind import_kind)
	{
		if (IsTypeSpecification(type) || ImportOpenGenericType(type, import_kind))
		{
			return ImportTypeSpecification(type, context);
		}
		TypeReference typeReference = new TypeReference(string.Empty, type.Name, module, ImportScope(type.Assembly), type.IsValueType);
		typeReference.etype = ImportElementType(type);
		if (IsNestedType(type))
		{
			typeReference.DeclaringType = ImportType(type.DeclaringType, context, import_kind);
		}
		else
		{
			typeReference.Namespace = type.Namespace ?? string.Empty;
		}
		if (type.IsGenericType)
		{
			ImportGenericParameters(typeReference, type.GetGenericArguments());
		}
		return typeReference;
	}

	private static bool ImportOpenGenericType(Type type, ImportGenericKind import_kind)
	{
		if (type.IsGenericType && type.IsGenericTypeDefinition)
		{
			return import_kind == ImportGenericKind.Open;
		}
		return false;
	}

	private static bool ImportOpenGenericMethod(MethodBase method, ImportGenericKind import_kind)
	{
		if (method.IsGenericMethod && method.IsGenericMethodDefinition)
		{
			return import_kind == ImportGenericKind.Open;
		}
		return false;
	}

	private static bool IsNestedType(Type type)
	{
		return type.IsNested;
	}

	private TypeReference ImportTypeSpecification(Type type, ImportGenericContext context)
	{
		if (type.IsByRef)
		{
			return new ByReferenceType(ImportType(type.GetElementType(), context));
		}
		if (type.IsPointer)
		{
			return new PointerType(ImportType(type.GetElementType(), context));
		}
		if (type.IsArray)
		{
			return new ArrayType(ImportType(type.GetElementType(), context), type.GetArrayRank());
		}
		if (type.IsGenericType)
		{
			return ImportGenericInstance(type, context);
		}
		if (type.IsGenericParameter)
		{
			return ImportGenericParameter(type, context);
		}
		throw new NotSupportedException(type.FullName);
	}

	private static TypeReference ImportGenericParameter(Type type, ImportGenericContext context)
	{
		if (context.IsEmpty)
		{
			throw new InvalidOperationException();
		}
		if (type.DeclaringMethod != null)
		{
			return context.MethodParameter(NormalizeMethodName(type.DeclaringMethod), type.GenericParameterPosition);
		}
		if (type.DeclaringType != null)
		{
			return context.TypeParameter(NormalizeTypeFullName(type.DeclaringType), type.GenericParameterPosition);
		}
		throw new InvalidOperationException();
	}

	private static string NormalizeMethodName(MethodBase method)
	{
		return NormalizeTypeFullName(method.DeclaringType) + "." + method.Name;
	}

	private static string NormalizeTypeFullName(Type type)
	{
		if (IsNestedType(type))
		{
			return NormalizeTypeFullName(type.DeclaringType) + "/" + type.Name;
		}
		return type.FullName;
	}

	private TypeReference ImportGenericInstance(Type type, ImportGenericContext context)
	{
		TypeReference typeReference = ImportType(type.GetGenericTypeDefinition(), context, ImportGenericKind.Definition);
		GenericInstanceType genericInstanceType = new GenericInstanceType(typeReference);
		Type[] genericArguments = type.GetGenericArguments();
		Collection<TypeReference> genericArguments2 = genericInstanceType.GenericArguments;
		context.Push(typeReference);
		try
		{
			for (int i = 0; i < genericArguments.Length; i++)
			{
				genericArguments2.Add(ImportType(genericArguments[i], context));
			}
			return genericInstanceType;
		}
		finally
		{
			context.Pop();
		}
	}

	private static bool IsTypeSpecification(Type type)
	{
		if (!type.HasElementType && !IsGenericInstance(type))
		{
			return type.IsGenericParameter;
		}
		return true;
	}

	private static bool IsGenericInstance(Type type)
	{
		if (type.IsGenericType)
		{
			return !type.IsGenericTypeDefinition;
		}
		return false;
	}

	private static ElementType ImportElementType(Type type)
	{
		if (!type_etype_mapping.TryGetValue(type, out var value))
		{
			return ElementType.None;
		}
		return value;
	}

	private AssemblyNameReference ImportScope(Assembly assembly)
	{
		AssemblyName name = assembly.GetName();
		if (TryGetAssemblyNameReference(name, out var assembly_reference))
		{
			return assembly_reference;
		}
		assembly_reference = new AssemblyNameReference(name.Name, name.Version)
		{
			Culture = name.CultureInfo.Name,
			PublicKeyToken = name.GetPublicKeyToken(),
			HashAlgorithm = (AssemblyHashAlgorithm)name.HashAlgorithm
		};
		module.AssemblyReferences.Add(assembly_reference);
		return assembly_reference;
	}

	private bool TryGetAssemblyNameReference(AssemblyName name, out AssemblyNameReference assembly_reference)
	{
		Collection<AssemblyNameReference> assemblyReferences = module.AssemblyReferences;
		for (int i = 0; i < assemblyReferences.Count; i++)
		{
			AssemblyNameReference assemblyNameReference = assemblyReferences[i];
			if (!(name.FullName != assemblyNameReference.FullName))
			{
				assembly_reference = assemblyNameReference;
				return true;
			}
		}
		assembly_reference = null;
		return false;
	}

	public FieldReference ImportField(FieldInfo field, ImportGenericContext context)
	{
		TypeReference typeReference = ImportType(field.DeclaringType, context);
		if (IsGenericInstance(field.DeclaringType))
		{
			field = ResolveFieldDefinition(field);
		}
		context.Push(typeReference);
		try
		{
			return new FieldReference
			{
				Name = field.Name,
				DeclaringType = typeReference,
				FieldType = ImportType(field.FieldType, context)
			};
		}
		finally
		{
			context.Pop();
		}
	}

	private static FieldInfo ResolveFieldDefinition(FieldInfo field)
	{
		return field.Module.ResolveField(field.MetadataToken);
	}

	public MethodReference ImportMethod(MethodBase method, ImportGenericContext context, ImportGenericKind import_kind)
	{
		if (IsMethodSpecification(method) || ImportOpenGenericMethod(method, import_kind))
		{
			return ImportMethodSpecification(method, context);
		}
		TypeReference declaringType = ImportType(method.DeclaringType, context);
		if (IsGenericInstance(method.DeclaringType))
		{
			method = method.Module.ResolveMethod(method.MetadataToken);
		}
		MethodReference methodReference = new MethodReference
		{
			Name = method.Name,
			HasThis = HasCallingConvention(method, CallingConventions.HasThis),
			ExplicitThis = HasCallingConvention(method, CallingConventions.ExplicitThis),
			DeclaringType = ImportType(method.DeclaringType, context, ImportGenericKind.Definition)
		};
		if (HasCallingConvention(method, CallingConventions.VarArgs))
		{
			methodReference.CallingConvention &= MethodCallingConvention.VarArg;
		}
		if (method.IsGenericMethod)
		{
			ImportGenericParameters(methodReference, method.GetGenericArguments());
		}
		context.Push(methodReference);
		try
		{
			MethodInfo methodInfo = method as MethodInfo;
			methodReference.ReturnType = ((methodInfo != null) ? ImportType(methodInfo.ReturnType, context) : ImportType(typeof(void), default(ImportGenericContext)));
			ParameterInfo[] parameters = method.GetParameters();
			Collection<ParameterDefinition> parameters2 = methodReference.Parameters;
			for (int i = 0; i < parameters.Length; i++)
			{
				parameters2.Add(new ParameterDefinition(ImportType(parameters[i].ParameterType, context)));
			}
			methodReference.DeclaringType = declaringType;
			return methodReference;
		}
		finally
		{
			context.Pop();
		}
	}

	private static void ImportGenericParameters(IGenericParameterProvider provider, Type[] arguments)
	{
		Collection<GenericParameter> genericParameters = provider.GenericParameters;
		for (int i = 0; i < arguments.Length; i++)
		{
			genericParameters.Add(new GenericParameter(arguments[i].Name, provider));
		}
	}

	private static bool IsMethodSpecification(MethodBase method)
	{
		if (method.IsGenericMethod)
		{
			return !method.IsGenericMethodDefinition;
		}
		return false;
	}

	private MethodReference ImportMethodSpecification(MethodBase method, ImportGenericContext context)
	{
		MethodInfo methodInfo = method as MethodInfo;
		if (methodInfo == null)
		{
			throw new InvalidOperationException();
		}
		MethodReference methodReference = ImportMethod(methodInfo.GetGenericMethodDefinition(), context, ImportGenericKind.Definition);
		GenericInstanceMethod genericInstanceMethod = new GenericInstanceMethod(methodReference);
		Type[] genericArguments = method.GetGenericArguments();
		Collection<TypeReference> genericArguments2 = genericInstanceMethod.GenericArguments;
		context.Push(methodReference);
		try
		{
			for (int i = 0; i < genericArguments.Length; i++)
			{
				genericArguments2.Add(ImportType(genericArguments[i], context));
			}
			return genericInstanceMethod;
		}
		finally
		{
			context.Pop();
		}
	}

	private static bool HasCallingConvention(MethodBase method, CallingConventions conventions)
	{
		return (method.CallingConvention & conventions) != 0;
	}

	public TypeReference ImportType(TypeReference type, ImportGenericContext context)
	{
		if (type.IsTypeSpecification())
		{
			return ImportTypeSpecification(type, context);
		}
		TypeReference typeReference = new TypeReference(type.Namespace, type.Name, module, ImportScope(type.Scope), type.IsValueType);
		MetadataSystem.TryProcessPrimitiveTypeReference(typeReference);
		if (type.IsNested)
		{
			typeReference.DeclaringType = ImportType(type.DeclaringType, context);
		}
		if (type.HasGenericParameters)
		{
			ImportGenericParameters(typeReference, type);
		}
		return typeReference;
	}

	private IMetadataScope ImportScope(IMetadataScope scope)
	{
		switch (scope.MetadataScopeType)
		{
		case MetadataScopeType.AssemblyNameReference:
			return ImportAssemblyName((AssemblyNameReference)scope);
		case MetadataScopeType.ModuleDefinition:
			if (scope == module)
			{
				return scope;
			}
			return ImportAssemblyName(((ModuleDefinition)scope).Assembly.Name);
		case MetadataScopeType.ModuleReference:
			throw new NotImplementedException();
		default:
			throw new NotSupportedException();
		}
	}

	private AssemblyNameReference ImportAssemblyName(AssemblyNameReference name)
	{
		if (TryGetAssemblyNameReference(name, out var assembly_reference))
		{
			return assembly_reference;
		}
		assembly_reference = new AssemblyNameReference(name.Name, name.Version)
		{
			Culture = name.Culture,
			HashAlgorithm = name.HashAlgorithm,
			IsRetargetable = name.IsRetargetable
		};
		byte[] array = ((!name.PublicKeyToken.IsNullOrEmpty()) ? new byte[name.PublicKeyToken.Length] : Empty<byte>.Array);
		if (array.Length != 0)
		{
			Buffer.BlockCopy(name.PublicKeyToken, 0, array, 0, array.Length);
		}
		assembly_reference.PublicKeyToken = array;
		module.AssemblyReferences.Add(assembly_reference);
		return assembly_reference;
	}

	private bool TryGetAssemblyNameReference(AssemblyNameReference name_reference, out AssemblyNameReference assembly_reference)
	{
		Collection<AssemblyNameReference> assemblyReferences = module.AssemblyReferences;
		for (int i = 0; i < assemblyReferences.Count; i++)
		{
			AssemblyNameReference assemblyNameReference = assemblyReferences[i];
			if (!(name_reference.FullName != assemblyNameReference.FullName))
			{
				assembly_reference = assemblyNameReference;
				return true;
			}
		}
		assembly_reference = null;
		return false;
	}

	private static void ImportGenericParameters(IGenericParameterProvider imported, IGenericParameterProvider original)
	{
		Collection<GenericParameter> genericParameters = original.GenericParameters;
		Collection<GenericParameter> genericParameters2 = imported.GenericParameters;
		for (int i = 0; i < genericParameters.Count; i++)
		{
			genericParameters2.Add(new GenericParameter(genericParameters[i].Name, imported));
		}
	}

	private TypeReference ImportTypeSpecification(TypeReference type, ImportGenericContext context)
	{
		switch (type.etype)
		{
		case ElementType.SzArray:
		{
			ArrayType arrayType = (ArrayType)type;
			return new ArrayType(ImportType(arrayType.ElementType, context));
		}
		case ElementType.Ptr:
		{
			PointerType pointerType = (PointerType)type;
			return new PointerType(ImportType(pointerType.ElementType, context));
		}
		case ElementType.ByRef:
		{
			ByReferenceType byReferenceType = (ByReferenceType)type;
			return new ByReferenceType(ImportType(byReferenceType.ElementType, context));
		}
		case ElementType.Pinned:
		{
			PinnedType pinnedType = (PinnedType)type;
			return new PinnedType(ImportType(pinnedType.ElementType, context));
		}
		case ElementType.Sentinel:
		{
			SentinelType sentinelType = (SentinelType)type;
			return new SentinelType(ImportType(sentinelType.ElementType, context));
		}
		case ElementType.CModOpt:
		{
			OptionalModifierType optionalModifierType = (OptionalModifierType)type;
			return new OptionalModifierType(ImportType(optionalModifierType.ModifierType, context), ImportType(optionalModifierType.ElementType, context));
		}
		case ElementType.CModReqD:
		{
			RequiredModifierType requiredModifierType = (RequiredModifierType)type;
			return new RequiredModifierType(ImportType(requiredModifierType.ModifierType, context), ImportType(requiredModifierType.ElementType, context));
		}
		case ElementType.Array:
		{
			ArrayType arrayType2 = (ArrayType)type;
			ArrayType arrayType3 = new ArrayType(ImportType(arrayType2.ElementType, context));
			if (arrayType2.IsVector)
			{
				return arrayType3;
			}
			Collection<ArrayDimension> dimensions = arrayType2.Dimensions;
			Collection<ArrayDimension> dimensions2 = arrayType3.Dimensions;
			dimensions2.Clear();
			for (int j = 0; j < dimensions.Count; j++)
			{
				ArrayDimension arrayDimension = dimensions[j];
				dimensions2.Add(new ArrayDimension(arrayDimension.LowerBound, arrayDimension.UpperBound));
			}
			return arrayType3;
		}
		case ElementType.GenericInst:
		{
			GenericInstanceType genericInstanceType = (GenericInstanceType)type;
			GenericInstanceType genericInstanceType2 = new GenericInstanceType(ImportType(genericInstanceType.ElementType, context));
			Collection<TypeReference> genericArguments = genericInstanceType.GenericArguments;
			Collection<TypeReference> genericArguments2 = genericInstanceType2.GenericArguments;
			for (int i = 0; i < genericArguments.Count; i++)
			{
				genericArguments2.Add(ImportType(genericArguments[i], context));
			}
			return genericInstanceType2;
		}
		case ElementType.Var:
		{
			GenericParameter genericParameter2 = (GenericParameter)type;
			if (genericParameter2.DeclaringType == null)
			{
				throw new InvalidOperationException();
			}
			return context.TypeParameter(genericParameter2.DeclaringType.FullName, genericParameter2.Position);
		}
		case ElementType.MVar:
		{
			GenericParameter genericParameter = (GenericParameter)type;
			if (genericParameter.DeclaringMethod == null)
			{
				throw new InvalidOperationException();
			}
			return context.MethodParameter(context.NormalizeMethodName(genericParameter.DeclaringMethod), genericParameter.Position);
		}
		default:
			throw new NotSupportedException(type.etype.ToString());
		}
	}

	public FieldReference ImportField(FieldReference field, ImportGenericContext context)
	{
		TypeReference typeReference = ImportType(field.DeclaringType, context);
		context.Push(typeReference);
		try
		{
			return new FieldReference
			{
				Name = field.Name,
				DeclaringType = typeReference,
				FieldType = ImportType(field.FieldType, context)
			};
		}
		finally
		{
			context.Pop();
		}
	}

	public MethodReference ImportMethod(MethodReference method, ImportGenericContext context)
	{
		if (method.IsGenericInstance)
		{
			return ImportMethodSpecification(method, context);
		}
		TypeReference declaringType = ImportType(method.DeclaringType, context);
		MethodReference methodReference = new MethodReference
		{
			Name = method.Name,
			HasThis = method.HasThis,
			ExplicitThis = method.ExplicitThis,
			DeclaringType = declaringType,
			CallingConvention = method.CallingConvention
		};
		if (method.HasGenericParameters)
		{
			ImportGenericParameters(methodReference, method);
		}
		context.Push(methodReference);
		try
		{
			methodReference.ReturnType = ImportType(method.ReturnType, context);
			if (!method.HasParameters)
			{
				return methodReference;
			}
			Collection<ParameterDefinition> parameters = methodReference.Parameters;
			Collection<ParameterDefinition> parameters2 = method.Parameters;
			for (int i = 0; i < parameters2.Count; i++)
			{
				parameters.Add(new ParameterDefinition(ImportType(parameters2[i].ParameterType, context)));
			}
			return methodReference;
		}
		finally
		{
			context.Pop();
		}
	}

	private MethodSpecification ImportMethodSpecification(MethodReference method, ImportGenericContext context)
	{
		if (!method.IsGenericInstance)
		{
			throw new NotSupportedException();
		}
		GenericInstanceMethod genericInstanceMethod = (GenericInstanceMethod)method;
		GenericInstanceMethod genericInstanceMethod2 = new GenericInstanceMethod(ImportMethod(genericInstanceMethod.ElementMethod, context));
		Collection<TypeReference> genericArguments = genericInstanceMethod.GenericArguments;
		Collection<TypeReference> genericArguments2 = genericInstanceMethod2.GenericArguments;
		for (int i = 0; i < genericArguments.Count; i++)
		{
			genericArguments2.Add(ImportType(genericArguments[i], context));
		}
		return genericInstanceMethod2;
	}
}


using Mono.Cecil;

public class ExportedType : IMetadataTokenProvider
{
	private string @namespace;

	private string name;

	private uint attributes;

	private IMetadataScope scope;

	private ModuleDefinition module;

	private int identifier;

	private ExportedType declaring_type;

	internal MetadataToken token;

	public string Namespace
	{
		get
		{
			return @namespace;
		}
		set
		{
			@namespace = value;
		}
	}

	public string Name
	{
		get
		{
			return name;
		}
		set
		{
			name = value;
		}
	}

	public TypeAttributes Attributes
	{
		get
		{
			return (TypeAttributes)attributes;
		}
		set
		{
			attributes = (uint)value;
		}
	}

	public IMetadataScope Scope
	{
		get
		{
			if (declaring_type != null)
			{
				return declaring_type.Scope;
			}
			return scope;
		}
	}

	public ExportedType DeclaringType
	{
		get
		{
			return declaring_type;
		}
		set
		{
			declaring_type = value;
		}
	}

	public MetadataToken MetadataToken
	{
		get
		{
			return token;
		}
		set
		{
			token = value;
		}
	}

	public int Identifier
	{
		get
		{
			return identifier;
		}
		set
		{
			identifier = value;
		}
	}

	public bool IsNotPublic
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 0u, value);
		}
	}

	public bool IsPublic
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 1u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 1u, value);
		}
	}

	public bool IsNestedPublic
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 2u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 2u, value);
		}
	}

	public bool IsNestedPrivate
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 3u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 3u, value);
		}
	}

	public bool IsNestedFamily
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 4u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 4u, value);
		}
	}

	public bool IsNestedAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 5u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 5u, value);
		}
	}

	public bool IsNestedFamilyAndAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 6u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 6u, value);
		}
	}

	public bool IsNestedFamilyOrAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 7u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 7u, value);
		}
	}

	public bool IsAutoLayout
	{
		get
		{
			return attributes.GetMaskedAttributes(24u, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(24u, 0u, value);
		}
	}

	public bool IsSequentialLayout
	{
		get
		{
			return attributes.GetMaskedAttributes(24u, 8u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(24u, 8u, value);
		}
	}

	public bool IsExplicitLayout
	{
		get
		{
			return attributes.GetMaskedAttributes(24u, 16u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(24u, 16u, value);
		}
	}

	public bool IsClass
	{
		get
		{
			return attributes.GetMaskedAttributes(32u, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(32u, 0u, value);
		}
	}

	public bool IsInterface
	{
		get
		{
			return attributes.GetMaskedAttributes(32u, 32u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(32u, 32u, value);
		}
	}

	public bool IsAbstract
	{
		get
		{
			return attributes.GetAttributes(128u);
		}
		set
		{
			attributes = attributes.SetAttributes(128u, value);
		}
	}

	public bool IsSealed
	{
		get
		{
			return attributes.GetAttributes(256u);
		}
		set
		{
			attributes = attributes.SetAttributes(256u, value);
		}
	}

	public bool IsSpecialName
	{
		get
		{
			return attributes.GetAttributes(1024u);
		}
		set
		{
			attributes = attributes.SetAttributes(1024u, value);
		}
	}

	public bool IsImport
	{
		get
		{
			return attributes.GetAttributes(4096u);
		}
		set
		{
			attributes = attributes.SetAttributes(4096u, value);
		}
	}

	public bool IsSerializable
	{
		get
		{
			return attributes.GetAttributes(8192u);
		}
		set
		{
			attributes = attributes.SetAttributes(8192u, value);
		}
	}

	public bool IsAnsiClass
	{
		get
		{
			return attributes.GetMaskedAttributes(196608u, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(196608u, 0u, value);
		}
	}

	public bool IsUnicodeClass
	{
		get
		{
			return attributes.GetMaskedAttributes(196608u, 65536u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(196608u, 65536u, value);
		}
	}

	public bool IsAutoClass
	{
		get
		{
			return attributes.GetMaskedAttributes(196608u, 131072u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(196608u, 131072u, value);
		}
	}

	public bool IsBeforeFieldInit
	{
		get
		{
			return attributes.GetAttributes(1048576u);
		}
		set
		{
			attributes = attributes.SetAttributes(1048576u, value);
		}
	}

	public bool IsRuntimeSpecialName
	{
		get
		{
			return attributes.GetAttributes(2048u);
		}
		set
		{
			attributes = attributes.SetAttributes(2048u, value);
		}
	}

	public bool HasSecurity
	{
		get
		{
			return attributes.GetAttributes(262144u);
		}
		set
		{
			attributes = attributes.SetAttributes(262144u, value);
		}
	}

	public bool IsForwarder
	{
		get
		{
			return attributes.GetAttributes(2097152u);
		}
		set
		{
			attributes = attributes.SetAttributes(2097152u, value);
		}
	}

	public string FullName
	{
		get
		{
			string text = (string.IsNullOrEmpty(@namespace) ? name : (@namespace + "." + name));
			if (declaring_type != null)
			{
				return declaring_type.FullName + "/" + text;
			}
			return text;
		}
	}

	public ExportedType(string @namespace, string name, ModuleDefinition module, IMetadataScope scope)
	{
		this.@namespace = @namespace;
		this.name = name;
		this.scope = scope;
		this.module = module;
	}

	public override string ToString()
	{
		return FullName;
	}

	public TypeDefinition Resolve()
	{
		return module.Resolve(CreateReference());
	}

	internal TypeReference CreateReference()
	{
		return new TypeReference(@namespace, name, module, scope)
		{
			DeclaringType = ((declaring_type != null) ? declaring_type.CreateReference() : null)
		};
	}
}


public enum SecurityAction : ushort
{
	Request = 1,
	Demand,
	Assert,
	Deny,
	PermitOnly,
	LinkDemand,
	InheritDemand,
	RequestMinimum,
	RequestOptional,
	RequestRefuse,
	PreJitGrant,
	PreJitDeny,
	NonCasDemand,
	NonCasLinkDemand,
	NonCasInheritance
}


using Mono.Cecil;
using Mono.Collections.Generic;

public interface ISecurityDeclarationProvider : IMetadataTokenProvider
{
	bool HasSecurityDeclarations { get; }

	Collection<SecurityDeclaration> SecurityDeclarations { get; }
}


using Mono.Cecil;
using Mono.Collections.Generic;

public sealed class SecurityAttribute : ICustomAttribute
{
	private TypeReference attribute_type;

	internal Collection<CustomAttributeNamedArgument> fields;

	internal Collection<CustomAttributeNamedArgument> properties;

	public TypeReference AttributeType
	{
		get
		{
			return attribute_type;
		}
		set
		{
			attribute_type = value;
		}
	}

	public bool HasFields => !fields.IsNullOrEmpty();

	public Collection<CustomAttributeNamedArgument> Fields => fields ?? (fields = new Collection<CustomAttributeNamedArgument>());

	public bool HasProperties => !properties.IsNullOrEmpty();

	public Collection<CustomAttributeNamedArgument> Properties => properties ?? (properties = new Collection<CustomAttributeNamedArgument>());

	public SecurityAttribute(TypeReference attributeType)
	{
		attribute_type = attributeType;
	}
}


using System;
using Mono.Cecil;
using Mono.Collections.Generic;

public sealed class SecurityDeclaration
{
	internal readonly uint signature;

	private byte[] blob;

	private readonly ModuleDefinition module;

	internal bool resolved;

	private SecurityAction action;

	internal Collection<SecurityAttribute> security_attributes;

	public SecurityAction Action
	{
		get
		{
			return action;
		}
		set
		{
			action = value;
		}
	}

	public bool HasSecurityAttributes
	{
		get
		{
			Resolve();
			return !security_attributes.IsNullOrEmpty();
		}
	}

	public Collection<SecurityAttribute> SecurityAttributes
	{
		get
		{
			Resolve();
			return security_attributes ?? (security_attributes = new Collection<SecurityAttribute>());
		}
	}

	internal bool HasImage
	{
		get
		{
			if (module != null)
			{
				return module.HasImage;
			}
			return false;
		}
	}

	internal SecurityDeclaration(SecurityAction action, uint signature, ModuleDefinition module)
	{
		this.action = action;
		this.signature = signature;
		this.module = module;
	}

	public SecurityDeclaration(SecurityAction action)
	{
		this.action = action;
		resolved = true;
	}

	public SecurityDeclaration(SecurityAction action, byte[] blob)
	{
		this.action = action;
		resolved = false;
		this.blob = blob;
	}

	public byte[] GetBlob()
	{
		if (blob != null)
		{
			return blob;
		}
		if (!HasImage || signature == 0)
		{
			throw new NotSupportedException();
		}
		return blob = module.Read(this, (SecurityDeclaration declaration, MetadataReader reader) => reader.ReadSecurityDeclarationBlob(declaration.signature));
	}

	private void Resolve()
	{
		if (!resolved && HasImage)
		{
			module.Read(this, delegate(SecurityDeclaration declaration, MetadataReader reader)
			{
				reader.ReadSecurityDeclarationSignature(declaration);
				return this;
			});
			resolved = true;
		}
	}
}


using Mono.Cecil;

public struct CustomAttributeArgument
{
	private readonly TypeReference type;

	private readonly object value;

	public TypeReference Type => type;

	public object Value => value;

	public CustomAttributeArgument(TypeReference type, object value)
	{
		Mixin.CheckType(type);
		this.type = type;
		this.value = value;
	}
}


using Mono.Cecil;

public struct CustomAttributeNamedArgument
{
	private readonly string name;

	private readonly CustomAttributeArgument argument;

	public string Name => name;

	public CustomAttributeArgument Argument => argument;

	public CustomAttributeNamedArgument(string name, CustomAttributeArgument argument)
	{
		Mixin.CheckName(name);
		this.name = name;
		this.argument = argument;
	}
}


using Mono.Cecil;
using Mono.Collections.Generic;

public interface ICustomAttribute
{
	TypeReference AttributeType { get; }

	bool HasFields { get; }

	bool HasProperties { get; }

	Collection<CustomAttributeNamedArgument> Fields { get; }

	Collection<CustomAttributeNamedArgument> Properties { get; }
}


using System;
using Mono.Cecil;
using Mono.Collections.Generic;

public sealed class CustomAttribute : ICustomAttribute
{
	internal readonly uint signature;

	internal bool resolved;

	private MethodReference constructor;

	private byte[] blob;

	internal Collection<CustomAttributeArgument> arguments;

	internal Collection<CustomAttributeNamedArgument> fields;

	internal Collection<CustomAttributeNamedArgument> properties;

	public MethodReference Constructor
	{
		get
		{
			return constructor;
		}
		set
		{
			constructor = value;
		}
	}

	public TypeReference AttributeType => constructor.DeclaringType;

	public bool IsResolved => resolved;

	public bool HasConstructorArguments
	{
		get
		{
			Resolve();
			return !arguments.IsNullOrEmpty();
		}
	}

	public Collection<CustomAttributeArgument> ConstructorArguments
	{
		get
		{
			Resolve();
			return arguments ?? (arguments = new Collection<CustomAttributeArgument>());
		}
	}

	public bool HasFields
	{
		get
		{
			Resolve();
			return !fields.IsNullOrEmpty();
		}
	}

	public Collection<CustomAttributeNamedArgument> Fields
	{
		get
		{
			Resolve();
			return fields ?? (fields = new Collection<CustomAttributeNamedArgument>());
		}
	}

	public bool HasProperties
	{
		get
		{
			Resolve();
			return !properties.IsNullOrEmpty();
		}
	}

	public Collection<CustomAttributeNamedArgument> Properties
	{
		get
		{
			Resolve();
			return properties ?? (properties = new Collection<CustomAttributeNamedArgument>());
		}
	}

	internal bool HasImage
	{
		get
		{
			if (constructor != null)
			{
				return constructor.HasImage;
			}
			return false;
		}
	}

	internal ModuleDefinition Module => constructor.Module;

	internal CustomAttribute(uint signature, MethodReference constructor)
	{
		this.signature = signature;
		this.constructor = constructor;
		resolved = false;
	}

	public CustomAttribute(MethodReference constructor)
	{
		this.constructor = constructor;
		resolved = true;
	}

	public CustomAttribute(MethodReference constructor, byte[] blob)
	{
		this.constructor = constructor;
		resolved = false;
		this.blob = blob;
	}

	public byte[] GetBlob()
	{
		if (blob != null)
		{
			return blob;
		}
		if (!HasImage)
		{
			throw new NotSupportedException();
		}
		return Module.Read(ref blob, this, (CustomAttribute attribute, MetadataReader reader) => reader.ReadCustomAttributeBlob(attribute.signature));
	}

	private void Resolve()
	{
		if (resolved || !HasImage)
		{
			return;
		}
		Module.Read(this, delegate(CustomAttribute attribute, MetadataReader reader)
		{
			try
			{
				reader.ReadCustomAttributeSignature(attribute);
				resolved = true;
			}
			catch (ResolutionException)
			{
				if (arguments != null)
				{
					arguments.Clear();
				}
				if (fields != null)
				{
					fields.Clear();
				}
				if (properties != null)
				{
					properties.Clear();
				}
				resolved = false;
			}
			return this;
		});
	}
}


using System;
using System.Collections.Generic;
using Mono.Cecil;

public class DefaultAssemblyResolver : BaseAssemblyResolver
{
	private readonly IDictionary<string, AssemblyDefinition> cache;

	public DefaultAssemblyResolver()
	{
		cache = new Dictionary<string, AssemblyDefinition>(StringComparer.Ordinal);
	}

	public override AssemblyDefinition Resolve(AssemblyNameReference name)
	{
		if (name == null)
		{
			throw new ArgumentNullException("name");
		}
		if (cache.TryGetValue(name.FullName, out var value))
		{
			return value;
		}
		value = base.Resolve(name);
		cache[name.FullName] = value;
		return value;
	}

	protected void RegisterAssembly(AssemblyDefinition assembly)
	{
		if (assembly == null)
		{
			throw new ArgumentNullException("assembly");
		}
		string fullName = assembly.Name.FullName;
		if (!cache.ContainsKey(fullName))
		{
			cache[fullName] = assembly;
		}
	}
}


internal enum FileAttributes : uint
{
	ContainsMetaData,
	ContainsNoMetaData
}


using System;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

public sealed class FunctionPointerType : TypeSpecification, IMethodSignature, IMetadataTokenProvider
{
	private readonly MethodReference function;

	public bool HasThis
	{
		get
		{
			return function.HasThis;
		}
		set
		{
			function.HasThis = value;
		}
	}

	public bool ExplicitThis
	{
		get
		{
			return function.ExplicitThis;
		}
		set
		{
			function.ExplicitThis = value;
		}
	}

	public MethodCallingConvention CallingConvention
	{
		get
		{
			return function.CallingConvention;
		}
		set
		{
			function.CallingConvention = value;
		}
	}

	public bool HasParameters => function.HasParameters;

	public Collection<ParameterDefinition> Parameters => function.Parameters;

	public TypeReference ReturnType
	{
		get
		{
			return function.MethodReturnType.ReturnType;
		}
		set
		{
			function.MethodReturnType.ReturnType = value;
		}
	}

	public MethodReturnType MethodReturnType => function.MethodReturnType;

	public override string Name
	{
		get
		{
			return function.Name;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override string Namespace
	{
		get
		{
			return string.Empty;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override ModuleDefinition Module => ReturnType.Module;

	public override IMetadataScope Scope
	{
		get
		{
			return function.ReturnType.Scope;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override bool IsFunctionPointer => true;

	public override bool ContainsGenericParameter => function.ContainsGenericParameter;

	public override string FullName
	{
		get
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(function.Name);
			stringBuilder.Append(" ");
			stringBuilder.Append(function.ReturnType.FullName);
			stringBuilder.Append(" *");
			this.MethodSignatureFullName(stringBuilder);
			return stringBuilder.ToString();
		}
	}

	public FunctionPointerType()
		: base(null)
	{
		function = new MethodReference();
		function.Name = "method";
		etype = Mono.Cecil.Metadata.ElementType.FnPtr;
	}

	public override TypeDefinition Resolve()
	{
		return null;
	}

	public override TypeReference GetElementType()
	{
		return this;
	}
}


using System.Text;
using Mono.Cecil;
using Mono.Collections.Generic;

public sealed class GenericInstanceMethod : MethodSpecification, IGenericInstance, IMetadataTokenProvider, IGenericContext
{
	private Collection<TypeReference> arguments;

	public bool HasGenericArguments => !arguments.IsNullOrEmpty();

	public Collection<TypeReference> GenericArguments => arguments ?? (arguments = new Collection<TypeReference>());

	public override bool IsGenericInstance => true;

	IGenericParameterProvider IGenericContext.Method => base.ElementMethod;

	IGenericParameterProvider IGenericContext.Type => base.ElementMethod.DeclaringType;

	public override bool ContainsGenericParameter
	{
		get
		{
			if (!this.ContainsGenericParameter())
			{
				return base.ContainsGenericParameter;
			}
			return true;
		}
	}

	public override string FullName
	{
		get
		{
			StringBuilder stringBuilder = new StringBuilder();
			MethodReference elementMethod = base.ElementMethod;
			stringBuilder.Append(elementMethod.ReturnType.FullName).Append(" ").Append(elementMethod.DeclaringType.FullName)
				.Append("::")
				.Append(elementMethod.Name);
			this.GenericInstanceFullName(stringBuilder);
			this.MethodSignatureFullName(stringBuilder);
			return stringBuilder.ToString();
		}
	}

	public GenericInstanceMethod(MethodReference method)
		: base(method)
	{
	}
}


using System;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

public sealed class GenericInstanceType : TypeSpecification, IGenericInstance, IMetadataTokenProvider, IGenericContext
{
	private Collection<TypeReference> arguments;

	public bool HasGenericArguments => !arguments.IsNullOrEmpty();

	public Collection<TypeReference> GenericArguments => arguments ?? (arguments = new Collection<TypeReference>());

	public override TypeReference DeclaringType
	{
		get
		{
			return base.ElementType.DeclaringType;
		}
		set
		{
			throw new NotSupportedException();
		}
	}

	public override string FullName
	{
		get
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(base.FullName);
			this.GenericInstanceFullName(stringBuilder);
			return stringBuilder.ToString();
		}
	}

	public override bool IsGenericInstance => true;

	public override bool ContainsGenericParameter
	{
		get
		{
			if (!this.ContainsGenericParameter())
			{
				return base.ContainsGenericParameter;
			}
			return true;
		}
	}

	IGenericParameterProvider IGenericContext.Type => base.ElementType;

	public GenericInstanceType(TypeReference type)
		: base(type)
	{
		base.IsValueType = type.IsValueType;
		etype = Mono.Cecil.Metadata.ElementType.GenericInst;
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

public sealed class GenericParameter : TypeReference, ICustomAttributeProvider, IMetadataTokenProvider
{
	internal int position;

	internal GenericParameterType type;

	internal IGenericParameterProvider owner;

	private ushort attributes;

	private Collection<TypeReference> constraints;

	private Collection<CustomAttribute> custom_attributes;

	public GenericParameterAttributes Attributes
	{
		get
		{
			return (GenericParameterAttributes)attributes;
		}
		set
		{
			attributes = (ushort)value;
		}
	}

	public int Position => position;

	public GenericParameterType Type => type;

	public IGenericParameterProvider Owner => owner;

	public bool HasConstraints
	{
		get
		{
			if (constraints != null)
			{
				return constraints.Count > 0;
			}
			if (base.HasImage)
			{
				return Module.Read(this, (GenericParameter generic_parameter, MetadataReader reader) => reader.HasGenericConstraints(generic_parameter));
			}
			return false;
		}
	}

	public Collection<TypeReference> Constraints
	{
		get
		{
			if (constraints != null)
			{
				return constraints;
			}
			if (base.HasImage)
			{
				return Module.Read(ref constraints, this, (GenericParameter generic_parameter, MetadataReader reader) => reader.ReadGenericConstraints(generic_parameter));
			}
			return constraints = new Collection<TypeReference>();
		}
	}

	public bool HasCustomAttributes
	{
		get
		{
			if (custom_attributes != null)
			{
				return custom_attributes.Count > 0;
			}
			return this.GetHasCustomAttributes(Module);
		}
	}

	public Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, Module);

	public override IMetadataScope Scope
	{
		get
		{
			if (owner == null)
			{
				return null;
			}
			if (owner.GenericParameterType != GenericParameterType.Method)
			{
				return ((TypeReference)owner).Scope;
			}
			return ((MethodReference)owner).DeclaringType.Scope;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override TypeReference DeclaringType
	{
		get
		{
			return owner as TypeReference;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public MethodReference DeclaringMethod => owner as MethodReference;

	public override ModuleDefinition Module => module ?? owner.Module;

	public override string Name
	{
		get
		{
			if (!string.IsNullOrEmpty(base.Name))
			{
				return base.Name;
			}
			return base.Name = ((type == GenericParameterType.Method) ? "!!" : "!") + position;
		}
	}

	public override string Namespace
	{
		get
		{
			return string.Empty;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override string FullName => Name;

	public override bool IsGenericParameter => true;

	public override bool ContainsGenericParameter => true;

	public override MetadataType MetadataType => (MetadataType)etype;

	public bool IsNonVariant
	{
		get
		{
			return attributes.GetMaskedAttributes(3, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(3, 0u, value);
		}
	}

	public bool IsCovariant
	{
		get
		{
			return attributes.GetMaskedAttributes(3, 1u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(3, 1u, value);
		}
	}

	public bool IsContravariant
	{
		get
		{
			return attributes.GetMaskedAttributes(3, 2u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(3, 2u, value);
		}
	}

	public bool HasReferenceTypeConstraint
	{
		get
		{
			return attributes.GetAttributes(4);
		}
		set
		{
			attributes = attributes.SetAttributes(4, value);
		}
	}

	public bool HasNotNullableValueTypeConstraint
	{
		get
		{
			return attributes.GetAttributes(8);
		}
		set
		{
			attributes = attributes.SetAttributes(8, value);
		}
	}

	public bool HasDefaultConstructorConstraint
	{
		get
		{
			return attributes.GetAttributes(16);
		}
		set
		{
			attributes = attributes.SetAttributes(16, value);
		}
	}

	public GenericParameter(IGenericParameterProvider owner)
		: this(string.Empty, owner)
	{
	}

	public GenericParameter(string name, IGenericParameterProvider owner)
		: base(string.Empty, name)
	{
		if (owner == null)
		{
			throw new ArgumentNullException();
		}
		position = -1;
		this.owner = owner;
		type = owner.GenericParameterType;
		etype = ConvertGenericParameterType(type);
		token = new MetadataToken(TokenType.GenericParam);
	}

	internal GenericParameter(int position, GenericParameterType type, ModuleDefinition module)
		: base(string.Empty, string.Empty)
	{
		if (module == null)
		{
			throw new ArgumentNullException();
		}
		this.position = position;
		this.type = type;
		etype = ConvertGenericParameterType(type);
		base.module = module;
		token = new MetadataToken(TokenType.GenericParam);
	}

	private static ElementType ConvertGenericParameterType(GenericParameterType type)
	{
		return type switch
		{
			GenericParameterType.Type => ElementType.Var, 
			GenericParameterType.Method => ElementType.MVar, 
			_ => throw new ArgumentOutOfRangeException(), 
		};
	}

	public override TypeDefinition Resolve()
	{
		return null;
	}
}


using Mono.Cecil;
using Mono.Collections.Generic;

internal sealed class GenericParameterCollection : Collection<GenericParameter>
{
	private readonly IGenericParameterProvider owner;

	internal GenericParameterCollection(IGenericParameterProvider owner)
	{
		this.owner = owner;
	}

	internal GenericParameterCollection(IGenericParameterProvider owner, int capacity)
		: base(capacity)
	{
		this.owner = owner;
	}

	protected override void OnAdd(GenericParameter item, int index)
	{
		UpdateGenericParameter(item, index);
	}

	protected override void OnInsert(GenericParameter item, int index)
	{
		UpdateGenericParameter(item, index);
		for (int i = index; i < size; i++)
		{
			items[i].position = i + 1;
		}
	}

	protected override void OnSet(GenericParameter item, int index)
	{
		UpdateGenericParameter(item, index);
	}

	private void UpdateGenericParameter(GenericParameter item, int index)
	{
		item.owner = owner;
		item.position = index;
		item.type = owner.GenericParameterType;
	}

	protected override void OnRemove(GenericParameter item, int index)
	{
		item.owner = null;
		item.position = -1;
		item.type = GenericParameterType.Type;
		for (int i = index + 1; i < size; i++)
		{
			items[i].position = i - 1;
		}
	}
}


using System;

[Flags]
public enum GenericParameterAttributes : ushort
{
	VarianceMask = 3,
	NonVariant = 0,
	Covariant = 1,
	Contravariant = 2,
	SpecialConstraintMask = 0x1C,
	ReferenceTypeConstraint = 4,
	NotNullableValueTypeConstraint = 8,
	DefaultConstructorConstraint = 0x10
}


using Mono.Cecil;

public interface IConstantProvider : IMetadataTokenProvider
{
	bool HasConstant { get; set; }

	object Constant { get; set; }
}


using Mono.Cecil;
using Mono.Collections.Generic;

public interface ICustomAttributeProvider : IMetadataTokenProvider
{
	Collection<CustomAttribute> CustomAttributes { get; }

	bool HasCustomAttributes { get; }
}


using Mono.Cecil;
using Mono.Collections.Generic;

public interface IGenericInstance : IMetadataTokenProvider
{
	bool HasGenericArguments { get; }

	Collection<TypeReference> GenericArguments { get; }
}


using Mono.Cecil;
using Mono.Collections.Generic;

public interface IGenericParameterProvider : IMetadataTokenProvider
{
	bool HasGenericParameters { get; }

	bool IsDefinition { get; }

	ModuleDefinition Module { get; }

	Collection<GenericParameter> GenericParameters { get; }

	GenericParameterType GenericParameterType { get; }
}


public enum GenericParameterType
{
	Type,
	Method
}


using Mono.Cecil;

internal interface IGenericContext
{
	bool IsDefinition { get; }

	IGenericParameterProvider Type { get; }

	IGenericParameterProvider Method { get; }
}


using Mono.Cecil;

public interface IMarshalInfoProvider : IMetadataTokenProvider
{
	bool HasMarshalInfo { get; }

	MarshalInfo MarshalInfo { get; set; }
}


using Mono.Cecil;

public class MarshalInfo
{
	internal NativeType native;

	public NativeType NativeType
	{
		get
		{
			return native;
		}
		set
		{
			native = value;
		}
	}

	public MarshalInfo(NativeType native)
	{
		this.native = native;
	}
}


using Mono.Cecil;

public sealed class ArrayMarshalInfo : MarshalInfo
{
	internal NativeType element_type;

	internal int size_parameter_index;

	internal int size;

	internal int size_parameter_multiplier;

	public NativeType ElementType
	{
		get
		{
			return element_type;
		}
		set
		{
			element_type = value;
		}
	}

	public int SizeParameterIndex
	{
		get
		{
			return size_parameter_index;
		}
		set
		{
			size_parameter_index = value;
		}
	}

	public int Size
	{
		get
		{
			return size;
		}
		set
		{
			size = value;
		}
	}

	public int SizeParameterMultiplier
	{
		get
		{
			return size_parameter_multiplier;
		}
		set
		{
			size_parameter_multiplier = value;
		}
	}

	public ArrayMarshalInfo()
		: base(NativeType.Array)
	{
		element_type = NativeType.None;
		size_parameter_index = -1;
		size = -1;
		size_parameter_multiplier = -1;
	}
}


using System;
using Mono.Cecil;

public sealed class CustomMarshalInfo : MarshalInfo
{
	internal Guid guid;

	internal string unmanaged_type;

	internal TypeReference managed_type;

	internal string cookie;

	public Guid Guid
	{
		get
		{
			return guid;
		}
		set
		{
			guid = value;
		}
	}

	public string UnmanagedType
	{
		get
		{
			return unmanaged_type;
		}
		set
		{
			unmanaged_type = value;
		}
	}

	public TypeReference ManagedType
	{
		get
		{
			return managed_type;
		}
		set
		{
			managed_type = value;
		}
	}

	public string Cookie
	{
		get
		{
			return cookie;
		}
		set
		{
			cookie = value;
		}
	}

	public CustomMarshalInfo()
		: base(NativeType.CustomMarshaler)
	{
	}
}


using Mono.Cecil;

public sealed class SafeArrayMarshalInfo : MarshalInfo
{
	internal VariantType element_type;

	public VariantType ElementType
	{
		get
		{
			return element_type;
		}
		set
		{
			element_type = value;
		}
	}

	public SafeArrayMarshalInfo()
		: base(NativeType.SafeArray)
	{
		element_type = VariantType.None;
	}
}


using Mono.Cecil;

public sealed class FixedArrayMarshalInfo : MarshalInfo
{
	internal NativeType element_type;

	internal int size;

	public NativeType ElementType
	{
		get
		{
			return element_type;
		}
		set
		{
			element_type = value;
		}
	}

	public int Size
	{
		get
		{
			return size;
		}
		set
		{
			size = value;
		}
	}

	public FixedArrayMarshalInfo()
		: base(NativeType.FixedArray)
	{
		element_type = NativeType.None;
	}
}


using Mono.Cecil;

public sealed class FixedSysStringMarshalInfo : MarshalInfo
{
	internal int size;

	public int Size
	{
		get
		{
			return size;
		}
		set
		{
			size = value;
		}
	}

	public FixedSysStringMarshalInfo()
		: base(NativeType.FixedSysString)
	{
		size = -1;
	}
}


using Mono.Cecil;

public interface IAssemblyResolver
{
	AssemblyDefinition Resolve(AssemblyNameReference name);

	AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);

	AssemblyDefinition Resolve(string fullName);

	AssemblyDefinition Resolve(string fullName, ReaderParameters parameters);
}


using Mono.Cecil;

public interface IMetadataResolver
{
	TypeDefinition Resolve(TypeReference type);

	FieldDefinition Resolve(FieldReference field);

	MethodDefinition Resolve(MethodReference method);
}


using System;
using System.Runtime.Serialization;
using Mono.Cecil;

[Serializable]
public class ResolutionException : Exception
{
	private readonly MemberReference member;

	public MemberReference Member => member;

	public IMetadataScope Scope
	{
		get
		{
			if (member is TypeReference typeReference)
			{
				return typeReference.Scope;
			}
			TypeReference declaringType = member.DeclaringType;
			if (declaringType != null)
			{
				return declaringType.Scope;
			}
			throw new NotSupportedException();
		}
	}

	public ResolutionException(MemberReference member)
		: base("Failed to resolve " + member.FullName)
	{
		if (member == null)
		{
			throw new ArgumentNullException("member");
		}
		this.member = member;
	}

	protected ResolutionException(SerializationInfo info, StreamingContext context)
		: base(info, context)
	{
	}
}


using System;
using Mono.Cecil;
using Mono.Collections.Generic;

public class MetadataResolver : IMetadataResolver
{
	private readonly IAssemblyResolver assembly_resolver;

	public IAssemblyResolver AssemblyResolver => assembly_resolver;

	public MetadataResolver(IAssemblyResolver assemblyResolver)
	{
		if (assemblyResolver == null)
		{
			throw new ArgumentNullException("assemblyResolver");
		}
		assembly_resolver = assemblyResolver;
	}

	public virtual TypeDefinition Resolve(TypeReference type)
	{
		if (type == null)
		{
			throw new ArgumentNullException("type");
		}
		type = type.GetElementType();
		IMetadataScope scope = type.Scope;
		if (scope == null)
		{
			return null;
		}
		switch (scope.MetadataScopeType)
		{
		case MetadataScopeType.AssemblyNameReference:
		{
			AssemblyDefinition assemblyDefinition = assembly_resolver.Resolve((AssemblyNameReference)scope);
			if (assemblyDefinition == null)
			{
				return null;
			}
			return GetType(assemblyDefinition.MainModule, type);
		}
		case MetadataScopeType.ModuleDefinition:
			return GetType((ModuleDefinition)scope, type);
		case MetadataScopeType.ModuleReference:
		{
			Collection<ModuleDefinition> modules = type.Module.Assembly.Modules;
			ModuleReference moduleReference = (ModuleReference)scope;
			for (int i = 0; i < modules.Count; i++)
			{
				ModuleDefinition moduleDefinition = modules[i];
				if (moduleDefinition.Name == moduleReference.Name)
				{
					return GetType(moduleDefinition, type);
				}
			}
			break;
		}
		}
		throw new NotSupportedException();
	}

	private static TypeDefinition GetType(ModuleDefinition module, TypeReference reference)
	{
		TypeDefinition typeDefinition = GetTypeDefinition(module, reference);
		if (typeDefinition != null)
		{
			return typeDefinition;
		}
		if (!module.HasExportedTypes)
		{
			return null;
		}
		Collection<ExportedType> exportedTypes = module.ExportedTypes;
		for (int i = 0; i < exportedTypes.Count; i++)
		{
			ExportedType exportedType = exportedTypes[i];
			if (!(exportedType.Name != reference.Name) && !(exportedType.Namespace != reference.Namespace))
			{
				return exportedType.Resolve();
			}
		}
		return null;
	}

	private static TypeDefinition GetTypeDefinition(ModuleDefinition module, TypeReference type)
	{
		if (!type.IsNested)
		{
			return module.GetType(type.Namespace, type.Name);
		}
		return type.DeclaringType.Resolve()?.GetNestedType(type.TypeFullName());
	}

	public virtual FieldDefinition Resolve(FieldReference field)
	{
		if (field == null)
		{
			throw new ArgumentNullException("field");
		}
		TypeDefinition typeDefinition = Resolve(field.DeclaringType);
		if (typeDefinition == null)
		{
			return null;
		}
		if (!typeDefinition.HasFields)
		{
			return null;
		}
		return GetField(typeDefinition, field);
	}

	private FieldDefinition GetField(TypeDefinition type, FieldReference reference)
	{
		while (type != null)
		{
			FieldDefinition field = GetField(type.Fields, reference);
			if (field != null)
			{
				return field;
			}
			if (type.BaseType == null)
			{
				return null;
			}
			type = Resolve(type.BaseType);
		}
		return null;
	}

	private static FieldDefinition GetField(Collection<FieldDefinition> fields, FieldReference reference)
	{
		for (int i = 0; i < fields.Count; i++)
		{
			FieldDefinition fieldDefinition = fields[i];
			if (!(fieldDefinition.Name != reference.Name) && AreSame(fieldDefinition.FieldType, reference.FieldType))
			{
				return fieldDefinition;
			}
		}
		return null;
	}

	public virtual MethodDefinition Resolve(MethodReference method)
	{
		if (method == null)
		{
			throw new ArgumentNullException("method");
		}
		TypeDefinition typeDefinition = Resolve(method.DeclaringType);
		if (typeDefinition == null)
		{
			return null;
		}
		method = method.GetElementMethod();
		if (!typeDefinition.HasMethods)
		{
			return null;
		}
		return GetMethod(typeDefinition, method);
	}

	private MethodDefinition GetMethod(TypeDefinition type, MethodReference reference)
	{
		while (type != null)
		{
			MethodDefinition method = GetMethod(type.Methods, reference);
			if (method != null)
			{
				return method;
			}
			if (type.BaseType == null)
			{
				return null;
			}
			type = Resolve(type.BaseType);
		}
		return null;
	}

	public static MethodDefinition GetMethod(Collection<MethodDefinition> methods, MethodReference reference)
	{
		for (int i = 0; i < methods.Count; i++)
		{
			MethodDefinition methodDefinition = methods[i];
			if (!(methodDefinition.Name != reference.Name) && methodDefinition.HasGenericParameters == reference.HasGenericParameters && (!methodDefinition.HasGenericParameters || methodDefinition.GenericParameters.Count == reference.GenericParameters.Count) && AreSame(methodDefinition.ReturnType, reference.ReturnType) && methodDefinition.HasParameters == reference.HasParameters)
			{
				if (!methodDefinition.HasParameters && !reference.HasParameters)
				{
					return methodDefinition;
				}
				if (AreSame(methodDefinition.Parameters, reference.Parameters))
				{
					return methodDefinition;
				}
			}
		}
		return null;
	}

	private static bool AreSame(Collection<ParameterDefinition> a, Collection<ParameterDefinition> b)
	{
		int count = a.Count;
		if (count != b.Count)
		{
			return false;
		}
		if (count == 0)
		{
			return true;
		}
		for (int i = 0; i < count; i++)
		{
			if (!AreSame(a[i].ParameterType, b[i].ParameterType))
			{
				return false;
			}
		}
		return true;
	}

	private static bool AreSame(TypeSpecification a, TypeSpecification b)
	{
		if (!AreSame(a.ElementType, b.ElementType))
		{
			return false;
		}
		if (a.IsGenericInstance)
		{
			return AreSame((GenericInstanceType)a, (GenericInstanceType)b);
		}
		if (a.IsRequiredModifier || a.IsOptionalModifier)
		{
			return AreSame((IModifierType)a, (IModifierType)b);
		}
		if (a.IsArray)
		{
			return AreSame((ArrayType)a, (ArrayType)b);
		}
		return true;
	}

	private static bool AreSame(ArrayType a, ArrayType b)
	{
		if (a.Rank != b.Rank)
		{
			return false;
		}
		return true;
	}

	private static bool AreSame(IModifierType a, IModifierType b)
	{
		return AreSame(a.ModifierType, b.ModifierType);
	}

	private static bool AreSame(GenericInstanceType a, GenericInstanceType b)
	{
		if (a.GenericArguments.Count != b.GenericArguments.Count)
		{
			return false;
		}
		for (int i = 0; i < a.GenericArguments.Count; i++)
		{
			if (!AreSame(a.GenericArguments[i], b.GenericArguments[i]))
			{
				return false;
			}
		}
		return true;
	}

	private static bool AreSame(GenericParameter a, GenericParameter b)
	{
		return a.Position == b.Position;
	}

	private static bool AreSame(TypeReference a, TypeReference b)
	{
		if (a == b)
		{
			return true;
		}
		if (a == null || b == null)
		{
			return false;
		}
		if (a.etype != b.etype)
		{
			return false;
		}
		if (a.IsGenericParameter)
		{
			return AreSame((GenericParameter)a, (GenericParameter)b);
		}
		if (a.IsTypeSpecification())
		{
			return AreSame((TypeSpecification)a, (TypeSpecification)b);
		}
		if (a.Name != b.Name || a.Namespace != b.Namespace)
		{
			return false;
		}
		return AreSame(a.DeclaringType, b.DeclaringType);
	}
}


using Mono.Cecil;

public interface IModifierType
{
	TypeReference ModifierType { get; }

	TypeReference ElementType { get; }
}


using System;
using Mono.Cecil;
using Mono.Cecil.Metadata;

public sealed class OptionalModifierType : TypeSpecification, IModifierType
{
	private TypeReference modifier_type;

	public TypeReference ModifierType
	{
		get
		{
			return modifier_type;
		}
		set
		{
			modifier_type = value;
		}
	}

	public override string Name => base.Name + Suffix;

	public override string FullName => base.FullName + Suffix;

	private string Suffix => string.Concat(" modopt(", modifier_type, ")");

	public override bool IsValueType
	{
		get
		{
			return false;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override bool IsOptionalModifier => true;

	public override bool ContainsGenericParameter
	{
		get
		{
			if (!modifier_type.ContainsGenericParameter)
			{
				return base.ContainsGenericParameter;
			}
			return true;
		}
	}

	public OptionalModifierType(TypeReference modifierType, TypeReference type)
		: base(type)
	{
		Mixin.CheckModifier(modifierType, type);
		modifier_type = modifierType;
		etype = Mono.Cecil.Metadata.ElementType.CModOpt;
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Metadata;

public sealed class RequiredModifierType : TypeSpecification, IModifierType
{
	private TypeReference modifier_type;

	public TypeReference ModifierType
	{
		get
		{
			return modifier_type;
		}
		set
		{
			modifier_type = value;
		}
	}

	public override string Name => base.Name + Suffix;

	public override string FullName => base.FullName + Suffix;

	private string Suffix => string.Concat(" modreq(", modifier_type, ")");

	public override bool IsValueType
	{
		get
		{
			return false;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override bool IsRequiredModifier => true;

	public override bool ContainsGenericParameter
	{
		get
		{
			if (!modifier_type.ContainsGenericParameter)
			{
				return base.ContainsGenericParameter;
			}
			return true;
		}
	}

	public RequiredModifierType(TypeReference modifierType, TypeReference type)
		: base(type)
	{
		Mixin.CheckModifier(modifierType, type);
		modifier_type = modifierType;
		etype = Mono.Cecil.Metadata.ElementType.CModReqD;
	}
}


public enum NativeType
{
	None = 102,
	Boolean = 2,
	I1 = 3,
	U1 = 4,
	I2 = 5,
	U2 = 6,
	I4 = 7,
	U4 = 8,
	I8 = 9,
	U8 = 10,
	R4 = 11,
	R8 = 12,
	LPStr = 20,
	Int = 31,
	UInt = 32,
	Func = 38,
	Array = 42,
	Currency = 15,
	BStr = 19,
	LPWStr = 21,
	LPTStr = 22,
	FixedSysString = 23,
	IUnknown = 25,
	IDispatch = 26,
	Struct = 27,
	IntF = 28,
	SafeArray = 29,
	FixedArray = 30,
	ByValStr = 34,
	ANSIBStr = 35,
	TBStr = 36,
	VariantBool = 37,
	ASAny = 40,
	LPStruct = 43,
	CustomMarshaler = 44,
	Error = 45,
	Max = 80
}


using System;
using Mono.Cecil;
using Mono.Cecil.Metadata;

public sealed class PinnedType : TypeSpecification
{
	public override bool IsValueType
	{
		get
		{
			return false;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override bool IsPinned => true;

	public PinnedType(TypeReference type)
		: base(type)
	{
		Mixin.CheckType(type);
		etype = Mono.Cecil.Metadata.ElementType.Pinned;
	}
}


internal struct Range
{
	public uint Start;

	public uint Length;

	public Range(uint index, uint length)
	{
		Start = index;
		Length = length;
	}
}


using System;
using System.Collections.Generic;
using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class MetadataSystem
{
	internal AssemblyNameReference[] AssemblyReferences;

	internal ModuleReference[] ModuleReferences;

	internal TypeDefinition[] Types;

	internal TypeReference[] TypeReferences;

	internal FieldDefinition[] Fields;

	internal MethodDefinition[] Methods;

	internal MemberReference[] MemberReferences;

	internal Dictionary<uint, uint[]> NestedTypes;

	internal Dictionary<uint, uint> ReverseNestedTypes;

	internal Dictionary<uint, MetadataToken[]> Interfaces;

	internal Dictionary<uint, Row<ushort, uint>> ClassLayouts;

	internal Dictionary<uint, uint> FieldLayouts;

	internal Dictionary<uint, uint> FieldRVAs;

	internal Dictionary<MetadataToken, uint> FieldMarshals;

	internal Dictionary<MetadataToken, Row<ElementType, uint>> Constants;

	internal Dictionary<uint, MetadataToken[]> Overrides;

	internal Dictionary<MetadataToken, Mono.Cecil.Range[]> CustomAttributes;

	internal Dictionary<MetadataToken, Mono.Cecil.Range[]> SecurityDeclarations;

	internal Dictionary<uint, Mono.Cecil.Range> Events;

	internal Dictionary<uint, Mono.Cecil.Range> Properties;

	internal Dictionary<uint, Row<MethodSemanticsAttributes, MetadataToken>> Semantics;

	internal Dictionary<uint, Row<PInvokeAttributes, uint, uint>> PInvokes;

	internal Dictionary<MetadataToken, Mono.Cecil.Range[]> GenericParameters;

	internal Dictionary<uint, MetadataToken[]> GenericConstraints;

	private static Dictionary<string, Row<ElementType, bool>> primitive_value_types;

	private static void InitializePrimitives()
	{
		primitive_value_types = new Dictionary<string, Row<ElementType, bool>>(18, StringComparer.Ordinal)
		{
			{
				"Void",
				new Row<ElementType, bool>(ElementType.Void, col2: false)
			},
			{
				"Boolean",
				new Row<ElementType, bool>(ElementType.Boolean, col2: true)
			},
			{
				"Char",
				new Row<ElementType, bool>(ElementType.Char, col2: true)
			},
			{
				"SByte",
				new Row<ElementType, bool>(ElementType.I1, col2: true)
			},
			{
				"Byte",
				new Row<ElementType, bool>(ElementType.U1, col2: true)
			},
			{
				"Int16",
				new Row<ElementType, bool>(ElementType.I2, col2: true)
			},
			{
				"UInt16",
				new Row<ElementType, bool>(ElementType.U2, col2: true)
			},
			{
				"Int32",
				new Row<ElementType, bool>(ElementType.I4, col2: true)
			},
			{
				"UInt32",
				new Row<ElementType, bool>(ElementType.U4, col2: true)
			},
			{
				"Int64",
				new Row<ElementType, bool>(ElementType.I8, col2: true)
			},
			{
				"UInt64",
				new Row<ElementType, bool>(ElementType.U8, col2: true)
			},
			{
				"Single",
				new Row<ElementType, bool>(ElementType.R4, col2: true)
			},
			{
				"Double",
				new Row<ElementType, bool>(ElementType.R8, col2: true)
			},
			{
				"String",
				new Row<ElementType, bool>(ElementType.String, col2: false)
			},
			{
				"TypedReference",
				new Row<ElementType, bool>(ElementType.TypedByRef, col2: false)
			},
			{
				"IntPtr",
				new Row<ElementType, bool>(ElementType.I, col2: true)
			},
			{
				"UIntPtr",
				new Row<ElementType, bool>(ElementType.U, col2: true)
			},
			{
				"Object",
				new Row<ElementType, bool>(ElementType.Object, col2: false)
			}
		};
	}

	public static void TryProcessPrimitiveTypeReference(TypeReference type)
	{
		if (!(type.Namespace != "System"))
		{
			IMetadataScope scope = type.scope;
			if (scope != null && scope.MetadataScopeType == MetadataScopeType.AssemblyNameReference && TryGetPrimitiveData(type, out var primitive_data))
			{
				type.etype = primitive_data.Col1;
				type.IsValueType = primitive_data.Col2;
			}
		}
	}

	public static bool TryGetPrimitiveElementType(TypeDefinition type, out ElementType etype)
	{
		etype = ElementType.None;
		if (type.Namespace != "System")
		{
			return false;
		}
		if (TryGetPrimitiveData(type, out var primitive_data) && primitive_data.Col1.IsPrimitive())
		{
			etype = primitive_data.Col1;
			return true;
		}
		return false;
	}

	private static bool TryGetPrimitiveData(TypeReference type, out Row<ElementType, bool> primitive_data)
	{
		if (primitive_value_types == null)
		{
			InitializePrimitives();
		}
		return primitive_value_types.TryGetValue(type.Name, out primitive_data);
	}

	public void Clear()
	{
		if (NestedTypes != null)
		{
			NestedTypes.Clear();
		}
		if (ReverseNestedTypes != null)
		{
			ReverseNestedTypes.Clear();
		}
		if (Interfaces != null)
		{
			Interfaces.Clear();
		}
		if (ClassLayouts != null)
		{
			ClassLayouts.Clear();
		}
		if (FieldLayouts != null)
		{
			FieldLayouts.Clear();
		}
		if (FieldRVAs != null)
		{
			FieldRVAs.Clear();
		}
		if (FieldMarshals != null)
		{
			FieldMarshals.Clear();
		}
		if (Constants != null)
		{
			Constants.Clear();
		}
		if (Overrides != null)
		{
			Overrides.Clear();
		}
		if (CustomAttributes != null)
		{
			CustomAttributes.Clear();
		}
		if (SecurityDeclarations != null)
		{
			SecurityDeclarations.Clear();
		}
		if (Events != null)
		{
			Events.Clear();
		}
		if (Properties != null)
		{
			Properties.Clear();
		}
		if (Semantics != null)
		{
			Semantics.Clear();
		}
		if (PInvokes != null)
		{
			PInvokes.Clear();
		}
		if (GenericParameters != null)
		{
			GenericParameters.Clear();
		}
		if (GenericConstraints != null)
		{
			GenericConstraints.Clear();
		}
	}

	public TypeDefinition GetTypeDefinition(uint rid)
	{
		if (rid < 1 || rid > Types.Length)
		{
			return null;
		}
		return Types[rid - 1];
	}

	public void AddTypeDefinition(TypeDefinition type)
	{
		Types[type.token.RID - 1] = type;
	}

	public TypeReference GetTypeReference(uint rid)
	{
		if (rid < 1 || rid > TypeReferences.Length)
		{
			return null;
		}
		return TypeReferences[rid - 1];
	}

	public void AddTypeReference(TypeReference type)
	{
		TypeReferences[type.token.RID - 1] = type;
	}

	public FieldDefinition GetFieldDefinition(uint rid)
	{
		if (rid < 1 || rid > Fields.Length)
		{
			return null;
		}
		return Fields[rid - 1];
	}

	public void AddFieldDefinition(FieldDefinition field)
	{
		Fields[field.token.RID - 1] = field;
	}

	public MethodDefinition GetMethodDefinition(uint rid)
	{
		if (rid < 1 || rid > Methods.Length)
		{
			return null;
		}
		return Methods[rid - 1];
	}

	public void AddMethodDefinition(MethodDefinition method)
	{
		Methods[method.token.RID - 1] = method;
	}

	public MemberReference GetMemberReference(uint rid)
	{
		if (rid < 1 || rid > MemberReferences.Length)
		{
			return null;
		}
		return MemberReferences[rid - 1];
	}

	public void AddMemberReference(MemberReference member)
	{
		MemberReferences[member.token.RID - 1] = member;
	}

	public bool TryGetNestedTypeMapping(TypeDefinition type, out uint[] mapping)
	{
		return NestedTypes.TryGetValue(type.token.RID, out mapping);
	}

	public void SetNestedTypeMapping(uint type_rid, uint[] mapping)
	{
		NestedTypes[type_rid] = mapping;
	}

	public void RemoveNestedTypeMapping(TypeDefinition type)
	{
		NestedTypes.Remove(type.token.RID);
	}

	public bool TryGetReverseNestedTypeMapping(TypeDefinition type, out uint declaring)
	{
		return ReverseNestedTypes.TryGetValue(type.token.RID, out declaring);
	}

	public void SetReverseNestedTypeMapping(uint nested, uint declaring)
	{
		ReverseNestedTypes.Add(nested, declaring);
	}

	public void RemoveReverseNestedTypeMapping(TypeDefinition type)
	{
		ReverseNestedTypes.Remove(type.token.RID);
	}

	public bool TryGetInterfaceMapping(TypeDefinition type, out MetadataToken[] mapping)
	{
		return Interfaces.TryGetValue(type.token.RID, out mapping);
	}

	public void SetInterfaceMapping(uint type_rid, MetadataToken[] mapping)
	{
		Interfaces[type_rid] = mapping;
	}

	public void RemoveInterfaceMapping(TypeDefinition type)
	{
		Interfaces.Remove(type.token.RID);
	}

	public void AddPropertiesRange(uint type_rid, Mono.Cecil.Range range)
	{
		Properties.Add(type_rid, range);
	}

	public bool TryGetPropertiesRange(TypeDefinition type, out Mono.Cecil.Range range)
	{
		return Properties.TryGetValue(type.token.RID, out range);
	}

	public void RemovePropertiesRange(TypeDefinition type)
	{
		Properties.Remove(type.token.RID);
	}

	public void AddEventsRange(uint type_rid, Mono.Cecil.Range range)
	{
		Events.Add(type_rid, range);
	}

	public bool TryGetEventsRange(TypeDefinition type, out Mono.Cecil.Range range)
	{
		return Events.TryGetValue(type.token.RID, out range);
	}

	public void RemoveEventsRange(TypeDefinition type)
	{
		Events.Remove(type.token.RID);
	}

	public bool TryGetGenericParameterRanges(IGenericParameterProvider owner, out Mono.Cecil.Range[] ranges)
	{
		return GenericParameters.TryGetValue(owner.MetadataToken, out ranges);
	}

	public void RemoveGenericParameterRange(IGenericParameterProvider owner)
	{
		GenericParameters.Remove(owner.MetadataToken);
	}

	public bool TryGetCustomAttributeRanges(ICustomAttributeProvider owner, out Mono.Cecil.Range[] ranges)
	{
		return CustomAttributes.TryGetValue(owner.MetadataToken, out ranges);
	}

	public void RemoveCustomAttributeRange(ICustomAttributeProvider owner)
	{
		CustomAttributes.Remove(owner.MetadataToken);
	}

	public bool TryGetSecurityDeclarationRanges(ISecurityDeclarationProvider owner, out Mono.Cecil.Range[] ranges)
	{
		return SecurityDeclarations.TryGetValue(owner.MetadataToken, out ranges);
	}

	public void RemoveSecurityDeclarationRange(ISecurityDeclarationProvider owner)
	{
		SecurityDeclarations.Remove(owner.MetadataToken);
	}

	public bool TryGetGenericConstraintMapping(GenericParameter generic_parameter, out MetadataToken[] mapping)
	{
		return GenericConstraints.TryGetValue(generic_parameter.token.RID, out mapping);
	}

	public void SetGenericConstraintMapping(uint gp_rid, MetadataToken[] mapping)
	{
		GenericConstraints[gp_rid] = mapping;
	}

	public void RemoveGenericConstraintMapping(GenericParameter generic_parameter)
	{
		GenericConstraints.Remove(generic_parameter.token.RID);
	}

	public bool TryGetOverrideMapping(MethodDefinition method, out MetadataToken[] mapping)
	{
		return Overrides.TryGetValue(method.token.RID, out mapping);
	}

	public void SetOverrideMapping(uint rid, MetadataToken[] mapping)
	{
		Overrides[rid] = mapping;
	}

	public void RemoveOverrideMapping(MethodDefinition method)
	{
		Overrides.Remove(method.token.RID);
	}

	public TypeDefinition GetFieldDeclaringType(uint field_rid)
	{
		return BinaryRangeSearch(Types, field_rid, field: true);
	}

	public TypeDefinition GetMethodDeclaringType(uint method_rid)
	{
		return BinaryRangeSearch(Types, method_rid, field: false);
	}

	private static TypeDefinition BinaryRangeSearch(TypeDefinition[] types, uint rid, bool field)
	{
		int num = 0;
		int num2 = types.Length - 1;
		while (num <= num2)
		{
			int num3 = num + (num2 - num) / 2;
			TypeDefinition typeDefinition = types[num3];
			Mono.Cecil.Range range = (field ? typeDefinition.fields_range : typeDefinition.methods_range);
			if (rid < range.Start)
			{
				num2 = num3 - 1;
				continue;
			}
			if (rid >= range.Start + range.Length)
			{
				num = num3 + 1;
				continue;
			}
			return typeDefinition;
		}
		return null;
	}
}


using Mono.Cecil;
using Mono.Collections.Generic;

public interface IMethodSignature : IMetadataTokenProvider
{
	bool HasThis { get; set; }

	bool ExplicitThis { get; set; }

	MethodCallingConvention CallingConvention { get; set; }

	bool HasParameters { get; }

	Collection<ParameterDefinition> Parameters { get; }

	TypeReference ReturnType { get; set; }

	MethodReturnType MethodReturnType { get; }
}


using Mono.Cecil;
using Mono.Collections.Generic;

internal sealed class ParameterDefinitionCollection : Collection<ParameterDefinition>
{
	private readonly IMethodSignature method;

	internal ParameterDefinitionCollection(IMethodSignature method)
	{
		this.method = method;
	}

	internal ParameterDefinitionCollection(IMethodSignature method, int capacity)
		: base(capacity)
	{
		this.method = method;
	}

	protected override void OnAdd(ParameterDefinition item, int index)
	{
		item.method = method;
		item.index = index;
	}

	protected override void OnInsert(ParameterDefinition item, int index)
	{
		item.method = method;
		item.index = index;
		for (int i = index; i < size; i++)
		{
			items[i].index = i + 1;
		}
	}

	protected override void OnSet(ParameterDefinition item, int index)
	{
		item.method = method;
		item.index = index;
	}

	protected override void OnRemove(ParameterDefinition item, int index)
	{
		item.method = null;
		item.index = -1;
		for (int i = index + 1; i < size; i++)
		{
			items[i].index = i - 1;
		}
	}
}


using System;
using System.IO;
using Mono.Cecil;

public sealed class EmbeddedResource : Resource
{
	private readonly MetadataReader reader;

	private uint? offset;

	private byte[] data;

	private Stream stream;

	public override ResourceType ResourceType => ResourceType.Embedded;

	public EmbeddedResource(string name, ManifestResourceAttributes attributes, byte[] data)
		: base(name, attributes)
	{
		this.data = data;
	}

	public EmbeddedResource(string name, ManifestResourceAttributes attributes, Stream stream)
		: base(name, attributes)
	{
		this.stream = stream;
	}

	internal EmbeddedResource(string name, ManifestResourceAttributes attributes, uint offset, MetadataReader reader)
		: base(name, attributes)
	{
		this.offset = offset;
		this.reader = reader;
	}

	public Stream GetResourceStream()
	{
		if (stream != null)
		{
			return stream;
		}
		if (data != null)
		{
			return new MemoryStream(data);
		}
		if (offset.HasValue)
		{
			return reader.GetManagedResourceStream(offset.Value);
		}
		throw new InvalidOperationException();
	}

	public byte[] GetResourceData()
	{
		if (stream != null)
		{
			return ReadStream(stream);
		}
		if (data != null)
		{
			return data;
		}
		if (offset.HasValue)
		{
			return reader.GetManagedResourceStream(offset.Value).ToArray();
		}
		throw new InvalidOperationException();
	}

	private static byte[] ReadStream(Stream stream)
	{
		int num3;
		if (stream.CanSeek)
		{
			int num = (int)stream.Length;
			byte[] array = new byte[num];
			int num2 = 0;
			while ((num3 = stream.Read(array, num2, num - num2)) > 0)
			{
				num2 += num3;
			}
			return array;
		}
		byte[] array2 = new byte[8192];
		MemoryStream memoryStream = new MemoryStream();
		while ((num3 = stream.Read(array2, 0, array2.Length)) > 0)
		{
			memoryStream.Write(array2, 0, num3);
		}
		return memoryStream.ToArray();
	}
}


using System;

[Flags]
public enum EventAttributes : ushort
{
	None = 0,
	SpecialName = 0x200,
	RTSpecialName = 0x400
}


using Mono.Cecil;
using Mono.Collections.Generic;

public sealed class EventDefinition : EventReference, IMemberDefinition, ICustomAttributeProvider, IMetadataTokenProvider
{
	private ushort attributes;

	private Collection<CustomAttribute> custom_attributes;

	internal MethodDefinition add_method;

	internal MethodDefinition invoke_method;

	internal MethodDefinition remove_method;

	internal Collection<MethodDefinition> other_methods;

	public EventAttributes Attributes
	{
		get
		{
			return (EventAttributes)attributes;
		}
		set
		{
			attributes = (ushort)value;
		}
	}

	public MethodDefinition AddMethod
	{
		get
		{
			if (add_method != null)
			{
				return add_method;
			}
			InitializeMethods();
			return add_method;
		}
		set
		{
			add_method = value;
		}
	}

	public MethodDefinition InvokeMethod
	{
		get
		{
			if (invoke_method != null)
			{
				return invoke_method;
			}
			InitializeMethods();
			return invoke_method;
		}
		set
		{
			invoke_method = value;
		}
	}

	public MethodDefinition RemoveMethod
	{
		get
		{
			if (remove_method != null)
			{
				return remove_method;
			}
			InitializeMethods();
			return remove_method;
		}
		set
		{
			remove_method = value;
		}
	}

	public bool HasOtherMethods
	{
		get
		{
			if (other_methods != null)
			{
				return other_methods.Count > 0;
			}
			InitializeMethods();
			return !other_methods.IsNullOrEmpty();
		}
	}

	public Collection<MethodDefinition> OtherMethods
	{
		get
		{
			if (other_methods != null)
			{
				return other_methods;
			}
			InitializeMethods();
			if (other_methods != null)
			{
				return other_methods;
			}
			return other_methods = new Collection<MethodDefinition>();
		}
	}

	public bool HasCustomAttributes
	{
		get
		{
			if (custom_attributes != null)
			{
				return custom_attributes.Count > 0;
			}
			return this.GetHasCustomAttributes(Module);
		}
	}

	public Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, Module);

	public bool IsSpecialName
	{
		get
		{
			return attributes.GetAttributes(512);
		}
		set
		{
			attributes = attributes.SetAttributes(512, value);
		}
	}

	public bool IsRuntimeSpecialName
	{
		get
		{
			return attributes.GetAttributes(1024);
		}
		set
		{
			attributes = attributes.SetAttributes(1024, value);
		}
	}

	public new TypeDefinition DeclaringType
	{
		get
		{
			return (TypeDefinition)base.DeclaringType;
		}
		set
		{
			base.DeclaringType = value;
		}
	}

	public override bool IsDefinition => true;

	public EventDefinition(string name, EventAttributes attributes, TypeReference eventType)
		: base(name, eventType)
	{
		this.attributes = (ushort)attributes;
		token = new MetadataToken(TokenType.Event);
	}

	private void InitializeMethods()
	{
		ModuleDefinition module = Module;
		if (module == null)
		{
			return;
		}
		lock (module.SyncRoot)
		{
			if (add_method == null && invoke_method == null && remove_method == null && module.HasImage())
			{
				module.Read(this, (EventDefinition @event, MetadataReader reader) => reader.ReadMethods(@event));
			}
		}
	}

	public override EventDefinition Resolve()
	{
		return this;
	}
}


using System;
using Mono.Cecil;

public abstract class EventReference : MemberReference
{
	private TypeReference event_type;

	public TypeReference EventType
	{
		get
		{
			return event_type;
		}
		set
		{
			event_type = value;
		}
	}

	public override string FullName => event_type.FullName + " " + MemberFullName();

	protected EventReference(string name, TypeReference eventType)
		: base(name)
	{
		if (eventType == null)
		{
			throw new ArgumentNullException("eventType");
		}
		event_type = eventType;
	}

	public abstract EventDefinition Resolve();
}


using System;

[Flags]
public enum FieldAttributes : ushort
{
	FieldAccessMask = 7,
	CompilerControlled = 0,
	Private = 1,
	FamANDAssem = 2,
	Assembly = 3,
	Family = 4,
	FamORAssem = 5,
	Public = 6,
	Static = 0x10,
	InitOnly = 0x20,
	Literal = 0x40,
	NotSerialized = 0x80,
	SpecialName = 0x200,
	PInvokeImpl = 0x2000,
	RTSpecialName = 0x400,
	HasFieldMarshal = 0x1000,
	HasDefault = 0x8000,
	HasFieldRVA = 0x100
}


using Mono;
using Mono.Cecil;
using Mono.Collections.Generic;

public sealed class FieldDefinition : FieldReference, IMemberDefinition, ICustomAttributeProvider, IMetadataTokenProvider, IConstantProvider, IMarshalInfoProvider
{
	private ushort attributes;

	private Collection<CustomAttribute> custom_attributes;

	private int offset = -2;

	internal int rva = -2;

	private byte[] initial_value;

	private object constant = Mixin.NotResolved;

	private MarshalInfo marshal_info;

	public bool HasLayoutInfo
	{
		get
		{
			if (offset >= 0)
			{
				return true;
			}
			ResolveLayout();
			return offset >= 0;
		}
	}

	public int Offset
	{
		get
		{
			if (offset >= 0)
			{
				return offset;
			}
			ResolveLayout();
			if (offset < 0)
			{
				return -1;
			}
			return offset;
		}
		set
		{
			offset = value;
		}
	}

	public int RVA
	{
		get
		{
			if (rva > 0)
			{
				return rva;
			}
			ResolveRVA();
			if (rva <= 0)
			{
				return 0;
			}
			return rva;
		}
	}

	public byte[] InitialValue
	{
		get
		{
			if (initial_value != null)
			{
				return initial_value;
			}
			ResolveRVA();
			if (initial_value == null)
			{
				initial_value = Empty<byte>.Array;
			}
			return initial_value;
		}
		set
		{
			initial_value = value;
			rva = 0;
		}
	}

	public FieldAttributes Attributes
	{
		get
		{
			return (FieldAttributes)attributes;
		}
		set
		{
			attributes = (ushort)value;
		}
	}

	public bool HasConstant
	{
		get
		{
			this.ResolveConstant(ref constant, Module);
			return constant != Mixin.NoValue;
		}
		set
		{
			if (!value)
			{
				constant = Mixin.NoValue;
			}
		}
	}

	public object Constant
	{
		get
		{
			if (!HasConstant)
			{
				return null;
			}
			return constant;
		}
		set
		{
			constant = value;
		}
	}

	public bool HasCustomAttributes
	{
		get
		{
			if (custom_attributes != null)
			{
				return custom_attributes.Count > 0;
			}
			return this.GetHasCustomAttributes(Module);
		}
	}

	public Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, Module);

	public bool HasMarshalInfo
	{
		get
		{
			if (marshal_info != null)
			{
				return true;
			}
			return this.GetHasMarshalInfo(Module);
		}
	}

	public MarshalInfo MarshalInfo
	{
		get
		{
			return marshal_info ?? this.GetMarshalInfo(ref marshal_info, Module);
		}
		set
		{
			marshal_info = value;
		}
	}

	public bool IsCompilerControlled
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 0u, value);
		}
	}

	public bool IsPrivate
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 1u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 1u, value);
		}
	}

	public bool IsFamilyAndAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 2u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 2u, value);
		}
	}

	public bool IsAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 3u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 3u, value);
		}
	}

	public bool IsFamily
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 4u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 4u, value);
		}
	}

	public bool IsFamilyOrAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 5u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 5u, value);
		}
	}

	public bool IsPublic
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 6u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 6u, value);
		}
	}

	public bool IsStatic
	{
		get
		{
			return attributes.GetAttributes(16);
		}
		set
		{
			attributes = attributes.SetAttributes(16, value);
		}
	}

	public bool IsInitOnly
	{
		get
		{
			return attributes.GetAttributes(32);
		}
		set
		{
			attributes = attributes.SetAttributes(32, value);
		}
	}

	public bool IsLiteral
	{
		get
		{
			return attributes.GetAttributes(64);
		}
		set
		{
			attributes = attributes.SetAttributes(64, value);
		}
	}

	public bool IsNotSerialized
	{
		get
		{
			return attributes.GetAttributes(128);
		}
		set
		{
			attributes = attributes.SetAttributes(128, value);
		}
	}

	public bool IsSpecialName
	{
		get
		{
			return attributes.GetAttributes(512);
		}
		set
		{
			attributes = attributes.SetAttributes(512, value);
		}
	}

	public bool IsPInvokeImpl
	{
		get
		{
			return attributes.GetAttributes(8192);
		}
		set
		{
			attributes = attributes.SetAttributes(8192, value);
		}
	}

	public bool IsRuntimeSpecialName
	{
		get
		{
			return attributes.GetAttributes(1024);
		}
		set
		{
			attributes = attributes.SetAttributes(1024, value);
		}
	}

	public bool HasDefault
	{
		get
		{
			return attributes.GetAttributes(32768);
		}
		set
		{
			attributes = attributes.SetAttributes(32768, value);
		}
	}

	public override bool IsDefinition => true;

	public new TypeDefinition DeclaringType
	{
		get
		{
			return (TypeDefinition)base.DeclaringType;
		}
		set
		{
			base.DeclaringType = value;
		}
	}

	private void ResolveLayout()
	{
		if (offset != -2)
		{
			return;
		}
		if (!base.HasImage)
		{
			offset = -1;
			return;
		}
		offset = Module.Read(this, (FieldDefinition field, MetadataReader reader) => reader.ReadFieldLayout(field));
	}

	private void ResolveRVA()
	{
		if (rva == -2 && base.HasImage)
		{
			rva = Module.Read(this, (FieldDefinition field, MetadataReader reader) => reader.ReadFieldRVA(field));
		}
	}

	public FieldDefinition(string name, FieldAttributes attributes, TypeReference fieldType)
		: base(name, fieldType)
	{
		this.attributes = (ushort)attributes;
	}

	public override FieldDefinition Resolve()
	{
		return this;
	}
}


using System;
using Mono.Cecil;

public class FieldReference : MemberReference
{
	private TypeReference field_type;

	public TypeReference FieldType
	{
		get
		{
			return field_type;
		}
		set
		{
			field_type = value;
		}
	}

	public override string FullName => field_type.FullName + " " + MemberFullName();

	public override bool ContainsGenericParameter
	{
		get
		{
			if (!field_type.ContainsGenericParameter)
			{
				return base.ContainsGenericParameter;
			}
			return true;
		}
	}

	internal FieldReference()
	{
		token = new MetadataToken(TokenType.MemberRef);
	}

	public FieldReference(string name, TypeReference fieldType)
		: base(name)
	{
		if (fieldType == null)
		{
			throw new ArgumentNullException("fieldType");
		}
		field_type = fieldType;
		token = new MetadataToken(TokenType.MemberRef);
	}

	public FieldReference(string name, TypeReference fieldType, TypeReference declaringType)
		: this(name, fieldType)
	{
		if (declaringType == null)
		{
			throw new ArgumentNullException("declaringType");
		}
		DeclaringType = declaringType;
	}

	public virtual FieldDefinition Resolve()
	{
		return (Module ?? throw new NotSupportedException()).Resolve(this);
	}
}


using Mono.Cecil;

public interface IMemberDefinition : ICustomAttributeProvider, IMetadataTokenProvider
{
	string Name { get; set; }

	string FullName { get; }

	bool IsSpecialName { get; set; }

	bool IsRuntimeSpecialName { get; set; }

	TypeDefinition DeclaringType { get; set; }
}


using Mono.Cecil;

public sealed class LinkedResource : Resource
{
	internal byte[] hash;

	private string file;

	public byte[] Hash => hash;

	public string File
	{
		get
		{
			return file;
		}
		set
		{
			file = value;
		}
	}

	public override ResourceType ResourceType => ResourceType.Linked;

	public LinkedResource(string name, ManifestResourceAttributes flags)
		: base(name, flags)
	{
	}

	public LinkedResource(string name, ManifestResourceAttributes flags, string file)
		: base(name, flags)
	{
		this.file = file;
	}
}


using Mono.Cecil;

public abstract class MemberReference : IMetadataTokenProvider
{
	private string name;

	private TypeReference declaring_type;

	internal MetadataToken token;

	public virtual string Name
	{
		get
		{
			return name;
		}
		set
		{
			name = value;
		}
	}

	public abstract string FullName { get; }

	public virtual TypeReference DeclaringType
	{
		get
		{
			return declaring_type;
		}
		set
		{
			declaring_type = value;
		}
	}

	public MetadataToken MetadataToken
	{
		get
		{
			return token;
		}
		set
		{
			token = value;
		}
	}

	internal bool HasImage => Module?.HasImage ?? false;

	public virtual ModuleDefinition Module
	{
		get
		{
			if (declaring_type == null)
			{
				return null;
			}
			return declaring_type.Module;
		}
	}

	public virtual bool IsDefinition => false;

	public virtual bool ContainsGenericParameter
	{
		get
		{
			if (declaring_type != null)
			{
				return declaring_type.ContainsGenericParameter;
			}
			return false;
		}
	}

	internal MemberReference()
	{
	}

	internal MemberReference(string name)
	{
		this.name = name ?? string.Empty;
	}

	internal string MemberFullName()
	{
		if (declaring_type == null)
		{
			return name;
		}
		return declaring_type.FullName + "::" + name;
	}

	public override string ToString()
	{
		return FullName;
	}
}


using System;

[Flags]
public enum MethodAttributes : ushort
{
	MemberAccessMask = 7,
	CompilerControlled = 0,
	Private = 1,
	FamANDAssem = 2,
	Assembly = 3,
	Family = 4,
	FamORAssem = 5,
	Public = 6,
	Static = 0x10,
	Final = 0x20,
	Virtual = 0x40,
	HideBySig = 0x80,
	VtableLayoutMask = 0x100,
	ReuseSlot = 0,
	NewSlot = 0x100,
	CheckAccessOnOverride = 0x200,
	Abstract = 0x400,
	SpecialName = 0x800,
	PInvokeImpl = 0x2000,
	UnmanagedExport = 8,
	RTSpecialName = 0x1000,
	HasSecurity = 0x4000,
	RequireSecObject = 0x8000
}


public enum MethodCallingConvention : byte
{
	Default = 0,
	C = 1,
	StdCall = 2,
	ThisCall = 3,
	FastCall = 4,
	VarArg = 5,
	Generic = 16
}


using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Collections.Generic;

public sealed class MethodDefinition : MethodReference, IMemberDefinition, ICustomAttributeProvider, IMetadataTokenProvider, ISecurityDeclarationProvider
{
	private ushort attributes;

	private ushort impl_attributes;

	internal volatile bool sem_attrs_ready;

	internal MethodSemanticsAttributes sem_attrs;

	private Collection<CustomAttribute> custom_attributes;

	private Collection<SecurityDeclaration> security_declarations;

	internal uint rva;

	internal PInvokeInfo pinvoke;

	private Collection<MethodReference> overrides;

	internal MethodBody body;

	public MethodAttributes Attributes
	{
		get
		{
			return (MethodAttributes)attributes;
		}
		set
		{
			attributes = (ushort)value;
		}
	}

	public MethodImplAttributes ImplAttributes
	{
		get
		{
			return (MethodImplAttributes)impl_attributes;
		}
		set
		{
			impl_attributes = (ushort)value;
		}
	}

	public MethodSemanticsAttributes SemanticsAttributes
	{
		get
		{
			if (sem_attrs_ready)
			{
				return sem_attrs;
			}
			if (base.HasImage)
			{
				ReadSemantics();
				return sem_attrs;
			}
			sem_attrs = MethodSemanticsAttributes.None;
			sem_attrs_ready = true;
			return sem_attrs;
		}
		set
		{
			sem_attrs = value;
		}
	}

	public bool HasSecurityDeclarations
	{
		get
		{
			if (security_declarations != null)
			{
				return security_declarations.Count > 0;
			}
			return this.GetHasSecurityDeclarations(Module);
		}
	}

	public Collection<SecurityDeclaration> SecurityDeclarations => security_declarations ?? this.GetSecurityDeclarations(ref security_declarations, Module);

	public bool HasCustomAttributes
	{
		get
		{
			if (custom_attributes != null)
			{
				return custom_attributes.Count > 0;
			}
			return this.GetHasCustomAttributes(Module);
		}
	}

	public Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, Module);

	public int RVA => (int)rva;

	public bool HasBody
	{
		get
		{
			if ((attributes & 0x400) == 0 && (attributes & 0x2000) == 0 && (impl_attributes & 0x1000) == 0 && (impl_attributes & 1) == 0 && (impl_attributes & 4) == 0)
			{
				return (impl_attributes & 3) == 0;
			}
			return false;
		}
	}

	public MethodBody Body
	{
		get
		{
			MethodBody methodBody = body;
			if (methodBody != null)
			{
				return methodBody;
			}
			if (!HasBody)
			{
				return null;
			}
			if (base.HasImage && rva != 0)
			{
				return Module.Read(ref body, this, (MethodDefinition method, MetadataReader reader) => reader.ReadMethodBody(method));
			}
			return body = new MethodBody(this);
		}
		set
		{
			ModuleDefinition module = Module;
			if (module == null)
			{
				body = value;
				return;
			}
			lock (module.SyncRoot)
			{
				body = value;
			}
		}
	}

	public bool HasPInvokeInfo
	{
		get
		{
			if (pinvoke != null)
			{
				return true;
			}
			return IsPInvokeImpl;
		}
	}

	public PInvokeInfo PInvokeInfo
	{
		get
		{
			if (pinvoke != null)
			{
				return pinvoke;
			}
			if (base.HasImage && IsPInvokeImpl)
			{
				return Module.Read(ref pinvoke, this, (MethodDefinition method, MetadataReader reader) => reader.ReadPInvokeInfo(method));
			}
			return null;
		}
		set
		{
			IsPInvokeImpl = true;
			pinvoke = value;
		}
	}

	public bool HasOverrides
	{
		get
		{
			if (overrides != null)
			{
				return overrides.Count > 0;
			}
			if (base.HasImage)
			{
				return Module.Read(this, (MethodDefinition method, MetadataReader reader) => reader.HasOverrides(method));
			}
			return false;
		}
	}

	public Collection<MethodReference> Overrides
	{
		get
		{
			if (overrides != null)
			{
				return overrides;
			}
			if (base.HasImage)
			{
				return Module.Read(ref overrides, this, (MethodDefinition method, MetadataReader reader) => reader.ReadOverrides(method));
			}
			return overrides = new Collection<MethodReference>();
		}
	}

	public override bool HasGenericParameters
	{
		get
		{
			if (generic_parameters != null)
			{
				return generic_parameters.Count > 0;
			}
			return this.GetHasGenericParameters(Module);
		}
	}

	public override Collection<GenericParameter> GenericParameters => generic_parameters ?? this.GetGenericParameters(ref generic_parameters, Module);

	public bool IsCompilerControlled
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 0u, value);
		}
	}

	public bool IsPrivate
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 1u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 1u, value);
		}
	}

	public bool IsFamilyAndAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 2u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 2u, value);
		}
	}

	public bool IsAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 3u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 3u, value);
		}
	}

	public bool IsFamily
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 4u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 4u, value);
		}
	}

	public bool IsFamilyOrAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 5u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 5u, value);
		}
	}

	public bool IsPublic
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 6u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 6u, value);
		}
	}

	public bool IsStatic
	{
		get
		{
			return attributes.GetAttributes(16);
		}
		set
		{
			attributes = attributes.SetAttributes(16, value);
		}
	}

	public bool IsFinal
	{
		get
		{
			return attributes.GetAttributes(32);
		}
		set
		{
			attributes = attributes.SetAttributes(32, value);
		}
	}

	public bool IsVirtual
	{
		get
		{
			return attributes.GetAttributes(64);
		}
		set
		{
			attributes = attributes.SetAttributes(64, value);
		}
	}

	public bool IsHideBySig
	{
		get
		{
			return attributes.GetAttributes(128);
		}
		set
		{
			attributes = attributes.SetAttributes(128, value);
		}
	}

	public bool IsReuseSlot
	{
		get
		{
			return attributes.GetMaskedAttributes(256, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(256, 0u, value);
		}
	}

	public bool IsNewSlot
	{
		get
		{
			return attributes.GetMaskedAttributes(256, 256u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(256, 256u, value);
		}
	}

	public bool IsCheckAccessOnOverride
	{
		get
		{
			return attributes.GetAttributes(512);
		}
		set
		{
			attributes = attributes.SetAttributes(512, value);
		}
	}

	public bool IsAbstract
	{
		get
		{
			return attributes.GetAttributes(1024);
		}
		set
		{
			attributes = attributes.SetAttributes(1024, value);
		}
	}

	public bool IsSpecialName
	{
		get
		{
			return attributes.GetAttributes(2048);
		}
		set
		{
			attributes = attributes.SetAttributes(2048, value);
		}
	}

	public bool IsPInvokeImpl
	{
		get
		{
			return attributes.GetAttributes(8192);
		}
		set
		{
			attributes = attributes.SetAttributes(8192, value);
		}
	}

	public bool IsUnmanagedExport
	{
		get
		{
			return attributes.GetAttributes(8);
		}
		set
		{
			attributes = attributes.SetAttributes(8, value);
		}
	}

	public bool IsRuntimeSpecialName
	{
		get
		{
			return attributes.GetAttributes(4096);
		}
		set
		{
			attributes = attributes.SetAttributes(4096, value);
		}
	}

	public bool HasSecurity
	{
		get
		{
			return attributes.GetAttributes(16384);
		}
		set
		{
			attributes = attributes.SetAttributes(16384, value);
		}
	}

	public bool IsIL
	{
		get
		{
			return impl_attributes.GetMaskedAttributes(3, 0u);
		}
		set
		{
			impl_attributes = impl_attributes.SetMaskedAttributes(3, 0u, value);
		}
	}

	public bool IsNative
	{
		get
		{
			return impl_attributes.GetMaskedAttributes(3, 1u);
		}
		set
		{
			impl_attributes = impl_attributes.SetMaskedAttributes(3, 1u, value);
		}
	}

	public bool IsRuntime
	{
		get
		{
			return impl_attributes.GetMaskedAttributes(3, 3u);
		}
		set
		{
			impl_attributes = impl_attributes.SetMaskedAttributes(3, 3u, value);
		}
	}

	public bool IsUnmanaged
	{
		get
		{
			return impl_attributes.GetMaskedAttributes(4, 4u);
		}
		set
		{
			impl_attributes = impl_attributes.SetMaskedAttributes(4, 4u, value);
		}
	}

	public bool IsManaged
	{
		get
		{
			return impl_attributes.GetMaskedAttributes(4, 0u);
		}
		set
		{
			impl_attributes = impl_attributes.SetMaskedAttributes(4, 0u, value);
		}
	}

	public bool IsForwardRef
	{
		get
		{
			return impl_attributes.GetAttributes(16);
		}
		set
		{
			impl_attributes = impl_attributes.SetAttributes(16, value);
		}
	}

	public bool IsPreserveSig
	{
		get
		{
			return impl_attributes.GetAttributes(128);
		}
		set
		{
			impl_attributes = impl_attributes.SetAttributes(128, value);
		}
	}

	public bool IsInternalCall
	{
		get
		{
			return impl_attributes.GetAttributes(4096);
		}
		set
		{
			impl_attributes = impl_attributes.SetAttributes(4096, value);
		}
	}

	public bool IsSynchronized
	{
		get
		{
			return impl_attributes.GetAttributes(32);
		}
		set
		{
			impl_attributes = impl_attributes.SetAttributes(32, value);
		}
	}

	public bool NoInlining
	{
		get
		{
			return impl_attributes.GetAttributes(8);
		}
		set
		{
			impl_attributes = impl_attributes.SetAttributes(8, value);
		}
	}

	public bool NoOptimization
	{
		get
		{
			return impl_attributes.GetAttributes(64);
		}
		set
		{
			impl_attributes = impl_attributes.SetAttributes(64, value);
		}
	}

	public bool IsSetter
	{
		get
		{
			return this.GetSemantics(MethodSemanticsAttributes.Setter);
		}
		set
		{
			this.SetSemantics(MethodSemanticsAttributes.Setter, value);
		}
	}

	public bool IsGetter
	{
		get
		{
			return this.GetSemantics(MethodSemanticsAttributes.Getter);
		}
		set
		{
			this.SetSemantics(MethodSemanticsAttributes.Getter, value);
		}
	}

	public bool IsOther
	{
		get
		{
			return this.GetSemantics(MethodSemanticsAttributes.Other);
		}
		set
		{
			this.SetSemantics(MethodSemanticsAttributes.Other, value);
		}
	}

	public bool IsAddOn
	{
		get
		{
			return this.GetSemantics(MethodSemanticsAttributes.AddOn);
		}
		set
		{
			this.SetSemantics(MethodSemanticsAttributes.AddOn, value);
		}
	}

	public bool IsRemoveOn
	{
		get
		{
			return this.GetSemantics(MethodSemanticsAttributes.RemoveOn);
		}
		set
		{
			this.SetSemantics(MethodSemanticsAttributes.RemoveOn, value);
		}
	}

	public bool IsFire
	{
		get
		{
			return this.GetSemantics(MethodSemanticsAttributes.Fire);
		}
		set
		{
			this.SetSemantics(MethodSemanticsAttributes.Fire, value);
		}
	}

	public new TypeDefinition DeclaringType
	{
		get
		{
			return (TypeDefinition)base.DeclaringType;
		}
		set
		{
			base.DeclaringType = value;
		}
	}

	public bool IsConstructor
	{
		get
		{
			if (IsRuntimeSpecialName && IsSpecialName)
			{
				if (!(Name == ".cctor"))
				{
					return Name == ".ctor";
				}
				return true;
			}
			return false;
		}
	}

	public override bool IsDefinition => true;

	internal void ReadSemantics()
	{
		if (sem_attrs_ready)
		{
			return;
		}
		ModuleDefinition module = Module;
		if (module != null && module.HasImage)
		{
			module.Read(this, (MethodDefinition method, MetadataReader reader) => reader.ReadAllSemantics(method));
		}
	}

	internal MethodDefinition()
	{
		token = new MetadataToken(TokenType.Method);
	}

	public MethodDefinition(string name, MethodAttributes attributes, TypeReference returnType)
		: base(name, returnType)
	{
		this.attributes = (ushort)attributes;
		HasThis = !IsStatic;
		token = new MetadataToken(TokenType.Method);
	}

	public override MethodDefinition Resolve()
	{
		return this;
	}
}


using System;

[Flags]
public enum MethodImplAttributes : ushort
{
	CodeTypeMask = 3,
	IL = 0,
	Native = 1,
	OPTIL = 2,
	Runtime = 3,
	ManagedMask = 4,
	Unmanaged = 4,
	Managed = 0,
	ForwardRef = 0x10,
	PreserveSig = 0x80,
	InternalCall = 0x1000,
	Synchronized = 0x20,
	NoOptimization = 0x40,
	NoInlining = 8
}


using System;
using System.Text;
using Mono.Cecil;
using Mono.Collections.Generic;

public class MethodReference : MemberReference, IMethodSignature, IMetadataTokenProvider, IGenericParameterProvider, IGenericContext
{
	internal ParameterDefinitionCollection parameters;

	private MethodReturnType return_type;

	private bool has_this;

	private bool explicit_this;

	private MethodCallingConvention calling_convention;

	internal Collection<GenericParameter> generic_parameters;

	public virtual bool HasThis
	{
		get
		{
			return has_this;
		}
		set
		{
			has_this = value;
		}
	}

	public virtual bool ExplicitThis
	{
		get
		{
			return explicit_this;
		}
		set
		{
			explicit_this = value;
		}
	}

	public virtual MethodCallingConvention CallingConvention
	{
		get
		{
			return calling_convention;
		}
		set
		{
			calling_convention = value;
		}
	}

	public virtual bool HasParameters => !parameters.IsNullOrEmpty();

	public virtual Collection<ParameterDefinition> Parameters
	{
		get
		{
			if (parameters == null)
			{
				parameters = new ParameterDefinitionCollection(this);
			}
			return parameters;
		}
	}

	IGenericParameterProvider IGenericContext.Type
	{
		get
		{
			TypeReference declaringType = DeclaringType;
			if (declaringType is GenericInstanceType genericInstanceType)
			{
				return genericInstanceType.ElementType;
			}
			return declaringType;
		}
	}

	IGenericParameterProvider IGenericContext.Method => this;

	GenericParameterType IGenericParameterProvider.GenericParameterType => GenericParameterType.Method;

	public virtual bool HasGenericParameters => !generic_parameters.IsNullOrEmpty();

	public virtual Collection<GenericParameter> GenericParameters
	{
		get
		{
			if (generic_parameters != null)
			{
				return generic_parameters;
			}
			return generic_parameters = new GenericParameterCollection(this);
		}
	}

	public TypeReference ReturnType
	{
		get
		{
			return MethodReturnType?.ReturnType;
		}
		set
		{
			MethodReturnType methodReturnType = MethodReturnType;
			if (methodReturnType != null)
			{
				methodReturnType.ReturnType = value;
			}
		}
	}

	public virtual MethodReturnType MethodReturnType
	{
		get
		{
			return return_type;
		}
		set
		{
			return_type = value;
		}
	}

	public override string FullName
	{
		get
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(ReturnType.FullName).Append(" ").Append(MemberFullName());
			this.MethodSignatureFullName(stringBuilder);
			return stringBuilder.ToString();
		}
	}

	public virtual bool IsGenericInstance => false;

	public override bool ContainsGenericParameter
	{
		get
		{
			if (ReturnType.ContainsGenericParameter || base.ContainsGenericParameter)
			{
				return true;
			}
			Collection<ParameterDefinition> collection = Parameters;
			for (int i = 0; i < collection.Count; i++)
			{
				if (collection[i].ParameterType.ContainsGenericParameter)
				{
					return true;
				}
			}
			return false;
		}
	}

	internal MethodReference()
	{
		return_type = new MethodReturnType(this);
		token = new MetadataToken(TokenType.MemberRef);
	}

	public MethodReference(string name, TypeReference returnType)
		: base(name)
	{
		if (returnType == null)
		{
			throw new ArgumentNullException("returnType");
		}
		return_type = new MethodReturnType(this);
		return_type.ReturnType = returnType;
		token = new MetadataToken(TokenType.MemberRef);
	}

	public MethodReference(string name, TypeReference returnType, TypeReference declaringType)
		: this(name, returnType)
	{
		if (declaringType == null)
		{
			throw new ArgumentNullException("declaringType");
		}
		DeclaringType = declaringType;
	}

	public virtual MethodReference GetElementMethod()
	{
		return this;
	}

	public virtual MethodDefinition Resolve()
	{
		return (Module ?? throw new NotSupportedException()).Resolve(this);
	}
}


using System.Threading;
using Mono.Cecil;
using Mono.Collections.Generic;

public sealed class MethodReturnType : IConstantProvider, IMetadataTokenProvider, ICustomAttributeProvider, IMarshalInfoProvider
{
	internal IMethodSignature method;

	internal ParameterDefinition parameter;

	private TypeReference return_type;

	public IMethodSignature Method => method;

	public TypeReference ReturnType
	{
		get
		{
			return return_type;
		}
		set
		{
			return_type = value;
		}
	}

	internal ParameterDefinition Parameter
	{
		get
		{
			if (parameter == null)
			{
				Interlocked.CompareExchange(ref parameter, new ParameterDefinition(return_type, method), null);
			}
			return parameter;
		}
	}

	public MetadataToken MetadataToken
	{
		get
		{
			return Parameter.MetadataToken;
		}
		set
		{
			Parameter.MetadataToken = value;
		}
	}

	public ParameterAttributes Attributes
	{
		get
		{
			return Parameter.Attributes;
		}
		set
		{
			Parameter.Attributes = value;
		}
	}

	public bool HasCustomAttributes
	{
		get
		{
			if (parameter != null)
			{
				return parameter.HasCustomAttributes;
			}
			return false;
		}
	}

	public Collection<CustomAttribute> CustomAttributes => Parameter.CustomAttributes;

	public bool HasDefault
	{
		get
		{
			if (parameter != null)
			{
				return parameter.HasDefault;
			}
			return false;
		}
		set
		{
			Parameter.HasDefault = value;
		}
	}

	public bool HasConstant
	{
		get
		{
			if (parameter != null)
			{
				return parameter.HasConstant;
			}
			return false;
		}
		set
		{
			Parameter.HasConstant = value;
		}
	}

	public object Constant
	{
		get
		{
			return Parameter.Constant;
		}
		set
		{
			Parameter.Constant = value;
		}
	}

	public bool HasFieldMarshal
	{
		get
		{
			if (parameter != null)
			{
				return parameter.HasFieldMarshal;
			}
			return false;
		}
		set
		{
			Parameter.HasFieldMarshal = value;
		}
	}

	public bool HasMarshalInfo
	{
		get
		{
			if (parameter != null)
			{
				return parameter.HasMarshalInfo;
			}
			return false;
		}
	}

	public MarshalInfo MarshalInfo
	{
		get
		{
			return Parameter.MarshalInfo;
		}
		set
		{
			Parameter.MarshalInfo = value;
		}
	}

	public MethodReturnType(IMethodSignature method)
	{
		this.method = method;
	}
}


using System;

[Flags]
public enum MethodSemanticsAttributes : ushort
{
	None = 0,
	Setter = 1,
	Getter = 2,
	Other = 4,
	AddOn = 8,
	RemoveOn = 0x10,
	Fire = 0x20
}


using System;
using Mono.Cecil;
using Mono.Collections.Generic;

public abstract class MethodSpecification : MethodReference
{
	private readonly MethodReference method;

	public MethodReference ElementMethod => method;

	public override string Name
	{
		get
		{
			return method.Name;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override MethodCallingConvention CallingConvention
	{
		get
		{
			return method.CallingConvention;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override bool HasThis
	{
		get
		{
			return method.HasThis;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override bool ExplicitThis
	{
		get
		{
			return method.ExplicitThis;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override MethodReturnType MethodReturnType
	{
		get
		{
			return method.MethodReturnType;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override TypeReference DeclaringType
	{
		get
		{
			return method.DeclaringType;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override ModuleDefinition Module => method.Module;

	public override bool HasParameters => method.HasParameters;

	public override Collection<ParameterDefinition> Parameters => method.Parameters;

	public override bool ContainsGenericParameter => method.ContainsGenericParameter;

	internal MethodSpecification(MethodReference method)
	{
		if (method == null)
		{
			throw new ArgumentNullException("method");
		}
		this.method = method;
		token = new MetadataToken(TokenType.MethodSpec);
	}

	public sealed override MethodReference GetElementMethod()
	{
		return method.GetElementMethod();
	}
}


using System;

[Flags]
public enum ParameterAttributes : ushort
{
	None = 0,
	In = 1,
	Out = 2,
	Lcid = 4,
	Retval = 8,
	Optional = 0x10,
	HasDefault = 0x1000,
	HasFieldMarshal = 0x2000,
	Unused = 0xCFE0
}


using Mono.Cecil;
using Mono.Collections.Generic;

public sealed class ParameterDefinition : ParameterReference, ICustomAttributeProvider, IMetadataTokenProvider, IConstantProvider, IMarshalInfoProvider
{
	private ushort attributes;

	internal IMethodSignature method;

	private object constant = Mixin.NotResolved;

	private Collection<CustomAttribute> custom_attributes;

	private MarshalInfo marshal_info;

	public ParameterAttributes Attributes
	{
		get
		{
			return (ParameterAttributes)attributes;
		}
		set
		{
			attributes = (ushort)value;
		}
	}

	public IMethodSignature Method => method;

	public int Sequence
	{
		get
		{
			if (method == null)
			{
				return -1;
			}
			if (!method.HasImplicitThis())
			{
				return index;
			}
			return index + 1;
		}
	}

	public bool HasConstant
	{
		get
		{
			this.ResolveConstant(ref constant, parameter_type.Module);
			return constant != Mixin.NoValue;
		}
		set
		{
			if (!value)
			{
				constant = Mixin.NoValue;
			}
		}
	}

	public object Constant
	{
		get
		{
			if (!HasConstant)
			{
				return null;
			}
			return constant;
		}
		set
		{
			constant = value;
		}
	}

	public bool HasCustomAttributes
	{
		get
		{
			if (custom_attributes != null)
			{
				return custom_attributes.Count > 0;
			}
			return this.GetHasCustomAttributes(parameter_type.Module);
		}
	}

	public Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, parameter_type.Module);

	public bool HasMarshalInfo
	{
		get
		{
			if (marshal_info != null)
			{
				return true;
			}
			return this.GetHasMarshalInfo(parameter_type.Module);
		}
	}

	public MarshalInfo MarshalInfo
	{
		get
		{
			return marshal_info ?? this.GetMarshalInfo(ref marshal_info, parameter_type.Module);
		}
		set
		{
			marshal_info = value;
		}
	}

	public bool IsIn
	{
		get
		{
			return attributes.GetAttributes(1);
		}
		set
		{
			attributes = attributes.SetAttributes(1, value);
		}
	}

	public bool IsOut
	{
		get
		{
			return attributes.GetAttributes(2);
		}
		set
		{
			attributes = attributes.SetAttributes(2, value);
		}
	}

	public bool IsLcid
	{
		get
		{
			return attributes.GetAttributes(4);
		}
		set
		{
			attributes = attributes.SetAttributes(4, value);
		}
	}

	public bool IsReturnValue
	{
		get
		{
			return attributes.GetAttributes(8);
		}
		set
		{
			attributes = attributes.SetAttributes(8, value);
		}
	}

	public bool IsOptional
	{
		get
		{
			return attributes.GetAttributes(16);
		}
		set
		{
			attributes = attributes.SetAttributes(16, value);
		}
	}

	public bool HasDefault
	{
		get
		{
			return attributes.GetAttributes(4096);
		}
		set
		{
			attributes = attributes.SetAttributes(4096, value);
		}
	}

	public bool HasFieldMarshal
	{
		get
		{
			return attributes.GetAttributes(8192);
		}
		set
		{
			attributes = attributes.SetAttributes(8192, value);
		}
	}

	internal ParameterDefinition(TypeReference parameterType, IMethodSignature method)
		: this(string.Empty, ParameterAttributes.None, parameterType)
	{
		this.method = method;
	}

	public ParameterDefinition(TypeReference parameterType)
		: this(string.Empty, ParameterAttributes.None, parameterType)
	{
	}

	public ParameterDefinition(string name, ParameterAttributes attributes, TypeReference parameterType)
		: base(name, parameterType)
	{
		this.attributes = (ushort)attributes;
		token = new MetadataToken(TokenType.Param);
	}

	public override ParameterDefinition Resolve()
	{
		return this;
	}
}


using System;
using Mono.Cecil;

public abstract class ParameterReference : IMetadataTokenProvider
{
	private string name;

	internal int index = -1;

	protected TypeReference parameter_type;

	internal MetadataToken token;

	public string Name
	{
		get
		{
			return name;
		}
		set
		{
			name = value;
		}
	}

	public int Index => index;

	public TypeReference ParameterType
	{
		get
		{
			return parameter_type;
		}
		set
		{
			parameter_type = value;
		}
	}

	public MetadataToken MetadataToken
	{
		get
		{
			return token;
		}
		set
		{
			token = value;
		}
	}

	internal ParameterReference(string name, TypeReference parameterType)
	{
		if (parameterType == null)
		{
			throw new ArgumentNullException("parameterType");
		}
		this.name = name ?? string.Empty;
		parameter_type = parameterType;
	}

	public override string ToString()
	{
		return name;
	}

	public abstract ParameterDefinition Resolve();
}


using System;

[Flags]
public enum PInvokeAttributes : ushort
{
	NoMangle = 1,
	CharSetMask = 6,
	CharSetNotSpec = 0,
	CharSetAnsi = 2,
	CharSetUnicode = 4,
	CharSetAuto = 6,
	SupportsLastError = 0x40,
	CallConvMask = 0x700,
	CallConvWinapi = 0x100,
	CallConvCdecl = 0x200,
	CallConvStdCall = 0x300,
	CallConvThiscall = 0x400,
	CallConvFastcall = 0x500,
	BestFitMask = 0x30,
	BestFitEnabled = 0x10,
	BestFitDisabled = 0x20,
	ThrowOnUnmappableCharMask = 0x3000,
	ThrowOnUnmappableCharEnabled = 0x1000,
	ThrowOnUnmappableCharDisabled = 0x2000
}


using Mono.Cecil;

public sealed class PInvokeInfo
{
	private ushort attributes;

	private string entry_point;

	private ModuleReference module;

	public PInvokeAttributes Attributes
	{
		get
		{
			return (PInvokeAttributes)attributes;
		}
		set
		{
			attributes = (ushort)value;
		}
	}

	public string EntryPoint
	{
		get
		{
			return entry_point;
		}
		set
		{
			entry_point = value;
		}
	}

	public ModuleReference Module
	{
		get
		{
			return module;
		}
		set
		{
			module = value;
		}
	}

	public bool IsNoMangle
	{
		get
		{
			return attributes.GetAttributes(1);
		}
		set
		{
			attributes = attributes.SetAttributes(1, value);
		}
	}

	public bool IsCharSetNotSpec
	{
		get
		{
			return attributes.GetMaskedAttributes(6, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(6, 0u, value);
		}
	}

	public bool IsCharSetAnsi
	{
		get
		{
			return attributes.GetMaskedAttributes(6, 2u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(6, 2u, value);
		}
	}

	public bool IsCharSetUnicode
	{
		get
		{
			return attributes.GetMaskedAttributes(6, 4u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(6, 4u, value);
		}
	}

	public bool IsCharSetAuto
	{
		get
		{
			return attributes.GetMaskedAttributes(6, 6u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(6, 6u, value);
		}
	}

	public bool SupportsLastError
	{
		get
		{
			return attributes.GetAttributes(64);
		}
		set
		{
			attributes = attributes.SetAttributes(64, value);
		}
	}

	public bool IsCallConvWinapi
	{
		get
		{
			return attributes.GetMaskedAttributes(1792, 256u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(1792, 256u, value);
		}
	}

	public bool IsCallConvCdecl
	{
		get
		{
			return attributes.GetMaskedAttributes(1792, 512u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(1792, 512u, value);
		}
	}

	public bool IsCallConvStdCall
	{
		get
		{
			return attributes.GetMaskedAttributes(1792, 768u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(1792, 768u, value);
		}
	}

	public bool IsCallConvThiscall
	{
		get
		{
			return attributes.GetMaskedAttributes(1792, 1024u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(1792, 1024u, value);
		}
	}

	public bool IsCallConvFastcall
	{
		get
		{
			return attributes.GetMaskedAttributes(1792, 1280u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(1792, 1280u, value);
		}
	}

	public bool IsBestFitEnabled
	{
		get
		{
			return attributes.GetMaskedAttributes(48, 16u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(48, 16u, value);
		}
	}

	public bool IsBestFitDisabled
	{
		get
		{
			return attributes.GetMaskedAttributes(48, 32u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(48, 32u, value);
		}
	}

	public bool IsThrowOnUnmappableCharEnabled
	{
		get
		{
			return attributes.GetMaskedAttributes(12288, 4096u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(12288, 4096u, value);
		}
	}

	public bool IsThrowOnUnmappableCharDisabled
	{
		get
		{
			return attributes.GetMaskedAttributes(12288, 8192u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(12288, 8192u, value);
		}
	}

	public PInvokeInfo(PInvokeAttributes attributes, string entryPoint, ModuleReference module)
	{
		this.attributes = (ushort)attributes;
		entry_point = entryPoint;
		this.module = module;
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Metadata;

public sealed class PointerType : TypeSpecification
{
	public override string Name => base.Name + "*";

	public override string FullName => base.FullName + "*";

	public override bool IsValueType
	{
		get
		{
			return false;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override bool IsPointer => true;

	public PointerType(TypeReference type)
		: base(type)
	{
		Mixin.CheckType(type);
		etype = Mono.Cecil.Metadata.ElementType.Ptr;
	}
}


using System;

[Flags]
public enum PropertyAttributes : ushort
{
	None = 0,
	SpecialName = 0x200,
	RTSpecialName = 0x400,
	HasDefault = 0x1000,
	Unused = 0xE9FF
}


using System.Text;
using Mono.Cecil;
using Mono.Collections.Generic;

public sealed class PropertyDefinition : PropertyReference, IMemberDefinition, ICustomAttributeProvider, IMetadataTokenProvider, IConstantProvider
{
	private bool? has_this;

	private ushort attributes;

	private Collection<CustomAttribute> custom_attributes;

	internal MethodDefinition get_method;

	internal MethodDefinition set_method;

	internal Collection<MethodDefinition> other_methods;

	private object constant = Mixin.NotResolved;

	public PropertyAttributes Attributes
	{
		get
		{
			return (PropertyAttributes)attributes;
		}
		set
		{
			attributes = (ushort)value;
		}
	}

	public bool HasThis
	{
		get
		{
			if (has_this.HasValue)
			{
				return has_this.Value;
			}
			if (GetMethod != null)
			{
				return get_method.HasThis;
			}
			if (SetMethod != null)
			{
				return set_method.HasThis;
			}
			return false;
		}
		set
		{
			has_this = value;
		}
	}

	public bool HasCustomAttributes
	{
		get
		{
			if (custom_attributes != null)
			{
				return custom_attributes.Count > 0;
			}
			return this.GetHasCustomAttributes(Module);
		}
	}

	public Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, Module);

	public MethodDefinition GetMethod
	{
		get
		{
			if (get_method != null)
			{
				return get_method;
			}
			InitializeMethods();
			return get_method;
		}
		set
		{
			get_method = value;
		}
	}

	public MethodDefinition SetMethod
	{
		get
		{
			if (set_method != null)
			{
				return set_method;
			}
			InitializeMethods();
			return set_method;
		}
		set
		{
			set_method = value;
		}
	}

	public bool HasOtherMethods
	{
		get
		{
			if (other_methods != null)
			{
				return other_methods.Count > 0;
			}
			InitializeMethods();
			return !other_methods.IsNullOrEmpty();
		}
	}

	public Collection<MethodDefinition> OtherMethods
	{
		get
		{
			if (other_methods != null)
			{
				return other_methods;
			}
			InitializeMethods();
			if (other_methods != null)
			{
				return other_methods;
			}
			return other_methods = new Collection<MethodDefinition>();
		}
	}

	public bool HasParameters
	{
		get
		{
			InitializeMethods();
			if (get_method != null)
			{
				return get_method.HasParameters;
			}
			if (set_method != null)
			{
				if (set_method.HasParameters)
				{
					return set_method.Parameters.Count > 1;
				}
				return false;
			}
			return false;
		}
	}

	public override Collection<ParameterDefinition> Parameters
	{
		get
		{
			InitializeMethods();
			if (get_method != null)
			{
				return MirrorParameters(get_method, 0);
			}
			if (set_method != null)
			{
				return MirrorParameters(set_method, 1);
			}
			return new Collection<ParameterDefinition>();
		}
	}

	public bool HasConstant
	{
		get
		{
			this.ResolveConstant(ref constant, Module);
			return constant != Mixin.NoValue;
		}
		set
		{
			if (!value)
			{
				constant = Mixin.NoValue;
			}
		}
	}

	public object Constant
	{
		get
		{
			if (!HasConstant)
			{
				return null;
			}
			return constant;
		}
		set
		{
			constant = value;
		}
	}

	public bool IsSpecialName
	{
		get
		{
			return attributes.GetAttributes(512);
		}
		set
		{
			attributes = attributes.SetAttributes(512, value);
		}
	}

	public bool IsRuntimeSpecialName
	{
		get
		{
			return attributes.GetAttributes(1024);
		}
		set
		{
			attributes = attributes.SetAttributes(1024, value);
		}
	}

	public bool HasDefault
	{
		get
		{
			return attributes.GetAttributes(4096);
		}
		set
		{
			attributes = attributes.SetAttributes(4096, value);
		}
	}

	public new TypeDefinition DeclaringType
	{
		get
		{
			return (TypeDefinition)base.DeclaringType;
		}
		set
		{
			base.DeclaringType = value;
		}
	}

	public override bool IsDefinition => true;

	public override string FullName
	{
		get
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(base.PropertyType.ToString());
			stringBuilder.Append(' ');
			stringBuilder.Append(MemberFullName());
			stringBuilder.Append('(');
			if (HasParameters)
			{
				Collection<ParameterDefinition> parameters = Parameters;
				for (int i = 0; i < parameters.Count; i++)
				{
					if (i > 0)
					{
						stringBuilder.Append(',');
					}
					stringBuilder.Append(parameters[i].ParameterType.FullName);
				}
			}
			stringBuilder.Append(')');
			return stringBuilder.ToString();
		}
	}

	private static Collection<ParameterDefinition> MirrorParameters(MethodDefinition method, int bound)
	{
		Collection<ParameterDefinition> collection = new Collection<ParameterDefinition>();
		if (!method.HasParameters)
		{
			return collection;
		}
		Collection<ParameterDefinition> parameters = method.Parameters;
		int num = parameters.Count - bound;
		for (int i = 0; i < num; i++)
		{
			collection.Add(parameters[i]);
		}
		return collection;
	}

	public PropertyDefinition(string name, PropertyAttributes attributes, TypeReference propertyType)
		: base(name, propertyType)
	{
		this.attributes = (ushort)attributes;
		token = new MetadataToken(TokenType.Property);
	}

	private void InitializeMethods()
	{
		ModuleDefinition module = Module;
		if (module == null)
		{
			return;
		}
		lock (module.SyncRoot)
		{
			if (get_method == null && set_method == null && module.HasImage())
			{
				module.Read(this, (PropertyDefinition property, MetadataReader reader) => reader.ReadMethods(property));
			}
		}
	}

	public override PropertyDefinition Resolve()
	{
		return this;
	}
}


using System;
using Mono.Cecil;
using Mono.Collections.Generic;

public abstract class PropertyReference : MemberReference
{
	private TypeReference property_type;

	public TypeReference PropertyType
	{
		get
		{
			return property_type;
		}
		set
		{
			property_type = value;
		}
	}

	public abstract Collection<ParameterDefinition> Parameters { get; }

	internal PropertyReference(string name, TypeReference propertyType)
		: base(name)
	{
		if (propertyType == null)
		{
			throw new ArgumentNullException("propertyType");
		}
		property_type = propertyType;
	}

	public abstract PropertyDefinition Resolve();
}


using System;
using Mono.Cecil;
using Mono.Cecil.Metadata;

public sealed class ByReferenceType : TypeSpecification
{
	public override string Name => base.Name + "&";

	public override string FullName => base.FullName + "&";

	public override bool IsValueType
	{
		get
		{
			return false;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override bool IsByReference => true;

	public ByReferenceType(TypeReference type)
		: base(type)
	{
		Mixin.CheckType(type);
		etype = Mono.Cecil.Metadata.ElementType.ByRef;
	}
}


public enum MetadataScopeType
{
	AssemblyNameReference,
	ModuleReference,
	ModuleDefinition
}


using Mono.Cecil;

public interface IMetadataScope : IMetadataTokenProvider
{
	MetadataScopeType MetadataScopeType { get; }

	string Name { get; set; }
}


using Mono.Cecil;

public interface IMetadataTokenProvider
{
	MetadataToken MetadataToken { get; set; }
}


using System;

[Flags]
public enum ManifestResourceAttributes : uint
{
	VisibilityMask = 7u,
	Public = 1u,
	Private = 2u
}


using Mono.Cecil;

public class ModuleReference : IMetadataScope, IMetadataTokenProvider
{
	private string name;

	internal MetadataToken token;

	public string Name
	{
		get
		{
			return name;
		}
		set
		{
			name = value;
		}
	}

	public virtual MetadataScopeType MetadataScopeType => MetadataScopeType.ModuleReference;

	public MetadataToken MetadataToken
	{
		get
		{
			return token;
		}
		set
		{
			token = value;
		}
	}

	internal ModuleReference()
	{
		token = new MetadataToken(TokenType.ModuleRef);
	}

	public ModuleReference(string name)
		: this()
	{
		this.name = name;
	}

	public override string ToString()
	{
		return name;
	}
}


using System;
using Mono.Cecil;
using Mono.Collections.Generic;

internal class MemberDefinitionCollection<T> : Collection<T> where T : IMemberDefinition
{
	private TypeDefinition container;

	internal MemberDefinitionCollection(TypeDefinition container)
	{
		this.container = container;
	}

	internal MemberDefinitionCollection(TypeDefinition container, int capacity)
		: base(capacity)
	{
		this.container = container;
	}

	protected override void OnAdd(T item, int index)
	{
		Attach(item);
	}

	protected sealed override void OnSet(T item, int index)
	{
		Attach(item);
	}

	protected sealed override void OnInsert(T item, int index)
	{
		Attach(item);
	}

	protected sealed override void OnRemove(T item, int index)
	{
		Detach(item);
	}

	protected sealed override void OnClear()
	{
		using Enumerator enumerator = GetEnumerator();
		while (enumerator.MoveNext())
		{
			Detach(enumerator.Current);
		}
	}

	private void Attach(T element)
	{
		if (element.DeclaringType != container)
		{
			if (element.DeclaringType != null)
			{
				throw new ArgumentException("Member already attached");
			}
			element.DeclaringType = container;
		}
	}

	private static void Detach(T element)
	{
		element.DeclaringType = null;
	}
}


public enum ReadingMode
{
	Immediate = 1,
	Deferred
}


using System.IO;
using Mono.Cecil;
using Mono.Cecil.Cil;

public sealed class ReaderParameters
{
	private ReadingMode reading_mode;

	private IAssemblyResolver assembly_resolver;

	private IMetadataResolver metadata_resolver;

	private Stream symbol_stream;

	private ISymbolReaderProvider symbol_reader_provider;

	private bool read_symbols;

	public ReadingMode ReadingMode
	{
		get
		{
			return reading_mode;
		}
		set
		{
			reading_mode = value;
		}
	}

	public IAssemblyResolver AssemblyResolver
	{
		get
		{
			return assembly_resolver;
		}
		set
		{
			assembly_resolver = value;
		}
	}

	public IMetadataResolver MetadataResolver
	{
		get
		{
			return metadata_resolver;
		}
		set
		{
			metadata_resolver = value;
		}
	}

	public Stream SymbolStream
	{
		get
		{
			return symbol_stream;
		}
		set
		{
			symbol_stream = value;
		}
	}

	public ISymbolReaderProvider SymbolReaderProvider
	{
		get
		{
			return symbol_reader_provider;
		}
		set
		{
			symbol_reader_provider = value;
		}
	}

	public bool ReadSymbols
	{
		get
		{
			return read_symbols;
		}
		set
		{
			read_symbols = value;
		}
	}

	public ReaderParameters()
		: this(ReadingMode.Deferred)
	{
	}

	public ReaderParameters(ReadingMode readingMode)
	{
		reading_mode = readingMode;
	}
}


using Mono.Cecil;

public sealed class ModuleParameters
{
	private ModuleKind kind;

	private TargetRuntime runtime;

	private TargetArchitecture architecture;

	private IAssemblyResolver assembly_resolver;

	private IMetadataResolver metadata_resolver;

	public ModuleKind Kind
	{
		get
		{
			return kind;
		}
		set
		{
			kind = value;
		}
	}

	public TargetRuntime Runtime
	{
		get
		{
			return runtime;
		}
		set
		{
			runtime = value;
		}
	}

	public TargetArchitecture Architecture
	{
		get
		{
			return architecture;
		}
		set
		{
			architecture = value;
		}
	}

	public IAssemblyResolver AssemblyResolver
	{
		get
		{
			return assembly_resolver;
		}
		set
		{
			assembly_resolver = value;
		}
	}

	public IMetadataResolver MetadataResolver
	{
		get
		{
			return metadata_resolver;
		}
		set
		{
			metadata_resolver = value;
		}
	}

	public ModuleParameters()
	{
		kind = ModuleKind.Dll;
		Runtime = GetCurrentRuntime();
		architecture = TargetArchitecture.I386;
	}

	private static TargetRuntime GetCurrentRuntime()
	{
		return typeof(object).Assembly.ImageRuntimeVersion.ParseRuntime();
	}
}


using System.IO;
using System.Reflection;
using Mono.Cecil.Cil;

public sealed class WriterParameters
{
	private Stream symbol_stream;

	private ISymbolWriterProvider symbol_writer_provider;

	private bool write_symbols;

	private StrongNameKeyPair key_pair;

	public Stream SymbolStream
	{
		get
		{
			return symbol_stream;
		}
		set
		{
			symbol_stream = value;
		}
	}

	public ISymbolWriterProvider SymbolWriterProvider
	{
		get
		{
			return symbol_writer_provider;
		}
		set
		{
			symbol_writer_provider = value;
		}
	}

	public bool WriteSymbols
	{
		get
		{
			return write_symbols;
		}
		set
		{
			write_symbols = value;
		}
	}

	public StrongNameKeyPair StrongNameKeyPair
	{
		get
		{
			return key_pair;
		}
		set
		{
			key_pair = value;
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Threading;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;
using Mono.Collections.Generic;

public sealed class ModuleDefinition : ModuleReference, Mono.Cecil.ICustomAttributeProvider, IMetadataTokenProvider
{
	internal Image Image;

	internal MetadataSystem MetadataSystem;

	internal ReadingMode ReadingMode;

	internal ISymbolReaderProvider SymbolReaderProvider;

	internal ISymbolReader symbol_reader;

	internal IAssemblyResolver assembly_resolver;

	internal IMetadataResolver metadata_resolver;

	internal TypeSystem type_system;

	private readonly MetadataReader reader;

	private readonly string fq_name;

	internal string runtime_version;

	internal ModuleKind kind;

	private TargetRuntime runtime;

	private TargetArchitecture architecture;

	private ModuleAttributes attributes;

	private ModuleCharacteristics characteristics;

	private Guid mvid;

	internal AssemblyDefinition assembly;

	private MethodDefinition entry_point;

	private MetadataImporter importer;

	private Collection<CustomAttribute> custom_attributes;

	private Collection<AssemblyNameReference> references;

	private Collection<ModuleReference> modules;

	private Collection<Resource> resources;

	private Collection<ExportedType> exported_types;

	private TypeDefinitionCollection types;

	private readonly object module_lock = new object();

	public bool IsMain => kind != ModuleKind.NetModule;

	public ModuleKind Kind
	{
		get
		{
			return kind;
		}
		set
		{
			kind = value;
		}
	}

	public TargetRuntime Runtime
	{
		get
		{
			return runtime;
		}
		set
		{
			runtime = value;
			runtime_version = runtime.RuntimeVersionString();
		}
	}

	public string RuntimeVersion
	{
		get
		{
			return runtime_version;
		}
		set
		{
			runtime_version = value;
			runtime = runtime_version.ParseRuntime();
		}
	}

	public TargetArchitecture Architecture
	{
		get
		{
			return architecture;
		}
		set
		{
			architecture = value;
		}
	}

	public ModuleAttributes Attributes
	{
		get
		{
			return attributes;
		}
		set
		{
			attributes = value;
		}
	}

	public ModuleCharacteristics Characteristics
	{
		get
		{
			return characteristics;
		}
		set
		{
			characteristics = value;
		}
	}

	public string FullyQualifiedName => fq_name;

	public Guid Mvid
	{
		get
		{
			return mvid;
		}
		set
		{
			mvid = value;
		}
	}

	internal bool HasImage => Image != null;

	public bool HasSymbols => symbol_reader != null;

	public ISymbolReader SymbolReader => symbol_reader;

	public override MetadataScopeType MetadataScopeType => MetadataScopeType.ModuleDefinition;

	public AssemblyDefinition Assembly => assembly;

	internal MetadataImporter MetadataImporter
	{
		get
		{
			if (importer == null)
			{
				Interlocked.CompareExchange(ref importer, new MetadataImporter(this), null);
			}
			return importer;
		}
	}

	public IAssemblyResolver AssemblyResolver
	{
		get
		{
			if (assembly_resolver == null)
			{
				Interlocked.CompareExchange(ref assembly_resolver, new DefaultAssemblyResolver(), null);
			}
			return assembly_resolver;
		}
	}

	public IMetadataResolver MetadataResolver
	{
		get
		{
			if (metadata_resolver == null)
			{
				Interlocked.CompareExchange(ref metadata_resolver, new MetadataResolver(AssemblyResolver), null);
			}
			return metadata_resolver;
		}
	}

	public TypeSystem TypeSystem
	{
		get
		{
			if (type_system == null)
			{
				Interlocked.CompareExchange(ref type_system, TypeSystem.CreateTypeSystem(this), null);
			}
			return type_system;
		}
	}

	public bool HasAssemblyReferences
	{
		get
		{
			if (references != null)
			{
				return references.Count > 0;
			}
			if (HasImage)
			{
				return Image.HasTable(Table.AssemblyRef);
			}
			return false;
		}
	}

	public Collection<AssemblyNameReference> AssemblyReferences
	{
		get
		{
			if (references != null)
			{
				return references;
			}
			if (HasImage)
			{
				return Read(ref references, this, (ModuleDefinition _, MetadataReader reader) => reader.ReadAssemblyReferences());
			}
			return references = new Collection<AssemblyNameReference>();
		}
	}

	public bool HasModuleReferences
	{
		get
		{
			if (modules != null)
			{
				return modules.Count > 0;
			}
			if (HasImage)
			{
				return Image.HasTable(Table.ModuleRef);
			}
			return false;
		}
	}

	public Collection<ModuleReference> ModuleReferences
	{
		get
		{
			if (modules != null)
			{
				return modules;
			}
			if (HasImage)
			{
				return Read(ref modules, this, (ModuleDefinition _, MetadataReader reader) => reader.ReadModuleReferences());
			}
			return modules = new Collection<ModuleReference>();
		}
	}

	public bool HasResources
	{
		get
		{
			if (resources != null)
			{
				return resources.Count > 0;
			}
			if (HasImage)
			{
				if (!Image.HasTable(Table.ManifestResource))
				{
					return Read(this, (ModuleDefinition _, MetadataReader reader) => reader.HasFileResource());
				}
				return true;
			}
			return false;
		}
	}

	public Collection<Resource> Resources
	{
		get
		{
			if (resources != null)
			{
				return resources;
			}
			if (HasImage)
			{
				return Read(ref resources, this, (ModuleDefinition _, MetadataReader reader) => reader.ReadResources());
			}
			return resources = new Collection<Resource>();
		}
	}

	public bool HasCustomAttributes
	{
		get
		{
			if (custom_attributes != null)
			{
				return custom_attributes.Count > 0;
			}
			return this.GetHasCustomAttributes(this);
		}
	}

	public Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, this);

	public bool HasTypes
	{
		get
		{
			if (types != null)
			{
				return types.Count > 0;
			}
			if (HasImage)
			{
				return Image.HasTable(Table.TypeDef);
			}
			return false;
		}
	}

	public Collection<TypeDefinition> Types
	{
		get
		{
			if (types != null)
			{
				return types;
			}
			if (HasImage)
			{
				return Read(ref types, this, (ModuleDefinition _, MetadataReader reader) => reader.ReadTypes());
			}
			return types = new TypeDefinitionCollection(this);
		}
	}

	public bool HasExportedTypes
	{
		get
		{
			if (exported_types != null)
			{
				return exported_types.Count > 0;
			}
			if (HasImage)
			{
				return Image.HasTable(Table.ExportedType);
			}
			return false;
		}
	}

	public Collection<ExportedType> ExportedTypes
	{
		get
		{
			if (exported_types != null)
			{
				return exported_types;
			}
			if (HasImage)
			{
				return Read(ref exported_types, this, (ModuleDefinition _, MetadataReader reader) => reader.ReadExportedTypes());
			}
			return exported_types = new Collection<ExportedType>();
		}
	}

	public MethodDefinition EntryPoint
	{
		get
		{
			if (entry_point != null)
			{
				return entry_point;
			}
			if (HasImage)
			{
				return Read(ref entry_point, this, (ModuleDefinition _, MetadataReader reader) => reader.ReadEntryPoint());
			}
			return entry_point = null;
		}
		set
		{
			entry_point = value;
		}
	}

	internal object SyncRoot => module_lock;

	public bool HasDebugHeader
	{
		get
		{
			if (Image != null)
			{
				return !Image.Debug.IsZero;
			}
			return false;
		}
	}

	internal ModuleDefinition()
	{
		MetadataSystem = new MetadataSystem();
		token = new MetadataToken(TokenType.Module, 1);
	}

	internal ModuleDefinition(Image image)
		: this()
	{
		Image = image;
		kind = image.Kind;
		RuntimeVersion = image.RuntimeVersion;
		architecture = image.Architecture;
		attributes = image.Attributes;
		characteristics = image.Characteristics;
		fq_name = image.FileName;
		reader = new MetadataReader(this);
	}

	public bool HasTypeReference(string fullName)
	{
		return HasTypeReference(string.Empty, fullName);
	}

	public bool HasTypeReference(string scope, string fullName)
	{
		CheckFullName(fullName);
		if (!HasImage)
		{
			return false;
		}
		return GetTypeReference(scope, fullName) != null;
	}

	public bool TryGetTypeReference(string fullName, out TypeReference type)
	{
		return TryGetTypeReference(string.Empty, fullName, out type);
	}

	public bool TryGetTypeReference(string scope, string fullName, out TypeReference type)
	{
		CheckFullName(fullName);
		if (!HasImage)
		{
			type = null;
			return false;
		}
		return (type = GetTypeReference(scope, fullName)) != null;
	}

	private TypeReference GetTypeReference(string scope, string fullname)
	{
		return Read(new Row<string, string>(scope, fullname), (Row<string, string> row, MetadataReader reader) => reader.GetTypeReference(row.Col1, row.Col2));
	}

	public IEnumerable<TypeReference> GetTypeReferences()
	{
		if (!HasImage)
		{
			return Empty<TypeReference>.Array;
		}
		return Read(this, (ModuleDefinition _, MetadataReader reader) => reader.GetTypeReferences());
	}

	public IEnumerable<MemberReference> GetMemberReferences()
	{
		if (!HasImage)
		{
			return Empty<MemberReference>.Array;
		}
		return Read(this, (ModuleDefinition _, MetadataReader reader) => reader.GetMemberReferences());
	}

	public TypeReference GetType(string fullName, bool runtimeName)
	{
		if (!runtimeName)
		{
			return GetType(fullName);
		}
		return TypeParser.ParseType(this, fullName);
	}

	public TypeDefinition GetType(string fullName)
	{
		CheckFullName(fullName);
		if (fullName.IndexOf('/') > 0)
		{
			return GetNestedType(fullName);
		}
		return ((TypeDefinitionCollection)Types).GetType(fullName);
	}

	public TypeDefinition GetType(string @namespace, string name)
	{
		Mixin.CheckName(name);
		return ((TypeDefinitionCollection)Types).GetType(@namespace ?? string.Empty, name);
	}

	public IEnumerable<TypeDefinition> GetTypes()
	{
		return GetTypes(Types);
	}

	private static IEnumerable<TypeDefinition> GetTypes(Collection<TypeDefinition> types)
	{
		for (int i = 0; i < types.Count; i++)
		{
			TypeDefinition type = types[i];
			yield return type;
			if (!type.HasNestedTypes)
			{
				continue;
			}
			foreach (TypeDefinition type2 in GetTypes(type.NestedTypes))
			{
				yield return type2;
			}
		}
	}

	private static void CheckFullName(string fullName)
	{
		if (fullName == null)
		{
			throw new ArgumentNullException("fullName");
		}
		if (fullName.Length == 0)
		{
			throw new ArgumentException();
		}
	}

	private TypeDefinition GetNestedType(string fullname)
	{
		string[] array = fullname.Split(new char[1] { '/' });
		TypeDefinition typeDefinition = GetType(array[0]);
		if (typeDefinition == null)
		{
			return null;
		}
		for (int i = 1; i < array.Length; i++)
		{
			TypeDefinition nestedType = typeDefinition.GetNestedType(array[i]);
			if (nestedType == null)
			{
				return null;
			}
			typeDefinition = nestedType;
		}
		return typeDefinition;
	}

	internal FieldDefinition Resolve(FieldReference field)
	{
		return MetadataResolver.Resolve(field);
	}

	internal MethodDefinition Resolve(MethodReference method)
	{
		return MetadataResolver.Resolve(method);
	}

	internal TypeDefinition Resolve(TypeReference type)
	{
		return MetadataResolver.Resolve(type);
	}

	private static void CheckType(object type)
	{
		if (type == null)
		{
			throw new ArgumentNullException("type");
		}
	}

	private static void CheckField(object field)
	{
		if (field == null)
		{
			throw new ArgumentNullException("field");
		}
	}

	private static void CheckMethod(object method)
	{
		if (method == null)
		{
			throw new ArgumentNullException("method");
		}
	}

	private static void CheckContext(IGenericParameterProvider context, ModuleDefinition module)
	{
		if (context == null || context.Module == module)
		{
			return;
		}
		throw new ArgumentException();
	}

	private static ImportGenericContext GenericContextFor(IGenericParameterProvider context)
	{
		if (context == null)
		{
			return default(ImportGenericContext);
		}
		return new ImportGenericContext(context);
	}

	public TypeReference Import(Type type)
	{
		return Import(type, null);
	}

	public TypeReference Import(Type type, IGenericParameterProvider context)
	{
		CheckType(type);
		CheckContext(context, this);
		return MetadataImporter.ImportType(type, GenericContextFor(context), (context != null) ? ImportGenericKind.Open : ImportGenericKind.Definition);
	}

	public FieldReference Import(FieldInfo field)
	{
		return Import(field, null);
	}

	public FieldReference Import(FieldInfo field, IGenericParameterProvider context)
	{
		CheckField(field);
		CheckContext(context, this);
		return MetadataImporter.ImportField(field, GenericContextFor(context));
	}

	public MethodReference Import(MethodBase method)
	{
		CheckMethod(method);
		return MetadataImporter.ImportMethod(method, default(ImportGenericContext), ImportGenericKind.Definition);
	}

	public MethodReference Import(MethodBase method, IGenericParameterProvider context)
	{
		CheckMethod(method);
		CheckContext(context, this);
		return MetadataImporter.ImportMethod(method, GenericContextFor(context), (context != null) ? ImportGenericKind.Open : ImportGenericKind.Definition);
	}

	public TypeReference Import(TypeReference type)
	{
		CheckType(type);
		if (type.Module == this)
		{
			return type;
		}
		return MetadataImporter.ImportType(type, default(ImportGenericContext));
	}

	public TypeReference Import(TypeReference type, IGenericParameterProvider context)
	{
		CheckType(type);
		if (type.Module == this)
		{
			return type;
		}
		CheckContext(context, this);
		return MetadataImporter.ImportType(type, GenericContextFor(context));
	}

	public FieldReference Import(FieldReference field)
	{
		CheckField(field);
		if (field.Module == this)
		{
			return field;
		}
		return MetadataImporter.ImportField(field, default(ImportGenericContext));
	}

	public FieldReference Import(FieldReference field, IGenericParameterProvider context)
	{
		CheckField(field);
		if (field.Module == this)
		{
			return field;
		}
		CheckContext(context, this);
		return MetadataImporter.ImportField(field, GenericContextFor(context));
	}

	public MethodReference Import(MethodReference method)
	{
		return Import(method, null);
	}

	public MethodReference Import(MethodReference method, IGenericParameterProvider context)
	{
		CheckMethod(method);
		if (method.Module == this)
		{
			return method;
		}
		CheckContext(context, this);
		return MetadataImporter.ImportMethod(method, GenericContextFor(context));
	}

	public IMetadataTokenProvider LookupToken(int token)
	{
		return LookupToken(new MetadataToken((uint)token));
	}

	public IMetadataTokenProvider LookupToken(MetadataToken token)
	{
		return Read(token, (MetadataToken t, MetadataReader reader) => reader.LookupToken(t));
	}

	internal TRet Read<TItem, TRet>(TItem item, Func<TItem, MetadataReader, TRet> read)
	{
		lock (module_lock)
		{
			int position = reader.position;
			IGenericContext context = reader.context;
			TRet result = read(item, reader);
			reader.position = position;
			reader.context = context;
			return result;
		}
	}

	internal TRet Read<TItem, TRet>(ref TRet variable, TItem item, Func<TItem, MetadataReader, TRet> read) where TRet : class
	{
		lock (module_lock)
		{
			if (variable != null)
			{
				return variable;
			}
			int position = reader.position;
			IGenericContext context = reader.context;
			TRet val = read(item, reader);
			reader.position = position;
			reader.context = context;
			return variable = val;
		}
	}

	public ImageDebugDirectory GetDebugHeader(out byte[] header)
	{
		if (!HasDebugHeader)
		{
			throw new InvalidOperationException();
		}
		return Image.GetDebugHeader(out header);
	}

	private void ProcessDebugHeader()
	{
		if (HasDebugHeader)
		{
			byte[] header;
			ImageDebugDirectory debugHeader = GetDebugHeader(out header);
			if (!symbol_reader.ProcessDebugHeader(debugHeader, header))
			{
				throw new InvalidOperationException();
			}
		}
	}

	public static ModuleDefinition CreateModule(string name, ModuleKind kind)
	{
		return CreateModule(name, new ModuleParameters
		{
			Kind = kind
		});
	}

	public static ModuleDefinition CreateModule(string name, ModuleParameters parameters)
	{
		Mixin.CheckName(name);
		Mixin.CheckParameters(parameters);
		ModuleDefinition moduleDefinition = new ModuleDefinition
		{
			Name = name,
			kind = parameters.Kind,
			Runtime = parameters.Runtime,
			architecture = parameters.Architecture,
			mvid = Guid.NewGuid(),
			Attributes = ModuleAttributes.ILOnly,
			Characteristics = (ModuleCharacteristics.DynamicBase | ModuleCharacteristics.NoSEH | ModuleCharacteristics.NXCompat | ModuleCharacteristics.TerminalServerAware)
		};
		if (parameters.AssemblyResolver != null)
		{
			moduleDefinition.assembly_resolver = parameters.AssemblyResolver;
		}
		if (parameters.MetadataResolver != null)
		{
			moduleDefinition.metadata_resolver = parameters.MetadataResolver;
		}
		if (parameters.Kind != ModuleKind.NetModule)
		{
			AssemblyDefinition assemblyDefinition = (moduleDefinition.assembly = new AssemblyDefinition());
			moduleDefinition.assembly.Name = CreateAssemblyName(name);
			assemblyDefinition.main_module = moduleDefinition;
		}
		moduleDefinition.Types.Add(new TypeDefinition(string.Empty, "<Module>", Mono.Cecil.TypeAttributes.NotPublic));
		return moduleDefinition;
	}

	private static AssemblyNameDefinition CreateAssemblyName(string name)
	{
		if (name.EndsWith(".dll") || name.EndsWith(".exe"))
		{
			name = name.Substring(0, name.Length - 4);
		}
		return new AssemblyNameDefinition(name, new Version(0, 0, 0, 0));
	}

	public void ReadSymbols()
	{
		if (string.IsNullOrEmpty(fq_name))
		{
			throw new InvalidOperationException();
		}
		ISymbolReaderProvider platformReaderProvider = SymbolProvider.GetPlatformReaderProvider();
		if (platformReaderProvider == null)
		{
			throw new InvalidOperationException();
		}
		ReadSymbols(platformReaderProvider.GetSymbolReader(this, fq_name));
	}

	public void ReadSymbols(ISymbolReader reader)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		symbol_reader = reader;
		ProcessDebugHeader();
	}

	public static ModuleDefinition ReadModule(string fileName)
	{
		return ReadModule(fileName, new ReaderParameters(ReadingMode.Deferred));
	}

	public static ModuleDefinition ReadModule(Stream stream)
	{
		return ReadModule(stream, new ReaderParameters(ReadingMode.Deferred));
	}

	public static ModuleDefinition ReadModule(string fileName, ReaderParameters parameters)
	{
		using Stream stream = GetFileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
		return ReadModule(stream, parameters);
	}

	private static void CheckStream(object stream)
	{
		if (stream == null)
		{
			throw new ArgumentNullException("stream");
		}
	}

	public static ModuleDefinition ReadModule(Stream stream, ReaderParameters parameters)
	{
		CheckStream(stream);
		if (!stream.CanRead || !stream.CanSeek)
		{
			throw new ArgumentException();
		}
		Mixin.CheckParameters(parameters);
		return ModuleReader.CreateModuleFrom(ImageReader.ReadImageFrom(stream), parameters);
	}

	private static Stream GetFileStream(string fileName, FileMode mode, FileAccess access, FileShare share)
	{
		if (fileName == null)
		{
			throw new ArgumentNullException("fileName");
		}
		if (fileName.Length == 0)
		{
			throw new ArgumentException();
		}
		return new FileStream(fileName, mode, access, share);
	}

	public void Write(string fileName)
	{
		Write(fileName, new WriterParameters());
	}

	public void Write(Stream stream)
	{
		Write(stream, new WriterParameters());
	}

	public void Write(string fileName, WriterParameters parameters)
	{
		using Stream stream = GetFileStream(fileName, FileMode.Create, FileAccess.ReadWrite, FileShare.None);
		Write(stream, parameters);
	}

	public void Write(Stream stream, WriterParameters parameters)
	{
		CheckStream(stream);
		if (!stream.CanWrite || !stream.CanSeek)
		{
			throw new ArgumentException();
		}
		Mixin.CheckParameters(parameters);
		ModuleWriter.WriteModuleTo(this, stream, parameters);
	}
}


public enum ModuleKind
{
	Dll,
	Console,
	Windows,
	NetModule
}


public enum TargetArchitecture
{
	I386,
	AMD64,
	IA64,
	ARMv7
}


using System;

[Flags]
public enum ModuleAttributes
{
	ILOnly = 1,
	Required32Bit = 2,
	StrongNameSigned = 8,
	Preferred32Bit = 0x20000
}


using System;

[Flags]
public enum ModuleCharacteristics
{
	HighEntropyVA = 0x20,
	DynamicBase = 0x40,
	NoSEH = 0x400,
	NXCompat = 0x100,
	AppContainer = 0x1000,
	TerminalServerAware = 0x8000
}


public enum ResourceType
{
	Linked,
	Embedded,
	AssemblyLinked
}


using Mono.Cecil;

public abstract class Resource
{
	private string name;

	private uint attributes;

	public string Name
	{
		get
		{
			return name;
		}
		set
		{
			name = value;
		}
	}

	public ManifestResourceAttributes Attributes
	{
		get
		{
			return (ManifestResourceAttributes)attributes;
		}
		set
		{
			attributes = (uint)value;
		}
	}

	public abstract ResourceType ResourceType { get; }

	public bool IsPublic
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 1u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 1u, value);
		}
	}

	public bool IsPrivate
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 2u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 2u, value);
		}
	}

	internal Resource(string name, ManifestResourceAttributes attributes)
	{
		this.name = name;
		this.attributes = (uint)attributes;
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Metadata;

public sealed class SentinelType : TypeSpecification
{
	public override bool IsValueType
	{
		get
		{
			return false;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override bool IsSentinel => true;

	public SentinelType(TypeReference type)
		: base(type)
	{
		Mixin.CheckType(type);
		etype = Mono.Cecil.Metadata.ElementType.Sentinel;
	}
}


public enum TargetRuntime
{
	Net_1_0,
	Net_1_1,
	Net_2_0,
	Net_4_0
}


using System;

[Flags]
public enum TypeAttributes : uint
{
	VisibilityMask = 7u,
	NotPublic = 0u,
	Public = 1u,
	NestedPublic = 2u,
	NestedPrivate = 3u,
	NestedFamily = 4u,
	NestedAssembly = 5u,
	NestedFamANDAssem = 6u,
	NestedFamORAssem = 7u,
	LayoutMask = 0x18u,
	AutoLayout = 0u,
	SequentialLayout = 8u,
	ExplicitLayout = 0x10u,
	ClassSemanticMask = 0x20u,
	Class = 0u,
	Interface = 0x20u,
	Abstract = 0x80u,
	Sealed = 0x100u,
	SpecialName = 0x400u,
	Import = 0x1000u,
	Serializable = 0x2000u,
	WindowsRuntime = 0x4000u,
	StringFormatMask = 0x30000u,
	AnsiClass = 0u,
	UnicodeClass = 0x10000u,
	AutoClass = 0x20000u,
	BeforeFieldInit = 0x100000u,
	RTSpecialName = 0x800u,
	HasSecurity = 0x40000u,
	Forwarder = 0x200000u
}


using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

public sealed class TypeDefinition : TypeReference, IMemberDefinition, ICustomAttributeProvider, IMetadataTokenProvider, ISecurityDeclarationProvider
{
	private uint attributes;

	private TypeReference base_type;

	internal Range fields_range;

	internal Range methods_range;

	private short packing_size = -2;

	private int class_size = -2;

	private Collection<TypeReference> interfaces;

	private Collection<TypeDefinition> nested_types;

	private Collection<MethodDefinition> methods;

	private Collection<FieldDefinition> fields;

	private Collection<EventDefinition> events;

	private Collection<PropertyDefinition> properties;

	private Collection<CustomAttribute> custom_attributes;

	private Collection<SecurityDeclaration> security_declarations;

	public TypeAttributes Attributes
	{
		get
		{
			return (TypeAttributes)attributes;
		}
		set
		{
			attributes = (uint)value;
		}
	}

	public TypeReference BaseType
	{
		get
		{
			return base_type;
		}
		set
		{
			base_type = value;
		}
	}

	public bool HasLayoutInfo
	{
		get
		{
			if (packing_size >= 0 || class_size >= 0)
			{
				return true;
			}
			ResolveLayout();
			if (packing_size < 0)
			{
				return class_size >= 0;
			}
			return true;
		}
	}

	public short PackingSize
	{
		get
		{
			if (packing_size >= 0)
			{
				return packing_size;
			}
			ResolveLayout();
			if (packing_size < 0)
			{
				return -1;
			}
			return packing_size;
		}
		set
		{
			packing_size = value;
		}
	}

	public int ClassSize
	{
		get
		{
			if (class_size >= 0)
			{
				return class_size;
			}
			ResolveLayout();
			if (class_size < 0)
			{
				return -1;
			}
			return class_size;
		}
		set
		{
			class_size = value;
		}
	}

	public bool HasInterfaces
	{
		get
		{
			if (interfaces != null)
			{
				return interfaces.Count > 0;
			}
			if (base.HasImage)
			{
				return Module.Read(this, (TypeDefinition type, MetadataReader reader) => reader.HasInterfaces(type));
			}
			return false;
		}
	}

	public Collection<TypeReference> Interfaces
	{
		get
		{
			if (interfaces != null)
			{
				return interfaces;
			}
			if (base.HasImage)
			{
				return Module.Read(ref interfaces, this, (TypeDefinition type, MetadataReader reader) => reader.ReadInterfaces(type));
			}
			return interfaces = new Collection<TypeReference>();
		}
	}

	public bool HasNestedTypes
	{
		get
		{
			if (nested_types != null)
			{
				return nested_types.Count > 0;
			}
			if (base.HasImage)
			{
				return Module.Read(this, (TypeDefinition type, MetadataReader reader) => reader.HasNestedTypes(type));
			}
			return false;
		}
	}

	public Collection<TypeDefinition> NestedTypes
	{
		get
		{
			if (nested_types != null)
			{
				return nested_types;
			}
			if (base.HasImage)
			{
				return Module.Read(ref nested_types, this, (TypeDefinition type, MetadataReader reader) => reader.ReadNestedTypes(type));
			}
			return nested_types = new MemberDefinitionCollection<TypeDefinition>(this);
		}
	}

	public bool HasMethods
	{
		get
		{
			if (methods != null)
			{
				return methods.Count > 0;
			}
			if (base.HasImage)
			{
				return methods_range.Length != 0;
			}
			return false;
		}
	}

	public Collection<MethodDefinition> Methods
	{
		get
		{
			if (methods != null)
			{
				return methods;
			}
			if (base.HasImage)
			{
				return Module.Read(ref methods, this, (TypeDefinition type, MetadataReader reader) => reader.ReadMethods(type));
			}
			return methods = new MemberDefinitionCollection<MethodDefinition>(this);
		}
	}

	public bool HasFields
	{
		get
		{
			if (fields != null)
			{
				return fields.Count > 0;
			}
			if (base.HasImage)
			{
				return fields_range.Length != 0;
			}
			return false;
		}
	}

	public Collection<FieldDefinition> Fields
	{
		get
		{
			if (fields != null)
			{
				return fields;
			}
			if (base.HasImage)
			{
				return Module.Read(ref fields, this, (TypeDefinition type, MetadataReader reader) => reader.ReadFields(type));
			}
			return fields = new MemberDefinitionCollection<FieldDefinition>(this);
		}
	}

	public bool HasEvents
	{
		get
		{
			if (events != null)
			{
				return events.Count > 0;
			}
			if (base.HasImage)
			{
				return Module.Read(this, (TypeDefinition type, MetadataReader reader) => reader.HasEvents(type));
			}
			return false;
		}
	}

	public Collection<EventDefinition> Events
	{
		get
		{
			if (events != null)
			{
				return events;
			}
			if (base.HasImage)
			{
				return Module.Read(ref events, this, (TypeDefinition type, MetadataReader reader) => reader.ReadEvents(type));
			}
			return events = new MemberDefinitionCollection<EventDefinition>(this);
		}
	}

	public bool HasProperties
	{
		get
		{
			if (properties != null)
			{
				return properties.Count > 0;
			}
			if (base.HasImage)
			{
				return Module.Read(this, (TypeDefinition type, MetadataReader reader) => reader.HasProperties(type));
			}
			return false;
		}
	}

	public Collection<PropertyDefinition> Properties
	{
		get
		{
			if (properties != null)
			{
				return properties;
			}
			if (base.HasImage)
			{
				return Module.Read(ref properties, this, (TypeDefinition type, MetadataReader reader) => reader.ReadProperties(type));
			}
			return properties = new MemberDefinitionCollection<PropertyDefinition>(this);
		}
	}

	public bool HasSecurityDeclarations
	{
		get
		{
			if (security_declarations != null)
			{
				return security_declarations.Count > 0;
			}
			return this.GetHasSecurityDeclarations(Module);
		}
	}

	public Collection<SecurityDeclaration> SecurityDeclarations => security_declarations ?? this.GetSecurityDeclarations(ref security_declarations, Module);

	public bool HasCustomAttributes
	{
		get
		{
			if (custom_attributes != null)
			{
				return custom_attributes.Count > 0;
			}
			return this.GetHasCustomAttributes(Module);
		}
	}

	public Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, Module);

	public override bool HasGenericParameters
	{
		get
		{
			if (generic_parameters != null)
			{
				return generic_parameters.Count > 0;
			}
			return this.GetHasGenericParameters(Module);
		}
	}

	public override Collection<GenericParameter> GenericParameters => generic_parameters ?? this.GetGenericParameters(ref generic_parameters, Module);

	public bool IsNotPublic
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 0u, value);
		}
	}

	public bool IsPublic
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 1u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 1u, value);
		}
	}

	public bool IsNestedPublic
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 2u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 2u, value);
		}
	}

	public bool IsNestedPrivate
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 3u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 3u, value);
		}
	}

	public bool IsNestedFamily
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 4u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 4u, value);
		}
	}

	public bool IsNestedAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 5u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 5u, value);
		}
	}

	public bool IsNestedFamilyAndAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 6u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 6u, value);
		}
	}

	public bool IsNestedFamilyOrAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 7u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 7u, value);
		}
	}

	public bool IsAutoLayout
	{
		get
		{
			return attributes.GetMaskedAttributes(24u, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(24u, 0u, value);
		}
	}

	public bool IsSequentialLayout
	{
		get
		{
			return attributes.GetMaskedAttributes(24u, 8u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(24u, 8u, value);
		}
	}

	public bool IsExplicitLayout
	{
		get
		{
			return attributes.GetMaskedAttributes(24u, 16u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(24u, 16u, value);
		}
	}

	public bool IsClass
	{
		get
		{
			return attributes.GetMaskedAttributes(32u, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(32u, 0u, value);
		}
	}

	public bool IsInterface
	{
		get
		{
			return attributes.GetMaskedAttributes(32u, 32u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(32u, 32u, value);
		}
	}

	public bool IsAbstract
	{
		get
		{
			return attributes.GetAttributes(128u);
		}
		set
		{
			attributes = attributes.SetAttributes(128u, value);
		}
	}

	public bool IsSealed
	{
		get
		{
			return attributes.GetAttributes(256u);
		}
		set
		{
			attributes = attributes.SetAttributes(256u, value);
		}
	}

	public bool IsSpecialName
	{
		get
		{
			return attributes.GetAttributes(1024u);
		}
		set
		{
			attributes = attributes.SetAttributes(1024u, value);
		}
	}

	public bool IsImport
	{
		get
		{
			return attributes.GetAttributes(4096u);
		}
		set
		{
			attributes = attributes.SetAttributes(4096u, value);
		}
	}

	public bool IsSerializable
	{
		get
		{
			return attributes.GetAttributes(8192u);
		}
		set
		{
			attributes = attributes.SetAttributes(8192u, value);
		}
	}

	public bool IsWindowsRuntime
	{
		get
		{
			return attributes.GetAttributes(16384u);
		}
		set
		{
			attributes = attributes.SetAttributes(16384u, value);
		}
	}

	public bool IsAnsiClass
	{
		get
		{
			return attributes.GetMaskedAttributes(196608u, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(196608u, 0u, value);
		}
	}

	public bool IsUnicodeClass
	{
		get
		{
			return attributes.GetMaskedAttributes(196608u, 65536u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(196608u, 65536u, value);
		}
	}

	public bool IsAutoClass
	{
		get
		{
			return attributes.GetMaskedAttributes(196608u, 131072u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(196608u, 131072u, value);
		}
	}

	public bool IsBeforeFieldInit
	{
		get
		{
			return attributes.GetAttributes(1048576u);
		}
		set
		{
			attributes = attributes.SetAttributes(1048576u, value);
		}
	}

	public bool IsRuntimeSpecialName
	{
		get
		{
			return attributes.GetAttributes(2048u);
		}
		set
		{
			attributes = attributes.SetAttributes(2048u, value);
		}
	}

	public bool HasSecurity
	{
		get
		{
			return attributes.GetAttributes(262144u);
		}
		set
		{
			attributes = attributes.SetAttributes(262144u, value);
		}
	}

	public bool IsEnum
	{
		get
		{
			if (base_type != null)
			{
				return base_type.IsTypeOf("System", "Enum");
			}
			return false;
		}
	}

	public override bool IsValueType
	{
		get
		{
			if (base_type == null)
			{
				return false;
			}
			if (!base_type.IsTypeOf("System", "Enum"))
			{
				if (base_type.IsTypeOf("System", "ValueType"))
				{
					return !this.IsTypeOf("System", "Enum");
				}
				return false;
			}
			return true;
		}
	}

	public override bool IsPrimitive
	{
		get
		{
			ElementType elementType;
			return MetadataSystem.TryGetPrimitiveElementType(this, out elementType);
		}
	}

	public override MetadataType MetadataType
	{
		get
		{
			if (MetadataSystem.TryGetPrimitiveElementType(this, out var result))
			{
				return (MetadataType)result;
			}
			return base.MetadataType;
		}
	}

	public override bool IsDefinition => true;

	public new TypeDefinition DeclaringType
	{
		get
		{
			return (TypeDefinition)base.DeclaringType;
		}
		set
		{
			base.DeclaringType = value;
		}
	}

	private void ResolveLayout()
	{
		if (packing_size != -2 || class_size != -2)
		{
			return;
		}
		if (!base.HasImage)
		{
			packing_size = -1;
			class_size = -1;
			return;
		}
		Row<short, int> row = Module.Read(this, (TypeDefinition type, MetadataReader reader) => reader.ReadTypeLayout(type));
		packing_size = row.Col1;
		class_size = row.Col2;
	}

	public TypeDefinition(string @namespace, string name, TypeAttributes attributes)
		: base(@namespace, name)
	{
		this.attributes = (uint)attributes;
		token = new MetadataToken(TokenType.TypeDef);
	}

	public TypeDefinition(string @namespace, string name, TypeAttributes attributes, TypeReference baseType)
		: this(@namespace, name, attributes)
	{
		BaseType = baseType;
	}

	public override TypeDefinition Resolve()
	{
		return this;
	}
}


using System;
using System.Collections.Generic;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

internal sealed class TypeDefinitionCollection : Collection<TypeDefinition>
{
	private readonly ModuleDefinition container;

	private readonly Dictionary<Row<string, string>, TypeDefinition> name_cache;

	internal TypeDefinitionCollection(ModuleDefinition container)
	{
		this.container = container;
		name_cache = new Dictionary<Row<string, string>, TypeDefinition>(new RowEqualityComparer());
	}

	internal TypeDefinitionCollection(ModuleDefinition container, int capacity)
		: base(capacity)
	{
		this.container = container;
		name_cache = new Dictionary<Row<string, string>, TypeDefinition>(capacity, new RowEqualityComparer());
	}

	protected override void OnAdd(TypeDefinition item, int index)
	{
		Attach(item);
	}

	protected override void OnSet(TypeDefinition item, int index)
	{
		Attach(item);
	}

	protected override void OnInsert(TypeDefinition item, int index)
	{
		Attach(item);
	}

	protected override void OnRemove(TypeDefinition item, int index)
	{
		Detach(item);
	}

	protected override void OnClear()
	{
		using Enumerator enumerator = GetEnumerator();
		while (enumerator.MoveNext())
		{
			TypeDefinition current = enumerator.Current;
			Detach(current);
		}
	}

	private void Attach(TypeDefinition type)
	{
		if (type.Module != null && type.Module != container)
		{
			throw new ArgumentException("Type already attached");
		}
		type.module = container;
		type.scope = container;
		name_cache[new Row<string, string>(type.Namespace, type.Name)] = type;
	}

	private void Detach(TypeDefinition type)
	{
		type.module = null;
		type.scope = null;
		name_cache.Remove(new Row<string, string>(type.Namespace, type.Name));
	}

	public TypeDefinition GetType(string fullname)
	{
		TypeParser.SplitFullName(fullname, out var @namespace, out var name);
		return GetType(@namespace, name);
	}

	public TypeDefinition GetType(string @namespace, string name)
	{
		if (name_cache.TryGetValue(new Row<string, string>(@namespace, name), out var value))
		{
			return value;
		}
		return null;
	}
}


public enum MetadataType : byte
{
	Void = 1,
	Boolean = 2,
	Char = 3,
	SByte = 4,
	Byte = 5,
	Int16 = 6,
	UInt16 = 7,
	Int32 = 8,
	UInt32 = 9,
	Int64 = 10,
	UInt64 = 11,
	Single = 12,
	Double = 13,
	String = 14,
	Pointer = 15,
	ByReference = 16,
	ValueType = 17,
	Class = 18,
	Var = 19,
	Array = 20,
	GenericInstance = 21,
	TypedByReference = 22,
	IntPtr = 24,
	UIntPtr = 25,
	FunctionPointer = 27,
	Object = 28,
	MVar = 30,
	RequiredModifier = 31,
	OptionalModifier = 32,
	Sentinel = 65,
	Pinned = 69
}


using System;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

public class TypeReference : MemberReference, IGenericParameterProvider, IMetadataTokenProvider, IGenericContext
{
	private string @namespace;

	private bool value_type;

	internal IMetadataScope scope;

	internal ModuleDefinition module;

	internal ElementType etype;

	private string fullname;

	protected Collection<GenericParameter> generic_parameters;

	public override string Name
	{
		get
		{
			return base.Name;
		}
		set
		{
			base.Name = value;
			fullname = null;
		}
	}

	public virtual string Namespace
	{
		get
		{
			return @namespace;
		}
		set
		{
			@namespace = value;
			fullname = null;
		}
	}

	public virtual bool IsValueType
	{
		get
		{
			return value_type;
		}
		set
		{
			value_type = value;
		}
	}

	public override ModuleDefinition Module
	{
		get
		{
			if (module != null)
			{
				return module;
			}
			return DeclaringType?.Module;
		}
	}

	IGenericParameterProvider IGenericContext.Type => this;

	IGenericParameterProvider IGenericContext.Method => null;

	GenericParameterType IGenericParameterProvider.GenericParameterType => GenericParameterType.Type;

	public virtual bool HasGenericParameters => !generic_parameters.IsNullOrEmpty();

	public virtual Collection<GenericParameter> GenericParameters
	{
		get
		{
			if (generic_parameters != null)
			{
				return generic_parameters;
			}
			return generic_parameters = new GenericParameterCollection(this);
		}
	}

	public virtual IMetadataScope Scope
	{
		get
		{
			TypeReference declaringType = DeclaringType;
			if (declaringType != null)
			{
				return declaringType.Scope;
			}
			return scope;
		}
		set
		{
			TypeReference declaringType = DeclaringType;
			if (declaringType != null)
			{
				declaringType.Scope = value;
			}
			else
			{
				scope = value;
			}
		}
	}

	public bool IsNested => DeclaringType != null;

	public override TypeReference DeclaringType
	{
		get
		{
			return base.DeclaringType;
		}
		set
		{
			base.DeclaringType = value;
			fullname = null;
		}
	}

	public override string FullName
	{
		get
		{
			if (fullname != null)
			{
				return fullname;
			}
			fullname = this.TypeFullName();
			if (IsNested)
			{
				fullname = DeclaringType.FullName + "/" + fullname;
			}
			return fullname;
		}
	}

	public virtual bool IsByReference => false;

	public virtual bool IsPointer => false;

	public virtual bool IsSentinel => false;

	public virtual bool IsArray => false;

	public virtual bool IsGenericParameter => false;

	public virtual bool IsGenericInstance => false;

	public virtual bool IsRequiredModifier => false;

	public virtual bool IsOptionalModifier => false;

	public virtual bool IsPinned => false;

	public virtual bool IsFunctionPointer => false;

	public virtual bool IsPrimitive => etype.IsPrimitive();

	public virtual MetadataType MetadataType
	{
		get
		{
			if (etype == ElementType.None)
			{
				if (!IsValueType)
				{
					return MetadataType.Class;
				}
				return MetadataType.ValueType;
			}
			return (MetadataType)etype;
		}
	}

	protected TypeReference(string @namespace, string name)
		: base(name)
	{
		this.@namespace = @namespace ?? string.Empty;
		token = new MetadataToken(TokenType.TypeRef, 0);
	}

	public TypeReference(string @namespace, string name, ModuleDefinition module, IMetadataScope scope)
		: this(@namespace, name)
	{
		this.module = module;
		this.scope = scope;
	}

	public TypeReference(string @namespace, string name, ModuleDefinition module, IMetadataScope scope, bool valueType)
		: this(@namespace, name, module, scope)
	{
		value_type = valueType;
	}

	public virtual TypeReference GetElementType()
	{
		return this;
	}

	public virtual TypeDefinition Resolve()
	{
		return (Module ?? throw new NotSupportedException()).Resolve(this);
	}
}


using System;
using Mono.Cecil;

public abstract class TypeSpecification : TypeReference
{
	private readonly TypeReference element_type;

	public TypeReference ElementType => element_type;

	public override string Name
	{
		get
		{
			return element_type.Name;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override string Namespace
	{
		get
		{
			return element_type.Namespace;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override IMetadataScope Scope
	{
		get
		{
			return element_type.Scope;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override ModuleDefinition Module => element_type.Module;

	public override string FullName => element_type.FullName;

	public override bool ContainsGenericParameter => element_type.ContainsGenericParameter;

	public override MetadataType MetadataType => (MetadataType)etype;

	internal TypeSpecification(TypeReference type)
		: base(null, null)
	{
		element_type = type;
		token = new MetadataToken(TokenType.TypeSpec);
	}

	public override TypeReference GetElementType()
	{
		return element_type.GetElementType();
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

public abstract class TypeSystem
{
	private sealed class CoreTypeSystem : TypeSystem
	{
		public CoreTypeSystem(ModuleDefinition module)
			: base(module)
		{
		}

		internal override TypeReference LookupType(string @namespace, string name)
		{
			TypeReference typeReference = LookupTypeDefinition(@namespace, name) ?? LookupTypeForwarded(@namespace, name);
			if (typeReference != null)
			{
				return typeReference;
			}
			throw new NotSupportedException();
		}

		private TypeReference LookupTypeDefinition(string @namespace, string name)
		{
			if (module.MetadataSystem.Types == null)
			{
				Initialize(module.Types);
			}
			return module.Read(new Row<string, string>(@namespace, name), delegate(Row<string, string> row, MetadataReader reader)
			{
				TypeDefinition[] types = reader.metadata.Types;
				for (int i = 0; i < types.Length; i++)
				{
					if (types[i] == null)
					{
						types[i] = reader.GetTypeDefinition((uint)(i + 1));
					}
					TypeDefinition typeDefinition = types[i];
					if (typeDefinition.Name == row.Col2 && typeDefinition.Namespace == row.Col1)
					{
						return typeDefinition;
					}
				}
				return (TypeDefinition)null;
			});
		}

		private TypeReference LookupTypeForwarded(string @namespace, string name)
		{
			if (!module.HasExportedTypes)
			{
				return null;
			}
			Collection<ExportedType> exportedTypes = module.ExportedTypes;
			for (int i = 0; i < exportedTypes.Count; i++)
			{
				ExportedType exportedType = exportedTypes[i];
				if (exportedType.Name == name && exportedType.Namespace == @namespace)
				{
					return exportedType.CreateReference();
				}
			}
			return null;
		}

		private static void Initialize(object obj)
		{
		}
	}

	private sealed class CommonTypeSystem : TypeSystem
	{
		private AssemblyNameReference corlib;

		public CommonTypeSystem(ModuleDefinition module)
			: base(module)
		{
		}

		internal override TypeReference LookupType(string @namespace, string name)
		{
			return CreateTypeReference(@namespace, name);
		}

		public AssemblyNameReference GetCorlibReference()
		{
			if (corlib != null)
			{
				return corlib;
			}
			Collection<AssemblyNameReference> assemblyReferences = module.AssemblyReferences;
			for (int i = 0; i < assemblyReferences.Count; i++)
			{
				AssemblyNameReference assemblyNameReference = assemblyReferences[i];
				if (assemblyNameReference.Name == "mscorlib")
				{
					return corlib = assemblyNameReference;
				}
			}
			corlib = new AssemblyNameReference
			{
				Name = "mscorlib",
				Version = GetCorlibVersion(),
				PublicKeyToken = new byte[8] { 183, 122, 92, 86, 25, 52, 224, 137 }
			};
			assemblyReferences.Add(corlib);
			return corlib;
		}

		private Version GetCorlibVersion()
		{
			switch (module.Runtime)
			{
			case TargetRuntime.Net_1_0:
			case TargetRuntime.Net_1_1:
				return new Version(1, 0, 0, 0);
			case TargetRuntime.Net_2_0:
				return new Version(2, 0, 0, 0);
			case TargetRuntime.Net_4_0:
				return new Version(4, 0, 0, 0);
			default:
				throw new NotSupportedException();
			}
		}

		private TypeReference CreateTypeReference(string @namespace, string name)
		{
			return new TypeReference(@namespace, name, module, GetCorlibReference());
		}
	}

	private readonly ModuleDefinition module;

	private TypeReference type_object;

	private TypeReference type_void;

	private TypeReference type_bool;

	private TypeReference type_char;

	private TypeReference type_sbyte;

	private TypeReference type_byte;

	private TypeReference type_int16;

	private TypeReference type_uint16;

	private TypeReference type_int32;

	private TypeReference type_uint32;

	private TypeReference type_int64;

	private TypeReference type_uint64;

	private TypeReference type_single;

	private TypeReference type_double;

	private TypeReference type_intptr;

	private TypeReference type_uintptr;

	private TypeReference type_string;

	private TypeReference type_typedref;

	public IMetadataScope Corlib
	{
		get
		{
			if (!(this is CommonTypeSystem commonTypeSystem))
			{
				return module;
			}
			return commonTypeSystem.GetCorlibReference();
		}
	}

	public TypeReference Object => type_object ?? LookupSystemType(ref type_object, "Object", ElementType.Object);

	public TypeReference Void => type_void ?? LookupSystemType(ref type_void, "Void", ElementType.Void);

	public TypeReference Boolean => type_bool ?? LookupSystemValueType(ref type_bool, "Boolean", ElementType.Boolean);

	public TypeReference Char => type_char ?? LookupSystemValueType(ref type_char, "Char", ElementType.Char);

	public TypeReference SByte => type_sbyte ?? LookupSystemValueType(ref type_sbyte, "SByte", ElementType.I1);

	public TypeReference Byte => type_byte ?? LookupSystemValueType(ref type_byte, "Byte", ElementType.U1);

	public TypeReference Int16 => type_int16 ?? LookupSystemValueType(ref type_int16, "Int16", ElementType.I2);

	public TypeReference UInt16 => type_uint16 ?? LookupSystemValueType(ref type_uint16, "UInt16", ElementType.U2);

	public TypeReference Int32 => type_int32 ?? LookupSystemValueType(ref type_int32, "Int32", ElementType.I4);

	public TypeReference UInt32 => type_uint32 ?? LookupSystemValueType(ref type_uint32, "UInt32", ElementType.U4);

	public TypeReference Int64 => type_int64 ?? LookupSystemValueType(ref type_int64, "Int64", ElementType.I8);

	public TypeReference UInt64 => type_uint64 ?? LookupSystemValueType(ref type_uint64, "UInt64", ElementType.U8);

	public TypeReference Single => type_single ?? LookupSystemValueType(ref type_single, "Single", ElementType.R4);

	public TypeReference Double => type_double ?? LookupSystemValueType(ref type_double, "Double", ElementType.R8);

	public TypeReference IntPtr => type_intptr ?? LookupSystemValueType(ref type_intptr, "IntPtr", ElementType.I);

	public TypeReference UIntPtr => type_uintptr ?? LookupSystemValueType(ref type_uintptr, "UIntPtr", ElementType.U);

	public TypeReference String => type_string ?? LookupSystemType(ref type_string, "String", ElementType.String);

	public TypeReference TypedReference => type_typedref ?? LookupSystemValueType(ref type_typedref, "TypedReference", ElementType.TypedByRef);

	private TypeSystem(ModuleDefinition module)
	{
		this.module = module;
	}

	internal static TypeSystem CreateTypeSystem(ModuleDefinition module)
	{
		if (module.IsCorlib())
		{
			return new CoreTypeSystem(module);
		}
		return new CommonTypeSystem(module);
	}

	internal abstract TypeReference LookupType(string @namespace, string name);

	private TypeReference LookupSystemType(ref TypeReference reference, string name, ElementType element_type)
	{
		lock (module.SyncRoot)
		{
			if (reference != null)
			{
				return reference;
			}
			TypeReference typeReference = LookupType("System", name);
			typeReference.etype = element_type;
			return reference = typeReference;
		}
	}

	private TypeReference LookupSystemValueType(ref TypeReference typeRef, string name, ElementType element_type)
	{
		lock (module.SyncRoot)
		{
			if (typeRef != null)
			{
				return typeRef;
			}
			TypeReference typeReference = LookupType("System", name);
			typeReference.etype = element_type;
			typeReference.IsValueType = true;
			return typeRef = typeReference;
		}
	}
}


using System;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

private sealed class CoreTypeSystem : TypeSystem
{
	public CoreTypeSystem(ModuleDefinition module)
		: base(module)
	{
	}

	internal override TypeReference LookupType(string @namespace, string name)
	{
		TypeReference typeReference = LookupTypeDefinition(@namespace, name) ?? LookupTypeForwarded(@namespace, name);
		if (typeReference != null)
		{
			return typeReference;
		}
		throw new NotSupportedException();
	}

	private TypeReference LookupTypeDefinition(string @namespace, string name)
	{
		if (module.MetadataSystem.Types == null)
		{
			Initialize(module.Types);
		}
		return module.Read(new Row<string, string>(@namespace, name), delegate(Row<string, string> row, MetadataReader reader)
		{
			TypeDefinition[] types = reader.metadata.Types;
			for (int i = 0; i < types.Length; i++)
			{
				if (types[i] == null)
				{
					types[i] = reader.GetTypeDefinition((uint)(i + 1));
				}
				TypeDefinition typeDefinition = types[i];
				if (typeDefinition.Name == row.Col2 && typeDefinition.Namespace == row.Col1)
				{
					return typeDefinition;
				}
			}
			return (TypeDefinition)null;
		});
	}

	private TypeReference LookupTypeForwarded(string @namespace, string name)
	{
		if (!module.HasExportedTypes)
		{
			return null;
		}
		Collection<ExportedType> exportedTypes = module.ExportedTypes;
		for (int i = 0; i < exportedTypes.Count; i++)
		{
			ExportedType exportedType = exportedTypes[i];
			if (exportedType.Name == name && exportedType.Namespace == @namespace)
			{
				return exportedType.CreateReference();
			}
		}
		return null;
	}

	private static void Initialize(object obj)
	{
	}
}


using System;
using Mono.Collections.Generic;

private sealed class CommonTypeSystem : TypeSystem
{
	private AssemblyNameReference corlib;

	public CommonTypeSystem(ModuleDefinition module)
		: base(module)
	{
	}

	internal override TypeReference LookupType(string @namespace, string name)
	{
		return CreateTypeReference(@namespace, name);
	}

	public AssemblyNameReference GetCorlibReference()
	{
		if (corlib != null)
		{
			return corlib;
		}
		Collection<AssemblyNameReference> assemblyReferences = module.AssemblyReferences;
		for (int i = 0; i < assemblyReferences.Count; i++)
		{
			AssemblyNameReference assemblyNameReference = assemblyReferences[i];
			if (assemblyNameReference.Name == "mscorlib")
			{
				return corlib = assemblyNameReference;
			}
		}
		corlib = new AssemblyNameReference
		{
			Name = "mscorlib",
			Version = GetCorlibVersion(),
			PublicKeyToken = new byte[8] { 183, 122, 92, 86, 25, 52, 224, 137 }
		};
		assemblyReferences.Add(corlib);
		return corlib;
	}

	private Version GetCorlibVersion()
	{
		switch (module.Runtime)
		{
		case TargetRuntime.Net_1_0:
		case TargetRuntime.Net_1_1:
			return new Version(1, 0, 0, 0);
		case TargetRuntime.Net_2_0:
			return new Version(2, 0, 0, 0);
		case TargetRuntime.Net_4_0:
			return new Version(4, 0, 0, 0);
		default:
			throw new NotSupportedException();
		}
	}

	private TypeReference CreateTypeReference(string @namespace, string name)
	{
		return new TypeReference(@namespace, name, module, GetCorlibReference());
	}
}


public enum VariantType
{
	None = 0,
	I2 = 2,
	I4 = 3,
	R4 = 4,
	R8 = 5,
	CY = 6,
	Date = 7,
	BStr = 8,
	Dispatch = 9,
	Error = 10,
	Bool = 11,
	Variant = 12,
	Unknown = 13,
	Decimal = 14,
	I1 = 16,
	UI1 = 17,
	UI2 = 18,
	UI4 = 19,
	Int = 22,
	UInt = 23
}


using System;
using System.IO;
using System.Reflection;
using System.Security.Cryptography;
using Mono;
using Mono.Cecil;
using Mono.Cecil.PE;

internal static class CryptoService
{
	public static void StrongName(Stream stream, ImageWriter writer, StrongNameKeyPair key_pair)
	{
		int strong_name_pointer;
		byte[] strong_name = CreateStrongName(key_pair, HashStream(stream, writer, out strong_name_pointer));
		PatchStrongName(stream, strong_name_pointer, strong_name);
	}

	private static void PatchStrongName(Stream stream, int strong_name_pointer, byte[] strong_name)
	{
		stream.Seek(strong_name_pointer, SeekOrigin.Begin);
		stream.Write(strong_name, 0, strong_name.Length);
	}

	private static byte[] CreateStrongName(StrongNameKeyPair key_pair, byte[] hash)
	{
		using RSA key = key_pair.CreateRSA();
		RSAPKCS1SignatureFormatter rSAPKCS1SignatureFormatter = new RSAPKCS1SignatureFormatter(key);
		rSAPKCS1SignatureFormatter.SetHashAlgorithm("SHA1");
		byte[] array = rSAPKCS1SignatureFormatter.CreateSignature(hash);
		Array.Reverse((Array)array);
		return array;
	}

	private static byte[] HashStream(Stream stream, ImageWriter writer, out int strong_name_pointer)
	{
		Section text = writer.text;
		int headerSize = (int)writer.GetHeaderSize();
		int pointerToRawData = (int)text.PointerToRawData;
		DataDirectory strongNameSignatureDirectory = writer.GetStrongNameSignatureDirectory();
		if (strongNameSignatureDirectory.Size == 0)
		{
			throw new InvalidOperationException();
		}
		strong_name_pointer = (int)(pointerToRawData + (strongNameSignatureDirectory.VirtualAddress - text.VirtualAddress));
		int size = (int)strongNameSignatureDirectory.Size;
		SHA1Managed sHA1Managed = new SHA1Managed();
		byte[] buffer = new byte[8192];
		using (CryptoStream dest_stream = new CryptoStream(Stream.Null, sHA1Managed, CryptoStreamMode.Write))
		{
			stream.Seek(0L, SeekOrigin.Begin);
			CopyStreamChunk(stream, dest_stream, buffer, headerSize);
			stream.Seek(pointerToRawData, SeekOrigin.Begin);
			CopyStreamChunk(stream, dest_stream, buffer, strong_name_pointer - pointerToRawData);
			stream.Seek(size, SeekOrigin.Current);
			CopyStreamChunk(stream, dest_stream, buffer, (int)(stream.Length - (strong_name_pointer + size)));
		}
		return sHA1Managed.Hash;
	}

	private static void CopyStreamChunk(Stream stream, Stream dest_stream, byte[] buffer, int length)
	{
		while (length > 0)
		{
			int num = stream.Read(buffer, 0, Math.Min(buffer.Length, length));
			dest_stream.Write(buffer, 0, num);
			length -= num;
		}
	}

	public static byte[] ComputeHash(string file)
	{
		if (!File.Exists(file))
		{
			return Empty<byte>.Array;
		}
		SHA1Managed sHA1Managed = new SHA1Managed();
		using (FileStream fileStream = new FileStream(file, FileMode.Open, FileAccess.Read, FileShare.Read))
		{
			byte[] buffer = new byte[8192];
			using CryptoStream dest_stream = new CryptoStream(Stream.Null, sHA1Managed, CryptoStreamMode.Write);
			CopyStreamChunk(fileStream, dest_stream, buffer, (int)fileStream.Length);
		}
		return sHA1Managed.Hash;
	}
}


using System.IO;
using Mono.Cecil.PE;

internal class BinaryStreamReader : BinaryReader
{
	public BinaryStreamReader(Stream stream)
		: base(stream)
	{
	}

	protected void Advance(int bytes)
	{
		BaseStream.Seek(bytes, SeekOrigin.Current);
	}

	protected DataDirectory ReadDataDirectory()
	{
		return new DataDirectory(ReadUInt32(), ReadUInt32());
	}
}


using System.IO;
using Mono.Cecil.PE;

internal class BinaryStreamWriter : BinaryWriter
{
	public BinaryStreamWriter(Stream stream)
		: base(stream)
	{
	}

	public void WriteByte(byte value)
	{
		Write(value);
	}

	public void WriteUInt16(ushort value)
	{
		Write(value);
	}

	public void WriteInt16(short value)
	{
		Write(value);
	}

	public void WriteUInt32(uint value)
	{
		Write(value);
	}

	public void WriteInt32(int value)
	{
		Write(value);
	}

	public void WriteUInt64(ulong value)
	{
		Write(value);
	}

	public void WriteBytes(byte[] bytes)
	{
		Write(bytes);
	}

	public void WriteDataDirectory(DataDirectory directory)
	{
		Write(directory.VirtualAddress);
		Write(directory.Size);
	}

	public void WriteBuffer(ByteBuffer buffer)
	{
		Write(buffer.buffer, 0, buffer.length);
	}

	protected void Advance(int bytes)
	{
		BaseStream.Seek(bytes, SeekOrigin.Current);
	}
}


using System.Collections.Generic;
using Mono.Cecil.PE;

internal sealed class ByteBufferEqualityComparer : IEqualityComparer<ByteBuffer>
{
	public bool Equals(ByteBuffer x, ByteBuffer y)
	{
		if (x.length != y.length)
		{
			return false;
		}
		byte[] buffer = x.buffer;
		byte[] buffer2 = y.buffer;
		for (int i = 0; i < x.length; i++)
		{
			if (buffer[i] != buffer2[i])
			{
				return false;
			}
		}
		return true;
	}

	public int GetHashCode(ByteBuffer buffer)
	{
		int num = 0;
		byte[] buffer2 = buffer.buffer;
		for (int i = 0; i < buffer.length; i++)
		{
			num = (num * 37) ^ buffer2[i];
		}
		return num;
	}
}


using System;
using Mono;
using Mono.Cecil.PE;

internal class ByteBuffer
{
	internal byte[] buffer;

	internal int length;

	internal int position;

	public ByteBuffer()
	{
		buffer = Empty<byte>.Array;
	}

	public ByteBuffer(int length)
	{
		buffer = new byte[length];
	}

	public ByteBuffer(byte[] buffer)
	{
		this.buffer = buffer ?? Empty<byte>.Array;
		length = this.buffer.Length;
	}

	public void Reset(byte[] buffer)
	{
		this.buffer = buffer ?? Empty<byte>.Array;
		length = this.buffer.Length;
	}

	public void Advance(int length)
	{
		position += length;
	}

	public byte ReadByte()
	{
		return buffer[position++];
	}

	public sbyte ReadSByte()
	{
		return (sbyte)ReadByte();
	}

	public byte[] ReadBytes(int length)
	{
		byte[] array = new byte[length];
		Buffer.BlockCopy(buffer, position, array, 0, length);
		position += length;
		return array;
	}

	public ushort ReadUInt16()
	{
		ushort result = (ushort)(buffer[position] | (buffer[position + 1] << 8));
		position += 2;
		return result;
	}

	public short ReadInt16()
	{
		return (short)ReadUInt16();
	}

	public uint ReadUInt32()
	{
		int result = buffer[position] | (buffer[position + 1] << 8) | (buffer[position + 2] << 16) | (buffer[position + 3] << 24);
		position += 4;
		return (uint)result;
	}

	public int ReadInt32()
	{
		return (int)ReadUInt32();
	}

	public ulong ReadUInt64()
	{
		uint num = ReadUInt32();
		return ((ulong)ReadUInt32() << 32) | num;
	}

	public long ReadInt64()
	{
		return (long)ReadUInt64();
	}

	public uint ReadCompressedUInt32()
	{
		byte b = ReadByte();
		if ((b & 0x80) == 0)
		{
			return b;
		}
		if ((b & 0x40) == 0)
		{
			return (uint)(((b & -129) << 8) | ReadByte());
		}
		return (uint)(((b & -193) << 24) | (ReadByte() << 16) | (ReadByte() << 8) | ReadByte());
	}

	public int ReadCompressedInt32()
	{
		int num = (int)(ReadCompressedUInt32() >> 1);
		if ((num & 1) == 0)
		{
			return num;
		}
		if (num < 64)
		{
			return num - 64;
		}
		if (num < 8192)
		{
			return num - 8192;
		}
		if (num < 268435456)
		{
			return num - 268435456;
		}
		return num - 536870912;
	}

	public float ReadSingle()
	{
		if (!BitConverter.IsLittleEndian)
		{
			byte[] array = ReadBytes(4);
			Array.Reverse((Array)array);
			return BitConverter.ToSingle(array, 0);
		}
		float result = BitConverter.ToSingle(buffer, position);
		position += 4;
		return result;
	}

	public double ReadDouble()
	{
		if (!BitConverter.IsLittleEndian)
		{
			byte[] array = ReadBytes(8);
			Array.Reverse((Array)array);
			return BitConverter.ToDouble(array, 0);
		}
		double result = BitConverter.ToDouble(buffer, position);
		position += 8;
		return result;
	}

	public void WriteByte(byte value)
	{
		if (position == buffer.Length)
		{
			Grow(1);
		}
		buffer[position++] = value;
		if (position > length)
		{
			length = position;
		}
	}

	public void WriteSByte(sbyte value)
	{
		WriteByte((byte)value);
	}

	public void WriteUInt16(ushort value)
	{
		if (position + 2 > buffer.Length)
		{
			Grow(2);
		}
		buffer[position++] = (byte)value;
		buffer[position++] = (byte)(value >> 8);
		if (position > length)
		{
			length = position;
		}
	}

	public void WriteInt16(short value)
	{
		WriteUInt16((ushort)value);
	}

	public void WriteUInt32(uint value)
	{
		if (position + 4 > buffer.Length)
		{
			Grow(4);
		}
		buffer[position++] = (byte)value;
		buffer[position++] = (byte)(value >> 8);
		buffer[position++] = (byte)(value >> 16);
		buffer[position++] = (byte)(value >> 24);
		if (position > length)
		{
			length = position;
		}
	}

	public void WriteInt32(int value)
	{
		WriteUInt32((uint)value);
	}

	public void WriteUInt64(ulong value)
	{
		if (position + 8 > buffer.Length)
		{
			Grow(8);
		}
		buffer[position++] = (byte)value;
		buffer[position++] = (byte)(value >> 8);
		buffer[position++] = (byte)(value >> 16);
		buffer[position++] = (byte)(value >> 24);
		buffer[position++] = (byte)(value >> 32);
		buffer[position++] = (byte)(value >> 40);
		buffer[position++] = (byte)(value >> 48);
		buffer[position++] = (byte)(value >> 56);
		if (position > length)
		{
			length = position;
		}
	}

	public void WriteInt64(long value)
	{
		WriteUInt64((ulong)value);
	}

	public void WriteCompressedUInt32(uint value)
	{
		if (value < 128)
		{
			WriteByte((byte)value);
			return;
		}
		if (value < 16384)
		{
			WriteByte((byte)(0x80 | (value >> 8)));
			WriteByte((byte)(value & 0xFF));
			return;
		}
		WriteByte((byte)((value >> 24) | 0xC0));
		WriteByte((byte)((value >> 16) & 0xFF));
		WriteByte((byte)((value >> 8) & 0xFF));
		WriteByte((byte)(value & 0xFF));
	}

	public void WriteCompressedInt32(int value)
	{
		if (value >= 0)
		{
			WriteCompressedUInt32((uint)(value << 1));
			return;
		}
		if (value > -64)
		{
			value = 64 + value;
		}
		else if (value >= -8192)
		{
			value = 8192 + value;
		}
		else if (value >= -536870912)
		{
			value = 536870912 + value;
		}
		WriteCompressedUInt32((uint)((value << 1) | 1));
	}

	public void WriteBytes(byte[] bytes)
	{
		int num = bytes.Length;
		if (position + num > buffer.Length)
		{
			Grow(num);
		}
		Buffer.BlockCopy(bytes, 0, buffer, position, num);
		position += num;
		if (position > length)
		{
			length = position;
		}
	}

	public void WriteBytes(int length)
	{
		if (position + length > buffer.Length)
		{
			Grow(length);
		}
		position += length;
		if (position > this.length)
		{
			this.length = position;
		}
	}

	public void WriteBytes(ByteBuffer buffer)
	{
		if (position + buffer.length > this.buffer.Length)
		{
			Grow(buffer.length);
		}
		Buffer.BlockCopy(buffer.buffer, 0, this.buffer, position, buffer.length);
		position += buffer.length;
		if (position > length)
		{
			length = position;
		}
	}

	public void WriteSingle(float value)
	{
		byte[] bytes = BitConverter.GetBytes(value);
		if (!BitConverter.IsLittleEndian)
		{
			Array.Reverse((Array)bytes);
		}
		WriteBytes(bytes);
	}

	public void WriteDouble(double value)
	{
		byte[] bytes = BitConverter.GetBytes(value);
		if (!BitConverter.IsLittleEndian)
		{
			Array.Reverse((Array)bytes);
		}
		WriteBytes(bytes);
	}

	private void Grow(int desired)
	{
		byte[] array = buffer;
		int num = array.Length;
		byte[] dst = new byte[Math.Max(num + desired, num * 2)];
		Buffer.BlockCopy(array, 0, dst, 0, num);
		buffer = dst;
	}
}


internal struct DataDirectory
{
	public readonly uint VirtualAddress;

	public readonly uint Size;

	public bool IsZero
	{
		get
		{
			if (VirtualAddress == 0)
			{
				return Size == 0;
			}
			return false;
		}
	}

	public DataDirectory(uint rva, uint size)
	{
		VirtualAddress = rva;
		Size = size;
	}
}


using System;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;

internal sealed class Image
{
	public ModuleKind Kind;

	public string RuntimeVersion;

	public TargetArchitecture Architecture;

	public ModuleCharacteristics Characteristics;

	public string FileName;

	public Section[] Sections;

	public Section MetadataSection;

	public uint EntryPointToken;

	public ModuleAttributes Attributes;

	public DataDirectory Debug;

	public DataDirectory Resources;

	public DataDirectory StrongName;

	public StringHeap StringHeap;

	public BlobHeap BlobHeap;

	public UserStringHeap UserStringHeap;

	public GuidHeap GuidHeap;

	public TableHeap TableHeap;

	private readonly int[] coded_index_sizes = new int[13];

	private readonly Func<Table, int> counter;

	public Image()
	{
		counter = GetTableLength;
	}

	public bool HasTable(Table table)
	{
		return GetTableLength(table) > 0;
	}

	public int GetTableLength(Table table)
	{
		return (int)TableHeap[table].Length;
	}

	public int GetTableIndexSize(Table table)
	{
		if (GetTableLength(table) >= 65536)
		{
			return 4;
		}
		return 2;
	}

	public int GetCodedIndexSize(CodedIndex coded_index)
	{
		int num = coded_index_sizes[(int)coded_index];
		if (num != 0)
		{
			return num;
		}
		return coded_index_sizes[(int)coded_index] = coded_index.GetSize(counter);
	}

	public uint ResolveVirtualAddress(uint rva)
	{
		Section sectionAtVirtualAddress = GetSectionAtVirtualAddress(rva);
		if (sectionAtVirtualAddress == null)
		{
			throw new ArgumentOutOfRangeException();
		}
		return ResolveVirtualAddressInSection(rva, sectionAtVirtualAddress);
	}

	public uint ResolveVirtualAddressInSection(uint rva, Section section)
	{
		return rva + section.PointerToRawData - section.VirtualAddress;
	}

	public Section GetSection(string name)
	{
		Section[] sections = Sections;
		foreach (Section section in sections)
		{
			if (section.Name == name)
			{
				return section;
			}
		}
		return null;
	}

	public Section GetSectionAtVirtualAddress(uint rva)
	{
		Section[] sections = Sections;
		foreach (Section section in sections)
		{
			if (rva >= section.VirtualAddress && rva < section.VirtualAddress + section.SizeOfRawData)
			{
				return section;
			}
		}
		return null;
	}

	public ImageDebugDirectory GetDebugHeader(out byte[] header)
	{
		Section sectionAtVirtualAddress = GetSectionAtVirtualAddress(Debug.VirtualAddress);
		ByteBuffer byteBuffer = new ByteBuffer(sectionAtVirtualAddress.Data);
		byteBuffer.position = (int)(Debug.VirtualAddress - sectionAtVirtualAddress.VirtualAddress);
		ImageDebugDirectory imageDebugDirectory = default(ImageDebugDirectory);
		imageDebugDirectory.Characteristics = byteBuffer.ReadInt32();
		imageDebugDirectory.TimeDateStamp = byteBuffer.ReadInt32();
		imageDebugDirectory.MajorVersion = byteBuffer.ReadInt16();
		imageDebugDirectory.MinorVersion = byteBuffer.ReadInt16();
		imageDebugDirectory.Type = byteBuffer.ReadInt32();
		imageDebugDirectory.SizeOfData = byteBuffer.ReadInt32();
		imageDebugDirectory.AddressOfRawData = byteBuffer.ReadInt32();
		imageDebugDirectory.PointerToRawData = byteBuffer.ReadInt32();
		ImageDebugDirectory result = imageDebugDirectory;
		if (result.SizeOfData == 0 || result.PointerToRawData == 0)
		{
			header = Empty<byte>.Array;
			return result;
		}
		byteBuffer.position = (int)(result.PointerToRawData - sectionAtVirtualAddress.PointerToRawData);
		header = new byte[result.SizeOfData];
		Buffer.BlockCopy(byteBuffer.buffer, byteBuffer.position, header, 0, header.Length);
		return result;
	}
}


using System;
using System.IO;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;

internal sealed class ImageReader : BinaryStreamReader
{
	private readonly Image image;

	private DataDirectory cli;

	private DataDirectory metadata;

	public ImageReader(Stream stream)
		: base(stream)
	{
		image = new Image();
		image.FileName = stream.GetFullyQualifiedName();
	}

	private void MoveTo(DataDirectory directory)
	{
		BaseStream.Position = image.ResolveVirtualAddress(directory.VirtualAddress);
	}

	private void MoveTo(uint position)
	{
		BaseStream.Position = position;
	}

	private void ReadImage()
	{
		if (BaseStream.Length < 128)
		{
			throw new BadImageFormatException();
		}
		if (ReadUInt16() != 23117)
		{
			throw new BadImageFormatException();
		}
		Advance(58);
		MoveTo(ReadUInt32());
		if (ReadUInt32() != 17744)
		{
			throw new BadImageFormatException();
		}
		image.Architecture = ReadArchitecture();
		ushort count = ReadUInt16();
		Advance(14);
		ushort characteristics = ReadUInt16();
		ReadOptionalHeaders(out var subsystem, out var dll_characteristics);
		ReadSections(count);
		ReadCLIHeader();
		ReadMetadata();
		image.Kind = GetModuleKind(characteristics, subsystem);
		image.Characteristics = (ModuleCharacteristics)dll_characteristics;
	}

	private TargetArchitecture ReadArchitecture()
	{
		return ReadUInt16() switch
		{
			332 => TargetArchitecture.I386, 
			34404 => TargetArchitecture.AMD64, 
			512 => TargetArchitecture.IA64, 
			452 => TargetArchitecture.ARMv7, 
			_ => throw new NotSupportedException(), 
		};
	}

	private static ModuleKind GetModuleKind(ushort characteristics, ushort subsystem)
	{
		if ((characteristics & 0x2000) != 0)
		{
			return ModuleKind.Dll;
		}
		if (subsystem == 2 || subsystem == 9)
		{
			return ModuleKind.Windows;
		}
		return ModuleKind.Console;
	}

	private void ReadOptionalHeaders(out ushort subsystem, out ushort dll_characteristics)
	{
		bool flag = ReadUInt16() == 523;
		Advance(66);
		subsystem = ReadUInt16();
		dll_characteristics = ReadUInt16();
		Advance(flag ? 88 : 72);
		image.Debug = ReadDataDirectory();
		Advance(56);
		cli = ReadDataDirectory();
		if (cli.IsZero)
		{
			throw new BadImageFormatException();
		}
		Advance(8);
	}

	private string ReadAlignedString(int length)
	{
		int num = 0;
		char[] array = new char[length];
		while (num < length)
		{
			byte b = ReadByte();
			if (b == 0)
			{
				break;
			}
			array[num++] = (char)b;
		}
		Advance(-1 + ((num + 4) & -4) - num);
		return new string(array, 0, num);
	}

	private string ReadZeroTerminatedString(int length)
	{
		int num = 0;
		char[] array = new char[length];
		byte[] array2 = ReadBytes(length);
		while (num < length)
		{
			byte b = array2[num];
			if (b == 0)
			{
				break;
			}
			array[num++] = (char)b;
		}
		return new string(array, 0, num);
	}

	private void ReadSections(ushort count)
	{
		Section[] array = new Section[count];
		for (int i = 0; i < count; i++)
		{
			Section section = new Section();
			section.Name = ReadZeroTerminatedString(8);
			Advance(4);
			section.VirtualAddress = ReadUInt32();
			section.SizeOfRawData = ReadUInt32();
			section.PointerToRawData = ReadUInt32();
			Advance(16);
			array[i] = section;
			ReadSectionData(section);
		}
		image.Sections = array;
	}

	private void ReadSectionData(Section section)
	{
		long position = BaseStream.Position;
		MoveTo(section.PointerToRawData);
		int sizeOfRawData = (int)section.SizeOfRawData;
		byte[] array = new byte[sizeOfRawData];
		int num = 0;
		int num2;
		while ((num2 = Read(array, num, sizeOfRawData - num)) > 0)
		{
			num += num2;
		}
		section.Data = array;
		BaseStream.Position = position;
	}

	private void ReadCLIHeader()
	{
		MoveTo(cli);
		Advance(8);
		metadata = ReadDataDirectory();
		image.Attributes = (ModuleAttributes)ReadUInt32();
		image.EntryPointToken = ReadUInt32();
		image.Resources = ReadDataDirectory();
		image.StrongName = ReadDataDirectory();
	}

	private void ReadMetadata()
	{
		MoveTo(metadata);
		if (ReadUInt32() != 1112167234)
		{
			throw new BadImageFormatException();
		}
		Advance(8);
		image.RuntimeVersion = ReadZeroTerminatedString(ReadInt32());
		Advance(2);
		ushort num = ReadUInt16();
		Section sectionAtVirtualAddress = image.GetSectionAtVirtualAddress(metadata.VirtualAddress);
		if (sectionAtVirtualAddress == null)
		{
			throw new BadImageFormatException();
		}
		image.MetadataSection = sectionAtVirtualAddress;
		for (int i = 0; i < num; i++)
		{
			ReadMetadataStream(sectionAtVirtualAddress);
		}
		if (image.TableHeap != null)
		{
			ReadTableHeap();
		}
	}

	private void ReadMetadataStream(Section section)
	{
		uint start = metadata.VirtualAddress - section.VirtualAddress + ReadUInt32();
		uint size = ReadUInt32();
		switch (ReadAlignedString(16))
		{
		case "#~":
		case "#-":
			image.TableHeap = new TableHeap(section, start, size);
			break;
		case "#Strings":
			image.StringHeap = new StringHeap(section, start, size);
			break;
		case "#Blob":
			image.BlobHeap = new BlobHeap(section, start, size);
			break;
		case "#GUID":
			image.GuidHeap = new GuidHeap(section, start, size);
			break;
		case "#US":
			image.UserStringHeap = new UserStringHeap(section, start, size);
			break;
		}
	}

	private void ReadTableHeap()
	{
		TableHeap tableHeap = image.TableHeap;
		uint pointerToRawData = tableHeap.Section.PointerToRawData;
		MoveTo(tableHeap.Offset + pointerToRawData);
		Advance(6);
		byte sizes = ReadByte();
		Advance(1);
		tableHeap.Valid = ReadInt64();
		tableHeap.Sorted = ReadInt64();
		for (int i = 0; i < 45; i++)
		{
			if (tableHeap.HasTable((Table)i))
			{
				tableHeap.Tables[i].Length = ReadUInt32();
			}
		}
		SetIndexSize(image.StringHeap, sizes, 1);
		SetIndexSize(image.GuidHeap, sizes, 2);
		SetIndexSize(image.BlobHeap, sizes, 4);
		ComputeTableInformations();
	}

	private static void SetIndexSize(Heap heap, uint sizes, byte flag)
	{
		if (heap != null)
		{
			heap.IndexSize = (((sizes & flag) != 0) ? 4 : 2);
		}
	}

	private int GetTableIndexSize(Table table)
	{
		return image.GetTableIndexSize(table);
	}

	private int GetCodedIndexSize(CodedIndex index)
	{
		return image.GetCodedIndexSize(index);
	}

	private void ComputeTableInformations()
	{
		uint num = (uint)(int)BaseStream.Position - image.MetadataSection.PointerToRawData;
		int indexSize = image.StringHeap.IndexSize;
		int num2 = ((image.BlobHeap != null) ? image.BlobHeap.IndexSize : 2);
		TableHeap tableHeap = image.TableHeap;
		TableInformation[] tables = tableHeap.Tables;
		for (int i = 0; i < 45; i++)
		{
			Table table = (Table)i;
			if (tableHeap.HasTable(table))
			{
				int num3 = table switch
				{
					Table.Module => 2 + indexSize + image.GuidHeap.IndexSize * 3, 
					Table.TypeRef => GetCodedIndexSize(CodedIndex.ResolutionScope) + indexSize * 2, 
					Table.TypeDef => 4 + indexSize * 2 + GetCodedIndexSize(CodedIndex.TypeDefOrRef) + GetTableIndexSize(Table.Field) + GetTableIndexSize(Table.Method), 
					Table.FieldPtr => GetTableIndexSize(Table.Field), 
					Table.Field => 2 + indexSize + num2, 
					Table.MethodPtr => GetTableIndexSize(Table.Method), 
					Table.Method => 8 + indexSize + num2 + GetTableIndexSize(Table.Param), 
					Table.ParamPtr => GetTableIndexSize(Table.Param), 
					Table.Param => 4 + indexSize, 
					Table.InterfaceImpl => GetTableIndexSize(Table.TypeDef) + GetCodedIndexSize(CodedIndex.TypeDefOrRef), 
					Table.MemberRef => GetCodedIndexSize(CodedIndex.MemberRefParent) + indexSize + num2, 
					Table.Constant => 2 + GetCodedIndexSize(CodedIndex.HasConstant) + num2, 
					Table.CustomAttribute => GetCodedIndexSize(CodedIndex.HasCustomAttribute) + GetCodedIndexSize(CodedIndex.CustomAttributeType) + num2, 
					Table.FieldMarshal => GetCodedIndexSize(CodedIndex.HasFieldMarshal) + num2, 
					Table.DeclSecurity => 2 + GetCodedIndexSize(CodedIndex.HasDeclSecurity) + num2, 
					Table.ClassLayout => 6 + GetTableIndexSize(Table.TypeDef), 
					Table.FieldLayout => 4 + GetTableIndexSize(Table.Field), 
					Table.StandAloneSig => num2, 
					Table.EventMap => GetTableIndexSize(Table.TypeDef) + GetTableIndexSize(Table.Event), 
					Table.EventPtr => GetTableIndexSize(Table.Event), 
					Table.Event => 2 + indexSize + GetCodedIndexSize(CodedIndex.TypeDefOrRef), 
					Table.PropertyMap => GetTableIndexSize(Table.TypeDef) + GetTableIndexSize(Table.Property), 
					Table.PropertyPtr => GetTableIndexSize(Table.Property), 
					Table.Property => 2 + indexSize + num2, 
					Table.MethodSemantics => 2 + GetTableIndexSize(Table.Method) + GetCodedIndexSize(CodedIndex.HasSemantics), 
					Table.MethodImpl => GetTableIndexSize(Table.TypeDef) + GetCodedIndexSize(CodedIndex.MethodDefOrRef) + GetCodedIndexSize(CodedIndex.MethodDefOrRef), 
					Table.ModuleRef => indexSize, 
					Table.TypeSpec => num2, 
					Table.ImplMap => 2 + GetCodedIndexSize(CodedIndex.MemberForwarded) + indexSize + GetTableIndexSize(Table.ModuleRef), 
					Table.FieldRVA => 4 + GetTableIndexSize(Table.Field), 
					Table.EncLog => 8, 
					Table.EncMap => 4, 
					Table.Assembly => 16 + num2 + indexSize * 2, 
					Table.AssemblyProcessor => 4, 
					Table.AssemblyOS => 12, 
					Table.AssemblyRef => 12 + num2 * 2 + indexSize * 2, 
					Table.AssemblyRefProcessor => 4 + GetTableIndexSize(Table.AssemblyRef), 
					Table.AssemblyRefOS => 12 + GetTableIndexSize(Table.AssemblyRef), 
					Table.File => 4 + indexSize + num2, 
					Table.ExportedType => 8 + indexSize * 2 + GetCodedIndexSize(CodedIndex.Implementation), 
					Table.ManifestResource => 8 + indexSize + GetCodedIndexSize(CodedIndex.Implementation), 
					Table.NestedClass => GetTableIndexSize(Table.TypeDef) + GetTableIndexSize(Table.TypeDef), 
					Table.GenericParam => 4 + GetCodedIndexSize(CodedIndex.TypeOrMethodDef) + indexSize, 
					Table.MethodSpec => GetCodedIndexSize(CodedIndex.MethodDefOrRef) + num2, 
					Table.GenericParamConstraint => GetTableIndexSize(Table.GenericParam) + GetCodedIndexSize(CodedIndex.TypeDefOrRef), 
					_ => throw new NotSupportedException(), 
				};
				tables[i].RowSize = (uint)num3;
				tables[i].Offset = num;
				num += (uint)(num3 * (int)tables[i].Length);
			}
		}
	}

	public static Image ReadImageFrom(Stream stream)
	{
		try
		{
			ImageReader imageReader = new ImageReader(stream);
			imageReader.ReadImage();
			return imageReader.image;
		}
		catch (EndOfStreamException inner)
		{
			throw new BadImageFormatException(stream.GetFullyQualifiedName(), inner);
		}
	}
}


using System;
using System.IO;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;

internal sealed class ImageWriter : BinaryStreamWriter
{
	private readonly ModuleDefinition module;

	private readonly MetadataBuilder metadata;

	private readonly TextMap text_map;

	private ImageDebugDirectory debug_directory;

	private byte[] debug_data;

	private ByteBuffer win32_resources;

	private const uint pe_header_size = 152u;

	private const uint section_header_size = 40u;

	private const uint file_alignment = 512u;

	private const uint section_alignment = 8192u;

	private const ulong image_base = 4194304uL;

	internal const uint text_rva = 8192u;

	private readonly bool pe64;

	private readonly bool has_reloc;

	private readonly uint time_stamp;

	internal Section text;

	internal Section rsrc;

	internal Section reloc;

	private ushort sections;

	private ImageWriter(ModuleDefinition module, MetadataBuilder metadata, Stream stream)
		: base(stream)
	{
		this.module = module;
		this.metadata = metadata;
		pe64 = module.Architecture == TargetArchitecture.AMD64 || module.Architecture == TargetArchitecture.IA64;
		has_reloc = module.Architecture == TargetArchitecture.I386;
		GetDebugHeader();
		GetWin32Resources();
		text_map = BuildTextMap();
		sections = (ushort)((!has_reloc) ? 1u : 2u);
		time_stamp = (uint)DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
	}

	private void GetDebugHeader()
	{
		ISymbolWriter symbol_writer = metadata.symbol_writer;
		if (symbol_writer != null && !symbol_writer.GetDebugHeader(out debug_directory, out debug_data))
		{
			debug_data = Empty<byte>.Array;
		}
	}

	private void GetWin32Resources()
	{
		Section imageResourceSection = GetImageResourceSection();
		if (imageResourceSection != null)
		{
			byte[] array = new byte[imageResourceSection.Data.Length];
			Buffer.BlockCopy(imageResourceSection.Data, 0, array, 0, imageResourceSection.Data.Length);
			win32_resources = new ByteBuffer(array);
		}
	}

	private Section GetImageResourceSection()
	{
		if (!module.HasImage)
		{
			return null;
		}
		return module.Image.GetSection(".rsrc");
	}

	public static ImageWriter CreateWriter(ModuleDefinition module, MetadataBuilder metadata, Stream stream)
	{
		ImageWriter imageWriter = new ImageWriter(module, metadata, stream);
		imageWriter.BuildSections();
		return imageWriter;
	}

	private void BuildSections()
	{
		bool num = win32_resources != null;
		if (num)
		{
			sections++;
		}
		text = CreateSection(".text", text_map.GetLength(), null);
		Section previous = text;
		if (num)
		{
			rsrc = CreateSection(".rsrc", (uint)win32_resources.length, previous);
			PatchWin32Resources(win32_resources);
			previous = rsrc;
		}
		if (has_reloc)
		{
			reloc = CreateSection(".reloc", 12u, previous);
		}
	}

	private Section CreateSection(string name, uint size, Section previous)
	{
		return new Section
		{
			Name = name,
			VirtualAddress = ((previous != null) ? (previous.VirtualAddress + Align(previous.VirtualSize, 8192u)) : 8192u),
			VirtualSize = size,
			PointerToRawData = ((previous != null) ? (previous.PointerToRawData + previous.SizeOfRawData) : Align(GetHeaderSize(), 512u)),
			SizeOfRawData = Align(size, 512u)
		};
	}

	private static uint Align(uint value, uint align)
	{
		align--;
		return (value + align) & ~align;
	}

	private void WriteDOSHeader()
	{
		Write(new byte[128]
		{
			77, 90, 144, 0, 3, 0, 0, 0, 4, 0,
			0, 0, 255, 255, 0, 0, 184, 0, 0, 0,
			0, 0, 0, 0, 64, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			128, 0, 0, 0, 14, 31, 186, 14, 0, 180,
			9, 205, 33, 184, 1, 76, 205, 33, 84, 104,
			105, 115, 32, 112, 114, 111, 103, 114, 97, 109,
			32, 99, 97, 110, 110, 111, 116, 32, 98, 101,
			32, 114, 117, 110, 32, 105, 110, 32, 68, 79,
			83, 32, 109, 111, 100, 101, 46, 13, 13, 10,
			36, 0, 0, 0, 0, 0, 0, 0
		});
	}

	private ushort SizeOfOptionalHeader()
	{
		return (ushort)((!pe64) ? 224u : 240u);
	}

	private void WritePEFileHeader()
	{
		WriteUInt32(17744u);
		WriteUInt16(GetMachine());
		WriteUInt16(sections);
		WriteUInt32(time_stamp);
		WriteUInt32(0u);
		WriteUInt32(0u);
		WriteUInt16(SizeOfOptionalHeader());
		ushort num = (ushort)(2 | ((!pe64) ? 256 : 32));
		if (module.Kind == ModuleKind.Dll || module.Kind == ModuleKind.NetModule)
		{
			num |= 0x2000;
		}
		WriteUInt16(num);
	}

	private ushort GetMachine()
	{
		return module.Architecture switch
		{
			TargetArchitecture.I386 => 332, 
			TargetArchitecture.AMD64 => 34404, 
			TargetArchitecture.IA64 => 512, 
			TargetArchitecture.ARMv7 => 452, 
			_ => throw new NotSupportedException(), 
		};
	}

	private Section LastSection()
	{
		if (reloc != null)
		{
			return reloc;
		}
		if (rsrc != null)
		{
			return rsrc;
		}
		return text;
	}

	private void WriteOptionalHeaders()
	{
		WriteUInt16((ushort)((!pe64) ? 267u : 523u));
		WriteByte(8);
		WriteByte(0);
		WriteUInt32(text.SizeOfRawData);
		WriteUInt32(((reloc != null) ? reloc.SizeOfRawData : 0) + ((rsrc != null) ? rsrc.SizeOfRawData : 0));
		WriteUInt32(0u);
		Mono.Cecil.Range range = text_map.GetRange(TextSegment.StartupStub);
		WriteUInt32((range.Length != 0) ? range.Start : 0u);
		WriteUInt32(8192u);
		if (!pe64)
		{
			WriteUInt32(0u);
			WriteUInt32(4194304u);
		}
		else
		{
			WriteUInt64(4194304uL);
		}
		WriteUInt32(8192u);
		WriteUInt32(512u);
		WriteUInt16(4);
		WriteUInt16(0);
		WriteUInt16(0);
		WriteUInt16(0);
		WriteUInt16(4);
		WriteUInt16(0);
		WriteUInt32(0u);
		Section section = LastSection();
		WriteUInt32(section.VirtualAddress + Align(section.VirtualSize, 8192u));
		WriteUInt32(text.PointerToRawData);
		WriteUInt32(0u);
		WriteUInt16(GetSubSystem());
		WriteUInt16((ushort)module.Characteristics);
		if (!pe64)
		{
			WriteUInt32(1048576u);
			WriteUInt32(4096u);
			WriteUInt32(1048576u);
			WriteUInt32(4096u);
		}
		else
		{
			WriteUInt64(1048576uL);
			WriteUInt64(4096uL);
			WriteUInt64(1048576uL);
			WriteUInt64(4096uL);
		}
		WriteUInt32(0u);
		WriteUInt32(16u);
		WriteZeroDataDirectory();
		WriteDataDirectory(text_map.GetDataDirectory(TextSegment.ImportDirectory));
		if (rsrc != null)
		{
			WriteUInt32(rsrc.VirtualAddress);
			WriteUInt32(rsrc.VirtualSize);
		}
		else
		{
			WriteZeroDataDirectory();
		}
		WriteZeroDataDirectory();
		WriteZeroDataDirectory();
		WriteUInt32((reloc != null) ? reloc.VirtualAddress : 0u);
		WriteUInt32((reloc != null) ? reloc.VirtualSize : 0u);
		if (text_map.GetLength(TextSegment.DebugDirectory) > 0)
		{
			WriteUInt32(text_map.GetRVA(TextSegment.DebugDirectory));
			WriteUInt32(28u);
		}
		else
		{
			WriteZeroDataDirectory();
		}
		WriteZeroDataDirectory();
		WriteZeroDataDirectory();
		WriteZeroDataDirectory();
		WriteZeroDataDirectory();
		WriteZeroDataDirectory();
		WriteDataDirectory(text_map.GetDataDirectory(TextSegment.ImportAddressTable));
		WriteZeroDataDirectory();
		WriteDataDirectory(text_map.GetDataDirectory(TextSegment.CLIHeader));
		WriteZeroDataDirectory();
	}

	private void WriteZeroDataDirectory()
	{
		WriteUInt32(0u);
		WriteUInt32(0u);
	}

	private ushort GetSubSystem()
	{
		switch (module.Kind)
		{
		case ModuleKind.Dll:
		case ModuleKind.Console:
		case ModuleKind.NetModule:
			return 3;
		case ModuleKind.Windows:
			return 2;
		default:
			throw new ArgumentOutOfRangeException();
		}
	}

	private void WriteSectionHeaders()
	{
		WriteSection(text, 1610612768u);
		if (rsrc != null)
		{
			WriteSection(rsrc, 1073741888u);
		}
		if (reloc != null)
		{
			WriteSection(reloc, 1107296320u);
		}
	}

	private void WriteSection(Section section, uint characteristics)
	{
		byte[] array = new byte[8];
		string name = section.Name;
		for (int i = 0; i < name.Length; i++)
		{
			array[i] = (byte)name[i];
		}
		WriteBytes(array);
		WriteUInt32(section.VirtualSize);
		WriteUInt32(section.VirtualAddress);
		WriteUInt32(section.SizeOfRawData);
		WriteUInt32(section.PointerToRawData);
		WriteUInt32(0u);
		WriteUInt32(0u);
		WriteUInt16(0);
		WriteUInt16(0);
		WriteUInt32(characteristics);
	}

	private void MoveTo(uint pointer)
	{
		BaseStream.Seek(pointer, SeekOrigin.Begin);
	}

	private void MoveToRVA(Section section, uint rva)
	{
		BaseStream.Seek(section.PointerToRawData + rva - section.VirtualAddress, SeekOrigin.Begin);
	}

	private void MoveToRVA(TextSegment segment)
	{
		MoveToRVA(text, text_map.GetRVA(segment));
	}

	private void WriteRVA(uint rva)
	{
		if (!pe64)
		{
			WriteUInt32(rva);
		}
		else
		{
			WriteUInt64(rva);
		}
	}

	private void PrepareSection(Section section)
	{
		MoveTo(section.PointerToRawData);
		if (section.SizeOfRawData <= 4096)
		{
			Write(new byte[section.SizeOfRawData]);
			MoveTo(section.PointerToRawData);
			return;
		}
		int i = 0;
		byte[] buffer = new byte[4096];
		int num;
		for (; i != section.SizeOfRawData; i += num)
		{
			num = Math.Min((int)section.SizeOfRawData - i, 4096);
			Write(buffer, 0, num);
		}
		MoveTo(section.PointerToRawData);
	}

	private void WriteText()
	{
		PrepareSection(text);
		if (has_reloc)
		{
			WriteRVA(text_map.GetRVA(TextSegment.ImportHintNameTable));
			WriteRVA(0u);
		}
		WriteUInt32(72u);
		WriteUInt16(2);
		WriteUInt16((ushort)((module.Runtime > TargetRuntime.Net_1_1) ? 5u : 0u));
		WriteUInt32(text_map.GetRVA(TextSegment.MetadataHeader));
		WriteUInt32(GetMetadataLength());
		WriteUInt32((uint)module.Attributes);
		WriteUInt32(metadata.entry_point.ToUInt32());
		WriteDataDirectory(text_map.GetDataDirectory(TextSegment.Resources));
		WriteDataDirectory(text_map.GetDataDirectory(TextSegment.StrongNameSignature));
		WriteZeroDataDirectory();
		WriteZeroDataDirectory();
		WriteZeroDataDirectory();
		WriteZeroDataDirectory();
		MoveToRVA(TextSegment.Code);
		WriteBuffer(metadata.code);
		MoveToRVA(TextSegment.Resources);
		WriteBuffer(metadata.resources);
		if (metadata.data.length > 0)
		{
			MoveToRVA(TextSegment.Data);
			WriteBuffer(metadata.data);
		}
		MoveToRVA(TextSegment.MetadataHeader);
		WriteMetadataHeader();
		WriteMetadata();
		if (text_map.GetLength(TextSegment.DebugDirectory) > 0)
		{
			MoveToRVA(TextSegment.DebugDirectory);
			WriteDebugDirectory();
		}
		if (has_reloc)
		{
			MoveToRVA(TextSegment.ImportDirectory);
			WriteImportDirectory();
			MoveToRVA(TextSegment.StartupStub);
			WriteStartupStub();
		}
	}

	private uint GetMetadataLength()
	{
		return text_map.GetRVA(TextSegment.DebugDirectory) - text_map.GetRVA(TextSegment.MetadataHeader);
	}

	private void WriteMetadataHeader()
	{
		WriteUInt32(1112167234u);
		WriteUInt16(1);
		WriteUInt16(1);
		WriteUInt32(0u);
		byte[] zeroTerminatedString = GetZeroTerminatedString(module.runtime_version);
		WriteUInt32((uint)zeroTerminatedString.Length);
		WriteBytes(zeroTerminatedString);
		WriteUInt16(0);
		WriteUInt16(GetStreamCount());
		uint offset = text_map.GetRVA(TextSegment.TableHeap) - text_map.GetRVA(TextSegment.MetadataHeader);
		WriteStreamHeader(ref offset, TextSegment.TableHeap, "#~");
		WriteStreamHeader(ref offset, TextSegment.StringHeap, "#Strings");
		WriteStreamHeader(ref offset, TextSegment.UserStringHeap, "#US");
		WriteStreamHeader(ref offset, TextSegment.GuidHeap, "#GUID");
		WriteStreamHeader(ref offset, TextSegment.BlobHeap, "#Blob");
	}

	private ushort GetStreamCount()
	{
		return (ushort)((uint)(2 + ((!metadata.user_string_heap.IsEmpty) ? 1 : 0) + 1) + ((!metadata.blob_heap.IsEmpty) ? 1u : 0u));
	}

	private void WriteStreamHeader(ref uint offset, TextSegment heap, string name)
	{
		uint length = (uint)text_map.GetLength(heap);
		if (length != 0)
		{
			WriteUInt32(offset);
			WriteUInt32(length);
			WriteBytes(GetZeroTerminatedString(name));
			offset += length;
		}
	}

	private static byte[] GetZeroTerminatedString(string @string)
	{
		return GetString(@string, (@string.Length + 1 + 3) & -4);
	}

	private static byte[] GetSimpleString(string @string)
	{
		return GetString(@string, @string.Length);
	}

	private static byte[] GetString(string @string, int length)
	{
		byte[] array = new byte[length];
		for (int i = 0; i < @string.Length; i++)
		{
			array[i] = (byte)@string[i];
		}
		return array;
	}

	private void WriteMetadata()
	{
		WriteHeap(TextSegment.TableHeap, metadata.table_heap);
		WriteHeap(TextSegment.StringHeap, metadata.string_heap);
		WriteHeap(TextSegment.UserStringHeap, metadata.user_string_heap);
		WriteGuidHeap();
		WriteHeap(TextSegment.BlobHeap, metadata.blob_heap);
	}

	private void WriteHeap(TextSegment heap, HeapBuffer buffer)
	{
		if (!buffer.IsEmpty)
		{
			MoveToRVA(heap);
			WriteBuffer(buffer);
		}
	}

	private void WriteGuidHeap()
	{
		MoveToRVA(TextSegment.GuidHeap);
		WriteBytes(module.Mvid.ToByteArray());
	}

	private void WriteDebugDirectory()
	{
		WriteInt32(debug_directory.Characteristics);
		WriteUInt32(time_stamp);
		WriteInt16(debug_directory.MajorVersion);
		WriteInt16(debug_directory.MinorVersion);
		WriteInt32(debug_directory.Type);
		WriteInt32(debug_directory.SizeOfData);
		WriteInt32(debug_directory.AddressOfRawData);
		WriteInt32((int)BaseStream.Position + 4);
		WriteBytes(debug_data);
	}

	private void WriteImportDirectory()
	{
		WriteUInt32(text_map.GetRVA(TextSegment.ImportDirectory) + 40);
		WriteUInt32(0u);
		WriteUInt32(0u);
		WriteUInt32(text_map.GetRVA(TextSegment.ImportHintNameTable) + 14);
		WriteUInt32(text_map.GetRVA(TextSegment.ImportAddressTable));
		Advance(20);
		WriteUInt32(text_map.GetRVA(TextSegment.ImportHintNameTable));
		MoveToRVA(TextSegment.ImportHintNameTable);
		WriteUInt16(0);
		WriteBytes(GetRuntimeMain());
		WriteByte(0);
		WriteBytes(GetSimpleString("mscoree.dll"));
		WriteUInt16(0);
	}

	private byte[] GetRuntimeMain()
	{
		if (module.Kind != 0 && module.Kind != ModuleKind.NetModule)
		{
			return GetSimpleString("_CorExeMain");
		}
		return GetSimpleString("_CorDllMain");
	}

	private void WriteStartupStub()
	{
		if (module.Architecture == TargetArchitecture.I386)
		{
			WriteUInt16(9727);
			WriteUInt32(4194304 + text_map.GetRVA(TextSegment.ImportAddressTable));
			return;
		}
		throw new NotSupportedException();
	}

	private void WriteRsrc()
	{
		PrepareSection(rsrc);
		WriteBuffer(win32_resources);
	}

	private void WriteReloc()
	{
		PrepareSection(reloc);
		uint rVA = text_map.GetRVA(TextSegment.StartupStub);
		rVA += (uint)((module.Architecture == TargetArchitecture.IA64) ? 32 : 2);
		uint num = rVA & 0xFFFFF000u;
		WriteUInt32(num);
		WriteUInt32(12u);
		if (module.Architecture == TargetArchitecture.I386)
		{
			WriteUInt32(12288 + rVA - num);
			return;
		}
		throw new NotSupportedException();
	}

	public void WriteImage()
	{
		WriteDOSHeader();
		WritePEFileHeader();
		WriteOptionalHeaders();
		WriteSectionHeaders();
		WriteText();
		if (rsrc != null)
		{
			WriteRsrc();
		}
		if (reloc != null)
		{
			WriteReloc();
		}
	}

	private TextMap BuildTextMap()
	{
		TextMap textMap = metadata.text_map;
		textMap.AddMap(TextSegment.Code, metadata.code.length, (!pe64) ? 4 : 16);
		textMap.AddMap(TextSegment.Resources, metadata.resources.length, 8);
		textMap.AddMap(TextSegment.Data, metadata.data.length, 4);
		if (metadata.data.length > 0)
		{
			metadata.table_heap.FixupData(textMap.GetRVA(TextSegment.Data));
		}
		textMap.AddMap(TextSegment.StrongNameSignature, GetStrongNameLength(), 4);
		textMap.AddMap(TextSegment.MetadataHeader, GetMetadataHeaderLength());
		textMap.AddMap(TextSegment.TableHeap, metadata.table_heap.length, 4);
		textMap.AddMap(TextSegment.StringHeap, metadata.string_heap.length, 4);
		textMap.AddMap(TextSegment.UserStringHeap, (!metadata.user_string_heap.IsEmpty) ? metadata.user_string_heap.length : 0, 4);
		textMap.AddMap(TextSegment.GuidHeap, 16);
		textMap.AddMap(TextSegment.BlobHeap, (!metadata.blob_heap.IsEmpty) ? metadata.blob_heap.length : 0, 4);
		int length = 0;
		if (!debug_data.IsNullOrEmpty())
		{
			debug_directory.AddressOfRawData = (int)(textMap.GetNextRVA(TextSegment.BlobHeap) + 28);
			length = debug_data.Length + 28;
		}
		textMap.AddMap(TextSegment.DebugDirectory, length, 4);
		if (!has_reloc)
		{
			uint nextRVA = textMap.GetNextRVA(TextSegment.DebugDirectory);
			textMap.AddMap(TextSegment.ImportDirectory, new Mono.Cecil.Range(nextRVA, 0u));
			textMap.AddMap(TextSegment.ImportHintNameTable, new Mono.Cecil.Range(nextRVA, 0u));
			textMap.AddMap(TextSegment.StartupStub, new Mono.Cecil.Range(nextRVA, 0u));
			return textMap;
		}
		uint nextRVA2 = textMap.GetNextRVA(TextSegment.DebugDirectory);
		uint num = nextRVA2 + 48;
		num = (num + 15) & 0xFFFFFFF0u;
		uint num2 = num - nextRVA2 + 27;
		uint num3 = nextRVA2 + num2;
		num3 = ((module.Architecture == TargetArchitecture.IA64) ? ((num3 + 15) & 0xFFFFFFF0u) : (2 + ((num3 + 3) & 0xFFFFFFFCu)));
		textMap.AddMap(TextSegment.ImportDirectory, new Mono.Cecil.Range(nextRVA2, num2));
		textMap.AddMap(TextSegment.ImportHintNameTable, new Mono.Cecil.Range(num, 0u));
		textMap.AddMap(TextSegment.StartupStub, new Mono.Cecil.Range(num3, GetStartupStubLength()));
		return textMap;
	}

	private uint GetStartupStubLength()
	{
		if (module.Architecture == TargetArchitecture.I386)
		{
			return 6u;
		}
		throw new NotSupportedException();
	}

	private int GetMetadataHeaderLength()
	{
		return 72 + ((!metadata.user_string_heap.IsEmpty) ? 12 : 0) + 16 + ((!metadata.blob_heap.IsEmpty) ? 16 : 0);
	}

	private int GetStrongNameLength()
	{
		if (module.Assembly == null)
		{
			return 0;
		}
		byte[] publicKey = module.Assembly.Name.PublicKey;
		if (publicKey.IsNullOrEmpty())
		{
			return 0;
		}
		int num = publicKey.Length;
		if (num > 32)
		{
			return num - 32;
		}
		return 128;
	}

	public DataDirectory GetStrongNameSignatureDirectory()
	{
		return text_map.GetDataDirectory(TextSegment.StrongNameSignature);
	}

	public uint GetHeaderSize()
	{
		return (uint)(152 + SizeOfOptionalHeader() + sections * 40);
	}

	private void PatchWin32Resources(ByteBuffer resources)
	{
		PatchResourceDirectoryTable(resources);
	}

	private void PatchResourceDirectoryTable(ByteBuffer resources)
	{
		resources.Advance(12);
		int num = resources.ReadUInt16() + resources.ReadUInt16();
		for (int i = 0; i < num; i++)
		{
			PatchResourceDirectoryEntry(resources);
		}
	}

	private void PatchResourceDirectoryEntry(ByteBuffer resources)
	{
		resources.Advance(4);
		uint num = resources.ReadUInt32();
		int position = resources.position;
		resources.position = (int)(num & 0x7FFFFFFF);
		if ((num & 0x80000000u) != 0)
		{
			PatchResourceDirectoryTable(resources);
		}
		else
		{
			PatchResourceDataEntry(resources);
		}
		resources.position = position;
	}

	private void PatchResourceDataEntry(ByteBuffer resources)
	{
		Section imageResourceSection = GetImageResourceSection();
		uint num = resources.ReadUInt32();
		resources.position -= 4;
		resources.WriteUInt32(num - imageResourceSection.VirtualAddress + rsrc.VirtualAddress);
	}
}


internal sealed class Section
{
	public string Name;

	public uint VirtualAddress;

	public uint VirtualSize;

	public uint SizeOfRawData;

	public uint PointerToRawData;

	public byte[] Data;
}


internal enum TextSegment
{
	ImportAddressTable,
	CLIHeader,
	Code,
	Resources,
	Data,
	StrongNameSignature,
	MetadataHeader,
	TableHeap,
	StringHeap,
	UserStringHeap,
	GuidHeap,
	BlobHeap,
	DebugDirectory,
	ImportDirectory,
	ImportHintNameTable,
	StartupStub
}


using Mono.Cecil;
using Mono.Cecil.PE;

internal sealed class TextMap
{
	private readonly Range[] map = new Range[16];

	public void AddMap(TextSegment segment, int length)
	{
		map[(int)segment] = new Range(GetStart(segment), (uint)length);
	}

	public void AddMap(TextSegment segment, int length, int align)
	{
		align--;
		AddMap(segment, (length + align) & ~align);
	}

	public void AddMap(TextSegment segment, Range range)
	{
		map[(int)segment] = range;
	}

	public Range GetRange(TextSegment segment)
	{
		return map[(int)segment];
	}

	public DataDirectory GetDataDirectory(TextSegment segment)
	{
		Range range = map[(int)segment];
		return new DataDirectory((range.Length != 0) ? range.Start : 0u, range.Length);
	}

	public uint GetRVA(TextSegment segment)
	{
		return map[(int)segment].Start;
	}

	public uint GetNextRVA(TextSegment segment)
	{
		return map[(int)segment].Start + map[(int)segment].Length;
	}

	public int GetLength(TextSegment segment)
	{
		return (int)map[(int)segment].Length;
	}

	private uint GetStart(TextSegment segment)
	{
		if (segment != 0)
		{
			return ComputeStart((int)segment);
		}
		return 8192u;
	}

	private uint ComputeStart(int index)
	{
		index--;
		return map[index].Start + map[index].Length;
	}

	public uint GetLength()
	{
		Range range = map[15];
		return range.Start - 8192 + range.Length;
	}
}


using System;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;

internal sealed class BlobHeap : Heap
{
	public BlobHeap(Section section, uint start, uint size)
		: base(section, start, size)
	{
	}

	public byte[] Read(uint index)
	{
		if (index == 0 || index > Size - 1)
		{
			return Empty<byte>.Array;
		}
		byte[] data = Section.Data;
		int position = (int)(index + Offset);
		int num = (int)data.ReadCompressedUInt32(ref position);
		byte[] array = new byte[num];
		Buffer.BlockCopy(data, position, array, 0, num);
		return array;
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class TableHeapBuffer : HeapBuffer
{
	private readonly ModuleDefinition module;

	private readonly MetadataBuilder metadata;

	internal MetadataTable[] tables = new MetadataTable[45];

	private bool large_string;

	private bool large_blob;

	private readonly int[] coded_index_sizes = new int[13];

	private readonly Func<Table, int> counter;

	public override bool IsEmpty => false;

	public TableHeapBuffer(ModuleDefinition module, MetadataBuilder metadata)
		: base(24)
	{
		this.module = module;
		this.metadata = metadata;
		counter = GetTableLength;
	}

	private int GetTableLength(Table table)
	{
		return tables[(uint)table]?.Length ?? 0;
	}

	public TTable GetTable<TTable>(Table table) where TTable : MetadataTable, new()
	{
		TTable val = (TTable)tables[(uint)table];
		if (val != null)
		{
			return val;
		}
		val = new TTable();
		tables[(uint)table] = val;
		return val;
	}

	public void WriteBySize(uint value, int size)
	{
		if (size == 4)
		{
			WriteUInt32(value);
		}
		else
		{
			WriteUInt16((ushort)value);
		}
	}

	public void WriteBySize(uint value, bool large)
	{
		if (large)
		{
			WriteUInt32(value);
		}
		else
		{
			WriteUInt16((ushort)value);
		}
	}

	public void WriteString(uint @string)
	{
		WriteBySize(@string, large_string);
	}

	public void WriteBlob(uint blob)
	{
		WriteBySize(blob, large_blob);
	}

	public void WriteRID(uint rid, Table table)
	{
		WriteBySize(rid, tables[(uint)table]?.IsLarge ?? false);
	}

	private int GetCodedIndexSize(CodedIndex coded_index)
	{
		int num = coded_index_sizes[(int)coded_index];
		if (num != 0)
		{
			return num;
		}
		return coded_index_sizes[(int)coded_index] = coded_index.GetSize(counter);
	}

	public void WriteCodedRID(uint rid, CodedIndex coded_index)
	{
		WriteBySize(rid, GetCodedIndexSize(coded_index));
	}

	public void WriteTableHeap()
	{
		WriteUInt32(0u);
		WriteByte(GetTableHeapVersion());
		WriteByte(0);
		WriteByte(GetHeapSizes());
		WriteByte(10);
		WriteUInt64(GetValid());
		WriteUInt64(24190111578624uL);
		WriteRowCount();
		WriteTables();
	}

	private void WriteRowCount()
	{
		for (int i = 0; i < tables.Length; i++)
		{
			MetadataTable metadataTable = tables[i];
			if (metadataTable != null && metadataTable.Length != 0)
			{
				WriteUInt32((uint)metadataTable.Length);
			}
		}
	}

	private void WriteTables()
	{
		for (int i = 0; i < tables.Length; i++)
		{
			MetadataTable metadataTable = tables[i];
			if (metadataTable != null && metadataTable.Length != 0)
			{
				metadataTable.Write(this);
			}
		}
	}

	private ulong GetValid()
	{
		ulong num = 0uL;
		for (int i = 0; i < tables.Length; i++)
		{
			MetadataTable metadataTable = tables[i];
			if (metadataTable != null && metadataTable.Length != 0)
			{
				metadataTable.Sort();
				num |= (ulong)(1L << i);
			}
		}
		return num;
	}

	private byte GetHeapSizes()
	{
		byte b = 0;
		if (metadata.string_heap.IsLarge)
		{
			large_string = true;
			b |= 1;
		}
		if (metadata.blob_heap.IsLarge)
		{
			large_blob = true;
			b |= 4;
		}
		return b;
	}

	private byte GetTableHeapVersion()
	{
		TargetRuntime runtime = module.Runtime;
		if (runtime == TargetRuntime.Net_1_0 || runtime == TargetRuntime.Net_1_1)
		{
			return 1;
		}
		return 2;
	}

	public void FixupData(uint data_rva)
	{
		FieldRVATable table = GetTable<FieldRVATable>(Table.FieldRVA);
		if (table.length != 0)
		{
			int num = (GetTable<FieldTable>(Table.Field).IsLarge ? 4 : 2);
			int num2 = position;
			position = table.position;
			for (int i = 0; i < table.length; i++)
			{
				uint num3 = ReadUInt32();
				position -= 4;
				WriteUInt32(num3 + data_rva);
				position += num;
			}
			position = num2;
		}
	}
}


using Mono.Cecil.PE;

internal sealed class ResourceBuffer : ByteBuffer
{
	public ResourceBuffer()
		: base(0)
	{
	}

	public uint AddResource(byte[] resource)
	{
		int result = position;
		WriteInt32(resource.Length);
		WriteBytes(resource);
		return (uint)result;
	}
}


using Mono.Cecil.PE;

internal sealed class DataBuffer : ByteBuffer
{
	public DataBuffer()
		: base(0)
	{
	}

	public uint AddData(byte[] data)
	{
		int result = position;
		WriteBytes(data);
		return (uint)result;
	}
}


using Mono.Cecil.PE;

internal abstract class HeapBuffer : ByteBuffer
{
	public bool IsLarge => length > 65535;

	public abstract bool IsEmpty { get; }

	protected HeapBuffer(int length)
		: base(length)
	{
	}
}


using System;
using System.Collections.Generic;
using System.Text;
using Mono.Cecil.Metadata;

internal class StringHeapBuffer : HeapBuffer
{
	private readonly Dictionary<string, uint> strings = new Dictionary<string, uint>(StringComparer.Ordinal);

	public sealed override bool IsEmpty => length <= 1;

	public StringHeapBuffer()
		: base(1)
	{
		WriteByte(0);
	}

	public uint GetStringIndex(string @string)
	{
		if (strings.TryGetValue(@string, out var value))
		{
			return value;
		}
		value = (uint)position;
		WriteString(@string);
		strings.Add(@string, value);
		return value;
	}

	protected virtual void WriteString(string @string)
	{
		WriteBytes(Encoding.UTF8.GetBytes(@string));
		WriteByte(0);
	}
}


using System.Collections.Generic;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;

internal sealed class BlobHeapBuffer : HeapBuffer
{
	private readonly Dictionary<ByteBuffer, uint> blobs = new Dictionary<ByteBuffer, uint>(new ByteBufferEqualityComparer());

	public override bool IsEmpty => length <= 1;

	public BlobHeapBuffer()
		: base(1)
	{
		WriteByte(0);
	}

	public uint GetBlobIndex(ByteBuffer blob)
	{
		if (blobs.TryGetValue(blob, out var value))
		{
			return value;
		}
		value = (uint)position;
		WriteBlob(blob);
		blobs.Add(blob, value);
		return value;
	}

	private void WriteBlob(ByteBuffer blob)
	{
		WriteCompressedUInt32((uint)blob.length);
		WriteBytes(blob);
	}
}


using Mono.Cecil.Metadata;

internal sealed class UserStringHeapBuffer : StringHeapBuffer
{
	protected override void WriteString(string @string)
	{
		WriteCompressedUInt32((uint)(@string.Length * 2 + 1));
		byte b = 0;
		foreach (char c in @string)
		{
			WriteUInt16(c);
			if (b != 1 && (c < ' ' || c > '~') && (c > '~' || (c >= '\u0001' && c <= '\b') || (c >= '\u000e' && c <= '\u001f') || c == '\'' || c == '-'))
			{
				b = 1;
			}
		}
		WriteByte(b);
	}
}


internal enum CodedIndex
{
	TypeDefOrRef,
	HasConstant,
	HasCustomAttribute,
	HasFieldMarshal,
	HasDeclSecurity,
	MemberRefParent,
	HasSemantics,
	MethodDefOrRef,
	MemberForwarded,
	Implementation,
	CustomAttributeType,
	ResolutionScope,
	TypeOrMethodDef
}


internal enum ElementType : byte
{
	None = 0,
	Void = 1,
	Boolean = 2,
	Char = 3,
	I1 = 4,
	U1 = 5,
	I2 = 6,
	U2 = 7,
	I4 = 8,
	U4 = 9,
	I8 = 10,
	U8 = 11,
	R4 = 12,
	R8 = 13,
	String = 14,
	Ptr = 15,
	ByRef = 16,
	ValueType = 17,
	Class = 18,
	Var = 19,
	Array = 20,
	GenericInst = 21,
	TypedByRef = 22,
	I = 24,
	U = 25,
	FnPtr = 27,
	Object = 28,
	SzArray = 29,
	MVar = 30,
	CModReqD = 31,
	CModOpt = 32,
	Internal = 33,
	Modifier = 64,
	Sentinel = 65,
	Pinned = 69,
	Type = 80,
	Boxed = 81,
	Enum = 85
}


using System;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;

internal sealed class GuidHeap : Heap
{
	public GuidHeap(Section section, uint start, uint size)
		: base(section, start, size)
	{
	}

	public Guid Read(uint index)
	{
		if (index == 0)
		{
			return default(Guid);
		}
		byte[] array = new byte[16];
		index--;
		Buffer.BlockCopy(Section.Data, (int)(Offset + index), array, 0, 16);
		return new Guid(array);
	}
}


using Mono.Cecil.PE;

internal abstract class Heap
{
	public int IndexSize;

	public readonly Section Section;

	public readonly uint Offset;

	public readonly uint Size;

	protected Heap(Section section, uint offset, uint size)
	{
		Section = section;
		Offset = offset;
		Size = size;
	}
}


internal struct Row<T1, T2>
{
	internal T1 Col1;

	internal T2 Col2;

	public Row(T1 col1, T2 col2)
	{
		Col1 = col1;
		Col2 = col2;
	}
}


internal struct Row<T1, T2, T3>
{
	internal T1 Col1;

	internal T2 Col2;

	internal T3 Col3;

	public Row(T1 col1, T2 col2, T3 col3)
	{
		Col1 = col1;
		Col2 = col2;
		Col3 = col3;
	}
}


internal struct Row<T1, T2, T3, T4>
{
	internal T1 Col1;

	internal T2 Col2;

	internal T3 Col3;

	internal T4 Col4;

	public Row(T1 col1, T2 col2, T3 col3, T4 col4)
	{
		Col1 = col1;
		Col2 = col2;
		Col3 = col3;
		Col4 = col4;
	}
}


internal struct Row<T1, T2, T3, T4, T5>
{
	internal T1 Col1;

	internal T2 Col2;

	internal T3 Col3;

	internal T4 Col4;

	internal T5 Col5;

	public Row(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5)
	{
		Col1 = col1;
		Col2 = col2;
		Col3 = col3;
		Col4 = col4;
		Col5 = col5;
	}
}


internal struct Row<T1, T2, T3, T4, T5, T6>
{
	internal T1 Col1;

	internal T2 Col2;

	internal T3 Col3;

	internal T4 Col4;

	internal T5 Col5;

	internal T6 Col6;

	public Row(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6)
	{
		Col1 = col1;
		Col2 = col2;
		Col3 = col3;
		Col4 = col4;
		Col5 = col5;
		Col6 = col6;
	}
}


internal struct Row<T1, T2, T3, T4, T5, T6, T7, T8, T9>
{
	internal T1 Col1;

	internal T2 Col2;

	internal T3 Col3;

	internal T4 Col4;

	internal T5 Col5;

	internal T6 Col6;

	internal T7 Col7;

	internal T8 Col8;

	internal T9 Col9;

	public Row(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6, T7 col7, T8 col8, T9 col9)
	{
		Col1 = col1;
		Col2 = col2;
		Col3 = col3;
		Col4 = col4;
		Col5 = col5;
		Col6 = col6;
		Col7 = col7;
		Col8 = col8;
		Col9 = col9;
	}
}


using System.Collections.Generic;
using Mono.Cecil.Metadata;

internal sealed class RowEqualityComparer : IEqualityComparer<Row<string, string>>, IEqualityComparer<Row<uint, uint>>, IEqualityComparer<Row<uint, uint, uint>>
{
	public bool Equals(Row<string, string> x, Row<string, string> y)
	{
		if (x.Col1 == y.Col1)
		{
			return x.Col2 == y.Col2;
		}
		return false;
	}

	public int GetHashCode(Row<string, string> obj)
	{
		string col = obj.Col1;
		string col2 = obj.Col2;
		return (col?.GetHashCode() ?? 0) ^ (col2?.GetHashCode() ?? 0);
	}

	public bool Equals(Row<uint, uint> x, Row<uint, uint> y)
	{
		if (x.Col1 == y.Col1)
		{
			return x.Col2 == y.Col2;
		}
		return false;
	}

	public int GetHashCode(Row<uint, uint> obj)
	{
		return (int)(obj.Col1 ^ obj.Col2);
	}

	public bool Equals(Row<uint, uint, uint> x, Row<uint, uint, uint> y)
	{
		if (x.Col1 == y.Col1 && x.Col2 == y.Col2)
		{
			return x.Col3 == y.Col3;
		}
		return false;
	}

	public int GetHashCode(Row<uint, uint, uint> obj)
	{
		return (int)(obj.Col1 ^ obj.Col2 ^ obj.Col3);
	}
}


using System.Collections.Generic;
using System.Text;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;

internal class StringHeap : Heap
{
	private readonly Dictionary<uint, string> strings = new Dictionary<uint, string>();

	public StringHeap(Section section, uint start, uint size)
		: base(section, start, size)
	{
	}

	public string Read(uint index)
	{
		if (index == 0)
		{
			return string.Empty;
		}
		if (strings.TryGetValue(index, out var value))
		{
			return value;
		}
		if (index > Size - 1)
		{
			return string.Empty;
		}
		value = ReadStringAt(index);
		if (value.Length != 0)
		{
			strings.Add(index, value);
		}
		return value;
	}

	protected virtual string ReadStringAt(uint index)
	{
		int num = 0;
		byte[] data = Section.Data;
		int num2 = (int)(index + Offset);
		for (int i = num2; data[i] != 0; i++)
		{
			num++;
		}
		return Encoding.UTF8.GetString(data, num2, num);
	}
}


internal enum Table : byte
{
	Module,
	TypeRef,
	TypeDef,
	FieldPtr,
	Field,
	MethodPtr,
	Method,
	ParamPtr,
	Param,
	InterfaceImpl,
	MemberRef,
	Constant,
	CustomAttribute,
	FieldMarshal,
	DeclSecurity,
	ClassLayout,
	FieldLayout,
	StandAloneSig,
	EventMap,
	EventPtr,
	Event,
	PropertyMap,
	PropertyPtr,
	Property,
	MethodSemantics,
	MethodImpl,
	ModuleRef,
	TypeSpec,
	ImplMap,
	FieldRVA,
	EncLog,
	EncMap,
	Assembly,
	AssemblyProcessor,
	AssemblyOS,
	AssemblyRef,
	AssemblyRefProcessor,
	AssemblyRefOS,
	File,
	ExportedType,
	ManifestResource,
	NestedClass,
	GenericParam,
	MethodSpec,
	GenericParamConstraint
}


internal struct TableInformation
{
	public uint Offset;

	public uint Length;

	public uint RowSize;
}


using Mono.Cecil.Metadata;
using Mono.Cecil.PE;

internal sealed class TableHeap : Heap
{
	public long Valid;

	public long Sorted;

	public const int TableCount = 45;

	public readonly TableInformation[] Tables = new TableInformation[45];

	public TableInformation this[Table table] => Tables[(uint)table];

	public TableHeap(Section section, uint start, uint size)
		: base(section, start, size)
	{
	}

	public bool HasTable(Table table)
	{
		return (Valid & (1L << (int)table)) != 0;
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;

internal sealed class UserStringHeap : StringHeap
{
	public UserStringHeap(Section section, uint start, uint size)
		: base(section, start, size)
	{
	}

	protected override string ReadStringAt(uint index)
	{
		byte[] data = Section.Data;
		int position = (int)(index + Offset);
		uint num = (uint)(data.ReadCompressedUInt32(ref position) & -2);
		if (num < 1)
		{
			return string.Empty;
		}
		char[] array = new char[num / 2];
		int i = position;
		int num2 = 0;
		for (; i < position + num; i += 2)
		{
			array[num2++] = (char)(data[i] | (data[i + 1] << 8));
		}
		return new string(array);
	}
}


public enum Code
{
	Nop,
	Break,
	Ldarg_0,
	Ldarg_1,
	Ldarg_2,
	Ldarg_3,
	Ldloc_0,
	Ldloc_1,
	Ldloc_2,
	Ldloc_3,
	Stloc_0,
	Stloc_1,
	Stloc_2,
	Stloc_3,
	Ldarg_S,
	Ldarga_S,
	Starg_S,
	Ldloc_S,
	Ldloca_S,
	Stloc_S,
	Ldnull,
	Ldc_I4_M1,
	Ldc_I4_0,
	Ldc_I4_1,
	Ldc_I4_2,
	Ldc_I4_3,
	Ldc_I4_4,
	Ldc_I4_5,
	Ldc_I4_6,
	Ldc_I4_7,
	Ldc_I4_8,
	Ldc_I4_S,
	Ldc_I4,
	Ldc_I8,
	Ldc_R4,
	Ldc_R8,
	Dup,
	Pop,
	Jmp,
	Call,
	Calli,
	Ret,
	Br_S,
	Brfalse_S,
	Brtrue_S,
	Beq_S,
	Bge_S,
	Bgt_S,
	Ble_S,
	Blt_S,
	Bne_Un_S,
	Bge_Un_S,
	Bgt_Un_S,
	Ble_Un_S,
	Blt_Un_S,
	Br,
	Brfalse,
	Brtrue,
	Beq,
	Bge,
	Bgt,
	Ble,
	Blt,
	Bne_Un,
	Bge_Un,
	Bgt_Un,
	Ble_Un,
	Blt_Un,
	Switch,
	Ldind_I1,
	Ldind_U1,
	Ldind_I2,
	Ldind_U2,
	Ldind_I4,
	Ldind_U4,
	Ldind_I8,
	Ldind_I,
	Ldind_R4,
	Ldind_R8,
	Ldind_Ref,
	Stind_Ref,
	Stind_I1,
	Stind_I2,
	Stind_I4,
	Stind_I8,
	Stind_R4,
	Stind_R8,
	Add,
	Sub,
	Mul,
	Div,
	Div_Un,
	Rem,
	Rem_Un,
	And,
	Or,
	Xor,
	Shl,
	Shr,
	Shr_Un,
	Neg,
	Not,
	Conv_I1,
	Conv_I2,
	Conv_I4,
	Conv_I8,
	Conv_R4,
	Conv_R8,
	Conv_U4,
	Conv_U8,
	Callvirt,
	Cpobj,
	Ldobj,
	Ldstr,
	Newobj,
	Castclass,
	Isinst,
	Conv_R_Un,
	Unbox,
	Throw,
	Ldfld,
	Ldflda,
	Stfld,
	Ldsfld,
	Ldsflda,
	Stsfld,
	Stobj,
	Conv_Ovf_I1_Un,
	Conv_Ovf_I2_Un,
	Conv_Ovf_I4_Un,
	Conv_Ovf_I8_Un,
	Conv_Ovf_U1_Un,
	Conv_Ovf_U2_Un,
	Conv_Ovf_U4_Un,
	Conv_Ovf_U8_Un,
	Conv_Ovf_I_Un,
	Conv_Ovf_U_Un,
	Box,
	Newarr,
	Ldlen,
	Ldelema,
	Ldelem_I1,
	Ldelem_U1,
	Ldelem_I2,
	Ldelem_U2,
	Ldelem_I4,
	Ldelem_U4,
	Ldelem_I8,
	Ldelem_I,
	Ldelem_R4,
	Ldelem_R8,
	Ldelem_Ref,
	Stelem_I,
	Stelem_I1,
	Stelem_I2,
	Stelem_I4,
	Stelem_I8,
	Stelem_R4,
	Stelem_R8,
	Stelem_Ref,
	Ldelem_Any,
	Stelem_Any,
	Unbox_Any,
	Conv_Ovf_I1,
	Conv_Ovf_U1,
	Conv_Ovf_I2,
	Conv_Ovf_U2,
	Conv_Ovf_I4,
	Conv_Ovf_U4,
	Conv_Ovf_I8,
	Conv_Ovf_U8,
	Refanyval,
	Ckfinite,
	Mkrefany,
	Ldtoken,
	Conv_U2,
	Conv_U1,
	Conv_I,
	Conv_Ovf_I,
	Conv_Ovf_U,
	Add_Ovf,
	Add_Ovf_Un,
	Mul_Ovf,
	Mul_Ovf_Un,
	Sub_Ovf,
	Sub_Ovf_Un,
	Endfinally,
	Leave,
	Leave_S,
	Stind_I,
	Conv_U,
	Arglist,
	Ceq,
	Cgt,
	Cgt_Un,
	Clt,
	Clt_Un,
	Ldftn,
	Ldvirtftn,
	Ldarg,
	Ldarga,
	Starg,
	Ldloc,
	Ldloca,
	Stloc,
	Localloc,
	Endfilter,
	Unaligned,
	Volatile,
	Tail,
	Initobj,
	Constrained,
	Cpblk,
	Initblk,
	No,
	Rethrow,
	Sizeof,
	Refanytype,
	Readonly
}


using System;
using System.Collections.Generic;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;
using Mono.Collections.Generic;

internal sealed class CodeWriter : ByteBuffer
{
	private readonly uint code_base;

	internal readonly MetadataBuilder metadata;

	private readonly Dictionary<uint, MetadataToken> standalone_signatures;

	private uint current;

	private MethodBody body;

	public CodeWriter(MetadataBuilder metadata)
		: base(0)
	{
		code_base = metadata.text_map.GetNextRVA(TextSegment.CLIHeader);
		current = code_base;
		this.metadata = metadata;
		standalone_signatures = new Dictionary<uint, MetadataToken>();
	}

	public uint WriteMethodBody(MethodDefinition method)
	{
		uint result = BeginMethod();
		if (IsUnresolved(method))
		{
			if (method.rva == 0)
			{
				return 0u;
			}
			WriteUnresolvedMethodBody(method);
		}
		else
		{
			if (IsEmptyMethodBody(method.Body))
			{
				return 0u;
			}
			WriteResolvedMethodBody(method);
		}
		Align(4);
		EndMethod();
		return result;
	}

	private static bool IsEmptyMethodBody(MethodBody body)
	{
		if (body.instructions.IsNullOrEmpty())
		{
			return body.variables.IsNullOrEmpty();
		}
		return false;
	}

	private static bool IsUnresolved(MethodDefinition method)
	{
		if (method.HasBody && method.HasImage)
		{
			return method.body == null;
		}
		return false;
	}

	private void WriteUnresolvedMethodBody(MethodDefinition method)
	{
		MethodSymbols symbols;
		ByteBuffer byteBuffer = metadata.module.Read(method, (MethodDefinition _, MetadataReader reader) => reader.code).PatchRawMethodBody(method, this, out symbols);
		WriteBytes(byteBuffer);
		if (!symbols.instructions.IsNullOrEmpty())
		{
			symbols.method_token = method.token;
			symbols.local_var_token = GetLocalVarToken(byteBuffer, symbols);
			metadata.symbol_writer?.Write(symbols);
		}
	}

	private static MetadataToken GetLocalVarToken(ByteBuffer buffer, MethodSymbols symbols)
	{
		if (symbols.variables.IsNullOrEmpty())
		{
			return MetadataToken.Zero;
		}
		buffer.position = 8;
		return new MetadataToken(buffer.ReadUInt32());
	}

	private void WriteResolvedMethodBody(MethodDefinition method)
	{
		body = method.Body;
		ComputeHeader();
		if (RequiresFatHeader())
		{
			WriteFatHeader();
		}
		else
		{
			WriteByte((byte)(2 | (body.CodeSize << 2)));
		}
		WriteInstructions();
		if (body.HasExceptionHandlers)
		{
			WriteExceptionHandlers();
		}
		metadata.symbol_writer?.Write(body);
	}

	private void WriteFatHeader()
	{
		MethodBody methodBody = body;
		byte b = 3;
		if (methodBody.InitLocals)
		{
			b |= 0x10;
		}
		if (methodBody.HasExceptionHandlers)
		{
			b |= 8;
		}
		WriteByte(b);
		WriteByte(48);
		WriteInt16((short)methodBody.max_stack_size);
		WriteInt32(methodBody.code_size);
		methodBody.local_var_token = (methodBody.HasVariables ? GetStandAloneSignature(methodBody.Variables) : MetadataToken.Zero);
		WriteMetadataToken(methodBody.local_var_token);
	}

	private void WriteInstructions()
	{
		Collection<Instruction> instructions = body.Instructions;
		Instruction[] items = instructions.items;
		int size = instructions.size;
		for (int i = 0; i < size; i++)
		{
			Instruction instruction = items[i];
			WriteOpCode(instruction.opcode);
			WriteOperand(instruction);
		}
	}

	private void WriteOpCode(OpCode opcode)
	{
		if (opcode.Size == 1)
		{
			WriteByte(opcode.Op2);
			return;
		}
		WriteByte(opcode.Op1);
		WriteByte(opcode.Op2);
	}

	private void WriteOperand(Instruction instruction)
	{
		OpCode opcode = instruction.opcode;
		OperandType operandType = opcode.OperandType;
		if (operandType == OperandType.InlineNone)
		{
			return;
		}
		object operand = instruction.operand;
		if (operand == null)
		{
			throw new ArgumentException();
		}
		switch (operandType)
		{
		case OperandType.InlineSwitch:
		{
			Instruction[] array = (Instruction[])operand;
			WriteInt32(array.Length);
			int num = instruction.Offset + opcode.Size + 4 * (array.Length + 1);
			for (int i = 0; i < array.Length; i++)
			{
				WriteInt32(GetTargetOffset(array[i]) - num);
			}
			break;
		}
		case OperandType.ShortInlineBrTarget:
		{
			Instruction instruction2 = (Instruction)operand;
			WriteSByte((sbyte)(GetTargetOffset(instruction2) - (instruction.Offset + opcode.Size + 1)));
			break;
		}
		case OperandType.InlineBrTarget:
		{
			Instruction instruction3 = (Instruction)operand;
			WriteInt32(GetTargetOffset(instruction3) - (instruction.Offset + opcode.Size + 4));
			break;
		}
		case OperandType.ShortInlineVar:
			WriteByte((byte)GetVariableIndex((VariableDefinition)operand));
			break;
		case OperandType.ShortInlineArg:
			WriteByte((byte)GetParameterIndex((ParameterDefinition)operand));
			break;
		case OperandType.InlineVar:
			WriteInt16((short)GetVariableIndex((VariableDefinition)operand));
			break;
		case OperandType.InlineArg:
			WriteInt16((short)GetParameterIndex((ParameterDefinition)operand));
			break;
		case OperandType.InlineSig:
			WriteMetadataToken(GetStandAloneSignature((CallSite)operand));
			break;
		case OperandType.ShortInlineI:
			if (opcode == OpCodes.Ldc_I4_S)
			{
				WriteSByte((sbyte)operand);
			}
			else
			{
				WriteByte((byte)operand);
			}
			break;
		case OperandType.InlineI:
			WriteInt32((int)operand);
			break;
		case OperandType.InlineI8:
			WriteInt64((long)operand);
			break;
		case OperandType.ShortInlineR:
			WriteSingle((float)operand);
			break;
		case OperandType.InlineR:
			WriteDouble((double)operand);
			break;
		case OperandType.InlineString:
			WriteMetadataToken(new MetadataToken(TokenType.String, GetUserStringIndex((string)operand)));
			break;
		case OperandType.InlineField:
		case OperandType.InlineMethod:
		case OperandType.InlineTok:
		case OperandType.InlineType:
			WriteMetadataToken(metadata.LookupToken((IMetadataTokenProvider)operand));
			break;
		default:
			throw new ArgumentException();
		}
	}

	private int GetTargetOffset(Instruction instruction)
	{
		if (instruction == null)
		{
			Instruction instruction2 = body.instructions[body.instructions.size - 1];
			return instruction2.offset + instruction2.GetSize();
		}
		return instruction.offset;
	}

	private uint GetUserStringIndex(string @string)
	{
		if (@string == null)
		{
			return 0u;
		}
		return metadata.user_string_heap.GetStringIndex(@string);
	}

	private static int GetVariableIndex(VariableDefinition variable)
	{
		return variable.Index;
	}

	private int GetParameterIndex(ParameterDefinition parameter)
	{
		if (body.method.HasThis)
		{
			if (parameter == body.this_parameter)
			{
				return 0;
			}
			return parameter.Index + 1;
		}
		return parameter.Index;
	}

	private bool RequiresFatHeader()
	{
		MethodBody methodBody = body;
		if (methodBody.CodeSize < 64 && !methodBody.InitLocals && !methodBody.HasVariables && !methodBody.HasExceptionHandlers)
		{
			return methodBody.MaxStackSize > 8;
		}
		return true;
	}

	private void ComputeHeader()
	{
		int num = 0;
		Collection<Instruction> instructions = body.instructions;
		Instruction[] items = instructions.items;
		int size = instructions.size;
		int stack_size = 0;
		int max_stack = 0;
		Dictionary<Instruction, int> stack_sizes = null;
		if (body.HasExceptionHandlers)
		{
			ComputeExceptionHandlerStackSize(ref stack_sizes);
		}
		for (int i = 0; i < size; i++)
		{
			Instruction instruction = items[i];
			instruction.offset = num;
			num += instruction.GetSize();
			ComputeStackSize(instruction, ref stack_sizes, ref stack_size, ref max_stack);
		}
		body.code_size = num;
		body.max_stack_size = max_stack;
	}

	private void ComputeExceptionHandlerStackSize(ref Dictionary<Instruction, int> stack_sizes)
	{
		Collection<ExceptionHandler> exceptionHandlers = body.ExceptionHandlers;
		for (int i = 0; i < exceptionHandlers.Count; i++)
		{
			ExceptionHandler exceptionHandler = exceptionHandlers[i];
			switch (exceptionHandler.HandlerType)
			{
			case ExceptionHandlerType.Catch:
				AddExceptionStackSize(exceptionHandler.HandlerStart, ref stack_sizes);
				break;
			case ExceptionHandlerType.Filter:
				AddExceptionStackSize(exceptionHandler.FilterStart, ref stack_sizes);
				AddExceptionStackSize(exceptionHandler.HandlerStart, ref stack_sizes);
				break;
			}
		}
	}

	private static void AddExceptionStackSize(Instruction handler_start, ref Dictionary<Instruction, int> stack_sizes)
	{
		if (handler_start != null)
		{
			if (stack_sizes == null)
			{
				stack_sizes = new Dictionary<Instruction, int>();
			}
			stack_sizes[handler_start] = 1;
		}
	}

	private static void ComputeStackSize(Instruction instruction, ref Dictionary<Instruction, int> stack_sizes, ref int stack_size, ref int max_stack)
	{
		if (stack_sizes != null && stack_sizes.TryGetValue(instruction, out var value))
		{
			stack_size = value;
		}
		max_stack = Math.Max(max_stack, stack_size);
		ComputeStackDelta(instruction, ref stack_size);
		max_stack = Math.Max(max_stack, stack_size);
		CopyBranchStackSize(instruction, ref stack_sizes, stack_size);
		ComputeStackSize(instruction, ref stack_size);
	}

	private static void CopyBranchStackSize(Instruction instruction, ref Dictionary<Instruction, int> stack_sizes, int stack_size)
	{
		if (stack_size == 0)
		{
			return;
		}
		switch (instruction.opcode.OperandType)
		{
		case OperandType.InlineBrTarget:
		case OperandType.ShortInlineBrTarget:
			CopyBranchStackSize(ref stack_sizes, (Instruction)instruction.operand, stack_size);
			break;
		case OperandType.InlineSwitch:
		{
			Instruction[] array = (Instruction[])instruction.operand;
			for (int i = 0; i < array.Length; i++)
			{
				CopyBranchStackSize(ref stack_sizes, array[i], stack_size);
			}
			break;
		}
		}
	}

	private static void CopyBranchStackSize(ref Dictionary<Instruction, int> stack_sizes, Instruction target, int stack_size)
	{
		if (stack_sizes == null)
		{
			stack_sizes = new Dictionary<Instruction, int>();
		}
		int num = stack_size;
		if (stack_sizes.TryGetValue(target, out var value))
		{
			num = Math.Max(num, value);
		}
		stack_sizes[target] = num;
	}

	private static void ComputeStackSize(Instruction instruction, ref int stack_size)
	{
		switch (instruction.opcode.FlowControl)
		{
		case FlowControl.Branch:
		case FlowControl.Break:
		case FlowControl.Return:
		case FlowControl.Throw:
			stack_size = 0;
			break;
		}
	}

	private static void ComputeStackDelta(Instruction instruction, ref int stack_size)
	{
		FlowControl flowControl = instruction.opcode.FlowControl;
		if (flowControl == FlowControl.Call)
		{
			IMethodSignature methodSignature = (IMethodSignature)instruction.operand;
			if (methodSignature.HasImplicitThis() && instruction.opcode.Code != Code.Newobj)
			{
				stack_size--;
			}
			if (methodSignature.HasParameters)
			{
				stack_size -= methodSignature.Parameters.Count;
			}
			if (instruction.opcode.Code == Code.Calli)
			{
				stack_size--;
			}
			if (methodSignature.ReturnType.etype != ElementType.Void || instruction.opcode.Code == Code.Newobj)
			{
				stack_size++;
			}
		}
		else
		{
			ComputePopDelta(instruction.opcode.StackBehaviourPop, ref stack_size);
			ComputePushDelta(instruction.opcode.StackBehaviourPush, ref stack_size);
		}
	}

	private static void ComputePopDelta(StackBehaviour pop_behavior, ref int stack_size)
	{
		switch (pop_behavior)
		{
		case StackBehaviour.Pop1:
		case StackBehaviour.Popi:
		case StackBehaviour.Popref:
			stack_size--;
			break;
		case StackBehaviour.Pop1_pop1:
		case StackBehaviour.Popi_pop1:
		case StackBehaviour.Popi_popi:
		case StackBehaviour.Popi_popi8:
		case StackBehaviour.Popi_popr4:
		case StackBehaviour.Popi_popr8:
		case StackBehaviour.Popref_pop1:
		case StackBehaviour.Popref_popi:
			stack_size -= 2;
			break;
		case StackBehaviour.Popi_popi_popi:
		case StackBehaviour.Popref_popi_popi:
		case StackBehaviour.Popref_popi_popi8:
		case StackBehaviour.Popref_popi_popr4:
		case StackBehaviour.Popref_popi_popr8:
		case StackBehaviour.Popref_popi_popref:
			stack_size -= 3;
			break;
		case StackBehaviour.PopAll:
			stack_size = 0;
			break;
		}
	}

	private static void ComputePushDelta(StackBehaviour push_behaviour, ref int stack_size)
	{
		switch (push_behaviour)
		{
		case StackBehaviour.Push1:
		case StackBehaviour.Pushi:
		case StackBehaviour.Pushi8:
		case StackBehaviour.Pushr4:
		case StackBehaviour.Pushr8:
		case StackBehaviour.Pushref:
			stack_size++;
			break;
		case StackBehaviour.Push1_push1:
			stack_size += 2;
			break;
		}
	}

	private void WriteExceptionHandlers()
	{
		Align(4);
		Collection<ExceptionHandler> exceptionHandlers = body.ExceptionHandlers;
		if (exceptionHandlers.Count < 21 && !RequiresFatSection(exceptionHandlers))
		{
			WriteSmallSection(exceptionHandlers);
		}
		else
		{
			WriteFatSection(exceptionHandlers);
		}
	}

	private static bool RequiresFatSection(Collection<ExceptionHandler> handlers)
	{
		for (int i = 0; i < handlers.Count; i++)
		{
			ExceptionHandler exceptionHandler = handlers[i];
			if (IsFatRange(exceptionHandler.TryStart, exceptionHandler.TryEnd))
			{
				return true;
			}
			if (IsFatRange(exceptionHandler.HandlerStart, exceptionHandler.HandlerEnd))
			{
				return true;
			}
			if (exceptionHandler.HandlerType == ExceptionHandlerType.Filter && IsFatRange(exceptionHandler.FilterStart, exceptionHandler.HandlerStart))
			{
				return true;
			}
		}
		return false;
	}

	private static bool IsFatRange(Instruction start, Instruction end)
	{
		if (start == null)
		{
			throw new ArgumentException();
		}
		if (end == null)
		{
			return true;
		}
		if (end.Offset - start.Offset <= 255)
		{
			return start.Offset > 65535;
		}
		return true;
	}

	private void WriteSmallSection(Collection<ExceptionHandler> handlers)
	{
		WriteByte(1);
		WriteByte((byte)(handlers.Count * 12 + 4));
		WriteBytes(2);
		WriteExceptionHandlers(handlers, delegate(int i)
		{
			WriteUInt16((ushort)i);
		}, delegate(int i)
		{
			WriteByte((byte)i);
		});
	}

	private void WriteFatSection(Collection<ExceptionHandler> handlers)
	{
		WriteByte(65);
		int num = handlers.Count * 24 + 4;
		WriteByte((byte)(num & 0xFF));
		WriteByte((byte)((num >> 8) & 0xFF));
		WriteByte((byte)((num >> 16) & 0xFF));
		WriteExceptionHandlers(handlers, base.WriteInt32, base.WriteInt32);
	}

	private void WriteExceptionHandlers(Collection<ExceptionHandler> handlers, Action<int> write_entry, Action<int> write_length)
	{
		for (int i = 0; i < handlers.Count; i++)
		{
			ExceptionHandler exceptionHandler = handlers[i];
			write_entry((int)exceptionHandler.HandlerType);
			write_entry(exceptionHandler.TryStart.Offset);
			write_length(GetTargetOffset(exceptionHandler.TryEnd) - exceptionHandler.TryStart.Offset);
			write_entry(exceptionHandler.HandlerStart.Offset);
			write_length(GetTargetOffset(exceptionHandler.HandlerEnd) - exceptionHandler.HandlerStart.Offset);
			WriteExceptionHandlerSpecific(exceptionHandler);
		}
	}

	private void WriteExceptionHandlerSpecific(ExceptionHandler handler)
	{
		switch (handler.HandlerType)
		{
		case ExceptionHandlerType.Catch:
			WriteMetadataToken(metadata.LookupToken(handler.CatchType));
			break;
		case ExceptionHandlerType.Filter:
			WriteInt32(handler.FilterStart.Offset);
			break;
		default:
			WriteInt32(0);
			break;
		}
	}

	public MetadataToken GetStandAloneSignature(Collection<VariableDefinition> variables)
	{
		uint localVariableBlobIndex = metadata.GetLocalVariableBlobIndex(variables);
		return GetStandAloneSignatureToken(localVariableBlobIndex);
	}

	public MetadataToken GetStandAloneSignature(CallSite call_site)
	{
		uint callSiteBlobIndex = metadata.GetCallSiteBlobIndex(call_site);
		return call_site.MetadataToken = GetStandAloneSignatureToken(callSiteBlobIndex);
	}

	private MetadataToken GetStandAloneSignatureToken(uint signature)
	{
		if (standalone_signatures.TryGetValue(signature, out var value))
		{
			return value;
		}
		value = new MetadataToken(TokenType.Signature, metadata.AddStandAloneSignature(signature));
		standalone_signatures.Add(signature, value);
		return value;
	}

	private uint BeginMethod()
	{
		return current;
	}

	private void WriteMetadataToken(MetadataToken token)
	{
		WriteUInt32(token.ToUInt32());
	}

	private void Align(int align)
	{
		align--;
		WriteBytes(((position + align) & ~align) - position);
	}

	private void EndMethod()
	{
		current = (uint)(code_base + position);
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.PE;
using Mono.Collections.Generic;

internal sealed class CodeReader : ByteBuffer
{
	internal readonly MetadataReader reader;

	private int start;

	private Section code_section;

	private MethodDefinition method;

	private MethodBody body;

	private int Offset => position - start;

	public CodeReader(Section section, MetadataReader reader)
		: base(section.Data)
	{
		code_section = section;
		this.reader = reader;
	}

	public MethodBody ReadMethodBody(MethodDefinition method)
	{
		this.method = method;
		body = new MethodBody(method);
		reader.context = method;
		ReadMethodBody();
		return body;
	}

	public void MoveTo(int rva)
	{
		if (!IsInSection(rva))
		{
			code_section = reader.image.GetSectionAtVirtualAddress((uint)rva);
			Reset(code_section.Data);
		}
		position = rva - (int)code_section.VirtualAddress;
	}

	private bool IsInSection(int rva)
	{
		if (code_section.VirtualAddress <= rva)
		{
			return rva < code_section.VirtualAddress + code_section.SizeOfRawData;
		}
		return false;
	}

	private void ReadMethodBody()
	{
		MoveTo(method.RVA);
		byte b = ReadByte();
		switch (b & 3)
		{
		case 2:
			body.code_size = b >> 2;
			body.MaxStackSize = 8;
			ReadCode();
			break;
		case 3:
			position--;
			ReadFatMethod();
			break;
		default:
			throw new InvalidOperationException();
		}
		ISymbolReader symbol_reader = reader.module.symbol_reader;
		if (symbol_reader != null)
		{
			Collection<Instruction> instructions = body.Instructions;
			symbol_reader.Read(body, (int offset) => GetInstruction(instructions, offset));
		}
	}

	private void ReadFatMethod()
	{
		ushort num = ReadUInt16();
		body.max_stack_size = ReadUInt16();
		body.code_size = (int)ReadUInt32();
		body.local_var_token = new MetadataToken(ReadUInt32());
		body.init_locals = (num & 0x10) != 0;
		if (body.local_var_token.RID != 0)
		{
			body.variables = ReadVariables(body.local_var_token);
		}
		ReadCode();
		if ((num & 8) != 0)
		{
			ReadSection();
		}
	}

	public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token)
	{
		int num = reader.position;
		VariableDefinitionCollection result = reader.ReadVariables(local_var_token);
		reader.position = num;
		return result;
	}

	private void ReadCode()
	{
		start = position;
		int num = body.code_size;
		if (num < 0 || buffer.Length <= (uint)(num + position))
		{
			num = 0;
		}
		int num2 = start + num;
		Collection<Instruction> collection = (body.instructions = new InstructionCollection((num + 1) / 2));
		while (position < num2)
		{
			int offset = position - start;
			OpCode opCode = ReadOpCode();
			Instruction instruction = new Instruction(offset, opCode);
			if (opCode.OperandType != OperandType.InlineNone)
			{
				instruction.operand = ReadOperand(instruction);
			}
			collection.Add(instruction);
		}
		ResolveBranches(collection);
	}

	private OpCode ReadOpCode()
	{
		byte b = ReadByte();
		if (b == 254)
		{
			return OpCodes.TwoBytesOpCode[ReadByte()];
		}
		return OpCodes.OneByteOpCode[b];
	}

	private object ReadOperand(Instruction instruction)
	{
		switch (instruction.opcode.OperandType)
		{
		case OperandType.InlineSwitch:
		{
			int num = ReadInt32();
			int num2 = Offset + 4 * num;
			int[] array = new int[num];
			for (int i = 0; i < num; i++)
			{
				array[i] = num2 + ReadInt32();
			}
			return array;
		}
		case OperandType.ShortInlineBrTarget:
			return ReadSByte() + Offset;
		case OperandType.InlineBrTarget:
			return ReadInt32() + Offset;
		case OperandType.ShortInlineI:
			if (instruction.opcode == OpCodes.Ldc_I4_S)
			{
				return ReadSByte();
			}
			return ReadByte();
		case OperandType.InlineI:
			return ReadInt32();
		case OperandType.ShortInlineR:
			return ReadSingle();
		case OperandType.InlineR:
			return ReadDouble();
		case OperandType.InlineI8:
			return ReadInt64();
		case OperandType.ShortInlineVar:
			return GetVariable(ReadByte());
		case OperandType.InlineVar:
			return GetVariable(ReadUInt16());
		case OperandType.ShortInlineArg:
			return GetParameter(ReadByte());
		case OperandType.InlineArg:
			return GetParameter(ReadUInt16());
		case OperandType.InlineSig:
			return GetCallSite(ReadToken());
		case OperandType.InlineString:
			return GetString(ReadToken());
		case OperandType.InlineField:
		case OperandType.InlineMethod:
		case OperandType.InlineTok:
		case OperandType.InlineType:
			return reader.LookupToken(ReadToken());
		default:
			throw new NotSupportedException();
		}
	}

	public string GetString(MetadataToken token)
	{
		return reader.image.UserStringHeap.Read(token.RID);
	}

	public ParameterDefinition GetParameter(int index)
	{
		return body.GetParameter(index);
	}

	public VariableDefinition GetVariable(int index)
	{
		return body.GetVariable(index);
	}

	public CallSite GetCallSite(MetadataToken token)
	{
		return reader.ReadCallSite(token);
	}

	private void ResolveBranches(Collection<Instruction> instructions)
	{
		Instruction[] items = instructions.items;
		int size = instructions.size;
		for (int i = 0; i < size; i++)
		{
			Instruction instruction = items[i];
			switch (instruction.opcode.OperandType)
			{
			case OperandType.InlineBrTarget:
			case OperandType.ShortInlineBrTarget:
				instruction.operand = GetInstruction((int)instruction.operand);
				break;
			case OperandType.InlineSwitch:
			{
				int[] array = (int[])instruction.operand;
				Instruction[] array2 = new Instruction[array.Length];
				for (int j = 0; j < array.Length; j++)
				{
					array2[j] = GetInstruction(array[j]);
				}
				instruction.operand = array2;
				break;
			}
			}
		}
	}

	private Instruction GetInstruction(int offset)
	{
		return GetInstruction(body.Instructions, offset);
	}

	private static Instruction GetInstruction(Collection<Instruction> instructions, int offset)
	{
		int size = instructions.size;
		Instruction[] items = instructions.items;
		if (offset < 0 || offset > items[size - 1].offset)
		{
			return null;
		}
		int num = 0;
		int num2 = size - 1;
		while (num <= num2)
		{
			int num3 = num + (num2 - num) / 2;
			Instruction instruction = items[num3];
			int offset2 = instruction.offset;
			if (offset == offset2)
			{
				return instruction;
			}
			if (offset < offset2)
			{
				num2 = num3 - 1;
			}
			else
			{
				num = num3 + 1;
			}
		}
		return null;
	}

	private void ReadSection()
	{
		Align(4);
		byte num = ReadByte();
		if ((num & 0x40) == 0)
		{
			ReadSmallSection();
		}
		else
		{
			ReadFatSection();
		}
		if ((num & 0x80) != 0)
		{
			ReadSection();
		}
	}

	private void ReadSmallSection()
	{
		int count = ReadByte() / 12;
		Advance(2);
		ReadExceptionHandlers(count, () => ReadUInt16(), () => ReadByte());
	}

	private void ReadFatSection()
	{
		position--;
		int count = (ReadInt32() >> 8) / 24;
		ReadExceptionHandlers(count, base.ReadInt32, base.ReadInt32);
	}

	private void ReadExceptionHandlers(int count, Func<int> read_entry, Func<int> read_length)
	{
		for (int i = 0; i < count; i++)
		{
			ExceptionHandler exceptionHandler = new ExceptionHandler((ExceptionHandlerType)(read_entry() & 7));
			exceptionHandler.TryStart = GetInstruction(read_entry());
			exceptionHandler.TryEnd = GetInstruction(exceptionHandler.TryStart.Offset + read_length());
			exceptionHandler.HandlerStart = GetInstruction(read_entry());
			exceptionHandler.HandlerEnd = GetInstruction(exceptionHandler.HandlerStart.Offset + read_length());
			ReadExceptionHandlerSpecific(exceptionHandler);
			body.ExceptionHandlers.Add(exceptionHandler);
		}
	}

	private void ReadExceptionHandlerSpecific(ExceptionHandler handler)
	{
		switch (handler.HandlerType)
		{
		case ExceptionHandlerType.Catch:
			handler.CatchType = (TypeReference)reader.LookupToken(ReadToken());
			break;
		case ExceptionHandlerType.Filter:
			handler.FilterStart = GetInstruction(ReadInt32());
			break;
		default:
			Advance(4);
			break;
		}
	}

	private void Align(int align)
	{
		align--;
		Advance(((position + align) & ~align) - position);
	}

	public MetadataToken ReadToken()
	{
		return new MetadataToken(ReadUInt32());
	}

	public ByteBuffer PatchRawMethodBody(MethodDefinition method, CodeWriter writer, out MethodSymbols symbols)
	{
		ByteBuffer byteBuffer = new ByteBuffer();
		symbols = new MethodSymbols(method.Name);
		this.method = method;
		reader.context = method;
		MoveTo(method.RVA);
		byte b = ReadByte();
		MetadataToken local_var_token;
		switch (b & 3)
		{
		case 2:
			byteBuffer.WriteByte(b);
			local_var_token = MetadataToken.Zero;
			symbols.code_size = b >> 2;
			PatchRawCode(byteBuffer, symbols.code_size, writer);
			break;
		case 3:
			position--;
			PatchRawFatMethod(byteBuffer, symbols, writer, out local_var_token);
			break;
		default:
			throw new NotSupportedException();
		}
		ISymbolReader symbol_reader = reader.module.symbol_reader;
		if (symbol_reader != null && writer.metadata.write_symbols)
		{
			symbols.method_token = GetOriginalToken(writer.metadata, method);
			symbols.local_var_token = local_var_token;
			symbol_reader.Read(symbols);
		}
		return byteBuffer;
	}

	private void PatchRawFatMethod(ByteBuffer buffer, MethodSymbols symbols, CodeWriter writer, out MetadataToken local_var_token)
	{
		ushort num = ReadUInt16();
		buffer.WriteUInt16(num);
		buffer.WriteUInt16(ReadUInt16());
		symbols.code_size = ReadInt32();
		buffer.WriteInt32(symbols.code_size);
		local_var_token = ReadToken();
		if (local_var_token.RID != 0)
		{
			buffer.WriteUInt32(((symbols.variables = ReadVariables(local_var_token)) != null) ? writer.GetStandAloneSignature(symbols.variables).ToUInt32() : 0u);
		}
		else
		{
			buffer.WriteUInt32(0u);
		}
		PatchRawCode(buffer, symbols.code_size, writer);
		if ((num & 8) != 0)
		{
			PatchRawSection(buffer, writer.metadata);
		}
	}

	private static MetadataToken GetOriginalToken(MetadataBuilder metadata, MethodDefinition method)
	{
		if (metadata.TryGetOriginalMethodToken(method.token, out var original))
		{
			return original;
		}
		return MetadataToken.Zero;
	}

	private void PatchRawCode(ByteBuffer buffer, int code_size, CodeWriter writer)
	{
		MetadataBuilder metadata = writer.metadata;
		buffer.WriteBytes(ReadBytes(code_size));
		int num = buffer.position;
		buffer.position -= code_size;
		while (buffer.position < num)
		{
			byte b = buffer.ReadByte();
			OpCode opCode;
			if (b != 254)
			{
				opCode = OpCodes.OneByteOpCode[b];
			}
			else
			{
				byte b2 = buffer.ReadByte();
				opCode = OpCodes.TwoBytesOpCode[b2];
			}
			switch (opCode.OperandType)
			{
			case OperandType.ShortInlineBrTarget:
			case OperandType.ShortInlineI:
			case OperandType.ShortInlineVar:
			case OperandType.ShortInlineArg:
				buffer.position++;
				break;
			case OperandType.InlineVar:
			case OperandType.InlineArg:
				buffer.position += 2;
				break;
			case OperandType.InlineBrTarget:
			case OperandType.InlineI:
			case OperandType.ShortInlineR:
				buffer.position += 4;
				break;
			case OperandType.InlineI8:
			case OperandType.InlineR:
				buffer.position += 8;
				break;
			case OperandType.InlineSwitch:
			{
				int num2 = buffer.ReadInt32();
				buffer.position += num2 * 4;
				break;
			}
			case OperandType.InlineString:
			{
				string @string = GetString(new MetadataToken(buffer.ReadUInt32()));
				buffer.position -= 4;
				buffer.WriteUInt32(new MetadataToken(TokenType.String, metadata.user_string_heap.GetStringIndex(@string)).ToUInt32());
				break;
			}
			case OperandType.InlineSig:
			{
				CallSite callSite = GetCallSite(new MetadataToken(buffer.ReadUInt32()));
				buffer.position -= 4;
				buffer.WriteUInt32(writer.GetStandAloneSignature(callSite).ToUInt32());
				break;
			}
			case OperandType.InlineField:
			case OperandType.InlineMethod:
			case OperandType.InlineTok:
			case OperandType.InlineType:
			{
				IMetadataTokenProvider provider = reader.LookupToken(new MetadataToken(buffer.ReadUInt32()));
				buffer.position -= 4;
				buffer.WriteUInt32(metadata.LookupToken(provider).ToUInt32());
				break;
			}
			}
		}
	}

	private void PatchRawSection(ByteBuffer buffer, MetadataBuilder metadata)
	{
		int num = position;
		Align(4);
		buffer.WriteBytes(position - num);
		byte b = ReadByte();
		if ((b & 0x40) == 0)
		{
			buffer.WriteByte(b);
			PatchRawSmallSection(buffer, metadata);
		}
		else
		{
			PatchRawFatSection(buffer, metadata);
		}
		if ((b & 0x80) != 0)
		{
			PatchRawSection(buffer, metadata);
		}
	}

	private void PatchRawSmallSection(ByteBuffer buffer, MetadataBuilder metadata)
	{
		byte b = ReadByte();
		buffer.WriteByte(b);
		Advance(2);
		buffer.WriteUInt16(0);
		int count = b / 12;
		PatchRawExceptionHandlers(buffer, metadata, count, fat_entry: false);
	}

	private void PatchRawFatSection(ByteBuffer buffer, MetadataBuilder metadata)
	{
		position--;
		int num = ReadInt32();
		buffer.WriteInt32(num);
		int count = (num >> 8) / 24;
		PatchRawExceptionHandlers(buffer, metadata, count, fat_entry: true);
	}

	private void PatchRawExceptionHandlers(ByteBuffer buffer, MetadataBuilder metadata, int count, bool fat_entry)
	{
		for (int i = 0; i < count; i++)
		{
			ExceptionHandlerType exceptionHandlerType;
			if (fat_entry)
			{
				uint num = ReadUInt32();
				exceptionHandlerType = (ExceptionHandlerType)(num & 7);
				buffer.WriteUInt32(num);
			}
			else
			{
				ushort num2 = ReadUInt16();
				exceptionHandlerType = (ExceptionHandlerType)(num2 & 7);
				buffer.WriteUInt16(num2);
			}
			buffer.WriteBytes(ReadBytes(fat_entry ? 16 : 6));
			if (exceptionHandlerType == ExceptionHandlerType.Catch)
			{
				IMetadataTokenProvider provider = reader.LookupToken(ReadToken());
				buffer.WriteUInt32(metadata.LookupToken(provider).ToUInt32());
			}
			else
			{
				buffer.WriteUInt32(ReadUInt32());
			}
		}
	}
}


public enum DocumentType
{
	Other,
	Text
}


public enum DocumentHashAlgorithm
{
	None,
	MD5,
	SHA1
}


public enum DocumentLanguage
{
	Other,
	C,
	Cpp,
	CSharp,
	Basic,
	Java,
	Cobol,
	Pascal,
	Cil,
	JScript,
	Smc,
	MCpp,
	FSharp
}


public enum DocumentLanguageVendor
{
	Other,
	Microsoft
}


using Mono;
using Mono.Cecil.Cil;

public sealed class Document
{
	private string url;

	private byte type;

	private byte hash_algorithm;

	private byte language;

	private byte language_vendor;

	private byte[] hash;

	public string Url
	{
		get
		{
			return url;
		}
		set
		{
			url = value;
		}
	}

	public DocumentType Type
	{
		get
		{
			return (DocumentType)type;
		}
		set
		{
			type = (byte)value;
		}
	}

	public DocumentHashAlgorithm HashAlgorithm
	{
		get
		{
			return (DocumentHashAlgorithm)hash_algorithm;
		}
		set
		{
			hash_algorithm = (byte)value;
		}
	}

	public DocumentLanguage Language
	{
		get
		{
			return (DocumentLanguage)language;
		}
		set
		{
			language = (byte)value;
		}
	}

	public DocumentLanguageVendor LanguageVendor
	{
		get
		{
			return (DocumentLanguageVendor)language_vendor;
		}
		set
		{
			language_vendor = (byte)value;
		}
	}

	public byte[] Hash
	{
		get
		{
			return hash;
		}
		set
		{
			hash = value;
		}
	}

	public Document(string url)
	{
		this.url = url;
		hash = Empty<byte>.Array;
	}
}


public enum ExceptionHandlerType
{
	Catch = 0,
	Filter = 1,
	Finally = 2,
	Fault = 4
}


using Mono.Cecil;
using Mono.Cecil.Cil;

public sealed class ExceptionHandler
{
	private Instruction try_start;

	private Instruction try_end;

	private Instruction filter_start;

	private Instruction handler_start;

	private Instruction handler_end;

	private TypeReference catch_type;

	private ExceptionHandlerType handler_type;

	public Instruction TryStart
	{
		get
		{
			return try_start;
		}
		set
		{
			try_start = value;
		}
	}

	public Instruction TryEnd
	{
		get
		{
			return try_end;
		}
		set
		{
			try_end = value;
		}
	}

	public Instruction FilterStart
	{
		get
		{
			return filter_start;
		}
		set
		{
			filter_start = value;
		}
	}

	public Instruction HandlerStart
	{
		get
		{
			return handler_start;
		}
		set
		{
			handler_start = value;
		}
	}

	public Instruction HandlerEnd
	{
		get
		{
			return handler_end;
		}
		set
		{
			handler_end = value;
		}
	}

	public TypeReference CatchType
	{
		get
		{
			return catch_type;
		}
		set
		{
			catch_type = value;
		}
	}

	public ExceptionHandlerType HandlerType
	{
		get
		{
			return handler_type;
		}
		set
		{
			handler_type = value;
		}
	}

	public ExceptionHandler(ExceptionHandlerType handlerType)
	{
		handler_type = handlerType;
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Collections.Generic;

public sealed class ILProcessor
{
	private readonly MethodBody body;

	private readonly Collection<Instruction> instructions;

	public MethodBody Body => body;

	internal ILProcessor(MethodBody body)
	{
		this.body = body;
		instructions = body.Instructions;
	}

	public Instruction Create(OpCode opcode)
	{
		return Instruction.Create(opcode);
	}

	public Instruction Create(OpCode opcode, TypeReference type)
	{
		return Instruction.Create(opcode, type);
	}

	public Instruction Create(OpCode opcode, CallSite site)
	{
		return Instruction.Create(opcode, site);
	}

	public Instruction Create(OpCode opcode, MethodReference method)
	{
		return Instruction.Create(opcode, method);
	}

	public Instruction Create(OpCode opcode, FieldReference field)
	{
		return Instruction.Create(opcode, field);
	}

	public Instruction Create(OpCode opcode, string value)
	{
		return Instruction.Create(opcode, value);
	}

	public Instruction Create(OpCode opcode, sbyte value)
	{
		return Instruction.Create(opcode, value);
	}

	public Instruction Create(OpCode opcode, byte value)
	{
		if (opcode.OperandType == OperandType.ShortInlineVar)
		{
			return Instruction.Create(opcode, body.Variables[value]);
		}
		if (opcode.OperandType == OperandType.ShortInlineArg)
		{
			return Instruction.Create(opcode, body.GetParameter(value));
		}
		return Instruction.Create(opcode, value);
	}

	public Instruction Create(OpCode opcode, int value)
	{
		if (opcode.OperandType == OperandType.InlineVar)
		{
			return Instruction.Create(opcode, body.Variables[value]);
		}
		if (opcode.OperandType == OperandType.InlineArg)
		{
			return Instruction.Create(opcode, body.GetParameter(value));
		}
		return Instruction.Create(opcode, value);
	}

	public Instruction Create(OpCode opcode, long value)
	{
		return Instruction.Create(opcode, value);
	}

	public Instruction Create(OpCode opcode, float value)
	{
		return Instruction.Create(opcode, value);
	}

	public Instruction Create(OpCode opcode, double value)
	{
		return Instruction.Create(opcode, value);
	}

	public Instruction Create(OpCode opcode, Instruction target)
	{
		return Instruction.Create(opcode, target);
	}

	public Instruction Create(OpCode opcode, Instruction[] targets)
	{
		return Instruction.Create(opcode, targets);
	}

	public Instruction Create(OpCode opcode, VariableDefinition variable)
	{
		return Instruction.Create(opcode, variable);
	}

	public Instruction Create(OpCode opcode, ParameterDefinition parameter)
	{
		return Instruction.Create(opcode, parameter);
	}

	public void Emit(OpCode opcode)
	{
		Append(Create(opcode));
	}

	public void Emit(OpCode opcode, TypeReference type)
	{
		Append(Create(opcode, type));
	}

	public void Emit(OpCode opcode, MethodReference method)
	{
		Append(Create(opcode, method));
	}

	public void Emit(OpCode opcode, CallSite site)
	{
		Append(Create(opcode, site));
	}

	public void Emit(OpCode opcode, FieldReference field)
	{
		Append(Create(opcode, field));
	}

	public void Emit(OpCode opcode, string value)
	{
		Append(Create(opcode, value));
	}

	public void Emit(OpCode opcode, byte value)
	{
		Append(Create(opcode, value));
	}

	public void Emit(OpCode opcode, sbyte value)
	{
		Append(Create(opcode, value));
	}

	public void Emit(OpCode opcode, int value)
	{
		Append(Create(opcode, value));
	}

	public void Emit(OpCode opcode, long value)
	{
		Append(Create(opcode, value));
	}

	public void Emit(OpCode opcode, float value)
	{
		Append(Create(opcode, value));
	}

	public void Emit(OpCode opcode, double value)
	{
		Append(Create(opcode, value));
	}

	public void Emit(OpCode opcode, Instruction target)
	{
		Append(Create(opcode, target));
	}

	public void Emit(OpCode opcode, Instruction[] targets)
	{
		Append(Create(opcode, targets));
	}

	public void Emit(OpCode opcode, VariableDefinition variable)
	{
		Append(Create(opcode, variable));
	}

	public void Emit(OpCode opcode, ParameterDefinition parameter)
	{
		Append(Create(opcode, parameter));
	}

	public void InsertBefore(Instruction target, Instruction instruction)
	{
		if (target == null)
		{
			throw new ArgumentNullException("target");
		}
		if (instruction == null)
		{
			throw new ArgumentNullException("instruction");
		}
		int num = instructions.IndexOf(target);
		if (num == -1)
		{
			throw new ArgumentOutOfRangeException("target");
		}
		instructions.Insert(num, instruction);
	}

	public void InsertAfter(Instruction target, Instruction instruction)
	{
		if (target == null)
		{
			throw new ArgumentNullException("target");
		}
		if (instruction == null)
		{
			throw new ArgumentNullException("instruction");
		}
		int num = instructions.IndexOf(target);
		if (num == -1)
		{
			throw new ArgumentOutOfRangeException("target");
		}
		instructions.Insert(num + 1, instruction);
	}

	public void Append(Instruction instruction)
	{
		if (instruction == null)
		{
			throw new ArgumentNullException("instruction");
		}
		instructions.Add(instruction);
	}

	public void Replace(Instruction target, Instruction instruction)
	{
		if (target == null)
		{
			throw new ArgumentNullException("target");
		}
		if (instruction == null)
		{
			throw new ArgumentNullException("instruction");
		}
		InsertAfter(target, instruction);
		Remove(target);
	}

	public void Remove(Instruction instruction)
	{
		if (instruction == null)
		{
			throw new ArgumentNullException("instruction");
		}
		if (!instructions.Remove(instruction))
		{
			throw new ArgumentOutOfRangeException("instruction");
		}
	}
}


using System;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Cil;

public sealed class Instruction
{
	internal int offset;

	internal OpCode opcode;

	internal object operand;

	internal Instruction previous;

	internal Instruction next;

	private SequencePoint sequence_point;

	public int Offset
	{
		get
		{
			return offset;
		}
		set
		{
			offset = value;
		}
	}

	public OpCode OpCode
	{
		get
		{
			return opcode;
		}
		set
		{
			opcode = value;
		}
	}

	public object Operand
	{
		get
		{
			return operand;
		}
		set
		{
			operand = value;
		}
	}

	public Instruction Previous
	{
		get
		{
			return previous;
		}
		set
		{
			previous = value;
		}
	}

	public Instruction Next
	{
		get
		{
			return next;
		}
		set
		{
			next = value;
		}
	}

	public SequencePoint SequencePoint
	{
		get
		{
			return sequence_point;
		}
		set
		{
			sequence_point = value;
		}
	}

	internal Instruction(int offset, OpCode opCode)
	{
		this.offset = offset;
		opcode = opCode;
	}

	internal Instruction(OpCode opcode, object operand)
	{
		this.opcode = opcode;
		this.operand = operand;
	}

	public int GetSize()
	{
		int size = opcode.Size;
		switch (opcode.OperandType)
		{
		case OperandType.InlineSwitch:
			return size + (1 + ((Instruction[])operand).Length) * 4;
		case OperandType.InlineI8:
		case OperandType.InlineR:
			return size + 8;
		case OperandType.InlineBrTarget:
		case OperandType.InlineField:
		case OperandType.InlineI:
		case OperandType.InlineMethod:
		case OperandType.InlineSig:
		case OperandType.InlineString:
		case OperandType.InlineTok:
		case OperandType.InlineType:
		case OperandType.ShortInlineR:
			return size + 4;
		case OperandType.InlineVar:
		case OperandType.InlineArg:
			return size + 2;
		case OperandType.ShortInlineBrTarget:
		case OperandType.ShortInlineI:
		case OperandType.ShortInlineVar:
		case OperandType.ShortInlineArg:
			return size + 1;
		default:
			return size;
		}
	}

	public override string ToString()
	{
		StringBuilder stringBuilder = new StringBuilder();
		AppendLabel(stringBuilder, this);
		stringBuilder.Append(':');
		stringBuilder.Append(' ');
		stringBuilder.Append(opcode.Name);
		if (operand == null)
		{
			return stringBuilder.ToString();
		}
		stringBuilder.Append(' ');
		switch (opcode.OperandType)
		{
		case OperandType.InlineBrTarget:
		case OperandType.ShortInlineBrTarget:
			AppendLabel(stringBuilder, (Instruction)operand);
			break;
		case OperandType.InlineSwitch:
		{
			Instruction[] array = (Instruction[])operand;
			for (int i = 0; i < array.Length; i++)
			{
				if (i > 0)
				{
					stringBuilder.Append(',');
				}
				AppendLabel(stringBuilder, array[i]);
			}
			break;
		}
		case OperandType.InlineString:
			stringBuilder.Append('"');
			stringBuilder.Append(operand);
			stringBuilder.Append('"');
			break;
		default:
			stringBuilder.Append(operand);
			break;
		}
		return stringBuilder.ToString();
	}

	private static void AppendLabel(StringBuilder builder, Instruction instruction)
	{
		builder.Append("IL_");
		builder.Append(instruction.offset.ToString("x4"));
	}

	public static Instruction Create(OpCode opcode)
	{
		if (opcode.OperandType != OperandType.InlineNone)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, null);
	}

	public static Instruction Create(OpCode opcode, TypeReference type)
	{
		if (type == null)
		{
			throw new ArgumentNullException("type");
		}
		if (opcode.OperandType != OperandType.InlineType && opcode.OperandType != OperandType.InlineTok)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, type);
	}

	public static Instruction Create(OpCode opcode, CallSite site)
	{
		if (site == null)
		{
			throw new ArgumentNullException("site");
		}
		if (opcode.Code != Code.Calli)
		{
			throw new ArgumentException("code");
		}
		return new Instruction(opcode, site);
	}

	public static Instruction Create(OpCode opcode, MethodReference method)
	{
		if (method == null)
		{
			throw new ArgumentNullException("method");
		}
		if (opcode.OperandType != OperandType.InlineMethod && opcode.OperandType != OperandType.InlineTok)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, method);
	}

	public static Instruction Create(OpCode opcode, FieldReference field)
	{
		if (field == null)
		{
			throw new ArgumentNullException("field");
		}
		if (opcode.OperandType != OperandType.InlineField && opcode.OperandType != OperandType.InlineTok)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, field);
	}

	public static Instruction Create(OpCode opcode, string value)
	{
		if (value == null)
		{
			throw new ArgumentNullException("value");
		}
		if (opcode.OperandType != OperandType.InlineString)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, value);
	}

	public static Instruction Create(OpCode opcode, sbyte value)
	{
		if (opcode.OperandType != OperandType.ShortInlineI && opcode != OpCodes.Ldc_I4_S)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, value);
	}

	public static Instruction Create(OpCode opcode, byte value)
	{
		if (opcode.OperandType != OperandType.ShortInlineI || opcode == OpCodes.Ldc_I4_S)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, value);
	}

	public static Instruction Create(OpCode opcode, int value)
	{
		if (opcode.OperandType != OperandType.InlineI)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, value);
	}

	public static Instruction Create(OpCode opcode, long value)
	{
		if (opcode.OperandType != OperandType.InlineI8)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, value);
	}

	public static Instruction Create(OpCode opcode, float value)
	{
		if (opcode.OperandType != OperandType.ShortInlineR)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, value);
	}

	public static Instruction Create(OpCode opcode, double value)
	{
		if (opcode.OperandType != OperandType.InlineR)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, value);
	}

	public static Instruction Create(OpCode opcode, Instruction target)
	{
		if (target == null)
		{
			throw new ArgumentNullException("target");
		}
		if (opcode.OperandType != 0 && opcode.OperandType != OperandType.ShortInlineBrTarget)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, target);
	}

	public static Instruction Create(OpCode opcode, Instruction[] targets)
	{
		if (targets == null)
		{
			throw new ArgumentNullException("targets");
		}
		if (opcode.OperandType != OperandType.InlineSwitch)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, targets);
	}

	public static Instruction Create(OpCode opcode, VariableDefinition variable)
	{
		if (variable == null)
		{
			throw new ArgumentNullException("variable");
		}
		if (opcode.OperandType != OperandType.ShortInlineVar && opcode.OperandType != OperandType.InlineVar)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, variable);
	}

	public static Instruction Create(OpCode opcode, ParameterDefinition parameter)
	{
		if (parameter == null)
		{
			throw new ArgumentNullException("parameter");
		}
		if (opcode.OperandType != OperandType.ShortInlineArg && opcode.OperandType != OperandType.InlineArg)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, parameter);
	}
}


using System;
using System.Threading;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Collections.Generic;

public sealed class MethodBody : IVariableDefinitionProvider
{
	internal readonly MethodDefinition method;

	internal ParameterDefinition this_parameter;

	internal int max_stack_size;

	internal int code_size;

	internal bool init_locals;

	internal MetadataToken local_var_token;

	internal Collection<Instruction> instructions;

	internal Collection<ExceptionHandler> exceptions;

	internal Collection<VariableDefinition> variables;

	private Scope scope;

	public MethodDefinition Method => method;

	public int MaxStackSize
	{
		get
		{
			return max_stack_size;
		}
		set
		{
			max_stack_size = value;
		}
	}

	public int CodeSize => code_size;

	public bool InitLocals
	{
		get
		{
			return init_locals;
		}
		set
		{
			init_locals = value;
		}
	}

	public MetadataToken LocalVarToken
	{
		get
		{
			return local_var_token;
		}
		set
		{
			local_var_token = value;
		}
	}

	public Collection<Instruction> Instructions => instructions ?? (instructions = new InstructionCollection());

	public bool HasExceptionHandlers => !exceptions.IsNullOrEmpty();

	public Collection<ExceptionHandler> ExceptionHandlers => exceptions ?? (exceptions = new Collection<ExceptionHandler>());

	public bool HasVariables => !variables.IsNullOrEmpty();

	public Collection<VariableDefinition> Variables => variables ?? (variables = new VariableDefinitionCollection());

	public Scope Scope
	{
		get
		{
			return scope;
		}
		set
		{
			scope = value;
		}
	}

	public ParameterDefinition ThisParameter
	{
		get
		{
			if (method == null || method.DeclaringType == null)
			{
				throw new NotSupportedException();
			}
			if (!method.HasThis)
			{
				return null;
			}
			if (this_parameter == null)
			{
				Interlocked.CompareExchange(ref this_parameter, CreateThisParameter(method), null);
			}
			return this_parameter;
		}
	}

	private static ParameterDefinition CreateThisParameter(MethodDefinition method)
	{
		TypeDefinition declaringType = method.DeclaringType;
		return new ParameterDefinition((declaringType.IsValueType || declaringType.IsPrimitive) ? ((TypeReference)new PointerType(declaringType)) : ((TypeReference)declaringType), method);
	}

	public MethodBody(MethodDefinition method)
	{
		this.method = method;
	}

	public ILProcessor GetILProcessor()
	{
		return new ILProcessor(this);
	}
}


using Mono.Cecil.Cil;
using Mono.Collections.Generic;

public interface IVariableDefinitionProvider
{
	bool HasVariables { get; }

	Collection<VariableDefinition> Variables { get; }
}


using Mono.Cecil.Cil;
using Mono.Collections.Generic;

internal class VariableDefinitionCollection : Collection<VariableDefinition>
{
	internal VariableDefinitionCollection()
	{
	}

	internal VariableDefinitionCollection(int capacity)
		: base(capacity)
	{
	}

	protected override void OnAdd(VariableDefinition item, int index)
	{
		item.index = index;
	}

	protected override void OnInsert(VariableDefinition item, int index)
	{
		item.index = index;
		for (int i = index; i < size; i++)
		{
			items[i].index = i + 1;
		}
	}

	protected override void OnSet(VariableDefinition item, int index)
	{
		item.index = index;
	}

	protected override void OnRemove(VariableDefinition item, int index)
	{
		item.index = -1;
		for (int i = index + 1; i < size; i++)
		{
			items[i].index = i - 1;
		}
	}
}


using Mono.Cecil.Cil;
using Mono.Collections.Generic;

internal class InstructionCollection : Collection<Instruction>
{
	internal InstructionCollection()
	{
	}

	internal InstructionCollection(int capacity)
		: base(capacity)
	{
	}

	protected override void OnAdd(Instruction item, int index)
	{
		if (index != 0)
		{
			Instruction instruction = items[index - 1];
			instruction.next = item;
			item.previous = instruction;
		}
	}

	protected override void OnInsert(Instruction item, int index)
	{
		if (size == 0)
		{
			return;
		}
		Instruction instruction = items[index];
		if (instruction == null)
		{
			Instruction instruction2 = items[index - 1];
			instruction2.next = item;
			item.previous = instruction2;
			return;
		}
		Instruction previous = instruction.previous;
		if (previous != null)
		{
			previous.next = item;
			item.previous = previous;
		}
		instruction.previous = item;
		item.next = instruction;
	}

	protected override void OnSet(Instruction item, int index)
	{
		Instruction instruction = items[index];
		item.previous = instruction.previous;
		item.next = instruction.next;
		instruction.previous = null;
		instruction.next = null;
	}

	protected override void OnRemove(Instruction item, int index)
	{
		Instruction previous = item.previous;
		if (previous != null)
		{
			previous.next = item.next;
		}
		Instruction next = item.next;
		if (next != null)
		{
			next.previous = item.previous;
		}
		item.previous = null;
		item.next = null;
	}
}


public enum FlowControl
{
	Branch,
	Break,
	Call,
	Cond_Branch,
	Meta,
	Next,
	Phi,
	Return,
	Throw
}


public enum OpCodeType
{
	Annotation,
	Macro,
	Nternal,
	Objmodel,
	Prefix,
	Primitive
}


public enum OperandType
{
	InlineBrTarget,
	InlineField,
	InlineI,
	InlineI8,
	InlineMethod,
	InlineNone,
	InlinePhi,
	InlineR,
	InlineSig,
	InlineString,
	InlineSwitch,
	InlineTok,
	InlineType,
	InlineVar,
	InlineArg,
	ShortInlineBrTarget,
	ShortInlineI,
	ShortInlineR,
	ShortInlineVar,
	ShortInlineArg
}


public enum StackBehaviour
{
	Pop0,
	Pop1,
	Pop1_pop1,
	Popi,
	Popi_pop1,
	Popi_popi,
	Popi_popi8,
	Popi_popi_popi,
	Popi_popr4,
	Popi_popr8,
	Popref,
	Popref_pop1,
	Popref_popi,
	Popref_popi_popi,
	Popref_popi_popi8,
	Popref_popi_popr4,
	Popref_popi_popr8,
	Popref_popi_popref,
	PopAll,
	Push0,
	Push1,
	Push1_push1,
	Pushi,
	Pushi8,
	Pushr4,
	Pushr8,
	Pushref,
	Varpop,
	Varpush
}


using Mono.Cecil.Cil;

public struct OpCode
{
	private readonly byte op1;

	private readonly byte op2;

	private readonly byte code;

	private readonly byte flow_control;

	private readonly byte opcode_type;

	private readonly byte operand_type;

	private readonly byte stack_behavior_pop;

	private readonly byte stack_behavior_push;

	public string Name => OpCodeNames.names[(int)Code];

	public int Size
	{
		get
		{
			if (op1 != byte.MaxValue)
			{
				return 2;
			}
			return 1;
		}
	}

	public byte Op1 => op1;

	public byte Op2 => op2;

	public short Value
	{
		get
		{
			if (op1 != byte.MaxValue)
			{
				return (short)((op1 << 8) | op2);
			}
			return op2;
		}
	}

	public Code Code => (Code)code;

	public FlowControl FlowControl => (FlowControl)flow_control;

	public OpCodeType OpCodeType => (OpCodeType)opcode_type;

	public OperandType OperandType => (OperandType)operand_type;

	public StackBehaviour StackBehaviourPop => (StackBehaviour)stack_behavior_pop;

	public StackBehaviour StackBehaviourPush => (StackBehaviour)stack_behavior_push;

	internal OpCode(int x, int y)
	{
		op1 = (byte)(x & 0xFF);
		op2 = (byte)((x >> 8) & 0xFF);
		code = (byte)((x >> 16) & 0xFF);
		flow_control = (byte)((x >> 24) & 0xFF);
		opcode_type = (byte)(y & 0xFF);
		operand_type = (byte)((y >> 8) & 0xFF);
		stack_behavior_pop = (byte)((y >> 16) & 0xFF);
		stack_behavior_push = (byte)((y >> 24) & 0xFF);
		if (op1 == byte.MaxValue)
		{
			OpCodes.OneByteOpCode[op2] = this;
		}
		else
		{
			OpCodes.TwoBytesOpCode[op2] = this;
		}
	}

	public override int GetHashCode()
	{
		return Value;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is OpCode opCode))
		{
			return false;
		}
		if (op1 == opCode.op1)
		{
			return op2 == opCode.op2;
		}
		return false;
	}

	public bool Equals(OpCode opcode)
	{
		if (op1 == opcode.op1)
		{
			return op2 == opcode.op2;
		}
		return false;
	}

	public static bool operator ==(OpCode one, OpCode other)
	{
		if (one.op1 == other.op1)
		{
			return one.op2 == other.op2;
		}
		return false;
	}

	public static bool operator !=(OpCode one, OpCode other)
	{
		if (one.op1 == other.op1)
		{
			return one.op2 != other.op2;
		}
		return true;
	}

	public override string ToString()
	{
		return Name;
	}
}


internal static class OpCodeNames
{
	internal static readonly string[] names;

	static OpCodeNames()
	{
		byte[] array = new byte[1790]
		{
			3, 110, 111, 112, 5, 98, 114, 101, 97, 107,
			7, 108, 100, 97, 114, 103, 46, 48, 7, 108,
			100, 97, 114, 103, 46, 49, 7, 108, 100, 97,
			114, 103, 46, 50, 7, 108, 100, 97, 114, 103,
			46, 51, 7, 108, 100, 108, 111, 99, 46, 48,
			7, 108, 100, 108, 111, 99, 46, 49, 7, 108,
			100, 108, 111, 99, 46, 50, 7, 108, 100, 108,
			111, 99, 46, 51, 7, 115, 116, 108, 111, 99,
			46, 48, 7, 115, 116, 108, 111, 99, 46, 49,
			7, 115, 116, 108, 111, 99, 46, 50, 7, 115,
			116, 108, 111, 99, 46, 51, 7, 108, 100, 97,
			114, 103, 46, 115, 8, 108, 100, 97, 114, 103,
			97, 46, 115, 7, 115, 116, 97, 114, 103, 46,
			115, 7, 108, 100, 108, 111, 99, 46, 115, 8,
			108, 100, 108, 111, 99, 97, 46, 115, 7, 115,
			116, 108, 111, 99, 46, 115, 6, 108, 100, 110,
			117, 108, 108, 9, 108, 100, 99, 46, 105, 52,
			46, 109, 49, 8, 108, 100, 99, 46, 105, 52,
			46, 48, 8, 108, 100, 99, 46, 105, 52, 46,
			49, 8, 108, 100, 99, 46, 105, 52, 46, 50,
			8, 108, 100, 99, 46, 105, 52, 46, 51, 8,
			108, 100, 99, 46, 105, 52, 46, 52, 8, 108,
			100, 99, 46, 105, 52, 46, 53, 8, 108, 100,
			99, 46, 105, 52, 46, 54, 8, 108, 100, 99,
			46, 105, 52, 46, 55, 8, 108, 100, 99, 46,
			105, 52, 46, 56, 8, 108, 100, 99, 46, 105,
			52, 46, 115, 6, 108, 100, 99, 46, 105, 52,
			6, 108, 100, 99, 46, 105, 56, 6, 108, 100,
			99, 46, 114, 52, 6, 108, 100, 99, 46, 114,
			56, 3, 100, 117, 112, 3, 112, 111, 112, 3,
			106, 109, 112, 4, 99, 97, 108, 108, 5, 99,
			97, 108, 108, 105, 3, 114, 101, 116, 4, 98,
			114, 46, 115, 9, 98, 114, 102, 97, 108, 115,
			101, 46, 115, 8, 98, 114, 116, 114, 117, 101,
			46, 115, 5, 98, 101, 113, 46, 115, 5, 98,
			103, 101, 46, 115, 5, 98, 103, 116, 46, 115,
			5, 98, 108, 101, 46, 115, 5, 98, 108, 116,
			46, 115, 8, 98, 110, 101, 46, 117, 110, 46,
			115, 8, 98, 103, 101, 46, 117, 110, 46, 115,
			8, 98, 103, 116, 46, 117, 110, 46, 115, 8,
			98, 108, 101, 46, 117, 110, 46, 115, 8, 98,
			108, 116, 46, 117, 110, 46, 115, 2, 98, 114,
			7, 98, 114, 102, 97, 108, 115, 101, 6, 98,
			114, 116, 114, 117, 101, 3, 98, 101, 113, 3,
			98, 103, 101, 3, 98, 103, 116, 3, 98, 108,
			101, 3, 98, 108, 116, 6, 98, 110, 101, 46,
			117, 110, 6, 98, 103, 101, 46, 117, 110, 6,
			98, 103, 116, 46, 117, 110, 6, 98, 108, 101,
			46, 117, 110, 6, 98, 108, 116, 46, 117, 110,
			6, 115, 119, 105, 116, 99, 104, 8, 108, 100,
			105, 110, 100, 46, 105, 49, 8, 108, 100, 105,
			110, 100, 46, 117, 49, 8, 108, 100, 105, 110,
			100, 46, 105, 50, 8, 108, 100, 105, 110, 100,
			46, 117, 50, 8, 108, 100, 105, 110, 100, 46,
			105, 52, 8, 108, 100, 105, 110, 100, 46, 117,
			52, 8, 108, 100, 105, 110, 100, 46, 105, 56,
			7, 108, 100, 105, 110, 100, 46, 105, 8, 108,
			100, 105, 110, 100, 46, 114, 52, 8, 108, 100,
			105, 110, 100, 46, 114, 56, 9, 108, 100, 105,
			110, 100, 46, 114, 101, 102, 9, 115, 116, 105,
			110, 100, 46, 114, 101, 102, 8, 115, 116, 105,
			110, 100, 46, 105, 49, 8, 115, 116, 105, 110,
			100, 46, 105, 50, 8, 115, 116, 105, 110, 100,
			46, 105, 52, 8, 115, 116, 105, 110, 100, 46,
			105, 56, 8, 115, 116, 105, 110, 100, 46, 114,
			52, 8, 115, 116, 105, 110, 100, 46, 114, 56,
			3, 97, 100, 100, 3, 115, 117, 98, 3, 109,
			117, 108, 3, 100, 105, 118, 6, 100, 105, 118,
			46, 117, 110, 3, 114, 101, 109, 6, 114, 101,
			109, 46, 117, 110, 3, 97, 110, 100, 2, 111,
			114, 3, 120, 111, 114, 3, 115, 104, 108, 3,
			115, 104, 114, 6, 115, 104, 114, 46, 117, 110,
			3, 110, 101, 103, 3, 110, 111, 116, 7, 99,
			111, 110, 118, 46, 105, 49, 7, 99, 111, 110,
			118, 46, 105, 50, 7, 99, 111, 110, 118, 46,
			105, 52, 7, 99, 111, 110, 118, 46, 105, 56,
			7, 99, 111, 110, 118, 46, 114, 52, 7, 99,
			111, 110, 118, 46, 114, 56, 7, 99, 111, 110,
			118, 46, 117, 52, 7, 99, 111, 110, 118, 46,
			117, 56, 8, 99, 97, 108, 108, 118, 105, 114,
			116, 5, 99, 112, 111, 98, 106, 5, 108, 100,
			111, 98, 106, 5, 108, 100, 115, 116, 114, 6,
			110, 101, 119, 111, 98, 106, 9, 99, 97, 115,
			116, 99, 108, 97, 115, 115, 6, 105, 115, 105,
			110, 115, 116, 9, 99, 111, 110, 118, 46, 114,
			46, 117, 110, 5, 117, 110, 98, 111, 120, 5,
			116, 104, 114, 111, 119, 5, 108, 100, 102, 108,
			100, 6, 108, 100, 102, 108, 100, 97, 5, 115,
			116, 102, 108, 100, 6, 108, 100, 115, 102, 108,
			100, 7, 108, 100, 115, 102, 108, 100, 97, 6,
			115, 116, 115, 102, 108, 100, 5, 115, 116, 111,
			98, 106, 14, 99, 111, 110, 118, 46, 111, 118,
			102, 46, 105, 49, 46, 117, 110, 14, 99, 111,
			110, 118, 46, 111, 118, 102, 46, 105, 50, 46,
			117, 110, 14, 99, 111, 110, 118, 46, 111, 118,
			102, 46, 105, 52, 46, 117, 110, 14, 99, 111,
			110, 118, 46, 111, 118, 102, 46, 105, 56, 46,
			117, 110, 14, 99, 111, 110, 118, 46, 111, 118,
			102, 46, 117, 49, 46, 117, 110, 14, 99, 111,
			110, 118, 46, 111, 118, 102, 46, 117, 50, 46,
			117, 110, 14, 99, 111, 110, 118, 46, 111, 118,
			102, 46, 117, 52, 46, 117, 110, 14, 99, 111,
			110, 118, 46, 111, 118, 102, 46, 117, 56, 46,
			117, 110, 13, 99, 111, 110, 118, 46, 111, 118,
			102, 46, 105, 46, 117, 110, 13, 99, 111, 110,
			118, 46, 111, 118, 102, 46, 117, 46, 117, 110,
			3, 98, 111, 120, 6, 110, 101, 119, 97, 114,
			114, 5, 108, 100, 108, 101, 110, 7, 108, 100,
			101, 108, 101, 109, 97, 9, 108, 100, 101, 108,
			101, 109, 46, 105, 49, 9, 108, 100, 101, 108,
			101, 109, 46, 117, 49, 9, 108, 100, 101, 108,
			101, 109, 46, 105, 50, 9, 108, 100, 101, 108,
			101, 109, 46, 117, 50, 9, 108, 100, 101, 108,
			101, 109, 46, 105, 52, 9, 108, 100, 101, 108,
			101, 109, 46, 117, 52, 9, 108, 100, 101, 108,
			101, 109, 46, 105, 56, 8, 108, 100, 101, 108,
			101, 109, 46, 105, 9, 108, 100, 101, 108, 101,
			109, 46, 114, 52, 9, 108, 100, 101, 108, 101,
			109, 46, 114, 56, 10, 108, 100, 101, 108, 101,
			109, 46, 114, 101, 102, 8, 115, 116, 101, 108,
			101, 109, 46, 105, 9, 115, 116, 101, 108, 101,
			109, 46, 105, 49, 9, 115, 116, 101, 108, 101,
			109, 46, 105, 50, 9, 115, 116, 101, 108, 101,
			109, 46, 105, 52, 9, 115, 116, 101, 108, 101,
			109, 46, 105, 56, 9, 115, 116, 101, 108, 101,
			109, 46, 114, 52, 9, 115, 116, 101, 108, 101,
			109, 46, 114, 56, 10, 115, 116, 101, 108, 101,
			109, 46, 114, 101, 102, 10, 108, 100, 101, 108,
			101, 109, 46, 97, 110, 121, 10, 115, 116, 101,
			108, 101, 109, 46, 97, 110, 121, 9, 117, 110,
			98, 111, 120, 46, 97, 110, 121, 11, 99, 111,
			110, 118, 46, 111, 118, 102, 46, 105, 49, 11,
			99, 111, 110, 118, 46, 111, 118, 102, 46, 117,
			49, 11, 99, 111, 110, 118, 46, 111, 118, 102,
			46, 105, 50, 11, 99, 111, 110, 118, 46, 111,
			118, 102, 46, 117, 50, 11, 99, 111, 110, 118,
			46, 111, 118, 102, 46, 105, 52, 11, 99, 111,
			110, 118, 46, 111, 118, 102, 46, 117, 52, 11,
			99, 111, 110, 118, 46, 111, 118, 102, 46, 105,
			56, 11, 99, 111, 110, 118, 46, 111, 118, 102,
			46, 117, 56, 9, 114, 101, 102, 97, 110, 121,
			118, 97, 108, 8, 99, 107, 102, 105, 110, 105,
			116, 101, 8, 109, 107, 114, 101, 102, 97, 110,
			121, 7, 108, 100, 116, 111, 107, 101, 110, 7,
			99, 111, 110, 118, 46, 117, 50, 7, 99, 111,
			110, 118, 46, 117, 49, 6, 99, 111, 110, 118,
			46, 105, 10, 99, 111, 110, 118, 46, 111, 118,
			102, 46, 105, 10, 99, 111, 110, 118, 46, 111,
			118, 102, 46, 117, 7, 97, 100, 100, 46, 111,
			118, 102, 10, 97, 100, 100, 46, 111, 118, 102,
			46, 117, 110, 7, 109, 117, 108, 46, 111, 118,
			102, 10, 109, 117, 108, 46, 111, 118, 102, 46,
			117, 110, 7, 115, 117, 98, 46, 111, 118, 102,
			10, 115, 117, 98, 46, 111, 118, 102, 46, 117,
			110, 10, 101, 110, 100, 102, 105, 110, 97, 108,
			108, 121, 5, 108, 101, 97, 118, 101, 7, 108,
			101, 97, 118, 101, 46, 115, 7, 115, 116, 105,
			110, 100, 46, 105, 6, 99, 111, 110, 118, 46,
			117, 7, 97, 114, 103, 108, 105, 115, 116, 3,
			99, 101, 113, 3, 99, 103, 116, 6, 99, 103,
			116, 46, 117, 110, 3, 99, 108, 116, 6, 99,
			108, 116, 46, 117, 110, 5, 108, 100, 102, 116,
			110, 9, 108, 100, 118, 105, 114, 116, 102, 116,
			110, 5, 108, 100, 97, 114, 103, 6, 108, 100,
			97, 114, 103, 97, 5, 115, 116, 97, 114, 103,
			5, 108, 100, 108, 111, 99, 6, 108, 100, 108,
			111, 99, 97, 5, 115, 116, 108, 111, 99, 8,
			108, 111, 99, 97, 108, 108, 111, 99, 9, 101,
			110, 100, 102, 105, 108, 116, 101, 114, 10, 117,
			110, 97, 108, 105, 103, 110, 101, 100, 46, 9,
			118, 111, 108, 97, 116, 105, 108, 101, 46, 5,
			116, 97, 105, 108, 46, 7, 105, 110, 105, 116,
			111, 98, 106, 12, 99, 111, 110, 115, 116, 114,
			97, 105, 110, 101, 100, 46, 5, 99, 112, 98,
			108, 107, 7, 105, 110, 105, 116, 98, 108, 107,
			3, 110, 111, 46, 7, 114, 101, 116, 104, 114,
			111, 119, 6, 115, 105, 122, 101, 111, 102, 10,
			114, 101, 102, 97, 110, 121, 116, 121, 112, 101,
			9, 114, 101, 97, 100, 111, 110, 108, 121, 46
		};
		names = new string[219];
		int i = 0;
		int num = 0;
		for (; i < names.Length; i++)
		{
			char[] array2 = new char[array[num++]];
			for (int j = 0; j < array2.Length; j++)
			{
				array2[j] = (char)array[num++];
			}
			names[i] = new string(array2);
		}
	}
}


using Mono.Cecil.Cil;

public static class OpCodes
{
	internal static readonly OpCode[] OneByteOpCode = new OpCode[225];

	internal static readonly OpCode[] TwoBytesOpCode = new OpCode[31];

	public static readonly OpCode Nop = new OpCode(83886335, 318768389);

	public static readonly OpCode Break = new OpCode(16843263, 318768389);

	public static readonly OpCode Ldarg_0 = new OpCode(84017919, 335545601);

	public static readonly OpCode Ldarg_1 = new OpCode(84083711, 335545601);

	public static readonly OpCode Ldarg_2 = new OpCode(84149503, 335545601);

	public static readonly OpCode Ldarg_3 = new OpCode(84215295, 335545601);

	public static readonly OpCode Ldloc_0 = new OpCode(84281087, 335545601);

	public static readonly OpCode Ldloc_1 = new OpCode(84346879, 335545601);

	public static readonly OpCode Ldloc_2 = new OpCode(84412671, 335545601);

	public static readonly OpCode Ldloc_3 = new OpCode(84478463, 335545601);

	public static readonly OpCode Stloc_0 = new OpCode(84544255, 318833921);

	public static readonly OpCode Stloc_1 = new OpCode(84610047, 318833921);

	public static readonly OpCode Stloc_2 = new OpCode(84675839, 318833921);

	public static readonly OpCode Stloc_3 = new OpCode(84741631, 318833921);

	public static readonly OpCode Ldarg_S = new OpCode(84807423, 335549185);

	public static readonly OpCode Ldarga_S = new OpCode(84873215, 369103617);

	public static readonly OpCode Starg_S = new OpCode(84939007, 318837505);

	public static readonly OpCode Ldloc_S = new OpCode(85004799, 335548929);

	public static readonly OpCode Ldloca_S = new OpCode(85070591, 369103361);

	public static readonly OpCode Stloc_S = new OpCode(85136383, 318837249);

	public static readonly OpCode Ldnull = new OpCode(85202175, 436208901);

	public static readonly OpCode Ldc_I4_M1 = new OpCode(85267967, 369100033);

	public static readonly OpCode Ldc_I4_0 = new OpCode(85333759, 369100033);

	public static readonly OpCode Ldc_I4_1 = new OpCode(85399551, 369100033);

	public static readonly OpCode Ldc_I4_2 = new OpCode(85465343, 369100033);

	public static readonly OpCode Ldc_I4_3 = new OpCode(85531135, 369100033);

	public static readonly OpCode Ldc_I4_4 = new OpCode(85596927, 369100033);

	public static readonly OpCode Ldc_I4_5 = new OpCode(85662719, 369100033);

	public static readonly OpCode Ldc_I4_6 = new OpCode(85728511, 369100033);

	public static readonly OpCode Ldc_I4_7 = new OpCode(85794303, 369100033);

	public static readonly OpCode Ldc_I4_8 = new OpCode(85860095, 369100033);

	public static readonly OpCode Ldc_I4_S = new OpCode(85925887, 369102849);

	public static readonly OpCode Ldc_I4 = new OpCode(85991679, 369099269);

	public static readonly OpCode Ldc_I8 = new OpCode(86057471, 385876741);

	public static readonly OpCode Ldc_R4 = new OpCode(86123263, 402657541);

	public static readonly OpCode Ldc_R8 = new OpCode(86189055, 419432197);

	public static readonly OpCode Dup = new OpCode(86255103, 352388357);

	public static readonly OpCode Pop = new OpCode(86320895, 318833925);

	public static readonly OpCode Jmp = new OpCode(36055039, 318768133);

	public static readonly OpCode Call = new OpCode(36120831, 471532549);

	public static readonly OpCode Calli = new OpCode(36186623, 471533573);

	public static readonly OpCode Ret = new OpCode(120138495, 320537861);

	public static readonly OpCode Br_S = new OpCode(2763775, 318770945);

	public static readonly OpCode Brfalse_S = new OpCode(53161215, 318967553);

	public static readonly OpCode Brtrue_S = new OpCode(53227007, 318967553);

	public static readonly OpCode Beq_S = new OpCode(53292799, 318902017);

	public static readonly OpCode Bge_S = new OpCode(53358591, 318902017);

	public static readonly OpCode Bgt_S = new OpCode(53424383, 318902017);

	public static readonly OpCode Ble_S = new OpCode(53490175, 318902017);

	public static readonly OpCode Blt_S = new OpCode(53555967, 318902017);

	public static readonly OpCode Bne_Un_S = new OpCode(53621759, 318902017);

	public static readonly OpCode Bge_Un_S = new OpCode(53687551, 318902017);

	public static readonly OpCode Bgt_Un_S = new OpCode(53753343, 318902017);

	public static readonly OpCode Ble_Un_S = new OpCode(53819135, 318902017);

	public static readonly OpCode Blt_Un_S = new OpCode(53884927, 318902017);

	public static readonly OpCode Br = new OpCode(3619071, 318767109);

	public static readonly OpCode Brfalse = new OpCode(54016511, 318963717);

	public static readonly OpCode Brtrue = new OpCode(54082303, 318963717);

	public static readonly OpCode Beq = new OpCode(54148095, 318898177);

	public static readonly OpCode Bge = new OpCode(54213887, 318898177);

	public static readonly OpCode Bgt = new OpCode(54279679, 318898177);

	public static readonly OpCode Ble = new OpCode(54345471, 318898177);

	public static readonly OpCode Blt = new OpCode(54411263, 318898177);

	public static readonly OpCode Bne_Un = new OpCode(54477055, 318898177);

	public static readonly OpCode Bge_Un = new OpCode(54542847, 318898177);

	public static readonly OpCode Bgt_Un = new OpCode(54608639, 318898177);

	public static readonly OpCode Ble_Un = new OpCode(54674431, 318898177);

	public static readonly OpCode Blt_Un = new OpCode(54740223, 318898177);

	public static readonly OpCode Switch = new OpCode(54806015, 318966277);

	public static readonly OpCode Ldind_I1 = new OpCode(88426239, 369296645);

	public static readonly OpCode Ldind_U1 = new OpCode(88492031, 369296645);

	public static readonly OpCode Ldind_I2 = new OpCode(88557823, 369296645);

	public static readonly OpCode Ldind_U2 = new OpCode(88623615, 369296645);

	public static readonly OpCode Ldind_I4 = new OpCode(88689407, 369296645);

	public static readonly OpCode Ldind_U4 = new OpCode(88755199, 369296645);

	public static readonly OpCode Ldind_I8 = new OpCode(88820991, 386073861);

	public static readonly OpCode Ldind_I = new OpCode(88886783, 369296645);

	public static readonly OpCode Ldind_R4 = new OpCode(88952575, 402851077);

	public static readonly OpCode Ldind_R8 = new OpCode(89018367, 419628293);

	public static readonly OpCode Ldind_Ref = new OpCode(89084159, 436405509);

	public static readonly OpCode Stind_Ref = new OpCode(89149951, 319096069);

	public static readonly OpCode Stind_I1 = new OpCode(89215743, 319096069);

	public static readonly OpCode Stind_I2 = new OpCode(89281535, 319096069);

	public static readonly OpCode Stind_I4 = new OpCode(89347327, 319096069);

	public static readonly OpCode Stind_I8 = new OpCode(89413119, 319161605);

	public static readonly OpCode Stind_R4 = new OpCode(89478911, 319292677);

	public static readonly OpCode Stind_R8 = new OpCode(89544703, 319358213);

	public static readonly OpCode Add = new OpCode(89610495, 335676677);

	public static readonly OpCode Sub = new OpCode(89676287, 335676677);

	public static readonly OpCode Mul = new OpCode(89742079, 335676677);

	public static readonly OpCode Div = new OpCode(89807871, 335676677);

	public static readonly OpCode Div_Un = new OpCode(89873663, 335676677);

	public static readonly OpCode Rem = new OpCode(89939455, 335676677);

	public static readonly OpCode Rem_Un = new OpCode(90005247, 335676677);

	public static readonly OpCode And = new OpCode(90071039, 335676677);

	public static readonly OpCode Or = new OpCode(90136831, 335676677);

	public static readonly OpCode Xor = new OpCode(90202623, 335676677);

	public static readonly OpCode Shl = new OpCode(90268415, 335676677);

	public static readonly OpCode Shr = new OpCode(90334207, 335676677);

	public static readonly OpCode Shr_Un = new OpCode(90399999, 335676677);

	public static readonly OpCode Neg = new OpCode(90465791, 335611141);

	public static readonly OpCode Not = new OpCode(90531583, 335611141);

	public static readonly OpCode Conv_I1 = new OpCode(90597375, 369165573);

	public static readonly OpCode Conv_I2 = new OpCode(90663167, 369165573);

	public static readonly OpCode Conv_I4 = new OpCode(90728959, 369165573);

	public static readonly OpCode Conv_I8 = new OpCode(90794751, 385942789);

	public static readonly OpCode Conv_R4 = new OpCode(90860543, 402720005);

	public static readonly OpCode Conv_R8 = new OpCode(90926335, 419497221);

	public static readonly OpCode Conv_U4 = new OpCode(90992127, 369165573);

	public static readonly OpCode Conv_U8 = new OpCode(91057919, 385942789);

	public static readonly OpCode Callvirt = new OpCode(40792063, 471532547);

	public static readonly OpCode Cpobj = new OpCode(91189503, 319097859);

	public static readonly OpCode Ldobj = new OpCode(91255295, 335744003);

	public static readonly OpCode Ldstr = new OpCode(91321087, 436209923);

	public static readonly OpCode Newobj = new OpCode(41055231, 437978115);

	public static readonly OpCode Castclass = new OpCode(91452671, 436866051);

	public static readonly OpCode Isinst = new OpCode(91518463, 369757187);

	public static readonly OpCode Conv_R_Un = new OpCode(91584255, 419497221);

	public static readonly OpCode Unbox = new OpCode(91650559, 369757189);

	public static readonly OpCode Throw = new OpCode(142047999, 319423747);

	public static readonly OpCode Ldfld = new OpCode(91782143, 336199939);

	public static readonly OpCode Ldflda = new OpCode(91847935, 369754371);

	public static readonly OpCode Stfld = new OpCode(91913727, 319488259);

	public static readonly OpCode Ldsfld = new OpCode(91979519, 335544579);

	public static readonly OpCode Ldsflda = new OpCode(92045311, 369099011);

	public static readonly OpCode Stsfld = new OpCode(92111103, 318832899);

	public static readonly OpCode Stobj = new OpCode(92176895, 319032323);

	public static readonly OpCode Conv_Ovf_I1_Un = new OpCode(92242687, 369165573);

	public static readonly OpCode Conv_Ovf_I2_Un = new OpCode(92308479, 369165573);

	public static readonly OpCode Conv_Ovf_I4_Un = new OpCode(92374271, 369165573);

	public static readonly OpCode Conv_Ovf_I8_Un = new OpCode(92440063, 385942789);

	public static readonly OpCode Conv_Ovf_U1_Un = new OpCode(92505855, 369165573);

	public static readonly OpCode Conv_Ovf_U2_Un = new OpCode(92571647, 369165573);

	public static readonly OpCode Conv_Ovf_U4_Un = new OpCode(92637439, 369165573);

	public static readonly OpCode Conv_Ovf_U8_Un = new OpCode(92703231, 385942789);

	public static readonly OpCode Conv_Ovf_I_Un = new OpCode(92769023, 369165573);

	public static readonly OpCode Conv_Ovf_U_Un = new OpCode(92834815, 369165573);

	public static readonly OpCode Box = new OpCode(92900607, 436276229);

	public static readonly OpCode Newarr = new OpCode(92966399, 436407299);

	public static readonly OpCode Ldlen = new OpCode(93032191, 369755395);

	public static readonly OpCode Ldelema = new OpCode(93097983, 369888259);

	public static readonly OpCode Ldelem_I1 = new OpCode(93163775, 369886467);

	public static readonly OpCode Ldelem_U1 = new OpCode(93229567, 369886467);

	public static readonly OpCode Ldelem_I2 = new OpCode(93295359, 369886467);

	public static readonly OpCode Ldelem_U2 = new OpCode(93361151, 369886467);

	public static readonly OpCode Ldelem_I4 = new OpCode(93426943, 369886467);

	public static readonly OpCode Ldelem_U4 = new OpCode(93492735, 369886467);

	public static readonly OpCode Ldelem_I8 = new OpCode(93558527, 386663683);

	public static readonly OpCode Ldelem_I = new OpCode(93624319, 369886467);

	public static readonly OpCode Ldelem_R4 = new OpCode(93690111, 403440899);

	public static readonly OpCode Ldelem_R8 = new OpCode(93755903, 420218115);

	public static readonly OpCode Ldelem_Ref = new OpCode(93821695, 436995331);

	public static readonly OpCode Stelem_I = new OpCode(93887487, 319620355);

	public static readonly OpCode Stelem_I1 = new OpCode(93953279, 319620355);

	public static readonly OpCode Stelem_I2 = new OpCode(94019071, 319620355);

	public static readonly OpCode Stelem_I4 = new OpCode(94084863, 319620355);

	public static readonly OpCode Stelem_I8 = new OpCode(94150655, 319685891);

	public static readonly OpCode Stelem_R4 = new OpCode(94216447, 319751427);

	public static readonly OpCode Stelem_R8 = new OpCode(94282239, 319816963);

	public static readonly OpCode Stelem_Ref = new OpCode(94348031, 319882499);

	public static readonly OpCode Ldelem_Any = new OpCode(94413823, 336333827);

	public static readonly OpCode Stelem_Any = new OpCode(94479615, 319884291);

	public static readonly OpCode Unbox_Any = new OpCode(94545407, 336202755);

	public static readonly OpCode Conv_Ovf_I1 = new OpCode(94614527, 369165573);

	public static readonly OpCode Conv_Ovf_U1 = new OpCode(94680319, 369165573);

	public static readonly OpCode Conv_Ovf_I2 = new OpCode(94746111, 369165573);

	public static readonly OpCode Conv_Ovf_U2 = new OpCode(94811903, 369165573);

	public static readonly OpCode Conv_Ovf_I4 = new OpCode(94877695, 369165573);

	public static readonly OpCode Conv_Ovf_U4 = new OpCode(94943487, 369165573);

	public static readonly OpCode Conv_Ovf_I8 = new OpCode(95009279, 385942789);

	public static readonly OpCode Conv_Ovf_U8 = new OpCode(95075071, 385942789);

	public static readonly OpCode Refanyval = new OpCode(95142655, 369167365);

	public static readonly OpCode Ckfinite = new OpCode(95208447, 419497221);

	public static readonly OpCode Mkrefany = new OpCode(95274751, 335744005);

	public static readonly OpCode Ldtoken = new OpCode(95342847, 369101573);

	public static readonly OpCode Conv_U2 = new OpCode(95408639, 369165573);

	public static readonly OpCode Conv_U1 = new OpCode(95474431, 369165573);

	public static readonly OpCode Conv_I = new OpCode(95540223, 369165573);

	public static readonly OpCode Conv_Ovf_I = new OpCode(95606015, 369165573);

	public static readonly OpCode Conv_Ovf_U = new OpCode(95671807, 369165573);

	public static readonly OpCode Add_Ovf = new OpCode(95737599, 335676677);

	public static readonly OpCode Add_Ovf_Un = new OpCode(95803391, 335676677);

	public static readonly OpCode Mul_Ovf = new OpCode(95869183, 335676677);

	public static readonly OpCode Mul_Ovf_Un = new OpCode(95934975, 335676677);

	public static readonly OpCode Sub_Ovf = new OpCode(96000767, 335676677);

	public static readonly OpCode Sub_Ovf_Un = new OpCode(96066559, 335676677);

	public static readonly OpCode Endfinally = new OpCode(129686783, 318768389);

	public static readonly OpCode Leave = new OpCode(12312063, 319946757);

	public static readonly OpCode Leave_S = new OpCode(12377855, 319950593);

	public static readonly OpCode Stind_I = new OpCode(96329727, 319096069);

	public static readonly OpCode Conv_U = new OpCode(96395519, 369165573);

	public static readonly OpCode Arglist = new OpCode(96403710, 369100037);

	public static readonly OpCode Ceq = new OpCode(96469502, 369231109);

	public static readonly OpCode Cgt = new OpCode(96535294, 369231109);

	public static readonly OpCode Cgt_Un = new OpCode(96601086, 369231109);

	public static readonly OpCode Clt = new OpCode(96666878, 369231109);

	public static readonly OpCode Clt_Un = new OpCode(96732670, 369231109);

	public static readonly OpCode Ldftn = new OpCode(96798462, 369099781);

	public static readonly OpCode Ldvirtftn = new OpCode(96864254, 369755141);

	public static readonly OpCode Ldarg = new OpCode(96930302, 335547909);

	public static readonly OpCode Ldarga = new OpCode(96996094, 369102341);

	public static readonly OpCode Starg = new OpCode(97061886, 318836229);

	public static readonly OpCode Ldloc = new OpCode(97127678, 335547653);

	public static readonly OpCode Ldloca = new OpCode(97193470, 369102085);

	public static readonly OpCode Stloc = new OpCode(97259262, 318835973);

	public static readonly OpCode Localloc = new OpCode(97325054, 369296645);

	public static readonly OpCode Endfilter = new OpCode(130945534, 318964997);

	public static readonly OpCode Unaligned = new OpCode(80679678, 318771204);

	public static readonly OpCode Volatile = new OpCode(80745470, 318768388);

	public static readonly OpCode Tail = new OpCode(80811262, 318768388);

	public static readonly OpCode Initobj = new OpCode(97654270, 318966787);

	public static readonly OpCode Constrained = new OpCode(97720062, 318770180);

	public static readonly OpCode Cpblk = new OpCode(97785854, 319227141);

	public static readonly OpCode Initblk = new OpCode(97851646, 319227141);

	public static readonly OpCode No = new OpCode(97917438, 318771204);

	public static readonly OpCode Rethrow = new OpCode(148314878, 318768387);

	public static readonly OpCode Sizeof = new OpCode(98049278, 369101829);

	public static readonly OpCode Refanytype = new OpCode(98115070, 369165573);

	public static readonly OpCode Readonly = new OpCode(98180862, 318768388);
}


using Mono.Cecil.Cil;

public sealed class SequencePoint
{
	private Document document;

	private int start_line;

	private int start_column;

	private int end_line;

	private int end_column;

	public int StartLine
	{
		get
		{
			return start_line;
		}
		set
		{
			start_line = value;
		}
	}

	public int StartColumn
	{
		get
		{
			return start_column;
		}
		set
		{
			start_column = value;
		}
	}

	public int EndLine
	{
		get
		{
			return end_line;
		}
		set
		{
			end_line = value;
		}
	}

	public int EndColumn
	{
		get
		{
			return end_column;
		}
		set
		{
			end_column = value;
		}
	}

	public Document Document
	{
		get
		{
			return document;
		}
		set
		{
			document = value;
		}
	}

	public SequencePoint(Document document)
	{
		this.document = document;
	}
}


public struct ImageDebugDirectory
{
	public int Characteristics;

	public int TimeDateStamp;

	public short MajorVersion;

	public short MinorVersion;

	public int Type;

	public int SizeOfData;

	public int AddressOfRawData;

	public int PointerToRawData;
}


using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Collections.Generic;

public sealed class Scope : IVariableDefinitionProvider
{
	private Instruction start;

	private Instruction end;

	private Collection<Scope> scopes;

	private Collection<VariableDefinition> variables;

	public Instruction Start
	{
		get
		{
			return start;
		}
		set
		{
			start = value;
		}
	}

	public Instruction End
	{
		get
		{
			return end;
		}
		set
		{
			end = value;
		}
	}

	public bool HasScopes => !scopes.IsNullOrEmpty();

	public Collection<Scope> Scopes
	{
		get
		{
			if (scopes == null)
			{
				scopes = new Collection<Scope>();
			}
			return scopes;
		}
	}

	public bool HasVariables => !variables.IsNullOrEmpty();

	public Collection<VariableDefinition> Variables
	{
		get
		{
			if (variables == null)
			{
				variables = new Collection<VariableDefinition>();
			}
			return variables;
		}
	}
}


using Mono.Cecil.Cil;

public struct InstructionSymbol
{
	public readonly int Offset;

	public readonly SequencePoint SequencePoint;

	public InstructionSymbol(int offset, SequencePoint sequencePoint)
	{
		Offset = offset;
		SequencePoint = sequencePoint;
	}
}


using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Collections.Generic;

public sealed class MethodSymbols
{
	internal int code_size;

	internal string method_name;

	internal MetadataToken method_token;

	internal MetadataToken local_var_token;

	internal Collection<VariableDefinition> variables;

	internal Collection<InstructionSymbol> instructions;

	public bool HasVariables => !variables.IsNullOrEmpty();

	public Collection<VariableDefinition> Variables
	{
		get
		{
			if (variables == null)
			{
				variables = new Collection<VariableDefinition>();
			}
			return variables;
		}
	}

	public Collection<InstructionSymbol> Instructions
	{
		get
		{
			if (instructions == null)
			{
				instructions = new Collection<InstructionSymbol>();
			}
			return instructions;
		}
	}

	public int CodeSize => code_size;

	public string MethodName => method_name;

	public MetadataToken MethodToken => method_token;

	public MetadataToken LocalVarToken => local_var_token;

	internal MethodSymbols(string methodName)
	{
		method_name = methodName;
	}

	public MethodSymbols(MetadataToken methodToken)
	{
		method_token = methodToken;
	}
}


using Mono.Cecil.Cil;

public delegate Instruction InstructionMapper(int offset);


using System;
using Mono.Cecil.Cil;

public interface ISymbolReader : IDisposable
{
	bool ProcessDebugHeader(ImageDebugDirectory directory, byte[] header);

	void Read(MethodBody body, InstructionMapper mapper);

	void Read(MethodSymbols symbols);
}


using System.IO;
using Mono.Cecil;
using Mono.Cecil.Cil;

public interface ISymbolReaderProvider
{
	ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);

	ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
}


using System;
using System.IO;
using System.Reflection;
using Mono.Cecil.Cil;

internal static class SymbolProvider
{
	private static readonly string symbol_kind = ((Type.GetType("Mono.Runtime") != null) ? "Mdb" : "Pdb");

	private static ISymbolReaderProvider reader_provider;

	private static ISymbolWriterProvider writer_provider;

	private static AssemblyName GetPlatformSymbolAssemblyName()
	{
		AssemblyName name = typeof(SymbolProvider).Assembly.GetName();
		AssemblyName assemblyName = new AssemblyName();
		assemblyName.Name = "Mono.Cecil." + symbol_kind;
		assemblyName.Version = name.Version;
		assemblyName.SetPublicKeyToken(name.GetPublicKeyToken());
		return assemblyName;
	}

	private static Type GetPlatformType(string fullname)
	{
		Type type = Type.GetType(fullname);
		if (type != null)
		{
			return type;
		}
		AssemblyName platformSymbolAssemblyName = GetPlatformSymbolAssemblyName();
		type = Type.GetType(fullname + ", " + platformSymbolAssemblyName.FullName);
		if (type != null)
		{
			return type;
		}
		try
		{
			Assembly assembly = Assembly.Load(platformSymbolAssemblyName);
			if (assembly != null)
			{
				return assembly.GetType(fullname);
			}
		}
		catch (FileNotFoundException)
		{
		}
		catch (FileLoadException)
		{
		}
		return null;
	}

	public static ISymbolReaderProvider GetPlatformReaderProvider()
	{
		if (reader_provider != null)
		{
			return reader_provider;
		}
		Type platformType = GetPlatformType(GetProviderTypeName("ReaderProvider"));
		if (platformType == null)
		{
			return null;
		}
		return reader_provider = (ISymbolReaderProvider)Activator.CreateInstance(platformType);
	}

	private static string GetProviderTypeName(string name)
	{
		return "Mono.Cecil." + symbol_kind + "." + symbol_kind + name;
	}

	public static ISymbolWriterProvider GetPlatformWriterProvider()
	{
		if (writer_provider != null)
		{
			return writer_provider;
		}
		Type platformType = GetPlatformType(GetProviderTypeName("WriterProvider"));
		if (platformType == null)
		{
			return null;
		}
		return writer_provider = (ISymbolWriterProvider)Activator.CreateInstance(platformType);
	}
}


using System;
using Mono.Cecil.Cil;

public interface ISymbolWriter : IDisposable
{
	bool GetDebugHeader(out ImageDebugDirectory directory, out byte[] header);

	void Write(MethodBody body);

	void Write(MethodSymbols symbols);
}


using System.IO;
using Mono.Cecil;
using Mono.Cecil.Cil;

public interface ISymbolWriterProvider
{
	ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);

	ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
}


using Mono.Cecil;
using Mono.Cecil.Cil;

public sealed class VariableDefinition : VariableReference
{
	public bool IsPinned => variable_type.IsPinned;

	public VariableDefinition(TypeReference variableType)
		: base(variableType)
	{
	}

	public VariableDefinition(string name, TypeReference variableType)
		: base(name, variableType)
	{
	}

	public override VariableDefinition Resolve()
	{
		return this;
	}
}


using Mono.Cecil;
using Mono.Cecil.Cil;

public abstract class VariableReference
{
	private string name;

	internal int index = -1;

	protected TypeReference variable_type;

	public string Name
	{
		get
		{
			return name;
		}
		set
		{
			name = value;
		}
	}

	public TypeReference VariableType
	{
		get
		{
			return variable_type;
		}
		set
		{
			variable_type = value;
		}
	}

	public int Index => index;

	internal VariableReference(TypeReference variable_type)
		: this(string.Empty, variable_type)
	{
	}

	internal VariableReference(string name, TypeReference variable_type)
	{
		this.name = name;
		this.variable_type = variable_type;
	}

	public abstract VariableDefinition Resolve();

	public override string ToString()
	{
		if (!string.IsNullOrEmpty(name))
		{
			return name;
		}
		if (index >= 0)
		{
			return "V_" + index;
		}
		return string.Empty;
	}
}


using System;
using Mono.Cecil;

public static class MethodDefinitionRocks
{
	public static MethodDefinition GetBaseMethod(this MethodDefinition self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		if (!self.IsVirtual)
		{
			return self;
		}
		if (self.IsNewSlot)
		{
			return self;
		}
		for (TypeDefinition typeDefinition = ResolveBaseType(self.DeclaringType); typeDefinition != null; typeDefinition = ResolveBaseType(typeDefinition))
		{
			MethodDefinition matchingMethod = GetMatchingMethod(typeDefinition, self);
			if (matchingMethod != null)
			{
				return matchingMethod;
			}
		}
		return self;
	}

	public static MethodDefinition GetOriginalBaseMethod(this MethodDefinition self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		while (true)
		{
			MethodDefinition baseMethod = GetBaseMethod(self);
			if (baseMethod == self)
			{
				break;
			}
			self = baseMethod;
		}
		return self;
	}

	private static TypeDefinition ResolveBaseType(TypeDefinition type)
	{
		return type?.BaseType?.Resolve();
	}

	private static MethodDefinition GetMatchingMethod(TypeDefinition type, MethodDefinition method)
	{
		return MetadataResolver.GetMethod(type.Methods, method);
	}
}


using System;
using System.Security;
using System.Security.Permissions;
using Mono.Cecil;

public static class SecurityDeclarationRocks
{
	public static PermissionSet ToPermissionSet(this SecurityDeclaration self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		if (TryProcessPermissionSetAttribute(self, out var set))
		{
			return set;
		}
		return CreatePermissionSet(self);
	}

	private static bool TryProcessPermissionSetAttribute(SecurityDeclaration declaration, out PermissionSet set)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Expected O, but got Unknown
		set = null;
		if (!declaration.HasSecurityAttributes && declaration.SecurityAttributes.Count != 1)
		{
			return false;
		}
		Mono.Cecil.SecurityAttribute securityAttribute = declaration.SecurityAttributes[0];
		if (!securityAttribute.AttributeType.IsTypeOf("System.Security.Permissions", "PermissionSetAttribute"))
		{
			return false;
		}
		PermissionSetAttribute val = new PermissionSetAttribute((System.Security.Permissions.SecurityAction)declaration.Action);
		CustomAttributeNamedArgument customAttributeNamedArgument = securityAttribute.Properties[0];
		string text = (string)customAttributeNamedArgument.Argument.Value;
		string name = customAttributeNamedArgument.Name;
		if (!(name == "XML"))
		{
			if (!(name == "Name"))
			{
				throw new NotImplementedException(customAttributeNamedArgument.Name);
			}
			val.Name = text;
		}
		else
		{
			val.XML = text;
		}
		set = val.CreatePermissionSet();
		return true;
	}

	private static PermissionSet CreatePermissionSet(SecurityDeclaration declaration)
	{
		PermissionSet permissionSet = new PermissionSet(PermissionState.None);
		foreach (Mono.Cecil.SecurityAttribute securityAttribute in declaration.SecurityAttributes)
		{
			IPermission perm = CreatePermission(declaration, securityAttribute);
			permissionSet.AddPermission(perm);
		}
		return permissionSet;
	}

	private static IPermission CreatePermission(SecurityDeclaration declaration, Mono.Cecil.SecurityAttribute attribute)
	{
		Type? type = Type.GetType(attribute.AttributeType.FullName);
		if (type == null)
		{
			throw new ArgumentException("attribute");
		}
		System.Security.Permissions.SecurityAttribute obj = CreateSecurityAttribute(type, declaration) ?? throw new InvalidOperationException();
		CompleteSecurityAttribute(obj, attribute);
		return obj.CreatePermission();
	}

	private static void CompleteSecurityAttribute(System.Security.Permissions.SecurityAttribute security_attribute, Mono.Cecil.SecurityAttribute attribute)
	{
		if (attribute.HasFields)
		{
			CompleteSecurityAttributeFields(security_attribute, attribute);
		}
		if (attribute.HasProperties)
		{
			CompleteSecurityAttributeProperties(security_attribute, attribute);
		}
	}

	private static void CompleteSecurityAttributeFields(System.Security.Permissions.SecurityAttribute security_attribute, Mono.Cecil.SecurityAttribute attribute)
	{
		Type type = security_attribute.GetType();
		foreach (CustomAttributeNamedArgument field in attribute.Fields)
		{
			type.GetField(field.Name).SetValue(security_attribute, field.Argument.Value);
		}
	}

	private static void CompleteSecurityAttributeProperties(System.Security.Permissions.SecurityAttribute security_attribute, Mono.Cecil.SecurityAttribute attribute)
	{
		Type type = security_attribute.GetType();
		foreach (CustomAttributeNamedArgument property in attribute.Properties)
		{
			type.GetProperty(property.Name).SetValue(security_attribute, property.Argument.Value, null);
		}
	}

	private static System.Security.Permissions.SecurityAttribute CreateSecurityAttribute(Type attribute_type, SecurityDeclaration declaration)
	{
		try
		{
			return (System.Security.Permissions.SecurityAttribute)Activator.CreateInstance(attribute_type, (System.Security.Permissions.SecurityAction)declaration.Action);
		}
		catch (MissingMethodException)
		{
			return (System.Security.Permissions.SecurityAttribute)Activator.CreateInstance(attribute_type, new object[0]);
		}
	}

	public static SecurityDeclaration ToSecurityDeclaration(this PermissionSet self, Mono.Cecil.SecurityAction action, ModuleDefinition module)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		if (module == null)
		{
			throw new ArgumentNullException("module");
		}
		SecurityDeclaration securityDeclaration = new SecurityDeclaration(action);
		Mono.Cecil.SecurityAttribute item = new Mono.Cecil.SecurityAttribute(module.TypeSystem.LookupType("System.Security.Permissions", "PermissionSetAttribute"))
		{
			Properties = 
			{
				new CustomAttributeNamedArgument("XML", new CustomAttributeArgument(module.TypeSystem.String, self.ToXml().ToString()))
			}
		};
		securityDeclaration.SecurityAttributes.Add(item);
		return securityDeclaration;
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Cil;

public static class MethodBodyRocks
{
	public static void SimplifyMacros(this MethodBody self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		foreach (Instruction instruction in self.Instructions)
		{
			if (instruction.OpCode.OpCodeType == OpCodeType.Macro)
			{
				switch (instruction.OpCode.Code)
				{
				case Code.Ldarg_0:
					ExpandMacro(instruction, OpCodes.Ldarg, self.GetParameter(0));
					break;
				case Code.Ldarg_1:
					ExpandMacro(instruction, OpCodes.Ldarg, self.GetParameter(1));
					break;
				case Code.Ldarg_2:
					ExpandMacro(instruction, OpCodes.Ldarg, self.GetParameter(2));
					break;
				case Code.Ldarg_3:
					ExpandMacro(instruction, OpCodes.Ldarg, self.GetParameter(3));
					break;
				case Code.Ldloc_0:
					ExpandMacro(instruction, OpCodes.Ldloc, self.Variables[0]);
					break;
				case Code.Ldloc_1:
					ExpandMacro(instruction, OpCodes.Ldloc, self.Variables[1]);
					break;
				case Code.Ldloc_2:
					ExpandMacro(instruction, OpCodes.Ldloc, self.Variables[2]);
					break;
				case Code.Ldloc_3:
					ExpandMacro(instruction, OpCodes.Ldloc, self.Variables[3]);
					break;
				case Code.Stloc_0:
					ExpandMacro(instruction, OpCodes.Stloc, self.Variables[0]);
					break;
				case Code.Stloc_1:
					ExpandMacro(instruction, OpCodes.Stloc, self.Variables[1]);
					break;
				case Code.Stloc_2:
					ExpandMacro(instruction, OpCodes.Stloc, self.Variables[2]);
					break;
				case Code.Stloc_3:
					ExpandMacro(instruction, OpCodes.Stloc, self.Variables[3]);
					break;
				case Code.Ldarg_S:
					instruction.OpCode = OpCodes.Ldarg;
					break;
				case Code.Ldarga_S:
					instruction.OpCode = OpCodes.Ldarga;
					break;
				case Code.Starg_S:
					instruction.OpCode = OpCodes.Starg;
					break;
				case Code.Ldloc_S:
					instruction.OpCode = OpCodes.Ldloc;
					break;
				case Code.Ldloca_S:
					instruction.OpCode = OpCodes.Ldloca;
					break;
				case Code.Stloc_S:
					instruction.OpCode = OpCodes.Stloc;
					break;
				case Code.Ldc_I4_M1:
					ExpandMacro(instruction, OpCodes.Ldc_I4, -1);
					break;
				case Code.Ldc_I4_0:
					ExpandMacro(instruction, OpCodes.Ldc_I4, 0);
					break;
				case Code.Ldc_I4_1:
					ExpandMacro(instruction, OpCodes.Ldc_I4, 1);
					break;
				case Code.Ldc_I4_2:
					ExpandMacro(instruction, OpCodes.Ldc_I4, 2);
					break;
				case Code.Ldc_I4_3:
					ExpandMacro(instruction, OpCodes.Ldc_I4, 3);
					break;
				case Code.Ldc_I4_4:
					ExpandMacro(instruction, OpCodes.Ldc_I4, 4);
					break;
				case Code.Ldc_I4_5:
					ExpandMacro(instruction, OpCodes.Ldc_I4, 5);
					break;
				case Code.Ldc_I4_6:
					ExpandMacro(instruction, OpCodes.Ldc_I4, 6);
					break;
				case Code.Ldc_I4_7:
					ExpandMacro(instruction, OpCodes.Ldc_I4, 7);
					break;
				case Code.Ldc_I4_8:
					ExpandMacro(instruction, OpCodes.Ldc_I4, 8);
					break;
				case Code.Ldc_I4_S:
					ExpandMacro(instruction, OpCodes.Ldc_I4, (int)(sbyte)instruction.Operand);
					break;
				case Code.Br_S:
					instruction.OpCode = OpCodes.Br;
					break;
				case Code.Brfalse_S:
					instruction.OpCode = OpCodes.Brfalse;
					break;
				case Code.Brtrue_S:
					instruction.OpCode = OpCodes.Brtrue;
					break;
				case Code.Beq_S:
					instruction.OpCode = OpCodes.Beq;
					break;
				case Code.Bge_S:
					instruction.OpCode = OpCodes.Bge;
					break;
				case Code.Bgt_S:
					instruction.OpCode = OpCodes.Bgt;
					break;
				case Code.Ble_S:
					instruction.OpCode = OpCodes.Ble;
					break;
				case Code.Blt_S:
					instruction.OpCode = OpCodes.Blt;
					break;
				case Code.Bne_Un_S:
					instruction.OpCode = OpCodes.Bne_Un;
					break;
				case Code.Bge_Un_S:
					instruction.OpCode = OpCodes.Bge_Un;
					break;
				case Code.Bgt_Un_S:
					instruction.OpCode = OpCodes.Bgt_Un;
					break;
				case Code.Ble_Un_S:
					instruction.OpCode = OpCodes.Ble_Un;
					break;
				case Code.Blt_Un_S:
					instruction.OpCode = OpCodes.Blt_Un;
					break;
				case Code.Leave_S:
					instruction.OpCode = OpCodes.Leave;
					break;
				}
			}
		}
	}

	private static void ExpandMacro(Instruction instruction, OpCode opcode, object operand)
	{
		instruction.OpCode = opcode;
		instruction.Operand = operand;
	}

	private static void MakeMacro(Instruction instruction, OpCode opcode)
	{
		instruction.OpCode = opcode;
		instruction.Operand = null;
	}

	public static void OptimizeMacros(this MethodBody self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		MethodDefinition method = self.Method;
		foreach (Instruction instruction in self.Instructions)
		{
			switch (instruction.OpCode.Code)
			{
			case Code.Ldarg:
			{
				int index = ((ParameterDefinition)instruction.Operand).Index;
				if (index == -1 && instruction.Operand == self.ThisParameter)
				{
					index = 0;
				}
				else if (method.HasThis)
				{
					index++;
				}
				switch (index)
				{
				case 0:
					MakeMacro(instruction, OpCodes.Ldarg_0);
					break;
				case 1:
					MakeMacro(instruction, OpCodes.Ldarg_1);
					break;
				case 2:
					MakeMacro(instruction, OpCodes.Ldarg_2);
					break;
				case 3:
					MakeMacro(instruction, OpCodes.Ldarg_3);
					break;
				default:
					if (index < 256)
					{
						ExpandMacro(instruction, OpCodes.Ldarg_S, instruction.Operand);
					}
					break;
				}
				break;
			}
			case Code.Ldloc:
			{
				int index = ((VariableDefinition)instruction.Operand).Index;
				switch (index)
				{
				case 0:
					MakeMacro(instruction, OpCodes.Ldloc_0);
					break;
				case 1:
					MakeMacro(instruction, OpCodes.Ldloc_1);
					break;
				case 2:
					MakeMacro(instruction, OpCodes.Ldloc_2);
					break;
				case 3:
					MakeMacro(instruction, OpCodes.Ldloc_3);
					break;
				default:
					if (index < 256)
					{
						ExpandMacro(instruction, OpCodes.Ldloc_S, instruction.Operand);
					}
					break;
				}
				break;
			}
			case Code.Stloc:
			{
				int index = ((VariableDefinition)instruction.Operand).Index;
				switch (index)
				{
				case 0:
					MakeMacro(instruction, OpCodes.Stloc_0);
					break;
				case 1:
					MakeMacro(instruction, OpCodes.Stloc_1);
					break;
				case 2:
					MakeMacro(instruction, OpCodes.Stloc_2);
					break;
				case 3:
					MakeMacro(instruction, OpCodes.Stloc_3);
					break;
				default:
					if (index < 256)
					{
						ExpandMacro(instruction, OpCodes.Stloc_S, instruction.Operand);
					}
					break;
				}
				break;
			}
			case Code.Ldarga:
			{
				int index = ((ParameterDefinition)instruction.Operand).Index;
				if (index == -1 && instruction.Operand == self.ThisParameter)
				{
					index = 0;
				}
				else if (method.HasThis)
				{
					index++;
				}
				if (index < 256)
				{
					ExpandMacro(instruction, OpCodes.Ldarga_S, instruction.Operand);
				}
				break;
			}
			case Code.Ldloca:
				if (((VariableDefinition)instruction.Operand).Index < 256)
				{
					ExpandMacro(instruction, OpCodes.Ldloca_S, instruction.Operand);
				}
				break;
			case Code.Ldc_I4:
			{
				int num = (int)instruction.Operand;
				switch (num)
				{
				case -1:
					MakeMacro(instruction, OpCodes.Ldc_I4_M1);
					break;
				case 0:
					MakeMacro(instruction, OpCodes.Ldc_I4_0);
					break;
				case 1:
					MakeMacro(instruction, OpCodes.Ldc_I4_1);
					break;
				case 2:
					MakeMacro(instruction, OpCodes.Ldc_I4_2);
					break;
				case 3:
					MakeMacro(instruction, OpCodes.Ldc_I4_3);
					break;
				case 4:
					MakeMacro(instruction, OpCodes.Ldc_I4_4);
					break;
				case 5:
					MakeMacro(instruction, OpCodes.Ldc_I4_5);
					break;
				case 6:
					MakeMacro(instruction, OpCodes.Ldc_I4_6);
					break;
				case 7:
					MakeMacro(instruction, OpCodes.Ldc_I4_7);
					break;
				case 8:
					MakeMacro(instruction, OpCodes.Ldc_I4_8);
					break;
				default:
					if (num >= -128 && num < 128)
					{
						ExpandMacro(instruction, OpCodes.Ldc_I4_S, (sbyte)num);
					}
					break;
				}
				break;
			}
			}
		}
		OptimizeBranches(self);
	}

	private static void OptimizeBranches(MethodBody body)
	{
		ComputeOffsets(body);
		foreach (Instruction instruction in body.Instructions)
		{
			if (instruction.OpCode.OperandType == OperandType.InlineBrTarget && OptimizeBranch(instruction))
			{
				ComputeOffsets(body);
			}
		}
	}

	private static bool OptimizeBranch(Instruction instruction)
	{
		int num = ((Instruction)instruction.Operand).Offset - (instruction.Offset + instruction.OpCode.Size + 4);
		if (num < -128 || num > 127)
		{
			return false;
		}
		switch (instruction.OpCode.Code)
		{
		case Code.Br:
			instruction.OpCode = OpCodes.Br_S;
			break;
		case Code.Brfalse:
			instruction.OpCode = OpCodes.Brfalse_S;
			break;
		case Code.Brtrue:
			instruction.OpCode = OpCodes.Brtrue_S;
			break;
		case Code.Beq:
			instruction.OpCode = OpCodes.Beq_S;
			break;
		case Code.Bge:
			instruction.OpCode = OpCodes.Bge_S;
			break;
		case Code.Bgt:
			instruction.OpCode = OpCodes.Bgt_S;
			break;
		case Code.Ble:
			instruction.OpCode = OpCodes.Ble_S;
			break;
		case Code.Blt:
			instruction.OpCode = OpCodes.Blt_S;
			break;
		case Code.Bne_Un:
			instruction.OpCode = OpCodes.Bne_Un_S;
			break;
		case Code.Bge_Un:
			instruction.OpCode = OpCodes.Bge_Un_S;
			break;
		case Code.Bgt_Un:
			instruction.OpCode = OpCodes.Bgt_Un_S;
			break;
		case Code.Ble_Un:
			instruction.OpCode = OpCodes.Ble_Un_S;
			break;
		case Code.Blt_Un:
			instruction.OpCode = OpCodes.Blt_Un_S;
			break;
		case Code.Leave:
			instruction.OpCode = OpCodes.Leave_S;
			break;
		}
		return true;
	}

	private static void ComputeOffsets(MethodBody body)
	{
		int num = 0;
		foreach (Instruction instruction in body.Instructions)
		{
			instruction.Offset = num;
			num += instruction.GetSize();
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Cil;

public interface IILVisitor
{
	void OnInlineNone(OpCode opcode);

	void OnInlineSByte(OpCode opcode, sbyte value);

	void OnInlineByte(OpCode opcode, byte value);

	void OnInlineInt32(OpCode opcode, int value);

	void OnInlineInt64(OpCode opcode, long value);

	void OnInlineSingle(OpCode opcode, float value);

	void OnInlineDouble(OpCode opcode, double value);

	void OnInlineString(OpCode opcode, string value);

	void OnInlineBranch(OpCode opcode, int offset);

	void OnInlineSwitch(OpCode opcode, int[] offsets);

	void OnInlineVariable(OpCode opcode, VariableDefinition variable);

	void OnInlineArgument(OpCode opcode, ParameterDefinition parameter);

	void OnInlineSignature(OpCode opcode, CallSite callSite);

	void OnInlineType(OpCode opcode, TypeReference type);

	void OnInlineField(OpCode opcode, FieldReference field);

	void OnInlineMethod(OpCode opcode, MethodReference method);
}


using System;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Rocks;
using Mono.Collections.Generic;

public static class ILParser
{
	private class ParseContext
	{
		public CodeReader Code { get; set; }

		public MetadataReader Metadata { get; set; }

		public Collection<VariableDefinition> Variables { get; set; }

		public IILVisitor Visitor { get; set; }
	}

	public static void Parse(MethodDefinition method, IILVisitor visitor)
	{
		if (method == null)
		{
			throw new ArgumentNullException("method");
		}
		if (visitor == null)
		{
			throw new ArgumentNullException("visitor");
		}
		if (!method.HasBody || !method.HasImage)
		{
			throw new ArgumentException();
		}
		ParseContext parseContext = CreateContext(method, visitor);
		CodeReader code = parseContext.Code;
		code.MoveTo(method.RVA);
		byte b = code.ReadByte();
		switch (b & 3)
		{
		case 2:
			ParseCode(b >> 2, parseContext);
			break;
		case 3:
			code.position--;
			ParseFatMethod(parseContext);
			break;
		default:
			throw new NotSupportedException();
		}
	}

	private static ParseContext CreateContext(MethodDefinition method, IILVisitor visitor)
	{
		CodeReader codeReader = method.Module.Read(method, (MethodDefinition _, MetadataReader reader) => new CodeReader(reader.image.MetadataSection, reader));
		return new ParseContext
		{
			Code = codeReader,
			Metadata = codeReader.reader,
			Visitor = visitor
		};
	}

	private static void ParseFatMethod(ParseContext context)
	{
		CodeReader code = context.Code;
		code.Advance(4);
		int code_size = code.ReadInt32();
		MetadataToken metadataToken = code.ReadToken();
		if (metadataToken != MetadataToken.Zero)
		{
			context.Variables = code.ReadVariables(metadataToken);
		}
		ParseCode(code_size, context);
	}

	private static void ParseCode(int code_size, ParseContext context)
	{
		CodeReader code = context.Code;
		MetadataReader metadata = context.Metadata;
		IILVisitor visitor = context.Visitor;
		int num = code.position + code_size;
		while (code.position < num)
		{
			byte b = code.ReadByte();
			OpCode opCode = ((b != 254) ? OpCodes.OneByteOpCode[b] : OpCodes.TwoBytesOpCode[code.ReadByte()]);
			switch (opCode.OperandType)
			{
			case OperandType.InlineNone:
				visitor.OnInlineNone(opCode);
				break;
			case OperandType.InlineSwitch:
			{
				int num2 = code.ReadInt32();
				int[] array = new int[num2];
				for (int i = 0; i < num2; i++)
				{
					array[i] = code.ReadInt32();
				}
				visitor.OnInlineSwitch(opCode, array);
				break;
			}
			case OperandType.ShortInlineBrTarget:
				visitor.OnInlineBranch(opCode, code.ReadSByte());
				break;
			case OperandType.InlineBrTarget:
				visitor.OnInlineBranch(opCode, code.ReadInt32());
				break;
			case OperandType.ShortInlineI:
				if (opCode == OpCodes.Ldc_I4_S)
				{
					visitor.OnInlineSByte(opCode, code.ReadSByte());
				}
				else
				{
					visitor.OnInlineByte(opCode, code.ReadByte());
				}
				break;
			case OperandType.InlineI:
				visitor.OnInlineInt32(opCode, code.ReadInt32());
				break;
			case OperandType.InlineI8:
				visitor.OnInlineInt64(opCode, code.ReadInt64());
				break;
			case OperandType.ShortInlineR:
				visitor.OnInlineSingle(opCode, code.ReadSingle());
				break;
			case OperandType.InlineR:
				visitor.OnInlineDouble(opCode, code.ReadDouble());
				break;
			case OperandType.InlineSig:
				visitor.OnInlineSignature(opCode, code.GetCallSite(code.ReadToken()));
				break;
			case OperandType.InlineString:
				visitor.OnInlineString(opCode, code.GetString(code.ReadToken()));
				break;
			case OperandType.ShortInlineArg:
				visitor.OnInlineArgument(opCode, code.GetParameter(code.ReadByte()));
				break;
			case OperandType.InlineArg:
				visitor.OnInlineArgument(opCode, code.GetParameter(code.ReadInt16()));
				break;
			case OperandType.ShortInlineVar:
				visitor.OnInlineVariable(opCode, GetVariable(context, code.ReadByte()));
				break;
			case OperandType.InlineVar:
				visitor.OnInlineVariable(opCode, GetVariable(context, code.ReadInt16()));
				break;
			case OperandType.InlineField:
			case OperandType.InlineMethod:
			case OperandType.InlineTok:
			case OperandType.InlineType:
			{
				IMetadataTokenProvider metadataTokenProvider = metadata.LookupToken(code.ReadToken());
				switch (metadataTokenProvider.MetadataToken.TokenType)
				{
				case TokenType.TypeRef:
				case TokenType.TypeDef:
				case TokenType.TypeSpec:
					visitor.OnInlineType(opCode, (TypeReference)metadataTokenProvider);
					break;
				case TokenType.Method:
				case TokenType.MethodSpec:
					visitor.OnInlineMethod(opCode, (MethodReference)metadataTokenProvider);
					break;
				case TokenType.Field:
					visitor.OnInlineField(opCode, (FieldReference)metadataTokenProvider);
					break;
				case TokenType.MemberRef:
					if (metadataTokenProvider is FieldReference field)
					{
						visitor.OnInlineField(opCode, field);
						break;
					}
					if (metadataTokenProvider is MethodReference method)
					{
						visitor.OnInlineMethod(opCode, method);
						break;
					}
					throw new InvalidOperationException();
				}
				break;
			}
			}
		}
	}

	private static VariableDefinition GetVariable(ParseContext context, int index)
	{
		return context.Variables[index];
	}
}


using Mono.Cecil.Cil;
using Mono.Collections.Generic;

private class ParseContext
{
	public CodeReader Code { get; set; }

	public MetadataReader Metadata { get; set; }

	public Collection<VariableDefinition> Variables { get; set; }

	public IILVisitor Visitor { get; set; }
}


using System;
using Mono.Cecil;

public static class TypeReferenceRocks
{
	public static ArrayType MakeArrayType(this TypeReference self)
	{
		return new ArrayType(self);
	}

	public static ArrayType MakeArrayType(this TypeReference self, int rank)
	{
		if (rank == 0)
		{
			throw new ArgumentOutOfRangeException("rank");
		}
		ArrayType arrayType = new ArrayType(self);
		for (int i = 1; i < rank; i++)
		{
			arrayType.Dimensions.Add(default(ArrayDimension));
		}
		return arrayType;
	}

	public static PointerType MakePointerType(this TypeReference self)
	{
		return new PointerType(self);
	}

	public static ByReferenceType MakeByReferenceType(this TypeReference self)
	{
		return new ByReferenceType(self);
	}

	public static OptionalModifierType MakeOptionalModifierType(this TypeReference self, TypeReference modifierType)
	{
		return new OptionalModifierType(modifierType, self);
	}

	public static RequiredModifierType MakeRequiredModifierType(this TypeReference self, TypeReference modifierType)
	{
		return new RequiredModifierType(modifierType, self);
	}

	public static GenericInstanceType MakeGenericInstanceType(this TypeReference self, params TypeReference[] arguments)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		if (arguments == null)
		{
			throw new ArgumentNullException("arguments");
		}
		if (arguments.Length == 0)
		{
			throw new ArgumentException();
		}
		if (self.GenericParameters.Count != arguments.Length)
		{
			throw new ArgumentException();
		}
		GenericInstanceType genericInstanceType = new GenericInstanceType(self);
		foreach (TypeReference item in arguments)
		{
			genericInstanceType.GenericArguments.Add(item);
		}
		return genericInstanceType;
	}

	public static PinnedType MakePinnedType(this TypeReference self)
	{
		return new PinnedType(self);
	}

	public static SentinelType MakeSentinelType(this TypeReference self)
	{
		return new SentinelType(self);
	}
}


using System;
using System.Collections.Generic;

internal static class Functional
{
	public static Func<A, R> Y<A, R>(Func<Func<A, R>, Func<A, R>> f)
	{
		Func<A, R> g = null;
		g = f((A a) => g(a));
		return g;
	}

	public static IEnumerable<TSource> Prepend<TSource>(this IEnumerable<TSource> source, TSource element)
	{
		if (source == null)
		{
			throw new ArgumentNullException("source");
		}
		return PrependIterator(source, element);
	}

	private static IEnumerable<TSource> PrependIterator<TSource>(IEnumerable<TSource> source, TSource element)
	{
		yield return element;
		foreach (TSource item in source)
		{
			yield return item;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Mono.Cecil;
using Mono.Cecil.Rocks;

public static class ModuleDefinitionRocks
{
	public static IEnumerable<TypeDefinition> GetAllTypes(this ModuleDefinition self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		return self.Types.SelectMany(Functional.Y((Func<TypeDefinition, IEnumerable<TypeDefinition>> f) => (TypeDefinition type) => Functional.Prepend(type.NestedTypes.SelectMany(f), type)));
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Mono;
using Mono.Cecil;

public static class TypeDefinitionRocks
{
	public static IEnumerable<MethodDefinition> GetConstructors(this TypeDefinition self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		if (!self.HasMethods)
		{
			return Empty<MethodDefinition>.Array;
		}
		return self.Methods.Where((MethodDefinition method) => method.IsConstructor);
	}

	public static MethodDefinition GetStaticConstructor(this TypeDefinition self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		if (!self.HasMethods)
		{
			return null;
		}
		return GetConstructors(self).FirstOrDefault((MethodDefinition ctor) => ctor.IsStatic);
	}

	public static IEnumerable<MethodDefinition> GetMethods(this TypeDefinition self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		if (!self.HasMethods)
		{
			return Empty<MethodDefinition>.Array;
		}
		return self.Methods.Where((MethodDefinition method) => !method.IsConstructor);
	}

	public static TypeReference GetEnumUnderlyingType(this TypeDefinition self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		if (!self.IsEnum)
		{
			throw new ArgumentException();
		}
		return self.GetEnumUnderlyingType();
	}
}


using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.IO.Compression;
using System.Net;
using System.Net.Sockets;
using System.Text;
using WebSocketSharp;
using WebSocketSharp.Net;
using WebSocketSharp.Net.WebSockets;
using WebSocketSharp.Server;

public static class Ext
{
	private static readonly byte[] _last = new byte[1];

	private static readonly int _retry = 5;

	private const string _tspecials = "()<>@,;:\\\"/[]?={} \t";

	private static byte[] compress(this byte[] data)
	{
		if (data.LongLength == 0)
		{
			return data;
		}
		using MemoryStream stream = new MemoryStream(data);
		return stream.compressToArray();
	}

	private static MemoryStream compress(this Stream stream)
	{
		MemoryStream memoryStream = new MemoryStream();
		if (stream.Length == 0)
		{
			return memoryStream;
		}
		stream.Position = 0L;
		using DeflateStream deflateStream = new DeflateStream(memoryStream, CompressionMode.Compress, leaveOpen: true);
		CopyTo(stream, deflateStream, 1024);
		deflateStream.Close();
		memoryStream.Write(_last, 0, 1);
		memoryStream.Position = 0L;
		return memoryStream;
	}

	private static byte[] compressToArray(this Stream stream)
	{
		using MemoryStream memoryStream = stream.compress();
		memoryStream.Close();
		return memoryStream.ToArray();
	}

	private static byte[] decompress(this byte[] data)
	{
		if (data.LongLength == 0)
		{
			return data;
		}
		using MemoryStream stream = new MemoryStream(data);
		return stream.decompressToArray();
	}

	private static MemoryStream decompress(this Stream stream)
	{
		MemoryStream memoryStream = new MemoryStream();
		if (stream.Length == 0)
		{
			return memoryStream;
		}
		stream.Position = 0L;
		using DeflateStream source = new DeflateStream(stream, CompressionMode.Decompress, leaveOpen: true);
		CopyTo(source, memoryStream, 1024);
		memoryStream.Position = 0L;
		return memoryStream;
	}

	private static byte[] decompressToArray(this Stream stream)
	{
		using MemoryStream memoryStream = stream.decompress();
		memoryStream.Close();
		return memoryStream.ToArray();
	}

	private static void times(this ulong n, Action action)
	{
		for (ulong num = 0uL; num < n; num++)
		{
			action();
		}
	}

	internal static byte[] Append(this ushort code, string reason)
	{
		byte[] array = code.InternalToByteArray(ByteOrder.Big);
		if (reason != null && reason.Length > 0)
		{
			List<byte> list = new List<byte>(array);
			list.AddRange(Encoding.UTF8.GetBytes(reason));
			array = list.ToArray();
		}
		return array;
	}

	internal static string CheckIfAvailable(this ServerState state, bool ready, bool start, bool shutting)
	{
		return ((!ready && (state == ServerState.Ready || state == ServerState.Stop)) || (!start && state == ServerState.Start) || (!shutting && state == ServerState.ShuttingDown)) ? ("This operation isn't available in: " + state.ToString().ToLower()) : null;
	}

	internal static string CheckIfAvailable(this WebSocketState state, bool connecting, bool open, bool closing, bool closed)
	{
		return ((!connecting && state == WebSocketState.Connecting) || (!open && state == WebSocketState.Open) || (!closing && state == WebSocketState.Closing) || (!closed && state == WebSocketState.Closed)) ? ("This operation isn't available in: " + state.ToString().ToLower()) : null;
	}

	internal static string CheckIfValidProtocols(this string[] protocols)
	{
		return protocols.Contains((string protocol) => protocol == null || protocol.Length == 0 || !protocol.IsToken()) ? "Contains an invalid value." : (protocols.ContainsTwice() ? "Contains a value twice." : null);
	}

	internal static string CheckIfValidServicePath(this string path)
	{
		return (path == null || path.Length == 0) ? "'path' is null or empty." : ((path[0] != '/') ? "'path' isn't an absolute path." : ((path.IndexOfAny(new char[2] { '?', '#' }) > -1) ? "'path' includes either or both query and fragment components." : null));
	}

	internal static string CheckIfValidSessionID(this string id)
	{
		return (id == null || id.Length == 0) ? "'id' is null or empty." : null;
	}

	internal static string CheckIfValidWaitTime(this TimeSpan time)
	{
		return (time <= TimeSpan.Zero) ? "A wait time is zero or less." : null;
	}

	internal static bool CheckWaitTime(this TimeSpan time, out string message)
	{
		message = null;
		if (time <= TimeSpan.Zero)
		{
			message = "A wait time is zero or less.";
			return false;
		}
		return true;
	}

	internal static void Close(this WebSocketSharp.Net.HttpListenerResponse response, WebSocketSharp.Net.HttpStatusCode code)
	{
		response.StatusCode = (int)code;
		response.OutputStream.Close();
	}

	internal static void CloseWithAuthChallenge(this WebSocketSharp.Net.HttpListenerResponse response, string challenge)
	{
		response.Headers.InternalSet("WWW-Authenticate", challenge, response: true);
		response.Close(WebSocketSharp.Net.HttpStatusCode.Unauthorized);
	}

	internal static byte[] Compress(this byte[] data, CompressionMethod method)
	{
		return (method == CompressionMethod.Deflate) ? data.compress() : data;
	}

	internal static Stream Compress(this Stream stream, CompressionMethod method)
	{
		return (method == CompressionMethod.Deflate) ? stream.compress() : stream;
	}

	internal static byte[] CompressToArray(this Stream stream, CompressionMethod method)
	{
		return (method == CompressionMethod.Deflate) ? stream.compressToArray() : stream.ToByteArray();
	}

	internal static bool Contains<T>(this IEnumerable<T> source, Func<T, bool> condition)
	{
		foreach (T item in source)
		{
			if (condition(item))
			{
				return true;
			}
		}
		return false;
	}

	internal static bool ContainsTwice(this string[] values)
	{
		int len = values.Length;
		Func<int, bool> contains = null;
		contains = delegate(int idx)
		{
			if (idx < len - 1)
			{
				for (int i = idx + 1; i < len; i++)
				{
					if (values[i] == values[idx])
					{
						return true;
					}
				}
				return contains(++idx);
			}
			return false;
		};
		return contains(0);
	}

	internal static T[] Copy<T>(this T[] source, long length)
	{
		T[] array = new T[length];
		Array.Copy(source, 0L, array, 0L, length);
		return array;
	}

	internal static void CopyTo(this Stream source, Stream destination, int bufferLength)
	{
		byte[] buffer = new byte[bufferLength];
		int num = 0;
		while ((num = source.Read(buffer, 0, bufferLength)) > 0)
		{
			destination.Write(buffer, 0, num);
		}
	}

	internal static void CopyToAsync(this Stream source, Stream destination, int bufferLength, Action completed, Action<Exception> error)
	{
		byte[] buff = new byte[bufferLength];
		AsyncCallback callback = null;
		callback = delegate(IAsyncResult ar)
		{
			try
			{
				int num = source.EndRead(ar);
				if (num <= 0)
				{
					if (completed != null)
					{
						completed();
					}
				}
				else
				{
					destination.Write(buff, 0, num);
					source.BeginRead(buff, 0, bufferLength, callback, null);
				}
			}
			catch (Exception obj)
			{
				if (error != null)
				{
					error(obj);
				}
			}
		};
		try
		{
			source.BeginRead(buff, 0, bufferLength, callback, null);
		}
		catch (Exception obj2)
		{
			if (error != null)
			{
				error(obj2);
			}
		}
	}

	internal static byte[] Decompress(this byte[] data, CompressionMethod method)
	{
		return (method == CompressionMethod.Deflate) ? data.decompress() : data;
	}

	internal static Stream Decompress(this Stream stream, CompressionMethod method)
	{
		return (method == CompressionMethod.Deflate) ? stream.decompress() : stream;
	}

	internal static byte[] DecompressToArray(this Stream stream, CompressionMethod method)
	{
		return (method == CompressionMethod.Deflate) ? stream.decompressToArray() : stream.ToByteArray();
	}

	internal static bool EqualsWith(this int value, char c, Action<int> action)
	{
		action(value);
		return value == c;
	}

	internal static string GetAbsolutePath(this Uri uri)
	{
		if (uri.IsAbsoluteUri)
		{
			return uri.AbsolutePath;
		}
		string originalString = uri.OriginalString;
		if (originalString[0] != '/')
		{
			return null;
		}
		int num = originalString.IndexOfAny(new char[2] { '?', '#' });
		return (num > 0) ? originalString.Substring(0, num) : originalString;
	}

	internal static string GetMessage(this CloseStatusCode code)
	{
		return code switch
		{
			CloseStatusCode.TlsHandshakeFailure => "An error has occurred during a TLS handshake.", 
			CloseStatusCode.ServerError => "WebSocket server got an internal error.", 
			CloseStatusCode.MandatoryExtension => "WebSocket client didn't receive expected extension(s).", 
			CloseStatusCode.TooBig => "A too big message has been received.", 
			CloseStatusCode.PolicyViolation => "A policy violation has occurred.", 
			CloseStatusCode.InvalidData => "Invalid data has been received.", 
			CloseStatusCode.Abnormal => "An exception has occurred.", 
			CloseStatusCode.UnsupportedData => "Unsupported data has been received.", 
			CloseStatusCode.ProtocolError => "A WebSocket protocol error has occurred.", 
			_ => string.Empty, 
		};
	}

	internal static string GetName(this string nameAndValue, char separator)
	{
		int num = nameAndValue.IndexOf(separator);
		return (num > 0) ? nameAndValue.Substring(0, num).Trim() : null;
	}

	internal static string GetValue(this string nameAndValue, char separator)
	{
		int num = nameAndValue.IndexOf(separator);
		return (num > -1 && num < nameAndValue.Length - 1) ? nameAndValue.Substring(num + 1).Trim() : null;
	}

	internal static string GetValue(this string nameAndValue, char separator, bool unquote)
	{
		int num = nameAndValue.IndexOf(separator);
		if (num < 0 || num == nameAndValue.Length - 1)
		{
			return null;
		}
		string text = nameAndValue.Substring(num + 1).Trim();
		return unquote ? text.Unquote() : text;
	}

	internal static TcpListenerWebSocketContext GetWebSocketContext(this TcpClient tcpClient, string protocol, bool secure, ServerSslConfiguration sslConfig, Logger logger)
	{
		return new TcpListenerWebSocketContext(tcpClient, protocol, secure, sslConfig, logger);
	}

	internal static byte[] InternalToByteArray(this ushort value, ByteOrder order)
	{
		byte[] bytes = BitConverter.GetBytes(value);
		if (!order.IsHostOrder())
		{
			Array.Reverse((Array)bytes);
		}
		return bytes;
	}

	internal static byte[] InternalToByteArray(this ulong value, ByteOrder order)
	{
		byte[] bytes = BitConverter.GetBytes(value);
		if (!order.IsHostOrder())
		{
			Array.Reverse((Array)bytes);
		}
		return bytes;
	}

	internal static bool IsCompressionExtension(this string value, CompressionMethod method)
	{
		return value.StartsWith(method.ToExtensionString());
	}

	internal static bool IsControl(this byte opcode)
	{
		return opcode > 7 && opcode < 16;
	}

	internal static bool IsControl(this Opcode opcode)
	{
		return (int)opcode >= 8;
	}

	internal static bool IsData(this byte opcode)
	{
		return opcode == 1 || opcode == 2;
	}

	internal static bool IsData(this Opcode opcode)
	{
		return opcode == Opcode.Text || opcode == Opcode.Binary;
	}

	internal static bool IsPortNumber(this int value)
	{
		return value > 0 && value < 65536;
	}

	internal static bool IsReserved(this ushort code)
	{
		return code == 1004 || code == 1005 || code == 1006 || code == 1015;
	}

	internal static bool IsReserved(this CloseStatusCode code)
	{
		return code == CloseStatusCode.Undefined || code == CloseStatusCode.NoStatus || code == CloseStatusCode.Abnormal || code == CloseStatusCode.TlsHandshakeFailure;
	}

	internal static bool IsSupported(this byte opcode)
	{
		return Enum.IsDefined(typeof(Opcode), opcode);
	}

	internal static bool IsText(this string value)
	{
		int length = value.Length;
		for (int i = 0; i < length; i++)
		{
			char c = value[i];
			if (c < ' ' && !Contains("\r\n\t", c))
			{
				return false;
			}
			switch (c)
			{
			case '\u007f':
				return false;
			case '\n':
				if (++i < length)
				{
					c = value[i];
					if (!Contains(" \t", c))
					{
						return false;
					}
				}
				break;
			}
		}
		return true;
	}

	internal static bool IsToken(this string value)
	{
		foreach (char c in value)
		{
			if (c < ' ' || c >= '\u007f' || Contains("()<>@,;:\\\"/[]?={} \t", c))
			{
				return false;
			}
		}
		return true;
	}

	internal static string Quote(this string value)
	{
		return string.Format("\"{0}\"", value.Replace("\"", "\\\""));
	}

	internal static byte[] ReadBytes(this Stream stream, int length)
	{
		byte[] array = new byte[length];
		int num = 0;
		try
		{
			int num2 = 0;
			while (length > 0)
			{
				num2 = stream.Read(array, num, length);
				if (num2 == 0)
				{
					break;
				}
				num += num2;
				length -= num2;
			}
		}
		catch
		{
		}
		return array.SubArray(0, num);
	}

	internal static byte[] ReadBytes(this Stream stream, long length, int bufferLength)
	{
		using MemoryStream memoryStream = new MemoryStream();
		try
		{
			byte[] buffer = new byte[bufferLength];
			int num = 0;
			while (length > 0)
			{
				if (length < bufferLength)
				{
					bufferLength = (int)length;
				}
				num = stream.Read(buffer, 0, bufferLength);
				if (num == 0)
				{
					break;
				}
				memoryStream.Write(buffer, 0, num);
				length -= num;
			}
		}
		catch
		{
		}
		memoryStream.Close();
		return memoryStream.ToArray();
	}

	internal static void ReadBytesAsync(this Stream stream, int length, Action<byte[]> completed, Action<Exception> error)
	{
		byte[] buff = new byte[length];
		int offset = 0;
		int retry = 0;
		AsyncCallback callback = null;
		callback = delegate(IAsyncResult ar)
		{
			try
			{
				int num = stream.EndRead(ar);
				if (num == 0 && retry < _retry)
				{
					retry++;
					stream.BeginRead(buff, offset, length, callback, null);
				}
				else if (num == 0 || num == length)
				{
					if (completed != null)
					{
						completed(buff.SubArray(0, offset + num));
					}
				}
				else
				{
					retry = 0;
					offset += num;
					length -= num;
					stream.BeginRead(buff, offset, length, callback, null);
				}
			}
			catch (Exception obj)
			{
				if (error != null)
				{
					error(obj);
				}
			}
		};
		try
		{
			stream.BeginRead(buff, offset, length, callback, null);
		}
		catch (Exception obj2)
		{
			if (error != null)
			{
				error(obj2);
			}
		}
	}

	internal static void ReadBytesAsync(this Stream stream, long length, int bufferLength, Action<byte[]> completed, Action<Exception> error)
	{
		MemoryStream dest = new MemoryStream();
		byte[] buff = new byte[bufferLength];
		int retry = 0;
		Action<long> read = null;
		read = delegate(long len)
		{
			if (len < bufferLength)
			{
				bufferLength = (int)len;
			}
			stream.BeginRead(buff, 0, bufferLength, delegate(IAsyncResult ar)
			{
				try
				{
					int num = stream.EndRead(ar);
					if (num > 0)
					{
						dest.Write(buff, 0, num);
					}
					if (num == 0 && retry < _retry)
					{
						int num2 = retry;
						retry = num2 + 1;
						read(len);
					}
					else if (num == 0 || num == len)
					{
						if (completed != null)
						{
							dest.Close();
							completed(dest.ToArray());
						}
						dest.Dispose();
					}
					else
					{
						retry = 0;
						read(len - num);
					}
				}
				catch (Exception obj)
				{
					dest.Dispose();
					if (error != null)
					{
						error(obj);
					}
				}
			}, null);
		};
		try
		{
			read(length);
		}
		catch (Exception obj2)
		{
			dest.Dispose();
			if (error != null)
			{
				error(obj2);
			}
		}
	}

	internal static string RemovePrefix(this string value, params string[] prefixes)
	{
		int num = 0;
		foreach (string text in prefixes)
		{
			if (value.StartsWith(text))
			{
				num = text.Length;
				break;
			}
		}
		return (num > 0) ? value.Substring(num) : value;
	}

	internal static T[] Reverse<T>(this T[] array)
	{
		int num = array.Length;
		T[] array2 = new T[num];
		int num2 = num - 1;
		for (int i = 0; i <= num2; i++)
		{
			array2[i] = array[num2 - i];
		}
		return array2;
	}

	internal static IEnumerable<string> SplitHeaderValue(this string value, params char[] separators)
	{
		int len = value.Length;
		string seps = new string(separators);
		StringBuilder buff = new StringBuilder(32);
		bool escaped = false;
		bool quoted = false;
		for (int i = 0; i < len; i++)
		{
			char c = value[i];
			switch (c)
			{
			case '"':
				if (escaped)
				{
					escaped = !escaped;
				}
				else
				{
					quoted = !quoted;
				}
				break;
			case '\\':
				if (i < len - 1 && value[i + 1] == '"')
				{
					escaped = true;
				}
				break;
			default:
				if (Contains(seps, c) && !quoted)
				{
					yield return buff.ToString();
					buff.Length = 0;
					continue;
				}
				break;
			}
			buff.Append(c);
		}
		if (buff.Length > 0)
		{
			yield return buff.ToString();
		}
	}

	internal static byte[] ToByteArray(this Stream stream)
	{
		using MemoryStream memoryStream = new MemoryStream();
		stream.Position = 0L;
		CopyTo(stream, memoryStream, 1024);
		memoryStream.Close();
		return memoryStream.ToArray();
	}

	internal static CompressionMethod ToCompressionMethod(this string value)
	{
		foreach (CompressionMethod value2 in Enum.GetValues(typeof(CompressionMethod)))
		{
			if (value2.ToExtensionString() == value)
			{
				return value2;
			}
		}
		return CompressionMethod.None;
	}

	internal static string ToExtensionString(this CompressionMethod method, params string[] parameters)
	{
		if (method == CompressionMethod.None)
		{
			return string.Empty;
		}
		string text = $"permessage-{method.ToString().ToLower()}";
		if (parameters == null || parameters.Length == 0)
		{
			return text;
		}
		return string.Format("{0}; {1}", text, parameters.ToString("; "));
	}

	internal static IPAddress ToIPAddress(this string hostnameOrAddress)
	{
		if (IPAddress.TryParse(hostnameOrAddress, out IPAddress address))
		{
			return address;
		}
		try
		{
			return Dns.GetHostAddresses(hostnameOrAddress)[0];
		}
		catch
		{
			return null;
		}
	}

	internal static List<TSource> ToList<TSource>(this IEnumerable<TSource> source)
	{
		return new List<TSource>(source);
	}

	internal static ushort ToUInt16(this byte[] source, ByteOrder sourceOrder)
	{
		return BitConverter.ToUInt16(source.ToHostOrder(sourceOrder), 0);
	}

	internal static ulong ToUInt64(this byte[] source, ByteOrder sourceOrder)
	{
		return BitConverter.ToUInt64(source.ToHostOrder(sourceOrder), 0);
	}

	internal static string TrimEndSlash(this string value)
	{
		value = value.TrimEnd(new char[1] { '/' });
		return (value.Length > 0) ? value : "/";
	}

	internal static bool TryCreateWebSocketUri(this string uriString, out Uri result, out string message)
	{
		result = null;
		Uri uri = uriString.ToUri();
		if (uri == null)
		{
			message = "An invalid URI string: " + uriString;
			return false;
		}
		if (!uri.IsAbsoluteUri)
		{
			message = "Not an absolute URI: " + uriString;
			return false;
		}
		string scheme = uri.Scheme;
		if (!(scheme == "ws") && !(scheme == "wss"))
		{
			message = "The scheme part isn't 'ws' or 'wss': " + uriString;
			return false;
		}
		if (uri.Fragment.Length > 0)
		{
			message = "Includes the fragment component: " + uriString;
			return false;
		}
		int port = uri.Port;
		if (port == 0)
		{
			message = "The port part is zero: " + uriString;
			return false;
		}
		result = ((port != -1) ? uri : new Uri(string.Format("{0}://{1}:{2}{3}", scheme, uri.Host, (scheme == "ws") ? 80 : 443, uri.PathAndQuery)));
		message = string.Empty;
		return true;
	}

	internal static string Unquote(this string value)
	{
		int num = value.IndexOf('"');
		if (num < 0)
		{
			return value;
		}
		int num2 = value.LastIndexOf('"');
		int num3 = num2 - num - 1;
		return (num3 < 0) ? value : ((num3 == 0) ? string.Empty : value.Substring(num + 1, num3).Replace("\\\"", "\""));
	}

	internal static string UTF8Decode(this byte[] bytes)
	{
		try
		{
			return Encoding.UTF8.GetString(bytes);
		}
		catch
		{
			return null;
		}
	}

	internal static byte[] UTF8Encode(this string s)
	{
		return Encoding.UTF8.GetBytes(s);
	}

	internal static void WriteBytes(this Stream stream, byte[] bytes, int bufferLength)
	{
		using MemoryStream source = new MemoryStream(bytes);
		CopyTo(source, stream, bufferLength);
	}

	internal static void WriteBytesAsync(this Stream stream, byte[] bytes, int bufferLength, Action completed, Action<Exception> error)
	{
		MemoryStream input = new MemoryStream(bytes);
		input.CopyToAsync(stream, bufferLength, delegate
		{
			if (completed != null)
			{
				completed();
			}
			input.Dispose();
		}, delegate(Exception ex)
		{
			input.Dispose();
			if (error != null)
			{
				error(ex);
			}
		});
	}

	public static bool Contains(this string value, params char[] chars)
	{
		return chars == null || chars.Length == 0 || (value != null && value.Length != 0 && value.IndexOfAny(chars) > -1);
	}

	public static bool Contains(this NameValueCollection collection, string name)
	{
		return collection != null && collection.Count > 0 && collection[name] != null;
	}

	public static bool Contains(this NameValueCollection collection, string name, string value)
	{
		if (collection == null || collection.Count == 0)
		{
			return false;
		}
		string text = collection[name];
		if (text == null)
		{
			return false;
		}
		string[] array = text.Split(new char[1] { ',' });
		foreach (string text2 in array)
		{
			if (text2.Trim().Equals(value, StringComparison.OrdinalIgnoreCase))
			{
				return true;
			}
		}
		return false;
	}

	public static void Emit(this EventHandler eventHandler, object sender, EventArgs e)
	{
		eventHandler?.Invoke(sender, e);
	}

	public static void Emit<TEventArgs>(this EventHandler<TEventArgs> eventHandler, object sender, TEventArgs e) where TEventArgs : EventArgs
	{
		eventHandler?.Invoke(sender, e);
	}

	public static WebSocketSharp.Net.CookieCollection GetCookies(this NameValueCollection headers, bool response)
	{
		string name = (response ? "Set-Cookie" : "Cookie");
		return (headers != null && headers.Contains(name)) ? WebSocketSharp.Net.CookieCollection.Parse(headers[name], response) : new WebSocketSharp.Net.CookieCollection();
	}

	public static string GetDescription(this WebSocketSharp.Net.HttpStatusCode code)
	{
		return ((int)code).GetStatusDescription();
	}

	public static string GetStatusDescription(this int code)
	{
		return code switch
		{
			100 => "Continue", 
			101 => "Switching Protocols", 
			102 => "Processing", 
			200 => "OK", 
			201 => "Created", 
			202 => "Accepted", 
			203 => "Non-Authoritative Information", 
			204 => "No Content", 
			205 => "Reset Content", 
			206 => "Partial Content", 
			207 => "Multi-Status", 
			300 => "Multiple Choices", 
			301 => "Moved Permanently", 
			302 => "Found", 
			303 => "See Other", 
			304 => "Not Modified", 
			305 => "Use Proxy", 
			307 => "Temporary Redirect", 
			400 => "Bad Request", 
			401 => "Unauthorized", 
			402 => "Payment Required", 
			403 => "Forbidden", 
			404 => "Not Found", 
			405 => "Method Not Allowed", 
			406 => "Not Acceptable", 
			407 => "Proxy Authentication Required", 
			408 => "Request Timeout", 
			409 => "Conflict", 
			410 => "Gone", 
			411 => "Length Required", 
			412 => "Precondition Failed", 
			413 => "Request Entity Too Large", 
			414 => "Request-Uri Too Long", 
			415 => "Unsupported Media Type", 
			416 => "Requested Range Not Satisfiable", 
			417 => "Expectation Failed", 
			422 => "Unprocessable Entity", 
			423 => "Locked", 
			424 => "Failed Dependency", 
			500 => "Internal Server Error", 
			501 => "Not Implemented", 
			502 => "Bad Gateway", 
			503 => "Service Unavailable", 
			504 => "Gateway Timeout", 
			505 => "Http Version Not Supported", 
			507 => "Insufficient Storage", 
			_ => string.Empty, 
		};
	}

	public static bool IsCloseStatusCode(this ushort value)
	{
		return value > 999 && value < 5000;
	}

	public static bool IsEnclosedIn(this string value, char c)
	{
		return value != null && value.Length > 1 && value[0] == c && value[value.Length - 1] == c;
	}

	public static bool IsHostOrder(this ByteOrder order)
	{
		return BitConverter.IsLittleEndian == (order == ByteOrder.Little);
	}

	public static bool IsLocal(this IPAddress address)
	{
		if (address == null)
		{
			return false;
		}
		if (address.Equals(IPAddress.Any))
		{
			return true;
		}
		if (address.Equals(IPAddress.Loopback))
		{
			return true;
		}
		if (Socket.OSSupportsIPv6)
		{
			if (address.Equals(IPAddress.IPv6Any))
			{
				return true;
			}
			if (address.Equals(IPAddress.IPv6Loopback))
			{
				return true;
			}
		}
		string hostName = Dns.GetHostName();
		IPAddress[] hostAddresses = Dns.GetHostAddresses(hostName);
		IPAddress[] array = hostAddresses;
		foreach (IPAddress obj in array)
		{
			if (address.Equals(obj))
			{
				return true;
			}
		}
		return false;
	}

	public static bool IsNullOrEmpty(this string value)
	{
		return value == null || value.Length == 0;
	}

	public static bool IsPredefinedScheme(this string value)
	{
		if (value == null || value.Length < 2)
		{
			return false;
		}
		char c = value[0];
		if (c == 'h')
		{
			return value == "http" || value == "https";
		}
		if (c == 'w')
		{
			return value == "ws" || value == "wss";
		}
		if (c == 'f')
		{
			return value == "file" || value == "ftp";
		}
		if (c == 'n')
		{
			c = value[1];
			return (c != 'e') ? (value == "nntp") : (value == "news" || value == "net.pipe" || value == "net.tcp");
		}
		return (c == 'g' && value == "gopher") || (c == 'm' && value == "mailto");
	}

	public static bool IsUpgradeTo(this WebSocketSharp.Net.HttpListenerRequest request, string protocol)
	{
		if (request == null)
		{
			throw new ArgumentNullException("request");
		}
		if (protocol == null)
		{
			throw new ArgumentNullException("protocol");
		}
		if (protocol.Length == 0)
		{
			throw new ArgumentException("An empty string.", "protocol");
		}
		return request.Headers.Contains("Upgrade", protocol) && request.Headers.Contains("Connection", "Upgrade");
	}

	public static bool MaybeUri(this string value)
	{
		if (value == null || value.Length == 0)
		{
			return false;
		}
		int num = value.IndexOf(':');
		if (num == -1)
		{
			return false;
		}
		if (num >= 10)
		{
			return false;
		}
		return value.Substring(0, num).IsPredefinedScheme();
	}

	public static T[] SubArray<T>(this T[] array, int startIndex, int length)
	{
		int num;
		if (array == null || (num = array.Length) == 0)
		{
			return new T[0];
		}
		if (startIndex < 0 || length <= 0 || startIndex + length > num)
		{
			return new T[0];
		}
		if (startIndex == 0 && length == num)
		{
			return array;
		}
		T[] array2 = new T[length];
		Array.Copy(array, startIndex, array2, 0, length);
		return array2;
	}

	public static T[] SubArray<T>(this T[] array, long startIndex, long length)
	{
		long num;
		if (array == null || (num = array.LongLength) == 0)
		{
			return new T[0];
		}
		if (startIndex < 0 || length <= 0 || startIndex + length > num)
		{
			return new T[0];
		}
		if (startIndex == 0L && length == num)
		{
			return array;
		}
		T[] array2 = new T[length];
		Array.Copy(array, startIndex, array2, 0L, length);
		return array2;
	}

	public static void Times(this int n, Action action)
	{
		if (n > 0 && action != null)
		{
			((ulong)n).times(action);
		}
	}

	public static void Times(this long n, Action action)
	{
		if (n > 0 && action != null)
		{
			((ulong)n).times(action);
		}
	}

	public static void Times(this uint n, Action action)
	{
		if (n != 0 && action != null)
		{
			times(n, action);
		}
	}

	public static void Times(this ulong n, Action action)
	{
		if (n != 0 && action != null)
		{
			n.times(action);
		}
	}

	public static void Times(this int n, Action<int> action)
	{
		if (n > 0 && action != null)
		{
			for (int i = 0; i < n; i++)
			{
				action(i);
			}
		}
	}

	public static void Times(this long n, Action<long> action)
	{
		if (n > 0 && action != null)
		{
			for (long num = 0L; num < n; num++)
			{
				action(num);
			}
		}
	}

	public static void Times(this uint n, Action<uint> action)
	{
		if (n != 0 && action != null)
		{
			for (uint num = 0u; num < n; num++)
			{
				action(num);
			}
		}
	}

	public static void Times(this ulong n, Action<ulong> action)
	{
		if (n != 0 && action != null)
		{
			for (ulong num = 0uL; num < n; num++)
			{
				action(num);
			}
		}
	}

	public static T To<T>(this byte[] source, ByteOrder sourceOrder) where T : struct
	{
		if (source == null)
		{
			throw new ArgumentNullException("source");
		}
		if (source.Length == 0)
		{
			return default(T);
		}
		Type typeFromHandle = typeof(T);
		byte[] value = source.ToHostOrder(sourceOrder);
		return ((object)typeFromHandle == typeof(bool)) ? ((T)(object)BitConverter.ToBoolean(value, 0)) : (((object)typeFromHandle == typeof(char)) ? ((T)(object)BitConverter.ToChar(value, 0)) : (((object)typeFromHandle == typeof(double)) ? ((T)(object)BitConverter.ToDouble(value, 0)) : (((object)typeFromHandle == typeof(short)) ? ((T)(object)BitConverter.ToInt16(value, 0)) : (((object)typeFromHandle == typeof(int)) ? ((T)(object)BitConverter.ToInt32(value, 0)) : (((object)typeFromHandle == typeof(long)) ? ((T)(object)BitConverter.ToInt64(value, 0)) : (((object)typeFromHandle == typeof(float)) ? ((T)(object)BitConverter.ToSingle(value, 0)) : (((object)typeFromHandle == typeof(ushort)) ? ((T)(object)BitConverter.ToUInt16(value, 0)) : (((object)typeFromHandle == typeof(uint)) ? ((T)(object)BitConverter.ToUInt32(value, 0)) : (((object)typeFromHandle == typeof(ulong)) ? ((T)(object)BitConverter.ToUInt64(value, 0)) : default(T))))))))));
	}

	public static byte[] ToByteArray<T>(this T value, ByteOrder order) where T : struct
	{
		Type typeFromHandle = typeof(T);
		byte[] array = (((object)typeFromHandle == typeof(bool)) ? BitConverter.GetBytes((bool)(object)value) : (((object)typeFromHandle != typeof(byte)) ? (((object)typeFromHandle == typeof(char)) ? BitConverter.GetBytes((char)(object)value) : (((object)typeFromHandle == typeof(double)) ? BitConverter.GetBytes((double)(object)value) : (((object)typeFromHandle == typeof(short)) ? BitConverter.GetBytes((short)(object)value) : (((object)typeFromHandle == typeof(int)) ? BitConverter.GetBytes((int)(object)value) : (((object)typeFromHandle == typeof(long)) ? BitConverter.GetBytes((long)(object)value) : (((object)typeFromHandle == typeof(float)) ? BitConverter.GetBytes((float)(object)value) : (((object)typeFromHandle == typeof(ushort)) ? BitConverter.GetBytes((ushort)(object)value) : (((object)typeFromHandle == typeof(uint)) ? BitConverter.GetBytes((uint)(object)value) : (((object)typeFromHandle == typeof(ulong)) ? BitConverter.GetBytes((ulong)(object)value) : WebSocket.EmptyBytes))))))))) : new byte[1] { (byte)(object)value }));
		if (array.Length > 1 && !order.IsHostOrder())
		{
			Array.Reverse((Array)array);
		}
		return array;
	}

	public static byte[] ToHostOrder(this byte[] source, ByteOrder sourceOrder)
	{
		if (source == null)
		{
			throw new ArgumentNullException("source");
		}
		return (source.Length > 1 && !sourceOrder.IsHostOrder()) ? source.Reverse() : source;
	}

	public static string ToString<T>(this T[] array, string separator)
	{
		if (array == null)
		{
			throw new ArgumentNullException("array");
		}
		int num = array.Length;
		if (num == 0)
		{
			return string.Empty;
		}
		if (separator == null)
		{
			separator = string.Empty;
		}
		StringBuilder buff = new StringBuilder(64);
		(num - 1).Times(delegate(int i)
		{
			buff.AppendFormat("{0}{1}", array[i].ToString(), separator);
		});
		buff.Append(array[num - 1].ToString());
		return buff.ToString();
	}

	public static Uri ToUri(this string uriString)
	{
		Uri.TryCreate(uriString, uriString.MaybeUri() ? UriKind.Absolute : UriKind.Relative, out Uri result);
		return result;
	}

	public static string UrlDecode(this string value)
	{
		return (value != null && value.Length > 0) ? HttpUtility.UrlDecode(value) : value;
	}

	public static string UrlEncode(this string value)
	{
		return (value != null && value.Length > 0) ? HttpUtility.UrlEncode(value) : value;
	}

	public static void WriteContent(this WebSocketSharp.Net.HttpListenerResponse response, byte[] content)
	{
		if (response == null)
		{
			throw new ArgumentNullException("response");
		}
		if (content == null)
		{
			throw new ArgumentNullException("content");
		}
		long num = content.LongLength;
		if (num == 0)
		{
			response.Close();
			return;
		}
		response.ContentLength64 = num;
		Stream outputStream = response.OutputStream;
		if (num <= int.MaxValue)
		{
			outputStream.Write(content, 0, (int)num);
		}
		else
		{
			outputStream.WriteBytes(content, 1024);
		}
		outputStream.Close();
	}
}


using System;
using WebSocketSharp;

public class MessageEventArgs : EventArgs
{
	private string _data;

	private bool _dataSet;

	private Opcode _opcode;

	private byte[] _rawData;

	internal Opcode Opcode => _opcode;

	public string Data
	{
		get
		{
			if (!_dataSet)
			{
				_data = ((_opcode != Opcode.Binary) ? _rawData.UTF8Decode() : BitConverter.ToString(_rawData));
				_dataSet = true;
			}
			return _data;
		}
	}

	public bool IsBinary => _opcode == Opcode.Binary;

	public bool IsPing => _opcode == Opcode.Ping;

	public bool IsText => _opcode == Opcode.Text;

	public bool IsClose => _opcode == Opcode.Close;

	public byte[] RawData => _rawData;

	internal MessageEventArgs(WebSocketFrame frame)
	{
		_opcode = frame.Opcode;
		_rawData = frame.PayloadData.ApplicationData;
	}

	internal MessageEventArgs(Opcode opcode, byte[] rawData)
	{
		if ((ulong)rawData.LongLength > PayloadData.MaxLength)
		{
			throw new WebSocketException(CloseStatusCode.TooBig);
		}
		_opcode = opcode;
		_rawData = rawData;
	}
}


using System;
using WebSocketSharp;

public class CloseEventArgs : EventArgs
{
	private bool _clean;

	private PayloadData _payloadData;

	internal PayloadData PayloadData => _payloadData;

	public ushort Code => _payloadData.Code;

	public string Reason => _payloadData.Reason ?? string.Empty;

	public bool WasClean
	{
		get
		{
			return _clean;
		}
		internal set
		{
			_clean = value;
		}
	}

	internal CloseEventArgs()
	{
		_payloadData = PayloadData.Empty;
	}

	internal CloseEventArgs(ushort code)
		: this(code, null)
	{
	}

	internal CloseEventArgs(CloseStatusCode code)
		: this((ushort)code, null)
	{
	}

	internal CloseEventArgs(PayloadData payloadData)
	{
		_payloadData = payloadData;
	}

	internal CloseEventArgs(ushort code, string reason)
	{
		_payloadData = new PayloadData(code, reason);
	}

	internal CloseEventArgs(CloseStatusCode code, string reason)
		: this((ushort)code, reason)
	{
	}
}


public enum ByteOrder
{
	Little,
	Big
}


using System;

public class ErrorEventArgs : EventArgs
{
	private Exception _exception;

	private string _message;

	public Exception Exception => _exception;

	public string Message => _message;

	internal ErrorEventArgs(string message)
		: this(message, null)
	{
	}

	internal ErrorEventArgs(string message, Exception exception)
	{
		_message = message;
		_exception = exception;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Net.Security;
using System.Net.Sockets;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using WebSocketSharp;
using WebSocketSharp.Net;
using WebSocketSharp.Net.WebSockets;

public class WebSocket : IDisposable
{
	private AuthenticationChallenge _authChallenge;

	private string _base64Key;

	private bool _client;

	private Action _closeContext;

	private CompressionMethod _compression;

	private WebSocketContext _context;

	private CookieCollection _cookies;

	private NetworkCredential _credentials;

	private bool _emitOnPing;

	private bool _enableRedirection;

	private AutoResetEvent _exitReceiving;

	private string _extensions;

	private bool _extensionsRequested;

	private object _forMessageEventQueue;

	private object _forSend;

	private object _forState;

	private MemoryStream _fragmentsBuffer;

	private bool _fragmentsCompressed;

	private Opcode _fragmentsOpcode;

	private const string _guid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";

	private Func<WebSocketContext, string> _handshakeRequestChecker;

	private bool _ignoreExtensions;

	private bool _inContinuation;

	private volatile bool _inMessage;

	private volatile Logger _logger;

	private Action<MessageEventArgs> _message;

	private Queue<MessageEventArgs> _messageEventQueue;

	private uint _nonceCount;

	private string _origin;

	private bool _preAuth;

	private string _protocol;

	private string[] _protocols;

	private bool _protocolsRequested;

	private NetworkCredential _proxyCredentials;

	private Uri _proxyUri;

	private volatile WebSocketState _readyState;

	private AutoResetEvent _receivePong;

	private bool _secure;

	private ClientSslConfiguration _sslConfig;

	private Stream _stream;

	private TcpClient _tcpClient;

	private Uri _uri;

	private const string _version = "13";

	private TimeSpan _waitTime;

	internal static readonly byte[] EmptyBytes;

	internal static readonly int FragmentLength;

	internal static readonly RandomNumberGenerator RandomNumber;

	internal CookieCollection CookieCollection => _cookies;

	internal Func<WebSocketContext, string> CustomHandshakeRequestChecker
	{
		get
		{
			return _handshakeRequestChecker;
		}
		set
		{
			_handshakeRequestChecker = value;
		}
	}

	internal bool HasMessage
	{
		get
		{
			lock (_forMessageEventQueue)
			{
				return _messageEventQueue.Count > 0;
			}
		}
	}

	internal bool IgnoreExtensions
	{
		get
		{
			return _ignoreExtensions;
		}
		set
		{
			_ignoreExtensions = value;
		}
	}

	internal bool IsConnected => _readyState == WebSocketState.Open || _readyState == WebSocketState.Closing;

	public CompressionMethod Compression
	{
		get
		{
			return _compression;
		}
		set
		{
			lock (_forState)
			{
				if (!checkIfAvailable(client: true, server: false, connecting: true, open: false, closing: false, closed: true, out var text))
				{
					_logger.Error(text);
					error("An error has occurred in setting the compression.", null);
				}
				else
				{
					_compression = value;
				}
			}
		}
	}

	public IEnumerable<Cookie> Cookies
	{
		get
		{
			lock (_cookies.SyncRoot)
			{
				foreach (Cookie cookie in _cookies)
				{
					yield return cookie;
				}
			}
		}
	}

	public NetworkCredential Credentials => _credentials;

	public bool EmitOnPing
	{
		get
		{
			return _emitOnPing;
		}
		set
		{
			_emitOnPing = value;
		}
	}

	public bool EnableRedirection
	{
		get
		{
			return _enableRedirection;
		}
		set
		{
			lock (_forState)
			{
				if (!checkIfAvailable(client: true, server: false, connecting: true, open: false, closing: false, closed: true, out var text))
				{
					_logger.Error(text);
					error("An error has occurred in setting the enable redirection.", null);
				}
				else
				{
					_enableRedirection = value;
				}
			}
		}
	}

	public string Extensions => _extensions ?? string.Empty;

	public bool IsAlive => Ping();

	public bool IsSecure => _secure;

	public Logger Log
	{
		get
		{
			return _logger;
		}
		internal set
		{
			_logger = value;
		}
	}

	public string Origin
	{
		get
		{
			return _origin;
		}
		set
		{
			lock (_forState)
			{
				Uri result;
				if (!checkIfAvailable(client: true, server: false, connecting: true, open: false, closing: false, closed: true, out var text))
				{
					_logger.Error(text);
					error("An error has occurred in setting the origin.", null);
				}
				else if (value.IsNullOrEmpty())
				{
					_origin = value;
				}
				else if (!Uri.TryCreate(value, UriKind.Absolute, out result) || result.Segments.Length > 1)
				{
					_logger.Error("The syntax of an origin must be '<scheme>://<host>[:<port>]'.");
					error("An error has occurred in setting the origin.", null);
				}
				else
				{
					_origin = value.TrimEnd(new char[1] { '/' });
				}
			}
		}
	}

	public string Protocol
	{
		get
		{
			return _protocol ?? string.Empty;
		}
		internal set
		{
			_protocol = value;
		}
	}

	public WebSocketState ReadyState => _readyState;

	public ClientSslConfiguration SslConfiguration
	{
		get
		{
			return _client ? (_sslConfig ?? (_sslConfig = new ClientSslConfiguration(_uri.DnsSafeHost))) : null;
		}
		set
		{
			lock (_forState)
			{
				if (!checkIfAvailable(client: true, server: false, connecting: true, open: false, closing: false, closed: true, out var text))
				{
					_logger.Error(text);
					error("An error has occurred in setting the ssl configuration.", null);
				}
				else
				{
					_sslConfig = value;
				}
			}
		}
	}

	public Uri Url => _client ? _uri : _context.RequestUri;

	public TimeSpan WaitTime
	{
		get
		{
			return _waitTime;
		}
		set
		{
			lock (_forState)
			{
				if (!checkIfAvailable(client: true, server: true, connecting: true, open: false, closing: false, closed: true, out var text) || !value.CheckWaitTime(out text))
				{
					_logger.Error(text);
					error("An error has occurred in setting the wait time.", null);
				}
				else
				{
					_waitTime = value;
				}
			}
		}
	}

	public event EventHandler<CloseEventArgs> OnClose;

	public event EventHandler<WebSocketSharp.ErrorEventArgs> OnError;

	public event EventHandler<MessageEventArgs> OnMessage;

	public event EventHandler OnOpen;

	static WebSocket()
	{
		EmptyBytes = new byte[0];
		FragmentLength = 1016;
		RandomNumber = new RNGCryptoServiceProvider();
	}

	internal WebSocket(HttpListenerWebSocketContext context, string protocol)
	{
		_context = context;
		_protocol = protocol;
		_closeContext = context.Close;
		_logger = context.Log;
		_message = messages;
		_secure = context.IsSecureConnection;
		_stream = context.Stream;
		_waitTime = TimeSpan.FromSeconds(1.0);
		init();
	}

	internal WebSocket(TcpListenerWebSocketContext context, string protocol)
	{
		_context = context;
		_protocol = protocol;
		_closeContext = context.Close;
		_logger = context.Log;
		_message = messages;
		_secure = context.IsSecureConnection;
		_stream = context.Stream;
		_waitTime = TimeSpan.FromSeconds(1.0);
		init();
	}

	public WebSocket(string url, params string[] protocols)
	{
		if (url == null)
		{
			throw new ArgumentNullException("url");
		}
		if (url.Length == 0)
		{
			throw new ArgumentException("An empty string.", "url");
		}
		if (!url.TryCreateWebSocketUri(out _uri, out var text))
		{
			throw new ArgumentException(text, "url");
		}
		if (protocols != null && protocols.Length != 0)
		{
			text = protocols.CheckIfValidProtocols();
			if (text != null)
			{
				throw new ArgumentException(text, "protocols");
			}
			_protocols = protocols;
		}
		_base64Key = CreateBase64Key();
		_client = true;
		_logger = new Logger();
		_message = messagec;
		_secure = _uri.Scheme == "wss";
		_waitTime = TimeSpan.FromSeconds(5.0);
		init();
	}

	private bool accept()
	{
		lock (_forState)
		{
			if (!checkIfAvailable(connecting: true, open: false, closing: false, closed: false, out var text))
			{
				_logger.Error(text);
				error("An error has occurred in accepting.", null);
				return false;
			}
			try
			{
				if (!acceptHandshake())
				{
					return false;
				}
				_readyState = WebSocketState.Open;
			}
			catch (Exception ex)
			{
				_logger.Fatal(ex.ToString());
				fatal("An exception has occurred while accepting.", ex);
				return false;
			}
			return true;
		}
	}

	private bool acceptHandshake()
	{
		_logger.Debug($"A request from {_context.UserEndPoint}:\n{_context}");
		if (!checkHandshakeRequest(_context, out var text))
		{
			sendHttpResponse(createHandshakeFailureResponse(HttpStatusCode.BadRequest));
			_logger.Fatal(text);
			fatal("An error has occurred while accepting.", CloseStatusCode.ProtocolError);
			return false;
		}
		if (!customCheckHandshakeRequest(_context, out text))
		{
			sendHttpResponse(createHandshakeFailureResponse(HttpStatusCode.BadRequest));
			_logger.Fatal(text);
			fatal("An error has occurred while accepting.", CloseStatusCode.PolicyViolation);
			return false;
		}
		_base64Key = _context.Headers["Sec-WebSocket-Key"];
		if (_protocol != null)
		{
			processSecWebSocketProtocolHeader(_context.SecWebSocketProtocols);
		}
		if (!_ignoreExtensions)
		{
			processSecWebSocketExtensionsClientHeader(_context.Headers["Sec-WebSocket-Extensions"]);
		}
		return sendHttpResponse(createHandshakeResponse());
	}

	private bool checkHandshakeRequest(WebSocketContext context, out string message)
	{
		message = null;
		if (context.RequestUri == null)
		{
			message = "Specifies an invalid Request-URI.";
			return false;
		}
		if (!context.IsWebSocketRequest)
		{
			message = "Not a WebSocket handshake request.";
			return false;
		}
		NameValueCollection headers = context.Headers;
		if (!validateSecWebSocketKeyHeader(headers["Sec-WebSocket-Key"]))
		{
			message = "Includes no Sec-WebSocket-Key header, or it has an invalid value.";
			return false;
		}
		if (!validateSecWebSocketVersionClientHeader(headers["Sec-WebSocket-Version"]))
		{
			message = "Includes no Sec-WebSocket-Version header, or it has an invalid value.";
			return false;
		}
		if (!validateSecWebSocketProtocolClientHeader(headers["Sec-WebSocket-Protocol"]))
		{
			message = "Includes an invalid Sec-WebSocket-Protocol header.";
			return false;
		}
		if (!_ignoreExtensions && !validateSecWebSocketExtensionsClientHeader(headers["Sec-WebSocket-Extensions"]))
		{
			message = "Includes an invalid Sec-WebSocket-Extensions header.";
			return false;
		}
		return true;
	}

	private bool checkHandshakeResponse(HttpResponse response, out string message)
	{
		message = null;
		if (response.IsRedirect)
		{
			message = "Indicates the redirection.";
			return false;
		}
		if (response.IsUnauthorized)
		{
			message = "Requires the authentication.";
			return false;
		}
		if (!response.IsWebSocketResponse)
		{
			message = "Not a WebSocket handshake response.";
			return false;
		}
		NameValueCollection headers = response.Headers;
		if (!validateSecWebSocketAcceptHeader(headers["Sec-WebSocket-Accept"]))
		{
			message = "Includes no Sec-WebSocket-Accept header, or it has an invalid value.";
			return false;
		}
		if (!validateSecWebSocketProtocolServerHeader(headers["Sec-WebSocket-Protocol"]))
		{
			message = "Includes no Sec-WebSocket-Protocol header, or it has an invalid value.";
			return false;
		}
		if (!validateSecWebSocketExtensionsServerHeader(headers["Sec-WebSocket-Extensions"]))
		{
			message = "Includes an invalid Sec-WebSocket-Extensions header.";
			return false;
		}
		if (!validateSecWebSocketVersionServerHeader(headers["Sec-WebSocket-Version"]))
		{
			message = "Includes an invalid Sec-WebSocket-Version header.";
			return false;
		}
		return true;
	}

	private bool checkIfAvailable(bool connecting, bool open, bool closing, bool closed, out string message)
	{
		message = null;
		if (!connecting && _readyState == WebSocketState.Connecting)
		{
			message = "This operation is not available in: connecting";
			return false;
		}
		if (!open && _readyState == WebSocketState.Open)
		{
			message = "This operation is not available in: open";
			return false;
		}
		if (!closing && _readyState == WebSocketState.Closing)
		{
			message = "This operation is not available in: closing";
			return false;
		}
		if (!closed && _readyState == WebSocketState.Closed)
		{
			message = "This operation is not available in: closed";
			return false;
		}
		return true;
	}

	private bool checkIfAvailable(bool client, bool server, bool connecting, bool open, bool closing, bool closed, out string message)
	{
		message = null;
		if (!client && _client)
		{
			message = "This operation is not available in: client";
			return false;
		}
		if (!server && !_client)
		{
			message = "This operation is not available in: server";
			return false;
		}
		return checkIfAvailable(connecting, open, closing, closed, out message);
	}

	private static bool checkParametersForSetCredentials(string username, string password, out string message)
	{
		message = null;
		if (username.IsNullOrEmpty())
		{
			return true;
		}
		if (Ext.Contains(username, ':') || !username.IsText())
		{
			message = "'username' contains an invalid character.";
			return false;
		}
		if (password.IsNullOrEmpty())
		{
			return true;
		}
		if (!password.IsText())
		{
			message = "'password' contains an invalid character.";
			return false;
		}
		return true;
	}

	private static bool checkParametersForSetProxy(string url, string username, string password, out string message)
	{
		message = null;
		if (url.IsNullOrEmpty())
		{
			return true;
		}
		if (!Uri.TryCreate(url, UriKind.Absolute, out Uri result) || result.Scheme != "http" || result.Segments.Length > 1)
		{
			message = "'url' is an invalid URL.";
			return false;
		}
		if (username.IsNullOrEmpty())
		{
			return true;
		}
		if (Ext.Contains(username, ':') || !username.IsText())
		{
			message = "'username' contains an invalid character.";
			return false;
		}
		if (password.IsNullOrEmpty())
		{
			return true;
		}
		if (!password.IsText())
		{
			message = "'password' contains an invalid character.";
			return false;
		}
		return true;
	}

	private bool checkReceivedFrame(WebSocketFrame frame, out string message)
	{
		message = null;
		bool isMasked = frame.IsMasked;
		if (_client && isMasked)
		{
			message = "A frame from the server is masked.";
			return false;
		}
		if (!_client && !isMasked)
		{
			message = "A frame from a client is not masked.";
			return false;
		}
		if (_inContinuation && frame.IsData)
		{
			message = "A data frame has been received while receiving continuation frames.";
			return false;
		}
		if (frame.IsCompressed && _compression == CompressionMethod.None)
		{
			message = "A compressed frame has been received without any agreement for it.";
			return false;
		}
		if (frame.Rsv2 == Rsv.On)
		{
			message = "The RSV2 of a frame is non-zero without any negotiation for it.";
			return false;
		}
		if (frame.Rsv3 == Rsv.On)
		{
			message = "The RSV3 of a frame is non-zero without any negotiation for it.";
			return false;
		}
		return true;
	}

	private void close(ushort code, string reason)
	{
		if (code == 1005)
		{
			close(new CloseEventArgs(), send: true, receive: true, received: false);
			return;
		}
		bool receive = !code.IsReserved();
		close(new CloseEventArgs(code, reason), receive, receive, received: false);
	}

	private void close(CloseEventArgs e, bool send, bool receive, bool received)
	{
		lock (_forState)
		{
			if (_readyState == WebSocketState.Closing)
			{
				_logger.Info("The closing is already in progress.");
				return;
			}
			if (_readyState == WebSocketState.Closed)
			{
				_logger.Info("The connection has been closed.");
				return;
			}
			send = send && _readyState == WebSocketState.Open;
			receive = receive && send;
			_readyState = WebSocketState.Closing;
		}
		_logger.Trace("Begin closing the connection.");
		byte[] frameAsBytes = (send ? WebSocketFrame.CreateCloseFrame(e.PayloadData, _client).ToArray() : null);
		e.WasClean = closeHandshake(frameAsBytes, receive, received);
		releaseResources();
		_logger.Trace("End closing the connection.");
		_readyState = WebSocketState.Closed;
		try
		{
			this.OnClose.Emit(this, e);
		}
		catch (Exception ex)
		{
			_logger.Error(ex.ToString());
			error("An exception has occurred during the OnClose event.", ex);
		}
	}

	private void closeAsync(ushort code, string reason)
	{
		if (code == 1005)
		{
			closeAsync(new CloseEventArgs(), send: true, receive: true, received: false);
			return;
		}
		bool receive = !code.IsReserved();
		closeAsync(new CloseEventArgs(code, reason), receive, receive, received: false);
	}

	private void closeAsync(CloseEventArgs e, bool send, bool receive, bool received)
	{
		Action<CloseEventArgs, bool, bool, bool> closer = close;
		closer.BeginInvoke(e, send, receive, received, delegate(IAsyncResult ar)
		{
			closer.EndInvoke(ar);
		}, null);
	}

	private bool closeHandshake(byte[] frameAsBytes, bool receive, bool received)
	{
		bool flag = frameAsBytes != null && sendBytes(frameAsBytes);
		received = received || (receive && flag && _exitReceiving != null && _exitReceiving.WaitOne(_waitTime));
		bool flag2 = flag && received;
		_logger.Debug($"Was clean?: {flag2}\n  sent: {flag}\n  received: {received}");
		return flag2;
	}

	private bool connect()
	{
		lock (_forState)
		{
			if (!checkIfAvailable(connecting: true, open: false, closing: false, closed: true, out var text))
			{
				_logger.Error(text);
				error("An error has occurred in connecting.", null);
				return false;
			}
			try
			{
				_readyState = WebSocketState.Connecting;
				if (!doHandshake())
				{
					return false;
				}
				_readyState = WebSocketState.Open;
			}
			catch (Exception ex)
			{
				_logger.Fatal(ex.ToString());
				fatal("An exception has occurred while connecting.", ex);
				return false;
			}
			return true;
		}
	}

	private string createExtensions()
	{
		StringBuilder stringBuilder = new StringBuilder(80);
		if (_compression != 0)
		{
			string arg = _compression.ToExtensionString("server_no_context_takeover", "client_no_context_takeover");
			stringBuilder.AppendFormat("{0}, ", arg);
		}
		int length = stringBuilder.Length;
		if (length > 2)
		{
			stringBuilder.Length = length - 2;
			return stringBuilder.ToString();
		}
		return null;
	}

	private HttpResponse createHandshakeFailureResponse(HttpStatusCode code)
	{
		HttpResponse httpResponse = HttpResponse.CreateCloseResponse(code);
		httpResponse.Headers["Sec-WebSocket-Version"] = "13";
		return httpResponse;
	}

	private HttpRequest createHandshakeRequest()
	{
		HttpRequest httpRequest = HttpRequest.CreateWebSocketRequest(_uri);
		NameValueCollection headers = httpRequest.Headers;
		if (!_origin.IsNullOrEmpty())
		{
			headers["Origin"] = _origin;
		}
		headers["Sec-WebSocket-Key"] = _base64Key;
		_protocolsRequested = _protocols != null;
		if (_protocolsRequested)
		{
			headers["Sec-WebSocket-Protocol"] = _protocols.ToString(", ");
		}
		_extensionsRequested = _compression != CompressionMethod.None;
		if (_extensionsRequested)
		{
			headers["Sec-WebSocket-Extensions"] = createExtensions();
		}
		headers["Sec-WebSocket-Version"] = "13";
		AuthenticationResponse authenticationResponse = null;
		if (_authChallenge != null && _credentials != null)
		{
			authenticationResponse = new AuthenticationResponse(_authChallenge, _credentials, _nonceCount);
			_nonceCount = authenticationResponse.NonceCount;
		}
		else if (_preAuth)
		{
			authenticationResponse = new AuthenticationResponse(_credentials);
		}
		if (authenticationResponse != null)
		{
			headers["Authorization"] = authenticationResponse.ToString();
		}
		if (_cookies.Count > 0)
		{
			httpRequest.SetCookies(_cookies);
		}
		return httpRequest;
	}

	private HttpResponse createHandshakeResponse()
	{
		HttpResponse httpResponse = HttpResponse.CreateWebSocketResponse();
		NameValueCollection headers = httpResponse.Headers;
		headers["Sec-WebSocket-Accept"] = CreateResponseKey(_base64Key);
		if (_protocol != null)
		{
			headers["Sec-WebSocket-Protocol"] = _protocol;
		}
		if (_extensions != null)
		{
			headers["Sec-WebSocket-Extensions"] = _extensions;
		}
		if (_cookies.Count > 0)
		{
			httpResponse.SetCookies(_cookies);
		}
		return httpResponse;
	}

	private bool customCheckHandshakeRequest(WebSocketContext context, out string message)
	{
		message = null;
		return _handshakeRequestChecker == null || (message = _handshakeRequestChecker(context)) == null;
	}

	private MessageEventArgs dequeueFromMessageEventQueue()
	{
		lock (_forMessageEventQueue)
		{
			return (_messageEventQueue.Count > 0) ? _messageEventQueue.Dequeue() : null;
		}
	}

	private bool doHandshake()
	{
		setClientStream();
		HttpResponse httpResponse = sendHandshakeRequest();
		if (!checkHandshakeResponse(httpResponse, out var text))
		{
			_logger.Fatal(text);
			fatal("An error has occurred while connecting.", CloseStatusCode.ProtocolError);
			return false;
		}
		if (_protocolsRequested)
		{
			_protocol = httpResponse.Headers["Sec-WebSocket-Protocol"];
		}
		if (_extensionsRequested)
		{
			processSecWebSocketExtensionsServerHeader(httpResponse.Headers["Sec-WebSocket-Extensions"]);
		}
		processCookies(httpResponse.Cookies);
		return true;
	}

	private void enqueueToMessageEventQueue(MessageEventArgs e)
	{
		lock (_forMessageEventQueue)
		{
			_messageEventQueue.Enqueue(e);
		}
	}

	private void error(string message, Exception exception)
	{
		try
		{
			this.OnError.Emit(this, new WebSocketSharp.ErrorEventArgs(message, exception));
		}
		catch (Exception ex)
		{
			_logger.Error(ex.ToString());
		}
	}

	private void fatal(string message, Exception exception)
	{
		CloseStatusCode code = ((exception is WebSocketException) ? ((WebSocketException)exception).Code : CloseStatusCode.Abnormal);
		fatal(message, code);
	}

	private void fatal(string message, CloseStatusCode code)
	{
		close(new CloseEventArgs(code, message), !code.IsReserved(), receive: false, received: false);
	}

	private void init()
	{
		_compression = CompressionMethod.None;
		_cookies = new CookieCollection();
		_forSend = new object();
		_forState = new object();
		_messageEventQueue = new Queue<MessageEventArgs>();
		_forMessageEventQueue = ((ICollection)_messageEventQueue).SyncRoot;
		_readyState = WebSocketState.Connecting;
	}

	private void message()
	{
		MessageEventArgs obj = null;
		lock (_forMessageEventQueue)
		{
			if (_inMessage || _messageEventQueue.Count == 0 || _readyState != WebSocketState.Open)
			{
				return;
			}
			_inMessage = true;
			obj = _messageEventQueue.Dequeue();
		}
		_message(obj);
	}

	private void messagec(MessageEventArgs e)
	{
		while (true)
		{
			try
			{
				this.OnMessage.Emit(this, e);
			}
			catch (Exception ex)
			{
				_logger.Error(ex.ToString());
				error("An exception has occurred during an OnMessage event.", ex);
			}
			lock (_forMessageEventQueue)
			{
				if (_messageEventQueue.Count == 0 || _readyState != WebSocketState.Open)
				{
					_inMessage = false;
					break;
				}
				e = _messageEventQueue.Dequeue();
			}
			bool flag = true;
		}
	}

	private void messages(MessageEventArgs e)
	{
		try
		{
			this.OnMessage.Emit(this, e);
		}
		catch (Exception ex)
		{
			_logger.Error(ex.ToString());
			error("An exception has occurred during an OnMessage event.", ex);
		}
		lock (_forMessageEventQueue)
		{
			if (_messageEventQueue.Count == 0 || _readyState != WebSocketState.Open)
			{
				_inMessage = false;
				return;
			}
			e = _messageEventQueue.Dequeue();
		}
		ThreadPool.QueueUserWorkItem(delegate
		{
			messages(e);
		});
	}

	private void open()
	{
		_inMessage = true;
		startReceiving();
		try
		{
			this.OnOpen.Emit(this, EventArgs.Empty);
		}
		catch (Exception ex)
		{
			_logger.Error(ex.ToString());
			error("An exception has occurred during the OnOpen event.", ex);
		}
		MessageEventArgs obj = null;
		lock (_forMessageEventQueue)
		{
			if (_messageEventQueue.Count == 0 || _readyState != WebSocketState.Open)
			{
				_inMessage = false;
				return;
			}
			obj = _messageEventQueue.Dequeue();
		}
		_message.BeginInvoke(obj, delegate(IAsyncResult ar)
		{
			_message.EndInvoke(ar);
		}, null);
	}

	private bool processCloseFrame(WebSocketFrame frame)
	{
		PayloadData payloadData = frame.PayloadData;
		close(new CloseEventArgs(payloadData), !payloadData.HasReservedCode, receive: false, received: true);
		return false;
	}

	private void processCookies(CookieCollection cookies)
	{
		if (cookies.Count != 0)
		{
			_cookies.SetOrRemove(cookies);
		}
	}

	private bool processDataFrame(WebSocketFrame frame)
	{
		enqueueToMessageEventQueue(frame.IsCompressed ? new MessageEventArgs(frame.Opcode, frame.PayloadData.ApplicationData.Decompress(_compression)) : new MessageEventArgs(frame));
		return true;
	}

	private bool processFragmentFrame(WebSocketFrame frame)
	{
		if (!_inContinuation)
		{
			if (frame.IsContinuation)
			{
				return true;
			}
			_fragmentsOpcode = frame.Opcode;
			_fragmentsCompressed = frame.IsCompressed;
			_fragmentsBuffer = new MemoryStream();
			_inContinuation = true;
		}
		_fragmentsBuffer.WriteBytes(frame.PayloadData.ApplicationData, 1024);
		if (frame.IsFinal)
		{
			using (_fragmentsBuffer)
			{
				byte[] rawData = (_fragmentsCompressed ? _fragmentsBuffer.DecompressToArray(_compression) : _fragmentsBuffer.ToArray());
				enqueueToMessageEventQueue(new MessageEventArgs(_fragmentsOpcode, rawData));
			}
			_fragmentsBuffer = null;
			_inContinuation = false;
		}
		return true;
	}

	private bool processPingFrame(WebSocketFrame frame)
	{
		if (send(new WebSocketFrame(Opcode.Pong, frame.PayloadData, _client).ToArray()))
		{
			_logger.Trace("Returned a pong.");
		}
		if (_emitOnPing)
		{
			enqueueToMessageEventQueue(new MessageEventArgs(frame));
		}
		return true;
	}

	private bool processPongFrame(WebSocketFrame frame)
	{
		_receivePong.Set();
		_logger.Trace("Received a pong.");
		return true;
	}

	private bool processReceivedFrame(WebSocketFrame frame)
	{
		if (!checkReceivedFrame(frame, out var text))
		{
			throw new WebSocketException(CloseStatusCode.ProtocolError, text);
		}
		frame.Unmask();
		return frame.IsFragment ? processFragmentFrame(frame) : (frame.IsData ? processDataFrame(frame) : (frame.IsPing ? processPingFrame(frame) : (frame.IsPong ? processPongFrame(frame) : (frame.IsClose ? processCloseFrame(frame) : processUnsupportedFrame(frame)))));
	}

	private void processSecWebSocketExtensionsClientHeader(string value)
	{
		if (value == null)
		{
			return;
		}
		StringBuilder stringBuilder = new StringBuilder(80);
		bool flag = false;
		foreach (string item in value.SplitHeaderValue(','))
		{
			string value2 = item.Trim();
			if (!flag && value2.IsCompressionExtension(CompressionMethod.Deflate))
			{
				_compression = CompressionMethod.Deflate;
				stringBuilder.AppendFormat("{0}, ", _compression.ToExtensionString("client_no_context_takeover", "server_no_context_takeover"));
				flag = true;
			}
		}
		int length = stringBuilder.Length;
		if (length > 2)
		{
			stringBuilder.Length = length - 2;
			_extensions = stringBuilder.ToString();
		}
	}

	private void processSecWebSocketExtensionsServerHeader(string value)
	{
		if (value == null)
		{
			_compression = CompressionMethod.None;
		}
		else
		{
			_extensions = value;
		}
	}

	private void processSecWebSocketProtocolHeader(IEnumerable<string> values)
	{
		if (!values.Contains((string p) => p == _protocol))
		{
			_protocol = null;
		}
	}

	private bool processUnsupportedFrame(WebSocketFrame frame)
	{
		_logger.Fatal("An unsupported frame:" + frame.PrintToString(dumped: false));
		fatal("There is no way to handle it.", CloseStatusCode.PolicyViolation);
		return false;
	}

	private void releaseClientResources()
	{
		if (_stream != null)
		{
			_stream.Dispose();
			_stream = null;
		}
		if (_tcpClient != null)
		{
			_tcpClient.Close();
			_tcpClient = null;
		}
	}

	private void releaseCommonResources()
	{
		if (_fragmentsBuffer != null)
		{
			_fragmentsBuffer.Dispose();
			_fragmentsBuffer = null;
			_inContinuation = false;
		}
		if (_receivePong != null)
		{
			_receivePong.Close();
			_receivePong = null;
		}
		if (_exitReceiving != null)
		{
			_exitReceiving.Close();
			_exitReceiving = null;
		}
	}

	private void releaseResources()
	{
		if (_client)
		{
			releaseClientResources();
		}
		else
		{
			releaseServerResources();
		}
		releaseCommonResources();
	}

	private void releaseServerResources()
	{
		if (_closeContext != null)
		{
			_closeContext();
			_closeContext = null;
			_stream = null;
			_context = null;
		}
	}

	private bool send(byte[] frameAsBytes)
	{
		lock (_forState)
		{
			if (_readyState != WebSocketState.Open)
			{
				_logger.Error("The sending has been interrupted.");
				return false;
			}
			return sendBytes(frameAsBytes);
		}
	}

	private bool send(Opcode opcode, Stream stream)
	{
		lock (_forSend)
		{
			Stream stream2 = stream;
			bool flag = false;
			bool flag2 = false;
			try
			{
				if (_compression != 0)
				{
					stream = stream.Compress(_compression);
					flag = true;
				}
				flag2 = send(opcode, stream, flag);
				if (!flag2)
				{
					error("The sending has been interrupted.", null);
				}
			}
			catch (Exception ex)
			{
				_logger.Error(ex.ToString());
				error("An exception has occurred while sending data.", ex);
			}
			finally
			{
				if (flag)
				{
					stream.Dispose();
				}
				stream2.Dispose();
			}
			return flag2;
		}
	}

	private bool send(Opcode opcode, Stream stream, bool compressed)
	{
		long length = stream.Length;
		if (length == 0)
		{
			return send(Fin.Final, opcode, EmptyBytes, compressed);
		}
		long num = length / FragmentLength;
		int num2 = (int)(length % FragmentLength);
		byte[] array = null;
		if (num == 0)
		{
			array = new byte[num2];
			return stream.Read(array, 0, num2) == num2 && send(Fin.Final, opcode, array, compressed);
		}
		array = new byte[FragmentLength];
		if (num == 1 && num2 == 0)
		{
			return stream.Read(array, 0, FragmentLength) == FragmentLength && send(Fin.Final, opcode, array, compressed);
		}
		if (stream.Read(array, 0, FragmentLength) != FragmentLength || !send(Fin.More, opcode, array, compressed))
		{
			return false;
		}
		long num3 = ((num2 == 0) ? (num - 2) : (num - 1));
		for (long num4 = 0L; num4 < num3; num4++)
		{
			if (stream.Read(array, 0, FragmentLength) != FragmentLength || !send(Fin.More, Opcode.Cont, array, compressed))
			{
				return false;
			}
		}
		if (num2 == 0)
		{
			num2 = FragmentLength;
		}
		else
		{
			array = new byte[num2];
		}
		return stream.Read(array, 0, num2) == num2 && send(Fin.Final, Opcode.Cont, array, compressed);
	}

	private bool send(Fin fin, Opcode opcode, byte[] data, bool compressed)
	{
		lock (_forState)
		{
			if (_readyState != WebSocketState.Open)
			{
				_logger.Error("The sending has been interrupted.");
				return false;
			}
			return sendBytes(new WebSocketFrame(fin, opcode, data, compressed, _client).ToArray());
		}
	}

	private void sendAsync(Opcode opcode, Stream stream, Action<bool> completed)
	{
		Func<Opcode, Stream, bool> sender = send;
		sender.BeginInvoke(opcode, stream, delegate(IAsyncResult ar)
		{
			try
			{
				bool obj = sender.EndInvoke(ar);
				if (completed != null)
				{
					completed(obj);
				}
			}
			catch (Exception ex)
			{
				_logger.Error(ex.ToString());
				error("An exception has occurred during a send callback.", ex);
			}
		}, null);
	}

	private bool sendBytes(byte[] bytes)
	{
		try
		{
			_stream.Write(bytes, 0, bytes.Length);
			return true;
		}
		catch (Exception ex)
		{
			_logger.Error(ex.ToString());
			return false;
		}
	}

	private HttpResponse sendHandshakeRequest()
	{
		HttpRequest httpRequest = createHandshakeRequest();
		HttpResponse httpResponse = sendHttpRequest(httpRequest, 90000);
		if (httpResponse.IsUnauthorized)
		{
			string text = httpResponse.Headers["WWW-Authenticate"];
			_logger.Warn($"Received an authentication requirement for '{text}'.");
			if (text.IsNullOrEmpty())
			{
				_logger.Error("No authentication challenge is specified.");
				return httpResponse;
			}
			_authChallenge = AuthenticationChallenge.Parse(text);
			if (_authChallenge == null)
			{
				_logger.Error("An invalid authentication challenge is specified.");
				return httpResponse;
			}
			if (_credentials != null && (!_preAuth || _authChallenge.Scheme == AuthenticationSchemes.Digest))
			{
				if (httpResponse.HasConnectionClose)
				{
					releaseClientResources();
					setClientStream();
				}
				AuthenticationResponse authenticationResponse = new AuthenticationResponse(_authChallenge, _credentials, _nonceCount);
				_nonceCount = authenticationResponse.NonceCount;
				httpRequest.Headers["Authorization"] = authenticationResponse.ToString();
				httpResponse = sendHttpRequest(httpRequest, 15000);
			}
		}
		if (httpResponse.IsRedirect)
		{
			string text2 = httpResponse.Headers["Location"];
			_logger.Warn($"Received a redirection to '{text2}'.");
			if (_enableRedirection)
			{
				if (text2.IsNullOrEmpty())
				{
					_logger.Error("No url to redirect is located.");
					return httpResponse;
				}
				if (!text2.TryCreateWebSocketUri(out var result, out var text3))
				{
					_logger.Error("An invalid url to redirect is located: " + text3);
					return httpResponse;
				}
				releaseClientResources();
				_uri = result;
				_secure = result.Scheme == "wss";
				setClientStream();
				return sendHandshakeRequest();
			}
		}
		return httpResponse;
	}

	private HttpResponse sendHttpRequest(HttpRequest request, int millisecondsTimeout)
	{
		_logger.Debug("A request to the server:\n" + request.ToString());
		HttpResponse response = request.GetResponse(_stream, millisecondsTimeout);
		_logger.Debug("A response to this request:\n" + response.ToString());
		return response;
	}

	private bool sendHttpResponse(HttpResponse response)
	{
		_logger.Debug("A response to this request:\n" + response.ToString());
		return sendBytes(response.ToByteArray());
	}

	private void sendProxyConnectRequest()
	{
		HttpRequest httpRequest = HttpRequest.CreateConnectRequest(_uri);
		HttpResponse httpResponse = sendHttpRequest(httpRequest, 90000);
		if (httpResponse.IsProxyAuthenticationRequired)
		{
			string text = httpResponse.Headers["Proxy-Authenticate"];
			_logger.Warn($"Received a proxy authentication requirement for '{text}'.");
			if (text.IsNullOrEmpty())
			{
				throw new WebSocketException("No proxy authentication challenge is specified.");
			}
			AuthenticationChallenge authenticationChallenge = AuthenticationChallenge.Parse(text);
			if (authenticationChallenge == null)
			{
				throw new WebSocketException("An invalid proxy authentication challenge is specified.");
			}
			if (_proxyCredentials != null)
			{
				if (httpResponse.HasConnectionClose)
				{
					releaseClientResources();
					_tcpClient = new TcpClient(_proxyUri.DnsSafeHost, _proxyUri.Port);
					_stream = _tcpClient.GetStream();
				}
				AuthenticationResponse authenticationResponse = new AuthenticationResponse(authenticationChallenge, _proxyCredentials, 0u);
				httpRequest.Headers["Proxy-Authorization"] = authenticationResponse.ToString();
				httpResponse = sendHttpRequest(httpRequest, 15000);
			}
			if (httpResponse.IsProxyAuthenticationRequired)
			{
				throw new WebSocketException("A proxy authentication is required.");
			}
		}
		if (httpResponse.StatusCode[0] != '2')
		{
			throw new WebSocketException("The proxy has failed a connection to the requested host and port.");
		}
	}

	private void setClientStream()
	{
		if (_proxyUri != null)
		{
			_tcpClient = new TcpClient(_proxyUri.DnsSafeHost, _proxyUri.Port);
			_stream = _tcpClient.GetStream();
			sendProxyConnectRequest();
		}
		else
		{
			_tcpClient = new TcpClient(_uri.DnsSafeHost, _uri.Port);
			_stream = _tcpClient.GetStream();
		}
		if (_secure)
		{
			ClientSslConfiguration sslConfiguration = SslConfiguration;
			string targetHost = sslConfiguration.TargetHost;
			if (targetHost != _uri.DnsSafeHost)
			{
				throw new WebSocketException(CloseStatusCode.TlsHandshakeFailure, "An invalid host name is specified.");
			}
			try
			{
				SslStream sslStream = new SslStream(_stream, leaveInnerStreamOpen: false, sslConfiguration.ServerCertificateValidationCallback, sslConfiguration.ClientCertificateSelectionCallback);
				sslStream.AuthenticateAsClient(targetHost, sslConfiguration.ClientCertificates, sslConfiguration.EnabledSslProtocols, sslConfiguration.CheckCertificateRevocation);
				_stream = sslStream;
			}
			catch (Exception innerException)
			{
				throw new WebSocketException(CloseStatusCode.TlsHandshakeFailure, innerException);
			}
		}
	}

	private void startReceiving()
	{
		if (_messageEventQueue.Count > 0)
		{
			_messageEventQueue.Clear();
		}
		_exitReceiving = new AutoResetEvent(initialState: false);
		_receivePong = new AutoResetEvent(initialState: false);
		Action receive = null;
		receive = delegate
		{
			WebSocketFrame.ReadFrameAsync(_stream, unmask: false, delegate(WebSocketFrame frame)
			{
				if (!processReceivedFrame(frame) || _readyState == WebSocketState.Closed)
				{
					_exitReceiving?.Set();
				}
				else
				{
					receive();
					if (!_inMessage && HasMessage && _readyState == WebSocketState.Open)
					{
						message();
					}
				}
			}, delegate(Exception ex)
			{
				_logger.Fatal(ex.ToString());
				fatal("An exception has occurred while receiving.", ex);
			});
		};
		receive();
	}

	private bool validateSecWebSocketAcceptHeader(string value)
	{
		return value != null && value == CreateResponseKey(_base64Key);
	}

	private bool validateSecWebSocketExtensionsClientHeader(string value)
	{
		return value == null || value.Length > 0;
	}

	private bool validateSecWebSocketExtensionsServerHeader(string value)
	{
		if (value == null)
		{
			return true;
		}
		if (value.Length == 0)
		{
			return false;
		}
		if (!_extensionsRequested)
		{
			return false;
		}
		bool flag = _compression != CompressionMethod.None;
		foreach (string item in value.SplitHeaderValue(','))
		{
			string text = item.Trim();
			if (flag && text.IsCompressionExtension(_compression))
			{
				if (!text.Contains("server_no_context_takeover"))
				{
					_logger.Error("The server hasn't sent back 'server_no_context_takeover'.");
					return false;
				}
				if (!text.Contains("client_no_context_takeover"))
				{
					_logger.Warn("The server hasn't sent back 'client_no_context_takeover'.");
				}
				string method = _compression.ToExtensionString();
				if (text.SplitHeaderValue(';').Contains(delegate(string t)
				{
					t = t.Trim();
					return t != method && t != "server_no_context_takeover" && t != "client_no_context_takeover";
				}))
				{
					return false;
				}
				continue;
			}
			return false;
		}
		return true;
	}

	private bool validateSecWebSocketKeyHeader(string value)
	{
		return value != null && value.Length > 0;
	}

	private bool validateSecWebSocketProtocolClientHeader(string value)
	{
		return value == null || value.Length > 0;
	}

	private bool validateSecWebSocketProtocolServerHeader(string value)
	{
		if (value == null)
		{
			return !_protocolsRequested;
		}
		if (value.Length == 0)
		{
			return false;
		}
		return _protocolsRequested && _protocols.Contains((string p) => p == value);
	}

	private bool validateSecWebSocketVersionClientHeader(string value)
	{
		return value != null && value == "13";
	}

	private bool validateSecWebSocketVersionServerHeader(string value)
	{
		return value == null || value == "13";
	}

	internal static bool CheckParametersForClose(ushort code, string reason, bool client, out string message)
	{
		message = null;
		if (!code.IsCloseStatusCode())
		{
			message = "'code' is an invalid status code.";
			return false;
		}
		if (code == 1005 && !reason.IsNullOrEmpty())
		{
			message = "'code' cannot have a reason.";
			return false;
		}
		if (code == 1010 && !client)
		{
			message = "'code' cannot be used by a server.";
			return false;
		}
		if (code == 1011 && client)
		{
			message = "'code' cannot be used by a client.";
			return false;
		}
		if (!reason.IsNullOrEmpty() && reason.UTF8Encode().Length > 123)
		{
			message = "The size of 'reason' is greater than the allowable max size.";
			return false;
		}
		return true;
	}

	internal static bool CheckParametersForClose(CloseStatusCode code, string reason, bool client, out string message)
	{
		message = null;
		if (code == CloseStatusCode.NoStatus && !reason.IsNullOrEmpty())
		{
			message = "'code' cannot have a reason.";
			return false;
		}
		if (code == CloseStatusCode.MandatoryExtension && !client)
		{
			message = "'code' cannot be used by a server.";
			return false;
		}
		if (code == CloseStatusCode.ServerError && client)
		{
			message = "'code' cannot be used by a client.";
			return false;
		}
		if (!reason.IsNullOrEmpty() && reason.UTF8Encode().Length > 123)
		{
			message = "The size of 'reason' is greater than the allowable max size.";
			return false;
		}
		return true;
	}

	internal static string CheckPingParameter(string message, out byte[] bytes)
	{
		bytes = message.UTF8Encode();
		return (bytes.Length > 125) ? "A message has greater than the allowable max size." : null;
	}

	internal static string CheckSendParameter(byte[] data)
	{
		return (data == null) ? "'data' is null." : null;
	}

	internal static string CheckSendParameter(FileInfo file)
	{
		return (file == null) ? "'file' is null." : null;
	}

	internal static string CheckSendParameter(string data)
	{
		return (data == null) ? "'data' is null." : null;
	}

	internal static string CheckSendParameters(Stream stream, int length)
	{
		return (stream == null) ? "'stream' is null." : ((!stream.CanRead) ? "'stream' cannot be read." : ((length < 1) ? "'length' is less than 1." : null));
	}

	internal void Close(HttpResponse response)
	{
		_readyState = WebSocketState.Closing;
		sendHttpResponse(response);
		releaseServerResources();
		_readyState = WebSocketState.Closed;
	}

	internal void Close(HttpStatusCode code)
	{
		Close(createHandshakeFailureResponse(code));
	}

	internal void Close(CloseEventArgs e, byte[] frameAsBytes, bool receive)
	{
		lock (_forState)
		{
			if (_readyState == WebSocketState.Closing)
			{
				_logger.Info("The closing is already in progress.");
				return;
			}
			if (_readyState == WebSocketState.Closed)
			{
				_logger.Info("The connection has been closed.");
				return;
			}
			_readyState = WebSocketState.Closing;
		}
		e.WasClean = closeHandshake(frameAsBytes, receive, received: false);
		releaseServerResources();
		releaseCommonResources();
		_readyState = WebSocketState.Closed;
		try
		{
			this.OnClose.Emit(this, e);
		}
		catch (Exception ex)
		{
			_logger.Error(ex.ToString());
		}
	}

	internal static string CreateBase64Key()
	{
		byte[] array = new byte[16];
		RandomNumber.GetBytes(array);
		return Convert.ToBase64String(array);
	}

	internal static string CreateResponseKey(string base64Key)
	{
		StringBuilder stringBuilder = new StringBuilder(base64Key, 64);
		stringBuilder.Append("258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
		SHA1 sHA = new SHA1CryptoServiceProvider();
		byte[] inArray = sHA.ComputeHash(stringBuilder.ToString().UTF8Encode());
		return Convert.ToBase64String(inArray);
	}

	internal void InternalAccept()
	{
		try
		{
			if (!acceptHandshake())
			{
				return;
			}
			_readyState = WebSocketState.Open;
		}
		catch (Exception ex)
		{
			_logger.Fatal(ex.ToString());
			fatal("An exception has occurred while accepting.", ex);
			return;
		}
		open();
	}

	internal bool Ping(byte[] frameAsBytes, TimeSpan timeout)
	{
		if (_readyState != WebSocketState.Open)
		{
			return false;
		}
		if (!send(frameAsBytes))
		{
			return false;
		}
		return _receivePong?.WaitOne(timeout) ?? false;
	}

	internal void Send(Opcode opcode, byte[] data, Dictionary<CompressionMethod, byte[]> cache)
	{
		lock (_forSend)
		{
			lock (_forState)
			{
				if (_readyState != WebSocketState.Open)
				{
					_logger.Error("The sending has been interrupted.");
					return;
				}
				try
				{
					if (!cache.TryGetValue(_compression, out var value))
					{
						value = new WebSocketFrame(Fin.Final, opcode, data.Compress(_compression), _compression != CompressionMethod.None, mask: false).ToArray();
						cache.Add(_compression, value);
					}
					sendBytes(value);
				}
				catch (Exception ex)
				{
					_logger.Error(ex.ToString());
				}
			}
		}
	}

	internal void Send(Opcode opcode, Stream stream, Dictionary<CompressionMethod, Stream> cache)
	{
		lock (_forSend)
		{
			try
			{
				if (!cache.TryGetValue(_compression, out var value))
				{
					value = stream.Compress(_compression);
					cache.Add(_compression, value);
				}
				else
				{
					value.Position = 0L;
				}
				send(opcode, value, _compression != CompressionMethod.None);
			}
			catch (Exception ex)
			{
				_logger.Error(ex.ToString());
			}
		}
	}

	public void Accept()
	{
		if (!checkIfAvailable(client: false, server: true, connecting: true, open: false, closing: false, closed: false, out var text))
		{
			_logger.Error(text);
			error("An error has occurred in accepting.", null);
		}
		else if (accept())
		{
			open();
		}
	}

	public void AcceptAsync()
	{
		if (!checkIfAvailable(client: false, server: true, connecting: true, open: false, closing: false, closed: false, out var text))
		{
			_logger.Error(text);
			error("An error has occurred in accepting.", null);
			return;
		}
		Func<bool> acceptor = accept;
		acceptor.BeginInvoke(delegate(IAsyncResult ar)
		{
			if (acceptor.EndInvoke(ar))
			{
				open();
			}
		}, null);
	}

	public void Close()
	{
		if (!checkIfAvailable(connecting: true, open: true, closing: false, closed: false, out var text))
		{
			_logger.Error(text);
			error("An error has occurred in closing the connection.", null);
		}
		else
		{
			close(new CloseEventArgs(), send: true, receive: true, received: false);
		}
	}

	public void Close(ushort code)
	{
		if (!checkIfAvailable(connecting: true, open: true, closing: false, closed: false, out var text))
		{
			_logger.Error(text);
			error("An error has occurred in closing the connection.", null);
		}
		else if (!CheckParametersForClose(code, null, _client, out text))
		{
			_logger.Error(text);
			error("An error has occurred in closing the connection.", null);
		}
		else
		{
			close(code, null);
		}
	}

	public void Close(CloseStatusCode code)
	{
		if (!checkIfAvailable(connecting: true, open: true, closing: false, closed: false, out var text))
		{
			_logger.Error(text);
			error("An error has occurred in closing the connection.", null);
		}
		else if (!CheckParametersForClose(code, null, _client, out text))
		{
			_logger.Error(text);
			error("An error has occurred in closing the connection.", null);
		}
		else
		{
			close((ushort)code, null);
		}
	}

	public void Close(ushort code, string reason)
	{
		if (!checkIfAvailable(connecting: true, open: true, closing: false, closed: false, out var text))
		{
			_logger.Error(text);
			error("An error has occurred in closing the connection.", null);
		}
		else if (!CheckParametersForClose(code, reason, _client, out text))
		{
			_logger.Error(text);
			error("An error has occurred in closing the connection.", null);
		}
		else
		{
			close(code, reason);
		}
	}

	public void Close(CloseStatusCode code, string reason)
	{
		if (!checkIfAvailable(connecting: true, open: true, closing: false, closed: false, out var text))
		{
			_logger.Error(text);
			error("An error has occurred in closing the connection.", null);
		}
		else if (!CheckParametersForClose(code, reason, _client, out text))
		{
			_logger.Error(text);
			error("An error has occurred in closing the connection.", null);
		}
		else
		{
			close((ushort)code, reason);
		}
	}

	public void CloseAsync()
	{
		if (!checkIfAvailable(connecting: true, open: true, closing: false, closed: false, out var text))
		{
			_logger.Error(text);
			error("An error has occurred in closing the connection.", null);
		}
		else
		{
			closeAsync(new CloseEventArgs(), send: true, receive: true, received: false);
		}
	}

	public void CloseAsync(ushort code)
	{
		if (!checkIfAvailable(connecting: true, open: true, closing: false, closed: false, out var text))
		{
			_logger.Error(text);
			error("An error has occurred in closing the connection.", null);
		}
		else if (!CheckParametersForClose(code, null, _client, out text))
		{
			_logger.Error(text);
			error("An error has occurred in closing the connection.", null);
		}
		else
		{
			closeAsync(code, null);
		}
	}

	public void CloseAsync(CloseStatusCode code)
	{
		if (!checkIfAvailable(connecting: true, open: true, closing: false, closed: false, out var text))
		{
			_logger.Error(text);
			error("An error has occurred in closing the connection.", null);
		}
		else if (!CheckParametersForClose(code, null, _client, out text))
		{
			_logger.Error(text);
			error("An error has occurred in closing the connection.", null);
		}
		else
		{
			closeAsync((ushort)code, null);
		}
	}

	public void CloseAsync(ushort code, string reason)
	{
		if (!checkIfAvailable(connecting: true, open: true, closing: false, closed: false, out var text))
		{
			_logger.Error(text);
			error("An error has occurred in closing the connection.", null);
		}
		else if (!CheckParametersForClose(code, reason, _client, out text))
		{
			_logger.Error(text);
			error("An error has occurred in closing the connection.", null);
		}
		else
		{
			closeAsync(code, reason);
		}
	}

	public void CloseAsync(CloseStatusCode code, string reason)
	{
		if (!checkIfAvailable(connecting: true, open: true, closing: false, closed: false, out var text))
		{
			_logger.Error(text);
			error("An error has occurred in closing the connection.", null);
		}
		else if (!CheckParametersForClose(code, reason, _client, out text))
		{
			_logger.Error(text);
			error("An error has occurred in closing the connection.", null);
		}
		else
		{
			closeAsync((ushort)code, reason);
		}
	}

	public void Connect()
	{
		if (!checkIfAvailable(client: true, server: false, connecting: true, open: false, closing: false, closed: true, out var text))
		{
			_logger.Error(text);
			error("An error has occurred in connecting.", null);
		}
		else if (connect())
		{
			open();
		}
	}

	public void ConnectAsync()
	{
		if (!checkIfAvailable(client: true, server: false, connecting: true, open: false, closing: false, closed: true, out var text))
		{
			_logger.Error(text);
			error("An error has occurred in connecting.", null);
			return;
		}
		Func<bool> connector = connect;
		connector.BeginInvoke(delegate(IAsyncResult ar)
		{
			if (connector.EndInvoke(ar))
			{
				open();
			}
		}, null);
	}

	public bool Ping()
	{
		byte[] frameAsBytes = (_client ? WebSocketFrame.CreatePingFrame(mask: true).ToArray() : WebSocketFrame.EmptyPingBytes);
		return Ping(frameAsBytes, _waitTime);
	}

	public bool Ping(string message)
	{
		if (message == null || message.Length == 0)
		{
			return Ping();
		}
		byte[] bytes;
		string text = CheckPingParameter(message, out bytes);
		if (text != null)
		{
			_logger.Error(text);
			error("An error has occurred in sending a ping.", null);
			return false;
		}
		return Ping(WebSocketFrame.CreatePingFrame(bytes, _client).ToArray(), _waitTime);
	}

	public void Send(byte[] data)
	{
		string text = _readyState.CheckIfAvailable(connecting: false, open: true, closing: false, closed: false) ?? CheckSendParameter(data);
		if (text != null)
		{
			_logger.Error(text);
			error("An error has occurred in sending data.", null);
		}
		else
		{
			send(Opcode.Binary, new MemoryStream(data));
		}
	}

	public void Send(FileInfo file)
	{
		string text = _readyState.CheckIfAvailable(connecting: false, open: true, closing: false, closed: false) ?? CheckSendParameter(file);
		if (text != null)
		{
			_logger.Error(text);
			error("An error has occurred in sending data.", null);
		}
		else
		{
			send(Opcode.Binary, file.OpenRead());
		}
	}

	public void Send(string data)
	{
		string text = _readyState.CheckIfAvailable(connecting: false, open: true, closing: false, closed: false) ?? CheckSendParameter(data);
		if (text != null)
		{
			_logger.Error(text);
			error("An error has occurred in sending data.", null);
		}
		else
		{
			send(Opcode.Text, new MemoryStream(data.UTF8Encode()));
		}
	}

	public void SendAsync(byte[] data, Action<bool> completed)
	{
		string text = _readyState.CheckIfAvailable(connecting: false, open: true, closing: false, closed: false) ?? CheckSendParameter(data);
		if (text != null)
		{
			_logger.Error(text);
			error("An error has occurred in sending data.", null);
		}
		else
		{
			sendAsync(Opcode.Binary, new MemoryStream(data), completed);
		}
	}

	public void SendAsync(FileInfo file, Action<bool> completed)
	{
		string text = _readyState.CheckIfAvailable(connecting: false, open: true, closing: false, closed: false) ?? CheckSendParameter(file);
		if (text != null)
		{
			_logger.Error(text);
			error("An error has occurred in sending data.", null);
		}
		else
		{
			sendAsync(Opcode.Binary, file.OpenRead(), completed);
		}
	}

	public void SendAsync(string data, Action<bool> completed)
	{
		string text = _readyState.CheckIfAvailable(connecting: false, open: true, closing: false, closed: false) ?? CheckSendParameter(data);
		if (text != null)
		{
			_logger.Error(text);
			error("An error has occurred in sending data.", null);
		}
		else
		{
			sendAsync(Opcode.Text, new MemoryStream(data.UTF8Encode()), completed);
		}
	}

	public void SendAsync(Stream stream, int length, Action<bool> completed)
	{
		string text = _readyState.CheckIfAvailable(connecting: false, open: true, closing: false, closed: false) ?? CheckSendParameters(stream, length);
		if (text != null)
		{
			_logger.Error(text);
			error("An error has occurred in sending data.", null);
			return;
		}
		stream.ReadBytesAsync(length, delegate(byte[] data)
		{
			int num = data.Length;
			if (num == 0)
			{
				_logger.Error("The data cannot be read from 'stream'.");
				error("An error has occurred in sending data.", null);
			}
			else
			{
				if (num < length)
				{
					_logger.Warn($"The length of the data is less than 'length':\n  expected: {length}\n  actual: {num}");
				}
				bool obj = send(Opcode.Binary, new MemoryStream(data));
				if (completed != null)
				{
					completed(obj);
				}
			}
		}, delegate(Exception ex)
		{
			_logger.Error(ex.ToString());
			error("An exception has occurred while sending data.", ex);
		});
	}

	public void SetCookie(Cookie cookie)
	{
		if (!checkIfAvailable(client: true, server: false, connecting: true, open: false, closing: false, closed: true, out var text))
		{
			_logger.Error(text);
			error("An error has occurred in setting a cookie.", null);
			return;
		}
		if (cookie == null)
		{
			_logger.Error("'cookie' is null.");
			error("An error has occurred in setting a cookie.", null);
			return;
		}
		lock (_forState)
		{
			if (!checkIfAvailable(connecting: true, open: false, closing: false, closed: true, out text))
			{
				_logger.Error(text);
				error("An error has occurred in setting a cookie.", null);
				return;
			}
			lock (_cookies.SyncRoot)
			{
				_cookies.SetOrRemove(cookie);
			}
		}
	}

	public void SetCredentials(string username, string password, bool preAuth)
	{
		if (!checkIfAvailable(client: true, server: false, connecting: true, open: false, closing: false, closed: true, out var text))
		{
			_logger.Error(text);
			error("An error has occurred in setting the credentials.", null);
			return;
		}
		if (!checkParametersForSetCredentials(username, password, out text))
		{
			_logger.Error(text);
			error("An error has occurred in setting the credentials.", null);
			return;
		}
		lock (_forState)
		{
			if (!checkIfAvailable(connecting: true, open: false, closing: false, closed: true, out text))
			{
				_logger.Error(text);
				error("An error has occurred in setting the credentials.", null);
			}
			else if (username.IsNullOrEmpty())
			{
				_logger.Warn("The credentials are initialized.");
				_credentials = null;
				_preAuth = false;
			}
			else
			{
				_credentials = new NetworkCredential(username, password, _uri.PathAndQuery);
				_preAuth = preAuth;
			}
		}
	}

	public void SetProxy(string url, string username, string password)
	{
		if (!checkIfAvailable(client: true, server: false, connecting: true, open: false, closing: false, closed: true, out var text))
		{
			_logger.Error(text);
			error("An error has occurred in setting the proxy.", null);
			return;
		}
		if (!checkParametersForSetProxy(url, username, password, out text))
		{
			_logger.Error(text);
			error("An error has occurred in setting the proxy.", null);
			return;
		}
		lock (_forState)
		{
			if (!checkIfAvailable(connecting: true, open: false, closing: false, closed: true, out text))
			{
				_logger.Error(text);
				error("An error has occurred in setting the proxy.", null);
				return;
			}
			if (url.IsNullOrEmpty())
			{
				_logger.Warn("The url and credentials for the proxy are initialized.");
				_proxyUri = null;
				_proxyCredentials = null;
				return;
			}
			_proxyUri = new Uri(url);
			if (username.IsNullOrEmpty())
			{
				_logger.Warn("The credentials for the proxy are initialized.");
				_proxyCredentials = null;
			}
			else
			{
				_proxyCredentials = new NetworkCredential(username, password, $"{_uri.DnsSafeHost}:{_uri.Port}");
			}
		}
	}

	void IDisposable.Dispose()
	{
		close(new CloseEventArgs(1001), send: true, receive: true, received: false);
	}
}


public enum CloseStatusCode : ushort
{
	Normal = 1000,
	Away = 1001,
	ProtocolError = 1002,
	UnsupportedData = 1003,
	Undefined = 1004,
	NoStatus = 1005,
	Abnormal = 1006,
	InvalidData = 1007,
	PolicyViolation = 1008,
	TooBig = 1009,
	MandatoryExtension = 1010,
	ServerError = 1011,
	TlsHandshakeFailure = 1015
}


internal enum Fin : byte
{
	More,
	Final
}


internal enum Mask : byte
{
	Off,
	On
}


public enum Opcode : byte
{
	Cont = 0,
	Text = 1,
	Binary = 2,
	Close = 8,
	Ping = 9,
	Pong = 10
}


using System;
using System.Collections;
using System.Collections.Generic;
using WebSocketSharp;

internal class PayloadData : IEnumerable<byte>, IEnumerable
{
	private ushort _code;

	private bool _codeSet;

	private byte[] _data;

	private long _extDataLength;

	private long _length;

	private string _reason;

	private bool _reasonSet;

	public static readonly PayloadData Empty;

	public static readonly ulong MaxLength;

	internal ushort Code
	{
		get
		{
			if (!_codeSet)
			{
				_code = (ushort)((_length > 1) ? _data.SubArray(0, 2).ToUInt16(ByteOrder.Big) : 1005);
				_codeSet = true;
			}
			return _code;
		}
	}

	internal long ExtensionDataLength
	{
		get
		{
			return _extDataLength;
		}
		set
		{
			_extDataLength = value;
		}
	}

	internal bool HasReservedCode => _length > 1 && Code.IsReserved();

	internal string Reason
	{
		get
		{
			if (!_reasonSet)
			{
				_reason = ((_length > 2) ? _data.SubArray(2L, _length - 2).UTF8Decode() : string.Empty);
				_reasonSet = true;
			}
			return _reason;
		}
	}

	public byte[] ApplicationData => (_extDataLength > 0) ? _data.SubArray(_extDataLength, _length - _extDataLength) : _data;

	public byte[] ExtensionData => (_extDataLength > 0) ? _data.SubArray(0L, _extDataLength) : WebSocket.EmptyBytes;

	public ulong Length => (ulong)_length;

	static PayloadData()
	{
		Empty = new PayloadData();
		MaxLength = 9223372036854775807uL;
	}

	internal PayloadData()
	{
		_code = 1005;
		_reason = string.Empty;
		_data = WebSocket.EmptyBytes;
		_codeSet = true;
		_reasonSet = true;
	}

	internal PayloadData(byte[] data)
		: this(data, data.LongLength)
	{
	}

	internal PayloadData(byte[] data, long length)
	{
		_data = data;
		_length = length;
	}

	internal PayloadData(ushort code, string reason)
	{
		_code = code;
		_reason = reason ?? string.Empty;
		_data = code.Append(reason);
		_length = _data.LongLength;
		_codeSet = true;
		_reasonSet = true;
	}

	internal void Mask(byte[] key)
	{
		for (long num = 0L; num < _length; num++)
		{
			_data[num] ^= key[num % 4];
		}
	}

	public IEnumerator<byte> GetEnumerator()
	{
		byte[] data = _data;
		for (int i = 0; i < data.Length; i++)
		{
			yield return data[i];
		}
	}

	public byte[] ToArray()
	{
		return _data;
	}

	public override string ToString()
	{
		return BitConverter.ToString(_data);
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


internal enum Rsv : byte
{
	Off,
	On
}


public enum CompressionMethod : byte
{
	None,
	Deflate
}


using System;
using WebSocketSharp;

public class WebSocketException : Exception
{
	private CloseStatusCode _code;

	public CloseStatusCode Code => _code;

	internal WebSocketException()
		: this(CloseStatusCode.Abnormal, null, null)
	{
	}

	internal WebSocketException(Exception innerException)
		: this(CloseStatusCode.Abnormal, null, innerException)
	{
	}

	internal WebSocketException(string message)
		: this(CloseStatusCode.Abnormal, message, null)
	{
	}

	internal WebSocketException(CloseStatusCode code)
		: this(code, null, null)
	{
	}

	internal WebSocketException(string message, Exception innerException)
		: this(CloseStatusCode.Abnormal, message, innerException)
	{
	}

	internal WebSocketException(CloseStatusCode code, Exception innerException)
		: this(code, null, innerException)
	{
	}

	internal WebSocketException(CloseStatusCode code, string message)
		: this(code, message, null)
	{
	}

	internal WebSocketException(CloseStatusCode code, string message, Exception innerException)
		: base(message ?? code.GetMessage(), innerException)
	{
		_code = code;
	}
}


using System;
using System.Diagnostics;
using System.Reflection;
using System.Text;
using WebSocketSharp;

public class LogData
{
	private StackFrame _caller;

	private DateTime _date;

	private LogLevel _level;

	private string _message;

	public StackFrame Caller => _caller;

	public DateTime Date => _date;

	public LogLevel Level => _level;

	public string Message => _message;

	internal LogData(LogLevel level, StackFrame caller, string message)
	{
		_level = level;
		_caller = caller;
		_message = message ?? string.Empty;
		_date = DateTime.Now;
	}

	public override string ToString()
	{
		string text = $"{_date}|{_level,-5}|";
		MethodBase method = _caller.GetMethod();
		Type declaringType = method.DeclaringType;
		string arg = $"{text}{declaringType.Name}.{method.Name}|";
		string[] array = _message.Replace("\r\n", "\n").TrimEnd(new char[1] { '\n' }).Split(new char[1] { '\n' });
		if (array.Length <= 1)
		{
			return $"{arg}{_message}";
		}
		StringBuilder stringBuilder = new StringBuilder($"{arg}{array[0]}\n", 64);
		string format = $"{{0,{text.Length}}}{{1}}\n";
		for (int i = 1; i < array.Length; i++)
		{
			stringBuilder.AppendFormat(format, "", array[i]);
		}
		stringBuilder.Length--;
		return stringBuilder.ToString();
	}
}


public enum LogLevel
{
	Trace,
	Debug,
	Info,
	Warn,
	Error,
	Fatal
}


using System;
using System.Diagnostics;
using System.IO;
using WebSocketSharp;

public class Logger
{
	private volatile string _file;

	private volatile LogLevel _level;

	private Action<LogData, string> _output;

	private object _sync;

	public string File
	{
		get
		{
			return _file;
		}
		set
		{
			lock (_sync)
			{
				_file = value;
				Warn($"The current path to the log file has been changed to {_file}.");
			}
		}
	}

	public LogLevel Level
	{
		get
		{
			return _level;
		}
		set
		{
			lock (_sync)
			{
				_level = value;
				Warn($"The current logging level has been changed to {_level}.");
			}
		}
	}

	public Action<LogData, string> Output
	{
		get
		{
			return _output;
		}
		set
		{
			lock (_sync)
			{
				_output = value ?? new Action<LogData, string>(defaultOutput);
				Warn("The current output action has been changed.");
			}
		}
	}

	public Logger()
		: this(LogLevel.Error, null, null)
	{
	}

	public Logger(LogLevel level)
		: this(level, null, null)
	{
	}

	public Logger(LogLevel level, string file, Action<LogData, string> output)
	{
		_level = level;
		_file = file;
		_output = output ?? new Action<LogData, string>(defaultOutput);
		_sync = new object();
	}

	private static void defaultOutput(LogData data, string path)
	{
		string value = data.ToString();
		Console.WriteLine(value);
		if (path != null && path.Length > 0)
		{
			writeToFile(value, path);
		}
	}

	private void output(string message, LogLevel level)
	{
		lock (_sync)
		{
			if (_level > level)
			{
				return;
			}
			LogData logData = null;
			try
			{
				logData = new LogData(level, new StackFrame(2, needFileInfo: true), message);
				_output(logData, _file);
			}
			catch (Exception ex)
			{
				logData = new LogData(LogLevel.Fatal, new StackFrame(0, needFileInfo: true), ex.Message);
				Console.WriteLine(logData.ToString());
			}
		}
	}

	private static void writeToFile(string value, string path)
	{
		using StreamWriter writer = new StreamWriter(path, append: true);
		using TextWriter textWriter = TextWriter.Synchronized(writer);
		textWriter.WriteLine(value);
	}

	public void Debug(string message)
	{
		if (_level <= LogLevel.Debug)
		{
			output(message, LogLevel.Debug);
		}
	}

	public void Error(string message)
	{
		if (_level <= LogLevel.Error)
		{
			output(message, LogLevel.Error);
		}
	}

	public void Fatal(string message)
	{
		output(message, LogLevel.Fatal);
	}

	public void Info(string message)
	{
		if (_level <= LogLevel.Info)
		{
			output(message, LogLevel.Info);
		}
	}

	public void Trace(string message)
	{
		if (_level <= LogLevel.Trace)
		{
			output(message, LogLevel.Trace);
		}
	}

	public void Warn(string message)
	{
		if (_level <= LogLevel.Warn)
		{
			output(message, LogLevel.Warn);
		}
	}
}


public enum WebSocketState : ushort
{
	Connecting,
	Open,
	Closing,
	Closed
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text;
using WebSocketSharp;

internal class WebSocketFrame : IEnumerable<byte>, IEnumerable
{
	private byte[] _extPayloadLength;

	private Fin _fin;

	private Mask _mask;

	private byte[] _maskingKey;

	private Opcode _opcode;

	private PayloadData _payloadData;

	private byte _payloadLength;

	private Rsv _rsv1;

	private Rsv _rsv2;

	private Rsv _rsv3;

	internal static readonly byte[] EmptyPingBytes;

	internal int ExtendedPayloadLengthCount => (_payloadLength >= 126) ? ((_payloadLength == 126) ? 2 : 8) : 0;

	internal ulong FullPayloadLength => (_payloadLength < 126) ? _payloadLength : ((_payloadLength == 126) ? _extPayloadLength.ToUInt16(ByteOrder.Big) : _extPayloadLength.ToUInt64(ByteOrder.Big));

	public byte[] ExtendedPayloadLength => _extPayloadLength;

	public Fin Fin => _fin;

	public bool IsBinary => _opcode == Opcode.Binary;

	public bool IsClose => _opcode == Opcode.Close;

	public bool IsCompressed => _rsv1 == Rsv.On;

	public bool IsContinuation => _opcode == Opcode.Cont;

	public bool IsControl => (int)_opcode >= 8;

	public bool IsData => _opcode == Opcode.Text || _opcode == Opcode.Binary;

	public bool IsFinal => _fin == Fin.Final;

	public bool IsFragment => _fin == Fin.More || _opcode == Opcode.Cont;

	public bool IsMasked => _mask == Mask.On;

	public bool IsPing => _opcode == Opcode.Ping;

	public bool IsPong => _opcode == Opcode.Pong;

	public bool IsText => _opcode == Opcode.Text;

	public ulong Length => (ulong)(2L + (long)(_extPayloadLength.Length + _maskingKey.Length)) + _payloadData.Length;

	public Mask Mask => _mask;

	public byte[] MaskingKey => _maskingKey;

	public Opcode Opcode => _opcode;

	public PayloadData PayloadData => _payloadData;

	public byte PayloadLength => _payloadLength;

	public Rsv Rsv1 => _rsv1;

	public Rsv Rsv2 => _rsv2;

	public Rsv Rsv3 => _rsv3;

	static WebSocketFrame()
	{
		EmptyPingBytes = CreatePingFrame(mask: false).ToArray();
	}

	private WebSocketFrame()
	{
	}

	internal WebSocketFrame(Opcode opcode, PayloadData payloadData, bool mask)
		: this(Fin.Final, opcode, payloadData, compressed: false, mask)
	{
	}

	internal WebSocketFrame(Fin fin, Opcode opcode, byte[] data, bool compressed, bool mask)
		: this(fin, opcode, new PayloadData(data), compressed, mask)
	{
	}

	internal WebSocketFrame(Fin fin, Opcode opcode, PayloadData payloadData, bool compressed, bool mask)
	{
		_fin = fin;
		_rsv1 = ((opcode.IsData() && compressed) ? Rsv.On : Rsv.Off);
		_rsv2 = Rsv.Off;
		_rsv3 = Rsv.Off;
		_opcode = opcode;
		ulong length = payloadData.Length;
		if (length < 126)
		{
			_payloadLength = (byte)length;
			_extPayloadLength = WebSocket.EmptyBytes;
		}
		else if (length < 65536)
		{
			_payloadLength = 126;
			_extPayloadLength = ((ushort)length).InternalToByteArray(ByteOrder.Big);
		}
		else
		{
			_payloadLength = 127;
			_extPayloadLength = length.InternalToByteArray(ByteOrder.Big);
		}
		if (mask)
		{
			_mask = Mask.On;
			_maskingKey = createMaskingKey();
			payloadData.Mask(_maskingKey);
		}
		else
		{
			_mask = Mask.Off;
			_maskingKey = WebSocket.EmptyBytes;
		}
		_payloadData = payloadData;
	}

	private static byte[] createMaskingKey()
	{
		byte[] array = new byte[4];
		WebSocket.RandomNumber.GetBytes(array);
		return array;
	}

	private static string dump(WebSocketFrame frame)
	{
		ulong length = frame.Length;
		long num = (long)(length / 4);
		int num2 = (int)(length % 4);
		int num3;
		string arg5;
		if (num < 10000)
		{
			num3 = 4;
			arg5 = "{0,4}";
		}
		else if (num < 65536)
		{
			num3 = 4;
			arg5 = "{0,4:X}";
		}
		else if (num < 4294967296L)
		{
			num3 = 8;
			arg5 = "{0,8:X}";
		}
		else
		{
			num3 = 16;
			arg5 = "{0,16:X}";
		}
		string arg6 = $"{{0,{num3}}}";
		string format = string.Format("\r\n{0} 01234567 89ABCDEF 01234567 89ABCDEF\r\n{0}+--------+--------+--------+--------+\\n", arg6);
		string lineFmt = $"{arg5}|{{1,8}} {{2,8}} {{3,8}} {{4,8}}|\n";
		string format2 = $"{arg6}+--------+--------+--------+--------+";
		StringBuilder output = new StringBuilder(64);
		Func<Action<string, string, string, string>> func = delegate
		{
			long lineCnt = 0L;
			return delegate(string arg1, string arg2, string arg3, string arg4)
			{
				output.AppendFormat(lineFmt, ++lineCnt, arg1, arg2, arg3, arg4);
			};
		};
		Action<string, string, string, string> action = func();
		output.AppendFormat(format, string.Empty);
		byte[] array = frame.ToArray();
		for (long num4 = 0L; num4 <= num; num4++)
		{
			long num5 = num4 * 4;
			if (num4 < num)
			{
				action(Convert.ToString(array[num5], 2).PadLeft(8, '0'), Convert.ToString(array[num5 + 1], 2).PadLeft(8, '0'), Convert.ToString(array[num5 + 2], 2).PadLeft(8, '0'), Convert.ToString(array[num5 + 3], 2).PadLeft(8, '0'));
			}
			else if (num2 > 0)
			{
				action(Convert.ToString(array[num5], 2).PadLeft(8, '0'), (num2 >= 2) ? Convert.ToString(array[num5 + 1], 2).PadLeft(8, '0') : string.Empty, (num2 == 3) ? Convert.ToString(array[num5 + 2], 2).PadLeft(8, '0') : string.Empty, string.Empty);
			}
		}
		output.AppendFormat(format2, string.Empty);
		return output.ToString();
	}

	private static string print(WebSocketFrame frame)
	{
		byte payloadLength = frame._payloadLength;
		string text = ((payloadLength > 125) ? frame.FullPayloadLength.ToString() : string.Empty);
		string text2 = BitConverter.ToString(frame._maskingKey);
		string text3 = ((payloadLength == 0) ? string.Empty : ((payloadLength > 125) ? "---" : ((frame.IsText && !frame.IsFragment && !frame.IsMasked && !frame.IsCompressed) ? frame._payloadData.ApplicationData.UTF8Decode() : frame._payloadData.ToString())));
		string format = "\r\n                    FIN: {0}\r\n                   RSV1: {1}\r\n                   RSV2: {2}\r\n                   RSV3: {3}\r\n                 Opcode: {4}\r\n                   MASK: {5}\r\n         Payload Length: {6}\r\nExtended Payload Length: {7}\r\n            Masking Key: {8}\r\n           Payload Data: {9}";
		return string.Format(format, frame._fin, frame._rsv1, frame._rsv2, frame._rsv3, frame._opcode, frame._mask, payloadLength, text, text2, text3);
	}

	private static WebSocketFrame processHeader(byte[] header)
	{
		if (header.Length != 2)
		{
			throw new WebSocketException("The header of a frame cannot be read from the stream.");
		}
		Fin fin = (((header[0] & 0x80) == 128) ? Fin.Final : Fin.More);
		Rsv rsv = (((header[0] & 0x40) == 64) ? Rsv.On : Rsv.Off);
		Rsv rsv2 = (((header[0] & 0x20) == 32) ? Rsv.On : Rsv.Off);
		Rsv rsv3 = (((header[0] & 0x10) == 16) ? Rsv.On : Rsv.Off);
		byte opcode = (byte)(header[0] & 0xF);
		Mask mask = (((header[1] & 0x80) == 128) ? Mask.On : Mask.Off);
		byte b = (byte)(header[1] & 0x7F);
		string text = ((!opcode.IsSupported()) ? "An unsupported opcode." : ((!opcode.IsData() && rsv == Rsv.On) ? "A non data frame is compressed." : ((opcode.IsControl() && fin == Fin.More) ? "A control frame is fragmented." : ((opcode.IsControl() && b > 125) ? "A control frame has a long payload length." : null))));
		if (text != null)
		{
			throw new WebSocketException(CloseStatusCode.ProtocolError, text);
		}
		WebSocketFrame webSocketFrame = new WebSocketFrame();
		webSocketFrame._fin = fin;
		webSocketFrame._rsv1 = rsv;
		webSocketFrame._rsv2 = rsv2;
		webSocketFrame._rsv3 = rsv3;
		webSocketFrame._opcode = (Opcode)opcode;
		webSocketFrame._mask = mask;
		webSocketFrame._payloadLength = b;
		return webSocketFrame;
	}

	private static WebSocketFrame readExtendedPayloadLength(Stream stream, WebSocketFrame frame)
	{
		int extendedPayloadLengthCount = frame.ExtendedPayloadLengthCount;
		if (extendedPayloadLengthCount == 0)
		{
			frame._extPayloadLength = WebSocket.EmptyBytes;
			return frame;
		}
		byte[] array = stream.ReadBytes(extendedPayloadLengthCount);
		if (array.Length != extendedPayloadLengthCount)
		{
			throw new WebSocketException("The extended payload length of a frame cannot be read from the stream.");
		}
		frame._extPayloadLength = array;
		return frame;
	}

	private static void readExtendedPayloadLengthAsync(Stream stream, WebSocketFrame frame, Action<WebSocketFrame> completed, Action<Exception> error)
	{
		int len = frame.ExtendedPayloadLengthCount;
		if (len == 0)
		{
			frame._extPayloadLength = WebSocket.EmptyBytes;
			completed(frame);
			return;
		}
		stream.ReadBytesAsync(len, delegate(byte[] bytes)
		{
			if (bytes.Length != len)
			{
				throw new WebSocketException("The extended payload length of a frame cannot be read from the stream.");
			}
			frame._extPayloadLength = bytes;
			completed(frame);
		}, error);
	}

	private static WebSocketFrame readHeader(Stream stream)
	{
		return processHeader(stream.ReadBytes(2));
	}

	private static void readHeaderAsync(Stream stream, Action<WebSocketFrame> completed, Action<Exception> error)
	{
		stream.ReadBytesAsync(2, delegate(byte[] bytes)
		{
			completed(processHeader(bytes));
		}, error);
	}

	private static WebSocketFrame readMaskingKey(Stream stream, WebSocketFrame frame)
	{
		int num = (frame.IsMasked ? 4 : 0);
		if (num == 0)
		{
			frame._maskingKey = WebSocket.EmptyBytes;
			return frame;
		}
		byte[] array = stream.ReadBytes(num);
		if (array.Length != num)
		{
			throw new WebSocketException("The masking key of a frame cannot be read from the stream.");
		}
		frame._maskingKey = array;
		return frame;
	}

	private static void readMaskingKeyAsync(Stream stream, WebSocketFrame frame, Action<WebSocketFrame> completed, Action<Exception> error)
	{
		int len = (frame.IsMasked ? 4 : 0);
		if (len == 0)
		{
			frame._maskingKey = WebSocket.EmptyBytes;
			completed(frame);
			return;
		}
		stream.ReadBytesAsync(len, delegate(byte[] bytes)
		{
			if (bytes.Length != len)
			{
				throw new WebSocketException("The masking key of a frame cannot be read from the stream.");
			}
			frame._maskingKey = bytes;
			completed(frame);
		}, error);
	}

	private static WebSocketFrame readPayloadData(Stream stream, WebSocketFrame frame)
	{
		ulong fullPayloadLength = frame.FullPayloadLength;
		if (fullPayloadLength == 0)
		{
			frame._payloadData = PayloadData.Empty;
			return frame;
		}
		if (fullPayloadLength > PayloadData.MaxLength)
		{
			throw new WebSocketException(CloseStatusCode.TooBig, "A frame has a long payload length.");
		}
		long num = (long)fullPayloadLength;
		byte[] array = ((frame._payloadLength < 127) ? stream.ReadBytes((int)fullPayloadLength) : stream.ReadBytes(num, 1024));
		if (array.LongLength != num)
		{
			throw new WebSocketException("The payload data of a frame cannot be read from the stream.");
		}
		frame._payloadData = new PayloadData(array, num);
		return frame;
	}

	private static void readPayloadDataAsync(Stream stream, WebSocketFrame frame, Action<WebSocketFrame> completed, Action<Exception> error)
	{
		ulong fullPayloadLength = frame.FullPayloadLength;
		if (fullPayloadLength == 0)
		{
			frame._payloadData = PayloadData.Empty;
			completed(frame);
			return;
		}
		if (fullPayloadLength > PayloadData.MaxLength)
		{
			throw new WebSocketException(CloseStatusCode.TooBig, "A frame has a long payload length.");
		}
		long llen = (long)fullPayloadLength;
		Action<byte[]> completed2 = delegate(byte[] bytes)
		{
			if (bytes.LongLength != llen)
			{
				throw new WebSocketException("The payload data of a frame cannot be read from the stream.");
			}
			frame._payloadData = new PayloadData(bytes, llen);
			completed(frame);
		};
		if (frame._payloadLength < 127)
		{
			stream.ReadBytesAsync((int)fullPayloadLength, completed2, error);
		}
		else
		{
			stream.ReadBytesAsync(llen, 1024, completed2, error);
		}
	}

	internal static WebSocketFrame CreateCloseFrame(PayloadData payloadData, bool mask)
	{
		return new WebSocketFrame(Fin.Final, Opcode.Close, payloadData, compressed: false, mask);
	}

	internal static WebSocketFrame CreatePingFrame(bool mask)
	{
		return new WebSocketFrame(Fin.Final, Opcode.Ping, PayloadData.Empty, compressed: false, mask);
	}

	internal static WebSocketFrame CreatePingFrame(byte[] data, bool mask)
	{
		return new WebSocketFrame(Fin.Final, Opcode.Ping, new PayloadData(data), compressed: false, mask);
	}

	internal static WebSocketFrame ReadFrame(Stream stream, bool unmask)
	{
		WebSocketFrame webSocketFrame = readHeader(stream);
		readExtendedPayloadLength(stream, webSocketFrame);
		readMaskingKey(stream, webSocketFrame);
		readPayloadData(stream, webSocketFrame);
		if (unmask)
		{
			webSocketFrame.Unmask();
		}
		return webSocketFrame;
	}

	internal static void ReadFrameAsync(Stream stream, bool unmask, Action<WebSocketFrame> completed, Action<Exception> error)
	{
		readHeaderAsync(stream, delegate(WebSocketFrame frame)
		{
			readExtendedPayloadLengthAsync(stream, frame, delegate(WebSocketFrame frame1)
			{
				readMaskingKeyAsync(stream, frame1, delegate(WebSocketFrame frame2)
				{
					readPayloadDataAsync(stream, frame2, delegate(WebSocketFrame frame3)
					{
						if (unmask)
						{
							frame3.Unmask();
						}
						completed(frame3);
					}, error);
				}, error);
			}, error);
		}, error);
	}

	internal void Unmask()
	{
		if (_mask != 0)
		{
			_mask = Mask.Off;
			_payloadData.Mask(_maskingKey);
			_maskingKey = WebSocket.EmptyBytes;
		}
	}

	public IEnumerator<byte> GetEnumerator()
	{
		byte[] array = ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			yield return array[i];
		}
	}

	public void Print(bool dumped)
	{
		Console.WriteLine(dumped ? dump(this) : print(this));
	}

	public string PrintToString(bool dumped)
	{
		return dumped ? dump(this) : print(this);
	}

	public byte[] ToArray()
	{
		using MemoryStream memoryStream = new MemoryStream();
		int fin = (int)_fin;
		fin = (fin << 1) + (int)_rsv1;
		fin = (fin << 1) + (int)_rsv2;
		fin = (fin << 1) + (int)_rsv3;
		fin = (fin << 4) + (int)_opcode;
		fin = (fin << 1) + (int)_mask;
		fin = (fin << 7) + _payloadLength;
		memoryStream.Write(((ushort)fin).InternalToByteArray(ByteOrder.Big), 0, 2);
		if (_payloadLength > 125)
		{
			memoryStream.Write(_extPayloadLength, 0, (_payloadLength == 126) ? 2 : 8);
		}
		if (_mask == Mask.On)
		{
			memoryStream.Write(_maskingKey, 0, 4);
		}
		if (_payloadLength > 0)
		{
			byte[] array = _payloadData.ToArray();
			if (_payloadLength < 127)
			{
				memoryStream.Write(array, 0, array.Length);
			}
			else
			{
				memoryStream.WriteBytes(array, 1024);
			}
		}
		memoryStream.Close();
		return memoryStream.ToArray();
	}

	public override string ToString()
	{
		return BitConverter.ToString(ToArray());
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Text;
using System.Threading;
using WebSocketSharp;
using WebSocketSharp.Net;

internal abstract class HttpBase
{
	private NameValueCollection _headers;

	private const int _headersMaxLength = 8192;

	private Version _version;

	internal byte[] EntityBodyData;

	protected const string CrLf = "\r\n";

	public string EntityBody
	{
		get
		{
			if (EntityBodyData == null || EntityBodyData.LongLength == 0)
			{
				return string.Empty;
			}
			Encoding encoding = null;
			string text = _headers["Content-Type"];
			if (text != null && text.Length > 0)
			{
				encoding = HttpUtility.GetEncoding(text);
			}
			return (encoding ?? Encoding.UTF8).GetString(EntityBodyData);
		}
	}

	public NameValueCollection Headers => _headers;

	public Version ProtocolVersion => _version;

	protected HttpBase(Version version, NameValueCollection headers)
	{
		_version = version;
		_headers = headers;
	}

	private static byte[] readEntityBody(Stream stream, string length)
	{
		if (!long.TryParse(length, out var result))
		{
			throw new ArgumentException("Cannot be parsed.", "length");
		}
		if (result < 0)
		{
			throw new ArgumentOutOfRangeException("length", "Less than zero.");
		}
		return (result > 1024) ? stream.ReadBytes(result, 1024) : ((result > 0) ? stream.ReadBytes((int)result) : null);
	}

	private static string[] readHeaders(Stream stream, int maxLength)
	{
		List<byte> buff = new List<byte>();
		int cnt = 0;
		Action<int> action = delegate(int i)
		{
			if (i == -1)
			{
				throw new EndOfStreamException("The header cannot be read from the data source.");
			}
			buff.Add((byte)i);
			cnt++;
		};
		bool flag = false;
		while (cnt < maxLength)
		{
			if (stream.ReadByte().EqualsWith('\r', action) && stream.ReadByte().EqualsWith('\n', action) && stream.ReadByte().EqualsWith('\r', action) && stream.ReadByte().EqualsWith('\n', action))
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			throw new WebSocketException("The length of header part is greater than the max length.");
		}
		return Encoding.UTF8.GetString(buff.ToArray()).Replace("\r\n ", " ").Replace("\r\n\t", " ")
			.Split(new string[1] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries);
	}

	protected static T Read<T>(Stream stream, Func<string[], T> parser, int millisecondsTimeout) where T : HttpBase
	{
		bool timeout = false;
		Timer timer = new Timer(delegate
		{
			timeout = true;
			stream.Close();
		}, null, millisecondsTimeout, -1);
		T val = null;
		Exception ex = null;
		try
		{
			val = parser(readHeaders(stream, 8192));
			string text = val.Headers["Content-Length"];
			if (text != null && text.Length > 0)
			{
				val.EntityBodyData = readEntityBody(stream, text);
			}
		}
		catch (Exception ex2)
		{
			ex = ex2;
		}
		finally
		{
			timer.Change(-1, -1);
			timer.Dispose();
		}
		string text2 = (timeout ? "A timeout has occurred while reading an HTTP request/response." : ((ex != null) ? "An exception has occurred while reading an HTTP request/response." : null));
		if (text2 != null)
		{
			throw new WebSocketException(text2, ex);
		}
		return val;
	}

	public byte[] ToByteArray()
	{
		return Encoding.UTF8.GetBytes(ToString());
	}
}


using System;
using System.Collections.Specialized;
using System.IO;
using System.Text;
using WebSocketSharp;
using WebSocketSharp.Net;

internal class HttpRequest : HttpBase
{
	private string _method;

	private string _uri;

	private bool _websocketRequest;

	private bool _websocketRequestSet;

	public AuthenticationResponse AuthenticationResponse
	{
		get
		{
			string text = base.Headers["Authorization"];
			return (text != null && text.Length > 0) ? AuthenticationResponse.Parse(text) : null;
		}
	}

	public CookieCollection Cookies => base.Headers.GetCookies(response: false);

	public string HttpMethod => _method;

	public bool IsWebSocketRequest
	{
		get
		{
			if (!_websocketRequestSet)
			{
				NameValueCollection headers = base.Headers;
				_websocketRequest = _method == "GET" && base.ProtocolVersion > HttpVersion.Version10 && headers.Contains("Upgrade", "websocket") && headers.Contains("Connection", "Upgrade");
				_websocketRequestSet = true;
			}
			return _websocketRequest;
		}
	}

	public string RequestUri => _uri;

	private HttpRequest(string method, string uri, Version version, NameValueCollection headers)
		: base(version, headers)
	{
		_method = method;
		_uri = uri;
	}

	internal HttpRequest(string method, string uri)
		: this(method, uri, HttpVersion.Version11, new NameValueCollection())
	{
		base.Headers["User-Agent"] = "websocket-sharp/1.0";
	}

	internal static HttpRequest CreateConnectRequest(Uri uri)
	{
		string dnsSafeHost = uri.DnsSafeHost;
		int port = uri.Port;
		string text = $"{dnsSafeHost}:{port}";
		HttpRequest httpRequest = new HttpRequest("CONNECT", text);
		httpRequest.Headers["Host"] = ((port == 80) ? dnsSafeHost : text);
		return httpRequest;
	}

	internal static HttpRequest CreateWebSocketRequest(Uri uri)
	{
		HttpRequest httpRequest = new HttpRequest("GET", uri.PathAndQuery);
		NameValueCollection headers = httpRequest.Headers;
		int port = uri.Port;
		string scheme = uri.Scheme;
		headers["Host"] = (((port == 80 && scheme == "ws") || (port == 443 && scheme == "wss")) ? uri.DnsSafeHost : uri.Authority);
		headers["Upgrade"] = "websocket";
		headers["Connection"] = "Upgrade";
		return httpRequest;
	}

	internal HttpResponse GetResponse(Stream stream, int millisecondsTimeout)
	{
		byte[] array = ToByteArray();
		stream.Write(array, 0, array.Length);
		return HttpBase.Read(stream, HttpResponse.Parse, millisecondsTimeout);
	}

	internal static HttpRequest Parse(string[] headerParts)
	{
		string[] array = headerParts[0].Split(new char[1] { ' ' }, 3);
		if (array.Length != 3)
		{
			throw new ArgumentException("Invalid request line: " + headerParts[0]);
		}
		WebHeaderCollection webHeaderCollection = new WebHeaderCollection();
		for (int i = 1; i < headerParts.Length; i++)
		{
			webHeaderCollection.InternalSet(headerParts[i], response: false);
		}
		return new HttpRequest(array[0], array[1], new Version(array[2].Substring(5)), webHeaderCollection);
	}

	internal static HttpRequest Read(Stream stream, int millisecondsTimeout)
	{
		return HttpBase.Read(stream, Parse, millisecondsTimeout);
	}

	public void SetCookies(CookieCollection cookies)
	{
		if (cookies == null || cookies.Count == 0)
		{
			return;
		}
		StringBuilder stringBuilder = new StringBuilder(64);
		foreach (Cookie item in cookies.Sorted)
		{
			if (!item.Expired)
			{
				stringBuilder.AppendFormat("{0}; ", item.ToString());
			}
		}
		int length = stringBuilder.Length;
		if (length > 2)
		{
			stringBuilder.Length = length - 2;
			base.Headers["Cookie"] = stringBuilder.ToString();
		}
	}

	public override string ToString()
	{
		StringBuilder stringBuilder = new StringBuilder(64);
		stringBuilder.AppendFormat("{0} {1} HTTP/{2}{3}", _method, _uri, base.ProtocolVersion, "\r\n");
		NameValueCollection headers = base.Headers;
		string[] allKeys = headers.AllKeys;
		foreach (string text in allKeys)
		{
			stringBuilder.AppendFormat("{0}: {1}{2}", text, headers[text], "\r\n");
		}
		stringBuilder.Append("\r\n");
		string entityBody = base.EntityBody;
		if (entityBody.Length > 0)
		{
			stringBuilder.Append(entityBody);
		}
		return stringBuilder.ToString();
	}
}


using System;
using System.Collections.Specialized;
using System.IO;
using System.Text;
using WebSocketSharp;
using WebSocketSharp.Net;

internal class HttpResponse : HttpBase
{
	private string _code;

	private string _reason;

	public CookieCollection Cookies => base.Headers.GetCookies(response: true);

	public bool HasConnectionClose => base.Headers.Contains("Connection", "close");

	public bool IsProxyAuthenticationRequired => _code == "407";

	public bool IsRedirect => _code == "301" || _code == "302";

	public bool IsUnauthorized => _code == "401";

	public bool IsWebSocketResponse
	{
		get
		{
			NameValueCollection headers = base.Headers;
			return base.ProtocolVersion > HttpVersion.Version10 && _code == "101" && headers.Contains("Upgrade", "websocket") && headers.Contains("Connection", "Upgrade");
		}
	}

	public string Reason => _reason;

	public string StatusCode => _code;

	private HttpResponse(string code, string reason, Version version, NameValueCollection headers)
		: base(version, headers)
	{
		_code = code;
		_reason = reason;
	}

	internal HttpResponse(HttpStatusCode code)
		: this(code, code.GetDescription())
	{
	}

	internal HttpResponse(HttpStatusCode code, string reason)
		: this(((int)code).ToString(), reason, HttpVersion.Version11, new NameValueCollection())
	{
		base.Headers["Server"] = "websocket-sharp/1.0";
	}

	internal static HttpResponse CreateCloseResponse(HttpStatusCode code)
	{
		HttpResponse httpResponse = new HttpResponse(code);
		httpResponse.Headers["Connection"] = "close";
		return httpResponse;
	}

	internal static HttpResponse CreateUnauthorizedResponse(string challenge)
	{
		HttpResponse httpResponse = new HttpResponse(HttpStatusCode.Unauthorized);
		httpResponse.Headers["WWW-Authenticate"] = challenge;
		return httpResponse;
	}

	internal static HttpResponse CreateWebSocketResponse()
	{
		HttpResponse httpResponse = new HttpResponse(HttpStatusCode.SwitchingProtocols);
		NameValueCollection headers = httpResponse.Headers;
		headers["Upgrade"] = "websocket";
		headers["Connection"] = "Upgrade";
		return httpResponse;
	}

	internal static HttpResponse Parse(string[] headerParts)
	{
		string[] array = headerParts[0].Split(new char[1] { ' ' }, 3);
		if (array.Length != 3)
		{
			throw new ArgumentException("Invalid status line: " + headerParts[0]);
		}
		WebHeaderCollection webHeaderCollection = new WebHeaderCollection();
		for (int i = 1; i < headerParts.Length; i++)
		{
			webHeaderCollection.InternalSet(headerParts[i], response: true);
		}
		return new HttpResponse(array[1], array[2], new Version(array[0].Substring(5)), webHeaderCollection);
	}

	internal static HttpResponse Read(Stream stream, int millisecondsTimeout)
	{
		return HttpBase.Read(stream, Parse, millisecondsTimeout);
	}

	public void SetCookies(CookieCollection cookies)
	{
		if (cookies == null || cookies.Count == 0)
		{
			return;
		}
		NameValueCollection headers = base.Headers;
		foreach (Cookie item in cookies.Sorted)
		{
			headers.Add("Set-Cookie", item.ToResponseString());
		}
	}

	public override string ToString()
	{
		StringBuilder stringBuilder = new StringBuilder(64);
		stringBuilder.AppendFormat("HTTP/{0} {1} {2}{3}", base.ProtocolVersion, _code, _reason, "\r\n");
		NameValueCollection headers = base.Headers;
		string[] allKeys = headers.AllKeys;
		foreach (string text in allKeys)
		{
			stringBuilder.AppendFormat("{0}: {1}{2}", text, headers[text], "\r\n");
		}
		stringBuilder.Append("\r\n");
		string entityBody = base.EntityBody;
		if (entityBody.Length > 0)
		{
			stringBuilder.Append(entityBody);
		}
		return stringBuilder.ToString();
	}
}


public enum AuthenticationSchemes
{
	None = 0,
	Digest = 1,
	Basic = 8,
	Anonymous = 0x8000
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Net;
using System.Text;
using WebSocketSharp.Net;

internal class ChunkStream
{
	private int _chunkRead;

	private int _chunkSize;

	private List<Chunk> _chunks;

	private bool _gotIt;

	private WebSocketSharp.Net.WebHeaderCollection _headers;

	private StringBuilder _saved;

	private bool _sawCr;

	private InputChunkState _state;

	private int _trailerState;

	internal WebSocketSharp.Net.WebHeaderCollection Headers => _headers;

	public int ChunkLeft => _chunkSize - _chunkRead;

	public bool WantMore => _state != InputChunkState.End;

	public ChunkStream(WebSocketSharp.Net.WebHeaderCollection headers)
	{
		_headers = headers;
		_chunkSize = -1;
		_chunks = new List<Chunk>();
		_saved = new StringBuilder();
	}

	public ChunkStream(byte[] buffer, int offset, int count, WebSocketSharp.Net.WebHeaderCollection headers)
		: this(headers)
	{
		Write(buffer, offset, count);
	}

	private int read(byte[] buffer, int offset, int count)
	{
		int num = 0;
		int count2 = _chunks.Count;
		for (int i = 0; i < count2; i++)
		{
			Chunk chunk = _chunks[i];
			if (chunk == null)
			{
				continue;
			}
			if (chunk.ReadLeft == 0)
			{
				_chunks[i] = null;
				continue;
			}
			num += chunk.Read(buffer, offset + num, count - num);
			if (num == count)
			{
				break;
			}
		}
		return num;
	}

	private static string removeChunkExtension(string value)
	{
		int num = value.IndexOf(';');
		return (num > -1) ? value.Substring(0, num) : value;
	}

	private InputChunkState seekCrLf(byte[] buffer, ref int offset, int length)
	{
		if (!_sawCr)
		{
			if (buffer[offset++] != 13)
			{
				throwProtocolViolation("CR is expected.");
			}
			_sawCr = true;
			if (offset == length)
			{
				return InputChunkState.DataEnded;
			}
		}
		if (buffer[offset++] != 10)
		{
			throwProtocolViolation("LF is expected.");
		}
		return InputChunkState.None;
	}

	private InputChunkState setChunkSize(byte[] buffer, ref int offset, int length)
	{
		byte b = 0;
		while (offset < length)
		{
			b = buffer[offset++];
			if (_sawCr)
			{
				if (b != 10)
				{
					throwProtocolViolation("LF is expected.");
				}
				break;
			}
			switch (b)
			{
			case 13:
				_sawCr = true;
				continue;
			case 10:
				throwProtocolViolation("LF is unexpected.");
				break;
			}
			if (b == 32)
			{
				_gotIt = true;
			}
			if (!_gotIt)
			{
				_saved.Append((char)b);
			}
			if (_saved.Length > 20)
			{
				throwProtocolViolation("The chunk size is too long.");
			}
		}
		if (!_sawCr || b != 10)
		{
			return InputChunkState.None;
		}
		_chunkRead = 0;
		try
		{
			_chunkSize = int.Parse(removeChunkExtension(_saved.ToString()), NumberStyles.HexNumber);
		}
		catch
		{
			throwProtocolViolation("The chunk size cannot be parsed.");
		}
		if (_chunkSize == 0)
		{
			_trailerState = 2;
			return InputChunkState.Trailer;
		}
		return InputChunkState.Data;
	}

	private InputChunkState setTrailer(byte[] buffer, ref int offset, int length)
	{
		if (_trailerState == 2 && buffer[offset] == 13 && _saved.Length == 0)
		{
			offset++;
			if (offset < length && buffer[offset] == 10)
			{
				offset++;
				return InputChunkState.End;
			}
			offset--;
		}
		while (offset < length && _trailerState < 4)
		{
			byte b = buffer[offset++];
			_saved.Append((char)b);
			if (_saved.Length > 4196)
			{
				throwProtocolViolation("The trailer is too long.");
			}
			if (_trailerState == 1 || _trailerState == 3)
			{
				if (b != 10)
				{
					throwProtocolViolation("LF is expected.");
				}
				_trailerState++;
				continue;
			}
			switch (b)
			{
			case 13:
				_trailerState++;
				continue;
			case 10:
				throwProtocolViolation("LF is unexpected.");
				break;
			}
			_trailerState = 0;
		}
		if (_trailerState < 4)
		{
			return InputChunkState.Trailer;
		}
		_saved.Length -= 2;
		StringReader stringReader = new StringReader(_saved.ToString());
		string text;
		while ((text = stringReader.ReadLine()) != null && text.Length > 0)
		{
			_headers.Add(text);
		}
		return InputChunkState.End;
	}

	private static void throwProtocolViolation(string message)
	{
		throw new WebException(message, null, WebExceptionStatus.ServerProtocolViolation, null);
	}

	private void write(byte[] buffer, ref int offset, int length)
	{
		if (_state == InputChunkState.End)
		{
			throwProtocolViolation("The chunks were ended.");
		}
		if (_state == InputChunkState.None)
		{
			_state = setChunkSize(buffer, ref offset, length);
			if (_state == InputChunkState.None)
			{
				return;
			}
			_saved.Length = 0;
			_sawCr = false;
			_gotIt = false;
		}
		if (_state == InputChunkState.Data && offset < length)
		{
			_state = writeData(buffer, ref offset, length);
			if (_state == InputChunkState.Data)
			{
				return;
			}
		}
		if (_state == InputChunkState.DataEnded && offset < length)
		{
			_state = seekCrLf(buffer, ref offset, length);
			if (_state == InputChunkState.DataEnded)
			{
				return;
			}
			_sawCr = false;
		}
		if (_state == InputChunkState.Trailer && offset < length)
		{
			_state = setTrailer(buffer, ref offset, length);
			if (_state == InputChunkState.Trailer)
			{
				return;
			}
			_saved.Length = 0;
		}
		if (offset < length)
		{
			write(buffer, ref offset, length);
		}
	}

	private InputChunkState writeData(byte[] buffer, ref int offset, int length)
	{
		int num = length - offset;
		int num2 = _chunkSize - _chunkRead;
		if (num > num2)
		{
			num = num2;
		}
		byte[] array = new byte[num];
		Buffer.BlockCopy(buffer, offset, array, 0, num);
		_chunks.Add(new Chunk(array));
		offset += num;
		_chunkRead += num;
		return (_chunkRead != _chunkSize) ? InputChunkState.Data : InputChunkState.DataEnded;
	}

	internal void ResetBuffer()
	{
		_chunkRead = 0;
		_chunkSize = -1;
		_chunks.Clear();
	}

	internal int WriteAndReadBack(byte[] buffer, int offset, int writeCount, int readCount)
	{
		Write(buffer, offset, writeCount);
		return Read(buffer, offset, readCount);
	}

	public int Read(byte[] buffer, int offset, int count)
	{
		if (count <= 0)
		{
			return 0;
		}
		return read(buffer, offset, count);
	}

	public void Write(byte[] buffer, int offset, int count)
	{
		if (count > 0)
		{
			write(buffer, ref offset, offset + count);
		}
	}
}


using System;
using System.Globalization;
using System.Text;
using WebSocketSharp;
using WebSocketSharp.Net;

[Serializable]
public sealed class Cookie
{
	private string _comment;

	private Uri _commentUri;

	private bool _discard;

	private string _domain;

	private DateTime _expires;

	private bool _httpOnly;

	private string _name;

	private string _path;

	private string _port;

	private int[] _ports;

	private static readonly char[] _reservedCharsForName;

	private static readonly char[] _reservedCharsForValue;

	private bool _secure;

	private DateTime _timestamp;

	private string _value;

	private int _version;

	internal bool ExactDomain { get; set; }

	internal int MaxAge
	{
		get
		{
			if (_expires == DateTime.MinValue)
			{
				return 0;
			}
			DateTime dateTime = ((_expires.Kind != DateTimeKind.Local) ? _expires.ToLocalTime() : _expires);
			TimeSpan timeSpan = dateTime - DateTime.Now;
			return (timeSpan > TimeSpan.Zero) ? ((int)timeSpan.TotalSeconds) : 0;
		}
	}

	internal int[] Ports => _ports;

	public string Comment
	{
		get
		{
			return _comment;
		}
		set
		{
			_comment = value ?? string.Empty;
		}
	}

	public Uri CommentUri
	{
		get
		{
			return _commentUri;
		}
		set
		{
			_commentUri = value;
		}
	}

	public bool Discard
	{
		get
		{
			return _discard;
		}
		set
		{
			_discard = value;
		}
	}

	public string Domain
	{
		get
		{
			return _domain;
		}
		set
		{
			if (value.IsNullOrEmpty())
			{
				_domain = string.Empty;
				ExactDomain = true;
			}
			else
			{
				_domain = value;
				ExactDomain = value[0] != '.';
			}
		}
	}

	public bool Expired
	{
		get
		{
			return _expires != DateTime.MinValue && _expires <= DateTime.Now;
		}
		set
		{
			_expires = (value ? DateTime.Now : DateTime.MinValue);
		}
	}

	public DateTime Expires
	{
		get
		{
			return _expires;
		}
		set
		{
			_expires = value;
		}
	}

	public bool HttpOnly
	{
		get
		{
			return _httpOnly;
		}
		set
		{
			_httpOnly = value;
		}
	}

	public string Name
	{
		get
		{
			return _name;
		}
		set
		{
			if (!canSetName(value, out var message))
			{
				throw new CookieException(message);
			}
			_name = value;
		}
	}

	public string Path
	{
		get
		{
			return _path;
		}
		set
		{
			_path = value ?? string.Empty;
		}
	}

	public string Port
	{
		get
		{
			return _port;
		}
		set
		{
			if (value.IsNullOrEmpty())
			{
				_port = string.Empty;
				_ports = new int[0];
				return;
			}
			if (!value.IsEnclosedIn('"'))
			{
				throw new CookieException("The value specified for the Port attribute isn't enclosed in double quotes.");
			}
			if (!tryCreatePorts(value, out _ports, out var parseError))
			{
				throw new CookieException($"The value specified for the Port attribute contains an invalid value: {parseError}");
			}
			_port = value;
		}
	}

	public bool Secure
	{
		get
		{
			return _secure;
		}
		set
		{
			_secure = value;
		}
	}

	public DateTime TimeStamp => _timestamp;

	public string Value
	{
		get
		{
			return _value;
		}
		set
		{
			if (!canSetValue(value, out var message))
			{
				throw new CookieException(message);
			}
			_value = ((value.Length > 0) ? value : "\"\"");
		}
	}

	public int Version
	{
		get
		{
			return _version;
		}
		set
		{
			if (value < 0 || value > 1)
			{
				throw new ArgumentOutOfRangeException("value", "Not 0 or 1.");
			}
			_version = value;
		}
	}

	static Cookie()
	{
		_reservedCharsForName = new char[7] { ' ', '=', ';', ',', '\n', '\r', '\t' };
		_reservedCharsForValue = new char[2] { ';', ',' };
	}

	public Cookie()
	{
		_comment = string.Empty;
		_domain = string.Empty;
		_expires = DateTime.MinValue;
		_name = string.Empty;
		_path = string.Empty;
		_port = string.Empty;
		_ports = new int[0];
		_timestamp = DateTime.Now;
		_value = string.Empty;
		_version = 0;
	}

	public Cookie(string name, string value)
		: this()
	{
		Name = name;
		Value = value;
	}

	public Cookie(string name, string value, string path)
		: this(name, value)
	{
		Path = path;
	}

	public Cookie(string name, string value, string path, string domain)
		: this(name, value, path)
	{
		Domain = domain;
	}

	private static bool canSetName(string name, out string message)
	{
		if (name.IsNullOrEmpty())
		{
			message = "The value specified for the Name is null or empty.";
			return false;
		}
		if (name[0] == '$' || name.Contains(_reservedCharsForName))
		{
			message = "The value specified for the Name contains an invalid character.";
			return false;
		}
		message = string.Empty;
		return true;
	}

	private static bool canSetValue(string value, out string message)
	{
		if (value == null)
		{
			message = "The value specified for the Value is null.";
			return false;
		}
		if (value.Contains(_reservedCharsForValue) && !value.IsEnclosedIn('"'))
		{
			message = "The value specified for the Value contains an invalid character.";
			return false;
		}
		message = string.Empty;
		return true;
	}

	private static int hash(int i, int j, int k, int l, int m)
	{
		return i ^ ((j << 13) | (j >> 19)) ^ ((k << 26) | (k >> 6)) ^ ((l << 7) | (l >> 25)) ^ ((m << 20) | (m >> 12));
	}

	private string toResponseStringVersion0()
	{
		StringBuilder stringBuilder = new StringBuilder(64);
		stringBuilder.AppendFormat("{0}={1}", _name, _value);
		if (_expires != DateTime.MinValue)
		{
			stringBuilder.AppendFormat("; Expires={0}", _expires.ToUniversalTime().ToString("ddd, dd'-'MMM'-'yyyy HH':'mm':'ss 'GMT'", CultureInfo.CreateSpecificCulture("en-US")));
		}
		if (!_path.IsNullOrEmpty())
		{
			stringBuilder.AppendFormat("; Path={0}", _path);
		}
		if (!_domain.IsNullOrEmpty())
		{
			stringBuilder.AppendFormat("; Domain={0}", _domain);
		}
		if (_secure)
		{
			stringBuilder.Append("; Secure");
		}
		if (_httpOnly)
		{
			stringBuilder.Append("; HttpOnly");
		}
		return stringBuilder.ToString();
	}

	private string toResponseStringVersion1()
	{
		StringBuilder stringBuilder = new StringBuilder(64);
		stringBuilder.AppendFormat("{0}={1}; Version={2}", _name, _value, _version);
		if (_expires != DateTime.MinValue)
		{
			stringBuilder.AppendFormat("; Max-Age={0}", MaxAge);
		}
		if (!_path.IsNullOrEmpty())
		{
			stringBuilder.AppendFormat("; Path={0}", _path);
		}
		if (!_domain.IsNullOrEmpty())
		{
			stringBuilder.AppendFormat("; Domain={0}", _domain);
		}
		if (!_port.IsNullOrEmpty())
		{
			if (_port == "\"\"")
			{
				stringBuilder.Append("; Port");
			}
			else
			{
				stringBuilder.AppendFormat("; Port={0}", _port);
			}
		}
		if (!_comment.IsNullOrEmpty())
		{
			stringBuilder.AppendFormat("; Comment={0}", _comment.UrlEncode());
		}
		if (_commentUri != null)
		{
			string originalString = _commentUri.OriginalString;
			stringBuilder.AppendFormat("; CommentURL={0}", originalString.IsToken() ? originalString : originalString.Quote());
		}
		if (_discard)
		{
			stringBuilder.Append("; Discard");
		}
		if (_secure)
		{
			stringBuilder.Append("; Secure");
		}
		return stringBuilder.ToString();
	}

	private static bool tryCreatePorts(string value, out int[] result, out string parseError)
	{
		string[] array = value.Trim(new char[1] { '"' }).Split(new char[1] { ',' });
		int num = array.Length;
		int[] array2 = new int[num];
		for (int i = 0; i < num; i++)
		{
			array2[i] = int.MinValue;
			string text = array[i].Trim();
			if (text.Length != 0 && !int.TryParse(text, out array2[i]))
			{
				result = new int[0];
				parseError = text;
				return false;
			}
		}
		result = array2;
		parseError = string.Empty;
		return true;
	}

	internal string ToRequestString(Uri uri)
	{
		if (_name.Length == 0)
		{
			return string.Empty;
		}
		if (_version == 0)
		{
			return $"{_name}={_value}";
		}
		StringBuilder stringBuilder = new StringBuilder(64);
		stringBuilder.AppendFormat("$Version={0}; {1}={2}", _version, _name, _value);
		if (!_path.IsNullOrEmpty())
		{
			stringBuilder.AppendFormat("; $Path={0}", _path);
		}
		else if (uri != null)
		{
			stringBuilder.AppendFormat("; $Path={0}", uri.GetAbsolutePath());
		}
		else
		{
			stringBuilder.Append("; $Path=/");
		}
		if ((uri == null || uri.Host != _domain) && !_domain.IsNullOrEmpty())
		{
			stringBuilder.AppendFormat("; $Domain={0}", _domain);
		}
		if (!_port.IsNullOrEmpty())
		{
			if (_port == "\"\"")
			{
				stringBuilder.Append("; $Port");
			}
			else
			{
				stringBuilder.AppendFormat("; $Port={0}", _port);
			}
		}
		return stringBuilder.ToString();
	}

	internal string ToResponseString()
	{
		return (_name.Length <= 0) ? string.Empty : ((_version == 0) ? toResponseStringVersion0() : toResponseStringVersion1());
	}

	public override bool Equals(object comparand)
	{
		return comparand is Cookie cookie && _name.Equals(cookie.Name, StringComparison.InvariantCultureIgnoreCase) && _value.Equals(cookie.Value, StringComparison.InvariantCulture) && _path.Equals(cookie.Path, StringComparison.InvariantCulture) && _domain.Equals(cookie.Domain, StringComparison.InvariantCultureIgnoreCase) && _version == cookie.Version;
	}

	public override int GetHashCode()
	{
		return hash(StringComparer.InvariantCultureIgnoreCase.GetHashCode(_name), _value.GetHashCode(), _path.GetHashCode(), StringComparer.InvariantCultureIgnoreCase.GetHashCode(_domain), _version);
	}

	public override string ToString()
	{
		return ToRequestString(null);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using WebSocketSharp;
using WebSocketSharp.Net;

[Serializable]
public class CookieCollection : ICollection, IEnumerable
{
	private List<Cookie> _list;

	private object _sync;

	internal IList<Cookie> List => _list;

	internal IEnumerable<Cookie> Sorted
	{
		get
		{
			List<Cookie> list = new List<Cookie>(_list);
			if (list.Count > 1)
			{
				list.Sort(compareCookieWithinSorted);
			}
			return list;
		}
	}

	public int Count => _list.Count;

	public bool IsReadOnly => true;

	public bool IsSynchronized => false;

	public Cookie this[int index]
	{
		get
		{
			if (index < 0 || index >= _list.Count)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			return _list[index];
		}
	}

	public Cookie this[string name]
	{
		get
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			foreach (Cookie item in Sorted)
			{
				if (item.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
				{
					return item;
				}
			}
			return null;
		}
	}

	public object SyncRoot => _sync ?? (_sync = ((ICollection)_list).SyncRoot);

	public CookieCollection()
	{
		_list = new List<Cookie>();
	}

	private static int compareCookieWithinSort(Cookie x, Cookie y)
	{
		return x.Name.Length + x.Value.Length - (y.Name.Length + y.Value.Length);
	}

	private static int compareCookieWithinSorted(Cookie x, Cookie y)
	{
		int num = 0;
		return ((num = x.Version - y.Version) != 0) ? num : (((num = x.Name.CompareTo(y.Name)) != 0) ? num : (y.Path.Length - x.Path.Length));
	}

	private static CookieCollection parseRequest(string value)
	{
		CookieCollection cookieCollection = new CookieCollection();
		Cookie cookie = null;
		int num = 0;
		string[] array = splitCookieHeaderValue(value);
		for (int i = 0; i < array.Length; i++)
		{
			string text = array[i].Trim();
			if (text.Length == 0)
			{
				continue;
			}
			if (text.StartsWith("$version", StringComparison.InvariantCultureIgnoreCase))
			{
				num = int.Parse(text.GetValue('=', unquote: true));
				continue;
			}
			if (text.StartsWith("$path", StringComparison.InvariantCultureIgnoreCase))
			{
				if (cookie != null)
				{
					cookie.Path = text.GetValue('=');
				}
				continue;
			}
			if (text.StartsWith("$domain", StringComparison.InvariantCultureIgnoreCase))
			{
				if (cookie != null)
				{
					cookie.Domain = text.GetValue('=');
				}
				continue;
			}
			if (text.StartsWith("$port", StringComparison.InvariantCultureIgnoreCase))
			{
				string port = (text.Equals("$port", StringComparison.InvariantCultureIgnoreCase) ? "\"\"" : text.GetValue('='));
				if (cookie != null)
				{
					cookie.Port = port;
				}
				continue;
			}
			if (cookie != null)
			{
				cookieCollection.Add(cookie);
			}
			string value2 = string.Empty;
			int num2 = text.IndexOf('=');
			string name;
			if (num2 == -1)
			{
				name = text;
			}
			else if (num2 == text.Length - 1)
			{
				name = text.Substring(0, num2).TrimEnd(new char[1] { ' ' });
			}
			else
			{
				name = text.Substring(0, num2).TrimEnd(new char[1] { ' ' });
				value2 = text.Substring(num2 + 1).TrimStart(new char[1] { ' ' });
			}
			cookie = new Cookie(name, value2);
			if (num != 0)
			{
				cookie.Version = num;
			}
		}
		if (cookie != null)
		{
			cookieCollection.Add(cookie);
		}
		return cookieCollection;
	}

	private static CookieCollection parseResponse(string value)
	{
		CookieCollection cookieCollection = new CookieCollection();
		Cookie cookie = null;
		string[] array = splitCookieHeaderValue(value);
		for (int i = 0; i < array.Length; i++)
		{
			string text = array[i].Trim();
			if (text.Length == 0)
			{
				continue;
			}
			if (text.StartsWith("version", StringComparison.InvariantCultureIgnoreCase))
			{
				if (cookie != null)
				{
					cookie.Version = int.Parse(text.GetValue('=', unquote: true));
				}
				continue;
			}
			if (text.StartsWith("expires", StringComparison.InvariantCultureIgnoreCase))
			{
				StringBuilder stringBuilder = new StringBuilder(text.GetValue('='), 32);
				if (i < array.Length - 1)
				{
					stringBuilder.AppendFormat(", {0}", array[++i].Trim());
				}
				if (!DateTime.TryParseExact(stringBuilder.ToString(), new string[2] { "ddd, dd'-'MMM'-'yyyy HH':'mm':'ss 'GMT'", "r" }, CultureInfo.CreateSpecificCulture("en-US"), DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal, out var result))
				{
					result = DateTime.Now;
				}
				if (cookie != null && cookie.Expires == DateTime.MinValue)
				{
					cookie.Expires = result.ToLocalTime();
				}
				continue;
			}
			if (text.StartsWith("max-age", StringComparison.InvariantCultureIgnoreCase))
			{
				int num = int.Parse(text.GetValue('=', unquote: true));
				DateTime expires = DateTime.Now.AddSeconds(num);
				if (cookie != null)
				{
					cookie.Expires = expires;
				}
				continue;
			}
			if (text.StartsWith("path", StringComparison.InvariantCultureIgnoreCase))
			{
				if (cookie != null)
				{
					cookie.Path = text.GetValue('=');
				}
				continue;
			}
			if (text.StartsWith("domain", StringComparison.InvariantCultureIgnoreCase))
			{
				if (cookie != null)
				{
					cookie.Domain = text.GetValue('=');
				}
				continue;
			}
			if (text.StartsWith("port", StringComparison.InvariantCultureIgnoreCase))
			{
				string port = (text.Equals("port", StringComparison.InvariantCultureIgnoreCase) ? "\"\"" : text.GetValue('='));
				if (cookie != null)
				{
					cookie.Port = port;
				}
				continue;
			}
			if (text.StartsWith("comment", StringComparison.InvariantCultureIgnoreCase))
			{
				if (cookie != null)
				{
					cookie.Comment = text.GetValue('=').UrlDecode();
				}
				continue;
			}
			if (text.StartsWith("commenturl", StringComparison.InvariantCultureIgnoreCase))
			{
				if (cookie != null)
				{
					cookie.CommentUri = text.GetValue('=', unquote: true).ToUri();
				}
				continue;
			}
			if (text.StartsWith("discard", StringComparison.InvariantCultureIgnoreCase))
			{
				if (cookie != null)
				{
					cookie.Discard = true;
				}
				continue;
			}
			if (text.StartsWith("secure", StringComparison.InvariantCultureIgnoreCase))
			{
				if (cookie != null)
				{
					cookie.Secure = true;
				}
				continue;
			}
			if (text.StartsWith("httponly", StringComparison.InvariantCultureIgnoreCase))
			{
				if (cookie != null)
				{
					cookie.HttpOnly = true;
				}
				continue;
			}
			if (cookie != null)
			{
				cookieCollection.Add(cookie);
			}
			string value2 = string.Empty;
			int num2 = text.IndexOf('=');
			string name;
			if (num2 == -1)
			{
				name = text;
			}
			else if (num2 == text.Length - 1)
			{
				name = text.Substring(0, num2).TrimEnd(new char[1] { ' ' });
			}
			else
			{
				name = text.Substring(0, num2).TrimEnd(new char[1] { ' ' });
				value2 = text.Substring(num2 + 1).TrimStart(new char[1] { ' ' });
			}
			cookie = new Cookie(name, value2);
		}
		if (cookie != null)
		{
			cookieCollection.Add(cookie);
		}
		return cookieCollection;
	}

	private int searchCookie(Cookie cookie)
	{
		string name = cookie.Name;
		string path = cookie.Path;
		string domain = cookie.Domain;
		int version = cookie.Version;
		for (int num = _list.Count - 1; num >= 0; num--)
		{
			Cookie cookie2 = _list[num];
			if (cookie2.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase) && cookie2.Path.Equals(path, StringComparison.InvariantCulture) && cookie2.Domain.Equals(domain, StringComparison.InvariantCultureIgnoreCase) && cookie2.Version == version)
			{
				return num;
			}
		}
		return -1;
	}

	private static string[] splitCookieHeaderValue(string value)
	{
		return new List<string>(value.SplitHeaderValue(',', ';')).ToArray();
	}

	internal static CookieCollection Parse(string value, bool response)
	{
		return response ? parseResponse(value) : parseRequest(value);
	}

	internal void SetOrRemove(Cookie cookie)
	{
		int num = searchCookie(cookie);
		if (num == -1)
		{
			if (!cookie.Expired)
			{
				_list.Add(cookie);
			}
		}
		else if (!cookie.Expired)
		{
			_list[num] = cookie;
		}
		else
		{
			_list.RemoveAt(num);
		}
	}

	internal void SetOrRemove(CookieCollection cookies)
	{
		foreach (Cookie cookie in cookies)
		{
			SetOrRemove(cookie);
		}
	}

	internal void Sort()
	{
		if (_list.Count > 1)
		{
			_list.Sort(compareCookieWithinSort);
		}
	}

	public void Add(Cookie cookie)
	{
		if (cookie == null)
		{
			throw new ArgumentNullException("cookie");
		}
		int num = searchCookie(cookie);
		if (num == -1)
		{
			_list.Add(cookie);
		}
		else
		{
			_list[num] = cookie;
		}
	}

	public void Add(CookieCollection cookies)
	{
		if (cookies == null)
		{
			throw new ArgumentNullException("cookies");
		}
		foreach (Cookie cookie in cookies)
		{
			Add(cookie);
		}
	}

	public void CopyTo(Array array, int index)
	{
		if (array == null)
		{
			throw new ArgumentNullException("array");
		}
		if (index < 0)
		{
			throw new ArgumentOutOfRangeException("index", "Less than zero.");
		}
		if (array.Rank > 1)
		{
			throw new ArgumentException("Multidimensional.", "array");
		}
		if (array.Length - index < _list.Count)
		{
			throw new ArgumentException("The number of elements in this collection is greater than the available space of the destination array.");
		}
		if (!array.GetType().GetElementType().IsAssignableFrom(typeof(Cookie)))
		{
			throw new InvalidCastException("The elements in this collection cannot be cast automatically to the type of the destination array.");
		}
		((ICollection)_list).CopyTo(array, index);
	}

	public void CopyTo(Cookie[] array, int index)
	{
		if (array == null)
		{
			throw new ArgumentNullException("array");
		}
		if (index < 0)
		{
			throw new ArgumentOutOfRangeException("index", "Less than zero.");
		}
		if (array.Length - index < _list.Count)
		{
			throw new ArgumentException("The number of elements in this collection is greater than the available space of the destination array.");
		}
		_list.CopyTo(array, index);
	}

	public IEnumerator GetEnumerator()
	{
		return _list.GetEnumerator();
	}
}


using System;
using System.Runtime.Serialization;
using System.Security.Permissions;

[Serializable]
public class CookieException : FormatException, ISerializable
{
	internal CookieException(string message)
		: base(message)
	{
	}

	internal CookieException(string message, Exception innerException)
		: base(message, innerException)
	{
	}

	protected CookieException(SerializationInfo serializationInfo, StreamingContext streamingContext)
		: base(serializationInfo, streamingContext)
	{
	}

	public CookieException()
	{
	}

	[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
	public override void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
	{
		base.GetObjectData(serializationInfo, streamingContext);
	}

	[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter, SerializationFormatter = true)]
	void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
	{
		base.GetObjectData(serializationInfo, streamingContext);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using WebSocketSharp.Net;

internal sealed class EndPointListener
{
	private List<HttpListenerPrefix> _all;

	private static readonly string _defaultCertFolderPath;

	private IPEndPoint _endpoint;

	private Dictionary<HttpListenerPrefix, WebSocketSharp.Net.HttpListener> _prefixes;

	private bool _secure;

	private Socket _socket;

	private ServerSslConfiguration _sslConfig;

	private List<HttpListenerPrefix> _unhandled;

	private Dictionary<HttpConnection, HttpConnection> _unregistered;

	private object _unregisteredSync;

	public IPAddress Address => _endpoint.Address;

	public bool IsSecure => _secure;

	public int Port => _endpoint.Port;

	public ServerSslConfiguration SslConfiguration => _sslConfig;

	static EndPointListener()
	{
		_defaultCertFolderPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
	}

	internal EndPointListener(IPEndPoint endpoint, bool secure, string certificateFolderPath, ServerSslConfiguration sslConfig, bool reuseAddress)
	{
		if (secure)
		{
			X509Certificate2 certificate = getCertificate(endpoint.Port, certificateFolderPath, sslConfig.ServerCertificate);
			if (certificate == null)
			{
				throw new ArgumentException("No server certificate could be found.");
			}
			_secure = true;
			_sslConfig = new ServerSslConfiguration(certificate, sslConfig.ClientCertificateRequired, sslConfig.EnabledSslProtocols, sslConfig.CheckCertificateRevocation);
			_sslConfig.ClientCertificateValidationCallback = sslConfig.ClientCertificateValidationCallback;
		}
		_endpoint = endpoint;
		_prefixes = new Dictionary<HttpListenerPrefix, WebSocketSharp.Net.HttpListener>();
		_unregistered = new Dictionary<HttpConnection, HttpConnection>();
		_unregisteredSync = ((ICollection)_unregistered).SyncRoot;
		_socket = new Socket(endpoint.Address.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
		if (reuseAddress)
		{
			_socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, optionValue: true);
		}
		_socket.Bind(endpoint);
		_socket.Listen(500);
		_socket.BeginAccept(onAccept, this);
	}

	private static void addSpecial(List<HttpListenerPrefix> prefixes, HttpListenerPrefix prefix)
	{
		string path = prefix.Path;
		foreach (HttpListenerPrefix prefix2 in prefixes)
		{
			if (prefix2.Path == path)
			{
				throw new WebSocketSharp.Net.HttpListenerException(87, "The prefix is already in use.");
			}
		}
		prefixes.Add(prefix);
	}

	private static RSACryptoServiceProvider createRSAFromFile(string filename)
	{
		byte[] array = null;
		using (FileStream fileStream = File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.Read))
		{
			array = new byte[fileStream.Length];
			fileStream.Read(array, 0, array.Length);
		}
		RSACryptoServiceProvider rSACryptoServiceProvider = new RSACryptoServiceProvider();
		rSACryptoServiceProvider.ImportCspBlob(array);
		return rSACryptoServiceProvider;
	}

	private static X509Certificate2 getCertificate(int port, string folderPath, X509Certificate2 defaultCertificate)
	{
		if (folderPath == null || folderPath.Length == 0)
		{
			folderPath = _defaultCertFolderPath;
		}
		try
		{
			string text = Path.Combine(folderPath, $"{port}.cer");
			string text2 = Path.Combine(folderPath, $"{port}.key");
			if (File.Exists(text) && File.Exists(text2))
			{
				X509Certificate2 x509Certificate = new X509Certificate2(text);
				x509Certificate.PrivateKey = createRSAFromFile(text2);
				return x509Certificate;
			}
		}
		catch
		{
		}
		return defaultCertificate;
	}

	private void leaveIfNoPrefix()
	{
		if (_prefixes.Count > 0)
		{
			return;
		}
		List<HttpListenerPrefix> unhandled = _unhandled;
		if (unhandled == null || unhandled.Count <= 0)
		{
			unhandled = _all;
			if (unhandled == null || unhandled.Count <= 0)
			{
				EndPointManager.RemoveEndPoint(_endpoint);
			}
		}
	}

	private static void onAccept(IAsyncResult asyncResult)
	{
		EndPointListener endPointListener = (EndPointListener)asyncResult.AsyncState;
		Socket socket = null;
		try
		{
			socket = endPointListener._socket.EndAccept(asyncResult);
		}
		catch (SocketException)
		{
		}
		catch (ObjectDisposedException)
		{
			return;
		}
		try
		{
			endPointListener._socket.BeginAccept(onAccept, endPointListener);
		}
		catch
		{
			socket?.Close();
			return;
		}
		if (socket != null)
		{
			processAccepted(socket, endPointListener);
		}
	}

	private static void processAccepted(Socket socket, EndPointListener listener)
	{
		HttpConnection httpConnection = null;
		try
		{
			httpConnection = new HttpConnection(socket, listener);
			lock (listener._unregisteredSync)
			{
				listener._unregistered[httpConnection] = httpConnection;
			}
			httpConnection.BeginReadRequest();
		}
		catch
		{
			if (httpConnection != null)
			{
				httpConnection.Close(force: true);
			}
			else
			{
				socket.Close();
			}
		}
	}

	private static bool removeSpecial(List<HttpListenerPrefix> prefixes, HttpListenerPrefix prefix)
	{
		string path = prefix.Path;
		int count = prefixes.Count;
		for (int i = 0; i < count; i++)
		{
			if (prefixes[i].Path == path)
			{
				prefixes.RemoveAt(i);
				return true;
			}
		}
		return false;
	}

	private static WebSocketSharp.Net.HttpListener searchHttpListenerFromSpecial(string path, List<HttpListenerPrefix> prefixes)
	{
		if (prefixes == null)
		{
			return null;
		}
		WebSocketSharp.Net.HttpListener result = null;
		int num = -1;
		foreach (HttpListenerPrefix prefix in prefixes)
		{
			string path2 = prefix.Path;
			int length = path2.Length;
			if (length >= num && path.StartsWith(path2))
			{
				num = length;
				result = prefix.Listener;
			}
		}
		return result;
	}

	internal static bool CertificateExists(int port, string folderPath)
	{
		if (folderPath == null || folderPath.Length == 0)
		{
			folderPath = _defaultCertFolderPath;
		}
		string path = Path.Combine(folderPath, $"{port}.cer");
		string path2 = Path.Combine(folderPath, $"{port}.key");
		return File.Exists(path) && File.Exists(path2);
	}

	internal void RemoveConnection(HttpConnection connection)
	{
		lock (_unregisteredSync)
		{
			_unregistered.Remove(connection);
		}
	}

	internal bool TrySearchHttpListener(Uri uri, out WebSocketSharp.Net.HttpListener listener)
	{
		listener = null;
		if (uri == null)
		{
			return false;
		}
		string host = uri.Host;
		bool flag = Uri.CheckHostName(host) == UriHostNameType.Dns;
		string text = uri.Port.ToString();
		string text2 = HttpUtility.UrlDecode(uri.AbsolutePath);
		string text3 = ((text2[text2.Length - 1] != '/') ? (text2 + "/") : text2);
		if (host != null && host.Length > 0)
		{
			int num = -1;
			foreach (HttpListenerPrefix key in _prefixes.Keys)
			{
				if (flag)
				{
					string host2 = key.Host;
					if (Uri.CheckHostName(host2) == UriHostNameType.Dns && host2 != host)
					{
						continue;
					}
				}
				if (!(key.Port != text))
				{
					string path = key.Path;
					int length = path.Length;
					if (length >= num && (text2.StartsWith(path) || text3.StartsWith(path)))
					{
						num = length;
						listener = _prefixes[key];
					}
				}
			}
			if (num != -1)
			{
				return true;
			}
		}
		List<HttpListenerPrefix> unhandled = _unhandled;
		listener = searchHttpListenerFromSpecial(text2, unhandled);
		if (listener == null && text3 != text2)
		{
			listener = searchHttpListenerFromSpecial(text3, unhandled);
		}
		if (listener != null)
		{
			return true;
		}
		unhandled = _all;
		listener = searchHttpListenerFromSpecial(text2, unhandled);
		if (listener == null && text3 != text2)
		{
			listener = searchHttpListenerFromSpecial(text3, unhandled);
		}
		return listener != null;
	}

	public void AddPrefix(HttpListenerPrefix prefix, WebSocketSharp.Net.HttpListener listener)
	{
		if (prefix.Host == "*")
		{
			List<HttpListenerPrefix> unhandled;
			List<HttpListenerPrefix> list;
			do
			{
				unhandled = _unhandled;
				list = ((unhandled != null) ? new List<HttpListenerPrefix>(unhandled) : new List<HttpListenerPrefix>());
				prefix.Listener = listener;
				addSpecial(list, prefix);
			}
			while (Interlocked.CompareExchange(ref _unhandled, list, unhandled) != unhandled);
			return;
		}
		if (prefix.Host == "+")
		{
			List<HttpListenerPrefix> unhandled;
			List<HttpListenerPrefix> list;
			do
			{
				unhandled = _all;
				list = ((unhandled != null) ? new List<HttpListenerPrefix>(unhandled) : new List<HttpListenerPrefix>());
				prefix.Listener = listener;
				addSpecial(list, prefix);
			}
			while (Interlocked.CompareExchange(ref _all, list, unhandled) != unhandled);
			return;
		}
		Dictionary<HttpListenerPrefix, WebSocketSharp.Net.HttpListener> prefixes;
		Dictionary<HttpListenerPrefix, WebSocketSharp.Net.HttpListener> dictionary;
		do
		{
			prefixes = _prefixes;
			if (prefixes.ContainsKey(prefix))
			{
				if (prefixes[prefix] != listener)
				{
					throw new WebSocketSharp.Net.HttpListenerException(87, $"There's another listener for {prefix}.");
				}
				break;
			}
			dictionary = new Dictionary<HttpListenerPrefix, WebSocketSharp.Net.HttpListener>(prefixes);
			dictionary[prefix] = listener;
		}
		while (Interlocked.CompareExchange(ref _prefixes, dictionary, prefixes) != prefixes);
	}

	public void Close()
	{
		_socket.Close();
		HttpConnection[] array = null;
		lock (_unregisteredSync)
		{
			if (_unregistered.Count == 0)
			{
				return;
			}
			Dictionary<HttpConnection, HttpConnection>.KeyCollection keys = _unregistered.Keys;
			array = new HttpConnection[keys.Count];
			keys.CopyTo(array, 0);
			_unregistered.Clear();
		}
		for (int num = array.Length - 1; num >= 0; num--)
		{
			array[num].Close(force: true);
		}
	}

	public void RemovePrefix(HttpListenerPrefix prefix, WebSocketSharp.Net.HttpListener listener)
	{
		if (prefix.Host == "*")
		{
			List<HttpListenerPrefix> unhandled;
			List<HttpListenerPrefix> list;
			do
			{
				unhandled = _unhandled;
				if (unhandled == null)
				{
					break;
				}
				list = new List<HttpListenerPrefix>(unhandled);
			}
			while (removeSpecial(list, prefix) && Interlocked.CompareExchange(ref _unhandled, list, unhandled) != unhandled);
			leaveIfNoPrefix();
			return;
		}
		if (prefix.Host == "+")
		{
			List<HttpListenerPrefix> unhandled;
			List<HttpListenerPrefix> list;
			do
			{
				unhandled = _all;
				if (unhandled == null)
				{
					break;
				}
				list = new List<HttpListenerPrefix>(unhandled);
			}
			while (removeSpecial(list, prefix) && Interlocked.CompareExchange(ref _all, list, unhandled) != unhandled);
			leaveIfNoPrefix();
			return;
		}
		Dictionary<HttpListenerPrefix, WebSocketSharp.Net.HttpListener> prefixes;
		Dictionary<HttpListenerPrefix, WebSocketSharp.Net.HttpListener> dictionary;
		do
		{
			prefixes = _prefixes;
			if (!prefixes.ContainsKey(prefix))
			{
				break;
			}
			dictionary = new Dictionary<HttpListenerPrefix, WebSocketSharp.Net.HttpListener>(prefixes);
			dictionary.Remove(prefix);
		}
		while (Interlocked.CompareExchange(ref _prefixes, dictionary, prefixes) != prefixes);
		leaveIfNoPrefix();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Net;
using WebSocketSharp;
using WebSocketSharp.Net;

internal sealed class EndPointManager
{
	private static readonly Dictionary<IPEndPoint, EndPointListener> _endpoints;

	static EndPointManager()
	{
		_endpoints = new Dictionary<IPEndPoint, EndPointListener>();
	}

	private EndPointManager()
	{
	}

	private static void addPrefix(string uriPrefix, WebSocketSharp.Net.HttpListener listener)
	{
		HttpListenerPrefix httpListenerPrefix = new HttpListenerPrefix(uriPrefix);
		IPAddress address = convertToIPAddress(httpListenerPrefix.Host);
		if (!address.IsLocal())
		{
			throw new WebSocketSharp.Net.HttpListenerException(87, "Includes an invalid host.");
		}
		if (!int.TryParse(httpListenerPrefix.Port, out var result))
		{
			throw new WebSocketSharp.Net.HttpListenerException(87, "Includes an invalid port.");
		}
		if (!result.IsPortNumber())
		{
			throw new WebSocketSharp.Net.HttpListenerException(87, "Includes an invalid port.");
		}
		string path = httpListenerPrefix.Path;
		if (path.IndexOf('%') != -1)
		{
			throw new WebSocketSharp.Net.HttpListenerException(87, "Includes an invalid path.");
		}
		if (path.IndexOf("//", StringComparison.Ordinal) != -1)
		{
			throw new WebSocketSharp.Net.HttpListenerException(87, "Includes an invalid path.");
		}
		IPEndPoint iPEndPoint = new IPEndPoint(address, result);
		if (_endpoints.TryGetValue(iPEndPoint, out var value))
		{
			if (value.IsSecure ^ httpListenerPrefix.IsSecure)
			{
				throw new WebSocketSharp.Net.HttpListenerException(87, "Includes an invalid scheme.");
			}
		}
		else
		{
			value = new EndPointListener(iPEndPoint, httpListenerPrefix.IsSecure, listener.CertificateFolderPath, listener.SslConfiguration, listener.ReuseAddress);
			_endpoints.Add(iPEndPoint, value);
		}
		value.AddPrefix(httpListenerPrefix, listener);
	}

	private static IPAddress convertToIPAddress(string hostname)
	{
		return (hostname == "*" || hostname == "+") ? IPAddress.Any : hostname.ToIPAddress();
	}

	private static void removePrefix(string uriPrefix, WebSocketSharp.Net.HttpListener listener)
	{
		HttpListenerPrefix httpListenerPrefix = new HttpListenerPrefix(uriPrefix);
		IPAddress address = convertToIPAddress(httpListenerPrefix.Host);
		if (!address.IsLocal() || !int.TryParse(httpListenerPrefix.Port, out var result) || !result.IsPortNumber())
		{
			return;
		}
		string path = httpListenerPrefix.Path;
		if (path.IndexOf('%') == -1 && path.IndexOf("//", StringComparison.Ordinal) == -1)
		{
			IPEndPoint key = new IPEndPoint(address, result);
			if (_endpoints.TryGetValue(key, out var value) && !(value.IsSecure ^ httpListenerPrefix.IsSecure))
			{
				value.RemovePrefix(httpListenerPrefix, listener);
			}
		}
	}

	internal static bool RemoveEndPoint(IPEndPoint endpoint)
	{
		lock (((ICollection)_endpoints).SyncRoot)
		{
			if (!_endpoints.TryGetValue(endpoint, out var value))
			{
				return false;
			}
			_endpoints.Remove(endpoint);
			value.Close();
			return true;
		}
	}

	public static void AddListener(WebSocketSharp.Net.HttpListener listener)
	{
		List<string> list = new List<string>();
		lock (((ICollection)_endpoints).SyncRoot)
		{
			try
			{
				foreach (string prefix in listener.Prefixes)
				{
					addPrefix(prefix, listener);
					list.Add(prefix);
				}
			}
			catch
			{
				foreach (string item in list)
				{
					removePrefix(item, listener);
				}
				throw;
			}
		}
	}

	public static void AddPrefix(string uriPrefix, WebSocketSharp.Net.HttpListener listener)
	{
		lock (((ICollection)_endpoints).SyncRoot)
		{
			addPrefix(uriPrefix, listener);
		}
	}

	public static void RemoveListener(WebSocketSharp.Net.HttpListener listener)
	{
		lock (((ICollection)_endpoints).SyncRoot)
		{
			foreach (string prefix in listener.Prefixes)
			{
				removePrefix(prefix, listener);
			}
		}
	}

	public static void RemovePrefix(string uriPrefix, WebSocketSharp.Net.HttpListener listener)
	{
		lock (((ICollection)_endpoints).SyncRoot)
		{
			removePrefix(uriPrefix, listener);
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Net.Security;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using WebSocketSharp.Net;

internal sealed class HttpConnection
{
	private byte[] _buffer;

	private const int _bufferLength = 8192;

	private WebSocketSharp.Net.HttpListenerContext _context;

	private bool _contextRegistered;

	private StringBuilder _currentLine;

	private InputState _inputState;

	private RequestStream _inputStream;

	private WebSocketSharp.Net.HttpListener _lastListener;

	private LineState _lineState;

	private EndPointListener _listener;

	private ResponseStream _outputStream;

	private int _position;

	private MemoryStream _requestBuffer;

	private int _reuses;

	private bool _secure;

	private Socket _socket;

	private Stream _stream;

	private object _sync;

	private int _timeout;

	private Dictionary<int, bool> _timeoutCanceled;

	private Timer _timer;

	public bool IsClosed => _socket == null;

	public bool IsSecure => _secure;

	public IPEndPoint LocalEndPoint => (IPEndPoint)_socket.LocalEndPoint;

	public IPEndPoint RemoteEndPoint => (IPEndPoint)_socket.RemoteEndPoint;

	public int Reuses => _reuses;

	public Stream Stream => _stream;

	internal HttpConnection(Socket socket, EndPointListener listener)
	{
		_socket = socket;
		_listener = listener;
		_secure = listener.IsSecure;
		NetworkStream networkStream = new NetworkStream(socket, ownsSocket: false);
		if (_secure)
		{
			ServerSslConfiguration sslConfiguration = listener.SslConfiguration;
			SslStream sslStream = new SslStream(networkStream, leaveInnerStreamOpen: false, sslConfiguration.ClientCertificateValidationCallback);
			sslStream.AuthenticateAsServer(sslConfiguration.ServerCertificate, sslConfiguration.ClientCertificateRequired, sslConfiguration.EnabledSslProtocols, sslConfiguration.CheckCertificateRevocation);
			_stream = sslStream;
		}
		else
		{
			_stream = networkStream;
		}
		_sync = new object();
		_timeout = 90000;
		_timeoutCanceled = new Dictionary<int, bool>();
		_timer = new Timer(onTimeout, this, -1, -1);
		init();
	}

	private void close()
	{
		lock (_sync)
		{
			if (_socket == null)
			{
				return;
			}
			disposeTimer();
			disposeRequestBuffer();
			disposeStream();
			closeSocket();
		}
		unregisterContext();
		removeConnection();
	}

	private void closeSocket()
	{
		try
		{
			_socket.Shutdown(SocketShutdown.Both);
		}
		catch
		{
		}
		_socket.Close();
		_socket = null;
	}

	private void disposeRequestBuffer()
	{
		if (_requestBuffer != null)
		{
			_requestBuffer.Dispose();
			_requestBuffer = null;
		}
	}

	private void disposeStream()
	{
		if (_stream != null)
		{
			_inputStream = null;
			_outputStream = null;
			_stream.Dispose();
			_stream = null;
		}
	}

	private void disposeTimer()
	{
		if (_timer != null)
		{
			try
			{
				_timer.Change(-1, -1);
			}
			catch
			{
			}
			_timer.Dispose();
			_timer = null;
		}
	}

	private void init()
	{
		_context = new WebSocketSharp.Net.HttpListenerContext(this);
		_inputState = InputState.RequestLine;
		_inputStream = null;
		_lineState = LineState.None;
		_outputStream = null;
		_position = 0;
		_requestBuffer = new MemoryStream();
	}

	private static void onRead(IAsyncResult asyncResult)
	{
		HttpConnection httpConnection = (HttpConnection)asyncResult.AsyncState;
		if (httpConnection._socket == null)
		{
			return;
		}
		lock (httpConnection._sync)
		{
			if (httpConnection._socket == null)
			{
				return;
			}
			int num = -1;
			int num2 = 0;
			try
			{
				int reuses = httpConnection._reuses;
				if (!httpConnection._timeoutCanceled[reuses])
				{
					httpConnection._timer.Change(-1, -1);
					httpConnection._timeoutCanceled[reuses] = true;
				}
				num = httpConnection._stream.EndRead(asyncResult);
				httpConnection._requestBuffer.Write(httpConnection._buffer, 0, num);
				num2 = (int)httpConnection._requestBuffer.Length;
			}
			catch (Exception ex)
			{
				if (httpConnection._requestBuffer != null && httpConnection._requestBuffer.Length > 0)
				{
					httpConnection.SendError(ex.Message, 400);
				}
				else
				{
					httpConnection.close();
				}
				return;
			}
			if (num <= 0)
			{
				httpConnection.close();
			}
			else if (httpConnection.processInput(httpConnection._requestBuffer.GetBuffer(), num2))
			{
				if (!httpConnection._context.HasError)
				{
					httpConnection._context.Request.FinishInitialization();
				}
				if (httpConnection._context.HasError)
				{
					httpConnection.SendError();
					return;
				}
				if (!httpConnection._listener.TrySearchHttpListener(httpConnection._context.Request.Url, out var listener))
				{
					httpConnection.SendError(null, 404);
					return;
				}
				if (httpConnection._lastListener != listener)
				{
					httpConnection.removeConnection();
					if (!listener.AddConnection(httpConnection))
					{
						httpConnection.close();
						return;
					}
					httpConnection._lastListener = listener;
				}
				httpConnection._context.Listener = listener;
				if (httpConnection._context.Authenticate() && httpConnection._context.Register())
				{
					httpConnection._contextRegistered = true;
				}
			}
			else
			{
				httpConnection._stream.BeginRead(httpConnection._buffer, 0, 8192, onRead, httpConnection);
			}
		}
	}

	private static void onTimeout(object state)
	{
		HttpConnection httpConnection = (HttpConnection)state;
		int reuses = httpConnection._reuses;
		if (httpConnection._socket == null)
		{
			return;
		}
		lock (httpConnection._sync)
		{
			if (httpConnection._socket != null && !httpConnection._timeoutCanceled[reuses])
			{
				httpConnection.SendError(null, 408);
			}
		}
	}

	private bool processInput(byte[] data, int length)
	{
		if (_currentLine == null)
		{
			_currentLine = new StringBuilder(64);
		}
		int read = 0;
		try
		{
			string text;
			while ((text = readLineFrom(data, _position, length, out read)) != null)
			{
				_position += read;
				if (text.Length == 0)
				{
					if (_inputState != 0)
					{
						if (_position > 32768)
						{
							_context.ErrorMessage = "Headers too long";
						}
						_currentLine = null;
						return true;
					}
				}
				else
				{
					if (_inputState == InputState.RequestLine)
					{
						_context.Request.SetRequestLine(text);
						_inputState = InputState.Headers;
					}
					else
					{
						_context.Request.AddHeader(text);
					}
					if (_context.HasError)
					{
						return true;
					}
				}
			}
		}
		catch (Exception ex)
		{
			_context.ErrorMessage = ex.Message;
			return true;
		}
		_position += read;
		if (_position >= 32768)
		{
			_context.ErrorMessage = "Headers too long";
			return true;
		}
		return false;
	}

	private string readLineFrom(byte[] buffer, int offset, int length, out int read)
	{
		read = 0;
		for (int i = offset; i < length; i++)
		{
			if (_lineState == LineState.Lf)
			{
				break;
			}
			read++;
			byte b = buffer[i];
			switch (b)
			{
			case 13:
				_lineState = LineState.Cr;
				break;
			case 10:
				_lineState = LineState.Lf;
				break;
			default:
				_currentLine.Append((char)b);
				break;
			}
		}
		if (_lineState != LineState.Lf)
		{
			return null;
		}
		string result = _currentLine.ToString();
		_currentLine.Length = 0;
		_lineState = LineState.None;
		return result;
	}

	private void removeConnection()
	{
		if (_lastListener != null)
		{
			_lastListener.RemoveConnection(this);
		}
		else
		{
			_listener.RemoveConnection(this);
		}
	}

	private void unregisterContext()
	{
		if (_contextRegistered)
		{
			_context.Unregister();
			_contextRegistered = false;
		}
	}

	internal void Close(bool force)
	{
		if (_socket == null)
		{
			return;
		}
		lock (_sync)
		{
			if (_socket == null)
			{
				return;
			}
			if (!force)
			{
				GetResponseStream().Close(force: false);
				if (!_context.Response.CloseConnection && _context.Request.FlushInput())
				{
					_reuses++;
					disposeRequestBuffer();
					unregisterContext();
					init();
					BeginReadRequest();
					return;
				}
			}
			else if (_outputStream != null)
			{
				_outputStream.Close(force: true);
			}
			close();
		}
	}

	public void BeginReadRequest()
	{
		if (_buffer == null)
		{
			_buffer = new byte[8192];
		}
		if (_reuses == 1)
		{
			_timeout = 15000;
		}
		try
		{
			_timeoutCanceled.Add(_reuses, value: false);
			_timer.Change(_timeout, -1);
			_stream.BeginRead(_buffer, 0, 8192, onRead, this);
		}
		catch
		{
			close();
		}
	}

	public void Close()
	{
		Close(force: false);
	}

	public RequestStream GetRequestStream(long contentLength, bool chunked)
	{
		if (_inputStream != null || _socket == null)
		{
			return _inputStream;
		}
		lock (_sync)
		{
			if (_socket == null)
			{
				return _inputStream;
			}
			byte[] buffer = _requestBuffer.GetBuffer();
			int num = (int)_requestBuffer.Length;
			disposeRequestBuffer();
			if (chunked)
			{
				_context.Response.SendChunked = true;
				_inputStream = new ChunkedRequestStream(_stream, buffer, _position, num - _position, _context);
			}
			else
			{
				_inputStream = new RequestStream(_stream, buffer, _position, num - _position, contentLength);
			}
			return _inputStream;
		}
	}

	public ResponseStream GetResponseStream()
	{
		if (_outputStream != null || _socket == null)
		{
			return _outputStream;
		}
		lock (_sync)
		{
			if (_socket == null)
			{
				return _outputStream;
			}
			bool ignoreWriteExceptions = _context.Listener?.IgnoreWriteExceptions ?? true;
			_outputStream = new ResponseStream(_stream, _context.Response, ignoreWriteExceptions);
			return _outputStream;
		}
	}

	public void SendError()
	{
		SendError(_context.ErrorMessage, _context.ErrorStatus);
	}

	public void SendError(string message, int status)
	{
		if (_socket == null)
		{
			return;
		}
		lock (_sync)
		{
			if (_socket == null)
			{
				return;
			}
			try
			{
				WebSocketSharp.Net.HttpListenerResponse response = _context.Response;
				response.StatusCode = status;
				response.ContentType = "text/html";
				StringBuilder stringBuilder = new StringBuilder(64);
				stringBuilder.AppendFormat("<html><body><h1>{0} {1}", status, response.StatusDescription);
				if (message != null && message.Length > 0)
				{
					stringBuilder.AppendFormat(" ({0})</h1></body></html>", message);
				}
				else
				{
					stringBuilder.Append("</h1></body></html>");
				}
				Encoding uTF = Encoding.UTF8;
				byte[] bytes = uTF.GetBytes(stringBuilder.ToString());
				response.ContentEncoding = uTF;
				response.ContentLength64 = bytes.LongLength;
				response.Close(bytes, willBlock: true);
			}
			catch
			{
				Close(force: true);
			}
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Security.Principal;
using WebSocketSharp;
using WebSocketSharp.Net;

public sealed class HttpListener : IDisposable
{
	private AuthenticationSchemes _authSchemes;

	private Func<HttpListenerRequest, AuthenticationSchemes> _authSchemeSelector;

	private string _certFolderPath;

	private Dictionary<HttpConnection, HttpConnection> _connections;

	private object _connectionsSync;

	private List<HttpListenerContext> _ctxQueue;

	private object _ctxQueueSync;

	private Dictionary<HttpListenerContext, HttpListenerContext> _ctxRegistry;

	private object _ctxRegistrySync;

	private static readonly string _defaultRealm;

	private bool _disposed;

	private bool _ignoreWriteExceptions;

	private volatile bool _listening;

	private Logger _logger;

	private HttpListenerPrefixCollection _prefixes;

	private string _realm;

	private bool _reuseAddress;

	private ServerSslConfiguration _sslConfig;

	private Func<IIdentity, NetworkCredential> _userCredFinder;

	private List<HttpListenerAsyncResult> _waitQueue;

	private object _waitQueueSync;

	internal bool IsDisposed => _disposed;

	internal bool ReuseAddress
	{
		get
		{
			return _reuseAddress;
		}
		set
		{
			_reuseAddress = value;
		}
	}

	public AuthenticationSchemes AuthenticationSchemes
	{
		get
		{
			CheckDisposed();
			return _authSchemes;
		}
		set
		{
			CheckDisposed();
			_authSchemes = value;
		}
	}

	public Func<HttpListenerRequest, AuthenticationSchemes> AuthenticationSchemeSelector
	{
		get
		{
			CheckDisposed();
			return _authSchemeSelector;
		}
		set
		{
			CheckDisposed();
			_authSchemeSelector = value;
		}
	}

	public string CertificateFolderPath
	{
		get
		{
			CheckDisposed();
			return _certFolderPath;
		}
		set
		{
			CheckDisposed();
			_certFolderPath = value;
		}
	}

	public bool IgnoreWriteExceptions
	{
		get
		{
			CheckDisposed();
			return _ignoreWriteExceptions;
		}
		set
		{
			CheckDisposed();
			_ignoreWriteExceptions = value;
		}
	}

	public bool IsListening => _listening;

	public static bool IsSupported => true;

	public Logger Log => _logger;

	public HttpListenerPrefixCollection Prefixes
	{
		get
		{
			CheckDisposed();
			return _prefixes;
		}
	}

	public string Realm
	{
		get
		{
			CheckDisposed();
			return _realm;
		}
		set
		{
			CheckDisposed();
			_realm = value;
		}
	}

	public ServerSslConfiguration SslConfiguration
	{
		get
		{
			CheckDisposed();
			return _sslConfig ?? (_sslConfig = new ServerSslConfiguration(null));
		}
		set
		{
			CheckDisposed();
			_sslConfig = value;
		}
	}

	public bool UnsafeConnectionNtlmAuthentication
	{
		get
		{
			throw new NotSupportedException();
		}
		set
		{
			throw new NotSupportedException();
		}
	}

	public Func<IIdentity, NetworkCredential> UserCredentialsFinder
	{
		get
		{
			CheckDisposed();
			return _userCredFinder;
		}
		set
		{
			CheckDisposed();
			_userCredFinder = value;
		}
	}

	static HttpListener()
	{
		_defaultRealm = "SECRET AREA";
	}

	public HttpListener()
	{
		_authSchemes = AuthenticationSchemes.Anonymous;
		_connections = new Dictionary<HttpConnection, HttpConnection>();
		_connectionsSync = ((ICollection)_connections).SyncRoot;
		_ctxQueue = new List<HttpListenerContext>();
		_ctxQueueSync = ((ICollection)_ctxQueue).SyncRoot;
		_ctxRegistry = new Dictionary<HttpListenerContext, HttpListenerContext>();
		_ctxRegistrySync = ((ICollection)_ctxRegistry).SyncRoot;
		_logger = new Logger();
		_prefixes = new HttpListenerPrefixCollection(this);
		_waitQueue = new List<HttpListenerAsyncResult>();
		_waitQueueSync = ((ICollection)_waitQueue).SyncRoot;
	}

	private void cleanupConnections()
	{
		HttpConnection[] array = null;
		lock (_connectionsSync)
		{
			if (_connections.Count == 0)
			{
				return;
			}
			Dictionary<HttpConnection, HttpConnection>.KeyCollection keys = _connections.Keys;
			array = new HttpConnection[keys.Count];
			keys.CopyTo(array, 0);
			_connections.Clear();
		}
		for (int num = array.Length - 1; num >= 0; num--)
		{
			array[num].Close(force: true);
		}
	}

	private void cleanupContextQueue(bool sendServiceUnavailable)
	{
		HttpListenerContext[] array = null;
		lock (_ctxQueueSync)
		{
			if (_ctxQueue.Count == 0)
			{
				return;
			}
			array = _ctxQueue.ToArray();
			_ctxQueue.Clear();
		}
		if (sendServiceUnavailable)
		{
			HttpListenerContext[] array2 = array;
			foreach (HttpListenerContext httpListenerContext in array2)
			{
				HttpListenerResponse response = httpListenerContext.Response;
				response.StatusCode = 503;
				response.Close();
			}
		}
	}

	private void cleanupContextRegistry()
	{
		HttpListenerContext[] array = null;
		lock (_ctxRegistrySync)
		{
			if (_ctxRegistry.Count == 0)
			{
				return;
			}
			Dictionary<HttpListenerContext, HttpListenerContext>.KeyCollection keys = _ctxRegistry.Keys;
			array = new HttpListenerContext[keys.Count];
			keys.CopyTo(array, 0);
			_ctxRegistry.Clear();
		}
		for (int num = array.Length - 1; num >= 0; num--)
		{
			array[num].Connection.Close(force: true);
		}
	}

	private void cleanupWaitQueue(Exception exception)
	{
		HttpListenerAsyncResult[] array = null;
		lock (_waitQueueSync)
		{
			if (_waitQueue.Count == 0)
			{
				return;
			}
			array = _waitQueue.ToArray();
			_waitQueue.Clear();
		}
		HttpListenerAsyncResult[] array2 = array;
		foreach (HttpListenerAsyncResult httpListenerAsyncResult in array2)
		{
			httpListenerAsyncResult.Complete(exception);
		}
	}

	private void close(bool force)
	{
		if (_listening)
		{
			_listening = false;
			EndPointManager.RemoveListener(this);
		}
		lock (_ctxRegistrySync)
		{
			cleanupContextQueue(!force);
		}
		cleanupContextRegistry();
		cleanupConnections();
		cleanupWaitQueue(new ObjectDisposedException(GetType().ToString()));
		_disposed = true;
	}

	private HttpListenerAsyncResult getAsyncResultFromQueue()
	{
		if (_waitQueue.Count == 0)
		{
			return null;
		}
		HttpListenerAsyncResult result = _waitQueue[0];
		_waitQueue.RemoveAt(0);
		return result;
	}

	private HttpListenerContext getContextFromQueue()
	{
		if (_ctxQueue.Count == 0)
		{
			return null;
		}
		HttpListenerContext result = _ctxQueue[0];
		_ctxQueue.RemoveAt(0);
		return result;
	}

	internal bool AddConnection(HttpConnection connection)
	{
		if (!_listening)
		{
			return false;
		}
		lock (_connectionsSync)
		{
			if (!_listening)
			{
				return false;
			}
			_connections[connection] = connection;
			return true;
		}
	}

	internal HttpListenerAsyncResult BeginGetContext(HttpListenerAsyncResult asyncResult)
	{
		lock (_ctxRegistrySync)
		{
			if (!_listening)
			{
				throw new HttpListenerException(995);
			}
			HttpListenerContext contextFromQueue = getContextFromQueue();
			if (contextFromQueue == null)
			{
				_waitQueue.Add(asyncResult);
			}
			else
			{
				asyncResult.Complete(contextFromQueue, syncCompleted: true);
			}
			return asyncResult;
		}
	}

	internal void CheckDisposed()
	{
		if (_disposed)
		{
			throw new ObjectDisposedException(GetType().ToString());
		}
	}

	internal string GetRealm()
	{
		string realm = _realm;
		return (realm != null && realm.Length > 0) ? realm : _defaultRealm;
	}

	internal Func<IIdentity, NetworkCredential> GetUserCredentialsFinder()
	{
		return _userCredFinder;
	}

	internal bool RegisterContext(HttpListenerContext context)
	{
		if (!_listening)
		{
			return false;
		}
		lock (_ctxRegistrySync)
		{
			if (!_listening)
			{
				return false;
			}
			_ctxRegistry[context] = context;
			HttpListenerAsyncResult asyncResultFromQueue = getAsyncResultFromQueue();
			if (asyncResultFromQueue == null)
			{
				_ctxQueue.Add(context);
			}
			else
			{
				asyncResultFromQueue.Complete(context);
			}
			return true;
		}
	}

	internal void RemoveConnection(HttpConnection connection)
	{
		lock (_connectionsSync)
		{
			_connections.Remove(connection);
		}
	}

	internal AuthenticationSchemes SelectAuthenticationScheme(HttpListenerRequest request)
	{
		Func<HttpListenerRequest, AuthenticationSchemes> authSchemeSelector = _authSchemeSelector;
		if (authSchemeSelector == null)
		{
			return _authSchemes;
		}
		try
		{
			return authSchemeSelector(request);
		}
		catch
		{
			return AuthenticationSchemes.None;
		}
	}

	internal void UnregisterContext(HttpListenerContext context)
	{
		lock (_ctxRegistrySync)
		{
			_ctxRegistry.Remove(context);
		}
	}

	public void Abort()
	{
		if (!_disposed)
		{
			close(force: true);
		}
	}

	public IAsyncResult BeginGetContext(AsyncCallback callback, object state)
	{
		CheckDisposed();
		if (_prefixes.Count == 0)
		{
			throw new InvalidOperationException("The listener has no URI prefix on which listens.");
		}
		if (!_listening)
		{
			throw new InvalidOperationException("The listener hasn't been started.");
		}
		return BeginGetContext(new HttpListenerAsyncResult(callback, state));
	}

	public void Close()
	{
		if (!_disposed)
		{
			close(force: false);
		}
	}

	public HttpListenerContext EndGetContext(IAsyncResult asyncResult)
	{
		CheckDisposed();
		if (asyncResult == null)
		{
			throw new ArgumentNullException("asyncResult");
		}
		if (!(asyncResult is HttpListenerAsyncResult httpListenerAsyncResult))
		{
			throw new ArgumentException("A wrong IAsyncResult.", "asyncResult");
		}
		if (httpListenerAsyncResult.EndCalled)
		{
			throw new InvalidOperationException("This IAsyncResult cannot be reused.");
		}
		httpListenerAsyncResult.EndCalled = true;
		if (!httpListenerAsyncResult.IsCompleted)
		{
			httpListenerAsyncResult.AsyncWaitHandle.WaitOne();
		}
		return httpListenerAsyncResult.GetContext();
	}

	public HttpListenerContext GetContext()
	{
		CheckDisposed();
		if (_prefixes.Count == 0)
		{
			throw new InvalidOperationException("The listener has no URI prefix on which listens.");
		}
		if (!_listening)
		{
			throw new InvalidOperationException("The listener hasn't been started.");
		}
		HttpListenerAsyncResult httpListenerAsyncResult = BeginGetContext(new HttpListenerAsyncResult(null, null));
		httpListenerAsyncResult.InGet = true;
		return EndGetContext(httpListenerAsyncResult);
	}

	public void Start()
	{
		CheckDisposed();
		if (!_listening)
		{
			EndPointManager.AddListener(this);
			_listening = true;
		}
	}

	public void Stop()
	{
		CheckDisposed();
		if (_listening)
		{
			_listening = false;
			EndPointManager.RemoveListener(this);
			lock (_ctxRegistrySync)
			{
				cleanupContextQueue(sendServiceUnavailable: true);
			}
			cleanupContextRegistry();
			cleanupConnections();
			cleanupWaitQueue(new HttpListenerException(995, "The listener is stopped."));
		}
	}

	void IDisposable.Dispose()
	{
		if (!_disposed)
		{
			close(force: true);
		}
	}
}


using System;
using System.Security.Principal;
using WebSocketSharp;
using WebSocketSharp.Net;
using WebSocketSharp.Net.WebSockets;

public sealed class HttpListenerContext
{
	private HttpConnection _connection;

	private string _error;

	private int _errorStatus;

	private HttpListener _listener;

	private HttpListenerRequest _request;

	private HttpListenerResponse _response;

	private IPrincipal _user;

	private HttpListenerWebSocketContext _websocketContext;

	internal HttpConnection Connection => _connection;

	internal string ErrorMessage
	{
		get
		{
			return _error;
		}
		set
		{
			_error = value;
		}
	}

	internal int ErrorStatus
	{
		get
		{
			return _errorStatus;
		}
		set
		{
			_errorStatus = value;
		}
	}

	internal bool HasError => _error != null;

	internal HttpListener Listener
	{
		get
		{
			return _listener;
		}
		set
		{
			_listener = value;
		}
	}

	public HttpListenerRequest Request => _request;

	public HttpListenerResponse Response => _response;

	public IPrincipal User => _user;

	internal HttpListenerContext(HttpConnection connection)
	{
		_connection = connection;
		_errorStatus = 400;
		_request = new HttpListenerRequest(this);
		_response = new HttpListenerResponse(this);
	}

	internal bool Authenticate()
	{
		AuthenticationSchemes authenticationSchemes = _listener.SelectAuthenticationScheme(_request);
		switch (authenticationSchemes)
		{
		case AuthenticationSchemes.Anonymous:
			return true;
		case AuthenticationSchemes.None:
			_response.Close(HttpStatusCode.Forbidden);
			return false;
		default:
		{
			string realm = _listener.GetRealm();
			IPrincipal principal = HttpUtility.CreateUser(_request.Headers["Authorization"], authenticationSchemes, realm, _request.HttpMethod, _listener.GetUserCredentialsFinder());
			if (principal == null || !principal.Identity.IsAuthenticated)
			{
				_response.CloseWithAuthChallenge(new AuthenticationChallenge(authenticationSchemes, realm).ToString());
				return false;
			}
			_user = principal;
			return true;
		}
		}
	}

	internal bool Register()
	{
		return _listener.RegisterContext(this);
	}

	internal void Unregister()
	{
		_listener.UnregisterContext(this);
	}

	public HttpListenerWebSocketContext AcceptWebSocket(string protocol)
	{
		if (_websocketContext != null)
		{
			throw new InvalidOperationException("The accepting is already in progress.");
		}
		if (protocol != null)
		{
			if (protocol.Length == 0)
			{
				throw new ArgumentException("An empty string.", "protocol");
			}
			if (!protocol.IsToken())
			{
				throw new ArgumentException("Contains an invalid character.", "protocol");
			}
		}
		_websocketContext = new HttpListenerWebSocketContext(this, protocol);
		return _websocketContext;
	}
}


using System;
using System.ComponentModel;
using System.Runtime.Serialization;

[Serializable]
public class HttpListenerException : Win32Exception
{
	public override int ErrorCode => base.NativeErrorCode;

	protected HttpListenerException(SerializationInfo serializationInfo, StreamingContext streamingContext)
		: base(serializationInfo, streamingContext)
	{
	}

	public HttpListenerException()
	{
	}

	public HttpListenerException(int errorCode)
		: base(errorCode)
	{
	}

	public HttpListenerException(int errorCode, string message)
		: base(errorCode, message)
	{
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using WebSocketSharp.Net;

public class HttpListenerPrefixCollection : ICollection<string>, IEnumerable<string>, IEnumerable
{
	private HttpListener _listener;

	private List<string> _prefixes;

	public int Count => _prefixes.Count;

	public bool IsReadOnly => false;

	public bool IsSynchronized => false;

	internal HttpListenerPrefixCollection(HttpListener listener)
	{
		_listener = listener;
		_prefixes = new List<string>();
	}

	public void Add(string uriPrefix)
	{
		_listener.CheckDisposed();
		HttpListenerPrefix.CheckPrefix(uriPrefix);
		if (!_prefixes.Contains(uriPrefix))
		{
			_prefixes.Add(uriPrefix);
			if (_listener.IsListening)
			{
				EndPointManager.AddPrefix(uriPrefix, _listener);
			}
		}
	}

	public void Clear()
	{
		_listener.CheckDisposed();
		_prefixes.Clear();
		if (_listener.IsListening)
		{
			EndPointManager.RemoveListener(_listener);
		}
	}

	public bool Contains(string uriPrefix)
	{
		_listener.CheckDisposed();
		if (uriPrefix == null)
		{
			throw new ArgumentNullException("uriPrefix");
		}
		return _prefixes.Contains(uriPrefix);
	}

	public void CopyTo(Array array, int offset)
	{
		_listener.CheckDisposed();
		((ICollection)_prefixes).CopyTo(array, offset);
	}

	public void CopyTo(string[] array, int offset)
	{
		_listener.CheckDisposed();
		_prefixes.CopyTo(array, offset);
	}

	public IEnumerator<string> GetEnumerator()
	{
		return _prefixes.GetEnumerator();
	}

	public bool Remove(string uriPrefix)
	{
		_listener.CheckDisposed();
		if (uriPrefix == null)
		{
			throw new ArgumentNullException("uriPrefix");
		}
		bool flag = _prefixes.Remove(uriPrefix);
		if (flag && _listener.IsListening)
		{
			EndPointManager.RemovePrefix(uriPrefix, _listener);
		}
		return flag;
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return _prefixes.GetEnumerator();
	}
}


using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Globalization;
using System.IO;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using WebSocketSharp;
using WebSocketSharp.Net;

public sealed class HttpListenerRequest
{
	private static readonly byte[] _100continue;

	private string[] _acceptTypes;

	private bool _chunked;

	private Encoding _contentEncoding;

	private long _contentLength;

	private bool _contentLengthSet;

	private WebSocketSharp.Net.HttpListenerContext _context;

	private WebSocketSharp.Net.CookieCollection _cookies;

	private WebSocketSharp.Net.WebHeaderCollection _headers;

	private Guid _identifier;

	private Stream _inputStream;

	private bool _keepAlive;

	private bool _keepAliveSet;

	private string _method;

	private NameValueCollection _queryString;

	private Uri _referer;

	private string _uri;

	private Uri _url;

	private string[] _userLanguages;

	private Version _version;

	private bool _websocketRequest;

	private bool _websocketRequestSet;

	public string[] AcceptTypes => _acceptTypes;

	public int ClientCertificateError => 0;

	public Encoding ContentEncoding => _contentEncoding ?? (_contentEncoding = Encoding.Default);

	public long ContentLength64 => _contentLength;

	public string ContentType => _headers["Content-Type"];

	public WebSocketSharp.Net.CookieCollection Cookies => _cookies ?? (_cookies = _headers.GetCookies(response: false));

	public bool HasEntityBody => _contentLength > 0 || _chunked;

	public NameValueCollection Headers => _headers;

	public string HttpMethod => _method;

	public Stream InputStream => _inputStream ?? (_inputStream = (HasEntityBody ? _context.Connection.GetRequestStream(_contentLength, _chunked) : Stream.Null));

	public bool IsAuthenticated => _context.User != null;

	public bool IsLocal => RemoteEndPoint.Address.IsLocal();

	public bool IsSecureConnection => _context.Connection.IsSecure;

	public bool IsWebSocketRequest
	{
		get
		{
			if (!_websocketRequestSet)
			{
				_websocketRequest = _method == "GET" && _version > WebSocketSharp.Net.HttpVersion.Version10 && _headers.Contains("Upgrade", "websocket") && _headers.Contains("Connection", "Upgrade");
				_websocketRequestSet = true;
			}
			return _websocketRequest;
		}
	}

	public bool KeepAlive
	{
		get
		{
			if (!_keepAliveSet)
			{
				string text;
				_keepAlive = _version > WebSocketSharp.Net.HttpVersion.Version10 || _headers.Contains("Connection", "keep-alive") || ((text = _headers["Keep-Alive"]) != null && text != "closed");
				_keepAliveSet = true;
			}
			return _keepAlive;
		}
	}

	public IPEndPoint LocalEndPoint => _context.Connection.LocalEndPoint;

	public Version ProtocolVersion => _version;

	public NameValueCollection QueryString => _queryString ?? (_queryString = HttpUtility.InternalParseQueryString(_url.Query, Encoding.UTF8));

	public string RawUrl => _url.PathAndQuery;

	public IPEndPoint RemoteEndPoint => _context.Connection.RemoteEndPoint;

	public Guid RequestTraceIdentifier => _identifier;

	public Uri Url => _url;

	public Uri UrlReferrer => _referer;

	public string UserAgent => _headers["User-Agent"];

	public string UserHostAddress => LocalEndPoint.ToString();

	public string UserHostName => _headers["Host"];

	public string[] UserLanguages => _userLanguages;

	static HttpListenerRequest()
	{
		_100continue = Encoding.ASCII.GetBytes("HTTP/1.1 100 Continue\r\n\r\n");
	}

	internal HttpListenerRequest(WebSocketSharp.Net.HttpListenerContext context)
	{
		_context = context;
		_contentLength = -1L;
		_headers = new WebSocketSharp.Net.WebHeaderCollection();
		_identifier = Guid.NewGuid();
	}

	private static bool tryCreateVersion(string version, out Version result)
	{
		try
		{
			result = new Version(version);
			return true;
		}
		catch
		{
			result = null;
			return false;
		}
	}

	internal void AddHeader(string header)
	{
		int num = header.IndexOf(':');
		if (num == -1)
		{
			_context.ErrorMessage = "Invalid header";
			return;
		}
		string text = header.Substring(0, num).Trim();
		string text2 = header.Substring(num + 1).Trim();
		_headers.InternalSet(text, text2, response: false);
		switch (text.ToLower(CultureInfo.InvariantCulture))
		{
		case "accept":
			_acceptTypes = new List<string>(text2.SplitHeaderValue(',')).ToArray();
			break;
		case "accept-language":
			_userLanguages = text2.Split(new char[1] { ',' });
			break;
		case "content-length":
		{
			if (long.TryParse(text2, out var result) && result >= 0)
			{
				_contentLength = result;
				_contentLengthSet = true;
			}
			else
			{
				_context.ErrorMessage = "Invalid Content-Length header";
			}
			break;
		}
		case "content-type":
			try
			{
				_contentEncoding = HttpUtility.GetEncoding(text2);
				break;
			}
			catch
			{
				_context.ErrorMessage = "Invalid Content-Type header";
				break;
			}
		case "referer":
			_referer = text2.ToUri();
			break;
		}
	}

	internal void FinishInitialization()
	{
		string text = _headers["Host"];
		bool flag = text == null || text.Length == 0;
		if (_version > WebSocketSharp.Net.HttpVersion.Version10 && flag)
		{
			_context.ErrorMessage = "Invalid Host header";
			return;
		}
		if (flag)
		{
			text = UserHostAddress;
		}
		_url = HttpUtility.CreateRequestUrl(_uri, text, IsWebSocketRequest, IsSecureConnection);
		if (_url == null)
		{
			_context.ErrorMessage = "Invalid request url";
			return;
		}
		string text2 = Headers["Transfer-Encoding"];
		if (_version > WebSocketSharp.Net.HttpVersion.Version10 && text2 != null && text2.Length > 0)
		{
			_chunked = text2.ToLower() == "chunked";
			if (!_chunked)
			{
				_context.ErrorMessage = string.Empty;
				_context.ErrorStatus = 501;
				return;
			}
		}
		if (!_chunked && !_contentLengthSet)
		{
			string text3 = _method.ToLower();
			if (text3 == "post" || text3 == "put")
			{
				_context.ErrorMessage = string.Empty;
				_context.ErrorStatus = 411;
				return;
			}
		}
		string text4 = Headers["Expect"];
		if (text4 != null && text4.Length > 0 && text4.ToLower() == "100-continue")
		{
			ResponseStream responseStream = _context.Connection.GetResponseStream();
			responseStream.InternalWrite(_100continue, 0, _100continue.Length);
		}
	}

	internal bool FlushInput()
	{
		if (!HasEntityBody)
		{
			return true;
		}
		int num = 2048;
		if (_contentLength > 0)
		{
			num = (int)Math.Min(_contentLength, num);
		}
		byte[] buffer = new byte[num];
		while (true)
		{
			try
			{
				IAsyncResult asyncResult = InputStream.BeginRead(buffer, 0, num, null, null);
				if (!asyncResult.IsCompleted && !asyncResult.AsyncWaitHandle.WaitOne(100))
				{
					return false;
				}
				if (InputStream.EndRead(asyncResult) <= 0)
				{
					return true;
				}
			}
			catch
			{
				return false;
			}
		}
	}

	internal void SetRequestLine(string requestLine)
	{
		string[] array = requestLine.Split(new char[1] { ' ' }, 3);
		if (array.Length != 3)
		{
			_context.ErrorMessage = "Invalid request line (parts)";
			return;
		}
		_method = array[0];
		if (!_method.IsToken())
		{
			_context.ErrorMessage = "Invalid request line (method)";
			return;
		}
		_uri = array[1];
		string text = array[2];
		if (text.Length != 8 || !text.StartsWith("HTTP/") || !tryCreateVersion(text.Substring(5), out _version) || _version.Major < 1)
		{
			_context.ErrorMessage = "Invalid request line (version)";
		}
	}

	public IAsyncResult BeginGetClientCertificate(AsyncCallback requestCallback, object state)
	{
		throw new NotImplementedException();
	}

	public X509Certificate2 EndGetClientCertificate(IAsyncResult asyncResult)
	{
		throw new NotImplementedException();
	}

	public X509Certificate2 GetClientCertificate()
	{
		throw new NotImplementedException();
	}

	public override string ToString()
	{
		StringBuilder stringBuilder = new StringBuilder(64);
		stringBuilder.AppendFormat("{0} {1} HTTP/{2}\r\n", _method, _uri, _version);
		stringBuilder.Append(_headers.ToString());
		return stringBuilder.ToString();
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Net;
using System.Text;
using WebSocketSharp;
using WebSocketSharp.Net;

public sealed class HttpListenerResponse : IDisposable
{
	private bool _closeConnection;

	private Encoding _contentEncoding;

	private long _contentLength;

	private string _contentType;

	private WebSocketSharp.Net.HttpListenerContext _context;

	private WebSocketSharp.Net.CookieCollection _cookies;

	private bool _disposed;

	private WebSocketSharp.Net.WebHeaderCollection _headers;

	private bool _headersSent;

	private bool _keepAlive;

	private string _location;

	private ResponseStream _outputStream;

	private bool _sendChunked;

	private int _statusCode;

	private string _statusDescription;

	private Version _version;

	internal bool CloseConnection
	{
		get
		{
			return _closeConnection;
		}
		set
		{
			_closeConnection = value;
		}
	}

	internal bool HeadersSent
	{
		get
		{
			return _headersSent;
		}
		set
		{
			_headersSent = value;
		}
	}

	public Encoding ContentEncoding
	{
		get
		{
			return _contentEncoding;
		}
		set
		{
			checkDisposed();
			_contentEncoding = value;
		}
	}

	public long ContentLength64
	{
		get
		{
			return _contentLength;
		}
		set
		{
			checkDisposedOrHeadersSent();
			if (value < 0)
			{
				throw new ArgumentOutOfRangeException("Less than zero.", "value");
			}
			_contentLength = value;
		}
	}

	public string ContentType
	{
		get
		{
			return _contentType;
		}
		set
		{
			checkDisposed();
			if (value != null && value.Length == 0)
			{
				throw new ArgumentException("An empty string.", "value");
			}
			_contentType = value;
		}
	}

	public WebSocketSharp.Net.CookieCollection Cookies
	{
		get
		{
			return _cookies ?? (_cookies = new WebSocketSharp.Net.CookieCollection());
		}
		set
		{
			_cookies = value;
		}
	}

	public WebSocketSharp.Net.WebHeaderCollection Headers
	{
		get
		{
			return _headers ?? (_headers = new WebSocketSharp.Net.WebHeaderCollection(HttpHeaderType.Response, internallyUsed: false));
		}
		set
		{
			if (value != null && value.State != HttpHeaderType.Response)
			{
				throw new InvalidOperationException("The specified headers aren't valid for a response.");
			}
			_headers = value;
		}
	}

	public bool KeepAlive
	{
		get
		{
			return _keepAlive;
		}
		set
		{
			checkDisposedOrHeadersSent();
			_keepAlive = value;
		}
	}

	public Stream OutputStream
	{
		get
		{
			checkDisposed();
			return _outputStream ?? (_outputStream = _context.Connection.GetResponseStream());
		}
	}

	public Version ProtocolVersion
	{
		get
		{
			return _version;
		}
		set
		{
			checkDisposedOrHeadersSent();
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (value.Major != 1 || (value.Minor != 0 && value.Minor != 1))
			{
				throw new ArgumentException("Not 1.0 or 1.1.", "value");
			}
			_version = value;
		}
	}

	public string RedirectLocation
	{
		get
		{
			return _location;
		}
		set
		{
			checkDisposed();
			if (value == null)
			{
				_location = null;
				return;
			}
			Uri result = null;
			if (!value.MaybeUri() || !Uri.TryCreate(value, UriKind.Absolute, out result))
			{
				throw new ArgumentException("Not an absolute URL.", "value");
			}
			_location = value;
		}
	}

	public bool SendChunked
	{
		get
		{
			return _sendChunked;
		}
		set
		{
			checkDisposedOrHeadersSent();
			_sendChunked = value;
		}
	}

	public int StatusCode
	{
		get
		{
			return _statusCode;
		}
		set
		{
			checkDisposedOrHeadersSent();
			if (value < 100 || value > 999)
			{
				throw new ProtocolViolationException("A value isn't between 100 and 999 inclusive.");
			}
			_statusCode = value;
			_statusDescription = value.GetStatusDescription();
		}
	}

	public string StatusDescription
	{
		get
		{
			return _statusDescription;
		}
		set
		{
			checkDisposedOrHeadersSent();
			if (value == null || value.Length == 0)
			{
				_statusDescription = _statusCode.GetStatusDescription();
				return;
			}
			if (!value.IsText() || value.IndexOfAny(new char[2] { '\r', '\n' }) > -1)
			{
				throw new ArgumentException("Contains invalid characters.", "value");
			}
			_statusDescription = value;
		}
	}

	internal HttpListenerResponse(WebSocketSharp.Net.HttpListenerContext context)
	{
		_context = context;
		_keepAlive = true;
		_statusCode = 200;
		_statusDescription = "OK";
		_version = WebSocketSharp.Net.HttpVersion.Version11;
	}

	private bool canAddOrUpdate(WebSocketSharp.Net.Cookie cookie)
	{
		if (_cookies == null || _cookies.Count == 0)
		{
			return true;
		}
		List<WebSocketSharp.Net.Cookie> list = findCookie(cookie).ToList();
		if (list.Count == 0)
		{
			return true;
		}
		int version = cookie.Version;
		foreach (WebSocketSharp.Net.Cookie item in list)
		{
			if (item.Version == version)
			{
				return true;
			}
		}
		return false;
	}

	private void checkDisposed()
	{
		if (_disposed)
		{
			throw new ObjectDisposedException(GetType().ToString());
		}
	}

	private void checkDisposedOrHeadersSent()
	{
		if (_disposed)
		{
			throw new ObjectDisposedException(GetType().ToString());
		}
		if (_headersSent)
		{
			throw new InvalidOperationException("Cannot be changed after the headers are sent.");
		}
	}

	private void close(bool force)
	{
		_disposed = true;
		_context.Connection.Close(force);
	}

	private IEnumerable<WebSocketSharp.Net.Cookie> findCookie(WebSocketSharp.Net.Cookie cookie)
	{
		string name = cookie.Name;
		string domain = cookie.Domain;
		string path = cookie.Path;
		if (_cookies == null)
		{
			yield break;
		}
		foreach (WebSocketSharp.Net.Cookie c in _cookies)
		{
			if (c.Name.Equals(name, StringComparison.OrdinalIgnoreCase) && c.Domain.Equals(domain, StringComparison.OrdinalIgnoreCase) && c.Path.Equals(path, StringComparison.Ordinal))
			{
				yield return c;
			}
		}
	}

	internal WebSocketSharp.Net.WebHeaderCollection WriteHeadersTo(MemoryStream destination)
	{
		WebSocketSharp.Net.WebHeaderCollection webHeaderCollection = new WebSocketSharp.Net.WebHeaderCollection(HttpHeaderType.Response, internallyUsed: true);
		if (_headers != null)
		{
			webHeaderCollection.Add(_headers);
		}
		if (_contentType != null)
		{
			string value = ((_contentType.IndexOf("charset=", StringComparison.Ordinal) == -1 && _contentEncoding != null) ? $"{_contentType}; charset={_contentEncoding.WebName}" : _contentType);
			webHeaderCollection.InternalSet("Content-Type", value, response: true);
		}
		if (webHeaderCollection["Server"] == null)
		{
			webHeaderCollection.InternalSet("Server", "websocket-sharp/1.0", response: true);
		}
		CultureInfo invariantCulture = CultureInfo.InvariantCulture;
		if (webHeaderCollection["Date"] == null)
		{
			webHeaderCollection.InternalSet("Date", DateTime.UtcNow.ToString("r", invariantCulture), response: true);
		}
		if (!_sendChunked)
		{
			webHeaderCollection.InternalSet("Content-Length", _contentLength.ToString(invariantCulture), response: true);
		}
		else
		{
			webHeaderCollection.InternalSet("Transfer-Encoding", "chunked", response: true);
		}
		bool flag = !_context.Request.KeepAlive || !_keepAlive || _statusCode == 400 || _statusCode == 408 || _statusCode == 411 || _statusCode == 413 || _statusCode == 414 || _statusCode == 500 || _statusCode == 503;
		int reuses = _context.Connection.Reuses;
		if (flag || reuses >= 100)
		{
			webHeaderCollection.InternalSet("Connection", "close", response: true);
		}
		else
		{
			webHeaderCollection.InternalSet("Keep-Alive", $"timeout=15,max={100 - reuses}", response: true);
			if (_context.Request.ProtocolVersion < WebSocketSharp.Net.HttpVersion.Version11)
			{
				webHeaderCollection.InternalSet("Connection", "keep-alive", response: true);
			}
		}
		if (_location != null)
		{
			webHeaderCollection.InternalSet("Location", _location, response: true);
		}
		if (_cookies != null)
		{
			foreach (WebSocketSharp.Net.Cookie cookie in _cookies)
			{
				webHeaderCollection.InternalSet("Set-Cookie", cookie.ToResponseString(), response: true);
			}
		}
		Encoding encoding = _contentEncoding ?? Encoding.Default;
		StreamWriter streamWriter = new StreamWriter(destination, encoding, 256);
		streamWriter.Write("HTTP/{0} {1} {2}\r\n", _version, _statusCode, _statusDescription);
		streamWriter.Write(webHeaderCollection.ToStringMultiValue(response: true));
		streamWriter.Flush();
		destination.Position = encoding.GetPreamble().Length;
		return webHeaderCollection;
	}

	public void Abort()
	{
		if (!_disposed)
		{
			close(force: true);
		}
	}

	public void AddHeader(string name, string value)
	{
		Headers.Set(name, value);
	}

	public void AppendCookie(WebSocketSharp.Net.Cookie cookie)
	{
		Cookies.Add(cookie);
	}

	public void AppendHeader(string name, string value)
	{
		Headers.Add(name, value);
	}

	public void Close()
	{
		if (!_disposed)
		{
			close(force: false);
		}
	}

	public void Close(byte[] responseEntity, bool willBlock)
	{
		checkDisposed();
		if (responseEntity == null)
		{
			throw new ArgumentNullException("responseEntity");
		}
		int count = responseEntity.Length;
		Stream output = OutputStream;
		if (willBlock)
		{
			output.Write(responseEntity, 0, count);
			close(force: false);
			return;
		}
		output.BeginWrite(responseEntity, 0, count, delegate(IAsyncResult ar)
		{
			output.EndWrite(ar);
			close(force: false);
		}, null);
	}

	public void CopyFrom(WebSocketSharp.Net.HttpListenerResponse templateResponse)
	{
		if (templateResponse == null)
		{
			throw new ArgumentNullException("templateResponse");
		}
		if (templateResponse._headers != null)
		{
			if (_headers != null)
			{
				_headers.Clear();
			}
			Headers.Add(templateResponse._headers);
		}
		else if (_headers != null)
		{
			_headers = null;
		}
		_contentLength = templateResponse._contentLength;
		_statusCode = templateResponse._statusCode;
		_statusDescription = templateResponse._statusDescription;
		_keepAlive = templateResponse._keepAlive;
		_version = templateResponse._version;
	}

	public void Redirect(string url)
	{
		checkDisposedOrHeadersSent();
		if (url == null)
		{
			throw new ArgumentNullException("url");
		}
		Uri result = null;
		if (!url.MaybeUri() || !Uri.TryCreate(url, UriKind.Absolute, out result))
		{
			throw new ArgumentException("Not an absolute URL.", "url");
		}
		_location = url;
		_statusCode = 302;
		_statusDescription = "Found";
	}

	public void SetCookie(WebSocketSharp.Net.Cookie cookie)
	{
		if (cookie == null)
		{
			throw new ArgumentNullException("cookie");
		}
		if (!canAddOrUpdate(cookie))
		{
			throw new ArgumentException("Cannot be replaced.", "cookie");
		}
		Cookies.Add(cookie);
	}

	void IDisposable.Dispose()
	{
		if (!_disposed)
		{
			close(force: true);
		}
	}
}


using System;
using System.Threading;

internal class HttpStreamAsyncResult : IAsyncResult
{
	private byte[] _buffer;

	private AsyncCallback _callback;

	private bool _completed;

	private int _count;

	private Exception _exception;

	private int _offset;

	private object _state;

	private object _sync;

	private int _syncRead;

	private ManualResetEvent _waitHandle;

	internal byte[] Buffer
	{
		get
		{
			return _buffer;
		}
		set
		{
			_buffer = value;
		}
	}

	internal int Count
	{
		get
		{
			return _count;
		}
		set
		{
			_count = value;
		}
	}

	internal Exception Exception => _exception;

	internal bool HasException => _exception != null;

	internal int Offset
	{
		get
		{
			return _offset;
		}
		set
		{
			_offset = value;
		}
	}

	internal int SyncRead
	{
		get
		{
			return _syncRead;
		}
		set
		{
			_syncRead = value;
		}
	}

	public object AsyncState => _state;

	public WaitHandle AsyncWaitHandle
	{
		get
		{
			lock (_sync)
			{
				return _waitHandle ?? (_waitHandle = new ManualResetEvent(_completed));
			}
		}
	}

	public bool CompletedSynchronously => _syncRead == _count;

	public bool IsCompleted
	{
		get
		{
			lock (_sync)
			{
				return _completed;
			}
		}
	}

	internal HttpStreamAsyncResult(AsyncCallback callback, object state)
	{
		_callback = callback;
		_state = state;
		_sync = new object();
	}

	internal void Complete()
	{
		lock (_sync)
		{
			if (_completed)
			{
				return;
			}
			_completed = true;
			if (_waitHandle != null)
			{
				_waitHandle.Set();
			}
			if (_callback != null)
			{
				_callback.BeginInvoke(this, delegate(IAsyncResult ar)
				{
					_callback.EndInvoke(ar);
				}, null);
			}
		}
	}

	internal void Complete(Exception exception)
	{
		_exception = exception;
		Complete();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Globalization;
using System.IO;
using System.Security.Principal;
using System.Text;
using WebSocketSharp;
using WebSocketSharp.Net;

internal sealed class HttpUtility
{
	private static Dictionary<string, char> _entities;

	private static char[] _hexChars = "0123456789abcdef".ToCharArray();

	private static object _sync = new object();

	private static int getChar(byte[] bytes, int offset, int length)
	{
		int num = 0;
		int num2 = length + offset;
		for (int i = offset; i < num2; i++)
		{
			int @int = getInt(bytes[i]);
			if (@int == -1)
			{
				return -1;
			}
			num = (num << 4) + @int;
		}
		return num;
	}

	private static int getChar(string s, int offset, int length)
	{
		int num = 0;
		int num2 = length + offset;
		for (int i = offset; i < num2; i++)
		{
			char c = s[i];
			if (c > '\u007f')
			{
				return -1;
			}
			int @int = getInt((byte)c);
			if (@int == -1)
			{
				return -1;
			}
			num = (num << 4) + @int;
		}
		return num;
	}

	private static char[] getChars(MemoryStream buffer, Encoding encoding)
	{
		return encoding.GetChars(buffer.GetBuffer(), 0, (int)buffer.Length);
	}

	private static Dictionary<string, char> getEntities()
	{
		lock (_sync)
		{
			if (_entities == null)
			{
				initEntities();
			}
			return _entities;
		}
	}

	private static int getInt(byte b)
	{
		char c = (char)b;
		return (c >= '0' && c <= '9') ? (c - 48) : ((c >= 'a' && c <= 'f') ? (c - 97 + 10) : ((c >= 'A' && c <= 'F') ? (c - 65 + 10) : (-1)));
	}

	private static void initEntities()
	{
		_entities = new Dictionary<string, char>();
		_entities.Add("nbsp", '\u00a0');
		_entities.Add("iexcl", '');
		_entities.Add("cent", '');
		_entities.Add("pound", '');
		_entities.Add("curren", '');
		_entities.Add("yen", '');
		_entities.Add("brvbar", '');
		_entities.Add("sect", '');
		_entities.Add("uml", '\u00a8');
		_entities.Add("copy", '');
		_entities.Add("ordf", '');
		_entities.Add("laquo", '');
		_entities.Add("not", '');
		_entities.Add("shy", '\u00ad');
		_entities.Add("reg", '');
		_entities.Add("macr", '\u00af');
		_entities.Add("deg", '');
		_entities.Add("plusmn", '');
		_entities.Add("sup2", '');
		_entities.Add("sup3", '');
		_entities.Add("acute", '\u00b4');
		_entities.Add("micro", '');
		_entities.Add("para", '');
		_entities.Add("middot", '');
		_entities.Add("cedil", '\u00b8');
		_entities.Add("sup1", '');
		_entities.Add("ordm", '');
		_entities.Add("raquo", '');
		_entities.Add("frac14", '');
		_entities.Add("frac12", '');
		_entities.Add("frac34", '');
		_entities.Add("iquest", '');
		_entities.Add("Agrave", '');
		_entities.Add("Aacute", '');
		_entities.Add("Acirc", '');
		_entities.Add("Atilde", '');
		_entities.Add("Auml", '');
		_entities.Add("Aring", '');
		_entities.Add("AElig", '');
		_entities.Add("Ccedil", '');
		_entities.Add("Egrave", '');
		_entities.Add("Eacute", '');
		_entities.Add("Ecirc", '');
		_entities.Add("Euml", '');
		_entities.Add("Igrave", '');
		_entities.Add("Iacute", '');
		_entities.Add("Icirc", '');
		_entities.Add("Iuml", '');
		_entities.Add("ETH", '');
		_entities.Add("Ntilde", '');
		_entities.Add("Ograve", '');
		_entities.Add("Oacute", '');
		_entities.Add("Ocirc", '');
		_entities.Add("Otilde", '');
		_entities.Add("Ouml", '');
		_entities.Add("times", '');
		_entities.Add("Oslash", '');
		_entities.Add("Ugrave", '');
		_entities.Add("Uacute", '');
		_entities.Add("Ucirc", '');
		_entities.Add("Uuml", '');
		_entities.Add("Yacute", '');
		_entities.Add("THORN", '');
		_entities.Add("szlig", '');
		_entities.Add("agrave", '');
		_entities.Add("aacute", '');
		_entities.Add("acirc", '');
		_entities.Add("atilde", '');
		_entities.Add("auml", '');
		_entities.Add("aring", '');
		_entities.Add("aelig", '');
		_entities.Add("ccedil", '');
		_entities.Add("egrave", '');
		_entities.Add("eacute", '');
		_entities.Add("ecirc", '');
		_entities.Add("euml", '');
		_entities.Add("igrave", '');
		_entities.Add("iacute", '');
		_entities.Add("icirc", '');
		_entities.Add("iuml", '');
		_entities.Add("eth", '');
		_entities.Add("ntilde", '');
		_entities.Add("ograve", '');
		_entities.Add("oacute", '');
		_entities.Add("ocirc", '');
		_entities.Add("otilde", '');
		_entities.Add("ouml", '');
		_entities.Add("divide", '');
		_entities.Add("oslash", '');
		_entities.Add("ugrave", '');
		_entities.Add("uacute", '');
		_entities.Add("ucirc", '');
		_entities.Add("uuml", '');
		_entities.Add("yacute", '');
		_entities.Add("thorn", '');
		_entities.Add("yuml", '');
		_entities.Add("fnof", '');
		_entities.Add("Alpha", '');
		_entities.Add("Beta", '');
		_entities.Add("Gamma", '');
		_entities.Add("Delta", '');
		_entities.Add("Epsilon", '');
		_entities.Add("Zeta", '');
		_entities.Add("Eta", '');
		_entities.Add("Theta", '');
		_entities.Add("Iota", '');
		_entities.Add("Kappa", '');
		_entities.Add("Lambda", '');
		_entities.Add("Mu", '');
		_entities.Add("Nu", '');
		_entities.Add("Xi", '');
		_entities.Add("Omicron", '');
		_entities.Add("Pi", '');
		_entities.Add("Rho", '');
		_entities.Add("Sigma", '');
		_entities.Add("Tau", '');
		_entities.Add("Upsilon", '');
		_entities.Add("Phi", '');
		_entities.Add("Chi", '');
		_entities.Add("Psi", '');
		_entities.Add("Omega", '');
		_entities.Add("alpha", '');
		_entities.Add("beta", '');
		_entities.Add("gamma", '');
		_entities.Add("delta", '');
		_entities.Add("epsilon", '');
		_entities.Add("zeta", '');
		_entities.Add("eta", '');
		_entities.Add("theta", '');
		_entities.Add("iota", '');
		_entities.Add("kappa", '');
		_entities.Add("lambda", '');
		_entities.Add("mu", '');
		_entities.Add("nu", '');
		_entities.Add("xi", '');
		_entities.Add("omicron", '');
		_entities.Add("pi", '');
		_entities.Add("rho", '');
		_entities.Add("sigmaf", '');
		_entities.Add("sigma", '');
		_entities.Add("tau", '');
		_entities.Add("upsilon", '');
		_entities.Add("phi", '');
		_entities.Add("chi", '');
		_entities.Add("psi", '');
		_entities.Add("omega", '');
		_entities.Add("thetasym", '');
		_entities.Add("upsih", '');
		_entities.Add("piv", '');
		_entities.Add("bull", '');
		_entities.Add("hellip", '');
		_entities.Add("prime", '');
		_entities.Add("Prime", '');
		_entities.Add("oline", '');
		_entities.Add("frasl", '');
		_entities.Add("weierp", '');
		_entities.Add("image", '');
		_entities.Add("real", '');
		_entities.Add("trade", '');
		_entities.Add("alefsym", '');
		_entities.Add("larr", '');
		_entities.Add("uarr", '');
		_entities.Add("rarr", '');
		_entities.Add("darr", '');
		_entities.Add("harr", '');
		_entities.Add("crarr", '');
		_entities.Add("lArr", '');
		_entities.Add("uArr", '');
		_entities.Add("rArr", '');
		_entities.Add("dArr", '');
		_entities.Add("hArr", '');
		_entities.Add("forall", '');
		_entities.Add("part", '');
		_entities.Add("exist", '');
		_entities.Add("empty", '');
		_entities.Add("nabla", '');
		_entities.Add("isin", '');
		_entities.Add("notin", '');
		_entities.Add("ni", '');
		_entities.Add("prod", '');
		_entities.Add("sum", '');
		_entities.Add("minus", '');
		_entities.Add("lowast", '');
		_entities.Add("radic", '');
		_entities.Add("prop", '');
		_entities.Add("infin", '');
		_entities.Add("ang", '');
		_entities.Add("and", '');
		_entities.Add("or", '');
		_entities.Add("cap", '');
		_entities.Add("cup", '');
		_entities.Add("int", '');
		_entities.Add("there4", '');
		_entities.Add("sim", '');
		_entities.Add("cong", '');
		_entities.Add("asymp", '');
		_entities.Add("ne", '');
		_entities.Add("equiv", '');
		_entities.Add("le", '');
		_entities.Add("ge", '');
		_entities.Add("sub", '');
		_entities.Add("sup", '');
		_entities.Add("nsub", '');
		_entities.Add("sube", '');
		_entities.Add("supe", '');
		_entities.Add("oplus", '');
		_entities.Add("otimes", '');
		_entities.Add("perp", '');
		_entities.Add("sdot", '');
		_entities.Add("lceil", '');
		_entities.Add("rceil", '');
		_entities.Add("lfloor", '');
		_entities.Add("rfloor", '');
		_entities.Add("lang", '');
		_entities.Add("rang", '');
		_entities.Add("loz", '');
		_entities.Add("spades", '');
		_entities.Add("clubs", '');
		_entities.Add("hearts", '');
		_entities.Add("diams", '');
		_entities.Add("quot", '"');
		_entities.Add("amp", '&');
		_entities.Add("lt", '<');
		_entities.Add("gt", '>');
		_entities.Add("OElig", '');
		_entities.Add("oelig", '');
		_entities.Add("Scaron", '');
		_entities.Add("scaron", '');
		_entities.Add("Yuml", '');
		_entities.Add("circ", '');
		_entities.Add("tilde", '\u02dc');
		_entities.Add("ensp", '\u2002');
		_entities.Add("emsp", '\u2003');
		_entities.Add("thinsp", '\u2009');
		_entities.Add("zwnj", '\u200c');
		_entities.Add("zwj", '\u200d');
		_entities.Add("lrm", '\u200e');
		_entities.Add("rlm", '\u200f');
		_entities.Add("ndash", '');
		_entities.Add("mdash", '');
		_entities.Add("lsquo", '');
		_entities.Add("rsquo", '');
		_entities.Add("sbquo", '');
		_entities.Add("ldquo", '');
		_entities.Add("rdquo", '');
		_entities.Add("bdquo", '');
		_entities.Add("dagger", '');
		_entities.Add("Dagger", '');
		_entities.Add("permil", '');
		_entities.Add("lsaquo", '');
		_entities.Add("rsaquo", '');
		_entities.Add("euro", '');
	}

	private static bool notEncoded(char c)
	{
		return c == '!' || c == '\'' || c == '(' || c == ')' || c == '*' || c == '-' || c == '.' || c == '_';
	}

	private static void urlEncode(char c, Stream result, bool unicode)
	{
		if (c > '')
		{
			result.WriteByte(37);
			result.WriteByte(117);
			int num = (int)c >> 12;
			result.WriteByte((byte)_hexChars[num]);
			num = ((int)c >> 8) & 0xF;
			result.WriteByte((byte)_hexChars[num]);
			num = ((int)c >> 4) & 0xF;
			result.WriteByte((byte)_hexChars[num]);
			num = c & 0xF;
			result.WriteByte((byte)_hexChars[num]);
		}
		else if (c > ' ' && notEncoded(c))
		{
			result.WriteByte((byte)c);
		}
		else if (c == ' ')
		{
			result.WriteByte(43);
		}
		else if (c < '0' || (c < 'A' && c > '9') || (c > 'Z' && c < 'a') || c > 'z')
		{
			if (unicode && c > '\u007f')
			{
				result.WriteByte(37);
				result.WriteByte(117);
				result.WriteByte(48);
				result.WriteByte(48);
			}
			else
			{
				result.WriteByte(37);
			}
			int num2 = (int)c >> 4;
			result.WriteByte((byte)_hexChars[num2]);
			num2 = c & 0xF;
			result.WriteByte((byte)_hexChars[num2]);
		}
		else
		{
			result.WriteByte((byte)c);
		}
	}

	private static void urlPathEncode(char c, Stream result)
	{
		if (c < '!' || c > '~')
		{
			byte[] bytes = Encoding.UTF8.GetBytes(c.ToString());
			byte[] array = bytes;
			foreach (byte b in array)
			{
				result.WriteByte(37);
				int num = b;
				int num2 = num >> 4;
				result.WriteByte((byte)_hexChars[num2]);
				num2 = num & 0xF;
				result.WriteByte((byte)_hexChars[num2]);
			}
		}
		else if (c == ' ')
		{
			result.WriteByte(37);
			result.WriteByte(50);
			result.WriteByte(48);
		}
		else
		{
			result.WriteByte((byte)c);
		}
	}

	private static void writeCharBytes(char c, IList buffer, Encoding encoding)
	{
		if (c > '')
		{
			byte[] bytes = encoding.GetBytes(new char[1] { c });
			foreach (byte b in bytes)
			{
				buffer.Add(b);
			}
		}
		else
		{
			buffer.Add((byte)c);
		}
	}

	internal static Uri CreateRequestUrl(string requestUri, string host, bool websocketRequest, bool secure)
	{
		if (requestUri == null || requestUri.Length == 0 || host == null || host.Length == 0)
		{
			return null;
		}
		string text = null;
		string arg = null;
		if (requestUri.StartsWith("/"))
		{
			arg = requestUri;
		}
		else if (requestUri.MaybeUri())
		{
			if (!Uri.TryCreate(requestUri, UriKind.Absolute, out Uri result) || ((!(text = result.Scheme).StartsWith("http") || websocketRequest) && !(text.StartsWith("ws") && websocketRequest)))
			{
				return null;
			}
			host = result.Authority;
			arg = result.PathAndQuery;
		}
		else if (!(requestUri == "*"))
		{
			host = requestUri;
		}
		if (text == null)
		{
			text = (websocketRequest ? "ws" : "http") + (secure ? "s" : string.Empty);
		}
		int num = host.IndexOf(':');
		if (num == -1)
		{
			host = string.Format("{0}:{1}", host, (text == "http" || text == "ws") ? 80 : 443);
		}
		string uriString = $"{text}://{host}{arg}";
		if (!Uri.TryCreate(uriString, UriKind.Absolute, out Uri result2))
		{
			return null;
		}
		return result2;
	}

	internal static IPrincipal CreateUser(string response, AuthenticationSchemes scheme, string realm, string method, Func<IIdentity, NetworkCredential> credentialsFinder)
	{
		if (response == null || response.Length == 0)
		{
			return null;
		}
		if (credentialsFinder == null)
		{
			return null;
		}
		if (scheme != AuthenticationSchemes.Basic && scheme != AuthenticationSchemes.Digest)
		{
			return null;
		}
		if (scheme == AuthenticationSchemes.Digest)
		{
			if (realm == null || realm.Length == 0)
			{
				return null;
			}
			if (method == null || method.Length == 0)
			{
				return null;
			}
		}
		if (!response.StartsWith(scheme.ToString(), StringComparison.OrdinalIgnoreCase))
		{
			return null;
		}
		AuthenticationResponse authenticationResponse = AuthenticationResponse.Parse(response);
		if (authenticationResponse == null)
		{
			return null;
		}
		IIdentity identity = authenticationResponse.ToIdentity();
		if (identity == null)
		{
			return null;
		}
		NetworkCredential networkCredential = null;
		try
		{
			networkCredential = credentialsFinder(identity);
		}
		catch
		{
		}
		if (networkCredential == null)
		{
			return null;
		}
		if (scheme == AuthenticationSchemes.Basic && ((HttpBasicIdentity)identity).Password != networkCredential.Password)
		{
			return null;
		}
		if (scheme == AuthenticationSchemes.Digest && !((HttpDigestIdentity)identity).IsValid(networkCredential.Password, realm, method, null))
		{
			return null;
		}
		return new GenericPrincipal(identity, networkCredential.Roles);
	}

	internal static Encoding GetEncoding(string contentType)
	{
		string[] array = contentType.Split(new char[1] { ';' });
		string[] array2 = array;
		foreach (string text in array2)
		{
			string text2 = text.Trim();
			if (text2.StartsWith("charset", StringComparison.OrdinalIgnoreCase))
			{
				return Encoding.GetEncoding(text2.GetValue('=', unquote: true));
			}
		}
		return null;
	}

	internal static NameValueCollection InternalParseQueryString(string query, Encoding encoding)
	{
		int length;
		if (query == null || (length = query.Length) == 0 || (length == 1 && query[0] == '?'))
		{
			return new NameValueCollection(1);
		}
		if (query[0] == '?')
		{
			query = query.Substring(1);
		}
		QueryStringCollection queryStringCollection = new QueryStringCollection();
		string[] array = query.Split(new char[1] { '&' });
		string[] array2 = array;
		foreach (string text in array2)
		{
			int num = text.IndexOf('=');
			if (num > -1)
			{
				string name = UrlDecode(text.Substring(0, num), encoding);
				string value = ((text.Length > num + 1) ? UrlDecode(text.Substring(num + 1), encoding) : string.Empty);
				queryStringCollection.Add(name, value);
			}
			else
			{
				queryStringCollection.Add(null, UrlDecode(text, encoding));
			}
		}
		return queryStringCollection;
	}

	internal static string InternalUrlDecode(byte[] bytes, int offset, int count, Encoding encoding)
	{
		StringBuilder stringBuilder = new StringBuilder();
		using (MemoryStream memoryStream = new MemoryStream())
		{
			int num = count + offset;
			for (int i = offset; i < num; i++)
			{
				if (bytes[i] == 37 && i + 2 < count && bytes[i + 1] != 37)
				{
					int @char;
					if (bytes[i + 1] == 117 && i + 5 < num)
					{
						if (memoryStream.Length > 0)
						{
							stringBuilder.Append(getChars(memoryStream, encoding));
							memoryStream.SetLength(0L);
						}
						@char = getChar(bytes, i + 2, 4);
						if (@char != -1)
						{
							stringBuilder.Append((char)@char);
							i += 5;
							continue;
						}
					}
					else if ((@char = getChar(bytes, i + 1, 2)) != -1)
					{
						memoryStream.WriteByte((byte)@char);
						i += 2;
						continue;
					}
				}
				if (memoryStream.Length > 0)
				{
					stringBuilder.Append(getChars(memoryStream, encoding));
					memoryStream.SetLength(0L);
				}
				if (bytes[i] == 43)
				{
					stringBuilder.Append(' ');
				}
				else
				{
					stringBuilder.Append((char)bytes[i]);
				}
			}
			if (memoryStream.Length > 0)
			{
				stringBuilder.Append(getChars(memoryStream, encoding));
			}
		}
		return stringBuilder.ToString();
	}

	internal static byte[] InternalUrlDecodeToBytes(byte[] bytes, int offset, int count)
	{
		using MemoryStream memoryStream = new MemoryStream();
		int num = offset + count;
		for (int i = offset; i < num; i++)
		{
			char c = (char)bytes[i];
			switch (c)
			{
			case '+':
				c = ' ';
				break;
			case '%':
				if (i < num - 2)
				{
					int @char = getChar(bytes, i + 1, 2);
					if (@char != -1)
					{
						c = (char)@char;
						i += 2;
					}
				}
				break;
			}
			memoryStream.WriteByte((byte)c);
		}
		memoryStream.Close();
		return memoryStream.ToArray();
	}

	internal static byte[] InternalUrlEncodeToBytes(byte[] bytes, int offset, int count)
	{
		using MemoryStream memoryStream = new MemoryStream();
		int num = offset + count;
		for (int i = offset; i < num; i++)
		{
			urlEncode((char)bytes[i], memoryStream, unicode: false);
		}
		memoryStream.Close();
		return memoryStream.ToArray();
	}

	internal static byte[] InternalUrlEncodeUnicodeToBytes(string s)
	{
		using MemoryStream memoryStream = new MemoryStream();
		foreach (char c in s)
		{
			urlEncode(c, memoryStream, unicode: true);
		}
		memoryStream.Close();
		return memoryStream.ToArray();
	}

	public static string HtmlAttributeEncode(string s)
	{
		if (s == null || s.Length == 0 || !s.Contains('&', '"', '<', '>'))
		{
			return s;
		}
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < s.Length; i++)
		{
			char c = s[i];
			stringBuilder.Append(c switch
			{
				'>' => "&gt;", 
				'<' => "&lt;", 
				'"' => "&quot;", 
				'&' => "&amp;", 
				_ => c.ToString(), 
			});
		}
		return stringBuilder.ToString();
	}

	public static void HtmlAttributeEncode(string s, TextWriter output)
	{
		if (output == null)
		{
			throw new ArgumentNullException("output");
		}
		output.Write(HtmlAttributeEncode(s));
	}

	public static string HtmlDecode(string s)
	{
		if (s == null || s.Length == 0 || !Ext.Contains(s, '&'))
		{
			return s;
		}
		StringBuilder stringBuilder = new StringBuilder();
		StringBuilder stringBuilder2 = new StringBuilder();
		int num = 0;
		int num2 = 0;
		bool flag = false;
		foreach (char c in s)
		{
			if (num == 0)
			{
				if (c == '&')
				{
					stringBuilder.Append(c);
					num = 1;
				}
				else
				{
					stringBuilder2.Append(c);
				}
				continue;
			}
			if (c == '&')
			{
				num = 1;
				if (flag)
				{
					stringBuilder.Append(num2.ToString(CultureInfo.InvariantCulture));
					flag = false;
				}
				stringBuilder2.Append(stringBuilder.ToString());
				stringBuilder.Length = 0;
				stringBuilder.Append('&');
				continue;
			}
			switch (num)
			{
			case 1:
				if (c == ';')
				{
					num = 0;
					stringBuilder2.Append(stringBuilder.ToString());
					stringBuilder2.Append(c);
					stringBuilder.Length = 0;
				}
				else
				{
					num2 = 0;
					num = ((c == '#') ? 3 : 2);
					stringBuilder.Append(c);
				}
				break;
			case 2:
				stringBuilder.Append(c);
				if (c == ';')
				{
					string text = stringBuilder.ToString();
					Dictionary<string, char> entities = getEntities();
					if (text.Length > 1 && entities.ContainsKey(text.Substring(1, text.Length - 2)))
					{
						text = entities[text.Substring(1, text.Length - 2)].ToString();
					}
					stringBuilder2.Append(text);
					num = 0;
					stringBuilder.Length = 0;
				}
				break;
			case 3:
				if (c == ';')
				{
					if (num2 > 65535)
					{
						stringBuilder2.Append("&#");
						stringBuilder2.Append(num2.ToString(CultureInfo.InvariantCulture));
						stringBuilder2.Append(";");
					}
					else
					{
						stringBuilder2.Append((char)num2);
					}
					num = 0;
					stringBuilder.Length = 0;
					flag = false;
				}
				else if (char.IsDigit(c))
				{
					num2 = num2 * 10 + (c - 48);
					flag = true;
				}
				else
				{
					num = 2;
					if (flag)
					{
						stringBuilder.Append(num2.ToString(CultureInfo.InvariantCulture));
						flag = false;
					}
					stringBuilder.Append(c);
				}
				break;
			}
		}
		if (stringBuilder.Length > 0)
		{
			stringBuilder2.Append(stringBuilder.ToString());
		}
		else if (flag)
		{
			stringBuilder2.Append(num2.ToString(CultureInfo.InvariantCulture));
		}
		return stringBuilder2.ToString();
	}

	public static void HtmlDecode(string s, TextWriter output)
	{
		if (output == null)
		{
			throw new ArgumentNullException("output");
		}
		output.Write(HtmlDecode(s));
	}

	public static string HtmlEncode(string s)
	{
		if (s == null || s.Length == 0)
		{
			return s;
		}
		bool flag = false;
		foreach (char c in s)
		{
			if (c == '&' || c == '"' || c == '<' || c == '>' || c > '\u009f')
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			return s;
		}
		StringBuilder stringBuilder = new StringBuilder();
		foreach (char c2 in s)
		{
			if (c2 == '&')
			{
				stringBuilder.Append("&amp;");
			}
			else if (c2 == '"')
			{
				stringBuilder.Append("&quot;");
			}
			else if (c2 == '<')
			{
				stringBuilder.Append("&lt;");
			}
			else if (c2 == '>')
			{
				stringBuilder.Append("&gt;");
			}
			else if (c2 > '\u009f')
			{
				stringBuilder.Append("&#");
				int num = c2;
				stringBuilder.Append(num.ToString(CultureInfo.InvariantCulture));
				stringBuilder.Append(";");
			}
			else
			{
				stringBuilder.Append(c2);
			}
		}
		return stringBuilder.ToString();
	}

	public static void HtmlEncode(string s, TextWriter output)
	{
		if (output == null)
		{
			throw new ArgumentNullException("output");
		}
		output.Write(HtmlEncode(s));
	}

	public static NameValueCollection ParseQueryString(string query)
	{
		return ParseQueryString(query, Encoding.UTF8);
	}

	public static NameValueCollection ParseQueryString(string query, Encoding encoding)
	{
		if (query == null)
		{
			throw new ArgumentNullException("query");
		}
		return InternalParseQueryString(query, encoding ?? Encoding.UTF8);
	}

	public static string UrlDecode(string s)
	{
		return UrlDecode(s, Encoding.UTF8);
	}

	public static string UrlDecode(string s, Encoding encoding)
	{
		if (s == null || s.Length == 0 || !s.Contains('%', '+'))
		{
			return s;
		}
		if (encoding == null)
		{
			encoding = Encoding.UTF8;
		}
		List<byte> list = new List<byte>();
		int length = s.Length;
		for (int i = 0; i < length; i++)
		{
			char c = s[i];
			if (c == '%' && i + 2 < length && s[i + 1] != '%')
			{
				int @char;
				if (s[i + 1] == 'u' && i + 5 < length)
				{
					@char = getChar(s, i + 2, 4);
					if (@char != -1)
					{
						writeCharBytes((char)@char, list, encoding);
						i += 5;
					}
					else
					{
						writeCharBytes('%', list, encoding);
					}
				}
				else if ((@char = getChar(s, i + 1, 2)) != -1)
				{
					writeCharBytes((char)@char, list, encoding);
					i += 2;
				}
				else
				{
					writeCharBytes('%', list, encoding);
				}
			}
			else if (c == '+')
			{
				writeCharBytes(' ', list, encoding);
			}
			else
			{
				writeCharBytes(c, list, encoding);
			}
		}
		return encoding.GetString(list.ToArray());
	}

	public static string UrlDecode(byte[] bytes, Encoding encoding)
	{
		int count;
		return (bytes == null) ? null : (((count = bytes.Length) == 0) ? string.Empty : InternalUrlDecode(bytes, 0, count, encoding ?? Encoding.UTF8));
	}

	public static string UrlDecode(byte[] bytes, int offset, int count, Encoding encoding)
	{
		if (bytes == null)
		{
			return null;
		}
		int num = bytes.Length;
		if (num == 0 || count == 0)
		{
			return string.Empty;
		}
		if (offset < 0 || offset >= num)
		{
			throw new ArgumentOutOfRangeException("offset");
		}
		if (count < 0 || count > num - offset)
		{
			throw new ArgumentOutOfRangeException("count");
		}
		return InternalUrlDecode(bytes, offset, count, encoding ?? Encoding.UTF8);
	}

	public static byte[] UrlDecodeToBytes(byte[] bytes)
	{
		int count;
		return (bytes != null && (count = bytes.Length) > 0) ? InternalUrlDecodeToBytes(bytes, 0, count) : bytes;
	}

	public static byte[] UrlDecodeToBytes(string s)
	{
		return UrlDecodeToBytes(s, Encoding.UTF8);
	}

	public static byte[] UrlDecodeToBytes(string s, Encoding encoding)
	{
		if (s == null)
		{
			return null;
		}
		if (s.Length == 0)
		{
			return new byte[0];
		}
		byte[] bytes = (encoding ?? Encoding.UTF8).GetBytes(s);
		return InternalUrlDecodeToBytes(bytes, 0, bytes.Length);
	}

	public static byte[] UrlDecodeToBytes(byte[] bytes, int offset, int count)
	{
		int num;
		if (bytes == null || (num = bytes.Length) == 0)
		{
			return bytes;
		}
		if (count == 0)
		{
			return new byte[0];
		}
		if (offset < 0 || offset >= num)
		{
			throw new ArgumentOutOfRangeException("offset");
		}
		if (count < 0 || count > num - offset)
		{
			throw new ArgumentOutOfRangeException("count");
		}
		return InternalUrlDecodeToBytes(bytes, offset, count);
	}

	public static string UrlEncode(byte[] bytes)
	{
		int count;
		return (bytes == null) ? null : (((count = bytes.Length) == 0) ? string.Empty : Encoding.ASCII.GetString(InternalUrlEncodeToBytes(bytes, 0, count)));
	}

	public static string UrlEncode(string s)
	{
		return UrlEncode(s, Encoding.UTF8);
	}

	public static string UrlEncode(string s, Encoding encoding)
	{
		int length;
		if (s == null || (length = s.Length) == 0)
		{
			return s;
		}
		bool flag = false;
		foreach (char c in s)
		{
			if ((c < '0' || (c < 'A' && c > '9') || (c > 'Z' && c < 'a') || c > 'z') && !notEncoded(c))
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			return s;
		}
		if (encoding == null)
		{
			encoding = Encoding.UTF8;
		}
		byte[] bytes = new byte[encoding.GetMaxByteCount(length)];
		int bytes2 = encoding.GetBytes(s, 0, length, bytes, 0);
		return Encoding.ASCII.GetString(InternalUrlEncodeToBytes(bytes, 0, bytes2));
	}

	public static string UrlEncode(byte[] bytes, int offset, int count)
	{
		byte[] array = UrlEncodeToBytes(bytes, offset, count);
		return (array == null) ? null : ((array.Length == 0) ? string.Empty : Encoding.ASCII.GetString(array));
	}

	public static byte[] UrlEncodeToBytes(byte[] bytes)
	{
		int count;
		return (bytes != null && (count = bytes.Length) > 0) ? InternalUrlEncodeToBytes(bytes, 0, count) : bytes;
	}

	public static byte[] UrlEncodeToBytes(string s)
	{
		return UrlEncodeToBytes(s, Encoding.UTF8);
	}

	public static byte[] UrlEncodeToBytes(string s, Encoding encoding)
	{
		if (s == null)
		{
			return null;
		}
		if (s.Length == 0)
		{
			return new byte[0];
		}
		byte[] bytes = (encoding ?? Encoding.UTF8).GetBytes(s);
		return InternalUrlEncodeToBytes(bytes, 0, bytes.Length);
	}

	public static byte[] UrlEncodeToBytes(byte[] bytes, int offset, int count)
	{
		int num;
		if (bytes == null || (num = bytes.Length) == 0)
		{
			return bytes;
		}
		if (count == 0)
		{
			return new byte[0];
		}
		if (offset < 0 || offset >= num)
		{
			throw new ArgumentOutOfRangeException("offset");
		}
		if (count < 0 || count > num - offset)
		{
			throw new ArgumentOutOfRangeException("count");
		}
		return InternalUrlEncodeToBytes(bytes, offset, count);
	}

	public static string UrlEncodeUnicode(string s)
	{
		return (s != null && s.Length > 0) ? Encoding.ASCII.GetString(InternalUrlEncodeUnicodeToBytes(s)) : s;
	}

	public static byte[] UrlEncodeUnicodeToBytes(string s)
	{
		return (s == null) ? null : ((s.Length == 0) ? new byte[0] : InternalUrlEncodeUnicodeToBytes(s));
	}

	public static string UrlPathEncode(string s)
	{
		if (s == null || s.Length == 0)
		{
			return s;
		}
		using MemoryStream memoryStream = new MemoryStream();
		foreach (char c in s)
		{
			urlPathEncode(c, memoryStream);
		}
		memoryStream.Close();
		return Encoding.ASCII.GetString(memoryStream.ToArray());
	}
}


using System;
using System.IO;
using WebSocketSharp.Net;

internal class RequestStream : Stream
{
	private long _bodyLeft;

	private byte[] _buffer;

	private int _count;

	private bool _disposed;

	private int _offset;

	private Stream _stream;

	public override bool CanRead => true;

	public override bool CanSeek => false;

	public override bool CanWrite => false;

	public override long Length
	{
		get
		{
			throw new NotSupportedException();
		}
	}

	public override long Position
	{
		get
		{
			throw new NotSupportedException();
		}
		set
		{
			throw new NotSupportedException();
		}
	}

	internal RequestStream(Stream stream, byte[] buffer, int offset, int count)
		: this(stream, buffer, offset, count, -1L)
	{
	}

	internal RequestStream(Stream stream, byte[] buffer, int offset, int count, long contentLength)
	{
		_stream = stream;
		_buffer = buffer;
		_offset = offset;
		_count = count;
		_bodyLeft = contentLength;
	}

	private int fillFromBuffer(byte[] buffer, int offset, int count)
	{
		if (buffer == null)
		{
			throw new ArgumentNullException("buffer");
		}
		if (offset < 0)
		{
			throw new ArgumentOutOfRangeException("offset", "A negative value.");
		}
		if (count < 0)
		{
			throw new ArgumentOutOfRangeException("count", "A negative value.");
		}
		int num = buffer.Length;
		if (offset + count > num)
		{
			throw new ArgumentException("The sum of 'offset' and 'count' is greater than 'buffer' length.");
		}
		if (_bodyLeft == 0)
		{
			return -1;
		}
		if (_count == 0 || count == 0)
		{
			return 0;
		}
		if (count > _count)
		{
			count = _count;
		}
		if (_bodyLeft > 0 && count > _bodyLeft)
		{
			count = (int)_bodyLeft;
		}
		Buffer.BlockCopy(_buffer, _offset, buffer, offset, count);
		_offset += count;
		_count -= count;
		if (_bodyLeft > 0)
		{
			_bodyLeft -= count;
		}
		return count;
	}

	public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
	{
		if (_disposed)
		{
			throw new ObjectDisposedException(GetType().ToString());
		}
		int num = fillFromBuffer(buffer, offset, count);
		if (num > 0 || num == -1)
		{
			HttpStreamAsyncResult httpStreamAsyncResult = new HttpStreamAsyncResult(callback, state);
			httpStreamAsyncResult.Buffer = buffer;
			httpStreamAsyncResult.Offset = offset;
			httpStreamAsyncResult.Count = count;
			httpStreamAsyncResult.SyncRead = ((num > 0) ? num : 0);
			httpStreamAsyncResult.Complete();
			return httpStreamAsyncResult;
		}
		if (_bodyLeft >= 0 && count > _bodyLeft)
		{
			count = (int)_bodyLeft;
		}
		return _stream.BeginRead(buffer, offset, count, callback, state);
	}

	public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
	{
		throw new NotSupportedException();
	}

	public override void Close()
	{
		_disposed = true;
	}

	public override int EndRead(IAsyncResult asyncResult)
	{
		if (_disposed)
		{
			throw new ObjectDisposedException(GetType().ToString());
		}
		if (asyncResult == null)
		{
			throw new ArgumentNullException("asyncResult");
		}
		if (asyncResult is HttpStreamAsyncResult)
		{
			HttpStreamAsyncResult httpStreamAsyncResult = (HttpStreamAsyncResult)asyncResult;
			if (!httpStreamAsyncResult.IsCompleted)
			{
				httpStreamAsyncResult.AsyncWaitHandle.WaitOne();
			}
			return httpStreamAsyncResult.SyncRead;
		}
		int num = _stream.EndRead(asyncResult);
		if (num > 0 && _bodyLeft > 0)
		{
			_bodyLeft -= num;
		}
		return num;
	}

	public override void EndWrite(IAsyncResult asyncResult)
	{
		throw new NotSupportedException();
	}

	public override void Flush()
	{
	}

	public override int Read(byte[] buffer, int offset, int count)
	{
		if (_disposed)
		{
			throw new ObjectDisposedException(GetType().ToString());
		}
		int num = fillFromBuffer(buffer, offset, count);
		if (num == -1)
		{
			return 0;
		}
		if (num > 0)
		{
			return num;
		}
		num = _stream.Read(buffer, offset, count);
		if (num > 0 && _bodyLeft > 0)
		{
			_bodyLeft -= num;
		}
		return num;
	}

	public override long Seek(long offset, SeekOrigin origin)
	{
		throw new NotSupportedException();
	}

	public override void SetLength(long value)
	{
		throw new NotSupportedException();
	}

	public override void Write(byte[] buffer, int offset, int count)
	{
		throw new NotSupportedException();
	}
}


using System;
using System.IO;
using System.Text;
using WebSocketSharp.Net;

internal class ResponseStream : Stream
{
	private MemoryStream _body;

	private static readonly byte[] _crlf = new byte[2] { 13, 10 };

	private bool _disposed;

	private HttpListenerResponse _response;

	private bool _sendChunked;

	private Stream _stream;

	private Action<byte[], int, int> _write;

	private Action<byte[], int, int> _writeBody;

	private Action<byte[], int, int> _writeChunked;

	public override bool CanRead => false;

	public override bool CanSeek => false;

	public override bool CanWrite => !_disposed;

	public override long Length
	{
		get
		{
			throw new NotSupportedException();
		}
	}

	public override long Position
	{
		get
		{
			throw new NotSupportedException();
		}
		set
		{
			throw new NotSupportedException();
		}
	}

	internal ResponseStream(Stream stream, HttpListenerResponse response, bool ignoreWriteExceptions)
	{
		_stream = stream;
		_response = response;
		if (ignoreWriteExceptions)
		{
			_write = writeWithoutThrowingException;
			_writeChunked = writeChunkedWithoutThrowingException;
		}
		else
		{
			_write = stream.Write;
			_writeChunked = writeChunked;
		}
		_body = new MemoryStream();
	}

	private bool flush(bool closing)
	{
		if (!_response.HeadersSent)
		{
			if (!flushHeaders(closing))
			{
				if (closing)
				{
					_response.CloseConnection = true;
				}
				return false;
			}
			_sendChunked = _response.SendChunked;
			_writeBody = (_sendChunked ? _writeChunked : _write);
		}
		flushBody(closing);
		if (closing && _sendChunked)
		{
			byte[] chunkSizeBytes = getChunkSizeBytes(0, final: true);
			_write(chunkSizeBytes, 0, chunkSizeBytes.Length);
		}
		return true;
	}

	private void flushBody(bool closing)
	{
		using (_body)
		{
			long length = _body.Length;
			if (length > int.MaxValue)
			{
				_body.Position = 0L;
				int num = 1024;
				byte[] array = new byte[num];
				int num2 = 0;
				while ((num2 = _body.Read(array, 0, num)) > 0)
				{
					_writeBody(array, 0, num2);
				}
			}
			else if (length > 0)
			{
				_writeBody(_body.GetBuffer(), 0, (int)length);
			}
		}
		_body = ((!closing) ? new MemoryStream() : null);
	}

	private bool flushHeaders(bool closing)
	{
		using (MemoryStream memoryStream = new MemoryStream())
		{
			WebHeaderCollection webHeaderCollection = _response.WriteHeadersTo(memoryStream);
			long position = memoryStream.Position;
			long num = memoryStream.Length - position;
			if (num > 32768)
			{
				return false;
			}
			if (!_response.SendChunked && _response.ContentLength64 != _body.Length)
			{
				return false;
			}
			_write(memoryStream.GetBuffer(), (int)position, (int)num);
			_response.CloseConnection = webHeaderCollection["Connection"] == "close";
			_response.HeadersSent = true;
		}
		return true;
	}

	private static byte[] getChunkSizeBytes(int size, bool final)
	{
		return Encoding.ASCII.GetBytes(string.Format("{0:x}\r\n{1}", size, final ? "\r\n" : ""));
	}

	private void writeChunked(byte[] buffer, int offset, int count)
	{
		byte[] chunkSizeBytes = getChunkSizeBytes(count, final: false);
		_stream.Write(chunkSizeBytes, 0, chunkSizeBytes.Length);
		_stream.Write(buffer, offset, count);
		_stream.Write(_crlf, 0, 2);
	}

	private void writeChunkedWithoutThrowingException(byte[] buffer, int offset, int count)
	{
		try
		{
			writeChunked(buffer, offset, count);
		}
		catch
		{
		}
	}

	private void writeWithoutThrowingException(byte[] buffer, int offset, int count)
	{
		try
		{
			_stream.Write(buffer, offset, count);
		}
		catch
		{
		}
	}

	internal void Close(bool force)
	{
		if (_disposed)
		{
			return;
		}
		_disposed = true;
		if (!force && flush(closing: true))
		{
			_response.Close();
		}
		else
		{
			if (_sendChunked)
			{
				byte[] chunkSizeBytes = getChunkSizeBytes(0, final: true);
				_write(chunkSizeBytes, 0, chunkSizeBytes.Length);
			}
			_body.Dispose();
			_body = null;
			_response.Abort();
		}
		_response = null;
		_stream = null;
	}

	internal void InternalWrite(byte[] buffer, int offset, int count)
	{
		_write(buffer, offset, count);
	}

	public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
	{
		throw new NotSupportedException();
	}

	public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
	{
		if (_disposed)
		{
			throw new ObjectDisposedException(GetType().ToString());
		}
		return _body.BeginWrite(buffer, offset, count, callback, state);
	}

	public override void Close()
	{
		Close(force: false);
	}

	protected override void Dispose(bool disposing)
	{
		Close(!disposing);
	}

	public override int EndRead(IAsyncResult asyncResult)
	{
		throw new NotSupportedException();
	}

	public override void EndWrite(IAsyncResult asyncResult)
	{
		if (_disposed)
		{
			throw new ObjectDisposedException(GetType().ToString());
		}
		_body.EndWrite(asyncResult);
	}

	public override void Flush()
	{
		if (!_disposed && (_sendChunked || _response.SendChunked))
		{
			flush(closing: false);
		}
	}

	public override int Read(byte[] buffer, int offset, int count)
	{
		throw new NotSupportedException();
	}

	public override long Seek(long offset, SeekOrigin origin)
	{
		throw new NotSupportedException();
	}

	public override void SetLength(long value)
	{
		throw new NotSupportedException();
	}

	public override void Write(byte[] buffer, int offset, int count)
	{
		if (_disposed)
		{
			throw new ObjectDisposedException(GetType().ToString());
		}
		_body.Write(buffer, offset, count);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Security.Permissions;
using System.Text;
using WebSocketSharp;
using WebSocketSharp.Net;

[Serializable]
[ComVisible(true)]
public class WebHeaderCollection : NameValueCollection, ISerializable
{
	private static readonly Dictionary<string, HttpHeaderInfo> _headers;

	private bool _internallyUsed;

	private HttpHeaderType _state;

	internal HttpHeaderType State => _state;

	public override string[] AllKeys => base.AllKeys;

	public override int Count => base.Count;

	public string this[HttpRequestHeader header]
	{
		get
		{
			return Get(Convert(header));
		}
		set
		{
			Add(header, value);
		}
	}

	public string this[HttpResponseHeader header]
	{
		get
		{
			return Get(Convert(header));
		}
		set
		{
			Add(header, value);
		}
	}

	public override KeysCollection Keys => base.Keys;

	static WebHeaderCollection()
	{
		_headers = new Dictionary<string, HttpHeaderInfo>(StringComparer.InvariantCultureIgnoreCase)
		{
			{
				"Accept",
				new HttpHeaderInfo("Accept", HttpHeaderType.Request | HttpHeaderType.Restricted | HttpHeaderType.MultiValue)
			},
			{
				"AcceptCharset",
				new HttpHeaderInfo("Accept-Charset", HttpHeaderType.Request | HttpHeaderType.MultiValue)
			},
			{
				"AcceptEncoding",
				new HttpHeaderInfo("Accept-Encoding", HttpHeaderType.Request | HttpHeaderType.MultiValue)
			},
			{
				"AcceptLanguage",
				new HttpHeaderInfo("Accept-Language", HttpHeaderType.Request | HttpHeaderType.MultiValue)
			},
			{
				"AcceptRanges",
				new HttpHeaderInfo("Accept-Ranges", HttpHeaderType.Response | HttpHeaderType.MultiValue)
			},
			{
				"Age",
				new HttpHeaderInfo("Age", HttpHeaderType.Response)
			},
			{
				"Allow",
				new HttpHeaderInfo("Allow", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
			},
			{
				"Authorization",
				new HttpHeaderInfo("Authorization", HttpHeaderType.Request | HttpHeaderType.MultiValue)
			},
			{
				"CacheControl",
				new HttpHeaderInfo("Cache-Control", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
			},
			{
				"Connection",
				new HttpHeaderInfo("Connection", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted | HttpHeaderType.MultiValue)
			},
			{
				"ContentEncoding",
				new HttpHeaderInfo("Content-Encoding", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
			},
			{
				"ContentLanguage",
				new HttpHeaderInfo("Content-Language", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
			},
			{
				"ContentLength",
				new HttpHeaderInfo("Content-Length", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted)
			},
			{
				"ContentLocation",
				new HttpHeaderInfo("Content-Location", HttpHeaderType.Request | HttpHeaderType.Response)
			},
			{
				"ContentMd5",
				new HttpHeaderInfo("Content-MD5", HttpHeaderType.Request | HttpHeaderType.Response)
			},
			{
				"ContentRange",
				new HttpHeaderInfo("Content-Range", HttpHeaderType.Request | HttpHeaderType.Response)
			},
			{
				"ContentType",
				new HttpHeaderInfo("Content-Type", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted)
			},
			{
				"Cookie",
				new HttpHeaderInfo("Cookie", HttpHeaderType.Request)
			},
			{
				"Cookie2",
				new HttpHeaderInfo("Cookie2", HttpHeaderType.Request)
			},
			{
				"Date",
				new HttpHeaderInfo("Date", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted)
			},
			{
				"Expect",
				new HttpHeaderInfo("Expect", HttpHeaderType.Request | HttpHeaderType.Restricted | HttpHeaderType.MultiValue)
			},
			{
				"Expires",
				new HttpHeaderInfo("Expires", HttpHeaderType.Request | HttpHeaderType.Response)
			},
			{
				"ETag",
				new HttpHeaderInfo("ETag", HttpHeaderType.Response)
			},
			{
				"From",
				new HttpHeaderInfo("From", HttpHeaderType.Request)
			},
			{
				"Host",
				new HttpHeaderInfo("Host", HttpHeaderType.Request | HttpHeaderType.Restricted)
			},
			{
				"IfMatch",
				new HttpHeaderInfo("If-Match", HttpHeaderType.Request | HttpHeaderType.MultiValue)
			},
			{
				"IfModifiedSince",
				new HttpHeaderInfo("If-Modified-Since", HttpHeaderType.Request | HttpHeaderType.Restricted)
			},
			{
				"IfNoneMatch",
				new HttpHeaderInfo("If-None-Match", HttpHeaderType.Request | HttpHeaderType.MultiValue)
			},
			{
				"IfRange",
				new HttpHeaderInfo("If-Range", HttpHeaderType.Request)
			},
			{
				"IfUnmodifiedSince",
				new HttpHeaderInfo("If-Unmodified-Since", HttpHeaderType.Request)
			},
			{
				"KeepAlive",
				new HttpHeaderInfo("Keep-Alive", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
			},
			{
				"LastModified",
				new HttpHeaderInfo("Last-Modified", HttpHeaderType.Request | HttpHeaderType.Response)
			},
			{
				"Location",
				new HttpHeaderInfo("Location", HttpHeaderType.Response)
			},
			{
				"MaxForwards",
				new HttpHeaderInfo("Max-Forwards", HttpHeaderType.Request)
			},
			{
				"Pragma",
				new HttpHeaderInfo("Pragma", HttpHeaderType.Request | HttpHeaderType.Response)
			},
			{
				"ProxyAuthenticate",
				new HttpHeaderInfo("Proxy-Authenticate", HttpHeaderType.Response | HttpHeaderType.MultiValue)
			},
			{
				"ProxyAuthorization",
				new HttpHeaderInfo("Proxy-Authorization", HttpHeaderType.Request)
			},
			{
				"ProxyConnection",
				new HttpHeaderInfo("Proxy-Connection", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted)
			},
			{
				"Public",
				new HttpHeaderInfo("Public", HttpHeaderType.Response | HttpHeaderType.MultiValue)
			},
			{
				"Range",
				new HttpHeaderInfo("Range", HttpHeaderType.Request | HttpHeaderType.Restricted | HttpHeaderType.MultiValue)
			},
			{
				"Referer",
				new HttpHeaderInfo("Referer", HttpHeaderType.Request | HttpHeaderType.Restricted)
			},
			{
				"RetryAfter",
				new HttpHeaderInfo("Retry-After", HttpHeaderType.Response)
			},
			{
				"SecWebSocketAccept",
				new HttpHeaderInfo("Sec-WebSocket-Accept", HttpHeaderType.Response | HttpHeaderType.Restricted)
			},
			{
				"SecWebSocketExtensions",
				new HttpHeaderInfo("Sec-WebSocket-Extensions", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted | HttpHeaderType.MultiValueInRequest)
			},
			{
				"SecWebSocketKey",
				new HttpHeaderInfo("Sec-WebSocket-Key", HttpHeaderType.Request | HttpHeaderType.Restricted)
			},
			{
				"SecWebSocketProtocol",
				new HttpHeaderInfo("Sec-WebSocket-Protocol", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValueInRequest)
			},
			{
				"SecWebSocketVersion",
				new HttpHeaderInfo("Sec-WebSocket-Version", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted | HttpHeaderType.MultiValueInResponse)
			},
			{
				"Server",
				new HttpHeaderInfo("Server", HttpHeaderType.Response)
			},
			{
				"SetCookie",
				new HttpHeaderInfo("Set-Cookie", HttpHeaderType.Response | HttpHeaderType.MultiValue)
			},
			{
				"SetCookie2",
				new HttpHeaderInfo("Set-Cookie2", HttpHeaderType.Response | HttpHeaderType.MultiValue)
			},
			{
				"Te",
				new HttpHeaderInfo("TE", HttpHeaderType.Request)
			},
			{
				"Trailer",
				new HttpHeaderInfo("Trailer", HttpHeaderType.Request | HttpHeaderType.Response)
			},
			{
				"TransferEncoding",
				new HttpHeaderInfo("Transfer-Encoding", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted | HttpHeaderType.MultiValue)
			},
			{
				"Translate",
				new HttpHeaderInfo("Translate", HttpHeaderType.Request)
			},
			{
				"Upgrade",
				new HttpHeaderInfo("Upgrade", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
			},
			{
				"UserAgent",
				new HttpHeaderInfo("User-Agent", HttpHeaderType.Request | HttpHeaderType.Restricted)
			},
			{
				"Vary",
				new HttpHeaderInfo("Vary", HttpHeaderType.Response | HttpHeaderType.MultiValue)
			},
			{
				"Via",
				new HttpHeaderInfo("Via", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
			},
			{
				"Warning",
				new HttpHeaderInfo("Warning", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
			},
			{
				"WwwAuthenticate",
				new HttpHeaderInfo("WWW-Authenticate", HttpHeaderType.Response | HttpHeaderType.Restricted | HttpHeaderType.MultiValue)
			}
		};
	}

	internal WebHeaderCollection(HttpHeaderType state, bool internallyUsed)
	{
		_state = state;
		_internallyUsed = internallyUsed;
	}

	protected WebHeaderCollection(SerializationInfo serializationInfo, StreamingContext streamingContext)
	{
		if (serializationInfo == null)
		{
			throw new ArgumentNullException("serializationInfo");
		}
		try
		{
			_internallyUsed = serializationInfo.GetBoolean("InternallyUsed");
			_state = (HttpHeaderType)serializationInfo.GetInt32("State");
			int @int = serializationInfo.GetInt32("Count");
			for (int i = 0; i < @int; i++)
			{
				base.Add(serializationInfo.GetString(i.ToString()), serializationInfo.GetString((@int + i).ToString()));
			}
		}
		catch (SerializationException ex)
		{
			throw new ArgumentException(ex.Message, "serializationInfo", ex);
		}
	}

	public WebHeaderCollection()
	{
	}

	private void add(string name, string value, bool ignoreRestricted)
	{
		Action<string, string> action = (ignoreRestricted ? new Action<string, string>(addWithoutCheckingNameAndRestricted) : new Action<string, string>(addWithoutCheckingName));
		doWithCheckingState(action, checkName(name), value, setState: true);
	}

	private void addWithoutCheckingName(string name, string value)
	{
		doWithoutCheckingName(base.Add, name, value);
	}

	private void addWithoutCheckingNameAndRestricted(string name, string value)
	{
		base.Add(name, checkValue(value));
	}

	private static int checkColonSeparated(string header)
	{
		int num = header.IndexOf(':');
		if (num == -1)
		{
			throw new ArgumentException("No colon could be found.", "header");
		}
		return num;
	}

	private static HttpHeaderType checkHeaderType(string name)
	{
		HttpHeaderInfo headerInfo = getHeaderInfo(name);
		return (headerInfo != null) ? ((headerInfo.IsRequest && !headerInfo.IsResponse) ? HttpHeaderType.Request : ((!headerInfo.IsRequest && headerInfo.IsResponse) ? HttpHeaderType.Response : HttpHeaderType.Unspecified)) : HttpHeaderType.Unspecified;
	}

	private static string checkName(string name)
	{
		if (name == null || name.Length == 0)
		{
			throw new ArgumentNullException("name");
		}
		name = name.Trim();
		if (!IsHeaderName(name))
		{
			throw new ArgumentException("Contains invalid characters.", "name");
		}
		return name;
	}

	private void checkRestricted(string name)
	{
		if (!_internallyUsed && isRestricted(name, response: true))
		{
			throw new ArgumentException("This header must be modified with the appropiate property.");
		}
	}

	private void checkState(bool response)
	{
		if (_state != 0)
		{
			if (response && _state == HttpHeaderType.Request)
			{
				throw new InvalidOperationException("This collection has already been used to store the request headers.");
			}
			if (!response && _state == HttpHeaderType.Response)
			{
				throw new InvalidOperationException("This collection has already been used to store the response headers.");
			}
		}
	}

	private static string checkValue(string value)
	{
		if (value == null || value.Length == 0)
		{
			return string.Empty;
		}
		value = value.Trim();
		if (value.Length > 65535)
		{
			throw new ArgumentOutOfRangeException("value", "Greater than 65,535 characters.");
		}
		if (!IsHeaderValue(value))
		{
			throw new ArgumentException("Contains invalid characters.", "value");
		}
		return value;
	}

	private static string convert(string key)
	{
		HttpHeaderInfo value;
		return _headers.TryGetValue(key, out value) ? value.Name : string.Empty;
	}

	private void doWithCheckingState(Action<string, string> action, string name, string value, bool setState)
	{
		switch (checkHeaderType(name))
		{
		case HttpHeaderType.Request:
			doWithCheckingState(action, name, value, response: false, setState);
			break;
		case HttpHeaderType.Response:
			doWithCheckingState(action, name, value, response: true, setState);
			break;
		default:
			action(name, value);
			break;
		}
	}

	private void doWithCheckingState(Action<string, string> action, string name, string value, bool response, bool setState)
	{
		checkState(response);
		action(name, value);
		if (setState && _state == HttpHeaderType.Unspecified)
		{
			_state = ((!response) ? HttpHeaderType.Request : HttpHeaderType.Response);
		}
	}

	private void doWithoutCheckingName(Action<string, string> action, string name, string value)
	{
		checkRestricted(name);
		action(name, checkValue(value));
	}

	private static HttpHeaderInfo getHeaderInfo(string name)
	{
		foreach (HttpHeaderInfo value in _headers.Values)
		{
			if (value.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
			{
				return value;
			}
		}
		return null;
	}

	private static bool isRestricted(string name, bool response)
	{
		return getHeaderInfo(name)?.IsRestricted(response) ?? false;
	}

	private void removeWithoutCheckingName(string name, string unuse)
	{
		checkRestricted(name);
		base.Remove(name);
	}

	private void setWithoutCheckingName(string name, string value)
	{
		doWithoutCheckingName(base.Set, name, value);
	}

	internal static string Convert(HttpRequestHeader header)
	{
		return convert(header.ToString());
	}

	internal static string Convert(HttpResponseHeader header)
	{
		return convert(header.ToString());
	}

	internal void InternalRemove(string name)
	{
		base.Remove(name);
	}

	internal void InternalSet(string header, bool response)
	{
		int num = checkColonSeparated(header);
		InternalSet(header.Substring(0, num), header.Substring(num + 1), response);
	}

	internal void InternalSet(string name, string value, bool response)
	{
		value = checkValue(value);
		if (IsMultiValue(name, response))
		{
			base.Add(name, value);
		}
		else
		{
			base.Set(name, value);
		}
	}

	internal static bool IsHeaderName(string name)
	{
		return name != null && name.Length > 0 && name.IsToken();
	}

	internal static bool IsHeaderValue(string value)
	{
		return value.IsText();
	}

	internal static bool IsMultiValue(string headerName, bool response)
	{
		if (headerName == null || headerName.Length == 0)
		{
			return false;
		}
		return getHeaderInfo(headerName)?.IsMultiValue(response) ?? false;
	}

	internal string ToStringMultiValue(bool response)
	{
		StringBuilder buff = new StringBuilder();
		Count.Times(delegate(int i)
		{
			string key = GetKey(i);
			if (IsMultiValue(key, response))
			{
				string[] values = GetValues(i);
				foreach (string arg in values)
				{
					buff.AppendFormat("{0}: {1}\r\n", key, arg);
				}
			}
			else
			{
				buff.AppendFormat("{0}: {1}\r\n", key, Get(i));
			}
		});
		return buff.Append("\r\n").ToString();
	}

	protected void AddWithoutValidate(string headerName, string headerValue)
	{
		add(headerName, headerValue, ignoreRestricted: true);
	}

	public void Add(string header)
	{
		if (header == null || header.Length == 0)
		{
			throw new ArgumentNullException("header");
		}
		int num = checkColonSeparated(header);
		add(header.Substring(0, num), header.Substring(num + 1), ignoreRestricted: false);
	}

	public void Add(HttpRequestHeader header, string value)
	{
		doWithCheckingState(addWithoutCheckingName, Convert(header), value, response: false, setState: true);
	}

	public void Add(HttpResponseHeader header, string value)
	{
		doWithCheckingState(addWithoutCheckingName, Convert(header), value, response: true, setState: true);
	}

	public override void Add(string name, string value)
	{
		add(name, value, ignoreRestricted: false);
	}

	public override void Clear()
	{
		base.Clear();
		_state = HttpHeaderType.Unspecified;
	}

	public override string Get(int index)
	{
		return base.Get(index);
	}

	public override string Get(string name)
	{
		return base.Get(name);
	}

	public override IEnumerator GetEnumerator()
	{
		return base.GetEnumerator();
	}

	public override string GetKey(int index)
	{
		return base.GetKey(index);
	}

	public override string[] GetValues(int index)
	{
		string[] values = base.GetValues(index);
		return (values != null && values.Length != 0) ? values : null;
	}

	public override string[] GetValues(string header)
	{
		string[] values = base.GetValues(header);
		return (values != null && values.Length != 0) ? values : null;
	}

	[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
	public override void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
	{
		if (serializationInfo == null)
		{
			throw new ArgumentNullException("serializationInfo");
		}
		serializationInfo.AddValue("InternallyUsed", _internallyUsed);
		serializationInfo.AddValue("State", (int)_state);
		int cnt = Count;
		serializationInfo.AddValue("Count", cnt);
		cnt.Times(delegate(int i)
		{
			serializationInfo.AddValue(i.ToString(), GetKey(i));
			serializationInfo.AddValue((cnt + i).ToString(), Get(i));
		});
	}

	public static bool IsRestricted(string headerName)
	{
		return isRestricted(checkName(headerName), response: false);
	}

	public static bool IsRestricted(string headerName, bool response)
	{
		return isRestricted(checkName(headerName), response);
	}

	public override void OnDeserialization(object sender)
	{
	}

	public void Remove(HttpRequestHeader header)
	{
		doWithCheckingState(removeWithoutCheckingName, Convert(header), null, response: false, setState: false);
	}

	public void Remove(HttpResponseHeader header)
	{
		doWithCheckingState(removeWithoutCheckingName, Convert(header), null, response: true, setState: false);
	}

	public override void Remove(string name)
	{
		doWithCheckingState(removeWithoutCheckingName, checkName(name), null, setState: false);
	}

	public void Set(HttpRequestHeader header, string value)
	{
		doWithCheckingState(setWithoutCheckingName, Convert(header), value, response: false, setState: true);
	}

	public void Set(HttpResponseHeader header, string value)
	{
		doWithCheckingState(setWithoutCheckingName, Convert(header), value, response: true, setState: true);
	}

	public override void Set(string name, string value)
	{
		doWithCheckingState(setWithoutCheckingName, checkName(name), value, setState: true);
	}

	public byte[] ToByteArray()
	{
		return Encoding.UTF8.GetBytes(ToString());
	}

	public override string ToString()
	{
		StringBuilder buff = new StringBuilder();
		Count.Times(delegate(int i)
		{
			buff.AppendFormat("{0}: {1}\r\n", GetKey(i), Get(i));
		});
		return buff.Append("\r\n").ToString();
	}

	[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter, SerializationFormatter = true)]
	void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
	{
		GetObjectData(serializationInfo, streamingContext);
	}
}


using System;

public class HttpVersion
{
	public static readonly Version Version10 = new Version(1, 0);

	public static readonly Version Version11 = new Version(1, 1);
}


public enum HttpStatusCode
{
	Continue = 100,
	SwitchingProtocols = 101,
	OK = 200,
	Created = 201,
	Accepted = 202,
	NonAuthoritativeInformation = 203,
	NoContent = 204,
	ResetContent = 205,
	PartialContent = 206,
	MultipleChoices = 300,
	Ambiguous = 300,
	MovedPermanently = 301,
	Moved = 301,
	Found = 302,
	Redirect = 302,
	SeeOther = 303,
	RedirectMethod = 303,
	NotModified = 304,
	UseProxy = 305,
	Unused = 306,
	TemporaryRedirect = 307,
	RedirectKeepVerb = 307,
	BadRequest = 400,
	Unauthorized = 401,
	PaymentRequired = 402,
	Forbidden = 403,
	NotFound = 404,
	MethodNotAllowed = 405,
	NotAcceptable = 406,
	ProxyAuthenticationRequired = 407,
	RequestTimeout = 408,
	Conflict = 409,
	Gone = 410,
	LengthRequired = 411,
	PreconditionFailed = 412,
	RequestEntityTooLarge = 413,
	RequestUriTooLong = 414,
	UnsupportedMediaType = 415,
	RequestedRangeNotSatisfiable = 416,
	ExpectationFailed = 417,
	InternalServerError = 500,
	NotImplemented = 501,
	BadGateway = 502,
	ServiceUnavailable = 503,
	GatewayTimeout = 504,
	HttpVersionNotSupported = 505
}


using System;

[Flags]
internal enum HttpHeaderType
{
	Unspecified = 0,
	Request = 1,
	Response = 2,
	Restricted = 4,
	MultiValue = 8,
	MultiValueInRequest = 0x10,
	MultiValueInResponse = 0x20
}


using WebSocketSharp.Net;

internal class HttpHeaderInfo
{
	private string _name;

	private HttpHeaderType _type;

	internal bool IsMultiValueInRequest => (_type & HttpHeaderType.MultiValueInRequest) == HttpHeaderType.MultiValueInRequest;

	internal bool IsMultiValueInResponse => (_type & HttpHeaderType.MultiValueInResponse) == HttpHeaderType.MultiValueInResponse;

	public bool IsRequest => (_type & HttpHeaderType.Request) == HttpHeaderType.Request;

	public bool IsResponse => (_type & HttpHeaderType.Response) == HttpHeaderType.Response;

	public string Name => _name;

	public HttpHeaderType Type => _type;

	internal HttpHeaderInfo(string name, HttpHeaderType type)
	{
		_name = name;
		_type = type;
	}

	public bool IsMultiValue(bool response)
	{
		return ((_type & HttpHeaderType.MultiValue) != HttpHeaderType.MultiValue) ? (response ? IsMultiValueInResponse : IsMultiValueInRequest) : (response ? IsResponse : IsRequest);
	}

	public bool IsRestricted(bool response)
	{
		return (_type & HttpHeaderType.Restricted) == HttpHeaderType.Restricted && (response ? IsResponse : IsRequest);
	}
}


using System.Security.Principal;

public class HttpBasicIdentity : GenericIdentity
{
	private string _password;

	public virtual string Password => _password;

	internal HttpBasicIdentity(string username, string password)
		: base(username, "Basic")
	{
		_password = password;
	}
}


using System.Collections.Specialized;
using System.Security.Principal;
using WebSocketSharp.Net;

public class HttpDigestIdentity : GenericIdentity
{
	private NameValueCollection _parameters;

	public string Algorithm => _parameters["algorithm"];

	public string Cnonce => _parameters["cnonce"];

	public string Nc => _parameters["nc"];

	public string Nonce => _parameters["nonce"];

	public string Opaque => _parameters["opaque"];

	public string Qop => _parameters["qop"];

	public string Realm => _parameters["realm"];

	public string Response => _parameters["response"];

	public string Uri => _parameters["uri"];

	internal HttpDigestIdentity(NameValueCollection parameters)
		: base(parameters["username"], "Digest")
	{
		_parameters = parameters;
	}

	internal bool IsValid(string password, string realm, string method, string entity)
	{
		NameValueCollection nameValueCollection = new NameValueCollection(_parameters);
		nameValueCollection["password"] = password;
		nameValueCollection["realm"] = realm;
		nameValueCollection["method"] = method;
		nameValueCollection["entity"] = entity;
		return _parameters["response"] == AuthenticationResponse.CreateRequestDigest(nameValueCollection);
	}
}


using System;

public class NetworkCredential
{
	private string _domain;

	private string _password;

	private string[] _roles;

	private string _userName;

	public string Domain
	{
		get
		{
			return _domain ?? string.Empty;
		}
		internal set
		{
			_domain = value;
		}
	}

	public string Password
	{
		get
		{
			return _password ?? string.Empty;
		}
		internal set
		{
			_password = value;
		}
	}

	public string[] Roles
	{
		get
		{
			return _roles ?? (_roles = new string[0]);
		}
		internal set
		{
			_roles = value;
		}
	}

	public string UserName
	{
		get
		{
			return _userName;
		}
		internal set
		{
			_userName = value;
		}
	}

	public NetworkCredential(string userName, string password)
		: this(userName, password, (string)null, (string[])null)
	{
	}

	public NetworkCredential(string userName, string password, string domain, params string[] roles)
	{
		if (userName == null)
		{
			throw new ArgumentNullException("userName");
		}
		if (userName.Length == 0)
		{
			throw new ArgumentException("An empty string.", "userName");
		}
		_userName = userName;
		_password = password;
		_domain = domain;
		_roles = roles;
	}
}


internal enum InputState
{
	RequestLine,
	Headers
}


internal enum LineState
{
	None,
	Cr,
	Lf
}


using WebSocketSharp.Net;

internal class ReadBufferState
{
	private HttpStreamAsyncResult _asyncResult;

	private byte[] _buffer;

	private int _count;

	private int _initialCount;

	private int _offset;

	public HttpStreamAsyncResult AsyncResult
	{
		get
		{
			return _asyncResult;
		}
		set
		{
			_asyncResult = value;
		}
	}

	public byte[] Buffer
	{
		get
		{
			return _buffer;
		}
		set
		{
			_buffer = value;
		}
	}

	public int Count
	{
		get
		{
			return _count;
		}
		set
		{
			_count = value;
		}
	}

	public int InitialCount
	{
		get
		{
			return _initialCount;
		}
		set
		{
			_initialCount = value;
		}
	}

	public int Offset
	{
		get
		{
			return _offset;
		}
		set
		{
			_offset = value;
		}
	}

	public ReadBufferState(byte[] buffer, int offset, int count, HttpStreamAsyncResult asyncResult)
	{
		_buffer = buffer;
		_offset = offset;
		_count = count;
		_initialCount = count;
		_asyncResult = asyncResult;
	}
}


using System;

internal class Chunk
{
	private byte[] _data;

	private int _offset;

	public int ReadLeft => _data.Length - _offset;

	public Chunk(byte[] data)
	{
		_data = data;
	}

	public int Read(byte[] buffer, int offset, int count)
	{
		int num = _data.Length - _offset;
		if (num == 0)
		{
			return num;
		}
		if (count > num)
		{
			count = num;
		}
		Buffer.BlockCopy(_data, _offset, buffer, offset, count);
		_offset += count;
		return count;
	}
}


internal enum InputChunkState
{
	None,
	Data,
	DataEnded,
	Trailer,
	End
}


using System;
using System.IO;
using WebSocketSharp.Net;

internal class ChunkedRequestStream : RequestStream
{
	private const int _bufferLength = 8192;

	private HttpListenerContext _context;

	private ChunkStream _decoder;

	private bool _disposed;

	private bool _noMoreData;

	internal ChunkStream Decoder
	{
		get
		{
			return _decoder;
		}
		set
		{
			_decoder = value;
		}
	}

	internal ChunkedRequestStream(Stream stream, byte[] buffer, int offset, int count, HttpListenerContext context)
		: base(stream, buffer, offset, count)
	{
		_context = context;
		_decoder = new ChunkStream((WebHeaderCollection)context.Request.Headers);
	}

	private void onRead(IAsyncResult asyncResult)
	{
		ReadBufferState readBufferState = (ReadBufferState)asyncResult.AsyncState;
		HttpStreamAsyncResult asyncResult2 = readBufferState.AsyncResult;
		try
		{
			int count = base.EndRead(asyncResult);
			_decoder.Write(asyncResult2.Buffer, asyncResult2.Offset, count);
			count = _decoder.Read(readBufferState.Buffer, readBufferState.Offset, readBufferState.Count);
			readBufferState.Offset += count;
			readBufferState.Count -= count;
			if (readBufferState.Count == 0 || !_decoder.WantMore || count == 0)
			{
				_noMoreData = !_decoder.WantMore && count == 0;
				asyncResult2.Count = readBufferState.InitialCount - readBufferState.Count;
				asyncResult2.Complete();
			}
			else
			{
				asyncResult2.Offset = 0;
				asyncResult2.Count = Math.Min(8192, _decoder.ChunkLeft + 6);
				base.BeginRead(asyncResult2.Buffer, asyncResult2.Offset, asyncResult2.Count, (AsyncCallback)onRead, (object)readBufferState);
			}
		}
		catch (Exception ex)
		{
			_context.Connection.SendError(ex.Message, 400);
			asyncResult2.Complete(ex);
		}
	}

	public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
	{
		if (_disposed)
		{
			throw new ObjectDisposedException(GetType().ToString());
		}
		if (buffer == null)
		{
			throw new ArgumentNullException("buffer");
		}
		if (offset < 0)
		{
			throw new ArgumentOutOfRangeException("offset", "A negative value.");
		}
		if (count < 0)
		{
			throw new ArgumentOutOfRangeException("count", "A negative value.");
		}
		int num = buffer.Length;
		if (offset + count > num)
		{
			throw new ArgumentException("The sum of 'offset' and 'count' is greater than 'buffer' length.");
		}
		HttpStreamAsyncResult httpStreamAsyncResult = new HttpStreamAsyncResult(callback, state);
		if (_noMoreData)
		{
			httpStreamAsyncResult.Complete();
			return httpStreamAsyncResult;
		}
		int num2 = _decoder.Read(buffer, offset, count);
		offset += num2;
		count -= num2;
		if (count == 0)
		{
			httpStreamAsyncResult.Count = num2;
			httpStreamAsyncResult.Complete();
			return httpStreamAsyncResult;
		}
		if (!_decoder.WantMore)
		{
			_noMoreData = num2 == 0;
			httpStreamAsyncResult.Count = num2;
			httpStreamAsyncResult.Complete();
			return httpStreamAsyncResult;
		}
		httpStreamAsyncResult.Buffer = new byte[8192];
		httpStreamAsyncResult.Offset = 0;
		httpStreamAsyncResult.Count = 8192;
		ReadBufferState readBufferState = new ReadBufferState(buffer, offset, count, httpStreamAsyncResult);
		readBufferState.InitialCount += num2;
		base.BeginRead(httpStreamAsyncResult.Buffer, httpStreamAsyncResult.Offset, httpStreamAsyncResult.Count, (AsyncCallback)onRead, (object)readBufferState);
		return httpStreamAsyncResult;
	}

	public override void Close()
	{
		if (!_disposed)
		{
			_disposed = true;
			base.Close();
		}
	}

	public override int EndRead(IAsyncResult asyncResult)
	{
		if (_disposed)
		{
			throw new ObjectDisposedException(GetType().ToString());
		}
		if (asyncResult == null)
		{
			throw new ArgumentNullException("asyncResult");
		}
		if (!(asyncResult is HttpStreamAsyncResult httpStreamAsyncResult))
		{
			throw new ArgumentException("A wrong IAsyncResult.", "asyncResult");
		}
		if (!httpStreamAsyncResult.IsCompleted)
		{
			httpStreamAsyncResult.AsyncWaitHandle.WaitOne();
		}
		if (httpStreamAsyncResult.HasException)
		{
			throw new HttpListenerException(400, "I/O operation aborted.");
		}
		return httpStreamAsyncResult.Count;
	}

	public override int Read(byte[] buffer, int offset, int count)
	{
		IAsyncResult asyncResult = BeginRead(buffer, offset, count, null, null);
		return EndRead(asyncResult);
	}
}


using System.Collections.Specialized;
using System.Text;

internal sealed class QueryStringCollection : NameValueCollection
{
	public override string ToString()
	{
		if (Count == 0)
		{
			return string.Empty;
		}
		StringBuilder stringBuilder = new StringBuilder();
		string[] allKeys = AllKeys;
		string[] array = allKeys;
		foreach (string text in array)
		{
			stringBuilder.AppendFormat("{0}={1}&", text, base[text]);
		}
		if (stringBuilder.Length > 0)
		{
			stringBuilder.Length--;
		}
		return stringBuilder.ToString();
	}
}


using System.Collections.Specialized;
using System.Text;
using WebSocketSharp.Net;

internal class AuthenticationChallenge : AuthenticationBase
{
	public string Domain => Parameters["domain"];

	public string Stale => Parameters["stale"];

	private AuthenticationChallenge(AuthenticationSchemes scheme, NameValueCollection parameters)
		: base(scheme, parameters)
	{
	}

	internal AuthenticationChallenge(AuthenticationSchemes scheme, string realm)
		: base(scheme, new NameValueCollection())
	{
		Parameters["realm"] = realm;
		if (scheme == AuthenticationSchemes.Digest)
		{
			Parameters["nonce"] = AuthenticationBase.CreateNonceValue();
			Parameters["algorithm"] = "MD5";
			Parameters["qop"] = "auth";
		}
	}

	internal static AuthenticationChallenge CreateBasicChallenge(string realm)
	{
		return new AuthenticationChallenge(AuthenticationSchemes.Basic, realm);
	}

	internal static AuthenticationChallenge CreateDigestChallenge(string realm)
	{
		return new AuthenticationChallenge(AuthenticationSchemes.Digest, realm);
	}

	internal static AuthenticationChallenge Parse(string value)
	{
		string[] array = value.Split(new char[1] { ' ' }, 2);
		if (array.Length != 2)
		{
			return null;
		}
		string text = array[0].ToLower();
		return (text == "basic") ? new AuthenticationChallenge(AuthenticationSchemes.Basic, AuthenticationBase.ParseParameters(array[1])) : ((text == "digest") ? new AuthenticationChallenge(AuthenticationSchemes.Digest, AuthenticationBase.ParseParameters(array[1])) : null);
	}

	internal override string ToBasicString()
	{
		return string.Format("Basic realm=\"{0}\"", Parameters["realm"]);
	}

	internal override string ToDigestString()
	{
		StringBuilder stringBuilder = new StringBuilder(128);
		string text = Parameters["domain"];
		if (text != null)
		{
			stringBuilder.AppendFormat("Digest realm=\"{0}\", domain=\"{1}\", nonce=\"{2}\"", Parameters["realm"], text, Parameters["nonce"]);
		}
		else
		{
			stringBuilder.AppendFormat("Digest realm=\"{0}\", nonce=\"{1}\"", Parameters["realm"], Parameters["nonce"]);
		}
		string text2 = Parameters["opaque"];
		if (text2 != null)
		{
			stringBuilder.AppendFormat(", opaque=\"{0}\"", text2);
		}
		string text3 = Parameters["stale"];
		if (text3 != null)
		{
			stringBuilder.AppendFormat(", stale={0}", text3);
		}
		string text4 = Parameters["algorithm"];
		if (text4 != null)
		{
			stringBuilder.AppendFormat(", algorithm={0}", text4);
		}
		string text5 = Parameters["qop"];
		if (text5 != null)
		{
			stringBuilder.AppendFormat(", qop=\"{0}\"", text5);
		}
		return stringBuilder.ToString();
	}
}


using System;
using System.Collections.Specialized;
using System.Security.Cryptography;
using System.Security.Principal;
using System.Text;
using WebSocketSharp;
using WebSocketSharp.Net;

internal class AuthenticationResponse : AuthenticationBase
{
	private uint _nonceCount;

	internal uint NonceCount => (_nonceCount < uint.MaxValue) ? _nonceCount : 0u;

	public string Cnonce => Parameters["cnonce"];

	public string Nc => Parameters["nc"];

	public string Password => Parameters["password"];

	public string Response => Parameters["response"];

	public string Uri => Parameters["uri"];

	public string UserName => Parameters["username"];

	private AuthenticationResponse(AuthenticationSchemes scheme, NameValueCollection parameters)
		: base(scheme, parameters)
	{
	}

	internal AuthenticationResponse(NetworkCredential credentials)
		: this(AuthenticationSchemes.Basic, new NameValueCollection(), credentials, 0u)
	{
	}

	internal AuthenticationResponse(AuthenticationChallenge challenge, NetworkCredential credentials, uint nonceCount)
		: this(challenge.Scheme, challenge.Parameters, credentials, nonceCount)
	{
	}

	internal AuthenticationResponse(AuthenticationSchemes scheme, NameValueCollection parameters, NetworkCredential credentials, uint nonceCount)
		: base(scheme, parameters)
	{
		Parameters["username"] = credentials.UserName;
		Parameters["password"] = credentials.Password;
		Parameters["uri"] = credentials.Domain;
		_nonceCount = nonceCount;
		if (scheme == AuthenticationSchemes.Digest)
		{
			initAsDigest();
		}
	}

	private static string createA1(string username, string password, string realm)
	{
		return $"{username}:{realm}:{password}";
	}

	private static string createA1(string username, string password, string realm, string nonce, string cnonce)
	{
		return $"{hash(createA1(username, password, realm))}:{nonce}:{cnonce}";
	}

	private static string createA2(string method, string uri)
	{
		return $"{method}:{uri}";
	}

	private static string createA2(string method, string uri, string entity)
	{
		return $"{method}:{uri}:{hash(entity)}";
	}

	private static string hash(string value)
	{
		byte[] bytes = Encoding.UTF8.GetBytes(value);
		MD5 mD = MD5.Create();
		byte[] array = mD.ComputeHash(bytes);
		StringBuilder stringBuilder = new StringBuilder(64);
		byte[] array2 = array;
		foreach (byte b in array2)
		{
			stringBuilder.Append(b.ToString("x2"));
		}
		return stringBuilder.ToString();
	}

	private void initAsDigest()
	{
		string text = Parameters["qop"];
		if (text != null)
		{
			if (text.Split(new char[1] { ',' }).Contains((string qop) => qop.Trim().ToLower() == "auth"))
			{
				Parameters["qop"] = "auth";
				Parameters["cnonce"] = AuthenticationBase.CreateNonceValue();
				Parameters["nc"] = $"{++_nonceCount:x8}";
			}
			else
			{
				Parameters["qop"] = null;
			}
		}
		Parameters["method"] = "GET";
		Parameters["response"] = CreateRequestDigest(Parameters);
	}

	internal static string CreateRequestDigest(NameValueCollection parameters)
	{
		string username = parameters["username"];
		string password = parameters["password"];
		string realm = parameters["realm"];
		string text = parameters["nonce"];
		string uri = parameters["uri"];
		string text2 = parameters["algorithm"];
		string text3 = parameters["qop"];
		string text4 = parameters["cnonce"];
		string text5 = parameters["nc"];
		string method = parameters["method"];
		string value = ((text2 != null && text2.ToLower() == "md5-sess") ? createA1(username, password, realm, text, text4) : createA1(username, password, realm));
		string value2 = ((text3 != null && text3.ToLower() == "auth-int") ? createA2(method, uri, parameters["entity"]) : createA2(method, uri));
		string arg = hash(value);
		string arg2 = ((text3 != null) ? $"{text}:{text5}:{text4}:{text3}:{hash(value2)}" : $"{text}:{hash(value2)}");
		return hash($"{arg}:{arg2}");
	}

	internal static AuthenticationResponse Parse(string value)
	{
		try
		{
			string[] array = value.Split(new char[1] { ' ' }, 2);
			if (array.Length != 2)
			{
				return null;
			}
			string text = array[0].ToLower();
			return (text == "basic") ? new AuthenticationResponse(AuthenticationSchemes.Basic, ParseBasicCredentials(array[1])) : ((text == "digest") ? new AuthenticationResponse(AuthenticationSchemes.Digest, AuthenticationBase.ParseParameters(array[1])) : null);
		}
		catch
		{
		}
		return null;
	}

	internal static NameValueCollection ParseBasicCredentials(string value)
	{
		string @string = Encoding.Default.GetString(Convert.FromBase64String(value));
		int num = @string.IndexOf(':');
		string text = @string.Substring(0, num);
		string value2 = ((num < @string.Length - 1) ? @string.Substring(num + 1) : string.Empty);
		num = text.IndexOf('\\');
		if (num > -1)
		{
			text = text.Substring(num + 1);
		}
		NameValueCollection nameValueCollection = new NameValueCollection();
		nameValueCollection["username"] = text;
		nameValueCollection["password"] = value2;
		return nameValueCollection;
	}

	internal override string ToBasicString()
	{
		string s = string.Format("{0}:{1}", Parameters["username"], Parameters["password"]);
		string text = Convert.ToBase64String(Encoding.UTF8.GetBytes(s));
		return "Basic " + text;
	}

	internal override string ToDigestString()
	{
		StringBuilder stringBuilder = new StringBuilder(256);
		stringBuilder.AppendFormat("Digest username=\"{0}\", realm=\"{1}\", nonce=\"{2}\", uri=\"{3}\", response=\"{4}\"", Parameters["username"], Parameters["realm"], Parameters["nonce"], Parameters["uri"], Parameters["response"]);
		string text = Parameters["opaque"];
		if (text != null)
		{
			stringBuilder.AppendFormat(", opaque=\"{0}\"", text);
		}
		string text2 = Parameters["algorithm"];
		if (text2 != null)
		{
			stringBuilder.AppendFormat(", algorithm={0}", text2);
		}
		string text3 = Parameters["qop"];
		if (text3 != null)
		{
			stringBuilder.AppendFormat(", qop={0}, cnonce=\"{1}\", nc={2}", text3, Parameters["cnonce"], Parameters["nc"]);
		}
		return stringBuilder.ToString();
	}

	public IIdentity ToIdentity()
	{
		AuthenticationSchemes scheme = base.Scheme;
		IIdentity result;
		if (scheme != AuthenticationSchemes.Basic)
		{
			IIdentity identity = ((scheme == AuthenticationSchemes.Digest) ? new HttpDigestIdentity(Parameters) : null);
			result = identity;
		}
		else
		{
			IIdentity identity = new HttpBasicIdentity(Parameters["username"], Parameters["password"]);
			result = identity;
		}
		return result;
	}
}


using System;
using System.Collections.Specialized;
using System.Text;
using WebSocketSharp;
using WebSocketSharp.Net;

internal abstract class AuthenticationBase
{
	private AuthenticationSchemes _scheme;

	internal NameValueCollection Parameters;

	public string Algorithm => Parameters["algorithm"];

	public string Nonce => Parameters["nonce"];

	public string Opaque => Parameters["opaque"];

	public string Qop => Parameters["qop"];

	public string Realm => Parameters["realm"];

	public AuthenticationSchemes Scheme => _scheme;

	protected AuthenticationBase(AuthenticationSchemes scheme, NameValueCollection parameters)
	{
		_scheme = scheme;
		Parameters = parameters;
	}

	internal static string CreateNonceValue()
	{
		byte[] array = new byte[16];
		Random random = new Random();
		random.NextBytes(array);
		StringBuilder stringBuilder = new StringBuilder(32);
		byte[] array2 = array;
		foreach (byte b in array2)
		{
			stringBuilder.Append(b.ToString("x2"));
		}
		return stringBuilder.ToString();
	}

	internal static NameValueCollection ParseParameters(string value)
	{
		NameValueCollection nameValueCollection = new NameValueCollection();
		foreach (string item in value.SplitHeaderValue(','))
		{
			int num = item.IndexOf('=');
			string name = ((num > 0) ? item.Substring(0, num).Trim() : null);
			string value2 = ((num < 0) ? item.Trim().Trim(new char[1] { '"' }) : ((num < item.Length - 1) ? item.Substring(num + 1).Trim().Trim(new char[1] { '"' }) : string.Empty));
			nameValueCollection.Add(name, value2);
		}
		return nameValueCollection;
	}

	internal abstract string ToBasicString();

	internal abstract string ToDigestString();

	public override string ToString()
	{
		return (_scheme == AuthenticationSchemes.Basic) ? ToBasicString() : ((_scheme == AuthenticationSchemes.Digest) ? ToDigestString() : string.Empty);
	}
}


using System;
using WebSocketSharp.Net;

internal sealed class HttpListenerPrefix
{
	private string _host;

	private HttpListener _listener;

	private string _original;

	private string _path;

	private string _port;

	private string _prefix;

	private bool _secure;

	public string Host => _host;

	public bool IsSecure => _secure;

	public HttpListener Listener
	{
		get
		{
			return _listener;
		}
		set
		{
			_listener = value;
		}
	}

	public string Original => _original;

	public string Path => _path;

	public string Port => _port;

	internal HttpListenerPrefix(string uriPrefix)
	{
		_original = uriPrefix;
		parse(uriPrefix);
	}

	private void parse(string uriPrefix)
	{
		if (uriPrefix.StartsWith("https"))
		{
			_secure = true;
		}
		int length = uriPrefix.Length;
		int num = uriPrefix.IndexOf(':') + 3;
		int num2 = uriPrefix.IndexOf('/', num + 1, length - num - 1);
		int num3 = uriPrefix.LastIndexOf(':', num2 - 1, num2 - num - 1);
		if (uriPrefix[num2 - 1] != ']' && num3 > num)
		{
			_host = uriPrefix.Substring(num, num3 - num);
			_port = uriPrefix.Substring(num3 + 1, num2 - num3 - 1);
		}
		else
		{
			_host = uriPrefix.Substring(num, num2 - num);
			_port = (_secure ? "443" : "80");
		}
		_path = uriPrefix.Substring(num2);
		_prefix = string.Format("http{0}://{1}:{2}{3}", _secure ? "s" : "", _host, _port, _path);
	}

	public static void CheckPrefix(string uriPrefix)
	{
		if (uriPrefix == null)
		{
			throw new ArgumentNullException("uriPrefix");
		}
		int length = uriPrefix.Length;
		if (length == 0)
		{
			throw new ArgumentException("An empty string.", "uriPrefix");
		}
		if (!uriPrefix.StartsWith("http://") && !uriPrefix.StartsWith("https://"))
		{
			throw new ArgumentException("The scheme isn't 'http' or 'https'.", "uriPrefix");
		}
		int num = uriPrefix.IndexOf(':') + 3;
		if (num >= length)
		{
			throw new ArgumentException("No host is specified.", "uriPrefix");
		}
		if (uriPrefix[num] == ':')
		{
			throw new ArgumentException("No host is specified.", "uriPrefix");
		}
		int num2 = uriPrefix.IndexOf('/', num, length - num);
		if (num2 == num)
		{
			throw new ArgumentException("No host is specified.", "uriPrefix");
		}
		if (num2 == -1 || uriPrefix[length - 1] != '/')
		{
			throw new ArgumentException("Ends without '/'.", "uriPrefix");
		}
		if (uriPrefix[num2 - 1] == ':')
		{
			throw new ArgumentException("No port is specified.", "uriPrefix");
		}
		if (num2 == length - 2)
		{
			throw new ArgumentException("No path is specified.", "uriPrefix");
		}
	}

	public override bool Equals(object obj)
	{
		return obj is HttpListenerPrefix httpListenerPrefix && httpListenerPrefix._prefix == _prefix;
	}

	public override int GetHashCode()
	{
		return _prefix.GetHashCode();
	}

	public override string ToString()
	{
		return _prefix;
	}
}


using System.Net.Security;
using System.Security.Authentication;
using System.Security.Cryptography.X509Certificates;
using WebSocketSharp.Net;

public class ClientSslConfiguration : SslConfiguration
{
	private X509CertificateCollection _certs;

	private string _host;

	public X509CertificateCollection ClientCertificates
	{
		get
		{
			return _certs;
		}
		set
		{
			_certs = value;
		}
	}

	public LocalCertificateSelectionCallback ClientCertificateSelectionCallback
	{
		get
		{
			return base.CertificateSelectionCallback;
		}
		set
		{
			base.CertificateSelectionCallback = value;
		}
	}

	public RemoteCertificateValidationCallback ServerCertificateValidationCallback
	{
		get
		{
			return base.CertificateValidationCallback;
		}
		set
		{
			base.CertificateValidationCallback = value;
		}
	}

	public string TargetHost
	{
		get
		{
			return _host;
		}
		set
		{
			_host = value;
		}
	}

	public ClientSslConfiguration(string targetHost)
		: this(targetHost, null, SslProtocols.Default, checkCertificateRevocation: false)
	{
	}

	public ClientSslConfiguration(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
		: base(enabledSslProtocols, checkCertificateRevocation)
	{
		_host = targetHost;
		_certs = clientCertificates;
	}
}


using System.Net.Security;
using System.Security.Authentication;
using System.Security.Cryptography.X509Certificates;
using WebSocketSharp.Net;

public class ServerSslConfiguration : SslConfiguration
{
	private X509Certificate2 _cert;

	private bool _clientCertRequired;

	public bool ClientCertificateRequired
	{
		get
		{
			return _clientCertRequired;
		}
		set
		{
			_clientCertRequired = value;
		}
	}

	public RemoteCertificateValidationCallback ClientCertificateValidationCallback
	{
		get
		{
			return base.CertificateValidationCallback;
		}
		set
		{
			base.CertificateValidationCallback = value;
		}
	}

	public X509Certificate2 ServerCertificate
	{
		get
		{
			return _cert;
		}
		set
		{
			_cert = value;
		}
	}

	public ServerSslConfiguration(X509Certificate2 serverCertificate)
		: this(serverCertificate, clientCertificateRequired: false, SslProtocols.Default, checkCertificateRevocation: false)
	{
	}

	public ServerSslConfiguration(X509Certificate2 serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
		: base(enabledSslProtocols, checkCertificateRevocation)
	{
		_cert = serverCertificate;
		_clientCertRequired = clientCertificateRequired;
	}
}


using System.Net.Security;
using System.Security.Authentication;
using System.Security.Cryptography.X509Certificates;

public abstract class SslConfiguration
{
	private LocalCertificateSelectionCallback _certSelectionCallback;

	private RemoteCertificateValidationCallback _certValidationCallback;

	private bool _checkCertRevocation;

	private SslProtocols _enabledProtocols;

	protected LocalCertificateSelectionCallback CertificateSelectionCallback
	{
		get
		{
			return (object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, string[] acceptableIssuers) => (X509Certificate)null;
		}
		set
		{
			_certSelectionCallback = value;
		}
	}

	protected RemoteCertificateValidationCallback CertificateValidationCallback
	{
		get
		{
			return (object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors) => true;
		}
		set
		{
			_certValidationCallback = value;
		}
	}

	public bool CheckCertificateRevocation
	{
		get
		{
			return _checkCertRevocation;
		}
		set
		{
			_checkCertRevocation = value;
		}
	}

	public SslProtocols EnabledSslProtocols
	{
		get
		{
			return _enabledProtocols;
		}
		set
		{
			_enabledProtocols = value;
		}
	}

	protected SslConfiguration(SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
	{
		_enabledProtocols = enabledSslProtocols;
		_checkCertRevocation = checkCertificateRevocation;
	}
}


using System;
using System.Threading;
using WebSocketSharp.Net;

internal class HttpListenerAsyncResult : IAsyncResult
{
	private AsyncCallback _callback;

	private bool _completed;

	private HttpListenerContext _context;

	private bool _endCalled;

	private Exception _exception;

	private bool _inGet;

	private object _state;

	private object _sync;

	private bool _syncCompleted;

	private ManualResetEvent _waitHandle;

	internal bool EndCalled
	{
		get
		{
			return _endCalled;
		}
		set
		{
			_endCalled = value;
		}
	}

	internal bool InGet
	{
		get
		{
			return _inGet;
		}
		set
		{
			_inGet = value;
		}
	}

	public object AsyncState => _state;

	public WaitHandle AsyncWaitHandle
	{
		get
		{
			lock (_sync)
			{
				return _waitHandle ?? (_waitHandle = new ManualResetEvent(_completed));
			}
		}
	}

	public bool CompletedSynchronously => _syncCompleted;

	public bool IsCompleted
	{
		get
		{
			lock (_sync)
			{
				return _completed;
			}
		}
	}

	internal HttpListenerAsyncResult(AsyncCallback callback, object state)
	{
		_callback = callback;
		_state = state;
		_sync = new object();
	}

	private static void complete(HttpListenerAsyncResult asyncResult)
	{
		lock (asyncResult._sync)
		{
			asyncResult._completed = true;
			asyncResult._waitHandle?.Set();
		}
		AsyncCallback callback = asyncResult._callback;
		if (callback == null)
		{
			return;
		}
		ThreadPool.QueueUserWorkItem(delegate
		{
			try
			{
				callback(asyncResult);
			}
			catch
			{
			}
		}, null);
	}

	internal void Complete(Exception exception)
	{
		_exception = ((_inGet && exception is ObjectDisposedException) ? new HttpListenerException(995, "The listener is closed.") : exception);
		complete(this);
	}

	internal void Complete(HttpListenerContext context)
	{
		Complete(context, syncCompleted: false);
	}

	internal void Complete(HttpListenerContext context, bool syncCompleted)
	{
		_context = context;
		_syncCompleted = syncCompleted;
		complete(this);
	}

	internal HttpListenerContext GetContext()
	{
		if (_exception != null)
		{
			throw _exception;
		}
		return _context;
	}
}


public enum HttpRequestHeader
{
	CacheControl,
	Connection,
	Date,
	KeepAlive,
	Pragma,
	Trailer,
	TransferEncoding,
	Upgrade,
	Via,
	Warning,
	Allow,
	ContentLength,
	ContentType,
	ContentEncoding,
	ContentLanguage,
	ContentLocation,
	ContentMd5,
	ContentRange,
	Expires,
	LastModified,
	Accept,
	AcceptCharset,
	AcceptEncoding,
	AcceptLanguage,
	Authorization,
	Cookie,
	Expect,
	From,
	Host,
	IfMatch,
	IfModifiedSince,
	IfNoneMatch,
	IfRange,
	IfUnmodifiedSince,
	MaxForwards,
	ProxyAuthorization,
	Referer,
	Range,
	Te,
	Translate,
	UserAgent,
	SecWebSocketKey,
	SecWebSocketExtensions,
	SecWebSocketProtocol,
	SecWebSocketVersion
}


public enum HttpResponseHeader
{
	CacheControl,
	Connection,
	Date,
	KeepAlive,
	Pragma,
	Trailer,
	TransferEncoding,
	Upgrade,
	Via,
	Warning,
	Allow,
	ContentLength,
	ContentType,
	ContentEncoding,
	ContentLanguage,
	ContentLocation,
	ContentMd5,
	ContentRange,
	Expires,
	LastModified,
	AcceptRanges,
	Age,
	ETag,
	Location,
	ProxyAuthenticate,
	RetryAfter,
	Server,
	SetCookie,
	Vary,
	WwwAuthenticate,
	SecWebSocketExtensions,
	SecWebSocketAccept,
	SecWebSocketProtocol,
	SecWebSocketVersion
}


using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Net;
using System.Security.Principal;
using WebSocketSharp;
using WebSocketSharp.Net;
using WebSocketSharp.Net.WebSockets;

public class HttpListenerWebSocketContext : WebSocketContext
{
	private WebSocketSharp.Net.HttpListenerContext _context;

	private WebSocket _websocket;

	internal Logger Log => _context.Listener.Log;

	internal Stream Stream => _context.Connection.Stream;

	public override WebSocketSharp.Net.CookieCollection CookieCollection => _context.Request.Cookies;

	public override NameValueCollection Headers => _context.Request.Headers;

	public override string Host => _context.Request.Headers["Host"];

	public override bool IsAuthenticated => _context.User != null;

	public override bool IsLocal => _context.Request.IsLocal;

	public override bool IsSecureConnection => _context.Connection.IsSecure;

	public override bool IsWebSocketRequest => _context.Request.IsWebSocketRequest;

	public override string Origin => _context.Request.Headers["Origin"];

	public override NameValueCollection QueryString => _context.Request.QueryString;

	public override Uri RequestUri => _context.Request.Url;

	public override string SecWebSocketKey => _context.Request.Headers["Sec-WebSocket-Key"];

	public override IEnumerable<string> SecWebSocketProtocols
	{
		get
		{
			string protocols = _context.Request.Headers["Sec-WebSocket-Protocol"];
			if (protocols != null)
			{
				string[] array = protocols.Split(new char[1] { ',' });
				foreach (string protocol in array)
				{
					yield return protocol.Trim();
				}
			}
		}
	}

	public override string SecWebSocketVersion => _context.Request.Headers["Sec-WebSocket-Version"];

	public override IPEndPoint ServerEndPoint => _context.Connection.LocalEndPoint;

	public override IPrincipal User => _context.User;

	public override IPEndPoint UserEndPoint => _context.Connection.RemoteEndPoint;

	public override WebSocket WebSocket => _websocket;

	internal HttpListenerWebSocketContext(WebSocketSharp.Net.HttpListenerContext context, string protocol)
	{
		_context = context;
		_websocket = new WebSocket(this, protocol);
	}

	internal void Close()
	{
		_context.Connection.Close(force: true);
	}

	internal void Close(WebSocketSharp.Net.HttpStatusCode code)
	{
		_context.Response.Close(code);
	}

	public override string ToString()
	{
		return _context.Request.ToString();
	}
}


using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Net;
using System.Net.Security;
using System.Net.Sockets;
using System.Security.Principal;
using System.Text;
using WebSocketSharp;
using WebSocketSharp.Net;
using WebSocketSharp.Net.WebSockets;

internal class TcpListenerWebSocketContext : WebSocketContext
{
	private WebSocketSharp.Net.CookieCollection _cookies;

	private Logger _logger;

	private NameValueCollection _queryString;

	private HttpRequest _request;

	private bool _secure;

	private Stream _stream;

	private TcpClient _tcpClient;

	private Uri _uri;

	private IPrincipal _user;

	private WebSocket _websocket;

	internal Logger Log => _logger;

	internal Stream Stream => _stream;

	public override WebSocketSharp.Net.CookieCollection CookieCollection => _cookies ?? (_cookies = _request.Cookies);

	public override NameValueCollection Headers => _request.Headers;

	public override string Host => _request.Headers["Host"];

	public override bool IsAuthenticated => _user != null;

	public override bool IsLocal => UserEndPoint.Address.IsLocal();

	public override bool IsSecureConnection => _secure;

	public override bool IsWebSocketRequest => _request.IsWebSocketRequest;

	public override string Origin => _request.Headers["Origin"];

	public override NameValueCollection QueryString => _queryString ?? (_queryString = HttpUtility.InternalParseQueryString((_uri != null) ? _uri.Query : null, Encoding.UTF8));

	public override Uri RequestUri => _uri;

	public override string SecWebSocketKey => _request.Headers["Sec-WebSocket-Key"];

	public override IEnumerable<string> SecWebSocketProtocols
	{
		get
		{
			string protocols = _request.Headers["Sec-WebSocket-Protocol"];
			if (protocols != null)
			{
				string[] array = protocols.Split(new char[1] { ',' });
				foreach (string protocol in array)
				{
					yield return protocol.Trim();
				}
			}
		}
	}

	public override string SecWebSocketVersion => _request.Headers["Sec-WebSocket-Version"];

	public override IPEndPoint ServerEndPoint => (IPEndPoint)_tcpClient.Client.LocalEndPoint;

	public override IPrincipal User => _user;

	public override IPEndPoint UserEndPoint => (IPEndPoint)_tcpClient.Client.RemoteEndPoint;

	public override WebSocket WebSocket => _websocket;

	internal TcpListenerWebSocketContext(TcpClient tcpClient, string protocol, bool secure, ServerSslConfiguration sslConfig, Logger logger)
	{
		_tcpClient = tcpClient;
		_secure = secure;
		_logger = logger;
		NetworkStream stream = tcpClient.GetStream();
		if (secure)
		{
			SslStream sslStream = new SslStream(stream, leaveInnerStreamOpen: false, sslConfig.ClientCertificateValidationCallback);
			sslStream.AuthenticateAsServer(sslConfig.ServerCertificate, sslConfig.ClientCertificateRequired, sslConfig.EnabledSslProtocols, sslConfig.CheckCertificateRevocation);
			_stream = sslStream;
		}
		else
		{
			_stream = stream;
		}
		_request = HttpRequest.Read(_stream, 90000);
		_uri = HttpUtility.CreateRequestUrl(_request.RequestUri, _request.Headers["Host"], _request.IsWebSocketRequest, secure);
		_websocket = new WebSocket(this, protocol);
	}

	internal bool Authenticate(WebSocketSharp.Net.AuthenticationSchemes scheme, string realm, Func<IIdentity, WebSocketSharp.Net.NetworkCredential> credentialsFinder)
	{
		if (scheme == WebSocketSharp.Net.AuthenticationSchemes.Anonymous)
		{
			return true;
		}
		if (scheme == WebSocketSharp.Net.AuthenticationSchemes.None)
		{
			Close(WebSocketSharp.Net.HttpStatusCode.Forbidden);
			return false;
		}
		string chal = new AuthenticationChallenge(scheme, realm).ToString();
		int retry = -1;
		Func<bool> auth = null;
		auth = delegate
		{
			retry++;
			if (retry > 99)
			{
				Close(WebSocketSharp.Net.HttpStatusCode.Forbidden);
				return false;
			}
			IPrincipal principal = HttpUtility.CreateUser(_request.Headers["Authorization"], scheme, realm, _request.HttpMethod, credentialsFinder);
			if (principal == null || !principal.Identity.IsAuthenticated)
			{
				SendAuthenticationChallenge(chal);
				return auth();
			}
			_user = principal;
			return true;
		};
		return auth();
	}

	internal void Close()
	{
		_stream.Close();
		_tcpClient.Close();
	}

	internal void Close(WebSocketSharp.Net.HttpStatusCode code)
	{
		_websocket.Close(HttpResponse.CreateCloseResponse(code));
	}

	internal void SendAuthenticationChallenge(string challenge)
	{
		byte[] array = HttpResponse.CreateUnauthorizedResponse(challenge).ToByteArray();
		_stream.Write(array, 0, array.Length);
		_request = HttpRequest.Read(_stream, 15000);
	}

	public override string ToString()
	{
		return _request.ToString();
	}
}


using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Net;
using System.Security.Principal;
using WebSocketSharp;
using WebSocketSharp.Net;

public abstract class WebSocketContext
{
	public abstract WebSocketSharp.Net.CookieCollection CookieCollection { get; }

	public abstract NameValueCollection Headers { get; }

	public abstract string Host { get; }

	public abstract bool IsAuthenticated { get; }

	public abstract bool IsLocal { get; }

	public abstract bool IsSecureConnection { get; }

	public abstract bool IsWebSocketRequest { get; }

	public abstract string Origin { get; }

	public abstract NameValueCollection QueryString { get; }

	public abstract Uri RequestUri { get; }

	public abstract string SecWebSocketKey { get; }

	public abstract IEnumerable<string> SecWebSocketProtocols { get; }

	public abstract string SecWebSocketVersion { get; }

	public abstract IPEndPoint ServerEndPoint { get; }

	public abstract IPrincipal User { get; }

	public abstract IPEndPoint UserEndPoint { get; }

	public abstract WebSocket WebSocket { get; }
}


using System;
using System.Net;
using System.Net.Sockets;
using System.Security.Principal;
using System.Threading;
using WebSocketSharp;
using WebSocketSharp.Net;
using WebSocketSharp.Net.WebSockets;
using WebSocketSharp.Server;

public class WebSocketServer
{
	private IPAddress _address;

	private WebSocketSharp.Net.AuthenticationSchemes _authSchemes;

	private static readonly string _defaultRealm;

	private bool _dnsStyle;

	private string _hostname;

	private TcpListener _listener;

	private Logger _logger;

	private int _port;

	private string _realm;

	private Thread _receiveThread;

	private bool _reuseAddress;

	private bool _secure;

	private WebSocketServiceManager _services;

	private ServerSslConfiguration _sslConfig;

	private volatile ServerState _state;

	private object _sync;

	private Func<IIdentity, WebSocketSharp.Net.NetworkCredential> _userCredFinder;

	public IPAddress Address => _address;

	public WebSocketSharp.Net.AuthenticationSchemes AuthenticationSchemes
	{
		get
		{
			return _authSchemes;
		}
		set
		{
			string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
			if (text != null)
			{
				_logger.Error(text);
			}
			else
			{
				_authSchemes = value;
			}
		}
	}

	public bool IsListening => _state == ServerState.Start;

	public bool IsSecure => _secure;

	public bool KeepClean
	{
		get
		{
			return _services.KeepClean;
		}
		set
		{
			string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
			if (text != null)
			{
				_logger.Error(text);
			}
			else
			{
				_services.KeepClean = value;
			}
		}
	}

	public Logger Log => _logger;

	public int Port => _port;

	public string Realm
	{
		get
		{
			return _realm;
		}
		set
		{
			string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
			if (text != null)
			{
				_logger.Error(text);
			}
			else
			{
				_realm = value;
			}
		}
	}

	public bool ReuseAddress
	{
		get
		{
			return _reuseAddress;
		}
		set
		{
			string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
			if (text != null)
			{
				_logger.Error(text);
			}
			else
			{
				_reuseAddress = value;
			}
		}
	}

	public ServerSslConfiguration SslConfiguration
	{
		get
		{
			return _sslConfig ?? (_sslConfig = new ServerSslConfiguration(null));
		}
		set
		{
			string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
			if (text != null)
			{
				_logger.Error(text);
			}
			else
			{
				_sslConfig = value;
			}
		}
	}

	public Func<IIdentity, WebSocketSharp.Net.NetworkCredential> UserCredentialsFinder
	{
		get
		{
			return _userCredFinder;
		}
		set
		{
			string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
			if (text != null)
			{
				_logger.Error(text);
			}
			else
			{
				_userCredFinder = value;
			}
		}
	}

	public TimeSpan WaitTime
	{
		get
		{
			return _services.WaitTime;
		}
		set
		{
			string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false) ?? value.CheckIfValidWaitTime();
			if (text != null)
			{
				_logger.Error(text);
			}
			else
			{
				_services.WaitTime = value;
			}
		}
	}

	public WebSocketServiceManager WebSocketServices => _services;

	static WebSocketServer()
	{
		_defaultRealm = "SECRET AREA";
	}

	public WebSocketServer()
	{
		init(null, IPAddress.Any, 80, secure: false);
	}

	public WebSocketServer(int port)
		: this(port, port == 443)
	{
	}

	public WebSocketServer(string url)
	{
		if (url == null)
		{
			throw new ArgumentNullException("url");
		}
		if (url.Length == 0)
		{
			throw new ArgumentException("An empty string.", "url");
		}
		if (!tryCreateUri(url, out var result, out var message))
		{
			throw new ArgumentException(message, "url");
		}
		string dnsSafeHost = result.DnsSafeHost;
		IPAddress address = dnsSafeHost.ToIPAddress();
		if (!address.IsLocal())
		{
			throw new ArgumentException("The host part isn't a local host name: " + url, "url");
		}
		init(dnsSafeHost, address, result.Port, result.Scheme == "wss");
	}

	public WebSocketServer(int port, bool secure)
	{
		if (!port.IsPortNumber())
		{
			throw new ArgumentOutOfRangeException("port", "Not between 1 and 65535 inclusive: " + port);
		}
		init(null, IPAddress.Any, port, secure);
	}

	public WebSocketServer(IPAddress address, int port)
		: this(address, port, port == 443)
	{
	}

	public WebSocketServer(IPAddress address, int port, bool secure)
	{
		if (address == null)
		{
			throw new ArgumentNullException("address");
		}
		if (!address.IsLocal())
		{
			throw new ArgumentException("Not a local IP address: " + address, "address");
		}
		if (!port.IsPortNumber())
		{
			throw new ArgumentOutOfRangeException("port", "Not between 1 and 65535 inclusive: " + port);
		}
		init(null, address, port, secure);
	}

	private void abort()
	{
		lock (_sync)
		{
			if (!IsListening)
			{
				return;
			}
			_state = ServerState.ShuttingDown;
		}
		_listener.Stop();
		_services.Stop(new CloseEventArgs(CloseStatusCode.ServerError), send: true, receive: false);
		_state = ServerState.Stop;
	}

	private bool checkIfAvailable(bool ready, bool start, bool shutting, bool stop, out string message)
	{
		message = null;
		if (!ready && _state == ServerState.Ready)
		{
			message = "This operation is not available in: ready";
			return false;
		}
		if (!start && _state == ServerState.Start)
		{
			message = "This operation is not available in: start";
			return false;
		}
		if (!shutting && _state == ServerState.ShuttingDown)
		{
			message = "This operation is not available in: shutting down";
			return false;
		}
		if (!stop && _state == ServerState.Stop)
		{
			message = "This operation is not available in: stop";
			return false;
		}
		return true;
	}

	private string checkIfCertificateExists()
	{
		return (_secure && (_sslConfig == null || _sslConfig.ServerCertificate == null)) ? "The secure connection requires a server certificate." : null;
	}

	private string getRealm()
	{
		string realm = _realm;
		return (realm != null && realm.Length > 0) ? realm : _defaultRealm;
	}

	private void init(string hostname, IPAddress address, int port, bool secure)
	{
		_hostname = hostname ?? address.ToString();
		_address = address;
		_port = port;
		_secure = secure;
		_authSchemes = WebSocketSharp.Net.AuthenticationSchemes.Anonymous;
		_dnsStyle = Uri.CheckHostName(hostname) == UriHostNameType.Dns;
		_listener = new TcpListener(address, port);
		_logger = new Logger();
		_services = new WebSocketServiceManager(_logger);
		_sync = new object();
	}

	private void processRequest(TcpListenerWebSocketContext context)
	{
		Uri requestUri = context.RequestUri;
		if (requestUri == null || requestUri.Port != _port)
		{
			context.Close(WebSocketSharp.Net.HttpStatusCode.BadRequest);
			return;
		}
		if (_dnsStyle)
		{
			string dnsSafeHost = requestUri.DnsSafeHost;
			if (Uri.CheckHostName(dnsSafeHost) == UriHostNameType.Dns && dnsSafeHost != _hostname)
			{
				context.Close(WebSocketSharp.Net.HttpStatusCode.NotFound);
				return;
			}
		}
		if (!_services.InternalTryGetServiceHost(requestUri.AbsolutePath, out var host))
		{
			context.Close(WebSocketSharp.Net.HttpStatusCode.NotImplemented);
		}
		else
		{
			host.StartSession(context);
		}
	}

	private void receiveRequest()
	{
		while (true)
		{
			try
			{
				TcpClient cl = _listener.AcceptTcpClient();
				ThreadPool.QueueUserWorkItem(delegate
				{
					try
					{
						TcpListenerWebSocketContext webSocketContext = cl.GetWebSocketContext(null, _secure, _sslConfig, _logger);
						if (webSocketContext.Authenticate(_authSchemes, getRealm(), _userCredFinder))
						{
							processRequest(webSocketContext);
						}
					}
					catch (Exception ex)
					{
						_logger.Fatal(ex.ToString());
						cl.Close();
					}
				});
			}
			catch (SocketException ex2)
			{
				_logger.Warn("Receiving has been stopped.\n  reason: " + ex2.Message);
				break;
			}
			catch (Exception ex3)
			{
				_logger.Fatal(ex3.ToString());
				break;
			}
		}
		if (IsListening)
		{
			abort();
		}
	}

	private void startReceiving()
	{
		if (_reuseAddress)
		{
			_listener.Server.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, optionValue: true);
		}
		_listener.Start();
		_receiveThread = new Thread(receiveRequest);
		_receiveThread.IsBackground = true;
		_receiveThread.Start();
	}

	private void stopReceiving(int millisecondsTimeout)
	{
		_listener.Stop();
		_receiveThread.Join(millisecondsTimeout);
	}

	private static bool tryCreateUri(string uriString, out Uri result, out string message)
	{
		if (!uriString.TryCreateWebSocketUri(out result, out message))
		{
			return false;
		}
		if (result.PathAndQuery != "/")
		{
			result = null;
			message = "Includes the path or query component: " + uriString;
			return false;
		}
		return true;
	}

	public void AddWebSocketService<TBehavior>(string path, Func<TBehavior> initializer) where TBehavior : WebSocketBehavior
	{
		string text = path.CheckIfValidServicePath() ?? ((initializer == null) ? "'initializer' is null." : null);
		if (text != null)
		{
			_logger.Error(text);
		}
		else
		{
			_services.Add(path, initializer);
		}
	}

	public void AddWebSocketService<TBehaviorWithNew>(string path) where TBehaviorWithNew : WebSocketBehavior, new()
	{
		AddWebSocketService(path, () => new TBehaviorWithNew());
	}

	public bool RemoveWebSocketService(string path)
	{
		string text = path.CheckIfValidServicePath();
		if (text != null)
		{
			_logger.Error(text);
			return false;
		}
		return _services.Remove(path);
	}

	public void Start()
	{
		lock (_sync)
		{
			string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false) ?? checkIfCertificateExists();
			if (text != null)
			{
				_logger.Error(text);
				return;
			}
			_services.Start();
			startReceiving();
			_state = ServerState.Start;
		}
	}

	public void Stop()
	{
		if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out var message))
		{
			_logger.Error(message);
			return;
		}
		lock (_sync)
		{
			if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out message))
			{
				_logger.Error(message);
				return;
			}
			_state = ServerState.ShuttingDown;
		}
		stopReceiving(5000);
		_services.Stop(new CloseEventArgs(), send: true, receive: true);
		_state = ServerState.Stop;
	}

	public void Stop(ushort code, string reason)
	{
		if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out var message))
		{
			_logger.Error(message);
			return;
		}
		if (!WebSocket.CheckParametersForClose(code, reason, client: false, out message))
		{
			_logger.Error(message);
			return;
		}
		lock (_sync)
		{
			if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out message))
			{
				_logger.Error(message);
				return;
			}
			_state = ServerState.ShuttingDown;
		}
		stopReceiving(5000);
		if (code == 1005)
		{
			_services.Stop(new CloseEventArgs(), send: true, receive: true);
		}
		else
		{
			bool flag = !code.IsReserved();
			_services.Stop(new CloseEventArgs(code, reason), flag, flag);
		}
		_state = ServerState.Stop;
	}

	public void Stop(CloseStatusCode code, string reason)
	{
		if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out var message))
		{
			_logger.Error(message);
			return;
		}
		if (!WebSocket.CheckParametersForClose(code, reason, client: false, out message))
		{
			_logger.Error(message);
			return;
		}
		lock (_sync)
		{
			if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out message))
			{
				_logger.Error(message);
				return;
			}
			_state = ServerState.ShuttingDown;
		}
		stopReceiving(5000);
		if (code == CloseStatusCode.NoStatus)
		{
			_services.Stop(new CloseEventArgs(), send: true, receive: true);
		}
		else
		{
			bool flag = !code.IsReserved();
			_services.Stop(new CloseEventArgs(code, reason), flag, flag);
		}
		_state = ServerState.Stop;
	}
}


using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Security.Principal;
using System.Threading;
using WebSocketSharp;
using WebSocketSharp.Net;
using WebSocketSharp.Net.WebSockets;
using WebSocketSharp.Server;

public class HttpServer
{
	private IPAddress _address;

	private string _hostname;

	private WebSocketSharp.Net.HttpListener _listener;

	private Logger _logger;

	private int _port;

	private Thread _receiveThread;

	private string _rootPath;

	private bool _secure;

	private WebSocketServiceManager _services;

	private volatile ServerState _state;

	private object _sync;

	private bool _windows;

	public IPAddress Address => _address;

	public WebSocketSharp.Net.AuthenticationSchemes AuthenticationSchemes
	{
		get
		{
			return _listener.AuthenticationSchemes;
		}
		set
		{
			string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
			if (text != null)
			{
				_logger.Error(text);
			}
			else
			{
				_listener.AuthenticationSchemes = value;
			}
		}
	}

	public bool IsListening => _state == ServerState.Start;

	public bool IsSecure => _secure;

	public bool KeepClean
	{
		get
		{
			return _services.KeepClean;
		}
		set
		{
			string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
			if (text != null)
			{
				_logger.Error(text);
			}
			else
			{
				_services.KeepClean = value;
			}
		}
	}

	public Logger Log => _logger;

	public int Port => _port;

	public string Realm
	{
		get
		{
			return _listener.Realm;
		}
		set
		{
			string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
			if (text != null)
			{
				_logger.Error(text);
			}
			else
			{
				_listener.Realm = value;
			}
		}
	}

	public bool ReuseAddress
	{
		get
		{
			return _listener.ReuseAddress;
		}
		set
		{
			string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
			if (text != null)
			{
				_logger.Error(text);
			}
			else
			{
				_listener.ReuseAddress = value;
			}
		}
	}

	public string RootPath
	{
		get
		{
			return (_rootPath != null && _rootPath.Length > 0) ? _rootPath : (_rootPath = "./Public");
		}
		set
		{
			string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
			if (text != null)
			{
				_logger.Error(text);
			}
			else
			{
				_rootPath = value;
			}
		}
	}

	public ServerSslConfiguration SslConfiguration
	{
		get
		{
			return _listener.SslConfiguration;
		}
		set
		{
			string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
			if (text != null)
			{
				_logger.Error(text);
			}
			else
			{
				_listener.SslConfiguration = value;
			}
		}
	}

	public Func<IIdentity, WebSocketSharp.Net.NetworkCredential> UserCredentialsFinder
	{
		get
		{
			return _listener.UserCredentialsFinder;
		}
		set
		{
			string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
			if (text != null)
			{
				_logger.Error(text);
			}
			else
			{
				_listener.UserCredentialsFinder = value;
			}
		}
	}

	public TimeSpan WaitTime
	{
		get
		{
			return _services.WaitTime;
		}
		set
		{
			string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false) ?? value.CheckIfValidWaitTime();
			if (text != null)
			{
				_logger.Error(text);
			}
			else
			{
				_services.WaitTime = value;
			}
		}
	}

	public WebSocketServiceManager WebSocketServices => _services;

	public event EventHandler<HttpRequestEventArgs> OnConnect;

	public event EventHandler<HttpRequestEventArgs> OnDelete;

	public event EventHandler<HttpRequestEventArgs> OnGet;

	public event EventHandler<HttpRequestEventArgs> OnHead;

	public event EventHandler<HttpRequestEventArgs> OnOptions;

	public event EventHandler<HttpRequestEventArgs> OnPatch;

	public event EventHandler<HttpRequestEventArgs> OnPost;

	public event EventHandler<HttpRequestEventArgs> OnPut;

	public event EventHandler<HttpRequestEventArgs> OnTrace;

	public HttpServer()
	{
		init("*", IPAddress.Any, 80, secure: false);
	}

	public HttpServer(int port)
		: this(port, port == 443)
	{
	}

	public HttpServer(string url)
	{
		if (url == null)
		{
			throw new ArgumentNullException("url");
		}
		if (url.Length == 0)
		{
			throw new ArgumentException("An empty string.", "url");
		}
		if (!tryCreateUri(url, out var result, out var message))
		{
			throw new ArgumentException(message, "url");
		}
		string host = getHost(result);
		IPAddress address = host.ToIPAddress();
		if (!address.IsLocal())
		{
			throw new ArgumentException("The host part isn't a local host name: " + url, "url");
		}
		init(host, address, result.Port, result.Scheme == "https");
	}

	public HttpServer(int port, bool secure)
	{
		if (!port.IsPortNumber())
		{
			throw new ArgumentOutOfRangeException("port", "Not between 1 and 65535 inclusive: " + port);
		}
		init("*", IPAddress.Any, port, secure);
	}

	public HttpServer(IPAddress address, int port)
		: this(address, port, port == 443)
	{
	}

	public HttpServer(IPAddress address, int port, bool secure)
	{
		if (address == null)
		{
			throw new ArgumentNullException("address");
		}
		if (!address.IsLocal())
		{
			throw new ArgumentException("Not a local IP address: " + address, "address");
		}
		if (!port.IsPortNumber())
		{
			throw new ArgumentOutOfRangeException("port", "Not between 1 and 65535 inclusive: " + port);
		}
		init(null, address, port, secure);
	}

	private void abort()
	{
		lock (_sync)
		{
			if (!IsListening)
			{
				return;
			}
			_state = ServerState.ShuttingDown;
		}
		_services.Stop(new CloseEventArgs(CloseStatusCode.ServerError), send: true, receive: false);
		_listener.Abort();
		_state = ServerState.Stop;
	}

	private bool checkIfAvailable(bool ready, bool start, bool shutting, bool stop, out string message)
	{
		message = null;
		if (!ready && _state == ServerState.Ready)
		{
			message = "This operation is not available in: ready";
			return false;
		}
		if (!start && _state == ServerState.Start)
		{
			message = "This operation is not available in: start";
			return false;
		}
		if (!shutting && _state == ServerState.ShuttingDown)
		{
			message = "This operation is not available in: shutting down";
			return false;
		}
		if (!stop && _state == ServerState.Stop)
		{
			message = "This operation is not available in: stop";
			return false;
		}
		return true;
	}

	private string checkIfCertificateExists()
	{
		if (!_secure)
		{
			return null;
		}
		bool flag = _listener.SslConfiguration.ServerCertificate != null;
		bool flag2 = EndPointListener.CertificateExists(_port, _listener.CertificateFolderPath);
		if (flag && flag2)
		{
			_logger.Warn("The server certificate associated with the port number already exists.");
			return null;
		}
		return (!(flag || flag2)) ? "The secure connection requires a server certificate." : null;
	}

	private static string convertToString(IPAddress address)
	{
		return (address.AddressFamily == AddressFamily.InterNetworkV6) ? $"[{address.ToString()}]" : address.ToString();
	}

	private static string getHost(Uri uri)
	{
		return (uri.HostNameType == UriHostNameType.IPv6) ? uri.Host : uri.DnsSafeHost;
	}

	private void init(string hostname, IPAddress address, int port, bool secure)
	{
		_hostname = hostname ?? convertToString(address);
		_address = address;
		_port = port;
		_secure = secure;
		_listener = new WebSocketSharp.Net.HttpListener();
		_listener.Prefixes.Add(string.Format("http{0}://{1}:{2}/", secure ? "s" : "", _hostname, port));
		_logger = _listener.Log;
		_services = new WebSocketServiceManager(_logger);
		_sync = new object();
		OperatingSystem oSVersion = Environment.OSVersion;
		_windows = oSVersion.Platform != PlatformID.Unix && oSVersion.Platform != PlatformID.MacOSX;
	}

	private void processRequest(WebSocketSharp.Net.HttpListenerContext context)
	{
		EventHandler<HttpRequestEventArgs> eventHandler = context.Request.HttpMethod switch
		{
			"PATCH" => this.OnPatch, 
			"CONNECT" => this.OnConnect, 
			"TRACE" => this.OnTrace, 
			"OPTIONS" => this.OnOptions, 
			"DELETE" => this.OnDelete, 
			"PUT" => this.OnPut, 
			"POST" => this.OnPost, 
			"HEAD" => this.OnHead, 
			"GET" => this.OnGet, 
			_ => null, 
		};
		if (eventHandler != null)
		{
			eventHandler(this, new HttpRequestEventArgs(context));
		}
		else
		{
			context.Response.StatusCode = 501;
		}
		context.Response.Close();
	}

	private void processRequest(HttpListenerWebSocketContext context)
	{
		if (!_services.InternalTryGetServiceHost(context.RequestUri.AbsolutePath, out var host))
		{
			context.Close(WebSocketSharp.Net.HttpStatusCode.NotImplemented);
		}
		else
		{
			host.StartSession(context);
		}
	}

	private void receiveRequest()
	{
		while (true)
		{
			try
			{
				WebSocketSharp.Net.HttpListenerContext ctx = _listener.GetContext();
				ThreadPool.QueueUserWorkItem(delegate
				{
					try
					{
						if (ctx.Request.IsUpgradeTo("websocket"))
						{
							processRequest(ctx.AcceptWebSocket(null));
						}
						else
						{
							processRequest(ctx);
						}
					}
					catch (Exception ex)
					{
						_logger.Fatal(ex.ToString());
						ctx.Connection.Close(force: true);
					}
				});
			}
			catch (WebSocketSharp.Net.HttpListenerException ex2)
			{
				_logger.Warn("Receiving has been stopped.\n  reason: " + ex2.Message);
				break;
			}
			catch (Exception ex3)
			{
				_logger.Fatal(ex3.ToString());
				break;
			}
		}
		if (IsListening)
		{
			abort();
		}
	}

	private void startReceiving()
	{
		_listener.Start();
		_receiveThread = new Thread(receiveRequest);
		_receiveThread.IsBackground = true;
		_receiveThread.Start();
	}

	private void stopReceiving(int millisecondsTimeout)
	{
		_listener.Close();
		_receiveThread.Join(millisecondsTimeout);
	}

	private static bool tryCreateUri(string uriString, out Uri result, out string message)
	{
		result = null;
		Uri uri = uriString.ToUri();
		if (uri == null)
		{
			message = "An invalid URI string: " + uriString;
			return false;
		}
		if (!uri.IsAbsoluteUri)
		{
			message = "Not an absolute URI: " + uriString;
			return false;
		}
		string scheme = uri.Scheme;
		if (!(scheme == "http") && !(scheme == "https"))
		{
			message = "The scheme part isn't 'http' or 'https': " + uriString;
			return false;
		}
		if (uri.PathAndQuery != "/")
		{
			message = "Includes the path or query component: " + uriString;
			return false;
		}
		if (uri.Fragment.Length > 0)
		{
			message = "Includes the fragment component: " + uriString;
			return false;
		}
		if (uri.Port == 0)
		{
			message = "The port part is zero: " + uriString;
			return false;
		}
		result = uri;
		message = string.Empty;
		return true;
	}

	public void AddWebSocketService<TBehavior>(string path, Func<TBehavior> initializer) where TBehavior : WebSocketBehavior
	{
		string text = path.CheckIfValidServicePath() ?? ((initializer == null) ? "'initializer' is null." : null);
		if (text != null)
		{
			_logger.Error(text);
		}
		else
		{
			_services.Add(path, initializer);
		}
	}

	public void AddWebSocketService<TBehaviorWithNew>(string path) where TBehaviorWithNew : WebSocketBehavior, new()
	{
		AddWebSocketService(path, () => new TBehaviorWithNew());
	}

	public byte[] GetFile(string path)
	{
		path = RootPath + path;
		if (_windows)
		{
			path = path.Replace("/", "\\");
		}
		return File.Exists(path) ? File.ReadAllBytes(path) : null;
	}

	public bool RemoveWebSocketService(string path)
	{
		string text = path.CheckIfValidServicePath();
		if (text != null)
		{
			_logger.Error(text);
			return false;
		}
		return _services.Remove(path);
	}

	public void Start()
	{
		lock (_sync)
		{
			string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false) ?? checkIfCertificateExists();
			if (text != null)
			{
				_logger.Error(text);
				return;
			}
			_services.Start();
			startReceiving();
			_state = ServerState.Start;
		}
	}

	public void Stop()
	{
		if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out var message))
		{
			_logger.Error(message);
			return;
		}
		lock (_sync)
		{
			if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out message))
			{
				_logger.Error(message);
				return;
			}
			_state = ServerState.ShuttingDown;
		}
		_services.Stop(new CloseEventArgs(), send: true, receive: true);
		stopReceiving(5000);
		_state = ServerState.Stop;
	}

	public void Stop(ushort code, string reason)
	{
		if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out var message))
		{
			_logger.Error(message);
			return;
		}
		if (!WebSocket.CheckParametersForClose(code, reason, client: false, out message))
		{
			_logger.Error(message);
			return;
		}
		lock (_sync)
		{
			if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out message))
			{
				_logger.Error(message);
				return;
			}
			_state = ServerState.ShuttingDown;
		}
		if (code == 1005)
		{
			_services.Stop(new CloseEventArgs(), send: true, receive: true);
		}
		else
		{
			bool flag = !code.IsReserved();
			_services.Stop(new CloseEventArgs(code, reason), flag, flag);
		}
		stopReceiving(5000);
		_state = ServerState.Stop;
	}

	public void Stop(CloseStatusCode code, string reason)
	{
		if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out var message))
		{
			_logger.Error(message);
			return;
		}
		if (!WebSocket.CheckParametersForClose(code, reason, client: false, out message))
		{
			_logger.Error(message);
			return;
		}
		lock (_sync)
		{
			if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out message))
			{
				_logger.Error(message);
				return;
			}
			_state = ServerState.ShuttingDown;
		}
		if (code == CloseStatusCode.NoStatus)
		{
			_services.Stop(new CloseEventArgs(), send: true, receive: true);
		}
		else
		{
			bool flag = !code.IsReserved();
			_services.Stop(new CloseEventArgs(code, reason), flag, flag);
		}
		stopReceiving(5000);
		_state = ServerState.Stop;
	}
}


using System;
using WebSocketSharp;
using WebSocketSharp.Net.WebSockets;
using WebSocketSharp.Server;

public abstract class WebSocketServiceHost
{
	internal ServerState State => Sessions.State;

	public abstract bool KeepClean { get; set; }

	public abstract string Path { get; }

	public abstract WebSocketSessionManager Sessions { get; }

	public abstract Type Type { get; }

	public abstract TimeSpan WaitTime { get; set; }

	internal void Start()
	{
		Sessions.Start();
	}

	internal void StartSession(WebSocketContext context)
	{
		CreateSession().Start(context, Sessions);
	}

	internal void Stop(ushort code, string reason)
	{
		CloseEventArgs closeEventArgs = new CloseEventArgs(code, reason);
		bool flag = !code.IsReserved();
		byte[] frameAsBytes = (flag ? WebSocketFrame.CreateCloseFrame(closeEventArgs.PayloadData, mask: false).ToArray() : null);
		Sessions.Stop(closeEventArgs, frameAsBytes, flag);
	}

	protected abstract WebSocketBehavior CreateSession();
}


using System;
using WebSocketSharp.Net;

public class HttpRequestEventArgs : EventArgs
{
	private HttpListenerRequest _request;

	private HttpListenerResponse _response;

	public HttpListenerRequest Request => _request;

	public HttpListenerResponse Response => _response;

	internal HttpRequestEventArgs(HttpListenerContext context)
	{
		_request = context.Request;
		_response = context.Response;
	}
}


using System;
using WebSocketSharp;
using WebSocketSharp.Net.WebSockets;

public interface IWebSocketSession
{
	WebSocketContext Context { get; }

	string ID { get; }

	string Protocol { get; }

	DateTime StartTime { get; }

	WebSocketState State { get; }
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Timers;
using WebSocketSharp;
using WebSocketSharp.Server;

public class WebSocketSessionManager
{
	private volatile bool _clean;

	private object _forSweep;

	private Logger _logger;

	private Dictionary<string, IWebSocketSession> _sessions;

	private volatile ServerState _state;

	private volatile bool _sweeping;

	private System.Timers.Timer _sweepTimer;

	private object _sync;

	private TimeSpan _waitTime;

	internal ServerState State => _state;

	public IEnumerable<string> ActiveIDs
	{
		get
		{
			foreach (KeyValuePair<string, bool> res in Broadping(WebSocketFrame.EmptyPingBytes, _waitTime))
			{
				if (res.Value)
				{
					yield return res.Key;
				}
			}
		}
	}

	public int Count
	{
		get
		{
			lock (_sync)
			{
				return _sessions.Count;
			}
		}
	}

	public IEnumerable<string> IDs
	{
		get
		{
			if (_state == ServerState.ShuttingDown)
			{
				return new string[0];
			}
			lock (_sync)
			{
				return _sessions.Keys.ToList();
			}
		}
	}

	public IEnumerable<string> InactiveIDs
	{
		get
		{
			foreach (KeyValuePair<string, bool> res in Broadping(WebSocketFrame.EmptyPingBytes, _waitTime))
			{
				if (!res.Value)
				{
					yield return res.Key;
				}
			}
		}
	}

	public IWebSocketSession this[string id]
	{
		get
		{
			TryGetSession(id, out var session);
			return session;
		}
	}

	public bool KeepClean
	{
		get
		{
			return _clean;
		}
		internal set
		{
			if (value != _clean)
			{
				_clean = value;
				if (_state == ServerState.Start)
				{
					_sweepTimer.Enabled = value;
				}
			}
		}
	}

	public IEnumerable<IWebSocketSession> Sessions
	{
		get
		{
			if (_state == ServerState.ShuttingDown)
			{
				return new IWebSocketSession[0];
			}
			lock (_sync)
			{
				return _sessions.Values.ToList();
			}
		}
	}

	public TimeSpan WaitTime
	{
		get
		{
			return _waitTime;
		}
		internal set
		{
			if (value == _waitTime)
			{
				return;
			}
			_waitTime = value;
			foreach (IWebSocketSession session in Sessions)
			{
				session.Context.WebSocket.WaitTime = value;
			}
		}
	}

	internal WebSocketSessionManager()
		: this(new Logger())
	{
	}

	internal WebSocketSessionManager(Logger logger)
	{
		_logger = logger;
		_clean = true;
		_forSweep = new object();
		_sessions = new Dictionary<string, IWebSocketSession>();
		_state = ServerState.Ready;
		_sync = ((ICollection)_sessions).SyncRoot;
		_waitTime = TimeSpan.FromSeconds(1.0);
		setSweepTimer(60000.0);
	}

	private void broadcast(Opcode opcode, byte[] data, Action completed)
	{
		Dictionary<CompressionMethod, byte[]> dictionary = new Dictionary<CompressionMethod, byte[]>();
		try
		{
			Broadcast(opcode, data, dictionary);
			completed?.Invoke();
		}
		catch (Exception ex)
		{
			_logger.Fatal(ex.ToString());
		}
		finally
		{
			dictionary.Clear();
		}
	}

	private void broadcast(Opcode opcode, Stream stream, Action completed)
	{
		Dictionary<CompressionMethod, Stream> dictionary = new Dictionary<CompressionMethod, Stream>();
		try
		{
			Broadcast(opcode, stream, dictionary);
			completed?.Invoke();
		}
		catch (Exception ex)
		{
			_logger.Fatal(ex.ToString());
		}
		finally
		{
			foreach (Stream value in dictionary.Values)
			{
				value.Dispose();
			}
			dictionary.Clear();
		}
	}

	private void broadcastAsync(Opcode opcode, byte[] data, Action completed)
	{
		ThreadPool.QueueUserWorkItem(delegate
		{
			broadcast(opcode, data, completed);
		});
	}

	private void broadcastAsync(Opcode opcode, Stream stream, Action completed)
	{
		ThreadPool.QueueUserWorkItem(delegate
		{
			broadcast(opcode, stream, completed);
		});
	}

	private static string createID()
	{
		return Guid.NewGuid().ToString("N");
	}

	private void setSweepTimer(double interval)
	{
		_sweepTimer = new System.Timers.Timer(interval);
		_sweepTimer.Elapsed += delegate
		{
			Sweep();
		};
	}

	private bool tryGetSession(string id, out IWebSocketSession session)
	{
		bool flag;
		lock (_sync)
		{
			flag = _sessions.TryGetValue(id, out session);
		}
		if (!flag)
		{
			_logger.Error("A session with the specified ID isn't found:\n  ID: " + id);
		}
		return flag;
	}

	internal string Add(IWebSocketSession session)
	{
		lock (_sync)
		{
			if (_state != ServerState.Start)
			{
				return null;
			}
			string text = createID();
			_sessions.Add(text, session);
			return text;
		}
	}

	internal void Broadcast(Opcode opcode, byte[] data, Dictionary<CompressionMethod, byte[]> cache)
	{
		foreach (IWebSocketSession session in Sessions)
		{
			if (_state != ServerState.Start)
			{
				break;
			}
			session.Context.WebSocket.Send(opcode, data, cache);
		}
	}

	internal void Broadcast(Opcode opcode, Stream stream, Dictionary<CompressionMethod, Stream> cache)
	{
		foreach (IWebSocketSession session in Sessions)
		{
			if (_state != ServerState.Start)
			{
				break;
			}
			session.Context.WebSocket.Send(opcode, stream, cache);
		}
	}

	internal Dictionary<string, bool> Broadping(byte[] frameAsBytes, TimeSpan timeout)
	{
		Dictionary<string, bool> dictionary = new Dictionary<string, bool>();
		foreach (IWebSocketSession session in Sessions)
		{
			if (_state != ServerState.Start)
			{
				break;
			}
			dictionary.Add(session.ID, session.Context.WebSocket.Ping(frameAsBytes, timeout));
		}
		return dictionary;
	}

	internal bool Remove(string id)
	{
		lock (_sync)
		{
			return _sessions.Remove(id);
		}
	}

	internal void Start()
	{
		lock (_sync)
		{
			_sweepTimer.Enabled = _clean;
			_state = ServerState.Start;
		}
	}

	internal void Stop(CloseEventArgs e, byte[] frameAsBytes, bool receive)
	{
		lock (_sync)
		{
			_state = ServerState.ShuttingDown;
			_sweepTimer.Enabled = false;
			foreach (IWebSocketSession item in _sessions.Values.ToList())
			{
				item.Context.WebSocket.Close(e, frameAsBytes, receive);
			}
			_state = ServerState.Stop;
		}
	}

	public void Broadcast(byte[] data)
	{
		string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckSendParameter(data);
		if (text != null)
		{
			_logger.Error(text);
		}
		else if (data.LongLength <= WebSocket.FragmentLength)
		{
			broadcast(Opcode.Binary, data, null);
		}
		else
		{
			broadcast(Opcode.Binary, new MemoryStream(data), null);
		}
	}

	public void Broadcast(string data)
	{
		string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckSendParameter(data);
		if (text != null)
		{
			_logger.Error(text);
			return;
		}
		byte[] array = data.UTF8Encode();
		if (array.LongLength <= WebSocket.FragmentLength)
		{
			broadcast(Opcode.Text, array, null);
		}
		else
		{
			broadcast(Opcode.Text, new MemoryStream(array), null);
		}
	}

	public void BroadcastAsync(byte[] data, Action completed)
	{
		string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckSendParameter(data);
		if (text != null)
		{
			_logger.Error(text);
		}
		else if (data.LongLength <= WebSocket.FragmentLength)
		{
			broadcastAsync(Opcode.Binary, data, completed);
		}
		else
		{
			broadcastAsync(Opcode.Binary, new MemoryStream(data), completed);
		}
	}

	public void BroadcastAsync(string data, Action completed)
	{
		string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckSendParameter(data);
		if (text != null)
		{
			_logger.Error(text);
			return;
		}
		byte[] array = data.UTF8Encode();
		if (array.LongLength <= WebSocket.FragmentLength)
		{
			broadcastAsync(Opcode.Text, array, completed);
		}
		else
		{
			broadcastAsync(Opcode.Text, new MemoryStream(array), completed);
		}
	}

	public void BroadcastAsync(Stream stream, int length, Action completed)
	{
		string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckSendParameters(stream, length);
		if (text != null)
		{
			_logger.Error(text);
			return;
		}
		stream.ReadBytesAsync(length, delegate(byte[] data)
		{
			int num = data.Length;
			if (num == 0)
			{
				_logger.Error("The data cannot be read from 'stream'.");
			}
			else
			{
				if (num < length)
				{
					_logger.Warn($"The data with 'length' cannot be read from 'stream':\n  expected: {length}\n  actual: {num}");
				}
				if (num <= WebSocket.FragmentLength)
				{
					broadcast(Opcode.Binary, data, completed);
				}
				else
				{
					broadcast(Opcode.Binary, new MemoryStream(data), completed);
				}
			}
		}, delegate(Exception ex)
		{
			_logger.Fatal(ex.ToString());
		});
	}

	public Dictionary<string, bool> Broadping()
	{
		string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false);
		if (text != null)
		{
			_logger.Error(text);
			return null;
		}
		return Broadping(WebSocketFrame.EmptyPingBytes, _waitTime);
	}

	public Dictionary<string, bool> Broadping(string message)
	{
		if (message == null || message.Length == 0)
		{
			return Broadping();
		}
		byte[] bytes = null;
		string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckPingParameter(message, out bytes);
		if (text != null)
		{
			_logger.Error(text);
			return null;
		}
		return Broadping(WebSocketFrame.CreatePingFrame(bytes, mask: false).ToArray(), _waitTime);
	}

	public void CloseSession(string id)
	{
		if (TryGetSession(id, out var session))
		{
			session.Context.WebSocket.Close();
		}
	}

	public void CloseSession(string id, ushort code, string reason)
	{
		if (TryGetSession(id, out var session))
		{
			session.Context.WebSocket.Close(code, reason);
		}
	}

	public void CloseSession(string id, CloseStatusCode code, string reason)
	{
		if (TryGetSession(id, out var session))
		{
			session.Context.WebSocket.Close(code, reason);
		}
	}

	public bool PingTo(string id)
	{
		IWebSocketSession session;
		return TryGetSession(id, out session) && session.Context.WebSocket.Ping();
	}

	public bool PingTo(string message, string id)
	{
		IWebSocketSession session;
		return TryGetSession(id, out session) && session.Context.WebSocket.Ping(message);
	}

	public void SendTo(byte[] data, string id)
	{
		if (TryGetSession(id, out var session))
		{
			session.Context.WebSocket.Send(data);
		}
	}

	public void SendTo(string data, string id)
	{
		if (TryGetSession(id, out var session))
		{
			session.Context.WebSocket.Send(data);
		}
	}

	public void SendToAsync(byte[] data, string id, Action<bool> completed)
	{
		if (TryGetSession(id, out var session))
		{
			session.Context.WebSocket.SendAsync(data, completed);
		}
	}

	public void SendToAsync(string data, string id, Action<bool> completed)
	{
		if (TryGetSession(id, out var session))
		{
			session.Context.WebSocket.SendAsync(data, completed);
		}
	}

	public void SendToAsync(Stream stream, int length, string id, Action<bool> completed)
	{
		if (TryGetSession(id, out var session))
		{
			session.Context.WebSocket.SendAsync(stream, length, completed);
		}
	}

	public void Sweep()
	{
		if (_state != ServerState.Start || _sweeping || Count == 0)
		{
			return;
		}
		lock (_forSweep)
		{
			_sweeping = true;
			foreach (string inactiveID in InactiveIDs)
			{
				if (_state != ServerState.Start)
				{
					break;
				}
				lock (_sync)
				{
					if (_sessions.TryGetValue(inactiveID, out var value))
					{
						switch (value.State)
						{
						case WebSocketState.Open:
							value.Context.WebSocket.Close(CloseStatusCode.ProtocolError);
							break;
						case WebSocketState.Closing:
							break;
						default:
							_sessions.Remove(inactiveID);
							break;
						}
					}
				}
			}
			_sweeping = false;
		}
	}

	public bool TryGetSession(string id, out IWebSocketSession session)
	{
		string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? id.CheckIfValidSessionID();
		if (text != null)
		{
			_logger.Error(text);
			session = null;
			return false;
		}
		return tryGetSession(id, out session);
	}
}


internal enum ServerState
{
	Ready,
	Start,
	ShuttingDown,
	Stop
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using WebSocketSharp;
using WebSocketSharp.Net;
using WebSocketSharp.Server;

public class WebSocketServiceManager
{
	private volatile bool _clean;

	private Dictionary<string, WebSocketServiceHost> _hosts;

	private Logger _logger;

	private volatile ServerState _state;

	private object _sync;

	private TimeSpan _waitTime;

	public int Count
	{
		get
		{
			lock (_sync)
			{
				return _hosts.Count;
			}
		}
	}

	public IEnumerable<WebSocketServiceHost> Hosts
	{
		get
		{
			lock (_sync)
			{
				return _hosts.Values.ToList();
			}
		}
	}

	public WebSocketServiceHost this[string path]
	{
		get
		{
			TryGetServiceHost(path, out var host);
			return host;
		}
	}

	public bool KeepClean
	{
		get
		{
			return _clean;
		}
		internal set
		{
			lock (_sync)
			{
				if (value == _clean)
				{
					return;
				}
				_clean = value;
				foreach (WebSocketServiceHost value2 in _hosts.Values)
				{
					value2.KeepClean = value;
				}
			}
		}
	}

	public IEnumerable<string> Paths
	{
		get
		{
			lock (_sync)
			{
				return _hosts.Keys.ToList();
			}
		}
	}

	public int SessionCount
	{
		get
		{
			int num = 0;
			foreach (WebSocketServiceHost host in Hosts)
			{
				if (_state != ServerState.Start)
				{
					break;
				}
				num += host.Sessions.Count;
			}
			return num;
		}
	}

	public TimeSpan WaitTime
	{
		get
		{
			return _waitTime;
		}
		internal set
		{
			lock (_sync)
			{
				if (value == _waitTime)
				{
					return;
				}
				_waitTime = value;
				foreach (WebSocketServiceHost value2 in _hosts.Values)
				{
					value2.WaitTime = value;
				}
			}
		}
	}

	internal WebSocketServiceManager()
		: this(new Logger())
	{
	}

	internal WebSocketServiceManager(Logger logger)
	{
		_logger = logger;
		_clean = true;
		_hosts = new Dictionary<string, WebSocketServiceHost>();
		_state = ServerState.Ready;
		_sync = ((ICollection)_hosts).SyncRoot;
		_waitTime = TimeSpan.FromSeconds(1.0);
	}

	private void broadcast(Opcode opcode, byte[] data, Action completed)
	{
		Dictionary<CompressionMethod, byte[]> dictionary = new Dictionary<CompressionMethod, byte[]>();
		try
		{
			foreach (WebSocketServiceHost host in Hosts)
			{
				if (_state != ServerState.Start)
				{
					break;
				}
				host.Sessions.Broadcast(opcode, data, dictionary);
			}
			completed?.Invoke();
		}
		catch (Exception ex)
		{
			_logger.Fatal(ex.ToString());
		}
		finally
		{
			dictionary.Clear();
		}
	}

	private void broadcast(Opcode opcode, Stream stream, Action completed)
	{
		Dictionary<CompressionMethod, Stream> dictionary = new Dictionary<CompressionMethod, Stream>();
		try
		{
			foreach (WebSocketServiceHost host in Hosts)
			{
				if (_state != ServerState.Start)
				{
					break;
				}
				host.Sessions.Broadcast(opcode, stream, dictionary);
			}
			completed?.Invoke();
		}
		catch (Exception ex)
		{
			_logger.Fatal(ex.ToString());
		}
		finally
		{
			foreach (Stream value in dictionary.Values)
			{
				value.Dispose();
			}
			dictionary.Clear();
		}
	}

	private void broadcastAsync(Opcode opcode, byte[] data, Action completed)
	{
		ThreadPool.QueueUserWorkItem(delegate
		{
			broadcast(opcode, data, completed);
		});
	}

	private void broadcastAsync(Opcode opcode, Stream stream, Action completed)
	{
		ThreadPool.QueueUserWorkItem(delegate
		{
			broadcast(opcode, stream, completed);
		});
	}

	private Dictionary<string, Dictionary<string, bool>> broadping(byte[] frameAsBytes, TimeSpan timeout)
	{
		Dictionary<string, Dictionary<string, bool>> dictionary = new Dictionary<string, Dictionary<string, bool>>();
		foreach (WebSocketServiceHost host in Hosts)
		{
			if (_state != ServerState.Start)
			{
				break;
			}
			dictionary.Add(host.Path, host.Sessions.Broadping(frameAsBytes, timeout));
		}
		return dictionary;
	}

	internal void Add<TBehavior>(string path, Func<TBehavior> initializer) where TBehavior : WebSocketBehavior
	{
		lock (_sync)
		{
			path = HttpUtility.UrlDecode(path).TrimEndSlash();
			if (_hosts.TryGetValue(path, out var value))
			{
				_logger.Error("A WebSocket service with the specified path already exists:\n  path: " + path);
				return;
			}
			value = new WebSocketServiceHost<TBehavior>(path, initializer, _logger);
			if (!_clean)
			{
				value.KeepClean = false;
			}
			if (_waitTime != value.WaitTime)
			{
				value.WaitTime = _waitTime;
			}
			if (_state == ServerState.Start)
			{
				value.Start();
			}
			_hosts.Add(path, value);
		}
	}

	internal bool InternalTryGetServiceHost(string path, out WebSocketServiceHost host)
	{
		bool flag;
		lock (_sync)
		{
			path = HttpUtility.UrlDecode(path).TrimEndSlash();
			flag = _hosts.TryGetValue(path, out host);
		}
		if (!flag)
		{
			_logger.Error("A WebSocket service with the specified path isn't found:\n  path: " + path);
		}
		return flag;
	}

	internal bool Remove(string path)
	{
		WebSocketServiceHost value;
		lock (_sync)
		{
			path = HttpUtility.UrlDecode(path).TrimEndSlash();
			if (!_hosts.TryGetValue(path, out value))
			{
				_logger.Error("A WebSocket service with the specified path isn't found:\n  path: " + path);
				return false;
			}
			_hosts.Remove(path);
		}
		if (value.State == ServerState.Start)
		{
			value.Stop(1001, null);
		}
		return true;
	}

	internal void Start()
	{
		lock (_sync)
		{
			foreach (WebSocketServiceHost value in _hosts.Values)
			{
				value.Start();
			}
			_state = ServerState.Start;
		}
	}

	internal void Stop(CloseEventArgs e, bool send, bool receive)
	{
		lock (_sync)
		{
			_state = ServerState.ShuttingDown;
			byte[] frameAsBytes = (send ? WebSocketFrame.CreateCloseFrame(e.PayloadData, mask: false).ToArray() : null);
			foreach (WebSocketServiceHost value in _hosts.Values)
			{
				value.Sessions.Stop(e, frameAsBytes, receive);
			}
			_hosts.Clear();
			_state = ServerState.Stop;
		}
	}

	public void Broadcast(byte[] data)
	{
		string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckSendParameter(data);
		if (text != null)
		{
			_logger.Error(text);
		}
		else if (data.LongLength <= WebSocket.FragmentLength)
		{
			broadcast(Opcode.Binary, data, null);
		}
		else
		{
			broadcast(Opcode.Binary, new MemoryStream(data), null);
		}
	}

	public void Broadcast(string data)
	{
		string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckSendParameter(data);
		if (text != null)
		{
			_logger.Error(text);
			return;
		}
		byte[] array = data.UTF8Encode();
		if (array.LongLength <= WebSocket.FragmentLength)
		{
			broadcast(Opcode.Text, array, null);
		}
		else
		{
			broadcast(Opcode.Text, new MemoryStream(array), null);
		}
	}

	public void BroadcastAsync(byte[] data, Action completed)
	{
		string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckSendParameter(data);
		if (text != null)
		{
			_logger.Error(text);
		}
		else if (data.LongLength <= WebSocket.FragmentLength)
		{
			broadcastAsync(Opcode.Binary, data, completed);
		}
		else
		{
			broadcastAsync(Opcode.Binary, new MemoryStream(data), completed);
		}
	}

	public void BroadcastAsync(string data, Action completed)
	{
		string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckSendParameter(data);
		if (text != null)
		{
			_logger.Error(text);
			return;
		}
		byte[] array = data.UTF8Encode();
		if (array.LongLength <= WebSocket.FragmentLength)
		{
			broadcastAsync(Opcode.Text, array, completed);
		}
		else
		{
			broadcastAsync(Opcode.Text, new MemoryStream(array), completed);
		}
	}

	public void BroadcastAsync(Stream stream, int length, Action completed)
	{
		string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckSendParameters(stream, length);
		if (text != null)
		{
			_logger.Error(text);
			return;
		}
		stream.ReadBytesAsync(length, delegate(byte[] data)
		{
			int num = data.Length;
			if (num == 0)
			{
				_logger.Error("The data cannot be read from 'stream'.");
			}
			else
			{
				if (num < length)
				{
					_logger.Warn($"The data with 'length' cannot be read from 'stream':\n  expected: {length}\n  actual: {num}");
				}
				if (num <= WebSocket.FragmentLength)
				{
					broadcast(Opcode.Binary, data, completed);
				}
				else
				{
					broadcast(Opcode.Binary, new MemoryStream(data), completed);
				}
			}
		}, delegate(Exception ex)
		{
			_logger.Fatal(ex.ToString());
		});
	}

	public Dictionary<string, Dictionary<string, bool>> Broadping()
	{
		string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false);
		if (text != null)
		{
			_logger.Error(text);
			return null;
		}
		return broadping(WebSocketFrame.EmptyPingBytes, _waitTime);
	}

	public Dictionary<string, Dictionary<string, bool>> Broadping(string message)
	{
		if (message == null || message.Length == 0)
		{
			return Broadping();
		}
		byte[] bytes = null;
		string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckPingParameter(message, out bytes);
		if (text != null)
		{
			_logger.Error(text);
			return null;
		}
		return broadping(WebSocketFrame.CreatePingFrame(bytes, mask: false).ToArray(), _waitTime);
	}

	public bool TryGetServiceHost(string path, out WebSocketServiceHost host)
	{
		string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? path.CheckIfValidServicePath();
		if (text != null)
		{
			_logger.Error(text);
			host = null;
			return false;
		}
		return InternalTryGetServiceHost(path, out host);
	}
}


using System;
using System.IO;
using WebSocketSharp;
using WebSocketSharp.Net;
using WebSocketSharp.Net.WebSockets;
using WebSocketSharp.Server;

public abstract class WebSocketBehavior : IWebSocketSession
{
	private WebSocketContext _context;

	private Func<CookieCollection, CookieCollection, bool> _cookiesValidator;

	private bool _emitOnPing;

	private string _id;

	private bool _ignoreExtensions;

	private Func<string, bool> _originValidator;

	private string _protocol;

	private WebSocketSessionManager _sessions;

	private DateTime _startTime;

	private WebSocket _websocket;

	protected Logger Log => (_websocket != null) ? _websocket.Log : null;

	protected WebSocketSessionManager Sessions => _sessions;

	public WebSocketContext Context => _context;

	public Func<CookieCollection, CookieCollection, bool> CookiesValidator
	{
		get
		{
			return _cookiesValidator;
		}
		set
		{
			_cookiesValidator = value;
		}
	}

	public bool EmitOnPing
	{
		get
		{
			return (_websocket != null) ? _websocket.EmitOnPing : _emitOnPing;
		}
		set
		{
			if (_websocket != null)
			{
				_websocket.EmitOnPing = value;
			}
			else
			{
				_emitOnPing = value;
			}
		}
	}

	public string ID => _id;

	public bool IgnoreExtensions
	{
		get
		{
			return _ignoreExtensions;
		}
		set
		{
			_ignoreExtensions = value;
		}
	}

	public Func<string, bool> OriginValidator
	{
		get
		{
			return _originValidator;
		}
		set
		{
			_originValidator = value;
		}
	}

	public string Protocol
	{
		get
		{
			return (_websocket != null) ? _websocket.Protocol : (_protocol ?? string.Empty);
		}
		set
		{
			if (State == WebSocketState.Connecting && (value == null || (value.Length != 0 && value.IsToken())))
			{
				_protocol = value;
			}
		}
	}

	public DateTime StartTime => _startTime;

	public WebSocketState State => (_websocket != null) ? _websocket.ReadyState : WebSocketState.Connecting;

	protected WebSocketBehavior()
	{
		_startTime = DateTime.MaxValue;
	}

	private string checkHandshakeRequest(WebSocketContext context)
	{
		return (_originValidator != null && !_originValidator(context.Origin)) ? "Includes no Origin header, or it has an invalid value." : ((_cookiesValidator != null && !_cookiesValidator(context.CookieCollection, context.WebSocket.CookieCollection)) ? "Includes no cookie, or an invalid cookie exists." : null);
	}

	private void onClose(object sender, CloseEventArgs e)
	{
		if (_id != null)
		{
			_sessions.Remove(_id);
			OnClose(e);
		}
	}

	private void onError(object sender, WebSocketSharp.ErrorEventArgs e)
	{
		OnError(e);
	}

	private void onMessage(object sender, MessageEventArgs e)
	{
		OnMessage(e);
	}

	private void onOpen(object sender, EventArgs e)
	{
		_id = _sessions.Add(this);
		if (_id == null)
		{
			_websocket.Close(CloseStatusCode.Away);
			return;
		}
		_startTime = DateTime.Now;
		OnOpen();
	}

	internal void Start(WebSocketContext context, WebSocketSessionManager sessions)
	{
		if (_websocket != null)
		{
			_websocket.Log.Error("This session has already been started.");
			context.WebSocket.Close(HttpStatusCode.ServiceUnavailable);
			return;
		}
		_context = context;
		_sessions = sessions;
		_websocket = context.WebSocket;
		_websocket.CustomHandshakeRequestChecker = checkHandshakeRequest;
		_websocket.EmitOnPing = _emitOnPing;
		_websocket.IgnoreExtensions = _ignoreExtensions;
		_websocket.Protocol = _protocol;
		TimeSpan waitTime = sessions.WaitTime;
		if (waitTime != _websocket.WaitTime)
		{
			_websocket.WaitTime = waitTime;
		}
		_websocket.OnOpen += onOpen;
		_websocket.OnMessage += onMessage;
		_websocket.OnError += onError;
		_websocket.OnClose += onClose;
		_websocket.InternalAccept();
	}

	protected void Error(string message, Exception exception)
	{
		if (message != null && message.Length > 0)
		{
			OnError(new WebSocketSharp.ErrorEventArgs(message, exception));
		}
	}

	protected virtual void OnClose(CloseEventArgs e)
	{
	}

	protected virtual void OnError(WebSocketSharp.ErrorEventArgs e)
	{
	}

	protected virtual void OnMessage(MessageEventArgs e)
	{
	}

	protected virtual void OnOpen()
	{
	}

	protected void Send(byte[] data)
	{
		if (_websocket != null)
		{
			_websocket.Send(data);
		}
	}

	protected void Send(FileInfo file)
	{
		if (_websocket != null)
		{
			_websocket.Send(file);
		}
	}

	protected void Send(string data)
	{
		if (_websocket != null)
		{
			_websocket.Send(data);
		}
	}

	protected void SendAsync(byte[] data, Action<bool> completed)
	{
		if (_websocket != null)
		{
			_websocket.SendAsync(data, completed);
		}
	}

	protected void SendAsync(FileInfo file, Action<bool> completed)
	{
		if (_websocket != null)
		{
			_websocket.SendAsync(file, completed);
		}
	}

	protected void SendAsync(string data, Action<bool> completed)
	{
		if (_websocket != null)
		{
			_websocket.SendAsync(data, completed);
		}
	}

	protected void SendAsync(Stream stream, int length, Action<bool> completed)
	{
		if (_websocket != null)
		{
			_websocket.SendAsync(stream, length, completed);
		}
	}
}


using System;
using WebSocketSharp;
using WebSocketSharp.Server;

internal class WebSocketServiceHost<TBehavior> : WebSocketServiceHost where TBehavior : WebSocketBehavior
{
	private Func<TBehavior> _initializer;

	private Logger _logger;

	private string _path;

	private WebSocketSessionManager _sessions;

	public override bool KeepClean
	{
		get
		{
			return _sessions.KeepClean;
		}
		set
		{
			string text = _sessions.State.CheckIfAvailable(ready: true, start: false, shutting: false);
			if (text != null)
			{
				_logger.Error(text);
			}
			else
			{
				_sessions.KeepClean = value;
			}
		}
	}

	public override string Path => _path;

	public override WebSocketSessionManager Sessions => _sessions;

	public override Type Type => typeof(TBehavior);

	public override TimeSpan WaitTime
	{
		get
		{
			return _sessions.WaitTime;
		}
		set
		{
			string text = _sessions.State.CheckIfAvailable(ready: true, start: false, shutting: false) ?? value.CheckIfValidWaitTime();
			if (text != null)
			{
				_logger.Error(text);
			}
			else
			{
				_sessions.WaitTime = value;
			}
		}
	}

	internal WebSocketServiceHost(string path, Func<TBehavior> initializer, Logger logger)
	{
		_path = path;
		_initializer = initializer;
		_logger = logger;
		_sessions = new WebSocketSessionManager(logger);
	}

	protected override WebSocketBehavior CreateSession()
	{
		return _initializer();
	}
}


