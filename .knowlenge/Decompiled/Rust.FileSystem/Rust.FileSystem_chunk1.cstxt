using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Facepunch.Extend;
using Rust;
using UnityEngine;
using UnityEngine.SceneManagement;

public class AssetBundleBackend : FileSystemBackend, IDisposable
{
	private AssetBundle rootBundle;

	private AssetBundleManifest manifest;

	private Dictionary<string, AssetBundle> bundles = new Dictionary<string, AssetBundle>(StringComparer.OrdinalIgnoreCase);

	private Dictionary<string, AssetBundle> files = new Dictionary<string, AssetBundle>(StringComparer.OrdinalIgnoreCase);

	private Dictionary<string, string> prefabToAssetSceneName = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

	private Dictionary<string, AsyncOperation> assetSceneLoads = new Dictionary<string, AsyncOperation>(StringComparer.OrdinalIgnoreCase);

	private Dictionary<string, Dictionary<string, GameObject>> assetScenePrefabs = new Dictionary<string, Dictionary<string, GameObject>>(StringComparer.OrdinalIgnoreCase);

	public string assetPath { get; private set; }

	public static bool Enabled => true;

	public void Load(string assetRoot)
	{
		try
		{
			isError = false;
			string? directoryName = Path.GetDirectoryName(assetRoot);
			char directorySeparatorChar = Path.DirectorySeparatorChar;
			assetPath = directoryName + directorySeparatorChar;
			rootBundle = AssetBundle.LoadFromFile(assetRoot);
			if ((Object)(object)rootBundle == (Object)null)
			{
				LoadError("Couldn't load root AssetBundle - " + assetRoot);
				return;
			}
			AssetBundleManifest[] array = rootBundle.LoadAllAssets<AssetBundleManifest>();
			if (array.Length != 1)
			{
				LoadError($"Couldn't find AssetBundleManifest - {array.Length}");
				return;
			}
			manifest = array[0];
			string[] allAssetBundles = manifest.GetAllAssetBundles();
			foreach (string text in allAssetBundles)
			{
				Debug.Log((object)("Loading " + text));
				LoadBundle(text);
			}
			AssetSceneManifest.Load(this);
			prefabToAssetSceneName.Clear();
			foreach (AssetSceneManifest.Entry scene in AssetSceneManifest.Current.Scenes)
			{
				foreach (string includedAsset in scene.IncludedAssets)
				{
					if (!prefabToAssetSceneName.TryAdd(includedAsset, scene.Name))
					{
						Debug.LogError((object)("Duplicate prefab in asset scenes: " + includedAsset));
					}
				}
			}
			foreach (AssetSceneManifest.Entry scene2 in AssetSceneManifest.Current.Scenes)
			{
				if (scene2.AutoLoad)
				{
					((MonoBehaviour)Global.Runner).StartCoroutine(LoadAssetScene(scene2.Name));
				}
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private AssetBundle LoadBundle(string bundleName)
	{
		if (bundles.ContainsKey(bundleName))
		{
			Debug.Log((object)("LoadBundle " + bundleName + " already loaded"));
			return null;
		}
		string text = assetPath + bundleName;
		if (!File.Exists(text))
		{
			return null;
		}
		AssetBundle val = AssetBundle.LoadFromFile(text);
		if ((Object)(object)val == (Object)null)
		{
			LoadError("Couldn't load AssetBundle - " + text);
			return null;
		}
		bundles.Add(bundleName, val);
		return val;
	}

	public void BuildFileIndex()
	{
		files.Clear();
		foreach (KeyValuePair<string, AssetBundle> bundle in bundles)
		{
			if (!bundle.Key.StartsWith("content", StringComparison.OrdinalIgnoreCase))
			{
				string[] allAssetNames = bundle.Value.GetAllAssetNames();
				foreach (string key in allAssetNames)
				{
					files.Add(key, bundle.Value);
				}
			}
		}
	}

	public void Dispose()
	{
		manifest = null;
		foreach (KeyValuePair<string, AssetBundle> bundle in bundles)
		{
			bundle.Value.Unload(false);
			Object.DestroyImmediate((Object)(object)bundle.Value);
		}
		bundles.Clear();
		if (Object.op_Implicit((Object)(object)rootBundle))
		{
			rootBundle.Unload(false);
			Object.DestroyImmediate((Object)(object)rootBundle);
			rootBundle = null;
		}
	}

	public override List<string> UnloadBundles(string partialName)
	{
		List<string> list = new List<string>();
		string[] array = bundles.Keys.ToArray();
		foreach (string text in array)
		{
			if (text.IndexOf(partialName, StringComparison.OrdinalIgnoreCase) < 0)
			{
				continue;
			}
			AssetBundle val = bundles[text];
			val.Unload(false);
			Object.DestroyImmediate((Object)(object)val);
			bundles.Remove(text);
			val = LoadBundle(text);
			string[] allAssetNames = val.GetAllAssetNames();
			foreach (string text2 in allAssetNames)
			{
				files[text2] = val;
				list.Add(text2);
				if (cache.TryGetValue(text2, out var value))
				{
					cache.Remove(text2);
					Object.DestroyImmediate(value, true);
				}
			}
		}
		return list;
	}

	public float GetAssetSceneProgress()
	{
		List<string> autoLoadScenes = AssetSceneManifest.Current.AutoLoadScenes;
		return GetAssetSceneProgress(autoLoadScenes);
	}

	public float GetAssetSceneProgress(List<string> sceneNames)
	{
		if (sceneNames == null || sceneNames.Count == 0)
		{
			return 1f;
		}
		int num = 0;
		float num2 = 0f;
		foreach (string sceneName in sceneNames)
		{
			float assetSceneProgress = GetAssetSceneProgress(sceneName);
			num2 += assetSceneProgress;
			if (assetSceneProgress >= 1f)
			{
				num++;
			}
		}
		if (num >= sceneNames.Count)
		{
			return 1f;
		}
		return Mathf.Min(num2 / (float)sceneNames.Count, 0.999f);
	}

	public float GetAssetSceneProgress(string sceneName)
	{
		if (!assetSceneLoads.TryGetValue(sceneName, out var value))
		{
			AssetSceneUtil.Log("Asset scene '" + sceneName + "' is not currently loading or loaded - cannot get progress.");
			return 0f;
		}
		return value.progress / 0.9f * 0.99f;
	}

	public IEnumerator LoadAssetScenes(List<string> sceneNames)
	{
		if (sceneNames == null || sceneNames.Count == 0)
		{
			yield break;
		}
		foreach (string sceneName in sceneNames)
		{
			if (!assetSceneLoads.ContainsKey(sceneName))
			{
				((MonoBehaviour)Global.Runner).StartCoroutine(LoadAssetScene(sceneName));
			}
		}
		while (GetAssetSceneProgress(sceneNames) < 1f)
		{
			yield return null;
		}
	}

	public IEnumerator UnloadAssetScenes(List<string> sceneNames, Action<string, Dictionary<string, GameObject>> onAssetSceneUnloaded)
	{
		List<AsyncOperation> unloadOperations = new List<AsyncOperation>();
		foreach (string sceneName in sceneNames)
		{
			if (!assetSceneLoads.TryGetValue(sceneName, out var asyncOperation))
			{
				continue;
			}
			AssetSceneManifest.Entry entry = List.FindWith<AssetSceneManifest.Entry, string>((IReadOnlyCollection<AssetSceneManifest.Entry>)AssetSceneManifest.Current.Scenes, (Func<AssetSceneManifest.Entry, string>)((AssetSceneManifest.Entry s) => s.Name), sceneName, (IEqualityComparer<string>)StringComparer.OrdinalIgnoreCase);
			if (entry == null || !entry.CanUnload)
			{
				Debug.LogError((object)("Asset scene '" + sceneName + "' is not allowed to be unloaded."));
				continue;
			}
			while (!asyncOperation.isDone)
			{
				yield return null;
			}
			AsyncOperation val = SceneManager.UnloadSceneAsync(sceneName);
			if (val == null)
			{
				continue;
			}
			Dictionary<string, GameObject> valueOrDefault = assetScenePrefabs.GetValueOrDefault(sceneName);
			if (valueOrDefault != null)
			{
				foreach (string key in valueOrDefault.Keys)
				{
					cache.Remove(key);
				}
			}
			onAssetSceneUnloaded?.Invoke(sceneName, valueOrDefault);
			assetSceneLoads.Remove(sceneName);
			assetScenePrefabs.Remove(sceneName);
			unloadOperations.Add(val);
			asyncOperation = null;
		}
		while (unloadOperations.Any((AsyncOperation o) => !o.isDone))
		{
			yield return null;
		}
	}

	public List<string> GetRequiredAssetScenesForPrefabs(IEnumerable<string> prefabPaths)
	{
		HashSet<string> hashSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
		foreach (string prefabPath in prefabPaths)
		{
			if (prefabToAssetSceneName.TryGetValue(prefabPath, out var value))
			{
				hashSet.Add(value);
			}
			else
			{
				Debug.LogWarning((object)("Prefab '" + prefabPath + "' does not have an associated asset scene."));
			}
		}
		return hashSet.ToList();
	}

	public List<(string Path, GameObject Prefab)> GetAssetScenePrefabs(List<string> assetSceneNames = null)
	{
		return (from kvp in assetScenePrefabs.Where((KeyValuePair<string, Dictionary<string, GameObject>> kvp) => assetSceneNames == null || assetSceneNames.Contains<string>(kvp.Key, StringComparer.OrdinalIgnoreCase)).SelectMany((KeyValuePair<string, Dictionary<string, GameObject>> d) => d.Value)
			select (Path: kvp.Key, Prefab: kvp.Value)).ToList();
	}

	private IEnumerator LoadAssetScene(string sceneName)
	{
		LoadSceneParameters val = default(LoadSceneParameters);
		((LoadSceneParameters)(ref val))..ctor((LoadSceneMode)1, (LocalPhysicsMode)2);
		if (assetSceneLoads.ContainsKey(sceneName))
		{
			Debug.LogError((object)("Already loaded asset scene: " + sceneName));
			yield break;
		}
		AssetSceneUtil.Log("Starting to load asset scene: " + sceneName);
		AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(sceneName, val);
		if (asyncLoad == null)
		{
			isError = true;
			loadingError = "Failed to load asset scene: " + sceneName;
			Debug.LogError((object)loadingError);
			yield break;
		}
		asyncLoad.allowSceneActivation = false;
		assetSceneLoads[sceneName] = asyncLoad;
		Scene currentActiveScene = SceneManager.GetActiveScene();
		while (!asyncLoad.isDone)
		{
			yield return null;
			if (asyncLoad.progress >= 0.9f)
			{
				AssetSceneUtil.Log("Asset scene " + sceneName + " loaded, activating...");
				currentActiveScene = SceneManager.GetActiveScene();
				asyncLoad.allowSceneActivation = true;
				SceneManager.SetActiveScene(currentActiveScene);
			}
		}
		SceneManager.SetActiveScene(currentActiveScene);
		Scene sceneByName = SceneManager.GetSceneByName(sceneName);
		if (!((Scene)(ref sceneByName)).IsValid() || !((Scene)(ref sceneByName)).isLoaded)
		{
			isError = true;
			loadingError = "Failed to get asset scene after loading: " + sceneName;
			Debug.LogError((object)loadingError);
			yield break;
		}
		AssetSceneUtil.Log("Asset scene " + sceneName + " activated successfully.");
		GameObject[] rootGameObjects = ((Scene)(ref sceneByName)).GetRootGameObjects();
		Dictionary<string, GameObject> dictionary = new Dictionary<string, GameObject>(StringComparer.OrdinalIgnoreCase);
		GameObject[] array = rootGameObjects;
		foreach (GameObject val2 in array)
		{
			string name = ((Object)val2).name;
			dictionary.TryAdd(name, val2);
			((Object)val2).name = Path.GetFileNameWithoutExtension(name);
		}
		assetScenePrefabs[sceneName] = dictionary;
		AssetSceneUtil.Log($"Asset scene {sceneName} root objects loaded: {rootGameObjects.Length}");
	}

	protected override T LoadAsset<T>(string filePath)
	{
		if (filePath.EndsWith(".prefab", StringComparison.OrdinalIgnoreCase))
		{
			if (prefabToAssetSceneName.TryGetValue(filePath, out var value))
			{
				if (assetScenePrefabs.TryGetValue(value, out var value2) && value2.TryGetValue(filePath, out var value3))
				{
					return (T)(object)((value3 is T) ? value3 : null);
				}
				Debug.LogError((object)((GetAssetSceneProgress(value) < 1f) ? ("Prefab '" + filePath + "' requires asset scene '" + value + "' to be loaded first.") : ("Prefab '" + filePath + "' is supposed to be in asset scene '" + value + "' but it was not found.")));
			}
			else
			{
				AssetSceneUtil.Log("Prefab '" + filePath + "' not found in any asset scenes.");
			}
			return default(T);
		}
		if (!files.TryGetValue(filePath, out var value4))
		{
			return default(T);
		}
		return value4.LoadAsset<T>(filePath);
	}

	protected override string[] LoadAssetList(string folder, string search)
	{
		List<string> list = new List<string>();
		foreach (KeyValuePair<string, Dictionary<string, GameObject>> assetScenePrefab in assetScenePrefabs)
		{
			assetScenePrefab.Deconstruct(out var _, out var value);
			foreach (KeyValuePair<string, GameObject> item in value.Where((KeyValuePair<string, GameObject> x) => x.Key.StartsWith(folder, StringComparison.OrdinalIgnoreCase)))
			{
				if (string.IsNullOrEmpty(search) || item.Key.IndexOf(search, StringComparison.OrdinalIgnoreCase) != -1)
				{
					list.Add(item.Key);
				}
			}
		}
		foreach (KeyValuePair<string, AssetBundle> item2 in files.Where((KeyValuePair<string, AssetBundle> x) => x.Key.StartsWith(folder, StringComparison.OrdinalIgnoreCase)))
		{
			if (string.IsNullOrEmpty(search) || item2.Key.IndexOf(search, StringComparison.OrdinalIgnoreCase) != -1)
			{
				list.Add(item2.Key);
			}
		}
		list.Sort(StringComparer.OrdinalIgnoreCase);
		return list.ToArray();
	}

	public override T[] LoadAllFromBundle<T>(string bundleName, string editorSearch)
	{
		foreach (KeyValuePair<string, AssetBundle> bundle in bundles)
		{
			if (bundle.Key.EndsWith(bundleName))
			{
				return bundle.Value.LoadAllAssets<T>();
			}
		}
		throw new Exception("LoadAllFromBundle found none");
	}

	public override bool HasAsset(string path)
	{
		if (!assetScenePrefabs.ContainsKey(path))
		{
			return files.ContainsKey(path);
		}
		return true;
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

[JsonModel]
public class AssetSceneManifest
{
	[JsonModel]
	public class Entry
	{
		public string Name { get; set; }

		public bool AutoLoad { get; set; }

		public bool CanUnload { get; set; }

		public List<string> IncludedAssets { get; set; }
	}

	public const string FileName = "AssetSceneManifest.json";

	public const string Prefix = "AssetScene-";

	public const string BootstrapSceneName = "AssetScene-bootstrap";

	public const string PrefabsSceneName = "AssetScene-prefabs";

	public const string WorldSceneName = "AssetScene-world";

	public const string MonumentSceneName = "AssetScene-monument";

	public const string PropsSceneName = "AssetScene-props";

	public List<Entry> Scenes { get; set; }

	[JsonIgnore]
	public List<string> AutoLoadScenes { get; private set; }

	[JsonIgnore]
	public List<string> UnloadableScenes { get; private set; }

	[JsonIgnore]
	public List<string> MonumentScenes { get; private set; }

	public static AssetSceneManifest Current { get; private set; }

	private void Initialize()
	{
		if (Scenes == null)
		{
			List<Entry> list2 = (Scenes = new List<Entry>());
		}
		AutoLoadScenes = (from s in Scenes
			where s.AutoLoad
			select s.Name).ToList();
		UnloadableScenes = (from s in Scenes
			where s.CanUnload
			select s.Name).ToList();
		MonumentScenes = (from s in Scenes
			where s.Name.StartsWith("AssetScene-monument", StringComparison.OrdinalIgnoreCase)
			select s.Name).ToList();
	}

	public static void Load(AssetBundleBackend backend)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Invalid comparison between Unknown and I4
		if (Current != null)
		{
			throw new InvalidOperationException("AssetSceneManifest is already loaded.");
		}
		Current = JsonConvert.DeserializeObject<AssetSceneManifest>(File.ReadAllText(((int)Application.platform == 1) ? Path.Combine(Application.dataPath, "../../Bundles/", "AssetSceneManifest.json") : Path.Combine(Application.dataPath, "../Bundles/", "AssetSceneManifest.json")));
		if (Current == null)
		{
			Current = new AssetSceneManifest();
		}
		Current.Initialize();
	}
}


public static class AssetSceneUtil
{
	public static void Log(string message)
	{
	}
}


using System.Diagnostics;
using System.IO;
using UnityEngine;

public static class FileSystem
{
	public static bool LogDebug;

	public static bool LogTime;

	public static FileSystemBackend Backend;

	public static bool IsBundled
	{
		get
		{
			if (Application.isPlaying)
			{
				return Backend is AssetBundleBackend;
			}
			return false;
		}
	}

	public static GameObject[] LoadPrefabs(string folder)
	{
		return Backend.LoadPrefabs(folder);
	}

	public static GameObject LoadPrefab(string filePath)
	{
		return Backend.LoadPrefab(filePath);
	}

	public static string[] FindAll(string folder, string search = "")
	{
		return Backend.FindAll(folder, search);
	}

	public static T[] LoadAll<T>(string folder, string search = "") where T : Object
	{
		if (!StringEx.IsLower(folder))
		{
			folder = folder.ToLower();
		}
		return Backend.LoadAll<T>(folder, search);
	}

	public static T[] LoadAllFromBundle<T>(string bundleName, string editorSearch) where T : Object
	{
		return Backend.LoadAllFromBundle<T>(bundleName, editorSearch);
	}

	public static T Load<T>(string filePath, bool complain = true) where T : Object
	{
		if (!StringEx.IsLower(filePath))
		{
			filePath = filePath.ToLower();
		}
		Stopwatch stopwatch = Stopwatch.StartNew();
		if (LogDebug)
		{
			File.AppendAllText("filesystem_debug.csv", $"{filePath}\n");
		}
		T val = Backend.Load<T>(filePath);
		if (complain && (Object)(object)val == (Object)null)
		{
			Debug.LogWarning((object)("[FileSystem] Not Found: " + filePath + " (" + typeof(T)?.ToString() + ")"));
		}
		if (LogTime)
		{
			File.AppendAllText("filesystem.csv", $"{filePath},{stopwatch.Elapsed.TotalMilliseconds}\n");
		}
		return val;
	}

	public static bool HasAsset(string filePath)
	{
		return Backend.HasAsset(filePath);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public abstract class FileSystemBackend
{
	public bool isError;

	public string loadingError = "";

	public Dictionary<string, Object> cache = new Dictionary<string, Object>(StringComparer.OrdinalIgnoreCase);

	public GameObject[] LoadPrefabs(string folder)
	{
		if (!folder.EndsWith("/", StringComparison.CurrentCultureIgnoreCase))
		{
			Debug.LogWarning((object)("LoadPrefabs - folder should end in '/' - " + folder));
		}
		if (!folder.StartsWith("assets/", StringComparison.CurrentCultureIgnoreCase))
		{
			Debug.LogWarning((object)("LoadPrefabs - should start with assets/ - " + folder));
		}
		return this.LoadAll<GameObject>(folder, ".prefab");
	}

	public GameObject LoadPrefab(string filePath)
	{
		if (!filePath.StartsWith("assets/", StringComparison.CurrentCultureIgnoreCase))
		{
			Debug.LogWarning((object)("LoadPrefab - should start with assets/ - " + filePath));
		}
		return this.Load<GameObject>(filePath);
	}

	public string[] FindAll(string folder, string search = "")
	{
		return LoadAssetList(folder, search);
	}

	public T[] LoadAll<T>(string folder, string search = "") where T : Object
	{
		List<T> list = new List<T>();
		string[] array = FindAll(folder, search);
		foreach (string filePath in array)
		{
			T val = Load<T>(filePath);
			if ((Object)(object)val != (Object)null)
			{
				list.Add(val);
			}
		}
		return list.ToArray();
	}

	public T Load<T>(string filePath) where T : Object
	{
		T val = default(T);
		if (cache.ContainsKey(filePath))
		{
			Object obj = cache[filePath];
			val = (T)(object)((obj is T) ? obj : null);
		}
		else
		{
			val = LoadAsset<T>(filePath);
			if ((Object)(object)val != (Object)null)
			{
				cache.Add(filePath, (Object)(object)val);
			}
		}
		return val;
	}

	protected void LoadError(string err)
	{
		Debug.LogError((object)err);
		loadingError = err;
		isError = true;
	}

	public virtual List<string> UnloadBundles(string partialName)
	{
		return new List<string>(0);
	}

	protected abstract T LoadAsset<T>(string filePath) where T : Object;

	protected abstract string[] LoadAssetList(string folder, string search);

	public abstract T[] LoadAllFromBundle<T>(string bundleName, string editorSearch) where T : Object;

	public abstract bool HasAsset(string path);
}


using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Runtime.CompilerServices;

[CompilerGenerated]
[EditorBrowsable(EditorBrowsableState.Never)]
[GeneratedCode("Unity.MonoScriptGenerator.MonoScriptInfoGenerator", null)]
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1
{
	private struct MonoScriptData
	{
		public byte[] FilePathsData;

		public byte[] TypesData;

		public int TotalTypes;

		public int TotalFiles;

		public bool IsEditorOnly;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static MonoScriptData Get()
	{
		MonoScriptData result = default(MonoScriptData);
		result.FilePathsData = new byte[292]
		{
			0, 0, 0, 1, 0, 0, 0, 53, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 82, 117, 115, 116, 46, 70,
			105, 108, 101, 83, 121, 115, 116, 101, 109, 92,
			65, 115, 115, 101, 116, 66, 117, 110, 100, 108,
			101, 66, 97, 99, 107, 101, 110, 100, 46, 99,
			115, 0, 0, 0, 2, 0, 0, 0, 53, 92,
			65, 115, 115, 101, 116, 115, 92, 80, 108, 117,
			103, 105, 110, 115, 92, 82, 117, 115, 116, 46,
			70, 105, 108, 101, 83, 121, 115, 116, 101, 109,
			92, 65, 115, 115, 101, 116, 83, 99, 101, 110,
			101, 77, 97, 110, 105, 102, 101, 115, 116, 46,
			99, 115, 0, 0, 0, 1, 0, 0, 0, 49,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 82, 117, 115, 116,
			46, 70, 105, 108, 101, 83, 121, 115, 116, 101,
			109, 92, 65, 115, 115, 101, 116, 83, 99, 101,
			110, 101, 85, 116, 105, 108, 46, 99, 115, 0,
			0, 0, 1, 0, 0, 0, 45, 92, 65, 115,
			115, 101, 116, 115, 92, 80, 108, 117, 103, 105,
			110, 115, 92, 82, 117, 115, 116, 46, 70, 105,
			108, 101, 83, 121, 115, 116, 101, 109, 92, 70,
			105, 108, 101, 83, 121, 115, 116, 101, 109, 46,
			99, 115, 0, 0, 0, 1, 0, 0, 0, 52,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 82, 117, 115, 116,
			46, 70, 105, 108, 101, 83, 121, 115, 116, 101,
			109, 92, 70, 105, 108, 101, 83, 121, 115, 116,
			101, 109, 66, 97, 99, 107, 101, 110, 100, 46,
			99, 115
		};
		result.TypesData = new byte[136]
		{
			0, 0, 0, 0, 19, 124, 65, 115, 115, 101,
			116, 66, 117, 110, 100, 108, 101, 66, 97, 99,
			107, 101, 110, 100, 0, 0, 0, 0, 19, 124,
			65, 115, 115, 101, 116, 83, 99, 101, 110, 101,
			77, 97, 110, 105, 102, 101, 115, 116, 0, 0,
			0, 0, 24, 65, 115, 115, 101, 116, 83, 99,
			101, 110, 101, 77, 97, 110, 105, 102, 101, 115,
			116, 124, 69, 110, 116, 114, 121, 0, 0, 0,
			0, 15, 124, 65, 115, 115, 101, 116, 83, 99,
			101, 110, 101, 85, 116, 105, 108, 0, 0, 0,
			0, 11, 124, 70, 105, 108, 101, 83, 121, 115,
			116, 101, 109, 0, 0, 0, 0, 18, 124, 70,
			105, 108, 101, 83, 121, 115, 116, 101, 109, 66,
			97, 99, 107, 101, 110, 100
		};
		result.TotalFiles = 5;
		result.TotalTypes = 6;
		result.IsEditorOnly = false;
		return result;
	}
}


using System.Collections.Generic;

[JsonModel]
public class Entry
{
	public string Name { get; set; }

	public bool AutoLoad { get; set; }

	public bool CanUnload { get; set; }

	public List<string> IncludedAssets { get; set; }
}


private struct MonoScriptData
{
	public byte[] FilePathsData;

	public byte[] TypesData;

	public int TotalTypes;

	public int TotalFiles;

	public bool IsEditorOnly;
}


