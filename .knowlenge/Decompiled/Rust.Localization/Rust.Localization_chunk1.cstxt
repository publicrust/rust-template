using UnityEngine;

public sealed class LocalizationTokenAttribute : PropertyAttribute
{
}


using System;
using System.Collections.Generic;
using System.Globalization;
using JetBrains.Annotations;
using Newtonsoft.Json;
using UnityEngine;
using UnityEngine.Serialization;

public static class Translate
{
	[Serializable]
	public class Phrase
	{
		[LocalizationToken]
		public string token;

		private string _english;

		[SerializeField]
		[HideInInspector]
		[FormerlySerializedAs("english")]
		[UsedImplicitly]
		private string legacyEnglish;

		private static readonly Memoized<Phrase, string> ImplicitPhraseCache = new Memoized<Phrase, string>((Func<string, Phrase>)((string s) => new Phrase("", s)));

		public string english
		{
			get
			{
				if (string.IsNullOrEmpty(token))
				{
					return _english;
				}
				return Get(token, _english, forceEnglish: true);
			}
			set
			{
				_english = value;
			}
		}

		public virtual string translated
		{
			get
			{
				if (string.IsNullOrEmpty(token))
				{
					return english;
				}
				return Get(token, _english);
			}
		}

		public bool IsValid()
		{
			if (string.IsNullOrEmpty(token))
			{
				return !string.IsNullOrEmpty(english);
			}
			return true;
		}

		public bool IsEmpty()
		{
			if (!string.IsNullOrEmpty(english))
			{
				return english == "#" + token;
			}
			return true;
		}

		public Phrase(string t = "", string eng = "")
		{
			token = t;
			_english = eng;
		}

		public static implicit operator Phrase(string b)
		{
			return ImplicitPhraseCache.Get(b ?? string.Empty);
		}

		public string GetRawEnglish()
		{
			return _english;
		}
	}

	public static string engineJsonPath = "Assets/Localization/en/engine.json";

	public static string generatedJsonPath = "Assets/Localization/en/engine-generated.json";

	public static Dictionary<string, string> englishBaseStrings = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

	private static string language = CultureInfo.InstalledUICulture.TwoLetterISOLanguageName;

	[ClientVar(ClientAdmin = true)]
	public static string overrideCulture;

	public static void Init()
	{
		CacheEnglishStrings();
	}

	public static string Get(string key, string def = null, bool forceEnglish = false)
	{
		if (string.IsNullOrEmpty(key))
		{
			return null;
		}
		if (englishBaseStrings == null || englishBaseStrings.Count == 0)
		{
			Init();
		}
		if (englishBaseStrings != null && englishBaseStrings.TryGetValue(key, out var value))
		{
			return value;
		}
		return def ?? ("#" + key);
	}

	public static Phrase GetPhrase(string token)
	{
		if (string.IsNullOrEmpty(token))
		{
			return null;
		}
		if (englishBaseStrings == null || englishBaseStrings.Count == 0)
		{
			Init();
		}
		if (englishBaseStrings != null && englishBaseStrings.TryGetValue(token, out var value))
		{
			return new Phrase(token, value);
		}
		return null;
	}

	public static void AddLanguageFile(string fileName, Dictionary<string, string> dict)
	{
		TextAsset val = FileSystem.Load<TextAsset>(fileName, true);
		if ((Object)(object)val == (Object)null)
		{
			return;
		}
		Dictionary<string, string> dictionary = JsonConvert.DeserializeObject<Dictionary<string, string>>(val.text);
		if (dictionary == null)
		{
			Debug.LogError((object)("Error loading translation file: " + fileName));
		}
		foreach (KeyValuePair<string, string> item in dictionary)
		{
			if (!dict.ContainsKey(item.Key))
			{
				string value = item.Value.Replace("\\n", "\n").Trim();
				dict.Add(item.Key, value);
			}
		}
	}

	private static void CacheEnglishStrings()
	{
		englishBaseStrings = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
		AddLanguageFile(engineJsonPath, englishBaseStrings);
		AddLanguageFile(generatedJsonPath, englishBaseStrings);
	}

	public static string GetLanguage()
	{
		return language;
	}

	public static bool CurrentLanguageIsRTL()
	{
		if (!(GetLanguage() == "ar"))
		{
			return GetLanguage() == "he";
		}
		return true;
	}

	[ClientVar]
	public static void printCultureInfo(Arg arg)
	{
		CultureInfo currentCulture = GetCurrentCulture();
		string text = "";
		if (!string.IsNullOrEmpty(overrideCulture))
		{
			text = text + "Override Culture: " + overrideCulture + "\n\n";
		}
		text = text + "Installed UI Culture: " + currentCulture.Name + " (" + currentCulture.DisplayName + ")\n";
		try
		{
			RegionInfo regionInfo = new RegionInfo(currentCulture.Name);
			NumberFormatInfo numberFormat = currentCulture.NumberFormat;
			text = text + "Region: " + regionInfo.TwoLetterISORegionName + " (" + regionInfo.DisplayName + ")\nCurrency: " + regionInfo.ISOCurrencySymbol + " (" + regionInfo.CurrencySymbol + ")\nDecimal: '" + numberFormat.NumberDecimalSeparator + "'Group: '" + numberFormat.NumberGroupSeparator + "'\nCurrency Format: " + 1234.56.ToString("C", numberFormat) + "\nNumber Format: " + 1234.56.ToString("N", numberFormat);
		}
		catch
		{
			text += "(No region info available)";
		}
		arg.ReplyWith(text);
	}

	public static CultureInfo GetCurrentCulture()
	{
		CultureInfo result = CultureInfo.InvariantCulture;
		if (!string.IsNullOrEmpty(overrideCulture))
		{
			try
			{
				result = new CultureInfo(overrideCulture);
			}
			catch
			{
			}
		}
		else
		{
			result = CultureInfo.InstalledUICulture;
		}
		return result;
	}
}


using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Runtime.CompilerServices;

[CompilerGenerated]
[EditorBrowsable(EditorBrowsableState.Never)]
[GeneratedCode("Unity.MonoScriptGenerator.MonoScriptInfoGenerator", null)]
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1
{
	private struct MonoScriptData
	{
		public byte[] FilePathsData;

		public byte[] TypesData;

		public int TotalTypes;

		public int TotalFiles;

		public bool IsEditorOnly;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static MonoScriptData Get()
	{
		MonoScriptData result = default(MonoScriptData);
		result.FilePathsData = new byte[179]
		{
			0, 0, 0, 1, 0, 0, 0, 46, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 82, 117, 115, 116, 46, 76,
			111, 99, 97, 108, 105, 122, 97, 116, 105, 111,
			110, 92, 73, 76, 111, 99, 97, 108, 105, 122,
			101, 46, 99, 115, 0, 0, 0, 1, 0, 0,
			0, 63, 92, 65, 115, 115, 101, 116, 115, 92,
			80, 108, 117, 103, 105, 110, 115, 92, 82, 117,
			115, 116, 46, 76, 111, 99, 97, 108, 105, 122,
			97, 116, 105, 111, 110, 92, 76, 111, 99, 97,
			108, 105, 122, 97, 116, 105, 111, 110, 84, 111,
			107, 101, 110, 65, 116, 116, 114, 105, 98, 117,
			116, 101, 46, 99, 115, 0, 0, 0, 2, 0,
			0, 0, 46, 92, 65, 115, 115, 101, 116, 115,
			92, 80, 108, 117, 103, 105, 110, 115, 92, 82,
			117, 115, 116, 46, 76, 111, 99, 97, 108, 105,
			122, 97, 116, 105, 111, 110, 92, 84, 114, 97,
			110, 115, 108, 97, 116, 101, 46, 99, 115
		};
		result.TypesData = new byte[100]
		{
			0, 0, 0, 0, 27, 82, 117, 115, 116, 46,
			76, 111, 99, 97, 108, 105, 122, 97, 116, 105,
			111, 110, 124, 73, 76, 111, 99, 97, 108, 105,
			122, 101, 0, 0, 0, 0, 27, 124, 76, 111,
			99, 97, 108, 105, 122, 97, 116, 105, 111, 110,
			84, 111, 107, 101, 110, 65, 116, 116, 114, 105,
			98, 117, 116, 101, 0, 0, 0, 0, 10, 124,
			84, 114, 97, 110, 115, 108, 97, 116, 101, 0,
			0, 0, 0, 16, 84, 114, 97, 110, 115, 108,
			97, 116, 101, 124, 80, 104, 114, 97, 115, 101
		};
		result.TotalFiles = 3;
		result.TotalTypes = 4;
		result.IsEditorOnly = false;
		return result;
	}
}


public interface ILocalize
{
	string LanguageToken { get; }

	string LanguageEnglish { get; }
}


using System;
using JetBrains.Annotations;
using UnityEngine;
using UnityEngine.Serialization;

[Serializable]
public class Phrase
{
	[LocalizationToken]
	public string token;

	private string _english;

	[SerializeField]
	[HideInInspector]
	[FormerlySerializedAs("english")]
	[UsedImplicitly]
	private string legacyEnglish;

	private static readonly Memoized<Phrase, string> ImplicitPhraseCache = new Memoized<Phrase, string>((Func<string, Phrase>)((string s) => new Phrase("", s)));

	public string english
	{
		get
		{
			if (string.IsNullOrEmpty(token))
			{
				return _english;
			}
			return Get(token, _english, forceEnglish: true);
		}
		set
		{
			_english = value;
		}
	}

	public virtual string translated
	{
		get
		{
			if (string.IsNullOrEmpty(token))
			{
				return english;
			}
			return Get(token, _english);
		}
	}

	public bool IsValid()
	{
		if (string.IsNullOrEmpty(token))
		{
			return !string.IsNullOrEmpty(english);
		}
		return true;
	}

	public bool IsEmpty()
	{
		if (!string.IsNullOrEmpty(english))
		{
			return english == "#" + token;
		}
		return true;
	}

	public Phrase(string t = "", string eng = "")
	{
		token = t;
		_english = eng;
	}

	public static implicit operator Phrase(string b)
	{
		return ImplicitPhraseCache.Get(b ?? string.Empty);
	}

	public string GetRawEnglish()
	{
		return _english;
	}
}


private struct MonoScriptData
{
	public byte[] FilePathsData;

	public byte[] TypesData;

	public int TotalTypes;

	public int TotalFiles;

	public bool IsEditorOnly;
}


