using Oxide.Core.Libraries.Covalence;

public class Universal : Covalence
{
}


using System;
using System.Collections.Generic;
using Oxide;
using Oxide.Pooling;

public class BaseArrayPoolProvider<T> : IArrayPoolProvider<T>, IPoolProvider<T[]>, IPoolProvider
{
	private readonly int maxSetCapacity;

	private readonly int maxArrayLength;

	private readonly T[] empty;

	private readonly Stack<T[]>[] pooledArrays;

	public BaseArrayPoolProvider(int poolCapacity, int arrayMaxLength)
	{
		maxSetCapacity = poolCapacity;
		maxArrayLength = arrayMaxLength;
		empty = InstantiateArray(0);
		pooledArrays = new Stack<T[]>[maxArrayLength];
		for (int i = 0; i < pooledArrays.Length; i++)
		{
			pooledArrays[i] = new Stack<T[]>(maxSetCapacity);
		}
	}

	public BaseArrayPoolProvider()
		: this(100, 50)
	{
	}

	public T[] Take()
	{
		return empty;
	}

	public T[] Take(int length)
	{
		if (length == 0)
		{
			return empty;
		}
		if (length > maxArrayLength)
		{
			return InstantiateArray(length);
		}
		if (length < 0)
		{
			throw new ArgumentOutOfRangeException("length", length, "must be at least zero");
		}
		Stack<T[]> stack = pooledArrays[length - 1];
		T[] array = default(T[]);
		lock (stack)
		{
			if (!ExtensionMethods.TryPop<T[]>(stack, ref array))
			{
				array = InstantiateArray(length);
			}
		}
		OnTake(array);
		return array;
	}

	public void Return(object item)
	{
		if (!(item is T[] array) || array.Length == 0 || array.Length > maxArrayLength || !OnReturn(array))
		{
			return;
		}
		Stack<T[]> stack = pooledArrays[array.Length - 1];
		lock (stack)
		{
			if (stack.Count < maxSetCapacity)
			{
				stack.Push(array);
			}
		}
	}

	protected virtual void OnTake(T[] array)
	{
	}

	protected virtual bool OnReturn(T[] array)
	{
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = default(T);
		}
		return true;
	}

	protected virtual T[] InstantiateArray(int length)
	{
		return new T[length];
	}
}


using System.Collections.Generic;
using Oxide;
using Oxide.Pooling;

internal abstract class BasePoolProvider<T> : IPoolProvider<T>, IPoolProvider
{
	private readonly Stack<T> pooledData;

	private int MaxPoolSize { get; }

	protected BasePoolProvider()
	{
		MaxPoolSize = 50;
		pooledData = new Stack<T>(MaxPoolSize);
	}

	public T Take()
	{
		T val = default(T);
		lock (pooledData)
		{
			if (!ExtensionMethods.TryPop<T>(pooledData, ref val))
			{
				val = InstantiateItem();
			}
		}
		OnTake(val);
		return val;
	}

	public void Return(object item)
	{
		if (!(item is T item2) || !OnReturn(item2))
		{
			return;
		}
		lock (pooledData)
		{
			if (pooledData.Count < MaxPoolSize)
			{
				pooledData.Push(item2);
			}
		}
	}

	protected abstract T InstantiateItem();

	protected virtual void OnTake(T item)
	{
	}

	protected virtual bool OnReturn(T item)
	{
		return true;
	}
}


using System;
using System.Collections.Generic;
using System.Text;
using Oxide.Pooling;

internal class CorePoolFactory : IPoolFactory
{
	private class ProviderExpirationToken : IDisposable
	{
		private readonly Type key;

		private readonly CorePoolFactory instance;

		public ProviderExpirationToken(Type key, CorePoolFactory instance)
		{
			this.key = key;
			this.instance = instance;
		}

		~ProviderExpirationToken()
		{
			Dispose(disposing: false);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
		}

		private void Dispose(bool disposing)
		{
			if (disposing)
			{
				GC.SuppressFinalize(this);
			}
			lock (instance.registeredProviders)
			{
				instance.registeredProviders.Remove(key);
			}
		}
	}

	private readonly Type arrayType = typeof(IArrayPoolProvider<>);

	private readonly Type itemType = typeof(IPoolProvider<>);

	private readonly Dictionary<Type, IPoolProvider> registeredProviders;

	public CorePoolFactory()
	{
		registeredProviders = new Dictionary<Type, IPoolProvider>
		{
			[typeof(object[])] = (IPoolProvider)(object)new BaseArrayPoolProvider<object>(256, 50),
			[typeof(StringBuilder)] = (IPoolProvider)(object)new StringPoolProvider()
		};
	}

	internal void Internal_RegisterProvider(Type type, IPoolProvider provider)
	{
		registeredProviders[type] = provider;
	}

	public IPoolProvider<T> GetProvider<T>()
	{
		lock (registeredProviders)
		{
			IPoolProvider value;
			return registeredProviders.TryGetValue(typeof(T), out value) ? ((IPoolProvider<T>)(object)value) : null;
		}
	}

	public bool IsHandledType<T>()
	{
		lock (registeredProviders)
		{
			return registeredProviders.ContainsKey(typeof(T));
		}
	}

	public IDisposable RegisterProvider<T>(out T provider, params object[] args) where T : IPoolProvider
	{
		provider = default(T);
		Type typeFromHandle = typeof(T);
		Type type = null;
		Type[] interfaces = typeFromHandle.GetInterfaces();
		foreach (Type type2 in interfaces)
		{
			bool flag = false;
			if (type2.IsGenericType)
			{
				Type genericTypeDefinition = type2.GetGenericTypeDefinition();
				if (arrayType == genericTypeDefinition)
				{
					flag = true;
				}
				else if (!(itemType == genericTypeDefinition))
				{
					continue;
				}
				type = (flag ? type2.GetGenericArguments()[0].MakeArrayType() : type2.GetGenericArguments()[0]);
				break;
			}
		}
		if (type == null)
		{
			throw new ArgumentNullException("genericType");
		}
		lock (registeredProviders)
		{
			if (!registeredProviders.ContainsKey(type))
			{
				provider = (T)Activator.CreateInstance(typeFromHandle, args);
				registeredProviders[type] = (IPoolProvider)(object)provider;
				return new ProviderExpirationToken(type, this);
			}
			throw new ArgumentException("A provider already exists for key " + type.FullName);
		}
	}
}


using System.Text;
using Oxide.Pooling;

internal sealed class StringPoolProvider : BasePoolProvider<StringBuilder>
{
	protected override void OnTake(StringBuilder item)
	{
		OnReturn(item);
	}

	protected override bool OnReturn(StringBuilder item)
	{
		item.Length = 0;
		return true;
	}

	protected override StringBuilder InstantiateItem()
	{
		return new StringBuilder();
	}
}


using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

public static class ExtensionMethods
{
	public static string Basename(this string text, string extension = null)
	{
		if (extension != null)
		{
			if (!extension.Equals("*.*"))
			{
				if (extension[0] == '*')
				{
					extension = extension.Substring(1);
				}
				return Regex.Match(text, "([^\\\\/]+)\\" + extension + "+$").Groups[1].Value;
			}
			Match match = Regex.Match(text, "([^\\\\/]+)\\.[^\\.]+$");
			if (match.Success)
			{
				return match.Groups[1].Value;
			}
		}
		return Regex.Match(text, "[^\\\\/]+$").Groups[0].Value;
	}

	public static bool Contains<T>(this T[] array, T value)
	{
		for (int i = 0; i < array.Length; i++)
		{
			T val = array[i];
			if (val.Equals(value))
			{
				return true;
			}
		}
		return false;
	}

	public static string Dirname(this string text)
	{
		return Regex.Match(text, "(.+)[\\/][^\\/]+$").Groups[1].Value;
	}

	public static string Humanize(this string name)
	{
		return Regex.Replace(name, "(\\B[A-Z])", " $1");
	}

	public static bool IsSteamId(this string id)
	{
		if (ulong.TryParse(id, out var result))
		{
			return result > 76561197960265728L;
		}
		return false;
	}

	public static bool IsSteamId(this ulong id)
	{
		return id > 76561197960265728L;
	}

	public static string Plaintext(this string text)
	{
		return Formatter.ToPlaintext(text);
	}

	public static string QuoteSafe(this string text)
	{
		return "\"" + text.Replace("\"", "\\\"").TrimEnd(new char[1] { '\\' }) + "\"";
	}

	public static string Quote(this string text)
	{
		return QuoteSafe(text);
	}

	public static T Sample<T>(this T[] array)
	{
		return array[Random.Range(0, array.Length)];
	}

	public static string Sanitize(this string text)
	{
		return text.Replace("{", "{{").Replace("}", "}}");
	}

	public static string SentenceCase(this string text)
	{
		return new Regex("(^[a-z])|\\.\\s+(.)", RegexOptions.ExplicitCapture).Replace(text.ToLower(), (Match s) => s.Value.ToUpper());
	}

	public static string TitleCase(this string text)
	{
		return CultureInfo.InstalledUICulture.TextInfo.ToTitleCase(Enumerable.Contains(text, '_') ? text.Replace('_', ' ') : text);
	}

	public static string Titleize(this string text)
	{
		return TitleCase(text);
	}

	public static string ToSentence<T>(this IEnumerable<T> items)
	{
		IEnumerator<T> enumerator = items.GetEnumerator();
		if (!enumerator.MoveNext())
		{
			return string.Empty;
		}
		T current = enumerator.Current;
		if (!enumerator.MoveNext())
		{
			return current?.ToString();
		}
		StringBuilder stringBuilder = new StringBuilder(current?.ToString());
		bool flag = true;
		while (flag)
		{
			T current2 = enumerator.Current;
			flag = enumerator.MoveNext();
			stringBuilder.Append(flag ? ", " : " and ");
			stringBuilder.Append(current2);
		}
		return stringBuilder.ToString();
	}

	public static string Truncate(this string text, int max)
	{
		if (text.Length > max)
		{
			return text.Substring(0, max) + " ...";
		}
		return text;
	}

	public static HashSet<T> ToHashSet<T>(this IEnumerable<T> collection)
	{
		return new HashSet<T>(collection);
	}
}


using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

public static class Analytics
{
	private static readonly WebRequests Webrequests = Interface.Oxide.GetLibrary<WebRequests>();

	private static readonly PluginManager PluginManager = Interface.Oxide.RootPluginManager;

	private static readonly Covalence Covalence = Interface.Oxide.GetLibrary<Covalence>();

	private static readonly Lang Lang = Interface.Oxide.GetLibrary<Lang>();

	private const string trackingId = "UA-48448359-3";

	private const string url = "https://www.google-analytics.com/collect";

	private static readonly string Identifier = $"{Covalence.Server.Address}:{Covalence.Server.Port}";

	public static void Collect()
	{
		SendPayload(string.Concat("v=1&tid=UA-48448359-3&cid=" + Identifier + "&t=screenview&cd=" + Covalence.Game + "+" + Covalence.Server.Version, $"&an=Oxide&av={OxideMod.Version}&ul={Lang.GetServerLanguage()}"));
	}

	public static void Event(string category, string action)
	{
		SendPayload("v=1&tid=UA-48448359-3&cid=" + Identifier + "&t=event&ec=" + category + "&ea=" + action);
	}

	public static void SendPayload(string payload)
	{
		Dictionary<string, string> headers = new Dictionary<string, string> { 
		{
			"User-Agent",
			$"Oxide/{OxideMod.Version} ({Environment.OSVersion}; {Environment.OSVersion.Platform})"
		} };
		Webrequests.Enqueue("https://www.google-analytics.com/collect", Uri.EscapeUriString(payload), delegate
		{
		}, null, RequestMethod.POST, headers);
	}
}


using System;
using Oxide.Core;
using Oxide.Pooling;

public static class ArrayPool
{
	private static readonly IArrayPoolProvider<object> pool;

	static ArrayPool()
	{
		pool = PoolingExtensions.GetArrayProvider<object>(Interface.Oxide.PoolFactory);
	}

	[Obsolete("Use Interface.Oxide.PoolFactory")]
	public static object[] Get(int length)
	{
		return pool.Take(length);
	}

	[Obsolete("Use Interface.Oxide.PoolFactory")]
	public static void Free(object[] array)
	{
		((IPoolProvider)pool).Return((object)array);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Oxide.Core;

public static class Cleanup
{
	internal static HashSet<string> files = new HashSet<string>();

	public static void Add(string file)
	{
		files.Add(file);
	}

	internal static void Run()
	{
		if (files == null)
		{
			return;
		}
		foreach (string file in files)
		{
			try
			{
				if (File.Exists(file))
				{
					Interface.Oxide.LogDebug("Clean up file: {0}", file);
					File.Delete(file);
				}
			}
			catch (Exception)
			{
				Interface.Oxide.LogWarning("Failed to clean up file: {0}", file);
			}
		}
		files = null;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

public sealed class CommandLine
{
	private readonly Dictionary<string, string> variables = new Dictionary<string, string>();

	public CommandLine(string[] commandline)
	{
		string text = string.Empty;
		string text2 = string.Empty;
		string[] array = commandline;
		foreach (string text3 in array)
		{
			text = text + "\"" + text3.Trim('/', '\\') + "\"";
		}
		array = Split(text);
		foreach (string text4 in array)
		{
			if (text4.Length <= 0)
			{
				continue;
			}
			string text5 = text4;
			if (text4[0] == '-' || text4[0] == '+')
			{
				if (text2 != string.Empty && !variables.ContainsKey(text2))
				{
					variables.Add(text2, string.Empty);
				}
				text2 = text5.Substring(1);
			}
			else
			{
				if (!(text2 != string.Empty))
				{
					continue;
				}
				if (!variables.ContainsKey(text2))
				{
					if (text2.Contains("dir"))
					{
						text5 = text5.Replace('/', '\\');
					}
					variables.Add(text2, text5);
				}
				text2 = string.Empty;
			}
		}
		if (text2 != string.Empty && !variables.ContainsKey(text2))
		{
			variables.Add(text2, string.Empty);
		}
	}

	public static string[] Split(string input)
	{
		input = input.Replace("\\\"", "&quot;");
		MatchCollection matchCollection = new Regex("\"([^\"]+)\"|'([^']+)'|\\S+").Matches(input);
		string[] array = new string[matchCollection.Count];
		for (int i = 0; i < matchCollection.Count; i++)
		{
			char[] trimChars = new char[2] { ' ', '"' };
			array[i] = matchCollection[i].Groups[0].Value.Trim(trimChars);
			array[i] = array[i].Replace("&quot;", "\"");
		}
		return array;
	}

	public bool HasVariable(string name)
	{
		return variables.Any((KeyValuePair<string, string> v) => v.Key == name);
	}

	public string GetVariable(string name)
	{
		try
		{
			return variables.Single((KeyValuePair<string, string> v) => v.Key == name).Value;
		}
		catch (Exception)
		{
			return null;
		}
	}

	public void GetArgument(string var, out string varname, out string format)
	{
		string variable = GetVariable(var);
		StringBuilder stringBuilder = new StringBuilder();
		StringBuilder stringBuilder2 = new StringBuilder();
		int num = 0;
		string text = variable;
		foreach (char c in text)
		{
			switch (c)
			{
			case '{':
				num++;
				break;
			case '}':
				num--;
				if (num == 0)
				{
					stringBuilder2.Append("{0}");
				}
				break;
			default:
				if (num == 0)
				{
					stringBuilder2.Append(c);
				}
				else
				{
					stringBuilder.Append(c);
				}
				break;
			}
		}
		varname = stringBuilder.ToString();
		format = stringBuilder2.ToString();
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Configuration;

public class DataFileSystem
{
	private readonly Dictionary<string, DynamicConfigFile> _datafiles;

	public string Directory { get; private set; }

	public DataFileSystem(string directory)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Directory = directory;
		_datafiles = new Dictionary<string, DynamicConfigFile>();
		KeyValuesConverter item = new KeyValuesConverter();
		new JsonSerializerSettings().Converters.Add((JsonConverter)(object)item);
	}

	public DynamicConfigFile GetFile(string name)
	{
		name = DynamicConfigFile.SanitizeName(name);
		if (_datafiles.TryGetValue(name, out var value))
		{
			return value;
		}
		value = new DynamicConfigFile(Path.Combine(Directory, name + ".json"));
		_datafiles.Add(name, value);
		return value;
	}

	public bool ExistsDatafile(string name)
	{
		return GetFile(name).Exists();
	}

	public DynamicConfigFile GetDatafile(string name)
	{
		DynamicConfigFile file = GetFile(name);
		if (file.Exists())
		{
			file.Load();
		}
		else
		{
			file.Save();
		}
		return file;
	}

	public string[] GetFiles(string path = "", string searchPattern = "*")
	{
		return System.IO.Directory.GetFiles(Path.Combine(Directory, path), searchPattern);
	}

	public void SaveDatafile(string name)
	{
		GetFile(name).Save();
	}

	public T ReadObject<T>(string name)
	{
		T val = default(T);
		if (ExistsDatafile(name))
		{
			val = GetFile(name).ReadObject<T>();
		}
		if (val == null)
		{
			val = Activator.CreateInstance<T>();
			WriteObject(name, val);
		}
		return val;
	}

	public void WriteObject<T>(string name, T Object, bool sync = false)
	{
		GetFile(name).WriteObject(Object, sync);
	}

	public void DeleteDataFile(string name)
	{
		GetFile(name).Delete();
	}

	public void ForEachObject<T>(string name, Action<T> callback)
	{
		string folder = DynamicConfigFile.SanitizeName(name);
		foreach (DynamicConfigFile item in from d in _datafiles
			where d.Key.StartsWith(folder)
			select d into a
			select a.Value)
		{
			callback?.Invoke(item.ReadObject<T>());
		}
	}
}


using System;
using System.Collections.Generic;
using Oxide.Core;

public class Event
{
	public delegate void Action<in T1, in T2, in T3, in T4, in T5>(T1 arg0, T2 arg1, T3 arg2, T4 arg3, T5 arg4);

	public class Callback
	{
		public Action Invoke;

		internal Callback Previous;

		internal Callback Next;

		internal Event Handler;

		public Callback(Action callback)
		{
			Invoke = callback;
		}

		public void Call()
		{
			Action invoke = Invoke;
			if (invoke == null)
			{
				return;
			}
			try
			{
				invoke();
			}
			catch (Exception ex)
			{
				Interface.Oxide.LogException("Exception while invoking event handler", ex);
			}
		}

		public void Remove()
		{
			Event handler = Handler;
			Callback next = Next;
			Callback previous = Previous;
			if (previous == null)
			{
				handler.First = next;
			}
			else
			{
				previous.Next = next;
				if (next == null)
				{
					handler.Last = previous;
				}
			}
			if (next == null)
			{
				handler.Last = previous;
			}
			else
			{
				next.Previous = previous;
				if (previous == null)
				{
					handler.First = next;
				}
			}
			if (handler.Invoking)
			{
				handler.RemovedQueue.Enqueue(this);
			}
			else
			{
				Previous = null;
				Next = null;
			}
			Invoke = null;
			Handler = null;
		}
	}

	public class Callback<T>
	{
		public Action<T> Invoke;

		internal Callback<T> Previous;

		internal Callback<T> Next;

		internal Event<T> Handler;

		public Callback(Action<T> callback)
		{
			Invoke = callback;
		}

		public void Call(T arg0)
		{
			Action<T> invoke = Invoke;
			if (invoke == null)
			{
				return;
			}
			try
			{
				invoke(arg0);
			}
			catch (Exception ex)
			{
				Interface.Oxide.LogException("Exception while invoking event handler", ex);
			}
		}

		public void Remove()
		{
			Event<T> handler = Handler;
			Callback<T> next = Next;
			Callback<T> previous = Previous;
			if (previous == null)
			{
				handler.First = next;
			}
			else
			{
				previous.Next = next;
				if (next == null)
				{
					handler.Last = previous;
				}
			}
			if (next == null)
			{
				handler.Last = previous;
			}
			else
			{
				next.Previous = previous;
				if (previous == null)
				{
					handler.First = next;
				}
			}
			if (handler.Invoking)
			{
				handler.RemovedQueue.Enqueue(this);
			}
			else
			{
				Previous = null;
				Next = null;
			}
			Invoke = null;
			Handler = null;
		}
	}

	public class Callback<T1, T2>
	{
		public Action<T1, T2> Invoke;

		internal Callback<T1, T2> Previous;

		internal Callback<T1, T2> Next;

		internal Event<T1, T2> Handler;

		public Callback(Action<T1, T2> callback)
		{
			Invoke = callback;
		}

		public void Call(T1 arg0, T2 arg1)
		{
			Action<T1, T2> invoke = Invoke;
			if (invoke == null)
			{
				return;
			}
			try
			{
				invoke(arg0, arg1);
			}
			catch (Exception ex)
			{
				Interface.Oxide.LogException("Exception while invoking event handler", ex);
			}
		}

		public void Remove()
		{
			Event<T1, T2> handler = Handler;
			Callback<T1, T2> next = Next;
			Callback<T1, T2> previous = Previous;
			if (previous == null)
			{
				handler.First = next;
			}
			else
			{
				previous.Next = next;
				if (next == null)
				{
					handler.Last = previous;
				}
			}
			if (next == null)
			{
				handler.Last = previous;
			}
			else
			{
				next.Previous = previous;
				if (previous == null)
				{
					handler.First = next;
				}
			}
			if (handler.Invoking)
			{
				handler.RemovedQueue.Enqueue(this);
			}
			else
			{
				Previous = null;
				Next = null;
			}
			Invoke = null;
			Handler = null;
		}
	}

	public class Callback<T1, T2, T3>
	{
		public Action<T1, T2, T3> Invoke;

		internal Callback<T1, T2, T3> Previous;

		internal Callback<T1, T2, T3> Next;

		internal Event<T1, T2, T3> Handler;

		public Callback(Action<T1, T2, T3> callback)
		{
			Invoke = callback;
		}

		public void Call(T1 arg0, T2 arg1, T3 arg2)
		{
			Action<T1, T2, T3> invoke = Invoke;
			if (invoke == null)
			{
				return;
			}
			try
			{
				invoke(arg0, arg1, arg2);
			}
			catch (Exception ex)
			{
				Interface.Oxide.LogException("Exception while invoking event handler", ex);
			}
		}

		public void Remove()
		{
			Event<T1, T2, T3> handler = Handler;
			Callback<T1, T2, T3> next = Next;
			Callback<T1, T2, T3> previous = Previous;
			if (previous == null)
			{
				handler.First = next;
			}
			else
			{
				previous.Next = next;
				if (next == null)
				{
					handler.Last = previous;
				}
			}
			if (next == null)
			{
				handler.Last = previous;
			}
			else
			{
				next.Previous = previous;
				if (previous == null)
				{
					handler.First = next;
				}
			}
			if (handler.Invoking)
			{
				handler.RemovedQueue.Enqueue(this);
			}
			else
			{
				Previous = null;
				Next = null;
			}
			Invoke = null;
			Handler = null;
		}
	}

	public class Callback<T1, T2, T3, T4>
	{
		public Action<T1, T2, T3, T4> Invoke;

		internal Callback<T1, T2, T3, T4> Previous;

		internal Callback<T1, T2, T3, T4> Next;

		internal Event<T1, T2, T3, T4> Handler;

		public Callback(Action<T1, T2, T3, T4> callback)
		{
			Invoke = callback;
		}

		public void Call(T1 arg0, T2 arg1, T3 arg2, T4 arg3)
		{
			Action<T1, T2, T3, T4> invoke = Invoke;
			if (invoke == null)
			{
				return;
			}
			try
			{
				invoke(arg0, arg1, arg2, arg3);
			}
			catch (Exception ex)
			{
				Interface.Oxide.LogException("Exception while invoking event handler", ex);
			}
		}

		public void Remove()
		{
			Event<T1, T2, T3, T4> handler = Handler;
			Callback<T1, T2, T3, T4> next = Next;
			Callback<T1, T2, T3, T4> previous = Previous;
			if (previous == null)
			{
				handler.First = next;
			}
			else
			{
				previous.Next = next;
				if (next == null)
				{
					handler.Last = previous;
				}
			}
			if (next == null)
			{
				handler.Last = previous;
			}
			else
			{
				next.Previous = previous;
				if (previous == null)
				{
					handler.First = next;
				}
			}
			if (handler.Invoking)
			{
				handler.RemovedQueue.Enqueue(this);
			}
			else
			{
				Previous = null;
				Next = null;
			}
			Invoke = null;
			Handler = null;
		}
	}

	public class Callback<T1, T2, T3, T4, T5>
	{
		public Action<T1, T2, T3, T4, T5> Invoke;

		internal Callback<T1, T2, T3, T4, T5> Previous;

		internal Callback<T1, T2, T3, T4, T5> Next;

		internal Event<T1, T2, T3, T4, T5> Handler;

		public Callback(Action<T1, T2, T3, T4, T5> callback)
		{
			Invoke = callback;
		}

		public void Call(T1 arg0, T2 arg1, T3 arg2, T4 arg3, T5 arg4)
		{
			Action<T1, T2, T3, T4, T5> invoke = Invoke;
			if (invoke == null)
			{
				return;
			}
			try
			{
				invoke(arg0, arg1, arg2, arg3, arg4);
			}
			catch (Exception ex)
			{
				Interface.Oxide.LogException("Exception while invoking event handler", ex);
			}
		}

		public void Remove()
		{
			Event<T1, T2, T3, T4, T5> handler = Handler;
			Callback<T1, T2, T3, T4, T5> next = Next;
			Callback<T1, T2, T3, T4, T5> previous = Previous;
			if (previous == null)
			{
				handler.First = next;
			}
			else
			{
				previous.Next = next;
				if (next == null)
				{
					handler.Last = previous;
				}
			}
			if (next == null)
			{
				handler.Last = previous;
			}
			else
			{
				next.Previous = previous;
				if (previous == null)
				{
					handler.First = next;
				}
			}
			if (handler.Invoking)
			{
				handler.RemovedQueue.Enqueue(this);
			}
			else
			{
				Previous = null;
				Next = null;
			}
			Invoke = null;
			Handler = null;
		}
	}

	public Callback First;

	public Callback Last;

	internal object Lock = new object();

	internal bool Invoking;

	internal Queue<Callback> RemovedQueue = new Queue<Callback>();

	public static void Remove(ref Callback callback)
	{
		if (callback != null)
		{
			callback.Remove();
			callback = null;
		}
	}

	public static void Remove<T1>(ref Callback<T1> callback)
	{
		if (callback != null)
		{
			callback.Remove();
			callback = null;
		}
	}

	public static void Remove<T1, T2>(ref Callback<T1, T2> callback)
	{
		if (callback != null)
		{
			callback.Remove();
			callback = null;
		}
	}

	public static void Remove<T1, T2, T3>(ref Callback<T1, T2, T3> callback)
	{
		if (callback != null)
		{
			callback.Remove();
			callback = null;
		}
	}

	public static void Remove<T1, T2, T3, T4>(ref Callback<T1, T2, T3, T4> callback)
	{
		if (callback != null)
		{
			callback.Remove();
			callback = null;
		}
	}

	public static void Remove<T1, T2, T3, T4, T5>(ref Callback<T1, T2, T3, T4, T5> callback)
	{
		if (callback != null)
		{
			callback.Remove();
			callback = null;
		}
	}

	public void Add(Callback callback)
	{
		callback.Handler = this;
		lock (Lock)
		{
			Callback last = Last;
			if (last == null)
			{
				First = callback;
				Last = callback;
			}
			else
			{
				last.Next = callback;
				callback.Previous = last;
				Last = callback;
			}
		}
	}

	public Callback Add(Action callback)
	{
		Callback callback2 = new Callback(callback);
		Add(callback2);
		return callback2;
	}

	public void Invoke()
	{
		lock (Lock)
		{
			Invoking = true;
			for (Callback callback = First; callback != null; callback = callback.Next)
			{
				callback.Call();
			}
			Invoking = false;
			Queue<Callback> removedQueue = RemovedQueue;
			while (removedQueue.Count > 0)
			{
				Callback callback = removedQueue.Dequeue();
				callback.Previous = null;
				callback.Next = null;
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Oxide.Core;

public class Event<T>
{
	public Event.Callback<T> First;

	public Event.Callback<T> Last;

	internal object Lock = new object();

	internal bool Invoking;

	internal Queue<Event.Callback<T>> RemovedQueue = new Queue<Event.Callback<T>>();

	public void Add(Event.Callback<T> callback)
	{
		callback.Handler = this;
		lock (Lock)
		{
			Event.Callback<T> last = Last;
			if (last == null)
			{
				First = callback;
				Last = callback;
			}
			else
			{
				last.Next = callback;
				callback.Previous = last;
				Last = callback;
			}
		}
	}

	public Event.Callback<T> Add(Action<T> callback)
	{
		Event.Callback<T> callback2 = new Event.Callback<T>(callback);
		Add(callback2);
		return callback2;
	}

	public void Invoke(T arg0)
	{
		lock (Lock)
		{
			Invoking = true;
			for (Event.Callback<T> callback = First; callback != null; callback = callback.Next)
			{
				callback.Call(arg0);
			}
			Invoking = false;
			Queue<Event.Callback<T>> removedQueue = RemovedQueue;
			while (removedQueue.Count > 0)
			{
				Event.Callback<T> callback = removedQueue.Dequeue();
				callback.Previous = null;
				callback.Next = null;
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Oxide.Core;

public class Event<T1, T2>
{
	public Event.Callback<T1, T2> First;

	public Event.Callback<T1, T2> Last;

	internal object Lock = new object();

	internal bool Invoking;

	internal Queue<Event.Callback<T1, T2>> RemovedQueue = new Queue<Event.Callback<T1, T2>>();

	public void Add(Event.Callback<T1, T2> callback)
	{
		callback.Handler = this;
		lock (Lock)
		{
			Event.Callback<T1, T2> last = Last;
			if (last == null)
			{
				First = callback;
				Last = callback;
			}
			else
			{
				last.Next = callback;
				callback.Previous = last;
				Last = callback;
			}
		}
	}

	public Event.Callback<T1, T2> Add(Action<T1, T2> callback)
	{
		Event.Callback<T1, T2> callback2 = new Event.Callback<T1, T2>(callback);
		Add(callback2);
		return callback2;
	}

	public void Invoke()
	{
		lock (Lock)
		{
			Invoking = true;
			for (Event.Callback<T1, T2> callback = First; callback != null; callback = callback.Next)
			{
				callback.Call(default(T1), default(T2));
			}
			Invoking = false;
			Queue<Event.Callback<T1, T2>> removedQueue = RemovedQueue;
			while (removedQueue.Count > 0)
			{
				Event.Callback<T1, T2> callback = removedQueue.Dequeue();
				callback.Previous = null;
				callback.Next = null;
			}
		}
	}

	public void Invoke(T1 arg0)
	{
		lock (Lock)
		{
			Invoking = true;
			for (Event.Callback<T1, T2> callback = First; callback != null; callback = callback.Next)
			{
				callback.Call(arg0, default(T2));
			}
			Invoking = false;
			Queue<Event.Callback<T1, T2>> removedQueue = RemovedQueue;
			while (removedQueue.Count > 0)
			{
				Event.Callback<T1, T2> callback = removedQueue.Dequeue();
				callback.Previous = null;
				callback.Next = null;
			}
		}
	}

	public void Invoke(T1 arg0, T2 arg1)
	{
		lock (Lock)
		{
			Invoking = true;
			for (Event.Callback<T1, T2> callback = First; callback != null; callback = callback.Next)
			{
				callback.Call(arg0, arg1);
			}
			Invoking = false;
			Queue<Event.Callback<T1, T2>> removedQueue = RemovedQueue;
			while (removedQueue.Count > 0)
			{
				Event.Callback<T1, T2> callback = removedQueue.Dequeue();
				callback.Previous = null;
				callback.Next = null;
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Oxide.Core;

public class Event<T1, T2, T3>
{
	public Event.Callback<T1, T2, T3> First;

	public Event.Callback<T1, T2, T3> Last;

	internal object Lock = new object();

	internal bool Invoking;

	internal Queue<Event.Callback<T1, T2, T3>> RemovedQueue = new Queue<Event.Callback<T1, T2, T3>>();

	public void Add(Event.Callback<T1, T2, T3> callback)
	{
		callback.Handler = this;
		lock (Lock)
		{
			Event.Callback<T1, T2, T3> last = Last;
			if (last == null)
			{
				First = callback;
				Last = callback;
			}
			else
			{
				last.Next = callback;
				callback.Previous = last;
				Last = callback;
			}
		}
	}

	public Event.Callback<T1, T2, T3> Add(Action<T1, T2, T3> callback)
	{
		Event.Callback<T1, T2, T3> callback2 = new Event.Callback<T1, T2, T3>(callback);
		Add(callback2);
		return callback2;
	}

	public void Invoke()
	{
		lock (Lock)
		{
			Invoking = true;
			for (Event.Callback<T1, T2, T3> callback = First; callback != null; callback = callback.Next)
			{
				callback.Invoke(default(T1), default(T2), default(T3));
			}
			Invoking = false;
			Queue<Event.Callback<T1, T2, T3>> removedQueue = RemovedQueue;
			while (removedQueue.Count > 0)
			{
				Event.Callback<T1, T2, T3> callback = removedQueue.Dequeue();
				callback.Previous = null;
				callback.Next = null;
			}
		}
	}

	public void Invoke(T1 arg0)
	{
		lock (Lock)
		{
			Invoking = true;
			for (Event.Callback<T1, T2, T3> callback = First; callback != null; callback = callback.Next)
			{
				callback.Call(arg0, default(T2), default(T3));
			}
			Invoking = false;
			Queue<Event.Callback<T1, T2, T3>> removedQueue = RemovedQueue;
			while (removedQueue.Count > 0)
			{
				Event.Callback<T1, T2, T3> callback = removedQueue.Dequeue();
				callback.Previous = null;
				callback.Next = null;
			}
		}
	}

	public void Invoke(T1 arg0, T2 arg1)
	{
		lock (Lock)
		{
			Invoking = true;
			for (Event.Callback<T1, T2, T3> callback = First; callback != null; callback = callback.Next)
			{
				callback.Call(arg0, arg1, default(T3));
			}
			Invoking = false;
			Queue<Event.Callback<T1, T2, T3>> removedQueue = RemovedQueue;
			while (removedQueue.Count > 0)
			{
				Event.Callback<T1, T2, T3> callback = removedQueue.Dequeue();
				callback.Previous = null;
				callback.Next = null;
			}
		}
	}

	public void Invoke(T1 arg0, T2 arg1, T3 arg2)
	{
		lock (Lock)
		{
			Invoking = true;
			for (Event.Callback<T1, T2, T3> callback = First; callback != null; callback = callback.Next)
			{
				callback.Call(arg0, arg1, arg2);
			}
			Invoking = false;
			Queue<Event.Callback<T1, T2, T3>> removedQueue = RemovedQueue;
			while (removedQueue.Count > 0)
			{
				Event.Callback<T1, T2, T3> callback = removedQueue.Dequeue();
				callback.Previous = null;
				callback.Next = null;
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Oxide.Core;

public class Event<T1, T2, T3, T4>
{
	public Event.Callback<T1, T2, T3, T4> First;

	public Event.Callback<T1, T2, T3, T4> Last;

	internal object Lock = new object();

	internal bool Invoking;

	internal Queue<Event.Callback<T1, T2, T3, T4>> RemovedQueue = new Queue<Event.Callback<T1, T2, T3, T4>>();

	public void Add(Event.Callback<T1, T2, T3, T4> callback)
	{
		callback.Handler = this;
		lock (Lock)
		{
			Event.Callback<T1, T2, T3, T4> last = Last;
			if (last == null)
			{
				First = callback;
				Last = callback;
			}
			else
			{
				last.Next = callback;
				callback.Previous = last;
				Last = callback;
			}
		}
	}

	public Event.Callback<T1, T2, T3, T4> Add(Action<T1, T2, T3, T4> callback)
	{
		Event.Callback<T1, T2, T3, T4> callback2 = new Event.Callback<T1, T2, T3, T4>(callback);
		Add(callback2);
		return callback2;
	}

	public void Invoke()
	{
		lock (Lock)
		{
			Invoking = true;
			for (Event.Callback<T1, T2, T3, T4> callback = First; callback != null; callback = callback.Next)
			{
				callback.Call(default(T1), default(T2), default(T3), default(T4));
			}
			Invoking = false;
			Queue<Event.Callback<T1, T2, T3, T4>> removedQueue = RemovedQueue;
			while (removedQueue.Count > 0)
			{
				Event.Callback<T1, T2, T3, T4> callback = removedQueue.Dequeue();
				callback.Previous = null;
				callback.Next = null;
			}
		}
	}

	public void Invoke(T1 arg0)
	{
		lock (Lock)
		{
			Invoking = true;
			for (Event.Callback<T1, T2, T3, T4> callback = First; callback != null; callback = callback.Next)
			{
				callback.Call(arg0, default(T2), default(T3), default(T4));
			}
			Invoking = false;
			Queue<Event.Callback<T1, T2, T3, T4>> removedQueue = RemovedQueue;
			while (removedQueue.Count > 0)
			{
				Event.Callback<T1, T2, T3, T4> callback = removedQueue.Dequeue();
				callback.Previous = null;
				callback.Next = null;
			}
		}
	}

	public void Invoke(T1 arg0, T2 arg1)
	{
		lock (Lock)
		{
			Invoking = true;
			for (Event.Callback<T1, T2, T3, T4> callback = First; callback != null; callback = callback.Next)
			{
				callback.Call(arg0, arg1, default(T3), default(T4));
			}
			Invoking = false;
			Queue<Event.Callback<T1, T2, T3, T4>> removedQueue = RemovedQueue;
			while (removedQueue.Count > 0)
			{
				Event.Callback<T1, T2, T3, T4> callback = removedQueue.Dequeue();
				callback.Previous = null;
				callback.Next = null;
			}
		}
	}

	public void Invoke(T1 arg0, T2 arg1, T3 arg2)
	{
		lock (Lock)
		{
			Invoking = true;
			for (Event.Callback<T1, T2, T3, T4> callback = First; callback != null; callback = callback.Next)
			{
				callback.Call(arg0, arg1, arg2, default(T4));
			}
			Invoking = false;
			Queue<Event.Callback<T1, T2, T3, T4>> removedQueue = RemovedQueue;
			while (removedQueue.Count > 0)
			{
				Event.Callback<T1, T2, T3, T4> callback = removedQueue.Dequeue();
				callback.Previous = null;
				callback.Next = null;
			}
		}
	}

	public void Invoke(T1 arg0, T2 arg1, T3 arg2, T4 arg3)
	{
		lock (Lock)
		{
			Invoking = true;
			for (Event.Callback<T1, T2, T3, T4> callback = First; callback != null; callback = callback.Next)
			{
				callback.Call(arg0, arg1, arg2, arg3);
			}
			Invoking = false;
			Queue<Event.Callback<T1, T2, T3, T4>> removedQueue = RemovedQueue;
			while (removedQueue.Count > 0)
			{
				Event.Callback<T1, T2, T3, T4> callback = removedQueue.Dequeue();
				callback.Previous = null;
				callback.Next = null;
			}
		}
	}
}


using System.Collections.Generic;
using Oxide.Core;

public class Event<T1, T2, T3, T4, T5>
{
	public Event.Callback<T1, T2, T3, T4, T5> First;

	public Event.Callback<T1, T2, T3, T4, T5> Last;

	internal object Lock = new object();

	internal bool Invoking;

	internal Queue<Event.Callback<T1, T2, T3, T4, T5>> RemovedQueue = new Queue<Event.Callback<T1, T2, T3, T4, T5>>();

	public void Add(Event.Callback<T1, T2, T3, T4, T5> callback)
	{
		callback.Handler = this;
		lock (Lock)
		{
			Event.Callback<T1, T2, T3, T4, T5> last = Last;
			if (last == null)
			{
				First = callback;
				Last = callback;
			}
			else
			{
				last.Next = callback;
				callback.Previous = last;
				Last = callback;
			}
		}
	}

	public Event.Callback<T1, T2, T3, T4, T5> Add(Event.Action<T1, T2, T3, T4, T5> callback)
	{
		Event.Callback<T1, T2, T3, T4, T5> callback2 = new Event.Callback<T1, T2, T3, T4, T5>(callback);
		Add(callback2);
		return callback2;
	}

	public void Invoke()
	{
		lock (Lock)
		{
			Invoking = true;
			for (Event.Callback<T1, T2, T3, T4, T5> callback = First; callback != null; callback = callback.Next)
			{
				callback.Call(default(T1), default(T2), default(T3), default(T4), default(T5));
			}
			Invoking = false;
			Queue<Event.Callback<T1, T2, T3, T4, T5>> removedQueue = RemovedQueue;
			while (removedQueue.Count > 0)
			{
				Event.Callback<T1, T2, T3, T4, T5> callback = removedQueue.Dequeue();
				callback.Previous = null;
				callback.Next = null;
			}
		}
	}

	public void Invoke(T1 arg0)
	{
		lock (Lock)
		{
			Invoking = true;
			for (Event.Callback<T1, T2, T3, T4, T5> callback = First; callback != null; callback = callback.Next)
			{
				callback.Call(arg0, default(T2), default(T3), default(T4), default(T5));
			}
			Invoking = false;
			Queue<Event.Callback<T1, T2, T3, T4, T5>> removedQueue = RemovedQueue;
			while (removedQueue.Count > 0)
			{
				Event.Callback<T1, T2, T3, T4, T5> callback = removedQueue.Dequeue();
				callback.Previous = null;
				callback.Next = null;
			}
		}
	}

	public void Invoke(T1 arg0, T2 arg1)
	{
		lock (Lock)
		{
			Invoking = true;
			for (Event.Callback<T1, T2, T3, T4, T5> callback = First; callback != null; callback = callback.Next)
			{
				callback.Call(arg0, arg1, default(T3), default(T4), default(T5));
			}
			Invoking = false;
			Queue<Event.Callback<T1, T2, T3, T4, T5>> removedQueue = RemovedQueue;
			while (removedQueue.Count > 0)
			{
				Event.Callback<T1, T2, T3, T4, T5> callback = removedQueue.Dequeue();
				callback.Previous = null;
				callback.Next = null;
			}
		}
	}

	public void Invoke(T1 arg0, T2 arg1, T3 arg2)
	{
		lock (Lock)
		{
			Invoking = true;
			for (Event.Callback<T1, T2, T3, T4, T5> callback = First; callback != null; callback = callback.Next)
			{
				callback.Call(arg0, arg1, arg2, default(T4), default(T5));
			}
			Invoking = false;
			Queue<Event.Callback<T1, T2, T3, T4, T5>> removedQueue = RemovedQueue;
			while (removedQueue.Count > 0)
			{
				Event.Callback<T1, T2, T3, T4, T5> callback = removedQueue.Dequeue();
				callback.Previous = null;
				callback.Next = null;
			}
		}
	}

	public void Invoke(T1 arg0, T2 arg1, T3 arg2, T4 arg3)
	{
		lock (Lock)
		{
			Invoking = true;
			for (Event.Callback<T1, T2, T3, T4, T5> callback = First; callback != null; callback = callback.Next)
			{
				callback.Call(arg0, arg1, arg2, arg3, default(T5));
			}
			Invoking = false;
			Queue<Event.Callback<T1, T2, T3, T4, T5>> removedQueue = RemovedQueue;
			while (removedQueue.Count > 0)
			{
				Event.Callback<T1, T2, T3, T4, T5> callback = removedQueue.Dequeue();
				callback.Previous = null;
				callback.Next = null;
			}
		}
	}

	public void Invoke(T1 arg0, T2 arg1, T3 arg2, T4 arg3, T5 arg4)
	{
		lock (Lock)
		{
			Invoking = true;
			for (Event.Callback<T1, T2, T3, T4, T5> callback = First; callback != null; callback = callback.Next)
			{
				callback.Call(arg0, arg1, arg2, arg3, arg4);
			}
			Invoking = false;
			Queue<Event.Callback<T1, T2, T3, T4, T5>> removedQueue = RemovedQueue;
			while (removedQueue.Count > 0)
			{
				Event.Callback<T1, T2, T3, T4, T5> callback = removedQueue.Dequeue();
				callback.Previous = null;
				callback.Next = null;
			}
		}
	}
}


using System;
using System.Collections.Generic;

public class ExceptionHandler
{
	private static readonly Dictionary<Type, Func<Exception, string>> Handlers = new Dictionary<Type, Func<Exception, string>>();

	public static void RegisterType(Type ex, Func<Exception, string> handler)
	{
		Handlers[ex] = handler;
	}

	public static string FormatException(Exception ex)
	{
		if (!Handlers.TryGetValue(ex.GetType(), out var value))
		{
			return null;
		}
		return value(ex);
	}
}


using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

public static class ExtensionMethods
{
	public static string Basename(this string text, string extension = null)
	{
		if (extension != null)
		{
			if (!extension.Equals("*.*"))
			{
				if (extension[0] == '*')
				{
					extension = extension.Substring(1);
				}
				return Regex.Match(text, "([^\\\\/]+)\\" + extension + "+$").Groups[1].Value;
			}
			Match match = Regex.Match(text, "([^\\\\/]+)\\.[^\\.]+$");
			if (match.Success)
			{
				return match.Groups[1].Value;
			}
		}
		return Regex.Match(text, "[^\\\\/]+$").Groups[0].Value;
	}

	public static bool Contains<T>(this T[] array, T value)
	{
		for (int i = 0; i < array.Length; i++)
		{
			T val = array[i];
			if (val.Equals(value))
			{
				return true;
			}
		}
		return false;
	}

	public static string Dirname(this string text)
	{
		return Regex.Match(text, "(.+)[\\/][^\\/]+$").Groups[1].Value;
	}

	public static string Humanize(this string name)
	{
		return Regex.Replace(name, "(\\B[A-Z])", " $1");
	}

	public static bool IsSteamId(this string id)
	{
		if (ulong.TryParse(id, out var result))
		{
			return result > 76561197960265728L;
		}
		return false;
	}

	public static bool IsSteamId(this ulong id)
	{
		return id > 76561197960265728L;
	}

	public static string Plaintext(this string text)
	{
		return Formatter.ToPlaintext(text);
	}

	public static string QuoteSafe(this string text)
	{
		return "\"" + text.Replace("\"", "\\\"").TrimEnd(new char[1] { '\\' }) + "\"";
	}

	public static string Quote(this string text)
	{
		return text.QuoteSafe();
	}

	public static T Sample<T>(this T[] array)
	{
		return array[Random.Range(0, array.Length)];
	}

	public static string Sanitize(this string text)
	{
		return text.Replace("{", "{{").Replace("}", "}}");
	}

	public static string SentenceCase(this string text)
	{
		return new Regex("(^[a-z])|\\.\\s+(.)", RegexOptions.ExplicitCapture).Replace(text.ToLower(), (Match s) => s.Value.ToUpper());
	}

	public static string TitleCase(this string text)
	{
		return CultureInfo.InstalledUICulture.TextInfo.ToTitleCase(Enumerable.Contains(text, '_') ? text.Replace('_', ' ') : text);
	}

	public static string Titleize(this string text)
	{
		return text.TitleCase();
	}

	public static string ToSentence<T>(this IEnumerable<T> items)
	{
		IEnumerator<T> enumerator = items.GetEnumerator();
		if (!enumerator.MoveNext())
		{
			return string.Empty;
		}
		T current = enumerator.Current;
		if (!enumerator.MoveNext())
		{
			return current?.ToString();
		}
		StringBuilder stringBuilder = new StringBuilder(current?.ToString());
		bool flag = true;
		while (flag)
		{
			T current2 = enumerator.Current;
			flag = enumerator.MoveNext();
			stringBuilder.Append(flag ? ", " : " and ");
			stringBuilder.Append(current2);
		}
		return stringBuilder.ToString();
	}

	public static string Truncate(this string text, int max)
	{
		if (text.Length > max)
		{
			return text.Substring(0, max) + " ...";
		}
		return text;
	}

	public static HashSet<T> ToHashSet<T>(this IEnumerable<T> collection)
	{
		return new HashSet<T>(collection);
	}
}


using System;
using Oxide.Core;
using Oxide.Pooling;

public static class Interface
{
	public static OxideMod Oxide { get; private set; }

	public static NativeDebugCallback DebugCallback { get; set; }

	private static IArrayPoolProvider<object> HookArrays { get; }

	public static OxideMod uMod => Oxide;

	static Interface()
	{
		Oxide = new OxideMod();
		HookArrays = PoolingExtensions.GetArrayProvider<object>(Oxide.PoolFactory);
	}

	public static void Initialize()
	{
		if (!Oxide.init_called)
		{
			Oxide.init_called = true;
			Oxide.Load();
		}
	}

	public static object CallDeprecatedHook(string oldHook, string newHook, DateTime expireDate, params object[] args)
	{
		return Oxide.CallDeprecatedHook(oldHook, newHook, expireDate, args);
	}

	public static object CallDeprecated(string oldHook, string newHook, DateTime expireDate, params object[] args)
	{
		return CallDeprecatedHook(oldHook, newHook, expireDate, args);
	}

	public static object CallHook(string hook, object[] args)
	{
		return Oxide.CallHook(hook, args);
	}

	public static object CallHook(string hook)
	{
		return CallHook(hook, null);
	}

	public static object CallDeprecatedHook(string oldHook, string newHook, DateTime expireDate)
	{
		return CallDeprecatedHook(oldHook, newHook, expireDate, null);
	}

	public static object CallHook(string hook, object obj1)
	{
		object[] array = HookArrays.Take(1);
		array[0] = obj1;
		object result = CallHook(hook, array);
		((IPoolProvider)HookArrays).Return((object)array);
		return result;
	}

	public static object CallDeprecatedHook(string oldHook, string newHook, DateTime expireDate, object obj1)
	{
		object[] array = HookArrays.Take(1);
		array[0] = obj1;
		object result = CallDeprecatedHook(oldHook, newHook, expireDate, array);
		((IPoolProvider)HookArrays).Return((object)array);
		return result;
	}

	public static object CallHook(string hook, object obj1, object obj2)
	{
		object[] array = HookArrays.Take(2);
		array[0] = obj1;
		array[1] = obj2;
		object result = CallHook(hook, array);
		((IPoolProvider)HookArrays).Return((object)array);
		return result;
	}

	public static object CallDeprecatedHook(string oldHook, string newHook, DateTime expireDate, object obj1, object obj2)
	{
		object[] array = HookArrays.Take(2);
		array[0] = obj1;
		array[1] = obj2;
		object result = CallDeprecatedHook(oldHook, newHook, expireDate, array);
		((IPoolProvider)HookArrays).Return((object)array);
		return result;
	}

	public static object CallHook(string hook, object obj1, object obj2, object obj3)
	{
		object[] array = HookArrays.Take(3);
		array[0] = obj1;
		array[1] = obj2;
		array[2] = obj3;
		object result = CallHook(hook, array);
		((IPoolProvider)HookArrays).Return((object)array);
		return result;
	}

	public static object CallDeprecatedHook(string oldHook, string newHook, DateTime expireDate, object obj1, object obj2, object obj3)
	{
		object[] array = HookArrays.Take(3);
		array[0] = obj1;
		array[1] = obj2;
		array[2] = obj3;
		object result = CallDeprecatedHook(oldHook, newHook, expireDate, array);
		((IPoolProvider)HookArrays).Return((object)array);
		return result;
	}

	public static object CallHook(string hook, object obj1, object obj2, object obj3, object obj4)
	{
		object[] array = HookArrays.Take(4);
		array[0] = obj1;
		array[1] = obj2;
		array[2] = obj3;
		array[3] = obj4;
		object result = CallHook(hook, array);
		((IPoolProvider)HookArrays).Return((object)array);
		return result;
	}

	public static object CallDeprecatedHook(string oldHook, string newHook, DateTime expireDate, object obj1, object obj2, object obj3, object obj4)
	{
		object[] array = HookArrays.Take(4);
		array[0] = obj1;
		array[1] = obj2;
		array[2] = obj3;
		array[3] = obj4;
		object result = CallDeprecatedHook(oldHook, newHook, expireDate, array);
		((IPoolProvider)HookArrays).Return((object)array);
		return result;
	}

	public static object CallHook(string hook, object obj1, object obj2, object obj3, object obj4, object obj5)
	{
		object[] array = HookArrays.Take(5);
		array[0] = obj1;
		array[1] = obj2;
		array[2] = obj3;
		array[3] = obj4;
		array[4] = obj5;
		object result = CallHook(hook, array);
		((IPoolProvider)HookArrays).Return((object)array);
		return result;
	}

	public static object CallDeprecatedHook(string oldHook, string newHook, DateTime expireDate, object obj1, object obj2, object obj3, object obj4, object obj5)
	{
		object[] array = HookArrays.Take(5);
		array[0] = obj1;
		array[1] = obj2;
		array[2] = obj3;
		array[3] = obj4;
		array[4] = obj5;
		object result = CallDeprecatedHook(oldHook, newHook, expireDate, array);
		((IPoolProvider)HookArrays).Return((object)array);
		return result;
	}

	public static object CallHook(string hook, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6)
	{
		object[] array = HookArrays.Take(6);
		array[0] = obj1;
		array[1] = obj2;
		array[2] = obj3;
		array[3] = obj4;
		array[4] = obj5;
		array[5] = obj6;
		object result = CallHook(hook, array);
		((IPoolProvider)HookArrays).Return((object)array);
		return result;
	}

	public static object CallDeprecatedHook(string oldHook, string newHook, DateTime expireDate, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6)
	{
		object[] array = HookArrays.Take(6);
		array[0] = obj1;
		array[1] = obj2;
		array[2] = obj3;
		array[3] = obj4;
		array[4] = obj5;
		array[5] = obj6;
		object result = CallDeprecatedHook(oldHook, newHook, expireDate, array);
		((IPoolProvider)HookArrays).Return((object)array);
		return result;
	}

	public static object CallHook(string hook, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6, object obj7)
	{
		object[] array = HookArrays.Take(7);
		array[0] = obj1;
		array[1] = obj2;
		array[2] = obj3;
		array[3] = obj4;
		array[4] = obj5;
		array[5] = obj6;
		array[6] = obj7;
		object result = CallHook(hook, array);
		((IPoolProvider)HookArrays).Return((object)array);
		return result;
	}

	public static object CallDeprecatedHook(string oldHook, string newHook, DateTime expireDate, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6, object obj7)
	{
		object[] array = HookArrays.Take(7);
		array[0] = obj1;
		array[1] = obj2;
		array[2] = obj3;
		array[3] = obj4;
		array[4] = obj5;
		array[5] = obj6;
		array[6] = obj7;
		object result = CallDeprecatedHook(oldHook, newHook, expireDate, array);
		((IPoolProvider)HookArrays).Return((object)array);
		return result;
	}

	public static object CallHook(string hook, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6, object obj7, object obj8)
	{
		object[] array = HookArrays.Take(8);
		array[0] = obj1;
		array[1] = obj2;
		array[2] = obj3;
		array[3] = obj4;
		array[4] = obj5;
		array[5] = obj6;
		array[6] = obj7;
		array[7] = obj8;
		object result = CallHook(hook, array);
		((IPoolProvider)HookArrays).Return((object)array);
		return result;
	}

	public static object CallDeprecatedHook(string oldHook, string newHook, DateTime expireDate, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6, object obj7, object obj8)
	{
		object[] array = HookArrays.Take(8);
		array[0] = obj1;
		array[1] = obj2;
		array[2] = obj3;
		array[3] = obj4;
		array[4] = obj5;
		array[5] = obj6;
		array[6] = obj7;
		array[7] = obj8;
		object result = CallDeprecatedHook(oldHook, newHook, expireDate, array);
		((IPoolProvider)HookArrays).Return((object)array);
		return result;
	}

	public static object CallHook(string hook, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6, object obj7, object obj8, object obj9)
	{
		object[] array = HookArrays.Take(9);
		array[0] = obj1;
		array[1] = obj2;
		array[2] = obj3;
		array[3] = obj4;
		array[4] = obj5;
		array[5] = obj6;
		array[6] = obj7;
		array[7] = obj8;
		array[8] = obj9;
		object result = CallHook(hook, array);
		((IPoolProvider)HookArrays).Return((object)array);
		return result;
	}

	public static object CallDeprecatedHook(string oldHook, string newHook, DateTime expireDate, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6, object obj7, object obj8, object obj9)
	{
		object[] array = HookArrays.Take(9);
		array[0] = obj1;
		array[1] = obj2;
		array[2] = obj3;
		array[3] = obj4;
		array[4] = obj5;
		array[5] = obj6;
		array[6] = obj7;
		array[7] = obj8;
		array[8] = obj9;
		object result = CallDeprecatedHook(oldHook, newHook, expireDate, array);
		((IPoolProvider)HookArrays).Return((object)array);
		return result;
	}

	public static object CallHook(string hook, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6, object obj7, object obj8, object obj9, object obj10)
	{
		object[] array = HookArrays.Take(10);
		array[0] = obj1;
		array[1] = obj2;
		array[2] = obj3;
		array[3] = obj4;
		array[4] = obj5;
		array[5] = obj6;
		array[6] = obj7;
		array[7] = obj8;
		array[8] = obj9;
		array[9] = obj10;
		object result = CallHook(hook, array);
		((IPoolProvider)HookArrays).Return((object)array);
		return result;
	}

	public static object CallDeprecatedHook(string oldHook, string newHook, DateTime expireDate, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6, object obj7, object obj8, object obj9, object obj10)
	{
		object[] array = HookArrays.Take(10);
		array[0] = obj1;
		array[1] = obj2;
		array[2] = obj3;
		array[3] = obj4;
		array[4] = obj5;
		array[5] = obj6;
		array[6] = obj7;
		array[7] = obj8;
		array[8] = obj9;
		array[9] = obj10;
		object result = CallDeprecatedHook(oldHook, newHook, expireDate, array);
		((IPoolProvider)HookArrays).Return((object)array);
		return result;
	}

	public static object Call(string hook, params object[] args)
	{
		return CallHook(hook, args);
	}

	public static T Call<T>(string hook, params object[] args)
	{
		return (T)Convert.ChangeType(CallHook(hook, args), typeof(T));
	}

	public static OxideMod GetMod()
	{
		return Oxide;
	}
}


using System.Collections.Generic;

public static class Localization
{
	public static readonly Dictionary<string, Dictionary<string, string>> languages = new Dictionary<string, Dictionary<string, string>> { ["en"] = new Dictionary<string, string>
	{
		["CommandUsageExtLoad"] = "Usage: oxide.ext.load <extname>+",
		["CommandUsageExtUnload"] = "Usage: oxide.ext.unload <extname>+",
		["CommandUsageExtReload"] = "Usage: oxide.ext.reload <extname>+",
		["CommandUsageGrant"] = "Usage: oxide.grant <group|user> <name|id> <permission>",
		["CommandUsageGroup"] = "Usage: oxide.group <add|set> <name> [title] [rank]",
		["CommandUsageGroupParent"] = "Usage: oxide.group <parent> <name> <parentName>",
		["CommandUsageGroupRemove"] = "Usage: oxide.group <remove> <name>",
		["CommandUsageLang"] = "Usage: oxide.lang <two-letter language code>",
		["CommandUsageLoad"] = "Usage: oxide.load *|<pluginname>+",
		["CommandUsageReload"] = "Usage: oxide.reload *|<pluginname>+",
		["CommandUsageRevoke"] = "Usage: oxide.revoke <group|user> <name|id> <permission>",
		["CommandUsageShow"] = "Usage: oxide.show <groups|perms>",
		["CommandUsageShowName"] = "Usage: oxide.show <group|user> <name>",
		["CommandUsageUnload"] = "Usage: oxide.unload *|<pluginname>+",
		["CommandUsageUserGroup"] = "Usage: oxide.usergroup <add|remove> <username> <groupname>",
		["ConnectionRejected"] = "Connection was rejected",
		["DataSaved"] = "Saving Oxide data...",
		["GroupAlreadyExists"] = "Group '{0}' already exists",
		["GroupAlreadyHasPermission"] = "Group '{0}' already has permission '{1}'",
		["GroupDoesNotHavePermission"] = "Group '{0}' does not have permission '{1}'",
		["GroupChanged"] = "Group '{0}' changed",
		["GroupCreated"] = "Group '{0}' created",
		["GroupDeleted"] = "Group '{0}' deleted",
		["GroupNotFound"] = "Group '{0}' doesn't exist",
		["GroupParentChanged"] = "Group '{0}' parent changed to '{1}'",
		["GroupParentNotChanged"] = "Group '{0}' parent was not changed",
		["GroupParentNotFound"] = "Group parent '{0}' doesn't exist",
		["GroupPermissionGranted"] = "Group '{0}' granted permission '{1}'",
		["GroupPermissionRevoked"] = "Group '{0}' revoked permission '{1}'",
		["GroupPermissions"] = "Group '{0}' permissions",
		["GroupPlayers"] = "Group '{0}' players",
		["Groups"] = "Groups",
		["InvalidLanguageName"] = "Invalid language name: '{0}'",
		["NoGroupPermissions"] = "No permissions currently granted",
		["NoPermissionGroups"] = "No groups with this permission",
		["NoPermissionPlayers"] = "No players with this permission",
		["NoPluginsFound"] = "No plugins are currently available",
		["NoPlayerGroups"] = "Player is not assigned to any groups",
		["NoPlayerPermissions"] = "No permissions currently granted",
		["NoPlayersInGroup"] = "No players currently in group",
		["NotAllowed"] = "You are not allowed to use the '{0}' command",
		["ParentGroupPermissions"] = "Parent group '{0}' permissions",
		["PermissionGroups"] = "Permission '{0}' Groups",
		["PermissionPlayers"] = "Permission '{0}' Players",
		["PermissionNotFound"] = "Permission '{0}' doesn't exist",
		["Permissions"] = "Permissions",
		["PermissionsNotLoaded"] = "Unable to load permission files! Permissions will not work until resolved.\n => {0}",
		["PlayerLanguage"] = "Player language set to {0}",
		["PluginNotLoaded"] = "Plugin '{0}' not loaded.",
		["PluginReloaded"] = "Reloaded plugin {0} v{1} by {2}",
		["PluginUnloaded"] = "Unloaded plugin {0} v{1} by {2}",
		["ServerLanguage"] = "Server language set to {0}",
		["Unknown"] = "Unknown",
		["UnknownCommand"] = "Unknown command: {0}",
		["PlayerAddedToGroup"] = "Player '{0}' added to group: {1}",
		["PlayerAlreadyHasPermission"] = "Player '{0}' already has permission '{1}'",
		["PlayerDoesNotHavePermission"] = "Player '{0}' does not have permission '{1}'",
		["PlayerNotFound"] = "Player '{0}' not found",
		["PlayerGroups"] = "Player '{0}' groups",
		["PlayerPermissions"] = "Player '{0}' permissions",
		["PlayerPermissionGranted"] = "Player '{0}' granted permission '{1}'",
		["PlayerPermissionRevoked"] = "Player '{0}' revoked permission '{1}'",
		["PlayerRemovedFromGroup"] = "Player '{0}' removed from group '{1}'",
		["PlayersFound"] = "Multiple players were found, please specify: {0}",
		["Version"] = "Server is running [#ffb658]Oxide {0}[/#] and [#ee715c]{1} {2} ({3})[/#]",
		["YouAreNotAdmin"] = "You are not an admin"
	} };
}


public delegate void NativeDebugCallback(string message);


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Threading;
using Newtonsoft.Json;
using Oxide;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Extensions;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Logging;
using Oxide.Core.Plugins;
using Oxide.Core.Plugins.Watchers;
using Oxide.Core.RemoteConsole;
using Oxide.Core.ServerConsole;
using Oxide.Pooling;
using WebSocketSharp;

public sealed class OxideMod
{
	internal static readonly Version AssemblyVersion = Assembly.GetExecutingAssembly().GetName().Version;

	public static readonly VersionNumber Version = new VersionNumber(AssemblyVersion.Major, AssemblyVersion.Minor, AssemblyVersion.Build);

	public static readonly string Branch = ExtensionMethods.Metadata(Assembly.GetExecutingAssembly(), "GitBranch").FirstOrDefault() ?? "unknown";

	private ExtensionManager extensionManager;

	public CommandLine CommandLine;

	private Covalence covalence;

	private Permission libperm;

	private Oxide.Core.Libraries.Timer libtimer;

	private Func<float> getTimeSinceStartup;

	private List<Action> nextTickQueue = new List<Action>();

	private List<Action> lastTickQueue = new List<Action>();

	private readonly object nextTickLock = new object();

	private Action<float> onFrame;

	internal bool init_called;

	private bool isInitialized;

	public RemoteConsole RemoteConsole;

	public ServerConsole ServerConsole;

	private Stopwatch timer;

	private NativeDebugCallback debugCallback;

	public IPoolFactory PoolFactory { get; }

	public CompoundLogger RootLogger { get; private set; }

	public PluginManager RootPluginManager { get; private set; }

	public DataFileSystem DataFileSystem { get; private set; }

	public string RootDirectory { get; private set; }

	public string ExtensionDirectory { get; private set; }

	public string InstanceDirectory { get; private set; }

	public string PluginDirectory { get; private set; }

	public string ConfigDirectory { get; private set; }

	public string DataDirectory { get; private set; }

	public string LangDirectory { get; private set; }

	public string LogDirectory { get; private set; }

	public float Now => getTimeSinceStartup();

	public bool IsShuttingDown { get; private set; }

	public OxideConfig Config { get; private set; }

	public bool HasLoadedCorePlugins { get; private set; }

	public OxideMod()
	{
		init_called = false;
		CorePoolFactory corePoolFactory = new CorePoolFactory();
		PoolFactory = (IPoolFactory)(object)corePoolFactory;
	}

	public void Load()
	{
		debugCallback = Interface.DebugCallback;
		RootDirectory = Environment.CurrentDirectory;
		if (RootDirectory.StartsWith(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData)))
		{
			RootDirectory = AppDomain.CurrentDomain.BaseDirectory;
		}
		if (RootDirectory == null)
		{
			throw new Exception("RootDirectory is null");
		}
		InstanceDirectory = Path.Combine(RootDirectory, "oxide");
		Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
		JsonConvert.DefaultSettings = () => new JsonSerializerSettings
		{
			Culture = CultureInfo.InvariantCulture
		};
		CommandLine = new CommandLine(Environment.GetCommandLineArgs());
		if (CommandLine.HasVariable("oxide.directory"))
		{
			CommandLine.GetArgument("oxide.directory", out var varname, out var format);
			if (string.IsNullOrEmpty(varname) || CommandLine.HasVariable(varname))
			{
				InstanceDirectory = Path.Combine(RootDirectory, Utility.CleanPath(string.Format(format, CommandLine.GetVariable(varname))));
			}
		}
		ExtensionDirectory = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
		if (ExtensionDirectory == null || !Directory.Exists(ExtensionDirectory))
		{
			throw new Exception("Could not identify extension directory");
		}
		if (!Directory.Exists(InstanceDirectory))
		{
			Directory.CreateDirectory(InstanceDirectory);
		}
		ConfigDirectory = Path.Combine(InstanceDirectory, Utility.CleanPath("config"));
		if (!Directory.Exists(ConfigDirectory))
		{
			Directory.CreateDirectory(ConfigDirectory);
		}
		DataDirectory = Path.Combine(InstanceDirectory, Utility.CleanPath("data"));
		if (!Directory.Exists(DataDirectory))
		{
			Directory.CreateDirectory(DataDirectory);
		}
		LangDirectory = Path.Combine(InstanceDirectory, Utility.CleanPath("lang"));
		if (!Directory.Exists(LangDirectory))
		{
			Directory.CreateDirectory(LangDirectory);
		}
		LogDirectory = Path.Combine(InstanceDirectory, Utility.CleanPath("logs"));
		if (!Directory.Exists(LogDirectory))
		{
			Directory.CreateDirectory(LogDirectory);
		}
		PluginDirectory = Path.Combine(InstanceDirectory, Utility.CleanPath("plugins"));
		if (!Directory.Exists(PluginDirectory))
		{
			Directory.CreateDirectory(PluginDirectory);
		}
		RegisterLibrarySearchPath(Path.Combine(ExtensionDirectory, (IntPtr.Size == 8) ? "x64" : "x86"));
		string text = Path.Combine(InstanceDirectory, "oxide.config.json");
		if (File.Exists(text))
		{
			Config = ConfigFile.Load<OxideConfig>(text);
		}
		else
		{
			Config = new OxideConfig(text);
			Config.Save();
		}
		if (CommandLine.HasVariable("web.ip"))
		{
			Config.Options.WebRequestIP = CommandLine.GetVariable("web.ip");
		}
		if (CommandLine.HasVariable("rcon.port"))
		{
			Config.Rcon.Port = Utility.GetNumbers(CommandLine.GetVariable("rcon.port"));
		}
		if (CommandLine.HasVariable("rcon.password"))
		{
			Config.Rcon.Password = CommandLine.GetVariable("rcon.password");
		}
		RootLogger = new CompoundLogger();
		RootLogger.AddLogger(new RotatingFileLogger
		{
			Directory = LogDirectory
		});
		if (debugCallback != null)
		{
			RootLogger.AddLogger(new CallbackLogger(debugCallback));
		}
		if (CommandLine.HasVariable("nolog"))
		{
			LogWarning("Usage of the 'nolog' variable will prevent logging");
		}
		LogInfo("Loading Oxide Core v{0}...", Version);
		RootPluginManager = new PluginManager(RootLogger)
		{
			ConfigPath = ConfigDirectory
		};
		extensionManager = new ExtensionManager(RootLogger);
		DataFileSystem = new DataFileSystem(DataDirectory);
		extensionManager.RegisterLibrary("Covalence", covalence = new Covalence());
		extensionManager.RegisterLibrary("Global", new Global());
		extensionManager.RegisterLibrary("Lang", new Lang());
		extensionManager.RegisterLibrary("Permission", libperm = new Permission());
		extensionManager.RegisterLibrary("Plugins", new Plugins(RootPluginManager));
		extensionManager.RegisterLibrary("Time", new Time());
		extensionManager.RegisterLibrary("Timer", libtimer = new Oxide.Core.Libraries.Timer());
		extensionManager.RegisterLibrary("WebRequests", new WebRequests());
		LogInfo("Loading extensions...");
		extensionManager.LoadAllExtensions(ExtensionDirectory);
		Cleanup.Run();
		covalence.Initialize();
		RemoteConsole = new RemoteConsole();
		RemoteConsole?.Initalize();
		if (getTimeSinceStartup == null)
		{
			timer = new Stopwatch();
			timer.Start();
			getTimeSinceStartup = () => (float)timer.Elapsed.TotalSeconds;
			LogWarning("A reliable clock is not available, falling back to a clock which may be unreliable on certain hardware");
		}
		foreach (Extension allExtension in extensionManager.GetAllExtensions())
		{
			allExtension.LoadPluginWatchers(PluginDirectory);
		}
		LogInfo("Loading plugins...");
		LoadAllPlugins(init: true);
		foreach (PluginChangeWatcher pluginChangeWatcher in extensionManager.GetPluginChangeWatchers())
		{
			pluginChangeWatcher.OnPluginSourceChanged += watcher_OnPluginSourceChanged;
			pluginChangeWatcher.OnPluginAdded += watcher_OnPluginAdded;
			pluginChangeWatcher.OnPluginRemoved += watcher_OnPluginRemoved;
		}
	}

	public T GetLibrary<T>(string name = null) where T : Library
	{
		return extensionManager.GetLibrary(name ?? typeof(T).Name) as T;
	}

	public IEnumerable<Extension> GetAllExtensions()
	{
		return extensionManager.GetAllExtensions();
	}

	public Extension GetExtension(string name)
	{
		return extensionManager.GetExtension(name);
	}

	public T GetExtension<T>() where T : Extension
	{
		return extensionManager.GetExtension<T>();
	}

	public IEnumerable<PluginLoader> GetPluginLoaders()
	{
		return extensionManager.GetPluginLoaders();
	}

	public void LogDebug(string format, params object[] args)
	{
		RootLogger.Write(LogType.Warning, "[DEBUG] " + format, args);
	}

	public void LogError(string format, params object[] args)
	{
		RootLogger.Write(LogType.Error, format, args);
	}

	public void LogException(string message, Exception ex)
	{
		RootLogger.WriteException(message, ex);
	}

	public void LogInfo(string format, params object[] args)
	{
		RootLogger.Write(LogType.Info, format, args);
	}

	public void LogWarning(string format, params object[] args)
	{
		RootLogger.Write(LogType.Warning, format, args);
	}

	public void LoadAllPlugins(bool init = false)
	{
		IEnumerable<PluginLoader> enumerable = extensionManager.GetPluginLoaders().ToArray();
		if (!HasLoadedCorePlugins)
		{
			foreach (PluginLoader item in enumerable)
			{
				Type[] corePlugins = item.CorePlugins;
				foreach (Type type in corePlugins)
				{
					try
					{
						Plugin plugin = (Plugin)Activator.CreateInstance(type);
						plugin.IsCorePlugin = true;
						PluginLoaded(plugin);
					}
					catch (Exception ex)
					{
						LogException("Could not load core plugin " + type.Name, ex);
					}
				}
			}
			HasLoadedCorePlugins = true;
		}
		foreach (PluginLoader item2 in enumerable)
		{
			foreach (string item3 in item2.ScanDirectory(PluginDirectory))
			{
				LoadPlugin(item3);
			}
		}
		if (!init)
		{
			return;
		}
		float now = Now;
		foreach (PluginLoader pluginLoader in extensionManager.GetPluginLoaders())
		{
			while (pluginLoader.LoadingPlugins.Count > 0)
			{
				Thread.Sleep(25);
				OnFrame(Now - now);
				now = Now;
			}
		}
		isInitialized = true;
	}

	public void UnloadAllPlugins(IList<string> skip = null)
	{
		Plugin[] array = (from p in RootPluginManager.GetPlugins()
			where !p.IsCorePlugin && (skip == null || !skip.Contains(p.Name))
			select p).ToArray();
		foreach (Plugin plugin in array)
		{
			UnloadPlugin(plugin.Name);
		}
	}

	public void ReloadAllPlugins(IList<string> skip = null)
	{
		Plugin[] array = (from p in RootPluginManager.GetPlugins()
			where !p.IsCorePlugin && (skip == null || !skip.Contains(p.Name))
			select p).ToArray();
		foreach (Plugin plugin in array)
		{
			ReloadPlugin(plugin.Name);
		}
	}

	public bool LoadPlugin(string name)
	{
		if (RootPluginManager.GetPlugin(name) != null)
		{
			return false;
		}
		HashSet<PluginLoader> hashSet = new HashSet<PluginLoader>(from l in extensionManager.GetPluginLoaders()
			where l.ScanDirectory(PluginDirectory).Contains(name)
			select l);
		if (hashSet.Count == 0)
		{
			LogError("Could not load plugin '{0}' (no plugin found with that file name)", name);
			return false;
		}
		if (hashSet.Count > 1)
		{
			LogError("Could not load plugin '{0}' (multiple plugin with that name)", name);
			return false;
		}
		PluginLoader pluginLoader = hashSet.First();
		try
		{
			Plugin plugin = pluginLoader.Load(PluginDirectory, name);
			if (plugin == null)
			{
				return true;
			}
			plugin.Loader = pluginLoader;
			PluginLoaded(plugin);
			return true;
		}
		catch (Exception ex)
		{
			LogException("Could not load plugin " + name, ex);
			return false;
		}
	}

	public bool PluginLoaded(Plugin plugin)
	{
		plugin.OnError += plugin_OnError;
		try
		{
			plugin.Loader?.PluginErrors.Remove(plugin.Name);
			RootPluginManager.AddPlugin(plugin);
			if (plugin.Loader != null && plugin.Loader.PluginErrors.ContainsKey(plugin.Name))
			{
				UnloadPlugin(plugin.Name);
				return false;
			}
			plugin.IsLoaded = true;
			CallHook("OnPluginLoaded", plugin);
			LogInfo("Loaded plugin {0} v{1} by {2}", plugin.Title, plugin.Version, plugin.Author);
			return true;
		}
		catch (Exception ex)
		{
			if (plugin.Loader != null)
			{
				plugin.Loader.PluginErrors[plugin.Name] = ex.Message;
			}
			LogException($"Could not initialize plugin '{plugin.Name} v{plugin.Version}'", ex);
			return false;
		}
	}

	public bool UnloadPlugin(string name)
	{
		Plugin plugin = RootPluginManager.GetPlugin(name);
		if (plugin == null || (plugin.IsCorePlugin && !IsShuttingDown))
		{
			return false;
		}
		extensionManager.GetPluginLoaders().SingleOrDefault((PluginLoader l) => l.LoadedPlugins.ContainsKey(name))?.Unloading(plugin);
		RootPluginManager.RemovePlugin(plugin);
		if (plugin.IsLoaded)
		{
			CallHook("OnPluginUnloaded", plugin);
		}
		plugin.IsLoaded = false;
		LogInfo("Unloaded plugin {0} v{1} by {2}", plugin.Title, plugin.Version, plugin.Author);
		return true;
	}

	public bool ReloadPlugin(string name)
	{
		bool flag = false;
		string directory = PluginDirectory;
		if (name.Contains("\\"))
		{
			flag = true;
			string directoryName = Path.GetDirectoryName(name);
			if (directoryName != null)
			{
				directory = Path.Combine(directory, directoryName);
				name = name.Substring(directoryName.Length + 1);
			}
		}
		PluginLoader pluginLoader = extensionManager.GetPluginLoaders().FirstOrDefault((PluginLoader l) => l.ScanDirectory(directory).Contains(name));
		if (pluginLoader != null)
		{
			pluginLoader.Reload(directory, name);
			return true;
		}
		if (flag)
		{
			return false;
		}
		UnloadPlugin(name);
		LoadPlugin(name);
		return true;
	}

	private void plugin_OnError(Plugin sender, string message)
	{
		LogError("{0} v{1}: {2}", sender.Name, sender.Version, message);
	}

	public bool LoadExtension(string name)
	{
		string path = ((!name.EndsWith(".dll")) ? (name + ".dll") : name);
		string text = Path.Combine(ExtensionDirectory, path);
		if (!File.Exists(text))
		{
			LogError("Could not load extension '" + name + "' (file not found)");
			return false;
		}
		extensionManager.LoadExtension(text);
		return true;
	}

	public bool UnloadExtension(string name)
	{
		string path = ((!name.EndsWith(".dll")) ? (name + ".dll") : name);
		string text = Path.Combine(ExtensionDirectory, path);
		if (!File.Exists(text))
		{
			LogError("Could not unload extension '" + name + "' (file not found)");
			return false;
		}
		extensionManager.UnloadExtension(text);
		return true;
	}

	public bool ReloadExtension(string name)
	{
		string path = ((!name.EndsWith(".dll")) ? (name + ".dll") : name);
		string text = Path.Combine(ExtensionDirectory, path);
		if (!File.Exists(text))
		{
			LogError("Could not reload extension '" + name + "' (file not found)");
			return false;
		}
		extensionManager.ReloadExtension(text);
		return true;
	}

	public object CallHook(string hookname, params object[] args)
	{
		return RootPluginManager?.CallHook(hookname, args);
	}

	public object CallDeprecatedHook(string oldHook, string newHook, DateTime expireDate, params object[] args)
	{
		return RootPluginManager?.CallDeprecatedHook(oldHook, newHook, expireDate, args);
	}

	public void NextTick(Action callback)
	{
		lock (nextTickLock)
		{
			nextTickQueue.Add(callback);
		}
	}

	public void OnFrame(Action<float> callback)
	{
		onFrame = (Action<float>)Delegate.Combine(onFrame, callback);
	}

	public void OnFrame(float delta)
	{
		if (nextTickQueue.Count > 0)
		{
			List<Action> list;
			lock (nextTickLock)
			{
				list = nextTickQueue;
				nextTickQueue = lastTickQueue;
				lastTickQueue = list;
			}
			for (int i = 0; i < list.Count; i++)
			{
				try
				{
					list[i]();
				}
				catch (Exception ex)
				{
					LogException("Exception while calling NextTick callback", ex);
				}
			}
			list.Clear();
		}
		libtimer.Update(delta);
		if (isInitialized)
		{
			ServerConsole?.Update();
			try
			{
				onFrame?.Invoke(delta);
			}
			catch (Exception ex2)
			{
				LogException(ex2.GetType().Name + " while invoke OnFrame in extensions", ex2);
			}
		}
	}

	public void OnSave()
	{
		libperm.SaveData();
	}

	public void OnShutdown()
	{
		if (IsShuttingDown)
		{
			return;
		}
		IsShuttingDown = true;
		UnloadAllPlugins();
		foreach (Extension allExtension in extensionManager.GetAllExtensions())
		{
			allExtension.OnShutdown();
		}
		foreach (string library in extensionManager.GetLibraries())
		{
			extensionManager.GetLibrary(library).Shutdown();
		}
		libperm.SaveData();
		RemoteConsole?.Shutdown("Server shutting down", (CloseStatusCode)1000);
		ServerConsole?.OnDisable();
		RootLogger.Shutdown();
	}

	public void RegisterEngineClock(Func<float> method)
	{
		getTimeSinceStartup = method;
	}

	public bool CheckConsole(bool force = false)
	{
		if (ConsoleWindow.Check(force))
		{
			return Config.Console.Enabled;
		}
		return false;
	}

	public bool EnableConsole(bool force = false)
	{
		if (CheckConsole(force))
		{
			ServerConsole = new ServerConsole();
			ServerConsole.OnEnable();
			return true;
		}
		return false;
	}

	private void watcher_OnPluginSourceChanged(string name)
	{
		ReloadPlugin(name);
	}

	private void watcher_OnPluginAdded(string name)
	{
		LoadPlugin(name);
	}

	private void watcher_OnPluginRemoved(string name)
	{
		UnloadPlugin(name);
	}

	private static void RegisterLibrarySearchPath(string path)
	{
		switch (Environment.OSVersion.Platform)
		{
		case PlatformID.Win32S:
		case PlatformID.Win32Windows:
		case PlatformID.Win32NT:
		{
			string text3 = Environment.GetEnvironmentVariable("PATH") ?? string.Empty;
			string text4;
			if (!string.IsNullOrEmpty(text3))
			{
				char pathSeparator = Path.PathSeparator;
				text4 = text3 + pathSeparator + path;
			}
			else
			{
				text4 = path;
			}
			string value2 = text4;
			Environment.SetEnvironmentVariable("PATH", value2);
			SetDllDirectory(path);
			break;
		}
		case PlatformID.Unix:
		case PlatformID.MacOSX:
		{
			string text = Environment.GetEnvironmentVariable("LD_LIBRARY_PATH") ?? string.Empty;
			string text2;
			if (!string.IsNullOrEmpty(text))
			{
				char pathSeparator = Path.PathSeparator;
				text2 = text + pathSeparator + path;
			}
			else
			{
				text2 = path;
			}
			string value = text2;
			Environment.SetEnvironmentVariable("LD_LIBRARY_PATH", value);
			break;
		}
		case PlatformID.WinCE:
		case PlatformID.Xbox:
			break;
		}
	}

	[DllImport("kernel32", SetLastError = true)]
	private static extern bool SetDllDirectory(string lpPathName);
}


using System;
using System.Collections.Generic;
using System.IO;
using Oxide.Core;
using ProtoBuf;

public class ProtoStorage
{
	public static IEnumerable<string> GetFiles(string subDirectory)
	{
		string fileDataPath = GetFileDataPath(subDirectory.Replace("..", ""));
		if (Directory.Exists(fileDataPath))
		{
			string[] files = Directory.GetFiles(fileDataPath, "*.data");
			foreach (string value in files)
			{
				yield return Utility.GetFileNameWithoutExtension(value);
			}
		}
	}

	public static T Load<T>(params string[] subPaths)
	{
		string fileName = GetFileName(subPaths);
		string fileDataPath = GetFileDataPath(fileName);
		try
		{
			if (File.Exists(fileDataPath))
			{
				using (FileStream fileStream = File.OpenRead(fileDataPath))
				{
					return Serializer.Deserialize<T>((Stream)fileStream);
				}
			}
		}
		catch (Exception ex)
		{
			Interface.Oxide.LogException("Failed to load protobuf data from " + fileName, ex);
		}
		return default(T);
	}

	public static void Save<T>(T data, params string[] subPaths)
	{
		string fileName = GetFileName(subPaths);
		string fileDataPath = GetFileDataPath(fileName);
		string directoryName = Path.GetDirectoryName(fileDataPath);
		try
		{
			if (directoryName != null && !Directory.Exists(directoryName))
			{
				Directory.CreateDirectory(directoryName);
			}
			FileMode mode = (File.Exists(fileDataPath) ? FileMode.Truncate : FileMode.Create);
			using FileStream fileStream = File.Open(fileDataPath, mode);
			Serializer.Serialize<T>((Stream)fileStream, data);
		}
		catch (Exception ex)
		{
			Interface.Oxide.LogException("Failed to save protobuf data to " + fileName, ex);
		}
	}

	public static bool Exists(params string[] subPaths)
	{
		return File.Exists(GetFileDataPath(GetFileName(subPaths)));
	}

	public static string GetFileName(params string[] subPaths)
	{
		char directorySeparatorChar = Path.DirectorySeparatorChar;
		return string.Join(directorySeparatorChar.ToString(), subPaths).Replace("..", "") + ".data";
	}

	public static string GetFileDataPath(string name)
	{
		return Path.Combine(Interface.Oxide.DataDirectory, name);
	}
}


using System;

public static class Random
{
	private static readonly Random random;

	static Random()
	{
		random = new Random();
	}

	public static int Range(int min, int max)
	{
		return random.Next(min, max);
	}

	public static int Range(int max)
	{
		return random.Next(max);
	}

	public static double Range(double min, double max)
	{
		return min + random.NextDouble() * (max - min);
	}

	public static float Range(float min, float max)
	{
		return (float)Range((double)min, (double)max);
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Extensions;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;

public static class RemoteLogger
{
	private class QueuedReport
	{
		public readonly Dictionary<string, string> Headers;

		public readonly string Body;

		public QueuedReport(Report report)
		{
			Headers = BuildHeaders();
			Body = JsonConvert.SerializeObject((object)report);
		}
	}

	public class Report
	{
		public string message;

		public string level;

		public string culprit;

		public string platform = "csharp";

		public string release = OxideMod.Version.ToString();

		public Dictionary<string, string> tags = Tags;

		public Dictionary<string, string> modules;

		public Dictionary<string, string> extra;

		private Dictionary<string, string> headers;

		public Report(string level, string culprit, string message, string exception = null)
		{
			headers = BuildHeaders();
			this.level = level;
			this.message = ((message.Length > 1000) ? message.Substring(0, 1000) : message);
			this.culprit = culprit;
			modules = new Dictionary<string, string>();
			foreach (Extension allExtension in Interface.Oxide.GetAllExtensions())
			{
				modules[allExtension.GetType().Assembly.GetName().Name] = allExtension.Version.ToString();
			}
			if (exception == null)
			{
				return;
			}
			extra = new Dictionary<string, string>();
			string[] array = exception.Split(new char[1] { '\n' }).Take(31).ToArray();
			for (int i = 0; i < array.Length; i++)
			{
				string text = array[i].Trim(' ', '\r', '\n').Replace('\t', ' ');
				if (text.Length > 0)
				{
					extra["line_" + i.ToString("00")] = text;
				}
			}
		}

		public void DetectModules(Assembly assembly)
		{
			if (!(assembly.GetTypes().FirstOrDefault((Type t) => t.BaseType == typeof(Extension)) == null))
			{
				return;
			}
			Type type = assembly.GetTypes().FirstOrDefault((Type t) => IsTypeDerivedFrom(t, typeof(Plugin)));
			if (type != null)
			{
				Plugin plugin = Interface.Oxide.RootPluginManager.GetPlugin(type.Name);
				if (plugin != null)
				{
					modules["Plugins." + plugin.Name] = plugin.Version.ToString();
				}
			}
		}

		public void DetectModules(string[] stackTrace)
		{
			foreach (string text in stackTrace)
			{
				if (text.StartsWith("Oxide.Plugins.PluginCompiler") && text.Contains("+"))
				{
					string name = text.Split(new char[1] { '+' })[0];
					Plugin plugin = Interface.Oxide.RootPluginManager.GetPlugin(name);
					if (plugin != null)
					{
						modules["Plugins." + plugin.Name] = plugin.Version.ToString();
					}
					break;
				}
			}
		}

		private static bool IsTypeDerivedFrom(Type type, Type baseType)
		{
			while (type != null && type != baseType)
			{
				if ((type = type.BaseType) == baseType)
				{
					return true;
				}
			}
			return false;
		}
	}

	private const int projectId = 141692;

	private const string host = "sentry.io";

	private const string publicKey = "2d0162c790be4036a94d2d8326d7f900";

	private const string secretKey = "8a6249aad4b84e368f900b32396e8b04";

	private static readonly string Url = "https://sentry.io/api/" + 141692 + "/store/";

	private static readonly string[][] sentryAuth = new string[4][]
	{
		new string[2] { "sentry_version", "7" },
		new string[2] { "sentry_client", "MiniRaven/1.0" },
		new string[2] { "sentry_key", "2d0162c790be4036a94d2d8326d7f900" },
		new string[2] { "sentry_secret", "8a6249aad4b84e368f900b32396e8b04" }
	};

	public static string Filename = Utility.GetFileNameWithoutExtension(Process.GetCurrentProcess().MainModule.FileName);

	private static readonly Dictionary<string, string> Tags = new Dictionary<string, string>
	{
		{
			"arch",
			(IntPtr.Size == 8) ? "x64" : "x86"
		},
		{
			"platform",
			Environment.OSVersion.Platform.ToString().ToLower()
		},
		{
			"os version",
			Environment.OSVersion.Version.ToString().ToLower()
		},
		{
			"game",
			Filename.ToLower().Replace("dedicated", "").Replace("server", "")
				.Replace("-", "")
				.Replace("_", "")
		}
	};

	private static readonly Timer Timers = Interface.Oxide.GetLibrary<Timer>();

	private static readonly WebRequests Webrequests = Interface.Oxide.GetLibrary<WebRequests>();

	private static readonly List<QueuedReport> QueuedReports = new List<QueuedReport>();

	private static bool submittingReports;

	public static string[] ExceptionFilter = new string[12]
	{
		"BadImageFormatException", "DllNotFoundException", "FileNotFoundException", "IOException", "KeyNotFoundException", "Oxide.Core.Configuration", "Oxide.Ext.", "Oxide.Plugins.<", "ReflectionTypeLoadException", "Sharing violation",
		"UnauthorizedAccessException", "WebException"
	};

	private static Dictionary<string, string> BuildHeaders()
	{
		string text = string.Join(", ", sentryAuth.Select((string[] x) => string.Join("=", x)).ToArray());
		text = text + ", sentry_timestamp=" + (int)DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
		return new Dictionary<string, string> { 
		{
			"X-Sentry-Auth",
			"Sentry " + text
		} };
	}

	public static void SetTag(string name, string value)
	{
		Tags[name] = value;
	}

	public static string GetTag(string name)
	{
		if (!Tags.TryGetValue(name, out var value))
		{
			return "unknown";
		}
		return value;
	}

	public static void Debug(string message)
	{
		EnqueueReport("debug", Assembly.GetCallingAssembly(), GetCurrentMethod(), message);
	}

	public static void Error(string message)
	{
		EnqueueReport("error", Assembly.GetCallingAssembly(), GetCurrentMethod(), message);
	}

	public static void Info(string message)
	{
		EnqueueReport("info", Assembly.GetCallingAssembly(), GetCurrentMethod(), message);
	}

	public static void Warning(string message)
	{
		EnqueueReport("warning", Assembly.GetCallingAssembly(), GetCurrentMethod(), message);
	}

	public static void Exception(string message, Exception exception)
	{
		if (!exception.StackTrace.Contains("Oxide.Core") && !exception.StackTrace.Contains("Oxide.Plugins.Compiler"))
		{
			return;
		}
		string[] exceptionFilter = ExceptionFilter;
		foreach (string value in exceptionFilter)
		{
			if (exception.StackTrace.Contains(value) || message.Contains(value))
			{
				return;
			}
		}
		EnqueueReport("fatal", Assembly.GetCallingAssembly(), GetCurrentMethod(), message, exception.ToString());
	}

	public static void Exception(string message, string rawStackTrace)
	{
		string[] array = rawStackTrace.Split('\r', '\n');
		string culprit = array[0].Split(new char[1] { '(' })[0].Trim();
		EnqueueReport("fatal", array, culprit, message, rawStackTrace);
	}

	private static void EnqueueReport(string level, Assembly assembly, string culprit, string message, string exception = null)
	{
		Report report = new Report(level, culprit, message, exception);
		report.DetectModules(assembly);
		EnqueueReport(report);
	}

	private static void EnqueueReport(string level, string[] stackTrace, string culprit, string message, string exception = null)
	{
		Report report = new Report(level, culprit, message, exception);
		report.DetectModules(stackTrace);
		EnqueueReport(report);
	}

	private static void EnqueueReport(Report report)
	{
		Dictionary<string, string>.ValueCollection values = report.extra.Values;
		if (!values.Contains("Oxide.Core") && !values.Contains("Oxide.Plugins.Compiler"))
		{
			return;
		}
		string[] exceptionFilter = ExceptionFilter;
		foreach (string value in exceptionFilter)
		{
			if (values.Contains(value) || values.Contains(value))
			{
				return;
			}
		}
		QueuedReports.Add(new QueuedReport(report));
		if (!submittingReports)
		{
			SubmitNextReport();
		}
	}

	private static void SubmitNextReport()
	{
		if (QueuedReports.Count < 1)
		{
			return;
		}
		QueuedReport queuedReport = QueuedReports[0];
		submittingReports = true;
		Webrequests.Enqueue(Url, queuedReport.Body, delegate(int code, string response)
		{
			if (code == 200)
			{
				QueuedReports.RemoveAt(0);
				submittingReports = false;
				SubmitNextReport();
			}
			else
			{
				Timers.Once(5f, SubmitNextReport);
			}
		}, null, RequestMethod.POST, queuedReport.Headers);
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static string GetCurrentMethod()
	{
		MethodBase method = new StackTrace().GetFrame(2).GetMethod();
		return method.DeclaringType?.FullName + "." + method.Name;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class ConcurrentHashSet<T> : ICollection<T>, IEnumerable<T>, IEnumerable
{
	private readonly HashSet<T> collection;

	private readonly object syncRoot = new object();

	public bool IsReadOnly => false;

	public int Count
	{
		get
		{
			lock (syncRoot)
			{
				return collection.Count;
			}
		}
	}

	public ConcurrentHashSet()
	{
		collection = new HashSet<T>();
	}

	public ConcurrentHashSet(ICollection<T> values)
	{
		collection = new HashSet<T>(values);
	}

	public bool Contains(T value)
	{
		lock (syncRoot)
		{
			return collection.Contains(value);
		}
	}

	public bool Add(T value)
	{
		lock (syncRoot)
		{
			return collection.Add(value);
		}
	}

	public bool Remove(T value)
	{
		lock (syncRoot)
		{
			return collection.Remove(value);
		}
	}

	public void Clear()
	{
		lock (syncRoot)
		{
			collection.Clear();
		}
	}

	public void CopyTo(T[] array, int index)
	{
		lock (syncRoot)
		{
			collection.CopyTo(array, index);
		}
	}

	public IEnumerator<T> GetEnumerator()
	{
		return collection.GetEnumerator();
	}

	public bool Any(Func<T, bool> callback)
	{
		lock (syncRoot)
		{
			return collection.Any(callback);
		}
	}

	public T[] ToArray()
	{
		lock (syncRoot)
		{
			return collection.ToArray();
		}
	}

	public bool TryDequeue(out T value)
	{
		lock (syncRoot)
		{
			value = collection.ElementAtOrDefault(0);
			if (value != null)
			{
				collection.Remove(value);
			}
			return value != null;
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}

	void ICollection<T>.Add(T value)
	{
		Add(value);
	}
}


using System;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core;

public class Utility
{
	public static void DatafileToProto<T>(string name, bool deleteAfter = true)
	{
		DataFileSystem dataFileSystem = Interface.Oxide.DataFileSystem;
		if (!dataFileSystem.ExistsDatafile(name))
		{
			return;
		}
		if (ProtoStorage.Exists(name))
		{
			Interface.Oxide.LogWarning("Failed to import JSON file: {0} already exists.", name);
			return;
		}
		try
		{
			ProtoStorage.Save(dataFileSystem.ReadObject<T>(name), name);
			if (deleteAfter)
			{
				File.Delete(dataFileSystem.GetFile(name).Filename);
			}
		}
		catch (Exception ex)
		{
			Interface.Oxide.LogException("Failed to convert datafile to proto storage: " + name, ex);
		}
	}

	public static void PrintCallStack()
	{
		Interface.Oxide.LogDebug("CallStack:{0}{1}", Environment.NewLine, new StackTrace(1, fNeedFileInfo: true));
	}

	public static string FormatBytes(double bytes)
	{
		string arg;
		if (bytes > 1048576.0)
		{
			arg = "mb";
			bytes /= 1048576.0;
		}
		else if (bytes > 1024.0)
		{
			arg = "kb";
			bytes /= 1024.0;
		}
		else
		{
			arg = "b";
		}
		return $"{bytes:0}{arg}";
	}

	public static string GetDirectoryName(string name)
	{
		try
		{
			name = name.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
			return name.Substring(0, name.LastIndexOf(Path.DirectorySeparatorChar));
		}
		catch
		{
			return null;
		}
	}

	public static string GetFileNameWithoutExtension(string value)
	{
		int num = value.Length - 1;
		for (int num2 = num; num2 >= 1; num2--)
		{
			if (value[num2] == '.')
			{
				num = num2 - 1;
				break;
			}
		}
		int num3 = 0;
		for (int num4 = num - 1; num4 >= 0; num4--)
		{
			char c = value[num4];
			if (c == '/' || c == '\\')
			{
				num3 = num4 + 1;
				break;
			}
		}
		return value.Substring(num3, num - num3 + 1);
	}

	public static string CleanPath(string path)
	{
		return path?.Replace('\\', Path.DirectorySeparatorChar).Replace('/', Path.DirectorySeparatorChar);
	}

	public static T ConvertFromJson<T>(string jsonstr)
	{
		return JsonConvert.DeserializeObject<T>(jsonstr);
	}

	public static string ConvertToJson(object obj, bool indented = false)
	{
		return JsonConvert.SerializeObject(obj, (Formatting)(indented ? 1 : 0));
	}

	public static IPAddress GetLocalIP()
	{
		UnicastIPAddressInformation unicastIPAddressInformation = null;
		NetworkInterface[] allNetworkInterfaces = NetworkInterface.GetAllNetworkInterfaces();
		foreach (NetworkInterface networkInterface in allNetworkInterfaces)
		{
			if (networkInterface.OperationalStatus != OperationalStatus.Up)
			{
				continue;
			}
			IPInterfaceProperties iPProperties = networkInterface.GetIPProperties();
			if (iPProperties.GatewayAddresses.Count == 0 || iPProperties.GatewayAddresses[0].Address.Equals(IPAddress.Parse("0.0.0.0")))
			{
				continue;
			}
			foreach (UnicastIPAddressInformation unicastAddress in iPProperties.UnicastAddresses)
			{
				if (unicastAddress.Address.AddressFamily != AddressFamily.InterNetwork || IPAddress.IsLoopback(unicastAddress.Address))
				{
					continue;
				}
				if (!unicastAddress.IsDnsEligible)
				{
					if (unicastIPAddressInformation == null)
					{
						unicastIPAddressInformation = unicastAddress;
					}
					continue;
				}
				try
				{
					if (unicastAddress.PrefixOrigin != PrefixOrigin.Dhcp)
					{
						if (unicastIPAddressInformation == null || !unicastIPAddressInformation.IsDnsEligible)
						{
							unicastIPAddressInformation = unicastAddress;
						}
						continue;
					}
				}
				catch
				{
				}
				return unicastAddress.Address;
			}
		}
		return unicastIPAddressInformation?.Address;
	}

	public static bool IsLocalIP(string ipAddress)
	{
		string[] array = ipAddress.Split(new string[1] { "." }, StringSplitOptions.RemoveEmptyEntries);
		int[] array2 = new int[4]
		{
			int.Parse(array[0]),
			int.Parse(array[1]),
			int.Parse(array[2]),
			int.Parse(array[3])
		};
		if (array2[0] != 0 && array2[0] != 10 && (array2[0] != 100 || array2[1] != 64) && array2[0] != 127 && (array2[0] != 192 || array2[1] != 168))
		{
			if (array2[0] == 172 && array2[1] >= 16)
			{
				return array2[1] <= 31;
			}
			return false;
		}
		return true;
	}

	public static bool ValidateIPv4(string ipAddress)
	{
		if (!string.IsNullOrEmpty(ipAddress.Trim()))
		{
			string[] array = ipAddress.Replace("\"", string.Empty).Trim().Split(new char[1] { '.' });
			byte result;
			if (array.Length == 4)
			{
				return array.All((string r) => byte.TryParse(r, out result));
			}
			return false;
		}
		return false;
	}

	public static int GetNumbers(string input)
	{
		int.TryParse(Regex.Replace(input, "[^.0-9]", ""), out var result);
		return result;
	}
}


using Oxide.Core;

public struct VersionNumber
{
	public int Major;

	public int Minor;

	public int Patch;

	public VersionNumber(int major, int minor, int patch)
	{
		Major = major;
		Minor = minor;
		Patch = patch;
	}

	public override string ToString()
	{
		return $"{Major}.{Minor}.{Patch}";
	}

	public static bool operator ==(VersionNumber a, VersionNumber b)
	{
		if (a.Major == b.Major && a.Minor == b.Minor)
		{
			return a.Patch == b.Patch;
		}
		return false;
	}

	public static bool operator !=(VersionNumber a, VersionNumber b)
	{
		if (a.Major == b.Major && a.Minor == b.Minor)
		{
			return a.Patch != b.Patch;
		}
		return true;
	}

	public static bool operator >(VersionNumber a, VersionNumber b)
	{
		if (a.Major < b.Major)
		{
			return false;
		}
		if (a.Major > b.Major)
		{
			return true;
		}
		if (a.Minor < b.Minor)
		{
			return false;
		}
		if (a.Minor > b.Minor)
		{
			return true;
		}
		return a.Patch > b.Patch;
	}

	public static bool operator >=(VersionNumber a, VersionNumber b)
	{
		if (a.Major < b.Major)
		{
			return false;
		}
		if (a.Major > b.Major)
		{
			return true;
		}
		if (a.Minor < b.Minor)
		{
			return false;
		}
		if (a.Minor > b.Minor)
		{
			return true;
		}
		return a.Patch >= b.Patch;
	}

	public static bool operator <(VersionNumber a, VersionNumber b)
	{
		if (a.Major > b.Major)
		{
			return false;
		}
		if (a.Major < b.Major)
		{
			return true;
		}
		if (a.Minor > b.Minor)
		{
			return false;
		}
		if (a.Minor < b.Minor)
		{
			return true;
		}
		return a.Patch < b.Patch;
	}

	public static bool operator <=(VersionNumber a, VersionNumber b)
	{
		if (a.Major > b.Major)
		{
			return false;
		}
		if (a.Major < b.Major)
		{
			return true;
		}
		if (a.Minor > b.Minor)
		{
			return false;
		}
		if (a.Minor < b.Minor)
		{
			return true;
		}
		return a.Patch <= b.Patch;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is VersionNumber versionNumber))
		{
			return false;
		}
		return this == versionNumber;
	}

	public override int GetHashCode()
	{
		return ((17 * 23 + Major.GetHashCode()) * 23 + Minor.GetHashCode()) * 23 + Patch.GetHashCode();
	}
}


using System;
using System.Globalization;
using Newtonsoft.Json;
using Oxide.Core;

public class VersionNumberShortConverter : JsonConverter
{
	private static readonly char[] separators = new char[1] { '.' };

	private static readonly Type vNumberType = typeof(VersionNumber);

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		Type type = value?.GetType();
		if (type != vNumberType)
		{
			throw new JsonSerializationException("Expected value of type VersionNumber, but got " + (type?.Name ?? "null"));
		}
		writer.WriteValue(ConvertToString((VersionNumber)value));
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Invalid comparison between Unknown and I4
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if ((int)reader.TokenType == 9)
		{
			try
			{
				return ParseFromString((string)reader.Value);
			}
			catch (Exception ex)
			{
				throw GenerateException(reader, "Failed to parse VersionNumber from '{0}': {1}", reader.Value, ex.Message);
			}
		}
		throw GenerateException(reader, "Unexpected token '{0}' ({1}) on VersionNumber deserialization. Expected: 'String'", reader.TokenType, reader.Value ?? "null");
	}

	public override bool CanConvert(Type objectType)
	{
		return objectType == vNumberType;
	}

	private static JsonSerializationException GenerateException(JsonReader reader, string format, params object[] args)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Expected O, but got Unknown
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Expected O, but got Unknown
		string text = string.Format(format, args);
		IJsonLineInfo val = (IJsonLineInfo)reader;
		if (val.HasLineInfo())
		{
			text += $" at {val.LineNumber}:{val.LinePosition}";
		}
		return new JsonSerializationException(text);
	}

	private string ConvertToString(VersionNumber number)
	{
		return number.ToString();
	}

	private VersionNumber ParseFromString(string strNumber)
	{
		string[] array = strNumber.Split(separators, StringSplitOptions.RemoveEmptyEntries);
		if (array.Length < 1 || array.Length > 3)
		{
			throw new ArgumentException("String does not match the VersionNumber serialization format", "strNumber");
		}
		int[] array2 = new int[3];
		for (int i = 0; i < array.Length; i++)
		{
			int num = int.Parse(array[i], NumberStyles.Integer);
			array2[i] = num;
		}
		return new VersionNumber(array2[0], array2[1], array2[2]);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;

public class ConsoleInput
{
	private string inputString = string.Empty;

	private readonly List<string> inputHistory = new List<string>();

	private int inputHistoryIndex;

	private float nextUpdate;

	internal readonly string[] StatusTextLeft = new string[4]
	{
		string.Empty,
		string.Empty,
		string.Empty,
		string.Empty
	};

	internal readonly string[] StatusTextRight = new string[4]
	{
		string.Empty,
		string.Empty,
		string.Empty,
		string.Empty
	};

	internal readonly ConsoleColor[] StatusTextLeftColor = new ConsoleColor[4]
	{
		ConsoleColor.White,
		ConsoleColor.White,
		ConsoleColor.White,
		ConsoleColor.White
	};

	internal readonly ConsoleColor[] StatusTextRightColor = new ConsoleColor[4]
	{
		ConsoleColor.White,
		ConsoleColor.White,
		ConsoleColor.White,
		ConsoleColor.White
	};

	public Func<string, string[]> Completion;

	public int LineWidth => Console.BufferWidth;

	public bool Valid => Console.BufferWidth > 0;

	internal event Action<string> OnInputText;

	public void ClearLine(int numLines)
	{
		Console.CursorLeft = 0;
		Console.Write(new string(' ', LineWidth * numLines));
		Console.CursorTop -= numLines;
		Console.CursorLeft = 0;
	}

	public void RedrawInputLine()
	{
		if (nextUpdate - 0.45f > Interface.Oxide.Now || LineWidth <= 0)
		{
			return;
		}
		try
		{
			Console.CursorTop++;
			for (int i = 0; i < StatusTextLeft.Length; i++)
			{
				if (!Interface.Oxide.Config.Console.ShowStatusBar)
				{
					break;
				}
				Console.CursorLeft = 0;
				Console.ForegroundColor = StatusTextLeftColor[i];
				Console.Write(StatusTextLeft[i].Substring(0, Math.Min(StatusTextLeft[i].Length, LineWidth - 1)));
				Console.ForegroundColor = StatusTextRightColor[i];
				Console.Write(StatusTextRight[i].PadRight(LineWidth));
			}
			Console.CursorTop -= ((!Interface.Oxide.Config.Console.ShowStatusBar) ? 1 : (StatusTextLeft.Length + 1));
			Console.CursorLeft = 0;
			Console.BackgroundColor = ConsoleColor.Black;
			Console.ForegroundColor = ConsoleColor.Green;
			ClearLine(1);
			if (inputString.Length == 0)
			{
				Console.ForegroundColor = ConsoleColor.Gray;
				return;
			}
			Console.Write((inputString.Length >= LineWidth - 2) ? inputString.Substring(inputString.Length - (LineWidth - 2)) : inputString);
			Console.ForegroundColor = ConsoleColor.Gray;
		}
		catch (Exception ex)
		{
			Interface.Oxide.LogException("RedrawInputLine: ", ex);
		}
	}

	public void Update()
	{
		if (!Valid)
		{
			return;
		}
		if (nextUpdate < Interface.Oxide.Now)
		{
			RedrawInputLine();
			nextUpdate = Interface.Oxide.Now + 0.5f;
		}
		try
		{
			if (!Console.KeyAvailable)
			{
				return;
			}
		}
		catch (Exception)
		{
			return;
		}
		ConsoleKeyInfo consoleKeyInfo = Console.ReadKey();
		if (consoleKeyInfo.Key != ConsoleKey.DownArrow && consoleKeyInfo.Key != ConsoleKey.UpArrow)
		{
			inputHistoryIndex = 0;
		}
		switch (consoleKeyInfo.Key)
		{
		case ConsoleKey.Enter:
		{
			ClearLine((!Interface.Oxide.Config.Console.ShowStatusBar) ? 1 : StatusTextLeft.Length);
			Console.ForegroundColor = ConsoleColor.Green;
			Console.WriteLine("> " + inputString);
			inputHistory.Insert(0, inputString);
			if (inputHistory.Count > 50)
			{
				inputHistory.RemoveRange(50, inputHistory.Count - 50);
			}
			string obj = inputString;
			inputString = string.Empty;
			this.OnInputText?.Invoke(obj);
			RedrawInputLine();
			break;
		}
		case ConsoleKey.Backspace:
			if (inputString.Length >= 1)
			{
				inputString = inputString.Substring(0, inputString.Length - 1);
				RedrawInputLine();
			}
			break;
		case ConsoleKey.Escape:
			inputString = string.Empty;
			RedrawInputLine();
			break;
		case ConsoleKey.UpArrow:
			if (inputHistory.Count != 0)
			{
				if (inputHistoryIndex < 0)
				{
					inputHistoryIndex = 0;
				}
				if (inputHistoryIndex >= inputHistory.Count - 1)
				{
					inputHistoryIndex = inputHistory.Count - 1;
					inputString = inputHistory[inputHistoryIndex];
					RedrawInputLine();
				}
				else
				{
					inputString = inputHistory[inputHistoryIndex++];
					RedrawInputLine();
				}
			}
			break;
		case ConsoleKey.DownArrow:
			if (inputHistory.Count != 0)
			{
				if (inputHistoryIndex >= inputHistory.Count - 1)
				{
					inputHistoryIndex = inputHistory.Count - 2;
				}
				inputString = ((inputHistoryIndex < 0) ? string.Empty : inputHistory[inputHistoryIndex--]);
				RedrawInputLine();
			}
			break;
		case ConsoleKey.Tab:
		{
			string[] array = Completion?.Invoke(inputString);
			if (array == null || array.Length == 0)
			{
				break;
			}
			if (array.Length > 1)
			{
				ClearLine((!Interface.Oxide.Config.Console.ShowStatusBar) ? 1 : (StatusTextLeft.Length + 1));
				Console.ForegroundColor = ConsoleColor.Yellow;
				int num = array.Max((string r) => r.Length);
				for (int i = 0; i < array.Length; i++)
				{
					string text = array[i];
					if (i > 0)
					{
						int firstDiffIndex = GetFirstDiffIndex(array[0], text);
						if (firstDiffIndex > 0 && firstDiffIndex < num)
						{
							num = firstDiffIndex;
						}
					}
					Console.WriteLine(text);
				}
				if (num > 0)
				{
					inputString = array[0].Substring(0, num);
				}
				RedrawInputLine();
			}
			else
			{
				inputString = array[0];
				RedrawInputLine();
			}
			break;
		}
		default:
			if (consoleKeyInfo.KeyChar != 0)
			{
				inputString += consoleKeyInfo.KeyChar;
				RedrawInputLine();
			}
			break;
		}
	}

	private static int GetFirstDiffIndex(string str1, string str2)
	{
		if (str1 == null || str2 == null)
		{
			return -1;
		}
		int num = Math.Min(str1.Length, str2.Length);
		for (int i = 0; i < num; i++)
		{
			if (str1[i] != str2[i])
			{
				return i;
			}
		}
		return num;
	}
}


using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using Microsoft.Win32.SafeHandles;

public class ConsoleWindow
{
	private const uint ATTACH_PARENT_PROCESS = uint.MaxValue;

	private const int STD_OUTPUT_HANDLE = -11;

	private TextWriter oldOutput;

	private Encoding oldEncoding;

	[DllImport("kernel32.dll", SetLastError = true)]
	private static extern bool AllocConsole();

	[DllImport("kernel32.dll", SetLastError = true)]
	private static extern bool AttachConsole(uint dwProcessId);

	[DllImport("kernel32.dll", SetLastError = true)]
	private static extern bool FreeConsole();

	[DllImport("kernel32.dll")]
	private static extern IntPtr GetConsoleWindow();

	[DllImport("kernel32.dll")]
	private static extern bool SetConsoleOutputCP(uint wCodePageId);

	[DllImport("kernel32.dll")]
	private static extern bool SetConsoleTitle(string lpConsoleTitle);

	[DllImport("kernel32.dll", CharSet = CharSet.Auto)]
	private static extern IntPtr GetModuleHandle(string lpModuleName);

	[DllImport("kernel32.dll", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
	private static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

	[DllImport("kernel32.dll", SetLastError = true)]
	private static extern IntPtr GetStdHandle(int nStdHandle);

	public static bool Check(bool force = false)
	{
		PlatformID platform = Environment.OSVersion.Platform;
		if ((uint)platform <= 2u)
		{
			IntPtr moduleHandle = GetModuleHandle("ntdll.dll");
			if (moduleHandle == IntPtr.Zero)
			{
				return false;
			}
			if (GetProcAddress(moduleHandle, "wine_get_version") == IntPtr.Zero)
			{
				if (!force)
				{
					return GetConsoleWindow() == IntPtr.Zero;
				}
				return true;
			}
			return false;
		}
		return false;
	}

	public void SetTitle(string title)
	{
		if (title != null)
		{
			SetConsoleTitle(title);
		}
	}

	public bool Initialize()
	{
		if (!AttachConsole(uint.MaxValue))
		{
			AllocConsole();
		}
		if (GetConsoleWindow() == IntPtr.Zero)
		{
			FreeConsole();
			return false;
		}
		oldOutput = Console.Out;
		oldEncoding = Console.OutputEncoding;
		UTF8Encoding uTF8Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
		SetConsoleOutputCP((uint)uTF8Encoding.CodePage);
		Console.OutputEncoding = uTF8Encoding;
		Stream stream;
		try
		{
			stream = new FileStream(new SafeFileHandle(GetStdHandle(-11), ownsHandle: true), FileAccess.Write);
		}
		catch (Exception)
		{
			stream = Console.OpenStandardOutput();
		}
		Console.SetOut(new StreamWriter(stream, uTF8Encoding)
		{
			AutoFlush = true
		});
		return true;
	}

	public void Shutdown()
	{
		if (oldOutput != null)
		{
			Console.SetOut(oldOutput);
		}
		if (oldEncoding != null)
		{
			SetConsoleOutputCP((uint)oldEncoding.CodePage);
			Console.OutputEncoding = oldEncoding;
		}
		FreeConsole();
	}
}


using System;
using System.Linq;
using Oxide.Core;
using Oxide.Core.ServerConsole;

public class ServerConsole
{
	private readonly ConsoleWindow console = new ConsoleWindow();

	private readonly ConsoleInput input = new ConsoleInput();

	private bool init;

	private float nextUpdate;

	private float nextTitleUpdate;

	public Func<string> Title;

	public Func<string> Status1Left;

	public Func<string> Status1Right;

	public Func<string> Status2Left;

	public Func<string> Status2Right;

	public Func<string> Status3Left;

	public Func<string> Status3Right;

	public Func<string, string[]> Completion
	{
		get
		{
			return input.Completion;
		}
		set
		{
			input.Completion = value;
		}
	}

	public ConsoleColor Status1LeftColor
	{
		get
		{
			return input.StatusTextLeftColor[1];
		}
		set
		{
			input.StatusTextLeftColor[1] = value;
		}
	}

	public ConsoleColor Status1RightColor
	{
		get
		{
			return input.StatusTextRightColor[1];
		}
		set
		{
			input.StatusTextRightColor[1] = value;
		}
	}

	public ConsoleColor Status2LeftColor
	{
		get
		{
			return input.StatusTextLeftColor[2];
		}
		set
		{
			input.StatusTextLeftColor[2] = value;
		}
	}

	public ConsoleColor Status2RightColor
	{
		get
		{
			return input.StatusTextRightColor[2];
		}
		set
		{
			input.StatusTextRightColor[2] = value;
		}
	}

	public ConsoleColor Status3RightColor
	{
		get
		{
			return input.StatusTextRightColor[3];
		}
		set
		{
			input.StatusTextRightColor[3] = value;
		}
	}

	public ConsoleColor Status3LeftColor
	{
		get
		{
			return input.StatusTextLeftColor[3];
		}
		set
		{
			input.StatusTextLeftColor[3] = value;
		}
	}

	private string title => Title?.Invoke();

	private string status1Left => GetStatusValue(Status1Left);

	private string status1Right => GetStatusValue(Status1Right).PadLeft(input.LineWidth - 1);

	private string status2Left => GetStatusValue(Status2Left);

	private string status2Right => GetStatusValue(Status2Right).PadLeft(input.LineWidth - 1);

	private string status3Left => GetStatusValue(Status3Left);

	private string status3Right => GetStatusValue(Status3Right).PadLeft(input.LineWidth - 1);

	public event Action<string> Input;

	private static string GetStatusValue(Func<string> status)
	{
		if (status == null)
		{
			return "";
		}
		return status() ?? string.Empty;
	}

	private static string GetStatusRight(int leftLength, string right)
	{
		if (leftLength < right.Length)
		{
			return right.Substring(leftLength);
		}
		return string.Empty;
	}

	public void AddMessage(string message, ConsoleColor color = ConsoleColor.Gray)
	{
		Console.ForegroundColor = color;
		int num = message.Split(new char[1] { '\n' }).Aggregate(0, (int sum, string line) => sum + (int)Math.Ceiling((double)line.Length / (double)Console.BufferWidth));
		input.ClearLine((Interface.Oxide.Config.Console.ShowStatusBar ? input.StatusTextLeft.Length : 0) + num);
		Console.WriteLine(message);
		input.RedrawInputLine();
		Console.ForegroundColor = ConsoleColor.Gray;
	}

	public void OnDisable()
	{
		if (init)
		{
			input.OnInputText -= OnInputText;
			console.Shutdown();
		}
	}

	public void OnEnable()
	{
		if (console.Initialize())
		{
			init = true;
			input.OnInputText += OnInputText;
			input.ClearLine(1);
			input.ClearLine(Console.WindowHeight);
			for (int i = 0; i < Console.WindowHeight; i++)
			{
				Console.WriteLine();
			}
		}
	}

	private void OnInputText(string obj)
	{
		try
		{
			this.Input?.Invoke(obj);
		}
		catch (Exception ex)
		{
			Interface.Oxide.LogException("OnInputText: ", ex);
		}
	}

	public static void PrintColored(params object[] objects)
	{
		if (Interface.Oxide.ServerConsole == null)
		{
			return;
		}
		Interface.Oxide.ServerConsole.input.ClearLine((!Interface.Oxide.Config.Console.ShowStatusBar) ? 1 : Interface.Oxide.ServerConsole.input.StatusTextLeft.Length);
		for (int i = 0; i < objects.Length; i++)
		{
			if (i % 2 != 0)
			{
				Console.Write((string)objects[i]);
			}
			else
			{
				Console.ForegroundColor = (ConsoleColor)(int)objects[i];
			}
		}
		if (Console.CursorLeft != 0)
		{
			Console.CursorTop++;
		}
		Interface.Oxide.ServerConsole.input.RedrawInputLine();
	}

	public void Update()
	{
		if (init)
		{
			if (Interface.Oxide.Config.Console.ShowStatusBar)
			{
				UpdateStatus();
			}
			input.Update();
			if (!(nextTitleUpdate > Interface.Oxide.Now))
			{
				nextTitleUpdate = Interface.Oxide.Now + 1f;
				console.SetTitle(title);
			}
		}
	}

	private void UpdateStatus()
	{
		if (!(nextUpdate > Interface.Oxide.Now))
		{
			nextUpdate = Interface.Oxide.Now + 0.66f;
			if (input.Valid)
			{
				string text = status1Left;
				string text2 = status2Left;
				string text3 = status3Left;
				input.StatusTextLeft[1] = text;
				input.StatusTextLeft[2] = text2;
				input.StatusTextLeft[3] = text3;
				input.StatusTextRight[1] = GetStatusRight(text.Length, status1Right);
				input.StatusTextRight[2] = GetStatusRight(text2.Length, status2Right);
				input.StatusTextRight[3] = GetStatusRight(text3.Length, status3Right);
			}
		}
	}
}


using System;
using System.Linq;
using System.Net;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.RemoteConsole;
using WebSocketSharp;
using WebSocketSharp.Net.WebSockets;
using WebSocketSharp.Server;

public class RemoteConsole
{
	private struct RconPlayer
	{
		private string SteamID { get; }

		private string OwnerSteamID { get; }

		private string DisplayName { get; }

		private string Address { get; }

		private int Ping { get; }

		private int ConnectedSeconds { get; }

		private float VoiationLevel { get; }

		private float CurrentLevel { get; }

		private float UnspentXp { get; }

		private float Health { get; }

		public RconPlayer(IPlayer player)
		{
			SteamID = player.Id;
			OwnerSteamID = "0";
			DisplayName = player.Name;
			Address = player.Address;
			Ping = player.Ping;
			ConnectedSeconds = 0;
			VoiationLevel = 0f;
			CurrentLevel = 0f;
			UnspentXp = 0f;
			Health = player.Health;
		}
	}

	public class RconListener : WebSocketBehavior
	{
		private readonly RemoteConsole Parent;

		private IPAddress Address;

		public RconListener(RemoteConsole parent)
		{
			((WebSocketBehavior)this).IgnoreExtensions = true;
			Parent = parent;
		}

		public void SendMessage(RemoteMessage message)
		{
			((WebSocketBehavior)this).Sessions.Broadcast(message.ToJSON());
		}

		protected override void OnClose(CloseEventArgs e)
		{
			string arg = (string.IsNullOrEmpty(e.Reason) ? "Unknown" : e.Reason);
			Interface.Oxide.LogInfo($"[Rcon] Connection from {Address} closed: {arg} ({e.Code})");
		}

		protected override void OnError(ErrorEventArgs e)
		{
			Interface.Oxide.LogException(e.Message, e.Exception);
		}

		protected override void OnMessage(MessageEventArgs e)
		{
			Parent?.OnMessage(e, ((WebSocketBehavior)this).Context);
		}

		protected override void OnOpen()
		{
			Address = ((WebSocketBehavior)this).Context.UserEndPoint.Address;
			Interface.Oxide.LogInfo($"[Rcon] New connection from {Address}");
		}
	}

	private readonly Covalence covalence = Interface.Oxide.GetLibrary<Covalence>();

	private readonly OxideConfig.OxideRcon config = Interface.Oxide.Config.Rcon;

	private RconListener listener;

	private WebSocketServer server;

	public void Initalize()
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Expected O, but got Unknown
		if (!config.Enabled || listener != null || server != null)
		{
			return;
		}
		if (string.IsNullOrEmpty(config.Password))
		{
			Interface.Oxide.LogWarning("[Rcon] Remote console password is not set, disabling");
			return;
		}
		try
		{
			server = new WebSocketServer(config.Port)
			{
				WaitTime = TimeSpan.FromSeconds(5.0),
				ReuseAddress = true
			};
			server.AddWebSocketService<RconListener>("/" + config.Password, (Func<RconListener>)(() => listener = new RconListener(this)));
			server.Start();
			Interface.Oxide.LogInfo($"[Rcon] Server started successfully on port {server.Port}");
		}
		catch (Exception ex)
		{
			OxideMod oxide = Interface.Oxide;
			WebSocketServer obj = server;
			oxide.LogException($"[Rcon] Failed to start server on port {((obj != null) ? new int?(obj.Port) : ((int?)null))}", ex);
			WebSocketServer obj2 = server;
			RemoteLogger.Exception($"Failed to start RCON server on port {((obj2 != null) ? new int?(obj2.Port) : ((int?)null))}", ex);
		}
	}

	public void Shutdown(string reason = "Server shutting down", CloseStatusCode code = 1000)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (server != null)
		{
			server.Stop(code, reason);
			server = null;
			listener = null;
			Interface.Oxide.LogInfo($"[Rcon] Service has stopped: {reason} ({code})");
		}
	}

	public void SendMessage(RemoteMessage message)
	{
		if (message != null && server != null && server.IsListening && listener != null)
		{
			listener.SendMessage(message);
		}
	}

	public void SendMessage(string message, int identifier)
	{
		if (!string.IsNullOrEmpty(message) && server != null && server.IsListening && listener != null)
		{
			listener.SendMessage(RemoteMessage.CreateMessage(message, identifier));
		}
	}

	public void SendMessage(WebSocketContext connection, string message, int identifier)
	{
		if (!string.IsNullOrEmpty(message) && server != null && server.IsListening && listener != null && connection != null)
		{
			WebSocket webSocket = connection.WebSocket;
			if (webSocket != null)
			{
				webSocket.Send(RemoteMessage.CreateMessage(message, identifier).ToJSON());
			}
		}
	}

	private void OnMessage(MessageEventArgs e, WebSocketContext connection)
	{
		if (covalence == null)
		{
			Interface.Oxide.LogError("[Rcon] Failed to process command, Covalence is null");
			return;
		}
		RemoteMessage message = RemoteMessage.GetMessage(e.Data);
		if (message == null)
		{
			Interface.Oxide.LogError("[Rcon] Failed to process command, RemoteMessage is null");
			return;
		}
		if (string.IsNullOrEmpty(message.Message))
		{
			Interface.Oxide.LogError("[Rcon] Failed to process command, RemoteMessage.Text is not set");
			return;
		}
		string[] array = CommandLine.Split(message.Message);
		string text = array[0].ToLower();
		string[] array2 = array.Skip(1).ToArray();
		if (Interface.CallHook("OnRconCommand", connection.UserEndPoint, text, array2) == null)
		{
			IServer obj = covalence.Server;
			object[] args = array2;
			obj.Command(text, args);
		}
	}
}


using System;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.RemoteConsole;

[Serializable]
public class RemoteMessage
{
	public string Message;

	public int Identifier;

	public string Type;

	public string Stacktrace;

	public static RemoteMessage CreateMessage(string message, int identifier = -1, string type = "Generic", string trace = "")
	{
		return new RemoteMessage
		{
			Message = message,
			Identifier = identifier,
			Type = type,
			Stacktrace = trace
		};
	}

	public static RemoteMessage GetMessage(string text)
	{
		try
		{
			return JsonConvert.DeserializeObject<RemoteMessage>(text);
		}
		catch (JsonReaderException)
		{
			Interface.Oxide.LogError("[Rcon] Failed to parse message, incorrect format");
			return null;
		}
	}

	internal string ToJSON()
	{
		return JsonConvert.SerializeObject((object)this, (Formatting)1);
	}
}


using System;

[AttributeUsage(AttributeTargets.Method)]
public class HookMethodAttribute : Attribute
{
	public string Name { get; }

	public HookMethodAttribute(string name)
	{
		Name = name;
	}
}


using System;

[AttributeUsage(AttributeTargets.Class)]
public class AutoPatchAttribute : Attribute
{
}


using System;
using System.Collections.Generic;
using System.Reflection;
using HarmonyLib;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Pooling;

public abstract class CSPlugin : Plugin
{
	protected Dictionary<string, List<HookMethod>> Hooks = new Dictionary<string, List<HookMethod>>();

	private Harmony _harmonyInstance;

	protected HookCache HooksCache = new HookCache();

	protected string HarmonyId => "com.oxidemod." + base.Name;

	protected Harmony HarmonyInstance
	{
		get
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Expected O, but got Unknown
			if (_harmonyInstance == null)
			{
				_harmonyInstance = new Harmony(HarmonyId);
			}
			return _harmonyInstance;
		}
	}

	protected IArrayPoolProvider<object> ObjectArrayPool { get; }

	public static T GetLibrary<T>(string name = null) where T : Library
	{
		return Interface.Oxide.GetLibrary<T>(name);
	}

	public CSPlugin()
	{
		ObjectArrayPool = PoolingExtensions.GetArrayProvider<object>(Interface.Oxide.PoolFactory);
		Type type = GetType();
		List<Type> list = new List<Type> { type };
		while (type != typeof(CSPlugin))
		{
			list.Add(type = type.BaseType);
		}
		for (int num = list.Count - 1; num >= 0; num--)
		{
			MethodInfo[] methods = list[num].GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			foreach (MethodInfo methodInfo in methods)
			{
				object[] customAttributes = methodInfo.GetCustomAttributes(typeof(HookMethodAttribute), inherit: true);
				if (customAttributes.Length >= 1)
				{
					AddHookMethod((customAttributes[0] as HookMethodAttribute)?.Name, methodInfo);
				}
			}
		}
	}

	public override void HandleAddedToManager(PluginManager manager)
	{
		base.HandleAddedToManager(manager);
		foreach (string key in Hooks.Keys)
		{
			Subscribe(key);
		}
		try
		{
			OnCallHook("Init", null);
		}
		catch (Exception ex)
		{
			Interface.Oxide.LogException($"Failed to initialize plugin '{base.Name} v{base.Version}'", ex);
			if (base.Loader != null)
			{
				base.Loader.PluginErrors[base.Name] = ex.Message;
			}
		}
		Type[] nestedTypes = GetType().GetNestedTypes(BindingFlags.DeclaredOnly | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		foreach (Type type in nestedTypes)
		{
			if (type.GetCustomAttributes(typeof(AutoPatchAttribute), inherit: false).Length < 1)
			{
				continue;
			}
			try
			{
				PatchClassProcessor obj = HarmonyInstance.CreateClassProcessor(type);
				List<MethodInfo> list = ((obj != null) ? obj.Patch() : null);
				if (list == null || list.Count == 0)
				{
					Interface.Oxide.LogWarning("[" + base.Title + "] AutoPatch attribute found on '" + type.Name + "' but no HarmonyPatch methods found. Skipping.");
					continue;
				}
				foreach (MethodInfo item in list)
				{
					Interface.Oxide.LogInfo("[" + base.Title + "] Automatically Harmony patched '" + (item?.Name ?? "unknown") + "' method. (" + type.Name + ")");
				}
			}
			catch (Exception ex2)
			{
				Interface.Oxide.LogException("[" + base.Title + "] Failed to automatically Harmony patch '" + type.Name + "'", ex2);
			}
		}
	}

	public override void HandleRemovedFromManager(PluginManager manager)
	{
		Harmony harmonyInstance = _harmonyInstance;
		if (harmonyInstance != null)
		{
			harmonyInstance.UnpatchAll(HarmonyId);
		}
		base.HandleRemovedFromManager(manager);
	}

	protected void AddHookMethod(string name, MethodInfo method)
	{
		if (!Hooks.TryGetValue(name, out var value))
		{
			value = new List<HookMethod>();
			Hooks[name] = value;
		}
		value.Add(new HookMethod(method));
	}

	protected sealed override object OnCallHook(string name, object[] args)
	{
		object result = null;
		bool flag = false;
		foreach (HookMethod item in FindHooks(name, args))
		{
			int num = ((args != null) ? args.Length : 0);
			object[] array;
			if (num != item.Parameters.Length)
			{
				array = ObjectArrayPool.Take(item.Parameters.Length);
				flag = true;
				if (num > 0 && array.Length != 0)
				{
					Array.Copy(args, array, Math.Min(num, array.Length));
				}
				if (array.Length > num)
				{
					for (int i = num; i < array.Length; i++)
					{
						ParameterInfo parameterInfo = item.Parameters[i];
						if (parameterInfo.DefaultValue != null && parameterInfo.DefaultValue != DBNull.Value)
						{
							array[i] = parameterInfo.DefaultValue;
						}
						else if (parameterInfo.ParameterType.IsValueType)
						{
							array[i] = Activator.CreateInstance(parameterInfo.ParameterType);
						}
					}
				}
			}
			else
			{
				array = args;
			}
			try
			{
				result = InvokeMethod(item, array);
			}
			catch (TargetInvocationException ex)
			{
				if (flag)
				{
					((IPoolProvider)ObjectArrayPool).Return((object)array);
				}
				throw ex.InnerException ?? ex;
			}
			if (num != item.Parameters.Length)
			{
				for (int j = 0; j < item.Parameters.Length; j++)
				{
					if (item.Parameters[j].IsOut || item.Parameters[j].ParameterType.IsByRef)
					{
						args[j] = array[j];
					}
				}
			}
			if (flag)
			{
				((IPoolProvider)ObjectArrayPool).Return((object)array);
			}
		}
		return result;
	}

	protected List<HookMethod> FindHooks(string name, object[] args)
	{
		HookCache cache;
		List<HookMethod> value = HooksCache.GetHookMethod(name, args, out cache);
		if (value != null)
		{
			return value;
		}
		List<HookMethod> list = new List<HookMethod>();
		if (!Hooks.TryGetValue(name, out value))
		{
			return list;
		}
		HookMethod hookMethod = null;
		HookMethod hookMethod2 = null;
		foreach (HookMethod item in value)
		{
			if (item.IsBaseHook)
			{
				list.Add(item);
				continue;
			}
			int num = ((args != null) ? args.Length : 0);
			bool flag = false;
			object[] array;
			if (num != item.Parameters.Length)
			{
				array = ObjectArrayPool.Take(item.Parameters.Length);
				flag = true;
				if (num > 0 && array.Length != 0)
				{
					Array.Copy(args, array, Math.Min(num, array.Length));
				}
				if (array.Length > num)
				{
					for (int i = num; i < array.Length; i++)
					{
						ParameterInfo parameterInfo = item.Parameters[i];
						if (parameterInfo.DefaultValue != null && parameterInfo.DefaultValue != DBNull.Value)
						{
							array[i] = parameterInfo.DefaultValue;
						}
						else if (parameterInfo.ParameterType.IsValueType)
						{
							array[i] = Activator.CreateInstance(parameterInfo.ParameterType);
						}
					}
				}
			}
			else
			{
				array = args;
			}
			if (item.HasMatchingSignature(array, out var exact))
			{
				if (exact)
				{
					hookMethod = item;
					break;
				}
				hookMethod2 = item;
			}
			if (flag)
			{
				((IPoolProvider)ObjectArrayPool).Return((object)array);
			}
		}
		if (hookMethod != null)
		{
			list.Add(hookMethod);
		}
		else if (hookMethod2 != null)
		{
			list.Add(hookMethod2);
		}
		cache.SetupMethods(list);
		return list;
	}

	protected virtual object InvokeMethod(HookMethod method, object[] args)
	{
		return method.Method.Invoke(this, args);
	}
}


using System.Collections.Generic;
using Oxide.Core.Plugins;

public class HookCache
{
	private string NullKey = "null";

	public Dictionary<string, HookCache> _cache = new Dictionary<string, HookCache>();

	public List<HookMethod> _methods;

	public List<HookMethod> GetHookMethod(string hookName, object[] args, out HookCache cache)
	{
		if (!_cache.TryGetValue(hookName, out var value))
		{
			value = new HookCache();
			_cache.Add(hookName, value);
		}
		return value.GetHookMethod(args, 0, out cache);
	}

	public List<HookMethod> GetHookMethod(object[] args, int index, out HookCache cache)
	{
		if (args == null || index >= args.Length)
		{
			cache = this;
			return _methods;
		}
		HookCache value;
		if (args[index] == null)
		{
			if (!_cache.TryGetValue(NullKey, out value))
			{
				value = new HookCache();
				_cache.Add(NullKey, value);
			}
		}
		else if (!_cache.TryGetValue(args[index].GetType().FullName, out value))
		{
			value = new HookCache();
			_cache.Add(args[index].GetType().FullName, value);
		}
		return value.GetHookMethod(args, index + 1, out cache);
	}

	public void SetupMethods(List<HookMethod> methods)
	{
		_methods = methods;
	}
}


using System;
using System.ComponentModel;
using System.Linq;
using System.Reflection;

public class HookMethod
{
	public string Name;

	public MethodInfo Method;

	public ParameterInfo[] Parameters { get; set; }

	public bool IsBaseHook { get; set; }

	public HookMethod(MethodInfo method)
	{
		Method = method;
		Name = method.Name;
		Parameters = Method.GetParameters();
		if (Parameters.Length != 0)
		{
			Name = Name + "(" + string.Join(", ", Parameters.Select((ParameterInfo x) => x.ParameterType.ToString()).ToArray()) + ")";
		}
		IsBaseHook = Name.StartsWith("base_");
	}

	public bool HasMatchingSignature(object[] args, out bool exact)
	{
		exact = true;
		if (Parameters.Length == 0 && (args == null || args.Length == 0))
		{
			return true;
		}
		for (int i = 0; i < args.Length; i++)
		{
			if (args[i] == null)
			{
				if (!CanAssignNull(Parameters[i].ParameterType))
				{
					return false;
				}
				continue;
			}
			if (exact && args[i].GetType() != Parameters[i].ParameterType && args[i].GetType().MakeByRefType() != Parameters[i].ParameterType && !CanConvertNumber(args[i], Parameters[i].ParameterType))
			{
				exact = false;
			}
			if (exact || args[i].GetType() == Parameters[i].ParameterType || args[i].GetType().MakeByRefType() == Parameters[i].ParameterType || Parameters[i].ParameterType.FullName == "System.Object")
			{
				continue;
			}
			if (args[i].GetType().IsValueType)
			{
				if (!TypeDescriptor.GetConverter(Parameters[i].ParameterType).CanConvertFrom(args[i].GetType()) && !CanConvertNumber(args[i], Parameters[i].ParameterType))
				{
					return false;
				}
			}
			else if (!Parameters[i].ParameterType.IsInstanceOfType(args[i]))
			{
				return false;
			}
		}
		return true;
	}

	private bool CanAssignNull(Type type)
	{
		if (!type.IsValueType)
		{
			return true;
		}
		return Nullable.GetUnderlyingType(type) != null;
	}

	private bool IsNumber(object obj)
	{
		if (obj != null)
		{
			return IsNumber(Nullable.GetUnderlyingType(obj.GetType()) ?? obj.GetType());
		}
		return false;
	}

	private bool IsNumber(Type type)
	{
		if (type.IsPrimitive)
		{
			if (type != typeof(bool) && type != typeof(char) && type != typeof(IntPtr))
			{
				return type != typeof(UIntPtr);
			}
			return false;
		}
		return type == typeof(decimal);
	}

	private bool CanConvertNumber(object value, Type type)
	{
		if (!IsNumber(value) || !IsNumber(type))
		{
			return false;
		}
		return TypeDescriptor.GetConverter(type).IsValid(value);
	}
}


using Oxide.Core.Plugins;

public delegate void PluginError(Plugin sender, string message);


using Oxide.Core;
using Oxide.Core.Plugins;

public class PluginManagerEvent : Event<Plugin, PluginManager>
{
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

public abstract class Plugin
{
	private class CommandInfo
	{
		public readonly string[] Names;

		public readonly string[] PermissionsRequired;

		public readonly CommandCallback Callback;

		public CommandInfo(string[] names, string[] perms, CommandCallback callback)
		{
			Names = names;
			PermissionsRequired = perms;
			Callback = callback;
		}
	}

	private string name;

	private bool isCorePlugin;

	public PluginManagerEvent OnAddedToManager = new PluginManagerEvent();

	public PluginManagerEvent OnRemovedFromManager = new PluginManagerEvent();

	private Stopwatch trackStopwatch = new Stopwatch();

	private Stopwatch stopwatch = new Stopwatch();

	private float averageAt;

	private double sum;

	private int preHookGcCount;

	protected int nestcount;

	private IDictionary<string, CommandInfo> commandInfos;

	private Permission permission = Interface.Oxide.GetLibrary<Permission>();

	public string Filename { get; protected set; }

	public string Name
	{
		get
		{
			return name;
		}
		set
		{
			if (string.IsNullOrEmpty(Name) || name == GetType().Name)
			{
				name = value;
			}
		}
	}

	public string Title { get; protected set; }

	public string Description { get; protected set; }

	public string Author { get; protected set; }

	public VersionNumber Version { get; protected set; }

	public int ResourceId { get; protected set; }

	public PluginManager Manager { get; private set; }

	public bool HasConfig { get; protected set; }

	public bool HasMessages { get; protected set; }

	public bool IsCorePlugin
	{
		get
		{
			return isCorePlugin;
		}
		set
		{
			if (!Interface.Oxide.HasLoadedCorePlugins)
			{
				isCorePlugin = value;
			}
		}
	}

	public PluginLoader Loader { get; set; }

	public virtual object Object => this;

	public DynamicConfigFile Config { get; private set; }

	public bool IsLoaded { get; internal set; }

	public double TotalHookTime { get; internal set; }

	public long TotalHookMemory { get; internal set; }

	private long _currentMemoryUsed { get; set; }

	public event PluginError OnError;

	public static implicit operator bool(Plugin plugin)
	{
		return plugin != null;
	}

	public static bool operator !(Plugin plugin)
	{
		return !(bool)plugin;
	}

	protected Plugin()
	{
		Name = GetType().Name;
		Title = Name.Humanize();
		Author = "Unnamed";
		Version = new VersionNumber(1, 0, 0);
		commandInfos = new Dictionary<string, CommandInfo>();
	}

	protected void Subscribe(string hook)
	{
		Manager.SubscribeToHook(hook, this);
	}

	protected void Unsubscribe(string hook)
	{
		Manager.UnsubscribeToHook(hook, this);
	}

	public virtual void HandleAddedToManager(PluginManager manager)
	{
		Manager = manager;
		if (HasConfig)
		{
			LoadConfig();
		}
		if (HasMessages)
		{
			LoadDefaultMessages();
		}
		OnAddedToManager?.Invoke(this, manager);
		RegisterWithCovalence();
	}

	public virtual void HandleRemovedFromManager(PluginManager manager)
	{
		UnregisterWithCovalence();
		if (Manager == manager)
		{
			Manager = null;
		}
		OnRemovedFromManager?.Invoke(this, manager);
	}

	public virtual void Load()
	{
	}

	public object CallHook(string hook, params object[] args)
	{
		float num = 0f;
		if (!IsCorePlugin && nestcount == 0)
		{
			preHookGcCount = GC.CollectionCount(0);
			num = Interface.Oxide.Now;
			stopwatch.Start();
			if (averageAt < 1f)
			{
				averageAt = num;
			}
		}
		TrackStart();
		nestcount++;
		try
		{
			return OnCallHook(hook, args);
		}
		catch (Exception ex)
		{
			Interface.Oxide.LogException($"Failed to call hook '{hook}' on plugin '{Name} v{Version}'", ex);
			return null;
		}
		finally
		{
			nestcount--;
			TrackEnd();
			if (num > 0f)
			{
				stopwatch.Stop();
				double totalSeconds = stopwatch.Elapsed.TotalSeconds;
				if (totalSeconds > 0.1)
				{
					string text = ((preHookGcCount == GC.CollectionCount(0)) ? string.Empty : " [GARBAGE COLLECT]");
					Interface.Oxide.LogWarning($"Calling '{hook}' on '{Name} v{Version}' took {totalSeconds * 1000.0:0}ms{text}");
				}
				stopwatch.Reset();
				double num2 = sum + totalSeconds;
				double num3 = (double)num + totalSeconds;
				if (num3 - (double)averageAt > 10.0)
				{
					num2 /= num3 - (double)averageAt;
					if (num2 > 0.1)
					{
						string text2 = ((preHookGcCount == GC.CollectionCount(0)) ? string.Empty : " [GARBAGE COLLECT]");
						Interface.Oxide.LogWarning($"Calling '{hook}' on '{Name} v{Version}' took average {sum * 1000.0:0}ms{text2}");
					}
					sum = 0.0;
					averageAt = 0f;
				}
				else
				{
					sum = num2;
				}
			}
		}
	}

	public object Call(string hook, params object[] args)
	{
		return CallHook(hook, args);
	}

	public T Call<T>(string hook, params object[] args)
	{
		return (T)Convert.ChangeType(CallHook(hook, args), typeof(T));
	}

	protected abstract object OnCallHook(string hook, object[] args);

	public void RaiseError(string message)
	{
		this.OnError?.Invoke(this, message);
	}

	public void TrackStart()
	{
		if (!IsCorePlugin && nestcount <= 0)
		{
			Stopwatch stopwatch = trackStopwatch;
			if (!stopwatch.IsRunning)
			{
				_currentMemoryUsed = GetMemory();
				stopwatch.Start();
			}
		}
	}

	public void TrackEnd()
	{
		if (!IsCorePlugin && nestcount <= 0)
		{
			Stopwatch stopwatch = trackStopwatch;
			if (stopwatch.IsRunning)
			{
				stopwatch.Stop();
				TotalHookTime += stopwatch.Elapsed.TotalSeconds;
				TotalHookMemory += Math.Max(0L, GetMemory() - _currentMemoryUsed);
				stopwatch.Reset();
			}
		}
	}

	private static long GetMemory()
	{
		return GC.GetTotalMemory(forceFullCollection: false);
	}

	protected virtual void LoadConfig()
	{
		Config = new DynamicConfigFile(Path.Combine(Manager.ConfigPath, Name + ".json"));
		if (!Config.Exists())
		{
			LoadDefaultConfig();
			SaveConfig();
		}
		try
		{
			Config.Load();
		}
		catch (Exception ex)
		{
			RaiseError("Failed to load config file (is the config file corrupt?) (" + ex.Message + ")");
		}
	}

	protected virtual void LoadDefaultConfig()
	{
		CallHook("LoadDefaultConfig", null);
	}

	protected virtual void SaveConfig()
	{
		if (Config == null)
		{
			return;
		}
		try
		{
			Config.Save();
		}
		catch (Exception ex)
		{
			RaiseError("Failed to save config file (does the config have illegal objects in it?) (" + ex.Message + ")");
		}
	}

	protected virtual void LoadDefaultMessages()
	{
		CallHook("LoadDefaultMessages", null);
	}

	public void AddUniversalCommand(string command, string callback, string perm = null)
	{
		AddCovalenceCommand(new string[1] { command }, callback, string.IsNullOrEmpty(perm) ? null : new string[1] { perm });
	}

	public void AddCovalenceCommand(string command, string callback, string perm = null)
	{
		AddCovalenceCommand(new string[1] { command }, callback, string.IsNullOrEmpty(perm) ? null : new string[1] { perm });
	}

	public void AddUniversalCommand(string[] commands, string callback, string perm)
	{
		AddCovalenceCommand(commands, callback, string.IsNullOrEmpty(perm) ? null : new string[1] { perm });
	}

	public void AddCovalenceCommand(string[] commands, string callback, string perm)
	{
		AddCovalenceCommand(commands, callback, string.IsNullOrEmpty(perm) ? null : new string[1] { perm });
	}

	public void AddUniversalCommand(string[] commands, string callback, string[] perms = null)
	{
		AddCovalenceCommand(commands, callback, perms);
	}

	public void AddCovalenceCommand(string[] commands, string callback, string[] perms = null)
	{
		AddCovalenceCommand(commands, perms, delegate(IPlayer caller, string command, string[] args)
		{
			CallHook(callback, caller, command, args);
			return true;
		});
		Covalence library = Interface.Oxide.GetLibrary<Covalence>();
		foreach (string command2 in commands)
		{
			library.RegisterCommand(command2, this, CovalenceCommandCallback);
		}
	}

	protected void AddUniversalCommand(string[] commands, string[] perms, CommandCallback callback)
	{
		AddCovalenceCommand(commands, perms, callback);
	}

	protected void AddCovalenceCommand(string[] commands, string[] perms, CommandCallback callback)
	{
		string[] array = commands;
		foreach (string text in array)
		{
			if (commandInfos.ContainsKey(text.ToLowerInvariant()))
			{
				Interface.Oxide.LogWarning("Covalence command alias already exists: {0}", text);
			}
			else
			{
				commandInfos.Add(text.ToLowerInvariant(), new CommandInfo(commands, perms, callback));
			}
		}
		if (perms == null)
		{
			return;
		}
		array = perms;
		foreach (string text2 in array)
		{
			if (!permission.PermissionExists(text2))
			{
				permission.RegisterPermission(text2, this);
			}
		}
	}

	private void RegisterWithCovalence()
	{
		Covalence library = Interface.Oxide.GetLibrary<Covalence>();
		foreach (KeyValuePair<string, CommandInfo> commandInfo in commandInfos)
		{
			library.RegisterCommand(commandInfo.Key, this, CovalenceCommandCallback);
		}
	}

	private bool CovalenceCommandCallback(IPlayer caller, string cmd, string[] args)
	{
		if (!commandInfos.TryGetValue(cmd, out var value))
		{
			return false;
		}
		if (caller == null)
		{
			Interface.Oxide.LogWarning("Plugin.CovalenceCommandCallback received null as the caller (bad game Covalence bindings?)");
			return false;
		}
		if (value.PermissionsRequired != null)
		{
			string[] permissionsRequired = value.PermissionsRequired;
			foreach (string perm in permissionsRequired)
			{
				if (!caller.HasPermission(perm) && !caller.IsServer && (!caller.IsAdmin || !IsCorePlugin))
				{
					caller.Message("You do not have permission to use the command '" + cmd + "'!");
					return true;
				}
			}
		}
		value.Callback(caller, cmd, args);
		return true;
	}

	private void UnregisterWithCovalence()
	{
		Covalence library = Interface.Oxide.GetLibrary<Covalence>();
		foreach (KeyValuePair<string, CommandInfo> commandInfo in commandInfos)
		{
			library.UnregisterCommand(commandInfo.Key, this);
		}
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;

public abstract class PluginLoader
{
	public Dictionary<string, Plugin> LoadedPlugins = new Dictionary<string, Plugin>();

	public ConcurrentHashSet<string> LoadingPlugins { get; } = new ConcurrentHashSet<string>();

	public Dictionary<string, string> PluginErrors { get; } = new Dictionary<string, string>();

	public virtual Type[] CorePlugins { get; } = new Type[0];

	public virtual string FileExtension { get; }

	public virtual IEnumerable<string> ScanDirectory(string directory)
	{
		if (FileExtension == null || !Directory.Exists(directory))
		{
			yield break;
		}
		IEnumerable<FileInfo> enumerable = from f in new DirectoryInfo(directory).GetFiles("*" + FileExtension)
			where (f.Attributes & FileAttributes.Hidden) != FileAttributes.Hidden
			select f;
		foreach (FileInfo item in enumerable)
		{
			yield return Utility.GetFileNameWithoutExtension(item.FullName);
		}
	}

	public virtual Plugin Load(string directory, string name)
	{
		if (LoadingPlugins.Contains(name))
		{
			Interface.Oxide.LogDebug("Load requested for plugin which is already loading: {0}", name);
			return null;
		}
		string filename = Path.Combine(directory, name + FileExtension);
		Plugin plugin = GetPlugin(filename);
		LoadingPlugins.Add(plugin.Name);
		Interface.Oxide.NextTick(delegate
		{
			LoadPlugin(plugin);
		});
		return null;
	}

	protected virtual Plugin GetPlugin(string filename)
	{
		return null;
	}

	protected void LoadPlugin(Plugin plugin, bool waitingForAccess = false)
	{
		if (!File.Exists(plugin.Filename))
		{
			LoadingPlugins.Remove(plugin.Name);
			Interface.Oxide.LogWarning("Script no longer exists: {0}", plugin.Name);
			return;
		}
		try
		{
			plugin.Load();
			Interface.Oxide.UnloadPlugin(plugin.Name);
			LoadingPlugins.Remove(plugin.Name);
			Interface.Oxide.PluginLoaded(plugin);
		}
		catch (IOException)
		{
			if (!waitingForAccess)
			{
				Interface.Oxide.LogWarning("Waiting for another application to stop using script: {0}", plugin.Name);
			}
			Interface.Oxide.GetLibrary<Timer>().Once(0.5f, delegate
			{
				LoadPlugin(plugin, waitingForAccess: true);
			});
		}
		catch (Exception ex2)
		{
			LoadingPlugins.Remove(plugin.Name);
			Interface.Oxide.LogException("Failed to load plugin " + plugin.Name, ex2);
		}
	}

	public virtual void Reload(string directory, string name)
	{
		Interface.Oxide.UnloadPlugin(name);
		Interface.Oxide.LoadPlugin(name);
	}

	public virtual void Unloading(Plugin plugin)
	{
	}
}


using Oxide.Core.Plugins;

public delegate void PluginEvent(Plugin plugin);


using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Logging;
using Oxide.Core.Plugins;
using Oxide.Pooling;

public sealed class PluginManager
{
	private enum SubscriptionChangeType : byte
	{
		Subscribe,
		Unsubscribe
	}

	private struct SubscriptionChange
	{
		public Plugin Plugin { get; }

		public SubscriptionChangeType Change { get; }

		public SubscriptionChange(Plugin plugin, SubscriptionChangeType type)
		{
			Plugin = plugin;
			Change = type;
		}
	}

	private class HookSubscriptions
	{
		public IList<Plugin> Plugins { get; }

		public int CallDepth { get; set; }

		public Queue<SubscriptionChange> PendingChanges { get; }

		public HookSubscriptions()
		{
			Plugins = new List<Plugin>();
			PendingChanges = new Queue<SubscriptionChange>();
			CallDepth = 0;
		}
	}

	private readonly IDictionary<string, Plugin> loadedPlugins;

	private readonly IDictionary<string, HookSubscriptions> hookSubscriptions;

	private readonly Dictionary<string, float> lastDeprecatedWarningAt = new Dictionary<string, float>();

	private readonly List<string> hookConflicts = new List<string>();

	public Logger Logger { get; private set; }

	public string ConfigPath { get; set; }

	private IArrayPoolProvider<object> ObjectPool { get; }

	public event PluginEvent OnPluginAdded;

	public event PluginEvent OnPluginRemoved;

	public PluginManager(Logger logger)
	{
		ObjectPool = PoolingExtensions.GetArrayProvider<object>(Interface.Oxide.PoolFactory);
		loadedPlugins = new Dictionary<string, Plugin>();
		hookSubscriptions = new Dictionary<string, HookSubscriptions>();
		Logger = logger;
	}

	public bool AddPlugin(Plugin plugin)
	{
		if (loadedPlugins.ContainsKey(plugin.Name))
		{
			return false;
		}
		loadedPlugins.Add(plugin.Name, plugin);
		plugin.HandleAddedToManager(this);
		this.OnPluginAdded?.Invoke(plugin);
		return true;
	}

	public bool RemovePlugin(Plugin plugin)
	{
		if (!loadedPlugins.ContainsKey(plugin.Name))
		{
			return false;
		}
		loadedPlugins.Remove(plugin.Name);
		lock (hookSubscriptions)
		{
			foreach (HookSubscriptions value in hookSubscriptions.Values)
			{
				if (value.Plugins.Contains(plugin))
				{
					value.Plugins.Remove(plugin);
				}
			}
		}
		plugin.HandleRemovedFromManager(this);
		this.OnPluginRemoved?.Invoke(plugin);
		return true;
	}

	public Plugin GetPlugin(string name)
	{
		if (!loadedPlugins.TryGetValue(name, out var value))
		{
			return null;
		}
		return value;
	}

	public IEnumerable<Plugin> GetPlugins()
	{
		return loadedPlugins.Values;
	}

	internal void SubscribeToHook(string hook, Plugin plugin)
	{
		if (!loadedPlugins.ContainsKey(plugin.Name) || (!plugin.IsCorePlugin && (hook.StartsWith("IOn") || hook.StartsWith("ICan"))))
		{
			return;
		}
		HookSubscriptions value;
		lock (hookSubscriptions)
		{
			if (!hookSubscriptions.TryGetValue(hook, out value))
			{
				value = new HookSubscriptions();
				hookSubscriptions[hook] = value;
			}
		}
		if (value.CallDepth > 0)
		{
			value.PendingChanges.Enqueue(new SubscriptionChange(plugin, SubscriptionChangeType.Subscribe));
		}
		else if (!value.Plugins.Contains(plugin))
		{
			value.Plugins.Add(plugin);
		}
	}

	internal void UnsubscribeToHook(string hook, Plugin plugin)
	{
		if (!loadedPlugins.ContainsKey(plugin.Name) || (!plugin.IsCorePlugin && (hook.StartsWith("IOn") || hook.StartsWith("ICan"))))
		{
			return;
		}
		HookSubscriptions value;
		lock (hookSubscriptions)
		{
			if (!hookSubscriptions.TryGetValue(hook, out value))
			{
				return;
			}
		}
		if (value.CallDepth > 0)
		{
			value.PendingChanges.Enqueue(new SubscriptionChange(plugin, SubscriptionChangeType.Unsubscribe));
		}
		else
		{
			value.Plugins.Remove(plugin);
		}
	}

	public object CallHook(string hook, params object[] args)
	{
		HookSubscriptions value;
		lock (hookSubscriptions)
		{
			if (!hookSubscriptions.TryGetValue(hook, out value))
			{
				return null;
			}
		}
		if (value.Plugins.Count == 0)
		{
			return null;
		}
		object[] array = ObjectPool.Take(value.Plugins.Count);
		int num = 0;
		object obj = null;
		Plugin plugin = null;
		value.CallDepth++;
		try
		{
			for (int i = 0; i < value.Plugins.Count; i++)
			{
				Plugin plugin2 = value.Plugins[i];
				object obj2 = plugin2.CallHook(hook, args);
				if (obj2 != null)
				{
					array[i] = obj2;
					obj = obj2;
					plugin = plugin2;
					num++;
				}
			}
			if (num == 0)
			{
				((IPoolProvider)ObjectPool).Return((object)array);
				return null;
			}
			if (num > 1 && obj != null)
			{
				hookConflicts.Clear();
				for (int j = 0; j < value.Plugins.Count; j++)
				{
					Plugin plugin3 = value.Plugins[j];
					object obj3 = array[j];
					if (obj3 == null)
					{
						continue;
					}
					if (obj3.GetType().IsValueType)
					{
						if (!array[j].Equals(obj))
						{
							hookConflicts.Add($"{plugin3.Name} - {obj3} ({obj3.GetType().Name})");
						}
					}
					else if (array[j] != obj)
					{
						hookConflicts.Add($"{plugin3.Name} - {obj3} ({obj3.GetType().Name})");
					}
				}
				if (hookConflicts.Count > 0)
				{
					hookConflicts.Add($"{plugin.Name} ({obj} ({obj.GetType().Name}))");
					Logger.Write(LogType.Warning, "Calling hook {0} resulted in a conflict between the following plugins: {1}", hook, string.Join(", ", hookConflicts.ToArray()));
				}
			}
			((IPoolProvider)ObjectPool).Return((object)array);
			return obj;
		}
		finally
		{
			value.CallDepth--;
			if (value.CallDepth == 0)
			{
				ProcessHookChanges(value);
			}
		}
	}

	private void ProcessHookChanges(HookSubscriptions subscriptions)
	{
		while (subscriptions.PendingChanges.Count != 0)
		{
			SubscriptionChange subscriptionChange = subscriptions.PendingChanges.Dequeue();
			if (subscriptionChange.Change == SubscriptionChangeType.Subscribe)
			{
				if (!subscriptions.Plugins.Contains(subscriptionChange.Plugin))
				{
					subscriptions.Plugins.Add(subscriptionChange.Plugin);
				}
			}
			else
			{
				subscriptions.Plugins.Remove(subscriptionChange.Plugin);
			}
		}
	}

	public object CallDeprecatedHook(string oldHook, string newHook, DateTime expireDate, params object[] args)
	{
		HookSubscriptions value;
		lock (hookSubscriptions)
		{
			if (!hookSubscriptions.TryGetValue(oldHook, out value))
			{
				return null;
			}
		}
		if (value.Plugins.Count == 0)
		{
			return null;
		}
		float now = Interface.Oxide.Now;
		if (!lastDeprecatedWarningAt.TryGetValue(oldHook, out var value2) || now - value2 > 3600f)
		{
			lastDeprecatedWarningAt[oldHook] = now;
			Interface.Oxide.LogWarning(string.Format("'{0} v{1}' is using deprecated hook '{2}', which will stop working on {3}. Please ask the author to update to '{4}'", value.Plugins[0].Name, value.Plugins[0].Version, oldHook, expireDate.ToString("D"), newHook));
		}
		return CallHook(oldHook, args);
	}
}


using System.IO;

public sealed class FileChange
{
	public string Name { get; private set; }

	public WatcherChangeTypes ChangeType { get; private set; }

	public FileChange(string name, WatcherChangeTypes changeType)
	{
		Name = name;
		ChangeType = changeType;
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Permissions;
using System.Text;
using System.Text.RegularExpressions;
using Mono.Unix.Native;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins.Watchers;
using Oxide.Pooling;

public sealed class FSWatcher : PluginChangeWatcher
{
	private class QueuedChange
	{
		internal WatcherChangeTypes type;

		internal Timer.TimerInstance timer;
	}

	private FileSystemWatcher watcher;

	private ICollection<string> watchedPlugins;

	private Dictionary<string, QueuedChange> changeQueue;

	private readonly object changeQueueLock = new object();

	private Timer timers;

	private Dictionary<string, FileSystemWatcher> m_symlinkWatchers = new Dictionary<string, FileSystemWatcher>();

	private IPoolProvider<StringBuilder> StringPool { get; }

	public FSWatcher(string directory, string filter)
	{
		StringPool = Interface.Oxide.PoolFactory.GetProvider<StringBuilder>();
		watchedPlugins = new HashSet<string>();
		changeQueue = new Dictionary<string, QueuedChange>();
		timers = Interface.Oxide.GetLibrary<Timer>();
		if (Interface.Oxide.Config.Options.PluginWatchers)
		{
			LoadWatcher(directory, filter);
			if (Environment.OSVersion.Platform != PlatformID.Unix)
			{
				return;
			}
			FileInfo[] files = new DirectoryInfo(directory).GetFiles(filter);
			foreach (FileInfo fileInfo in files)
			{
				if (IsFileSymlink(fileInfo.FullName))
				{
					LoadWatcherSymlink(fileInfo.FullName);
				}
			}
		}
		else
		{
			Interface.Oxide.LogWarning("Automatic plugin reloading and unloading has been disabled");
		}
	}

	private bool IsFileSymlink(string path)
	{
		return (File.GetAttributes(path) & FileAttributes.ReparsePoint) > FileAttributes.None;
	}

	[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
	private void LoadWatcherSymlink(string path)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Invalid comparison between Unknown and I4
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Expected I4, but got Unknown
		StringBuilder stringBuilder = StringPool.Take();
		stringBuilder.Capacity = 4096;
		try
		{
			int num = Syscall.readlink(path, stringBuilder);
			if (num == -1)
			{
				Errno lastError = Stdlib.GetLastError();
				if ((int)lastError != 22)
				{
					throw new IOException($"Unable to process symlink | {lastError}", (int)lastError);
				}
				return;
			}
			string path2 = stringBuilder.ToString(0, num);
			string directoryName = Path.GetDirectoryName(path2);
			string fileName = Path.GetFileName(path2);
			FileSystemWatcher fileSystemWatcher = new FileSystemWatcher(directoryName, fileName);
			m_symlinkWatchers[path] = fileSystemWatcher;
			fileSystemWatcher.Changed += symlinkTarget_Changed;
			fileSystemWatcher.Created += symlinkTarget_Changed;
			fileSystemWatcher.Deleted += symlinkTarget_Changed;
			fileSystemWatcher.Error += watcher_Error;
			fileSystemWatcher.NotifyFilter = NotifyFilters.LastWrite;
			fileSystemWatcher.IncludeSubdirectories = false;
			fileSystemWatcher.EnableRaisingEvents = true;
		}
		finally
		{
			((IPoolProvider)StringPool).Return((object)stringBuilder);
		}
		void symlinkTarget_Changed(object sender, FileSystemEventArgs e)
		{
			watcher_Changed(sender, e);
		}
	}

	[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
	private void LoadWatcher(string directory, string filter)
	{
		watcher = new FileSystemWatcher(directory, filter);
		watcher.Changed += watcher_Changed;
		watcher.Created += watcher_Changed;
		watcher.Deleted += watcher_Changed;
		watcher.Error += watcher_Error;
		watcher.NotifyFilter = NotifyFilters.FileName | NotifyFilters.LastWrite;
		watcher.IncludeSubdirectories = true;
		watcher.EnableRaisingEvents = true;
		GC.KeepAlive(watcher);
	}

	public void AddMapping(string name)
	{
		watchedPlugins.Add(name);
	}

	public void RemoveMapping(string name)
	{
		watchedPlugins.Remove(name);
	}

	private void watcher_Changed(object sender, FileSystemEventArgs e)
	{
		FileSystemWatcher fileSystemWatcher = (FileSystemWatcher)sender;
		int length = e.FullPath.Length - fileSystemWatcher.Path.Length - Path.GetExtension(e.Name).Length - 1;
		string subPath = e.FullPath.Substring(fileSystemWatcher.Path.Length + 1, length);
		QueuedChange change;
		lock (changeQueueLock)
		{
			if (!changeQueue.TryGetValue(subPath, out change))
			{
				change = new QueuedChange();
				changeQueue[subPath] = change;
			}
			change.timer?.Destroy();
			change.timer = null;
			switch (e.ChangeType)
			{
			case WatcherChangeTypes.Changed:
				if (change.type != WatcherChangeTypes.Created)
				{
					change.type = WatcherChangeTypes.Changed;
				}
				break;
			case WatcherChangeTypes.Created:
				if (change.type == WatcherChangeTypes.Deleted)
				{
					change.type = WatcherChangeTypes.Changed;
				}
				else
				{
					change.type = WatcherChangeTypes.Created;
				}
				break;
			case WatcherChangeTypes.Deleted:
				if (change.type == WatcherChangeTypes.Created)
				{
					changeQueue.Remove(subPath);
					return;
				}
				change.type = WatcherChangeTypes.Deleted;
				break;
			case WatcherChangeTypes.Created | WatcherChangeTypes.Deleted:
				break;
			}
		}
		Interface.Oxide.NextTick(delegate
		{
			if (Environment.OSVersion.Platform == PlatformID.Unix)
			{
				switch (e.ChangeType)
				{
				case WatcherChangeTypes.Created:
					if (IsFileSymlink(e.FullPath))
					{
						LoadWatcherSymlink(e.FullPath);
					}
					break;
				case WatcherChangeTypes.Deleted:
					if (m_symlinkWatchers.ContainsKey(e.FullPath))
					{
						m_symlinkWatchers.TryGetValue(e.FullPath, out var value);
						value?.Dispose();
						m_symlinkWatchers.Remove(e.FullPath);
					}
					break;
				}
			}
			change.timer?.Destroy();
			change.timer = timers.Once(0.2f, delegate
			{
				lock (changeQueueLock)
				{
					change.timer = null;
					changeQueue.Remove(subPath);
				}
				if (Regex.Match(subPath, "include\\\\", RegexOptions.IgnoreCase).Success)
				{
					if (change.type == WatcherChangeTypes.Created || change.type == WatcherChangeTypes.Changed)
					{
						FirePluginSourceChanged(subPath);
					}
				}
				else
				{
					switch (change.type)
					{
					case WatcherChangeTypes.Changed:
						if (watchedPlugins.Contains(subPath))
						{
							FirePluginSourceChanged(subPath);
						}
						else
						{
							FirePluginAdded(subPath);
						}
						break;
					case WatcherChangeTypes.Created:
						FirePluginAdded(subPath);
						break;
					case WatcherChangeTypes.Deleted:
						if (watchedPlugins.Contains(subPath))
						{
							FirePluginRemoved(subPath);
						}
						break;
					case WatcherChangeTypes.Created | WatcherChangeTypes.Deleted:
						break;
					}
				}
			});
		});
	}

	private void watcher_Error(object sender, ErrorEventArgs e)
	{
		Interface.Oxide.NextTick(delegate
		{
			Interface.Oxide.LogError("FSWatcher error: {0}", e.GetException());
			RemoteLogger.Exception("FSWatcher error", e.GetException());
		});
	}
}


public delegate void PluginChangeEvent(string name);


public delegate void PluginAddEvent(string name);


public delegate void PluginRemoveEvent(string name);


using Oxide.Core.Plugins.Watchers;

public abstract class PluginChangeWatcher
{
	public event PluginChangeEvent OnPluginSourceChanged;

	public event PluginAddEvent OnPluginAdded;

	public event PluginRemoveEvent OnPluginRemoved;

	protected void FirePluginSourceChanged(string name)
	{
		this.OnPluginSourceChanged?.Invoke(name);
	}

	protected void FirePluginAdded(string name)
	{
		this.OnPluginAdded?.Invoke(name);
	}

	protected void FirePluginRemoved(string name)
	{
		this.OnPluginRemoved?.Invoke(name);
	}
}


using Oxide.Core;
using Oxide.Core.Logging;

public class CallbackLogger : Logger
{
	private NativeDebugCallback callback;

	public CallbackLogger(NativeDebugCallback callback)
		: base(processImmediately: true)
	{
		this.callback = callback;
	}

	protected override void ProcessMessage(LogMessage message)
	{
		callback?.Invoke(message.LogfileMessage);
	}
}


using System.Collections.Generic;
using Oxide.Core.Logging;

public sealed class CompoundLogger : Logger
{
	private readonly HashSet<Logger> subloggers;

	private readonly List<LogMessage> messagecache;

	private bool usecache;

	private readonly object Lock = new object();

	public CompoundLogger()
		: base(processImmediately: true)
	{
		subloggers = new HashSet<Logger>();
		messagecache = new List<LogMessage>();
		usecache = true;
	}

	public void AddLogger(Logger logger)
	{
		subloggers.Add(logger);
		lock (Lock)
		{
			foreach (LogMessage item in messagecache)
			{
				logger.Write(item);
			}
		}
	}

	public void RemoveLogger(Logger logger)
	{
		logger.OnRemoved();
		subloggers.Remove(logger);
	}

	public void Shutdown()
	{
		foreach (Logger sublogger in subloggers)
		{
			sublogger.OnRemoved();
		}
		subloggers.Clear();
	}

	public override void Write(LogType type, string format, params object[] args)
	{
		foreach (Logger sublogger in subloggers)
		{
			sublogger.Write(type, format, args);
		}
		if (usecache)
		{
			lock (Lock)
			{
				messagecache.Add(CreateLogMessage(type, format, args));
			}
		}
	}

	public void DisableCache()
	{
		usecache = false;
		lock (Lock)
		{
			messagecache.Clear();
		}
	}
}


public enum LogType
{
	Chat,
	Error,
	Info,
	Warning,
	Debug
}


using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Logging;
using Oxide.Core.RemoteConsole;

public abstract class Logger
{
	public struct LogMessage
	{
		public LogType Type;

		public string ConsoleMessage;

		public string LogfileMessage;
	}

	protected Queue<LogMessage> MessageQueue;

	private bool processImmediately;

	protected Logger(bool processImmediately)
	{
		this.processImmediately = processImmediately;
		if (!processImmediately)
		{
			MessageQueue = new Queue<LogMessage>();
		}
	}

	protected LogMessage CreateLogMessage(LogType type, string format, object[] args)
	{
		LogMessage logMessage = default(LogMessage);
		logMessage.Type = type;
		logMessage.ConsoleMessage = $"[Oxide] {DateTime.Now.ToShortTimeString()} [{type}] {format}";
		logMessage.LogfileMessage = $"{DateTime.Now.ToShortTimeString()} [{type}] {format}";
		LogMessage result = logMessage;
		if (Interface.Oxide.Config.Console.MinimalistMode)
		{
			result.ConsoleMessage = format;
		}
		if (args.Length != 0)
		{
			result.ConsoleMessage = string.Format(result.ConsoleMessage, args);
			result.LogfileMessage = string.Format(result.LogfileMessage, args);
		}
		return result;
	}

	public virtual void HandleMessage(string message, string stackTrace, LogType logType)
	{
		if (message.ToLower().Contains("[chat]"))
		{
			logType = LogType.Chat;
		}
		ConsoleColor color;
		string type;
		switch (logType)
		{
		case LogType.Chat:
			color = ConsoleColor.Green;
			type = "Chat";
			break;
		case LogType.Error:
			color = ConsoleColor.Red;
			type = "Error";
			break;
		case LogType.Warning:
			color = ConsoleColor.Yellow;
			type = "Warning";
			break;
		default:
			color = ConsoleColor.Gray;
			type = "Generic";
			break;
		}
		Interface.Oxide.ServerConsole.AddMessage(message, color);
		Interface.Oxide.RemoteConsole.SendMessage(new RemoteMessage
		{
			Message = message,
			Identifier = -1,
			Type = type,
			Stacktrace = stackTrace
		});
	}

	public virtual void Write(LogType type, string format, params object[] args)
	{
		LogMessage message = CreateLogMessage(type, format, args);
		Write(message);
	}

	internal virtual void Write(LogMessage message)
	{
		if (processImmediately)
		{
			ProcessMessage(message);
		}
		else
		{
			MessageQueue.Enqueue(message);
		}
	}

	protected virtual void ProcessMessage(LogMessage message)
	{
	}

	public virtual void WriteException(string message, Exception ex)
	{
		string text = ExceptionHandler.FormatException(ex);
		if (text != null)
		{
			Write(LogType.Error, message + Environment.NewLine + text);
			return;
		}
		Exception ex2 = ex;
		while (ex.InnerException != null)
		{
			ex = ex.InnerException;
		}
		if (ex2.GetType() != ex.GetType())
		{
			Write(LogType.Error, "ExType: {0}", ex2.GetType().Name);
		}
		Write(LogType.Error, message + " (" + ex.GetType().Name + ": " + ex.Message + ")\n" + ex.StackTrace);
	}

	public virtual void OnRemoved()
	{
	}
}


using System;
using System.IO;
using Oxide.Core.Logging;

public sealed class RotatingFileLogger : ThreadedLogger
{
	private StreamWriter writer;

	public string Directory { get; set; }

	private string GetLogFilename(DateTime date)
	{
		return Path.Combine(Directory, $"oxide_{date:yyyy-MM-dd}.txt");
	}

	protected override void BeginBatchProcess()
	{
		writer = new StreamWriter(new FileStream(GetLogFilename(DateTime.Now), FileMode.Append, FileAccess.Write));
	}

	protected override void ProcessMessage(LogMessage message)
	{
		writer.WriteLine(message.LogfileMessage);
	}

	protected override void FinishBatchProcess()
	{
		writer.Close();
		writer.Dispose();
		writer = null;
	}
}


using System.Threading;
using Oxide.Core.Logging;

public abstract class ThreadedLogger : Logger
{
	private AutoResetEvent waitevent;

	private bool exit;

	private object syncroot;

	private Thread workerthread;

	public ThreadedLogger()
		: base(processImmediately: false)
	{
		waitevent = new AutoResetEvent(initialState: false);
		exit = false;
		syncroot = new object();
		workerthread = new Thread(Worker)
		{
			IsBackground = true
		};
		workerthread.Start();
	}

	~ThreadedLogger()
	{
		OnRemoved();
	}

	public override void OnRemoved()
	{
		if (!exit)
		{
			exit = true;
			waitevent.Set();
			workerthread.Join();
		}
	}

	internal override void Write(LogMessage msg)
	{
		lock (syncroot)
		{
			base.Write(msg);
		}
		waitevent.Set();
	}

	protected abstract void BeginBatchProcess();

	protected abstract void FinishBatchProcess();

	private void Worker()
	{
		while (!exit)
		{
			waitevent.WaitOne();
			lock (syncroot)
			{
				if (MessageQueue.Count <= 0)
				{
					continue;
				}
				BeginBatchProcess();
				try
				{
					while (MessageQueue.Count > 0)
					{
						LogMessage message = MessageQueue.Dequeue();
						ProcessMessage(message);
					}
				}
				finally
				{
					FinishBatchProcess();
				}
			}
		}
	}
}


using System;
using Oxide.Core;
using Oxide.Core.Libraries;

public class Global : Library
{
	public override bool IsGlobal => true;

	[LibraryFunction("V")]
	public VersionNumber MakeVersion(ushort major, ushort minor, ushort patch)
	{
		return new VersionNumber(major, minor, patch);
	}

	[LibraryFunction("new")]
	public object New(Type type, object[] args)
	{
		if (args != null)
		{
			return Activator.CreateInstance(type, args);
		}
		return Activator.CreateInstance(type);
	}
}


using System.Collections.Generic;
using System.IO;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using ProtoBuf;

public class Lang : Library
{
	[ProtoContract(/*Could not decode attribute arguments.*/)]
	private class LangData
	{
		public string Lang = "en";

		public readonly Dictionary<string, string> UserData = new Dictionary<string, string>();
	}

	private const string defaultLang = "en";

	private readonly LangData langData;

	private readonly Dictionary<string, Dictionary<string, string>> langFiles;

	private readonly Dictionary<Plugin, Event.Callback<Plugin, PluginManager>> pluginRemovedFromManager;

	public override bool IsGlobal => false;

	public Lang()
	{
		langFiles = new Dictionary<string, Dictionary<string, string>>();
		langData = ProtoStorage.Load<LangData>(new string[1] { "oxide.lang" }) ?? new LangData();
		pluginRemovedFromManager = new Dictionary<Plugin, Event.Callback<Plugin, PluginManager>>();
	}

	[LibraryFunction("RegisterMessages")]
	public void RegisterMessages(Dictionary<string, string> messages, Plugin plugin, string lang = "en")
	{
		if (messages == null || string.IsNullOrEmpty(lang) || plugin == null)
		{
			return;
		}
		string text = $"{lang}{Path.DirectorySeparatorChar}{plugin.Name}.json";
		Dictionary<string, string> messageFile = GetMessageFile(plugin.Name, lang);
		bool flag;
		if (messageFile == null)
		{
			langFiles.Remove(text);
			AddLangFile(text, messages, plugin);
			flag = true;
		}
		else
		{
			flag = MergeMessages(messageFile, messages);
			messages = messageFile;
		}
		if (flag)
		{
			if (!Directory.Exists(Path.Combine(Interface.Oxide.LangDirectory, lang)))
			{
				Directory.CreateDirectory(Path.Combine(Interface.Oxide.LangDirectory, lang));
			}
			File.WriteAllText(Path.Combine(Interface.Oxide.LangDirectory, text), JsonConvert.SerializeObject((object)messages, (Formatting)1));
		}
	}

	[LibraryFunction("GetLanguage")]
	public string GetLanguage(string userId)
	{
		if (!string.IsNullOrEmpty(userId) && langData.UserData.TryGetValue(userId, out var value))
		{
			return value;
		}
		return langData.Lang;
	}

	[LibraryFunction("GetLanguages")]
	public string[] GetLanguages(Plugin plugin = null)
	{
		List<string> list = new List<string>();
		string[] directories = Directory.GetDirectories(Interface.Oxide.LangDirectory);
		foreach (string text in directories)
		{
			if (Directory.GetFiles(text).Length != 0 && (plugin == null || (plugin != null && File.Exists(Path.Combine(text, plugin.Name + ".json")))))
			{
				list.Add(text.Substring(Interface.Oxide.LangDirectory.Length + 1));
			}
		}
		return list.ToArray();
	}

	[LibraryFunction("GetMessage")]
	public string GetMessage(string key, Plugin plugin, string userId = null)
	{
		if (string.IsNullOrEmpty(key) || plugin == null)
		{
			return key;
		}
		return GetMessageKey(key, plugin, GetLanguage(userId));
	}

	[LibraryFunction("GetMessageByLanguage")]
	public string GetMessageByLanguage(string key, Plugin plugin, string lang = "en")
	{
		if (string.IsNullOrEmpty(key) || plugin == null)
		{
			return key;
		}
		return GetMessageKey(key, plugin, lang);
	}

	[LibraryFunction("GetMessages")]
	public Dictionary<string, string> GetMessages(string lang, Plugin plugin)
	{
		if (string.IsNullOrEmpty(lang) || plugin == null)
		{
			return null;
		}
		string text = $"{lang}{Path.DirectorySeparatorChar}{plugin.Name}.json";
		if (!langFiles.TryGetValue(text, out var value))
		{
			value = GetMessageFile(plugin.Name, lang);
			if (value == null)
			{
				return null;
			}
			AddLangFile(text, value, plugin);
		}
		return value.ToDictionary((KeyValuePair<string, string> k) => k.Key, (KeyValuePair<string, string> v) => v.Value);
	}

	[LibraryFunction("GetServerLanguage")]
	public string GetServerLanguage()
	{
		return langData.Lang;
	}

	[LibraryFunction("SetLanguage")]
	public void SetLanguage(string lang, string userId)
	{
		if (!string.IsNullOrEmpty(lang) && !string.IsNullOrEmpty(userId) && (!langData.UserData.TryGetValue(userId, out var value) || !lang.Equals(value)))
		{
			langData.UserData[userId] = lang;
			SaveData();
		}
	}

	[LibraryFunction("SetServerLanguage")]
	public void SetServerLanguage(string lang)
	{
		if (!string.IsNullOrEmpty(lang) && !lang.Equals(langData.Lang))
		{
			langData.Lang = lang;
			SaveData();
		}
	}

	private void AddLangFile(string file, Dictionary<string, string> langFile, Plugin plugin)
	{
		langFiles.Add(file, langFile);
		if (plugin != null && !pluginRemovedFromManager.ContainsKey(plugin))
		{
			pluginRemovedFromManager[plugin] = plugin.OnRemovedFromManager.Add(plugin_OnRemovedFromManager);
		}
	}

	private Dictionary<string, string> GetMessageFile(string plugin, string lang = "en")
	{
		if (string.IsNullOrEmpty(plugin))
		{
			return null;
		}
		char[] invalidFileNameChars = Path.GetInvalidFileNameChars();
		foreach (char oldChar in invalidFileNameChars)
		{
			lang = lang.Replace(oldChar, '_');
		}
		string path = $"{lang}{Path.DirectorySeparatorChar}{plugin}.json";
		string path2 = Path.Combine(Interface.Oxide.LangDirectory, path);
		if (!File.Exists(path2))
		{
			return null;
		}
		return JsonConvert.DeserializeObject<Dictionary<string, string>>(File.ReadAllText(path2));
	}

	private string GetMessageKey(string key, Plugin plugin, string lang = "en")
	{
		string text = $"{lang}{Path.DirectorySeparatorChar}{plugin.Name}.json";
		if (!langFiles.TryGetValue(text, out var value))
		{
			value = GetMessageFile(plugin.Name, lang) ?? GetMessageFile(plugin.Name, langData.Lang) ?? GetMessageFile(plugin.Name);
			if (value == null)
			{
				Interface.Oxide.LogWarning("Plugin '" + plugin.Name + "' is using the Lang API but has no messages registered");
				return key;
			}
			Dictionary<string, string> messageFile = GetMessageFile(plugin.Name);
			if (messageFile != null && MergeMessages(value, messageFile) && File.Exists(Path.Combine(Interface.Oxide.LangDirectory, text)))
			{
				File.WriteAllText(Path.Combine(Interface.Oxide.LangDirectory, text), JsonConvert.SerializeObject((object)value, (Formatting)1));
			}
			AddLangFile(text, value, plugin);
		}
		if (!value.TryGetValue(key, out var value2))
		{
			return key;
		}
		return value2;
	}

	private bool MergeMessages(Dictionary<string, string> existingMessages, Dictionary<string, string> messages)
	{
		bool result = false;
		foreach (KeyValuePair<string, string> message in messages)
		{
			if (!existingMessages.ContainsKey(message.Key))
			{
				existingMessages.Add(message.Key, message.Value);
				result = true;
			}
		}
		if (existingMessages.Count > 0)
		{
			string[] array = existingMessages.Keys.ToArray();
			foreach (string key in array)
			{
				if (!messages.ContainsKey(key))
				{
					existingMessages.Remove(key);
					result = true;
				}
			}
		}
		return result;
	}

	private void SaveData()
	{
		ProtoStorage.Save(langData, "oxide.lang");
	}

	private void plugin_OnRemovedFromManager(Plugin sender, PluginManager manager)
	{
		if (pluginRemovedFromManager.TryGetValue(sender, out var value))
		{
			value.Remove();
			pluginRemovedFromManager.Remove(sender);
		}
		string[] languages = GetLanguages(sender);
		foreach (string arg in languages)
		{
			langFiles.Remove($"{arg}{Path.DirectorySeparatorChar}{sender.Name}.json");
		}
	}
}


using System;

[AttributeUsage(AttributeTargets.Method)]
public class LibraryFunction : Attribute
{
	public string Name { get; }

	public LibraryFunction()
	{
	}

	public LibraryFunction(string name)
	{
		Name = name;
	}
}


using System;

[AttributeUsage(AttributeTargets.Property)]
public class LibraryProperty : Attribute
{
	public string Name { get; private set; }

	public LibraryProperty()
	{
	}

	public LibraryProperty(string name)
	{
		Name = name;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Oxide.Core;
using Oxide.Core.Libraries;

public abstract class Library
{
	private IDictionary<string, MethodInfo> functions;

	private IDictionary<string, PropertyInfo> properties;

	public virtual bool IsGlobal { get; }

	public Exception LastException { get; protected set; }

	public static implicit operator bool(Library library)
	{
		return library != null;
	}

	public static bool operator !(Library library)
	{
		return !library;
	}

	public Library()
	{
		functions = new Dictionary<string, MethodInfo>();
		properties = new Dictionary<string, PropertyInfo>();
		Type type = GetType();
		MethodInfo[] methods = type.GetMethods();
		foreach (MethodInfo methodInfo in methods)
		{
			LibraryFunction libraryFunction;
			try
			{
				libraryFunction = methodInfo.GetCustomAttributes(typeof(LibraryFunction), inherit: true).SingleOrDefault() as LibraryFunction;
				if (libraryFunction == null)
				{
					continue;
				}
			}
			catch (TypeLoadException)
			{
				continue;
			}
			string text = libraryFunction.Name ?? methodInfo.Name;
			if (functions.ContainsKey(text))
			{
				Interface.Oxide.LogError(type.FullName + " library tried to register an already registered function: " + text);
			}
			else
			{
				functions[text] = methodInfo;
			}
		}
		PropertyInfo[] array = type.GetProperties();
		foreach (PropertyInfo propertyInfo in array)
		{
			LibraryProperty libraryProperty;
			try
			{
				libraryProperty = propertyInfo.GetCustomAttributes(typeof(LibraryProperty), inherit: true).SingleOrDefault() as LibraryProperty;
				if (libraryProperty == null)
				{
					continue;
				}
			}
			catch (TypeLoadException)
			{
				continue;
			}
			string text2 = libraryProperty.Name ?? propertyInfo.Name;
			if (properties.ContainsKey(text2))
			{
				Interface.Oxide.LogError("{0} library tried to register an already registered property: {1}", type.FullName, text2);
			}
			else
			{
				properties[text2] = propertyInfo;
			}
		}
	}

	public virtual void Shutdown()
	{
	}

	public IEnumerable<string> GetFunctionNames()
	{
		return functions.Keys;
	}

	public IEnumerable<string> GetPropertyNames()
	{
		return properties.Keys;
	}

	public MethodInfo GetFunction(string name)
	{
		if (!functions.TryGetValue(name, out var value))
		{
			return null;
		}
		return value;
	}

	public PropertyInfo GetProperty(string name)
	{
		if (!properties.TryGetValue(name, out var value))
		{
			return null;
		}
		return value;
	}
}


using System;
using System.Collections.Generic;
using ProtoBuf;

[ProtoContract(/*Could not decode attribute arguments.*/)]
public class UserData
{
	public string LastSeenNickname { get; set; } = "Unnamed";

	public HashSet<string> Perms { get; set; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

	public HashSet<string> Groups { get; set; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
}


using System;
using System.Collections.Generic;
using ProtoBuf;

[ProtoContract(/*Could not decode attribute arguments.*/)]
public class GroupData
{
	public string Title { get; set; } = string.Empty;

	public int Rank { get; set; }

	public HashSet<string> Perms { get; set; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

	public string ParentGroup { get; set; } = string.Empty;
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;

public class Permission : Library
{
	private readonly Dictionary<Plugin, HashSet<string>> registeredPermissions;

	private Dictionary<string, UserData> usersData;

	private Dictionary<string, GroupData> groupsData;

	private Func<string, bool> validate;

	public override bool IsGlobal => false;

	public bool IsLoaded { get; private set; }

	public Permission()
	{
		registeredPermissions = new Dictionary<Plugin, HashSet<string>>();
		LoadFromDatafile();
	}

	private void LoadFromDatafile()
	{
		VerifyAndLoadUsersData();
		VerifyAndLoadGroupsData();
		bool flag = false;
		foreach (KeyValuePair<string, GroupData> groupsDatum in groupsData)
		{
			if (!string.IsNullOrEmpty(groupsDatum.Value.ParentGroup) && HasCircularParent(groupsDatum.Key, groupsDatum.Value.ParentGroup))
			{
				Interface.Oxide.LogWarning("Detected circular parent group for '{0}'; removing parent '{1}'", groupsDatum.Key, groupsDatum.Value.ParentGroup);
				groupsDatum.Value.ParentGroup = null;
				flag = true;
			}
		}
		if (flag)
		{
			SaveGroups();
		}
		IsLoaded = true;
	}

	private void VerifyAndLoadUsersData()
	{
		Utility.DatafileToProto<Dictionary<string, UserData>>("oxide.users");
		Dictionary<string, UserData> obj = ProtoStorage.Load<Dictionary<string, UserData>>(new string[1] { "oxide.users" }) ?? new Dictionary<string, UserData>(StringComparer.OrdinalIgnoreCase);
		Dictionary<string, UserData> dictionary = new Dictionary<string, UserData>(StringComparer.OrdinalIgnoreCase);
		HashSet<string> hashSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
		HashSet<string> hashSet2 = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
		bool flag = false;
		foreach (KeyValuePair<string, UserData> item in obj)
		{
			UserData value = item.Value;
			hashSet2.Clear();
			hashSet.Clear();
			foreach (string perm in value.Perms)
			{
				hashSet2.Add(perm);
			}
			value.Perms = new HashSet<string>(hashSet2, StringComparer.OrdinalIgnoreCase);
			foreach (string group in value.Groups)
			{
				hashSet.Add(group);
			}
			value.Groups = new HashSet<string>(hashSet, StringComparer.OrdinalIgnoreCase);
			if (dictionary.ContainsKey(item.Key))
			{
				UserData userData = dictionary[item.Key];
				userData.Perms.UnionWith(value.Perms);
				userData.Groups.UnionWith(value.Groups);
				flag = true;
			}
			else
			{
				dictionary.Add(item.Key, value);
			}
		}
		usersData = dictionary;
		if (flag)
		{
			SaveUsers();
		}
	}

	private void VerifyAndLoadGroupsData()
	{
		Utility.DatafileToProto<Dictionary<string, GroupData>>("oxide.groups");
		Dictionary<string, GroupData> obj = ProtoStorage.Load<Dictionary<string, GroupData>>(new string[1] { "oxide.groups" }) ?? new Dictionary<string, GroupData>(StringComparer.OrdinalIgnoreCase);
		Dictionary<string, GroupData> dictionary = new Dictionary<string, GroupData>(StringComparer.OrdinalIgnoreCase);
		HashSet<string> hashSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
		bool flag = false;
		foreach (KeyValuePair<string, GroupData> item in obj)
		{
			GroupData value = item.Value;
			hashSet.Clear();
			foreach (string perm in value.Perms)
			{
				hashSet.Add(perm);
			}
			value.Perms = new HashSet<string>(hashSet, StringComparer.OrdinalIgnoreCase);
			if (dictionary.ContainsKey(item.Key))
			{
				dictionary[item.Key].Perms.UnionWith(value.Perms);
				flag = true;
			}
			else
			{
				dictionary.Add(item.Key, value);
			}
		}
		groupsData = dictionary;
		if (flag)
		{
			SaveGroups();
		}
	}

	private Dictionary<string, GroupData> VerifyGroupData(Dictionary<string, GroupData> data)
	{
		Dictionary<string, GroupData> dictionary = new Dictionary<string, GroupData>(StringComparer.OrdinalIgnoreCase);
		HashSet<string> hashSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
		foreach (KeyValuePair<string, GroupData> entry in data)
		{
			GroupData value = entry.Value;
			hashSet.Clear();
			foreach (string perm in value.Perms)
			{
				hashSet.Add(perm);
			}
			value.Perms = new HashSet<string>(hashSet, StringComparer.OrdinalIgnoreCase);
			if (dictionary.ContainsKey(entry.Key))
			{
				GroupData groupData = dictionary[entry.Key];
				string text = dictionary.Keys.FirstOrDefault((string x) => x.Equals(entry.Key, StringComparison.OrdinalIgnoreCase));
				groupData.Perms.UnionWith(value.Perms);
				Interface.Oxide.LogWarning("Duplicate group '{0}' found, merged entries with {1}", entry.Key, text);
			}
			else
			{
				dictionary.Add(entry.Key, value);
			}
		}
		return dictionary;
	}

	[LibraryFunction("Export")]
	public void Export(string prefix = "auth")
	{
		if (IsLoaded)
		{
			Interface.Oxide.DataFileSystem.WriteObject(prefix + ".groups", groupsData);
			Interface.Oxide.DataFileSystem.WriteObject(prefix + ".users", usersData);
		}
	}

	public void SaveData()
	{
		SaveUsers();
		SaveGroups();
	}

	public void SaveUsers()
	{
		ProtoStorage.Save(usersData, "oxide.users");
	}

	public void SaveGroups()
	{
		ProtoStorage.Save(groupsData, "oxide.groups");
	}

	public void RegisterValidate(Func<string, bool> val)
	{
		validate = val;
	}

	public void CleanUp()
	{
		if (!IsLoaded || validate == null)
		{
			return;
		}
		string[] array = usersData.Keys.Where((string i) => !validate(i)).ToArray();
		if (array.Length != 0)
		{
			string[] array2 = array;
			foreach (string key in array2)
			{
				usersData.Remove(key);
			}
		}
	}

	public void MigrateGroup(string oldGroupName, string newGroupName)
	{
		if (IsLoaded && GroupExists(oldGroupName))
		{
			string fileDataPath = ProtoStorage.GetFileDataPath("oxide.groups.data");
			File.Copy(fileDataPath, fileDataPath + ".old", overwrite: true);
			string[] groupPermissions = GetGroupPermissions(oldGroupName);
			foreach (string permission in groupPermissions)
			{
				GrantGroupPermission(newGroupName, permission, null);
			}
			if (GetUsersInGroup(oldGroupName).Length == 0)
			{
				RemoveGroup(oldGroupName);
			}
		}
	}

	[LibraryFunction("RegisterPermission")]
	public void RegisterPermission(string permission, Plugin owner)
	{
		if (string.IsNullOrEmpty(permission))
		{
			return;
		}
		if (PermissionExists(permission))
		{
			Interface.Oxide.LogWarning("Duplicate permission registered '{0}' (by plugin '{1}')", permission, owner.Title);
			return;
		}
		if (!registeredPermissions.TryGetValue(owner, out var value))
		{
			value = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
			registeredPermissions.Add(owner, value);
			owner.OnRemovedFromManager.Add(owner_OnRemovedFromManager);
		}
		value.Add(permission);
		Interface.CallHook("OnPermissionRegistered", permission, owner);
		if (!permission.StartsWith(owner.Name + ".", StringComparison.OrdinalIgnoreCase) && !owner.IsCorePlugin)
		{
			Interface.Oxide.LogWarning("Missing plugin name prefix '{0}' for permission '{1}' (by plugin '{2}')", owner.Name.ToLower(), permission, owner.Title);
		}
	}

	[LibraryFunction("PermissionExists")]
	public bool PermissionExists(string permission, Plugin owner = null)
	{
		if (string.IsNullOrEmpty(permission))
		{
			return false;
		}
		if (owner == null)
		{
			if (registeredPermissions.Count > 0)
			{
				if (permission.Equals("*"))
				{
					return true;
				}
				if (permission.EndsWith("*"))
				{
					return registeredPermissions.Values.SelectMany((HashSet<string> v) => v).Any((string p) => p.StartsWith(permission.TrimEnd(new char[1] { '*' }), StringComparison.OrdinalIgnoreCase));
				}
			}
			return registeredPermissions.Values.Any((HashSet<string> v) => v.Contains<string>(permission, StringComparer.OrdinalIgnoreCase));
		}
		if (!registeredPermissions.TryGetValue(owner, out var value))
		{
			return false;
		}
		if (value.Count > 0)
		{
			if (permission.Equals("*"))
			{
				return true;
			}
			if (permission.EndsWith("*"))
			{
				return value.Any((string p) => p.StartsWith(permission.TrimEnd(new char[1] { '*' }), StringComparison.OrdinalIgnoreCase));
			}
		}
		return value.Contains<string>(permission, StringComparer.OrdinalIgnoreCase);
	}

	private void owner_OnRemovedFromManager(Plugin sender, PluginManager manager)
	{
		registeredPermissions.Remove(sender);
	}

	[LibraryFunction("UserIdValid")]
	public bool UserIdValid(string playerId)
	{
		if (validate != null)
		{
			return validate(playerId);
		}
		return true;
	}

	[LibraryFunction("UserExists")]
	public bool UserExists(string playerId)
	{
		return usersData.ContainsKey(playerId);
	}

	public UserData GetUserData(string playerId)
	{
		if (!usersData.TryGetValue(playerId, out var value))
		{
			usersData.Add(playerId, value = new UserData());
		}
		return value;
	}

	[LibraryFunction("UpdateNickname")]
	public void UpdateNickname(string playerId, string playerName)
	{
		if (UserExists(playerId))
		{
			UserData userData = GetUserData(playerId);
			string lastSeenNickname = userData.LastSeenNickname;
			string obj = playerName.Sanitize();
			userData.LastSeenNickname = playerName.Sanitize();
			Interface.CallHook("OnUserNameUpdated", playerId, lastSeenNickname, obj);
		}
	}

	[LibraryFunction("UserHasAnyGroup")]
	public bool UserHasAnyGroup(string playerId)
	{
		if (UserExists(playerId))
		{
			return GetUserData(playerId).Groups.Count > 0;
		}
		return false;
	}

	[LibraryFunction("GroupsHavePermission")]
	public bool GroupsHavePermission(HashSet<string> groupNames, string permission)
	{
		return groupNames.Any((string g) => GroupHasPermission(g, permission));
	}

	[LibraryFunction("GroupHasPermission")]
	public bool GroupHasPermission(string groupName, string permission)
	{
		if (!GroupExists(groupName) || string.IsNullOrEmpty(permission))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (!value.Perms.Contains<string>(permission, StringComparer.OrdinalIgnoreCase))
		{
			return GroupHasPermission(value.ParentGroup, permission);
		}
		return true;
	}

	[LibraryFunction("UserHasPermission")]
	public bool UserHasPermission(string playerId, string permission)
	{
		if (string.IsNullOrEmpty(permission))
		{
			return false;
		}
		if (playerId.Equals("server_console"))
		{
			return true;
		}
		UserData userData = GetUserData(playerId);
		if (userData.Perms.Contains<string>(permission, StringComparer.OrdinalIgnoreCase))
		{
			return true;
		}
		return GroupsHavePermission(userData.Groups, permission);
	}

	[LibraryFunction("GetUserGroups")]
	public string[] GetUserGroups(string playerId)
	{
		return GetUserData(playerId).Groups.ToArray();
	}

	[LibraryFunction("GetUserPermissions")]
	public string[] GetUserPermissions(string playerId)
	{
		UserData userData = GetUserData(playerId);
		HashSet<string> hashSet = new HashSet<string>(userData.Perms, StringComparer.OrdinalIgnoreCase);
		foreach (string group in userData.Groups)
		{
			hashSet.UnionWith(GetGroupPermissions(group));
		}
		return hashSet.ToArray();
	}

	[LibraryFunction("GetGroupPermissions")]
	public string[] GetGroupPermissions(string groupName, bool parents = false)
	{
		if (!GroupExists(groupName))
		{
			return new string[0];
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return new string[0];
		}
		HashSet<string> hashSet = new HashSet<string>(value.Perms);
		if (parents)
		{
			hashSet.UnionWith(GetGroupPermissions(value.ParentGroup));
		}
		return hashSet.ToArray();
	}

	[LibraryFunction("GetPermissions")]
	public string[] GetPermissions()
	{
		return new HashSet<string>(registeredPermissions.Values.SelectMany((HashSet<string> v) => v)).ToArray();
	}

	[LibraryFunction("GetPermissionUsers")]
	public string[] GetPermissionUsers(string permission)
	{
		if (string.IsNullOrEmpty(permission))
		{
			return new string[0];
		}
		HashSet<string> hashSet = new HashSet<string>();
		foreach (KeyValuePair<string, UserData> usersDatum in usersData)
		{
			if (usersDatum.Value.Perms.Contains<string>(permission, StringComparer.OrdinalIgnoreCase))
			{
				hashSet.Add(usersDatum.Key + "(" + usersDatum.Value.LastSeenNickname + ")");
			}
		}
		return hashSet.ToArray();
	}

	[LibraryFunction("GetPermissionGroups")]
	public string[] GetPermissionGroups(string permission)
	{
		if (string.IsNullOrEmpty(permission))
		{
			return new string[0];
		}
		HashSet<string> hashSet = new HashSet<string>();
		foreach (KeyValuePair<string, GroupData> groupsDatum in groupsData)
		{
			if (groupsDatum.Value.Perms.Contains<string>(permission, StringComparer.OrdinalIgnoreCase))
			{
				hashSet.Add(groupsDatum.Key);
			}
		}
		return hashSet.ToArray();
	}

	[LibraryFunction("AddUserGroup")]
	public void AddUserGroup(string playerId, string groupName)
	{
		if (GroupExists(groupName) && GetUserData(playerId).Groups.Add(groupName))
		{
			Interface.Call("OnUserGroupAdded", playerId, groupName);
		}
	}

	[LibraryFunction("RemoveUserGroup")]
	public void RemoveUserGroup(string playerId, string groupName)
	{
		if (!GroupExists(groupName))
		{
			return;
		}
		UserData userData = GetUserData(playerId);
		if (groupName.Equals("*"))
		{
			if (userData.Groups.Count > 0)
			{
				userData.Groups.Clear();
			}
		}
		else if (userData.Groups.Remove(groupName))
		{
			Interface.Call("OnUserGroupRemoved", playerId, groupName);
		}
	}

	[LibraryFunction("UserHasGroup")]
	public bool UserHasGroup(string playerId, string groupName)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		return GetUserData(playerId).Groups.Contains<string>(groupName, StringComparer.OrdinalIgnoreCase);
	}

	[LibraryFunction("GroupExists")]
	public bool GroupExists(string groupName)
	{
		if (!string.IsNullOrEmpty(groupName))
		{
			if (!groupName.Equals("*"))
			{
				return groupsData.ContainsKey(groupName);
			}
			return true;
		}
		return false;
	}

	public GroupData GetGroupData(string groupName)
	{
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return null;
		}
		return value;
	}

	[LibraryFunction("GetGroups")]
	public string[] GetGroups()
	{
		return groupsData.Keys.ToArray();
	}

	[LibraryFunction("GetUsersInGroup")]
	public string[] GetUsersInGroup(string groupName)
	{
		if (!GroupExists(groupName))
		{
			return new string[0];
		}
		return (from u in usersData
			where u.Value.Groups.Contains<string>(groupName, StringComparer.OrdinalIgnoreCase)
			select u.Key + " (" + u.Value.LastSeenNickname + ")").ToArray();
	}

	[LibraryFunction("GetGroupTitle")]
	public string GetGroupTitle(string groupName)
	{
		if (!GroupExists(groupName))
		{
			return string.Empty;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return string.Empty;
		}
		return value.Title;
	}

	[LibraryFunction("GetGroupRank")]
	public int GetGroupRank(string groupName)
	{
		if (!GroupExists(groupName))
		{
			return 0;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return 0;
		}
		return value.Rank;
	}

	[LibraryFunction("GrantUserPermission")]
	public void GrantUserPermission(string playerId, string permission, Plugin owner)
	{
		if (!PermissionExists(permission, owner))
		{
			return;
		}
		UserData userData = GetUserData(playerId);
		if (permission.EndsWith("*"))
		{
			HashSet<string> value;
			if (owner == null)
			{
				value = new HashSet<string>(registeredPermissions.Values.SelectMany((HashSet<string> v) => v));
			}
			else if (!registeredPermissions.TryGetValue(owner, out value))
			{
				return;
			}
			if (permission.Equals("*"))
			{
				value.Aggregate(seed: false, (bool c, string s) => c | userData.Perms.Add(s));
				return;
			}
			value.Where((string p) => p.StartsWith(permission.TrimEnd(new char[1] { '*' }), StringComparison.OrdinalIgnoreCase)).Aggregate(seed: false, (bool c, string s) => c | userData.Perms.Add(s));
		}
		else if (userData.Perms.Add(permission))
		{
			Interface.Call("OnUserPermissionGranted", playerId, permission);
		}
	}

	[LibraryFunction("RevokeUserPermission")]
	public void RevokeUserPermission(string playerId, string permission)
	{
		if (string.IsNullOrEmpty(permission))
		{
			return;
		}
		UserData userData = GetUserData(playerId);
		if (permission.EndsWith("*"))
		{
			if (permission.Equals("*"))
			{
				if (userData.Perms.Count > 0)
				{
					userData.Perms.Clear();
				}
				return;
			}
			userData.Perms.RemoveWhere((string p) => p.StartsWith(permission.TrimEnd(new char[1] { '*' }), StringComparison.OrdinalIgnoreCase));
			_ = 0;
		}
		else if (userData.Perms.Remove(permission))
		{
			Interface.Call("OnUserPermissionRevoked", playerId, permission);
		}
	}

	[LibraryFunction("GrantGroupPermission")]
	public void GrantGroupPermission(string groupName, string permission, Plugin owner)
	{
		if (!PermissionExists(permission, owner) || !GroupExists(groupName) || !groupsData.TryGetValue(groupName, out var groupData))
		{
			return;
		}
		if (permission.EndsWith("*"))
		{
			HashSet<string> value;
			if (owner == null)
			{
				value = new HashSet<string>(registeredPermissions.Values.SelectMany((HashSet<string> v) => v));
			}
			else if (!registeredPermissions.TryGetValue(owner, out value))
			{
				return;
			}
			if (permission.Equals("*"))
			{
				value.Aggregate(seed: false, (bool c, string s) => c | groupData.Perms.Add(s));
				return;
			}
			value.Where((string p) => p.StartsWith(permission.TrimEnd(new char[1] { '*' }), StringComparison.OrdinalIgnoreCase)).Aggregate(seed: false, (bool c, string s) => c | groupData.Perms.Add(s));
		}
		else if (groupData.Perms.Add(permission))
		{
			Interface.Call("OnGroupPermissionGranted", groupName, permission);
		}
	}

	[LibraryFunction("RevokeGroupPermission")]
	public void RevokeGroupPermission(string groupName, string permission)
	{
		if (!GroupExists(groupName) || string.IsNullOrEmpty(permission) || !groupsData.TryGetValue(groupName, out var value))
		{
			return;
		}
		if (permission.EndsWith("*"))
		{
			if (permission.Equals("*"))
			{
				if (value.Perms.Count > 0)
				{
					value.Perms.Clear();
				}
				return;
			}
			value.Perms.RemoveWhere((string p) => p.StartsWith(permission.TrimEnd(new char[1] { '*' }), StringComparison.OrdinalIgnoreCase));
			_ = 0;
		}
		else if (value.Perms.Remove(permission))
		{
			Interface.Call("OnGroupPermissionRevoked", groupName, permission);
		}
	}

	[LibraryFunction("CreateGroup")]
	public bool CreateGroup(string groupName, string groupTitle, int groupRank)
	{
		if (GroupExists(groupName) || string.IsNullOrEmpty(groupName))
		{
			return false;
		}
		GroupData value = new GroupData
		{
			Title = groupTitle,
			Rank = groupRank
		};
		groupsData.Add(groupName, value);
		Interface.CallHook("OnGroupCreated", groupName, groupTitle, groupRank);
		return true;
	}

	[LibraryFunction("RemoveGroup")]
	public bool RemoveGroup(string groupName)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		bool flag = groupsData.Remove(groupName);
		if (flag)
		{
			foreach (GroupData item in groupsData.Values.Where((GroupData g) => g.ParentGroup == groupName))
			{
				item.ParentGroup = string.Empty;
			}
		}
		if (usersData.Values.Aggregate(seed: false, (bool current, UserData userData) => current | userData.Groups.Remove(groupName)))
		{
			SaveUsers();
		}
		if (flag)
		{
			Interface.CallHook("OnGroupDeleted", groupName);
		}
		return true;
	}

	[LibraryFunction("SetGroupTitle")]
	public bool SetGroupTitle(string groupName, string groupTitle)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (value.Title == groupTitle)
		{
			return true;
		}
		value.Title = groupTitle;
		Interface.CallHook("OnGroupTitleSet", groupName, groupTitle);
		return true;
	}

	[LibraryFunction("SetGroupRank")]
	public bool SetGroupRank(string groupName, int groupRank)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (value.Rank == groupRank)
		{
			return true;
		}
		value.Rank = groupRank;
		Interface.CallHook("OnGroupRankSet", groupName, groupRank);
		return true;
	}

	[LibraryFunction("GetGroupParent")]
	public string GetGroupParent(string groupName)
	{
		if (!GroupExists(groupName))
		{
			return string.Empty;
		}
		if (groupsData.TryGetValue(groupName, out var value))
		{
			return value.ParentGroup;
		}
		return string.Empty;
	}

	[LibraryFunction("SetGroupParent")]
	public bool SetGroupParent(string groupName, string parentGroupName)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (string.IsNullOrEmpty(parentGroupName))
		{
			value.ParentGroup = null;
			return true;
		}
		if (!GroupExists(parentGroupName) || groupName.Equals(parentGroupName))
		{
			return false;
		}
		if (!string.IsNullOrEmpty(value.ParentGroup) && value.ParentGroup.Equals(parentGroupName))
		{
			return true;
		}
		if (HasCircularParent(groupName, parentGroupName))
		{
			return false;
		}
		value.ParentGroup = parentGroupName;
		Interface.CallHook("OnGroupParentSet", groupName, parentGroupName);
		return true;
	}

	private bool HasCircularParent(string groupName, string parentGroupName)
	{
		if (!groupsData.TryGetValue(parentGroupName, out var value))
		{
			return false;
		}
		HashSet<string> hashSet = new HashSet<string> { groupName, parentGroupName };
		while (!string.IsNullOrEmpty(value.ParentGroup))
		{
			if (!hashSet.Add(value.ParentGroup))
			{
				return true;
			}
			if (!groupsData.TryGetValue(value.ParentGroup, out value))
			{
				return false;
			}
		}
		return false;
	}
}


using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;

public class Plugins : Library
{
	public override bool IsGlobal => false;

	public PluginManager PluginManager { get; private set; }

	public Plugins(PluginManager pluginmanager)
	{
		PluginManager = pluginmanager;
	}

	[LibraryFunction("Exists")]
	public bool Exists(string name)
	{
		return PluginManager.GetPlugin(name) != null;
	}

	[LibraryFunction("Find")]
	public Plugin Find(string name)
	{
		return PluginManager.GetPlugin(name);
	}

	[LibraryFunction("CallHook")]
	public object CallHook(string hookname, params object[] args)
	{
		return Interface.Call(hookname, args);
	}

	[LibraryFunction("GetAll")]
	public Plugin[] GetAll()
	{
		return PluginManager.GetPlugins().ToArray();
	}
}


using System;
using Oxide.Core.Libraries;

public class Time : Library
{
	private static readonly DateTime Epoch = new DateTime(1970, 1, 1);

	public override bool IsGlobal => false;

	[LibraryFunction("GetCurrentTime")]
	public DateTime GetCurrentTime()
	{
		return DateTime.UtcNow;
	}

	[LibraryFunction("GetDateTimeFromUnix")]
	public DateTime GetDateTimeFromUnix(uint timestamp)
	{
		DateTime epoch = Epoch;
		return epoch.AddSeconds(timestamp);
	}

	[LibraryFunction("GetUnixTimestamp")]
	public uint GetUnixTimestamp()
	{
		return (uint)DateTime.UtcNow.Subtract(Epoch).TotalSeconds;
	}

	[LibraryFunction("GetUnixFromDateTime")]
	public uint GetUnixFromDateTime(DateTime time)
	{
		return (uint)time.Subtract(Epoch).TotalSeconds;
	}
}


using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;

public class Timer : Library
{
	public class TimeSlot
	{
		public int Count;

		public TimerInstance FirstInstance;

		public TimerInstance LastInstance;

		public void GetExpired(double now, Queue<TimerInstance> queue)
		{
			TimerInstance timerInstance = FirstInstance;
			while (timerInstance != null && !((double)timerInstance.ExpiresAt > now))
			{
				queue.Enqueue(timerInstance);
				timerInstance = timerInstance.NextInstance;
			}
		}

		public void InsertTimer(TimerInstance timer)
		{
			float expiresAt = timer.ExpiresAt;
			TimerInstance firstInstance = FirstInstance;
			TimerInstance lastInstance = LastInstance;
			TimerInstance timerInstance = firstInstance;
			if (firstInstance != null)
			{
				float expiresAt2 = firstInstance.ExpiresAt;
				float expiresAt3 = lastInstance.ExpiresAt;
				if (expiresAt <= expiresAt2)
				{
					timerInstance = firstInstance;
				}
				else if (expiresAt >= expiresAt3)
				{
					timerInstance = null;
				}
				else if (expiresAt3 - expiresAt < expiresAt - expiresAt2)
				{
					timerInstance = lastInstance;
					TimerInstance timerInstance2 = timerInstance;
					while (timerInstance2 != null && !(timerInstance2.ExpiresAt <= expiresAt))
					{
						timerInstance = timerInstance2;
						timerInstance2 = timerInstance2.PreviousInstance;
					}
				}
				else
				{
					while (timerInstance != null && !(timerInstance.ExpiresAt > expiresAt))
					{
						timerInstance = timerInstance.NextInstance;
					}
				}
			}
			if (timerInstance == null)
			{
				timer.NextInstance = null;
				if (lastInstance == null)
				{
					FirstInstance = timer;
					LastInstance = timer;
				}
				else
				{
					lastInstance.NextInstance = timer;
					timer.PreviousInstance = lastInstance;
					LastInstance = timer;
				}
			}
			else
			{
				TimerInstance previousInstance = timerInstance.PreviousInstance;
				if (previousInstance == null)
				{
					FirstInstance = timer;
				}
				else
				{
					previousInstance.NextInstance = timer;
				}
				timerInstance.PreviousInstance = timer;
				timer.PreviousInstance = previousInstance;
				timer.NextInstance = timerInstance;
			}
			timer.Added(this);
		}
	}

	public class TimerInstance
	{
		public const int MaxPooled = 5000;

		internal static Queue<TimerInstance> Pool = new Queue<TimerInstance>();

		internal float ExpiresAt;

		internal TimeSlot TimeSlot;

		internal TimerInstance NextInstance;

		internal TimerInstance PreviousInstance;

		private Event.Callback<Plugin, PluginManager> removedFromManager;

		private Timer timer;

		public int Repetitions { get; private set; }

		public float Delay { get; private set; }

		public Action Callback { get; private set; }

		public bool Destroyed { get; private set; }

		public Plugin Owner { get; private set; }

		internal TimerInstance(Timer timer, int repetitions, float delay, Action callback, Plugin owner)
		{
			Load(timer, repetitions, delay, callback, owner);
		}

		internal void Load(Timer timer, int repetitions, float delay, Action callback, Plugin owner)
		{
			this.timer = timer;
			Repetitions = repetitions;
			Delay = delay;
			Callback = callback;
			ExpiresAt = Oxide.Now + delay;
			Owner = owner;
			Destroyed = false;
			if (owner != null)
			{
				removedFromManager = owner.OnRemovedFromManager.Add(OnRemovedFromManager);
			}
		}

		public void Reset(float delay = -1f, int repetitions = 1)
		{
			lock (Lock)
			{
				if (delay < 0f)
				{
					delay = Delay;
				}
				else
				{
					Delay = delay;
				}
				Repetitions = repetitions;
				ExpiresAt = Oxide.Now + delay;
				if (Destroyed)
				{
					Destroyed = false;
					Plugin owner = Owner;
					if (owner != null)
					{
						removedFromManager = owner.OnRemovedFromManager.Add(OnRemovedFromManager);
					}
				}
				else
				{
					Remove();
				}
				timer.InsertTimer(this);
			}
		}

		public bool Destroy()
		{
			lock (Lock)
			{
				if (Destroyed)
				{
					return false;
				}
				Destroyed = true;
				Remove();
				Event.Remove(ref removedFromManager);
			}
			return true;
		}

		public bool DestroyToPool()
		{
			lock (Lock)
			{
				if (Destroyed)
				{
					return false;
				}
				Destroyed = true;
				Callback = null;
				Remove();
				Event.Remove(ref removedFromManager);
				Queue<TimerInstance> pool = Pool;
				if (pool.Count < 5000)
				{
					pool.Enqueue(this);
				}
			}
			return true;
		}

		internal void Added(TimeSlot time_slot)
		{
			time_slot.Count++;
			Count++;
			TimeSlot = time_slot;
		}

		internal void Invoke(float now)
		{
			if (Repetitions > 0 && --Repetitions == 0)
			{
				Destroy();
				FireCallback();
				return;
			}
			Remove();
			float num = (ExpiresAt += Delay);
			timer.InsertTimer(this, num < now);
			FireCallback();
		}

		internal void Remove()
		{
			TimeSlot timeSlot = TimeSlot;
			if (timeSlot != null)
			{
				timeSlot.Count--;
				Count--;
				TimerInstance previousInstance = PreviousInstance;
				TimerInstance nextInstance = NextInstance;
				if (nextInstance == null)
				{
					timeSlot.LastInstance = previousInstance;
				}
				else
				{
					nextInstance.PreviousInstance = previousInstance;
				}
				if (previousInstance == null)
				{
					timeSlot.FirstInstance = nextInstance;
				}
				else
				{
					previousInstance.NextInstance = nextInstance;
				}
				TimeSlot = null;
				PreviousInstance = null;
				NextInstance = null;
			}
		}

		private void FireCallback()
		{
			Owner?.TrackStart();
			try
			{
				Callback();
			}
			catch (Exception ex)
			{
				Destroy();
				string text = $"Failed to run a {Delay:0.00} timer";
				if ((bool)Owner && Owner != null)
				{
					text += $" in '{Owner.Name} v{Owner.Version}'";
				}
				Interface.Oxide.LogException(text, ex);
			}
			finally
			{
				Owner?.TrackEnd();
			}
		}

		private void OnRemovedFromManager(Plugin sender, PluginManager manager)
		{
			Destroy();
		}
	}

	internal static readonly object Lock = new object();

	internal static readonly OxideMod Oxide = Interface.Oxide;

	public const int TimeSlots = 512;

	public const int LastTimeSlot = 511;

	public const float TickDuration = 0.01f;

	private readonly TimeSlot[] timeSlots = new TimeSlot[512];

	private readonly Queue<TimerInstance> expiredInstanceQueue = new Queue<TimerInstance>();

	private int currentSlot;

	private double nextSlotAt = 0.009999999776482582;

	public override bool IsGlobal => false;

	public static int Count { get; private set; }

	public Timer()
	{
		for (int i = 0; i < 512; i++)
		{
			timeSlots[i] = new TimeSlot();
		}
	}

	public void Update(float delta)
	{
		float now = Oxide.Now;
		TimeSlot[] array = timeSlots;
		Queue<TimerInstance> queue = expiredInstanceQueue;
		int num = 0;
		lock (Lock)
		{
			int num2 = currentSlot;
			double num3 = nextSlotAt;
			while (true)
			{
				array[num2].GetExpired((num3 > (double)now) ? ((double)now) : num3, queue);
				if ((double)now <= num3)
				{
					break;
				}
				num++;
				num2 = ((num2 < 511) ? (num2 + 1) : 0);
				num3 += 0.009999999776482582;
			}
			if (num > 0)
			{
				currentSlot = num2;
				nextSlotAt = num3;
			}
			int count = queue.Count;
			for (int i = 0; i < count; i++)
			{
				TimerInstance timerInstance = queue.Dequeue();
				if (!timerInstance.Destroyed)
				{
					timerInstance.Invoke(now);
				}
			}
		}
	}

	internal TimerInstance AddTimer(int repetitions, float delay, Action callback, Plugin owner = null)
	{
		lock (Lock)
		{
			Queue<TimerInstance> pool = TimerInstance.Pool;
			TimerInstance timerInstance;
			if (pool.Count > 0)
			{
				timerInstance = pool.Dequeue();
				timerInstance.Load(this, repetitions, delay, callback, owner);
			}
			else
			{
				timerInstance = new TimerInstance(this, repetitions, delay, callback, owner);
			}
			InsertTimer(timerInstance, timerInstance.ExpiresAt < Oxide.Now);
			return timerInstance;
		}
	}

	private void InsertTimer(TimerInstance timer, bool in_past = false)
	{
		int num = (in_past ? currentSlot : ((int)(timer.ExpiresAt / 0.01f) & 0x1FF));
		timeSlots[num].InsertTimer(timer);
	}

	[LibraryFunction("Once")]
	public TimerInstance Once(float delay, Action callback, Plugin owner = null)
	{
		return AddTimer(1, delay, callback, owner);
	}

	[LibraryFunction("Repeat")]
	public TimerInstance Repeat(float delay, int reps, Action callback, Plugin owner = null)
	{
		return AddTimer(reps, delay, callback, owner);
	}

	[LibraryFunction("NextFrame")]
	public TimerInstance NextFrame(Action callback)
	{
		return AddTimer(1, 0f, callback);
	}
}


public enum RequestMethod
{
	DELETE,
	GET,
	PATCH,
	POST,
	PUT
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

public class WebRequests : Library
{
	public class WebRequest
	{
		private HttpWebRequest request;

		private WaitHandle waitHandle;

		private RegisteredWaitHandle registeredWaitHandle;

		private Event.Callback<Plugin, PluginManager> removedFromManager;

		public Action<int, string> Callback { get; }

		public float Timeout { get; set; }

		public string Method { get; set; }

		public string Url { get; }

		public string Body { get; set; }

		public int ResponseCode { get; protected set; }

		public string ResponseText { get; protected set; }

		public Plugin Owner { get; protected set; }

		public Dictionary<string, string> RequestHeaders { get; set; }

		public DecompressionMethods DecompressionMethod { get; set; }

		public WebRequest(string url, Action<int, string> callback, Plugin owner)
		{
			Url = url;
			Callback = callback;
			Owner = owner;
			removedFromManager = Owner?.OnRemovedFromManager.Add(owner_OnRemovedFromManager);
		}

		public void Start()
		{
			try
			{
				request = (HttpWebRequest)System.Net.WebRequest.Create(Url);
				request.Method = Method;
				request.Credentials = CredentialCache.DefaultCredentials;
				request.Proxy = null;
				request.KeepAlive = false;
				request.Timeout = (int)Math.Round((Timeout.Equals(0f) ? WebRequests.Timeout : Timeout) * 1000f);
				if (AllowDecompression && DecompressionMethod == DecompressionMethods.None)
				{
					request.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;
				}
				else
				{
					request.AutomaticDecompression = DecompressionMethod;
				}
				request.ServicePoint.MaxIdleTime = request.Timeout;
				request.ServicePoint.Expect100Continue = ServicePointManager.Expect100Continue;
				request.ServicePoint.ConnectionLimit = ServicePointManager.DefaultConnectionLimit;
				request.UserAgent = $"Oxide Mod (v{OxideMod.Version}; https://umod.org)";
				if (!request.RequestUri.IsLoopback && IPAddress.TryParse(Interface.Oxide.Config.Options.WebRequestIP, out IPAddress address))
				{
					request.ServicePoint.BindIPEndPointDelegate = (ServicePoint servicePoint, IPEndPoint remoteEndPoint, int retryCount) => new IPEndPoint(address, 0);
				}
				byte[] data = new byte[0];
				if (Body != null)
				{
					data = Encoding.UTF8.GetBytes(Body);
					request.ContentLength = data.Length;
					request.ContentType = "application/x-www-form-urlencoded";
				}
				if (RequestHeaders != null)
				{
					request.SetRawHeaders(RequestHeaders);
				}
				if (data.Length != 0)
				{
					request.BeginGetRequestStream(delegate(IAsyncResult result)
					{
						if (request != null)
						{
							try
							{
								using Stream stream = request.EndGetRequestStream(result);
								stream.Write(data, 0, data.Length);
							}
							catch (Exception exception)
							{
								ResponseText = FormatWebException(exception, ResponseText ?? string.Empty);
								request?.Abort();
								OnComplete();
								return;
							}
							WaitForResponse();
						}
					}, null);
				}
				else
				{
					WaitForResponse();
				}
			}
			catch (Exception ex)
			{
				ResponseText = FormatWebException(ex, ResponseText ?? string.Empty);
				string text = "Web request produced exception (Url: " + Url + ")";
				if ((bool)Owner)
				{
					text += $" in '{Owner.Name} v{Owner.Version}' plugin";
				}
				Interface.Oxide.LogException(text, ex);
				request?.Abort();
				OnComplete();
			}
		}

		private void WaitForResponse()
		{
			IAsyncResult asyncResult = request.BeginGetResponse(delegate(IAsyncResult res)
			{
				try
				{
					using HttpWebResponse httpWebResponse = (HttpWebResponse)request.EndGetResponse(res);
					using (Stream stream = httpWebResponse.GetResponseStream())
					{
						using StreamReader streamReader = new StreamReader(stream);
						ResponseText = streamReader.ReadToEnd();
					}
					ResponseCode = (int)httpWebResponse.StatusCode;
				}
				catch (WebException ex)
				{
					ResponseText = FormatWebException(ex, ResponseText ?? string.Empty);
					if (ex.Response is HttpWebResponse httpWebResponse2)
					{
						try
						{
							using Stream stream2 = httpWebResponse2.GetResponseStream();
							using StreamReader streamReader2 = new StreamReader(stream2);
							ResponseText = streamReader2.ReadToEnd();
						}
						catch (Exception)
						{
						}
						ResponseCode = (int)httpWebResponse2.StatusCode;
					}
				}
				catch (Exception ex3)
				{
					ResponseText = FormatWebException(ex3, ResponseText ?? string.Empty);
					string text = "Web request produced exception (Url: " + Url + ")";
					if ((bool)Owner)
					{
						text += $" in '{Owner.Name} v{Owner.Version}' plugin";
					}
					Interface.Oxide.LogException(text, ex3);
				}
				if (request != null)
				{
					request.Abort();
					OnComplete();
				}
			}, null);
			waitHandle = asyncResult.AsyncWaitHandle;
			registeredWaitHandle = ThreadPool.RegisterWaitForSingleObject(waitHandle, OnTimeout, null, request.Timeout, executeOnlyOnce: true);
		}

		private void OnTimeout(object state, bool timedOut)
		{
			if (timedOut)
			{
				request?.Abort();
			}
			if (Owner != null)
			{
				Event.Remove(ref removedFromManager);
				Owner = null;
			}
		}

		private void OnComplete()
		{
			Event.Remove(ref removedFromManager);
			registeredWaitHandle?.Unregister(waitHandle);
			Interface.Oxide.NextTick(delegate
			{
				if (request != null)
				{
					request = null;
					Owner?.TrackStart();
					try
					{
						Callback(ResponseCode, ResponseText);
					}
					catch (Exception ex)
					{
						string text = "Web request callback raised an exception";
						if ((bool)Owner && Owner != null)
						{
							text += $" in '{Owner.Name} v{Owner.Version}' plugin";
						}
						Interface.Oxide.LogException(text, ex);
					}
					Owner?.TrackEnd();
					Owner = null;
				}
			});
		}

		private void owner_OnRemovedFromManager(Plugin sender, PluginManager manager)
		{
			if (request != null)
			{
				HttpWebRequest httpWebRequest = request;
				request = null;
				httpWebRequest.Abort();
			}
		}
	}

	private static readonly Covalence covalence = Interface.Oxide.GetLibrary<Covalence>();

	public static float Timeout = 30f;

	[Obsolete("AllowDecompression is deprecated, use Enqueue with DecompressionMode instead")]
	public static bool AllowDecompression = false;

	private readonly Queue<WebRequest> queue = new Queue<WebRequest>();

	private readonly object syncroot = new object();

	private readonly Thread workerthread;

	private readonly AutoResetEvent workevent = new AutoResetEvent(initialState: false);

	private bool shutdown;

	private readonly int maxWorkerThreads;

	private readonly int maxCompletionPortThreads;

	public static string FormatWebException(Exception exception, string response)
	{
		if (!string.IsNullOrEmpty(response))
		{
			response += Environment.NewLine;
		}
		response += exception.Message;
		if (exception.InnerException != null)
		{
			response = FormatWebException(exception.InnerException, response);
		}
		return response;
	}

	public WebRequests()
	{
		ServicePointManager.Expect100Continue = false;
		ServicePointManager.ServerCertificateValidationCallback = (object <p0>, X509Certificate <p1>, X509Chain <p2>, SslPolicyErrors <p3>) => true;
		ServicePointManager.DefaultConnectionLimit = 200;
		ThreadPool.GetMaxThreads(out maxWorkerThreads, out maxCompletionPortThreads);
		maxCompletionPortThreads = (int)((double)maxCompletionPortThreads * 0.6);
		maxWorkerThreads = (int)((double)maxWorkerThreads * 0.75);
		workerthread = new Thread(Worker);
		workerthread.Start();
	}

	public override void Shutdown()
	{
		if (!shutdown)
		{
			shutdown = true;
			workevent.Set();
			Thread.Sleep(250);
			workerthread.Abort();
		}
	}

	private void Worker()
	{
		try
		{
			while (!shutdown)
			{
				ThreadPool.GetAvailableThreads(out var workerThreads, out var completionPortThreads);
				if (workerThreads <= maxWorkerThreads || completionPortThreads <= maxCompletionPortThreads)
				{
					Thread.Sleep(100);
					continue;
				}
				WebRequest webRequest = null;
				lock (syncroot)
				{
					if (queue.Count > 0)
					{
						webRequest = queue.Dequeue();
					}
				}
				if (webRequest != null)
				{
					webRequest.Start();
				}
				else
				{
					workevent.WaitOne();
				}
			}
		}
		catch (Exception ex)
		{
			Interface.Oxide.LogException("WebRequests worker: ", ex);
		}
	}

	[LibraryFunction("EnqueueGet")]
	[Obsolete("EnqueueGet is deprecated, use Enqueue instead")]
	public void EnqueueGet(string url, Action<int, string> callback, Plugin owner, Dictionary<string, string> headers = null, float timeout = 0f)
	{
		Enqueue(url, null, callback, owner, RequestMethod.GET, headers, timeout);
	}

	[LibraryFunction("EnqueuePost")]
	[Obsolete("EnqueuePost is deprecated, use Enqueue instead")]
	public void EnqueuePost(string url, string body, Action<int, string> callback, Plugin owner, Dictionary<string, string> headers = null, float timeout = 0f)
	{
		Enqueue(url, body, callback, owner, RequestMethod.POST, headers, timeout);
	}

	[LibraryFunction("EnqueuePut")]
	[Obsolete("EnqueuePut is deprecated, use Enqueue instead")]
	public void EnqueuePut(string url, string body, Action<int, string> callback, Plugin owner, Dictionary<string, string> headers = null, float timeout = 0f)
	{
		Enqueue(url, body, callback, owner, RequestMethod.PUT, headers, timeout);
	}

	[LibraryFunction("Enqueue")]
	public void Enqueue(string url, string body, Action<int, string> callback, Plugin owner, RequestMethod method = RequestMethod.GET, Dictionary<string, string> headers = null, float timeout = 0f, DecompressionMethods decompressionMethod = DecompressionMethods.None)
	{
		WebRequest item = new WebRequest(url, callback, owner)
		{
			Method = method.ToString(),
			RequestHeaders = headers,
			Timeout = timeout,
			Body = body,
			DecompressionMethod = decompressionMethod
		};
		lock (syncroot)
		{
			queue.Enqueue(item);
		}
		workevent.Set();
	}

	[LibraryFunction("GetQueueLength")]
	public int GetQueueLength()
	{
		return queue.Count;
	}
}


using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;

public static class HttpWebRequestExtensions
{
	private static readonly string[] RestrictedHeaders;

	private static readonly Dictionary<string, PropertyInfo> HeaderProperties;

	static HttpWebRequestExtensions()
	{
		RestrictedHeaders = new string[14]
		{
			"Accept", "Connection", "Content-Length", "Content-Type", "Date", "Expect", "Host", "If-Modified-Since", "Keep-Alive", "Proxy-Connection",
			"Range", "Referer", "Transfer-Encoding", "User-Agent"
		};
		HeaderProperties = new Dictionary<string, PropertyInfo>(StringComparer.OrdinalIgnoreCase);
		Type typeFromHandle = typeof(HttpWebRequest);
		string[] restrictedHeaders = RestrictedHeaders;
		foreach (string text in restrictedHeaders)
		{
			HeaderProperties[text] = typeFromHandle.GetProperty(text.Replace("-", ""));
		}
	}

	public static void SetRawHeaders(this WebRequest request, Dictionary<string, string> headers)
	{
		foreach (KeyValuePair<string, string> header in headers)
		{
			SetRawHeader(request, header.Key, header.Value);
		}
	}

	public static void SetRawHeader(this WebRequest request, string name, string value)
	{
		if (HeaderProperties.ContainsKey(name))
		{
			PropertyInfo propertyInfo = HeaderProperties[name];
			if (propertyInfo.PropertyType == typeof(DateTime))
			{
				propertyInfo.SetValue(request, DateTime.Parse(value), null);
			}
			else if (propertyInfo.PropertyType == typeof(bool))
			{
				propertyInfo.SetValue(request, bool.Parse(value), null);
			}
			else if (propertyInfo.PropertyType == typeof(long))
			{
				propertyInfo.SetValue(request, long.Parse(value), null);
			}
			else
			{
				propertyInfo.SetValue(request, value, null);
			}
		}
		else
		{
			request.Headers[name] = value;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Text;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

public sealed class CommandHandler
{
	private CommandCallback callback;

	private Func<string, bool> commandFilter;

	public CommandHandler(CommandCallback callback, Func<string, bool> commandFilter)
	{
		this.callback = callback;
		this.commandFilter = commandFilter;
	}

	public static string GetChatCommandPrefix(string message)
	{
		foreach (string item in Interface.Oxide.Config.Commands.ChatPrefix)
		{
			if (message.StartsWith(item, StringComparison.OrdinalIgnoreCase))
			{
				return item;
			}
		}
		return null;
	}

	public bool HandleChatMessage(IPlayer player, string message)
	{
		if (message.Length == 0)
		{
			return false;
		}
		string chatCommandPrefix = GetChatCommandPrefix(message);
		if (chatCommandPrefix == null)
		{
			return false;
		}
		message = message.Substring(chatCommandPrefix.Length);
		ParseCommand(message, out var cmd, out var args);
		player.LastCommand = CommandType.Chat;
		if (cmd != null)
		{
			return HandleCommand(player, cmd, args);
		}
		return false;
	}

	public bool HandleConsoleMessage(IPlayer player, string message)
	{
		if (message.StartsWith("global."))
		{
			message = message.Substring(7);
		}
		ParseCommand(message, out var cmd, out var args);
		player.LastCommand = CommandType.Console;
		if (cmd != null)
		{
			return HandleCommand(player, cmd, args);
		}
		return false;
	}

	private bool HandleCommand(IPlayer player, string command, string[] args)
	{
		if ((commandFilter == null || commandFilter(command)) && callback != null)
		{
			return callback(player, command, args);
		}
		return false;
	}

	private void ParseCommand(string argstr, out string cmd, out string[] args)
	{
		List<string> list = new List<string>();
		StringBuilder stringBuilder = new StringBuilder();
		bool flag = false;
		foreach (char c in argstr)
		{
			if (c == '"')
			{
				if (flag)
				{
					string text = stringBuilder.ToString().Trim();
					if (!string.IsNullOrEmpty(text))
					{
						list.Add(text);
					}
					stringBuilder = new StringBuilder();
					flag = false;
				}
				else
				{
					flag = true;
				}
			}
			else if (char.IsWhiteSpace(c) && !flag)
			{
				string text2 = stringBuilder.ToString().Trim();
				if (!string.IsNullOrEmpty(text2))
				{
					list.Add(text2);
				}
				stringBuilder = new StringBuilder();
			}
			else
			{
				stringBuilder.Append(c);
			}
		}
		if (stringBuilder.Length > 0)
		{
			string text3 = stringBuilder.ToString().Trim();
			if (!string.IsNullOrEmpty(text3))
			{
				list.Add(text3);
			}
		}
		if (list.Count == 0)
		{
			cmd = null;
			args = null;
		}
		else
		{
			cmd = list[0].ToLowerInvariant();
			list.RemoveAt(0);
			args = list.ToArray();
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Logging;
using Oxide.Core.Plugins;

public class Covalence : Library
{
	private ICommandSystem cmdSystem;

	private ICovalenceProvider provider;

	private readonly Logger logger;

	public override bool IsGlobal => false;

	[LibraryProperty("Server")]
	public IServer Server { get; private set; }

	[LibraryProperty("Players")]
	public IPlayerManager Players { get; private set; }

	[LibraryProperty("Game")]
	public string Game => provider?.GameName ?? string.Empty;

	[LibraryProperty("ClientAppId")]
	public uint ClientAppId => provider?.ClientAppId ?? 0;

	[LibraryProperty("ServerAppId")]
	public uint ServerAppId => provider?.ServerAppId ?? 0;

	public string FormatText(string text)
	{
		return provider.FormatText(text);
	}

	public Covalence()
	{
		logger = Interface.Oxide.RootLogger;
	}

	internal void Initialize()
	{
		Type baseType = typeof(ICovalenceProvider);
		IEnumerable<Type> enumerable = null;
		Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
		foreach (Assembly assembly in assemblies)
		{
			Type[] array = null;
			try
			{
				array = assembly.GetTypes();
			}
			catch (ReflectionTypeLoadException ex)
			{
				array = ex.Types;
			}
			catch (TypeLoadException ex2)
			{
				logger.Write(LogType.Warning, "Covalence: Type {0} could not be loaded from assembly '{1}': {2}", ex2.TypeName, assembly.FullName, ex2);
			}
			if (array != null)
			{
				enumerable = enumerable?.Concat(array) ?? array;
			}
		}
		if (enumerable == null)
		{
			logger.Write(LogType.Warning, "Covalence not available yet for this game");
			return;
		}
		List<Type> list = new List<Type>(enumerable.Where((Type t) => t != null && t.IsClass && !t.IsAbstract && t.FindInterfaces((Type m, object o) => m == baseType, null).Length == 1));
		if (list.Count == 0)
		{
			logger.Write(LogType.Warning, "Covalence not available yet for this game");
			return;
		}
		Type type;
		if (list.Count > 1)
		{
			type = list[0];
			StringBuilder stringBuilder = new StringBuilder();
			for (int j = 1; j < list.Count; j++)
			{
				if (j > 1)
				{
					stringBuilder.Append(',');
				}
				stringBuilder.Append(list[j].FullName);
			}
			logger.Write(LogType.Warning, "Multiple Covalence providers found! Using {0}. (Also found {1})", type, stringBuilder);
		}
		else
		{
			type = list[0];
		}
		try
		{
			provider = (ICovalenceProvider)Activator.CreateInstance(type);
		}
		catch (Exception ex3)
		{
			logger.Write(LogType.Warning, "Got exception when instantiating Covalence provider, Covalence will not be functional for this session.");
			logger.Write(LogType.Warning, "{0}", ex3);
			return;
		}
		Server = provider.CreateServer();
		Players = provider.CreatePlayerManager();
		cmdSystem = provider.CreateCommandSystemProvider();
		logger.Write(LogType.Info, "Using Covalence provider for game '{0}'", provider.GameName);
	}

	public void RegisterCommand(string command, Plugin plugin, CommandCallback callback)
	{
		if (cmdSystem == null)
		{
			return;
		}
		try
		{
			cmdSystem.RegisterCommand(command, plugin, callback);
		}
		catch (CommandAlreadyExistsException)
		{
			string text = plugin?.Name ?? "An unknown plugin";
			logger.Write(LogType.Error, "{0} tried to register command '{1}', this command already exists and cannot be overridden!", text, command);
		}
	}

	public void UnregisterCommand(string command, Plugin plugin)
	{
		cmdSystem?.UnregisterCommand(command, plugin);
	}
}


using System;
using System.Runtime.Serialization;

[Serializable]
public class CommandAlreadyExistsException : Exception
{
	public CommandAlreadyExistsException()
	{
	}

	public CommandAlreadyExistsException(string cmd)
		: base("Command " + cmd + " already exists")
	{
	}

	public CommandAlreadyExistsException(string message, Exception inner)
		: base(message, inner)
	{
	}

	protected CommandAlreadyExistsException(SerializationInfo info, StreamingContext context)
		: base(info, context)
	{
	}
}


using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

public class Element : Formatter.Poolable<Element>
{
	public ElementType Type;

	public object Val;

	public List<Element> Body = new List<Element>();

	public Element()
	{
	}

	public Element(ElementType type, object val)
	{
		Type = type;
		Val = val;
	}

	private static Element Get(ElementType type, object val, bool shouldPool)
	{
		if (!shouldPool)
		{
			return new Element(type, val);
		}
		Element element = Formatter.Poolable<Element>.TakeFromPool();
		element.Type = type;
		element.Val = val;
		return element;
	}

	protected override void Reset()
	{
		Type = ElementType.String;
		Val = null;
		Formatter.Poolable<Element>.ReturnToPool(Body);
	}

	public static Element String(object s, bool shouldPool = false)
	{
		return Get(ElementType.String, s, shouldPool);
	}

	public static Element Tag(ElementType type, bool shouldPool = false)
	{
		return Get(type, null, shouldPool);
	}

	public static Element ParamTag(ElementType type, object val, bool shouldPool = false)
	{
		return Get(type, val, shouldPool);
	}
}


public enum ElementType
{
	String,
	Bold,
	Italic,
	Color,
	Size
}


using System;
using System.Collections.Generic;
using System.Text;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Pooling;

public class Formatter
{
	private class Token : Poolable<Token>
	{
		public TokenType Type;

		public object Val;

		public string Pattern;

		private static readonly Stack<Token> pool = new Stack<Token>();

		public static Token TakeFromPool(TokenType type, object val, string pattern)
		{
			Token token = Poolable<Token>.TakeFromPool();
			token.Type = type;
			token.Val = val;
			token.Pattern = pattern;
			return token;
		}

		protected override void Reset()
		{
			Type = TokenType.String;
			Val = null;
			Pattern = null;
		}
	}

	private enum TokenType
	{
		String,
		Bold,
		Italic,
		Color,
		Size,
		CloseBold,
		CloseItalic,
		CloseColor,
		CloseSize
	}

	private class Lexer : Poolable<Lexer>
	{
		private enum StateType
		{
			Str,
			Tag,
			CloseTag,
			EndTag,
			ParamTag
		}

		private List<Token> tokens = new List<Token>();

		private int patternStart;

		private int tokenStart;

		private int position;

		private string text;

		private StateType state;

		private TokenType currentTokenType;

		private Func<string, object> currentParser;

		private char Current()
		{
			return text[position];
		}

		private void Next()
		{
			position++;
		}

		private void StartNewToken()
		{
			tokenStart = position;
		}

		private void StartNewPattern()
		{
			patternStart = position;
			StartNewToken();
		}

		private void ResetTokenStart()
		{
			tokenStart = patternStart;
		}

		private string Token()
		{
			return text.Substring(tokenStart, position - tokenStart);
		}

		private void Add(TokenType type, object val = null)
		{
			Token item = Formatter.Token.TakeFromPool(type, val, text.Substring(patternStart, position - patternStart));
			tokens.Add(item);
		}

		private void WritePatternString()
		{
			if (patternStart < position)
			{
				int num = tokenStart;
				tokenStart = patternStart;
				Add(TokenType.String, Token());
				tokenStart = num;
			}
		}

		private static bool IsValidColorCode(string val)
		{
			if (val.Length != 6 && val.Length != 8)
			{
				return false;
			}
			foreach (char c in val)
			{
				if ((c < '0' || c > '9') && (c < 'a' || c > 'f') && (c < 'A' || c > 'F'))
				{
					return false;
				}
			}
			return true;
		}

		private static object ParseColor(string val)
		{
			if (!colorNames.TryGetValue(val.ToLower(), out var value) && !IsValidColorCode(val))
			{
				return null;
			}
			value = value ?? val;
			if (value.Length == 6)
			{
				value += "ff";
			}
			return value;
		}

		private static object ParseSize(string val)
		{
			if (int.TryParse(val, out var result))
			{
				return result;
			}
			return null;
		}

		private void EndTag()
		{
			if (Current() == ']')
			{
				Next();
				Add(currentTokenType);
				StartNewPattern();
				state = StateType.Str;
			}
			else
			{
				ResetTokenStart();
				state = StateType.Str;
			}
		}

		private void ParamTag()
		{
			if (Current() != ']')
			{
				Next();
				return;
			}
			object obj = currentParser(Token());
			if (obj == null)
			{
				ResetTokenStart();
				state = StateType.Str;
				return;
			}
			Next();
			Add(currentTokenType, obj);
			StartNewPattern();
			state = StateType.Str;
		}

		private void CloseTag()
		{
			switch (Current())
			{
			case 'b':
				currentTokenType = TokenType.CloseBold;
				Next();
				state = StateType.EndTag;
				break;
			case 'i':
				currentTokenType = TokenType.CloseItalic;
				Next();
				state = StateType.EndTag;
				break;
			case '#':
				currentTokenType = TokenType.CloseColor;
				Next();
				state = StateType.EndTag;
				break;
			case '+':
				currentTokenType = TokenType.CloseSize;
				Next();
				state = StateType.EndTag;
				break;
			default:
				ResetTokenStart();
				state = StateType.Str;
				break;
			}
		}

		private void Tag()
		{
			switch (Current())
			{
			case 'b':
				currentTokenType = TokenType.Bold;
				Next();
				state = StateType.EndTag;
				break;
			case 'i':
				currentTokenType = TokenType.Italic;
				Next();
				state = StateType.EndTag;
				break;
			case '#':
				currentTokenType = TokenType.Color;
				currentParser = ParseColor;
				Next();
				StartNewToken();
				state = StateType.ParamTag;
				break;
			case '+':
				currentTokenType = TokenType.Size;
				currentParser = ParseSize;
				Next();
				StartNewToken();
				state = StateType.ParamTag;
				break;
			case '/':
				Next();
				state = StateType.CloseTag;
				break;
			default:
				ResetTokenStart();
				state = StateType.Str;
				break;
			}
		}

		private void Str()
		{
			if (Current() == '[')
			{
				WritePatternString();
				StartNewPattern();
				Next();
				state = StateType.Tag;
			}
			else
			{
				Next();
			}
		}

		public static List<Token> Lex(string text)
		{
			return new Lexer().TokenizeText(text);
		}

		public List<Token> TokenizeText(string text)
		{
			this.text = text;
			while (position < text.Length)
			{
				switch (state)
				{
				case StateType.Str:
					Str();
					break;
				case StateType.Tag:
					Tag();
					break;
				case StateType.CloseTag:
					CloseTag();
					break;
				case StateType.EndTag:
					EndTag();
					break;
				case StateType.ParamTag:
					ParamTag();
					break;
				}
			}
			WritePatternString();
			return tokens;
		}

		protected override void Reset()
		{
			text = null;
			patternStart = 0;
			tokenStart = 0;
			position = 0;
			Poolable<Formatter.Token>.ReturnToPool(tokens);
			currentTokenType = TokenType.String;
			currentParser = null;
			state = StateType.Str;
		}
	}

	private class Entry : Poolable<Entry>
	{
		public string Pattern;

		public Element Element;

		public static Entry TakeFromPool(string pattern, Element element)
		{
			Entry entry = Poolable<Entry>.TakeFromPool();
			entry.Pattern = pattern;
			entry.Element = element;
			return entry;
		}

		protected override void Reset()
		{
			Pattern = null;
			Element = null;
		}
	}

	private class ElementTreeBuilder : Poolable<ElementTreeBuilder>
	{
		private readonly Stack<Entry> entries = new Stack<Entry>();

		public bool shouldPoolElements;

		public Element ProcessTokens(List<Token> tokens)
		{
			int num = 0;
			entries.Clear();
			entries.Push(Entry.TakeFromPool(null, Element.Tag(ElementType.String, shouldPoolElements)));
			while (num < tokens.Count)
			{
				Token token = tokens[num++];
				Element element = entries.Peek().Element;
				if (token.Type == closeTags[element.Type])
				{
					entries.Pop();
					entries.Peek().Element.Body.Add(element);
					continue;
				}
				switch (token.Type)
				{
				case TokenType.String:
					element.Body.Add(Element.String(token.Val, shouldPoolElements));
					break;
				case TokenType.Bold:
					entries.Push(Entry.TakeFromPool(token.Pattern, Element.Tag(ElementType.Bold, shouldPoolElements)));
					break;
				case TokenType.Italic:
					entries.Push(Entry.TakeFromPool(token.Pattern, Element.Tag(ElementType.Italic, shouldPoolElements)));
					break;
				case TokenType.Color:
					entries.Push(Entry.TakeFromPool(token.Pattern, Element.ParamTag(ElementType.Color, token.Val, shouldPoolElements)));
					break;
				case TokenType.Size:
					entries.Push(Entry.TakeFromPool(token.Pattern, Element.ParamTag(ElementType.Size, token.Val, shouldPoolElements)));
					break;
				default:
					element.Body.Add(Element.String(token.Pattern, shouldPoolElements));
					break;
				}
			}
			while (entries.Count > 1)
			{
				Entry entry = entries.Pop();
				List<Element> body = entries.Peek().Element.Body;
				body.Add(Element.String(entry.Pattern));
				body.AddRange(entry.Element.Body);
				Poolable<Entry>.ReturnToPool(entry);
			}
			Entry entry2 = entries.Pop();
			Element element2 = entry2.Element;
			Poolable<Entry>.ReturnToPool(entry2);
			return element2;
		}

		protected override void Reset()
		{
			shouldPoolElements = false;
			while (entries.Count > 0)
			{
				Poolable<Entry>.ReturnToPool(entries.Pop());
			}
		}
	}

	private class Tag
	{
		public string Open;

		public string Close;

		public Tag(string open, string close)
		{
			Open = open;
			Close = close;
		}
	}

	public abstract class Poolable<T> where T : Poolable<T>, new()
	{
		private static readonly Stack<T> _pool = new Stack<T>();

		private static readonly object _poolLock = new object();

		protected bool isFromPool { get; private set; }

		public static T TakeFromPool()
		{
			T val;
			lock (_poolLock)
			{
				val = ((_pool.Count > 0) ? _pool.Pop() : new T());
			}
			val.isFromPool = true;
			return val;
		}

		public static void ReturnToPool(T obj)
		{
			if (obj == null || !obj.isFromPool)
			{
				return;
			}
			obj.Reset();
			lock (_poolLock)
			{
				_pool.Push(obj);
			}
		}

		public static void ReturnToPool(List<T> objs)
		{
			if (objs != null)
			{
				for (int i = 0; i < objs.Count; i++)
				{
					ReturnToPool(objs[i]);
				}
				objs.Clear();
			}
		}

		protected abstract void Reset();
	}

	private static readonly Dictionary<string, string> colorNames = new Dictionary<string, string>
	{
		["aqua"] = "00ffff",
		["black"] = "000000",
		["blue"] = "0000ff",
		["brown"] = "a52a2a",
		["cyan"] = "00ffff",
		["darkblue"] = "0000a0",
		["fuchsia"] = "ff00ff",
		["green"] = "008000",
		["grey"] = "808080",
		["lightblue"] = "add8e6",
		["lime"] = "00ff00",
		["magenta"] = "ff00ff",
		["maroon"] = "800000",
		["navy"] = "000080",
		["olive"] = "808000",
		["orange"] = "ffa500",
		["purple"] = "800080",
		["red"] = "ff0000",
		["silver"] = "c0c0c0",
		["teal"] = "008080",
		["white"] = "ffffff",
		["yellow"] = "ffff00"
	};

	private static readonly Tag emptyTag = new Tag(string.Empty, string.Empty);

	private static readonly Tag boldTag = new Tag("<b>", "</b>");

	private static readonly Tag italicTag = new Tag("<i>", "</i>");

	private static readonly Dictionary<ElementType, Func<object, Tag>> plainTextTranslations = new Dictionary<ElementType, Func<object, Tag>>();

	private static readonly Dictionary<ElementType, Func<object, Tag>> unityTranslations = new Dictionary<ElementType, Func<object, Tag>>
	{
		[ElementType.Bold] = (object _) => boldTag,
		[ElementType.Italic] = (object _) => italicTag,
		[ElementType.Color] = (object c) => new Tag($"<color=#{c}>", "</color>"),
		[ElementType.Size] = (object s) => new Tag($"<size={s}>", "</size>")
	};

	private static readonly Dictionary<ElementType, Func<object, Tag>> rustLegacyTranslations = new Dictionary<ElementType, Func<object, Tag>> { [ElementType.Color] = (object c) => new Tag("[color #" + RGBAtoRGB(c) + "]", "[color #ffffff]") };

	private static readonly Dictionary<ElementType, Func<object, Tag>> rokAnd7DTDTranslations = new Dictionary<ElementType, Func<object, Tag>> { [ElementType.Color] = (object c) => new Tag("[" + RGBAtoRGB(c) + "]", "[e7e7e7]") };

	private static readonly Dictionary<ElementType, Func<object, Tag>> terrariaTranslations = new Dictionary<ElementType, Func<object, Tag>> { [ElementType.Color] = (object c) => new Tag("[c/" + RGBAtoRGB(c) + ":", "]") };

	private static readonly IPoolProvider<StringBuilder> stringPool = Interface.Oxide.PoolFactory.GetProvider<StringBuilder>();

	private static readonly Dictionary<ElementType, TokenType?> closeTags = new Dictionary<ElementType, TokenType?>
	{
		[ElementType.String] = null,
		[ElementType.Bold] = TokenType.CloseBold,
		[ElementType.Italic] = TokenType.CloseItalic,
		[ElementType.Color] = TokenType.CloseColor,
		[ElementType.Size] = TokenType.CloseSize
	};

	public static List<Element> Parse(string text)
	{
		return ParseText(text, shouldPoolElements: false).Body;
	}

	private static Element ParseText(string text, bool shouldPoolElements = true)
	{
		Lexer lexer = Poolable<Lexer>.TakeFromPool();
		try
		{
			return ProcessTokens(lexer.TokenizeText(text), shouldPoolElements);
		}
		finally
		{
			Poolable<Lexer>.ReturnToPool(lexer);
		}
	}

	private static Element ProcessTokens(List<Token> tokens, bool shouldPoolElements)
	{
		ElementTreeBuilder elementTreeBuilder = Poolable<ElementTreeBuilder>.TakeFromPool();
		try
		{
			elementTreeBuilder.shouldPoolElements = shouldPoolElements;
			return elementTreeBuilder.ProcessTokens(tokens);
		}
		finally
		{
			Poolable<ElementTreeBuilder>.ReturnToPool(elementTreeBuilder);
		}
	}

	private static Tag Translation(Element e, Dictionary<ElementType, Func<object, Tag>> translations)
	{
		if (!translations.TryGetValue(e.Type, out var value))
		{
			return emptyTag;
		}
		return value(e.Val);
	}

	private static string ToTreeFormat(List<Element> tree, Dictionary<ElementType, Func<object, Tag>> translations)
	{
		StringBuilder stringBuilder = stringPool.Take();
		try
		{
			AppendTreeFormat(tree, translations, stringBuilder);
			return stringBuilder.ToString();
		}
		finally
		{
			((IPoolProvider)stringPool).Return((object)stringBuilder);
		}
	}

	private static void AppendTreeFormat(List<Element> tree, Dictionary<ElementType, Func<object, Tag>> translations, StringBuilder sb)
	{
		foreach (Element item in tree)
		{
			if (item.Type == ElementType.String)
			{
				sb.Append(item.Val);
				continue;
			}
			Tag tag = Translation(item, translations);
			sb.Append(tag.Open);
			AppendTreeFormat(item.Body, translations, sb);
			sb.Append(tag.Close);
		}
	}

	private static string ToTreeFormat(string text, Dictionary<ElementType, Func<object, Tag>> translations)
	{
		Element element = ParseText(text);
		try
		{
			return ToTreeFormat(element.Body, translations);
		}
		finally
		{
			Poolable<Element>.ReturnToPool(element);
		}
	}

	private static string RGBAtoRGB(object rgba)
	{
		return rgba.ToString().Substring(0, 6);
	}

	public static string ToPlaintext(string text)
	{
		return ToTreeFormat(text, plainTextTranslations);
	}

	public static string ToUnity(string text)
	{
		return ToTreeFormat(text, unityTranslations);
	}

	public static string ToRustLegacy(string text)
	{
		return ToTreeFormat(text, rustLegacyTranslations);
	}

	public static string ToRoKAnd7DTD(string text)
	{
		return ToTreeFormat(text, rokAnd7DTDTranslations);
	}

	public static string ToTerraria(string text)
	{
		return ToTreeFormat(text, terrariaTranslations);
	}
}


public enum CommandType
{
	Chat,
	Console
}


using Oxide.Core.Libraries.Covalence;

public delegate bool CommandCallback(IPlayer caller, string command, string[] args);


using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

public interface ICommandSystem
{
	void RegisterCommand(string command, Plugin plugin, CommandCallback callback);

	void UnregisterCommand(string command, Plugin plugin);
}


using Oxide.Core.Libraries.Covalence;

public interface ICovalenceProvider
{
	string GameName { get; }

	uint ClientAppId { get; }

	uint ServerAppId { get; }

	ICommandSystem CreateCommandSystemProvider();

	IPlayerManager CreatePlayerManager();

	IServer CreateServer();

	string FormatText(string text);
}


using System;
using System.Globalization;
using Oxide.Core.Libraries.Covalence;

public interface IPlayer
{
	object Object { get; }

	CommandType LastCommand { get; set; }

	string Name { get; set; }

	string Id { get; }

	string Address { get; }

	int Ping { get; }

	CultureInfo Language { get; }

	bool IsConnected { get; }

	bool IsSleeping { get; }

	bool IsServer { get; }

	bool IsAdmin { get; }

	bool IsBanned { get; }

	TimeSpan BanTimeRemaining { get; }

	float Health { get; set; }

	float MaxHealth { get; set; }

	void Ban(string reason, TimeSpan duration = default(TimeSpan));

	void Heal(float amount);

	void Hurt(float amount);

	void Kick(string reason);

	void Kill();

	void Rename(string name);

	void Teleport(float x, float y, float z);

	void Teleport(GenericPosition pos);

	void Unban();

	void Position(out float x, out float y, out float z);

	GenericPosition Position();

	void Message(string message, string prefix, params object[] args);

	void Message(string message);

	void Reply(string message, string prefix, params object[] args);

	void Reply(string message);

	void Command(string command, params object[] args);

	bool HasPermission(string perm);

	void GrantPermission(string perm);

	void RevokePermission(string perm);

	bool BelongsToGroup(string group);

	void AddToGroup(string group);

	void RemoveFromGroup(string group);
}


using Oxide.Core.Libraries.Covalence;

public class GenericPosition
{
	public float X;

	public float Y;

	public float Z;

	public GenericPosition()
	{
	}

	public GenericPosition(float x, float y, float z)
	{
		X = x;
		Y = y;
		Z = z;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is GenericPosition))
		{
			return false;
		}
		GenericPosition genericPosition = (GenericPosition)obj;
		if (X.Equals(genericPosition.X) && Y.Equals(genericPosition.Y))
		{
			return Z.Equals(genericPosition.Z);
		}
		return false;
	}

	public static bool operator ==(GenericPosition a, GenericPosition b)
	{
		if ((object)a == b)
		{
			return true;
		}
		if ((object)a == null || (object)b == null)
		{
			return false;
		}
		if (a.X.Equals(b.X) && a.Y.Equals(b.Y))
		{
			return a.Z.Equals(b.Z);
		}
		return false;
	}

	public static bool operator !=(GenericPosition a, GenericPosition b)
	{
		return !(a == b);
	}

	public static GenericPosition operator +(GenericPosition a, GenericPosition b)
	{
		return new GenericPosition(a.X + b.X, a.Y + b.Y, a.Z + b.Z);
	}

	public static GenericPosition operator -(GenericPosition a, GenericPosition b)
	{
		return new GenericPosition(a.X - b.X, a.Y - b.Y, a.Z - b.Z);
	}

	public static GenericPosition operator *(float mult, GenericPosition a)
	{
		return new GenericPosition(a.X * mult, a.Y * mult, a.Z * mult);
	}

	public static GenericPosition operator *(GenericPosition a, float mult)
	{
		return new GenericPosition(a.X * mult, a.Y * mult, a.Z * mult);
	}

	public static GenericPosition operator /(GenericPosition a, float div)
	{
		return new GenericPosition(a.X / div, a.Y / div, a.Z / div);
	}

	public override int GetHashCode()
	{
		return X.GetHashCode() ^ (Y.GetHashCode() << 2) ^ (Z.GetHashCode() >> 2);
	}

	public override string ToString()
	{
		return $"({X}, {Y}, {Z})";
	}
}


using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

public interface IPlayerManager
{
	IEnumerable<IPlayer> All { get; }

	IEnumerable<IPlayer> Connected { get; }

	IPlayer FindPlayerById(string id);

	IPlayer FindPlayerByObj(object obj);

	IPlayer FindPlayer(string partialNameOrId);

	IEnumerable<IPlayer> FindPlayers(string partialNameOrId);
}


using System;
using System.Globalization;
using System.Net;
using Oxide.Core.Libraries.Covalence;

public interface IServer
{
	string Name { get; set; }

	IPAddress Address { get; }

	IPAddress LocalAddress { get; }

	ushort Port { get; }

	string Version { get; }

	string Protocol { get; }

	CultureInfo Language { get; }

	int Players { get; }

	int MaxPlayers { get; set; }

	DateTime Time { get; set; }

	SaveInfo SaveInfo { get; }

	void Ban(string id, string reason, TimeSpan duration = default(TimeSpan));

	TimeSpan BanTimeRemaining(string id);

	bool IsBanned(string id);

	void Save();

	void Unban(string id);

	void Broadcast(string message, string prefix, params object[] args);

	void Broadcast(string message);

	void Command(string command, params object[] args);
}


using System;
using System.IO;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;

public class SaveInfo
{
	private readonly Time time = Interface.Oxide.GetLibrary<Time>();

	private readonly string FullPath;

	public string SaveName { get; private set; }

	public DateTime CreationTime { get; private set; }

	public uint CreationTimeUnix { get; private set; }

	public void Refresh()
	{
		if (File.Exists(FullPath))
		{
			CreationTime = File.GetCreationTime(FullPath);
			CreationTimeUnix = time.GetUnixFromDateTime(CreationTime);
		}
	}

	private SaveInfo(string filepath)
	{
		FullPath = filepath;
		SaveName = Utility.GetFileNameWithoutExtension(filepath);
		Refresh();
	}

	public static SaveInfo Create(string filepath)
	{
		if (!File.Exists(filepath))
		{
			return null;
		}
		return new SaveInfo(filepath);
	}
}


using System.Collections.Generic;
using System.Linq;
using Oxide;
using Oxide.Core;
using Oxide.Core.Extensions;

public abstract class Extension
{
	public abstract string Name { get; }

	public abstract string Author { get; }

	public abstract VersionNumber Version { get; }

	public string Filename { get; set; }

	public virtual string Branch { get; }

	public virtual bool IsCoreExtension { get; }

	public virtual bool IsGameExtension { get; }

	public virtual bool SupportsReloading { get; }

	public ExtensionManager Manager { get; }

	public virtual string[] DefaultReferences { get; protected set; } = new string[0];

	public virtual string[] WhitelistAssemblies { get; protected set; } = new string[0];

	public virtual string[] WhitelistNamespaces { get; protected set; } = new string[0];

	public Extension(ExtensionManager manager)
	{
		Manager = manager;
		Branch = ExtensionMethods.Metadata(GetType().Assembly, "GitBranch").FirstOrDefault() ?? "master";
	}

	public virtual void Load()
	{
	}

	public virtual void Unload()
	{
	}

	public virtual void LoadPluginWatchers(string pluginDirectory)
	{
	}

	public virtual IEnumerable<string> GetPreprocessorDirectives()
	{
		return Enumerable.Empty<string>();
	}

	public virtual void OnModLoad()
	{
	}

	public virtual void OnShutdown()
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using Oxide.Core;
using Oxide.Core.Extensions;
using Oxide.Core.Libraries;
using Oxide.Core.Logging;
using Oxide.Core.Plugins;
using Oxide.Core.Plugins.Watchers;

public sealed class ExtensionManager
{
	private IList<Extension> extensions;

	private const string extSearchPattern = "Oxide.*.dll";

	private IList<PluginLoader> pluginloaders;

	private IDictionary<string, Library> libraries;

	private IList<PluginChangeWatcher> changewatchers;

	public CompoundLogger Logger { get; private set; }

	public ExtensionManager(CompoundLogger logger)
	{
		Logger = logger;
		extensions = new List<Extension>();
		pluginloaders = new List<PluginLoader>();
		libraries = new Dictionary<string, Library>();
		changewatchers = new List<PluginChangeWatcher>();
	}

	public void RegisterPluginLoader(PluginLoader loader)
	{
		pluginloaders.Add(loader);
	}

	public IEnumerable<PluginLoader> GetPluginLoaders()
	{
		return pluginloaders;
	}

	public void RegisterLibrary(string name, Library library)
	{
		if (libraries.ContainsKey(name))
		{
			Interface.Oxide.LogError("An extension tried to register an already registered library: " + name);
		}
		else
		{
			libraries[name] = library;
		}
	}

	public IEnumerable<string> GetLibraries()
	{
		return libraries.Keys;
	}

	public Library GetLibrary(string name)
	{
		if (libraries.TryGetValue(name, out var value))
		{
			return value;
		}
		return null;
	}

	public void RegisterPluginChangeWatcher(PluginChangeWatcher watcher)
	{
		changewatchers.Add(watcher);
	}

	public IEnumerable<PluginChangeWatcher> GetPluginChangeWatchers()
	{
		return changewatchers;
	}

	public void LoadExtension(string filename)
	{
		string fileNameWithoutExtension = Utility.GetFileNameWithoutExtension(filename);
		if (extensions.Any((Extension x) => x.Filename == filename))
		{
			Logger.Write(LogType.Error, "Failed to load extension '" + fileNameWithoutExtension + "': extension already loaded.");
			return;
		}
		try
		{
			Assembly assembly = null;
			Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
			foreach (Assembly assembly2 in assemblies)
			{
				if (!(assembly2.GetName().Name != fileNameWithoutExtension))
				{
					assembly = assembly2;
					break;
				}
			}
			if (assembly == null)
			{
				assembly = Assembly.Load(File.ReadAllBytes(filename));
			}
			Type typeFromHandle = typeof(Extension);
			Type type = null;
			Type[] exportedTypes = assembly.GetExportedTypes();
			foreach (Type type2 in exportedTypes)
			{
				if (typeFromHandle.IsAssignableFrom(type2))
				{
					type = type2;
					break;
				}
			}
			if (type == null)
			{
				Logger.Write(LogType.Error, "Failed to load extension {0} ({1})", fileNameWithoutExtension, "Specified assembly does not implement an Extension class");
			}
			else if (Activator.CreateInstance(type, this) is Extension extension)
			{
				extension.Filename = filename;
				extension.Load();
				extensions.Add(extension);
				string text = extension.Version.ToString();
				if (extension.Branch != "master")
				{
					text = text + "@" + extension.Branch;
				}
				Logger.Write(LogType.Info, "Loaded extension " + extension.Name + " v" + text + " by " + extension.Author);
			}
		}
		catch (Exception ex)
		{
			Logger.WriteException("Failed to load extension " + fileNameWithoutExtension, ex);
			RemoteLogger.Exception("Failed to load extension " + fileNameWithoutExtension, ex);
		}
	}

	public void UnloadExtension(string filename)
	{
		string fileNameWithoutExtension = Utility.GetFileNameWithoutExtension(filename);
		Extension extension = extensions.SingleOrDefault((Extension x) => x.Filename == filename);
		if (extension == null)
		{
			Logger.Write(LogType.Error, "Failed to unload extension '" + fileNameWithoutExtension + "': extension not loaded.");
			return;
		}
		if (extension.IsCoreExtension || extension.IsGameExtension)
		{
			Logger.Write(LogType.Error, "Failed to unload extension '" + fileNameWithoutExtension + "': you may not unload Core or Game extensions.");
			return;
		}
		if (!extension.SupportsReloading)
		{
			Logger.Write(LogType.Error, "Failed to unload extension '" + fileNameWithoutExtension + "': this extension doesn't support reloading.");
			return;
		}
		extension.Unload();
		extensions.Remove(extension);
		Logger.Write(LogType.Info, $"Unloaded extension {extension.Name} v{extension.Version} by {extension.Author}");
	}

	public void ReloadExtension(string filename)
	{
		string name = Utility.GetFileNameWithoutExtension(filename);
		Extension extension = extensions.SingleOrDefault((Extension x) => Utility.GetFileNameWithoutExtension(x.Filename) == name);
		if (extension == null)
		{
			LoadExtension(filename);
			return;
		}
		if (extension.IsCoreExtension || extension.IsGameExtension)
		{
			Logger.Write(LogType.Error, "Failed to unload extension '" + name + "': you may not unload Core or Game extensions.");
			return;
		}
		if (!extension.SupportsReloading)
		{
			Logger.Write(LogType.Error, "Failed to reload extension '" + name + "': this extension doesn't support reloading.");
			return;
		}
		UnloadExtension(filename);
		LoadExtension(filename);
	}

	public void LoadAllExtensions(string directory)
	{
		List<string> list = new List<string>();
		List<string> list2 = new List<string>();
		List<string> list3 = new List<string>();
		string[] ignoredExtensions = new string[3] { "Oxide.Core.dll", "Oxide.References.dll", "Oxide.Common.dll" };
		string[] array = new string[7] { "Oxide.CSharp", "Oxide.JavaScript", "Oxide.Lua", "Oxide.MySql", "Oxide.Python", "Oxide.SQLite", "Oxide.Unity" };
		string[] array2 = new string[19]
		{
			"Oxide.Blackwake", "Oxide.Blockstorm", "Oxide.FortressCraft", "Oxide.FromTheDepths", "Oxide.GangBeasts", "Oxide.Hurtworld", "Oxide.InterstellarRift", "Oxide.MedievalEngineers", "Oxide.Nomad", "Oxide.PlanetExplorers",
			"Oxide.ReignOfKings", "Oxide.Rust", "Oxide.RustLegacy", "Oxide.SavageLands", "Oxide.SevenDaysToDie", "Oxide.SpaceEngineers", "Oxide.TheForest", "Oxide.Terraria", "Oxide.Unturned"
		};
		string[] files = Directory.GetFiles(directory, "Oxide.*.dll");
		foreach (string item in files.Where((string e) => !ignoredExtensions.Contains<string>(Path.GetFileName(e))))
		{
			if (item.Contains("Oxide.Core.") && Array.IndexOf(files, item.Replace(".Core", "")) != -1)
			{
				Cleanup.Add(item);
				continue;
			}
			if (item.Contains("Oxide.Ext.") && Array.IndexOf(files, item.Replace(".Ext", "")) != -1)
			{
				Cleanup.Add(item);
				continue;
			}
			if (item.Contains("Oxide.Game."))
			{
				Cleanup.Add(item);
				continue;
			}
			string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(item);
			if (array.Contains(fileNameWithoutExtension))
			{
				list.Add(item);
			}
			else if (array2.Contains(fileNameWithoutExtension))
			{
				list2.Add(item);
			}
			else
			{
				list3.Add(item);
			}
		}
		foreach (string item2 in list)
		{
			LoadExtension(Path.Combine(directory, item2));
		}
		foreach (string item3 in list2)
		{
			LoadExtension(Path.Combine(directory, item3));
		}
		foreach (string item4 in list3)
		{
			LoadExtension(Path.Combine(directory, item4));
		}
		Extension[] array3 = extensions.ToArray();
		foreach (Extension extension in array3)
		{
			try
			{
				extension.OnModLoad();
			}
			catch (Exception ex)
			{
				extensions.Remove(extension);
				Logger.WriteException($"Failed OnModLoad extension {extension.Name} v{extension.Version}", ex);
				RemoteLogger.Exception($"Failed OnModLoad extension {extension.Name} v{extension.Version}", ex);
			}
		}
	}

	public IEnumerable<Extension> GetAllExtensions()
	{
		return extensions;
	}

	public bool IsExtensionPresent(string name)
	{
		return extensions.Any((Extension e) => e.Name == name);
	}

	public bool IsExtensionPresent<T>() where T : Extension
	{
		return extensions.Any((Extension e) => e is T);
	}

	public Extension GetExtension(string name)
	{
		try
		{
			return extensions.Single((Extension e) => e.Name == name);
		}
		catch (Exception)
		{
			return null;
		}
	}

	public T GetExtension<T>() where T : Extension
	{
		return (T)extensions.FirstOrDefault((Extension e) => e is T);
	}
}


using System.Data.Common;
using Oxide.Core.Plugins;

public sealed class Connection
{
	public string ConnectionString { get; set; }

	public bool ConnectionPersistent { get; set; }

	public DbConnection Con { get; set; }

	public Plugin Plugin { get; set; }

	public long LastInsertRowId { get; set; }

	public Connection(string connection, bool persistent)
	{
		ConnectionString = connection;
		ConnectionPersistent = persistent;
	}
}


using System;
using System.Collections.Generic;
using Oxide.Core.Database;
using Oxide.Core.Plugins;

public interface IDatabaseProvider
{
	Connection OpenDb(string file, Plugin plugin, bool persistent = false);

	void CloseDb(Connection db);

	Sql NewSql();

	void Query(Sql sql, Connection db, Action<List<Dictionary<string, object>>> callback);

	void ExecuteNonQuery(Sql sql, Connection db, Action<int> callback = null);

	void Insert(Sql sql, Connection db, Action<int> callback = null);

	void Update(Sql sql, Connection db, Action<int> callback = null);

	void Delete(Sql sql, Connection db, Action<int> callback = null);
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using Oxide.Core.Database;

public class Sql
{
	public class SqlJoinClause
	{
		private readonly Sql _sql;

		public SqlJoinClause(Sql sql)
		{
			_sql = sql;
		}

		public Sql On(string onClause, params object[] args)
		{
			return _sql.Append("ON " + onClause, args);
		}
	}

	private static readonly Regex Filter = new Regex("LOAD\\s*DATA|INTO\\s*(OUTFILE|DUMPFILE)|LOAD_FILE", RegexOptions.IgnoreCase | RegexOptions.Compiled);

	private static readonly Regex RxParams = new Regex("(?<!@)@\\w+", RegexOptions.Compiled);

	private readonly object[] _args;

	private readonly string _sql;

	private object[] _argsFinal;

	private Sql _rhs;

	private string _sqlFinal;

	public static Sql Builder => new Sql();

	public string SQL
	{
		get
		{
			Build();
			return _sqlFinal;
		}
	}

	public object[] Arguments
	{
		get
		{
			Build();
			return _argsFinal;
		}
	}

	public Sql()
	{
	}

	public Sql(string sql, params object[] args)
	{
		_sql = sql;
		_args = args;
	}

	private void Build()
	{
		if (_sqlFinal == null)
		{
			StringBuilder stringBuilder = new StringBuilder();
			List<object> list = new List<object>();
			Build(stringBuilder, list, null);
			string text = stringBuilder.ToString();
			if (Filter.IsMatch(text))
			{
				throw new Exception("Commands LOAD DATA, LOAD_FILE, OUTFILE, DUMPFILE not allowed.");
			}
			_sqlFinal = text;
			_argsFinal = list.ToArray();
		}
	}

	public Sql Append(Sql sql)
	{
		Sql sql2 = this;
		while (sql2._rhs != null)
		{
			sql2 = sql2._rhs;
		}
		sql2._rhs = sql;
		return this;
	}

	public Sql Append(string sql, params object[] args)
	{
		return Append(new Sql(sql, args));
	}

	private static bool Is(Sql sql, string sqltype)
	{
		if (sql != null && sql._sql != null)
		{
			return sql._sql.StartsWith(sqltype, StringComparison.InvariantCultureIgnoreCase);
		}
		return false;
	}

	private void Build(StringBuilder sb, List<object> args, Sql lhs)
	{
		if (!string.IsNullOrEmpty(_sql))
		{
			if (sb.Length > 0)
			{
				sb.Append("\n");
			}
			string text = ProcessParams(_sql, _args, args);
			if (Is(lhs, "WHERE ") && Is(this, "WHERE "))
			{
				text = "AND " + text.Substring(6);
			}
			if (Is(lhs, "ORDER BY ") && Is(this, "ORDER BY "))
			{
				text = ", " + text.Substring(9);
			}
			sb.Append(text);
		}
		_rhs?.Build(sb, args, this);
	}

	public Sql Where(string sql, params object[] args)
	{
		return Append(new Sql("WHERE (" + sql + ")", args));
	}

	public Sql OrderBy(params object[] columns)
	{
		return Append(new Sql("ORDER BY " + string.Join(", ", columns.Select((object x) => x.ToString()).ToArray())));
	}

	public Sql Select(params object[] columns)
	{
		return Append(new Sql("SELECT " + string.Join(", ", columns.Select((object x) => x.ToString()).ToArray())));
	}

	public Sql From(params object[] tables)
	{
		return Append(new Sql("FROM " + string.Join(", ", tables.Select((object x) => x.ToString()).ToArray())));
	}

	public Sql GroupBy(params object[] columns)
	{
		return Append(new Sql("GROUP BY " + string.Join(", ", columns.Select((object x) => x.ToString()).ToArray())));
	}

	private SqlJoinClause Join(string joinType, string table)
	{
		return new SqlJoinClause(Append(new Sql(joinType + table)));
	}

	public SqlJoinClause InnerJoin(string table)
	{
		return Join("INNER JOIN ", table);
	}

	public SqlJoinClause LeftJoin(string table)
	{
		return Join("LEFT JOIN ", table);
	}

	public static string ProcessParams(string sql, object[] argsSrc, List<object> argsDest)
	{
		return RxParams.Replace(sql, delegate(Match m)
		{
			string text = m.Value.Substring(1);
			object obj;
			if (int.TryParse(text, out var result))
			{
				if (result < 0 || result >= argsSrc.Length)
				{
					throw new ArgumentOutOfRangeException($"Parameter '@{result}' specified but only {argsSrc.Length} parameters supplied (in `{sql}`)");
				}
				obj = argsSrc[result];
			}
			else
			{
				bool flag = false;
				obj = null;
				object[] array = argsSrc;
				foreach (object obj2 in array)
				{
					PropertyInfo property = obj2.GetType().GetProperty(text);
					if (!(property == null))
					{
						obj = property.GetValue(obj2, null);
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					throw new ArgumentException("Parameter '@" + text + "' specified but none of the passed arguments have a property with this name (in '" + sql + "')");
				}
			}
			if (obj is IEnumerable && !(obj is string) && !(obj is byte[]))
			{
				StringBuilder stringBuilder = new StringBuilder();
				foreach (object item in obj as IEnumerable)
				{
					stringBuilder.Append(((stringBuilder.Length == 0) ? "@" : ",@") + argsDest.Count);
					argsDest.Add(item);
				}
				return stringBuilder.ToString();
			}
			argsDest.Add(obj);
			return "@" + (argsDest.Count - 1);
		});
	}

	public static void AddParams(IDbCommand cmd, object[] items, string parameterPrefix)
	{
		foreach (object item in items)
		{
			AddParam(cmd, item, "@");
		}
	}

	public static void AddParam(IDbCommand cmd, object item, string parameterPrefix)
	{
		if (item is IDbDataParameter dbDataParameter)
		{
			dbDataParameter.ParameterName = $"{parameterPrefix}{cmd.Parameters.Count}";
			cmd.Parameters.Add(dbDataParameter);
			return;
		}
		IDbDataParameter dbDataParameter2 = cmd.CreateParameter();
		dbDataParameter2.ParameterName = $"{parameterPrefix}{cmd.Parameters.Count}";
		if (item == null)
		{
			dbDataParameter2.Value = DBNull.Value;
		}
		else
		{
			Type type = item.GetType();
			if (type.IsEnum)
			{
				dbDataParameter2.Value = (int)item;
			}
			else if (type == typeof(Guid))
			{
				dbDataParameter2.Value = item.ToString();
				dbDataParameter2.DbType = DbType.String;
				dbDataParameter2.Size = 40;
			}
			else if (type == typeof(string))
			{
				dbDataParameter2.Size = Math.Max(((string)item).Length + 1, 4000);
				dbDataParameter2.Value = item;
			}
			else if (type == typeof(bool))
			{
				dbDataParameter2.Value = (((bool)item) ? 1 : 0);
			}
			else
			{
				dbDataParameter2.Value = item;
			}
		}
		cmd.Parameters.Add(dbDataParameter2);
	}
}


using System;
using System.Globalization;
using System.IO;
using Newtonsoft.Json;
using Oxide.Core.Configuration;

public abstract class ConfigFile
{
	private static JsonSerializerSettings SerializerSettings = new JsonSerializerSettings
	{
		DefaultValueHandling = (DefaultValueHandling)2,
		Culture = CultureInfo.InvariantCulture,
		Formatting = (Formatting)1,
		MissingMemberHandling = (MissingMemberHandling)0
	};

	[JsonIgnore]
	public string Filename { get; private set; }

	protected ConfigFile(string filename)
	{
		Filename = filename;
	}

	public static T Load<T>(string filename) where T : ConfigFile
	{
		T obj = (T)Activator.CreateInstance(typeof(T), filename);
		obj.Load();
		return obj;
	}

	public virtual void Load(string filename = null)
	{
		JsonConvert.PopulateObject(File.ReadAllText(filename ?? Filename), (object)this, SerializerSettings);
	}

	public virtual void Save(string filename = null)
	{
		string contents = JsonConvert.SerializeObject((object)this, SerializerSettings);
		File.WriteAllText(filename ?? Filename, contents);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;

public class DynamicConfigFile : ConfigFile, IEnumerable<KeyValuePair<string, object>>, IEnumerable
{
	private Dictionary<string, object> _keyvalues;

	private readonly JsonSerializerSettings _settings;

	private readonly string _chroot;

	public JsonSerializerSettings Settings { get; set; } = new JsonSerializerSettings();

	public object this[string key]
	{
		get
		{
			if (!_keyvalues.TryGetValue(key, out var value))
			{
				return null;
			}
			return value;
		}
		set
		{
			_keyvalues[key] = value;
		}
	}

	public object this[string keyLevel1, string keyLevel2]
	{
		get
		{
			return Get(keyLevel1, keyLevel2);
		}
		set
		{
			Set(keyLevel1, keyLevel2, value);
		}
	}

	public object this[string keyLevel1, string keyLevel2, string keyLevel3]
	{
		get
		{
			return Get(keyLevel1, keyLevel2, keyLevel3);
		}
		set
		{
			Set(keyLevel1, keyLevel2, keyLevel3, value);
		}
	}

	public DynamicConfigFile(string filename)
		: base(filename)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Expected O, but got Unknown
		_keyvalues = new Dictionary<string, object>();
		_settings = new JsonSerializerSettings();
		_settings.Converters.Add((JsonConverter)(object)new KeyValuesConverter());
		_chroot = Interface.Oxide.InstanceDirectory;
	}

	public override void Load(string filename = null)
	{
		filename = CheckPath(filename ?? base.Filename);
		string text = File.ReadAllText(filename);
		_keyvalues = JsonConvert.DeserializeObject<Dictionary<string, object>>(text, _settings);
	}

	public T ReadObject<T>(string filename = null)
	{
		filename = CheckPath(filename ?? base.Filename);
		T val;
		if (Exists(filename))
		{
			val = JsonConvert.DeserializeObject<T>(File.ReadAllText(filename), Settings);
		}
		else
		{
			val = Activator.CreateInstance<T>();
			WriteObject(val, sync: false, filename);
		}
		return val;
	}

	public override void Save(string filename = null)
	{
		filename = CheckPath(filename ?? base.Filename);
		string directoryName = Utility.GetDirectoryName(filename);
		if (directoryName != null && !Directory.Exists(directoryName))
		{
			Directory.CreateDirectory(directoryName);
		}
		File.WriteAllText(filename, JsonConvert.SerializeObject((object)_keyvalues, (Formatting)1, _settings));
	}

	public void WriteObject<T>(T config, bool sync = false, string filename = null)
	{
		filename = CheckPath(filename ?? base.Filename);
		string directoryName = Utility.GetDirectoryName(filename);
		if (directoryName != null && !Directory.Exists(directoryName))
		{
			Directory.CreateDirectory(directoryName);
		}
		string text = JsonConvert.SerializeObject((object)config, (Formatting)1, Settings);
		File.WriteAllText(filename, text);
		if (sync)
		{
			_keyvalues = JsonConvert.DeserializeObject<Dictionary<string, object>>(text, _settings);
		}
	}

	public bool Exists(string filename = null)
	{
		filename = CheckPath(filename ?? base.Filename);
		string directoryName = Utility.GetDirectoryName(filename);
		if (directoryName != null && !Directory.Exists(directoryName))
		{
			return false;
		}
		return File.Exists(filename);
	}

	public void Delete(string filename = null)
	{
		filename = CheckPath(filename ?? base.Filename);
		if (Exists(filename))
		{
			File.Delete(filename);
		}
	}

	private string CheckPath(string filename)
	{
		filename = SanitizeName(filename);
		string fullPath = Path.GetFullPath(filename);
		if (!fullPath.StartsWith(_chroot, StringComparison.Ordinal))
		{
			throw new Exception("Only access to oxide directory!\nPath: " + fullPath);
		}
		return fullPath;
	}

	public static string SanitizeName(string name)
	{
		if (string.IsNullOrEmpty(name))
		{
			return string.Empty;
		}
		name = name.Replace('\\', Path.DirectorySeparatorChar).Replace('/', Path.DirectorySeparatorChar);
		name = Regex.Replace(name, "[" + Regex.Escape(new string(Path.GetInvalidPathChars())) + "]", "_");
		name = Regex.Replace(name, "\\.+", ".");
		return name.TrimStart(new char[1] { '.' });
	}

	[Obsolete("SanitiseName is deprecated, use SanitizeName instead")]
	public static string SanitiseName(string name)
	{
		return SanitizeName(name);
	}

	public void Clear()
	{
		_keyvalues.Clear();
	}

	public void Remove(string key)
	{
		_keyvalues.Remove(key);
	}

	public object ConvertValue(object value, Type destinationType)
	{
		if (!destinationType.IsGenericType)
		{
			return Convert.ChangeType(value, destinationType);
		}
		if (destinationType.GetGenericTypeDefinition() == typeof(List<>))
		{
			Type conversionType = destinationType.GetGenericArguments()[0];
			IList list = (IList)Activator.CreateInstance(destinationType);
			{
				foreach (object item in (IList)value)
				{
					list.Add(Convert.ChangeType(item, conversionType));
				}
				return list;
			}
		}
		if (destinationType.GetGenericTypeDefinition() == typeof(Dictionary<, >))
		{
			Type conversionType2 = destinationType.GetGenericArguments()[0];
			Type conversionType3 = destinationType.GetGenericArguments()[1];
			IDictionary dictionary = (IDictionary)Activator.CreateInstance(destinationType);
			{
				foreach (object key in ((IDictionary)value).Keys)
				{
					dictionary.Add(Convert.ChangeType(key, conversionType2), Convert.ChangeType(((IDictionary)value)[key], conversionType3));
				}
				return dictionary;
			}
		}
		throw new InvalidCastException("Generic types other than List<> and Dictionary<,> are not supported");
	}

	public T ConvertValue<T>(object value)
	{
		return (T)ConvertValue(value, typeof(T));
	}

	public object Get(params string[] path)
	{
		if (path.Length < 1)
		{
			throw new ArgumentException("path must not be empty");
		}
		if (!_keyvalues.TryGetValue(path[0], out var value))
		{
			return null;
		}
		for (int i = 1; i < path.Length; i++)
		{
			if (!(value is Dictionary<string, object> dictionary) || !dictionary.TryGetValue(path[i], out value))
			{
				return null;
			}
		}
		return value;
	}

	public T Get<T>(params string[] path)
	{
		return ConvertValue<T>(Get(path));
	}

	public void Set(params object[] pathAndTrailingValue)
	{
		if (pathAndTrailingValue.Length < 2)
		{
			throw new ArgumentException("path must not be empty");
		}
		string[] array = new string[pathAndTrailingValue.Length - 1];
		for (int i = 0; i < pathAndTrailingValue.Length - 1; i++)
		{
			array[i] = (string)pathAndTrailingValue[i];
		}
		object value = pathAndTrailingValue[^1];
		if (array.Length == 1)
		{
			_keyvalues[array[0]] = value;
			return;
		}
		if (!_keyvalues.TryGetValue(array[0], out var value2))
		{
			value2 = (_keyvalues[array[0]] = new Dictionary<string, object>());
		}
		for (int j = 1; j < array.Length - 1; j++)
		{
			if (!(value2 is Dictionary<string, object>))
			{
				throw new ArgumentException("path is not a dictionary");
			}
			Dictionary<string, object> dictionary2 = (Dictionary<string, object>)value2;
			if (!dictionary2.TryGetValue(array[j], out value2))
			{
				value2 = (dictionary2[array[j]] = new Dictionary<string, object>());
			}
		}
		((Dictionary<string, object>)value2)[array[^1]] = value;
	}

	public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
	{
		return _keyvalues.GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return _keyvalues.GetEnumerator();
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;

public class KeyValuesConverter : JsonConverter
{
	public override bool CanConvert(Type objectType)
	{
		if (!(objectType == typeof(Dictionary<string, object>)))
		{
			return objectType == typeof(List<object>);
		}
		return true;
	}

	private void Throw(string message)
	{
		throw new Exception(message);
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Invalid comparison between Unknown and I4
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Invalid comparison between Unknown and I4
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Invalid comparison between Unknown and I4
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Invalid comparison between Unknown and I4
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Expected I4, but got Unknown
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Expected I4, but got Unknown
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		JsonToken tokenType;
		JsonToken tokenType2;
		if (objectType == typeof(Dictionary<string, object>))
		{
			Dictionary<string, object> dictionary = (existingValue as Dictionary<string, object>) ?? new Dictionary<string, object>();
			if ((int)reader.TokenType == 2)
			{
				return dictionary;
			}
			while (reader.Read() && (int)reader.TokenType != 13)
			{
				if ((int)reader.TokenType != 4)
				{
					tokenType = reader.TokenType;
					Throw("Unexpected token: " + ((object)(JsonToken)(ref tokenType)/*cast due to .constrained prefix*/).ToString());
				}
				string key = reader.Value as string;
				if (!reader.Read())
				{
					Throw("Unexpected end of json");
				}
				tokenType = reader.TokenType;
				switch (tokenType - 1)
				{
				case 7:
				case 8:
				case 9:
				case 10:
				case 15:
				case 16:
					dictionary[key] = reader.Value;
					break;
				case 6:
				{
					string text = reader.Value.ToString();
					if (int.TryParse(text, out var result))
					{
						dictionary[key] = result;
					}
					else
					{
						dictionary[key] = text;
					}
					break;
				}
				case 0:
					dictionary[key] = serializer.Deserialize<Dictionary<string, object>>(reader);
					break;
				case 1:
					dictionary[key] = serializer.Deserialize<List<object>>(reader);
					break;
				default:
					tokenType2 = reader.TokenType;
					Throw("Unexpected token: " + ((object)(JsonToken)(ref tokenType2)/*cast due to .constrained prefix*/).ToString());
					break;
				}
			}
			return dictionary;
		}
		if (objectType == typeof(List<object>))
		{
			List<object> list = (existingValue as List<object>) ?? new List<object>();
			while (reader.Read() && (int)reader.TokenType != 14)
			{
				tokenType = reader.TokenType;
				switch (tokenType - 1)
				{
				case 7:
				case 8:
				case 9:
				case 10:
				case 15:
				case 16:
					list.Add(reader.Value);
					break;
				case 6:
				{
					string text2 = reader.Value.ToString();
					if (int.TryParse(text2, out var result2))
					{
						list.Add(result2);
					}
					else
					{
						list.Add(text2);
					}
					break;
				}
				case 0:
					list.Add(serializer.Deserialize<Dictionary<string, object>>(reader));
					break;
				case 1:
					list.Add(serializer.Deserialize<List<object>>(reader));
					break;
				default:
					tokenType2 = reader.TokenType;
					Throw("Unexpected token: " + ((object)(JsonToken)(ref tokenType2)/*cast due to .constrained prefix*/).ToString());
					break;
				}
			}
			return list;
		}
		return existingValue;
	}

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		if (value is Dictionary<string, object>)
		{
			Dictionary<string, object> source = (Dictionary<string, object>)value;
			writer.WriteStartObject();
			foreach (KeyValuePair<string, object> item in source.OrderBy((KeyValuePair<string, object> i) => i.Key))
			{
				writer.WritePropertyName(item.Key, true);
				serializer.Serialize(writer, item.Value);
			}
			writer.WriteEndObject();
		}
		else
		{
			if (!(value is List<object>))
			{
				return;
			}
			List<object> obj = (List<object>)value;
			writer.WriteStartArray();
			foreach (object item2 in obj)
			{
				serializer.Serialize(writer, item2);
			}
			writer.WriteEndArray();
		}
	}
}


using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using Newtonsoft.Json;
using Oxide.Core.Configuration;

public class OxideConfig : ConfigFile
{
	public class OxideOptions
	{
		public bool Modded { get; set; } = true;

		public bool PluginWatchers { get; set; } = true;

		public DefaultGroups DefaultGroups { get; set; } = new DefaultGroups();

		public string WebRequestIP { get; set; } = "0.0.0.0";
	}

	public class CommandOptions
	{
		[JsonProperty(PropertyName = "Chat command prefixes")]
		public List<string> ChatPrefix { get; set; } = new List<string> { "/" };
	}

	public class CompilerOptions
	{
		[JsonProperty(PropertyName = "Shutdown on idle")]
		public bool IdleShutdown { get; set; } = true;

		[JsonProperty(PropertyName = "Seconds before idle")]
		public int IdleTimeout { get; set; } = 60;

		[JsonProperty(PropertyName = "Preprocessor directives")]
		public List<string> PreprocessorDirectives { get; set; } = new List<string>();

		[JsonProperty(PropertyName = "Enable Publicizer")]
		public bool? Publicize { get; set; } = true;

		[JsonProperty(PropertyName = "Ignored Publicizer References")]
		public List<string> IgnoredPublicizerReferences { get; set; } = new List<string>();
	}

	[JsonObject]
	public class DefaultGroups : IEnumerable<string>, IEnumerable
	{
		public string Players { get; set; } = "default";

		public string Administrators { get; set; } = "admin";

		public IEnumerator<string> GetEnumerator()
		{
			yield return Players;
			yield return Administrators;
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	public class OxideConsole
	{
		public bool Enabled { get; set; } = true;

		public bool MinimalistMode { get; set; } = true;

		public bool ShowStatusBar { get; set; } = true;
	}

	public class OxideRcon
	{
		public bool Enabled { get; set; }

		public int Port { get; set; } = 25580;

		public string Password { get; set; } = string.Empty;

		public string ChatPrefix { get; set; } = "[Server Console]";
	}

	public OxideOptions Options { get; set; }

	[JsonProperty(PropertyName = "Commands")]
	public CommandOptions Commands { get; set; }

	[JsonProperty(PropertyName = "Plugin Compiler")]
	public CompilerOptions Compiler { get; set; }

	[JsonProperty(PropertyName = "OxideConsole")]
	public OxideConsole Console { get; set; }

	[JsonProperty(PropertyName = "OxideRcon")]
	public OxideRcon Rcon { get; set; }

	public OxideConfig(string filename)
		: base(filename)
	{
		InitializeDefaultValues();
	}

	public override void Load(string filename = null)
	{
		base.Load(filename);
		if (InitializeDefaultValues())
		{
			Save();
		}
		if (Compiler.PreprocessorDirectives.Count > 0)
		{
			Compiler.PreprocessorDirectives = Compiler.PreprocessorDirectives.Select((string s) => s.ToUpperInvariant().Replace(" ", "_")).Distinct().ToList();
		}
		Commands.ChatPrefix = Commands.ChatPrefix.Distinct().ToList();
	}

	private bool InitializeDefaultValues()
	{
		bool result = false;
		if (Options == null)
		{
			Options = new OxideOptions();
			result = true;
		}
		if (Commands == null)
		{
			Commands = new CommandOptions();
			result = true;
		}
		if (Commands.ChatPrefix == null)
		{
			Commands.ChatPrefix = new List<string> { "/" };
			result = true;
		}
		if (Commands.ChatPrefix.Count == 0)
		{
			Commands.ChatPrefix.Add("/");
			result = true;
		}
		if (Options.DefaultGroups == null)
		{
			Options.DefaultGroups = new DefaultGroups();
			result = true;
		}
		if (string.IsNullOrEmpty(Options.WebRequestIP) || !IPAddress.TryParse(Options.WebRequestIP, out IPAddress _))
		{
			Options.WebRequestIP = "0.0.0.0";
			result = true;
		}
		if (Console == null)
		{
			Console = new OxideConsole();
			result = true;
		}
		if (Rcon == null)
		{
			Rcon = new OxideRcon();
			result = true;
		}
		if (Compiler == null)
		{
			Compiler = new CompilerOptions();
			result = true;
		}
		if (Compiler.PreprocessorDirectives == null)
		{
			Compiler.PreprocessorDirectives = new List<string>();
			result = true;
		}
		if (!Compiler.Publicize.HasValue)
		{
			Compiler.Publicize = true;
			result = true;
		}
		if (Compiler.IgnoredPublicizerReferences == null)
		{
			Compiler.IgnoredPublicizerReferences = new List<string>();
			result = true;
		}
		return result;
	}
}


using System;

private class ProviderExpirationToken : IDisposable
{
	private readonly Type key;

	private readonly CorePoolFactory instance;

	public ProviderExpirationToken(Type key, CorePoolFactory instance)
	{
		this.key = key;
		this.instance = instance;
	}

	~ProviderExpirationToken()
	{
		Dispose(disposing: false);
	}

	public void Dispose()
	{
		Dispose(disposing: true);
	}

	private void Dispose(bool disposing)
	{
		if (disposing)
		{
			GC.SuppressFinalize(this);
		}
		lock (instance.registeredProviders)
		{
			instance.registeredProviders.Remove(key);
		}
	}
}


public delegate void Action<in T1, in T2, in T3, in T4, in T5>(T1 arg0, T2 arg1, T3 arg2, T4 arg3, T5 arg4);


using System;

public class Callback
{
	public Action Invoke;

	internal Callback Previous;

	internal Callback Next;

	internal Event Handler;

	public Callback(Action callback)
	{
		Invoke = callback;
	}

	public void Call()
	{
		Action invoke = Invoke;
		if (invoke == null)
		{
			return;
		}
		try
		{
			invoke();
		}
		catch (Exception ex)
		{
			Interface.Oxide.LogException("Exception while invoking event handler", ex);
		}
	}

	public void Remove()
	{
		Event handler = Handler;
		Callback next = Next;
		Callback previous = Previous;
		if (previous == null)
		{
			handler.First = next;
		}
		else
		{
			previous.Next = next;
			if (next == null)
			{
				handler.Last = previous;
			}
		}
		if (next == null)
		{
			handler.Last = previous;
		}
		else
		{
			next.Previous = previous;
			if (previous == null)
			{
				handler.First = next;
			}
		}
		if (handler.Invoking)
		{
			handler.RemovedQueue.Enqueue(this);
		}
		else
		{
			Previous = null;
			Next = null;
		}
		Invoke = null;
		Handler = null;
	}
}


using System;

public class Callback<T>
{
	public Action<T> Invoke;

	internal Callback<T> Previous;

	internal Callback<T> Next;

	internal Event<T> Handler;

	public Callback(Action<T> callback)
	{
		Invoke = callback;
	}

	public void Call(T arg0)
	{
		Action<T> invoke = Invoke;
		if (invoke == null)
		{
			return;
		}
		try
		{
			invoke(arg0);
		}
		catch (Exception ex)
		{
			Interface.Oxide.LogException("Exception while invoking event handler", ex);
		}
	}

	public void Remove()
	{
		Event<T> handler = Handler;
		Callback<T> next = Next;
		Callback<T> previous = Previous;
		if (previous == null)
		{
			handler.First = next;
		}
		else
		{
			previous.Next = next;
			if (next == null)
			{
				handler.Last = previous;
			}
		}
		if (next == null)
		{
			handler.Last = previous;
		}
		else
		{
			next.Previous = previous;
			if (previous == null)
			{
				handler.First = next;
			}
		}
		if (handler.Invoking)
		{
			handler.RemovedQueue.Enqueue(this);
		}
		else
		{
			Previous = null;
			Next = null;
		}
		Invoke = null;
		Handler = null;
	}
}


using System;

public class Callback<T1, T2>
{
	public Action<T1, T2> Invoke;

	internal Callback<T1, T2> Previous;

	internal Callback<T1, T2> Next;

	internal Event<T1, T2> Handler;

	public Callback(Action<T1, T2> callback)
	{
		Invoke = callback;
	}

	public void Call(T1 arg0, T2 arg1)
	{
		Action<T1, T2> invoke = Invoke;
		if (invoke == null)
		{
			return;
		}
		try
		{
			invoke(arg0, arg1);
		}
		catch (Exception ex)
		{
			Interface.Oxide.LogException("Exception while invoking event handler", ex);
		}
	}

	public void Remove()
	{
		Event<T1, T2> handler = Handler;
		Callback<T1, T2> next = Next;
		Callback<T1, T2> previous = Previous;
		if (previous == null)
		{
			handler.First = next;
		}
		else
		{
			previous.Next = next;
			if (next == null)
			{
				handler.Last = previous;
			}
		}
		if (next == null)
		{
			handler.Last = previous;
		}
		else
		{
			next.Previous = previous;
			if (previous == null)
			{
				handler.First = next;
			}
		}
		if (handler.Invoking)
		{
			handler.RemovedQueue.Enqueue(this);
		}
		else
		{
			Previous = null;
			Next = null;
		}
		Invoke = null;
		Handler = null;
	}
}


using System;

public class Callback<T1, T2, T3>
{
	public Action<T1, T2, T3> Invoke;

	internal Callback<T1, T2, T3> Previous;

	internal Callback<T1, T2, T3> Next;

	internal Event<T1, T2, T3> Handler;

	public Callback(Action<T1, T2, T3> callback)
	{
		Invoke = callback;
	}

	public void Call(T1 arg0, T2 arg1, T3 arg2)
	{
		Action<T1, T2, T3> invoke = Invoke;
		if (invoke == null)
		{
			return;
		}
		try
		{
			invoke(arg0, arg1, arg2);
		}
		catch (Exception ex)
		{
			Interface.Oxide.LogException("Exception while invoking event handler", ex);
		}
	}

	public void Remove()
	{
		Event<T1, T2, T3> handler = Handler;
		Callback<T1, T2, T3> next = Next;
		Callback<T1, T2, T3> previous = Previous;
		if (previous == null)
		{
			handler.First = next;
		}
		else
		{
			previous.Next = next;
			if (next == null)
			{
				handler.Last = previous;
			}
		}
		if (next == null)
		{
			handler.Last = previous;
		}
		else
		{
			next.Previous = previous;
			if (previous == null)
			{
				handler.First = next;
			}
		}
		if (handler.Invoking)
		{
			handler.RemovedQueue.Enqueue(this);
		}
		else
		{
			Previous = null;
			Next = null;
		}
		Invoke = null;
		Handler = null;
	}
}


using System;

public class Callback<T1, T2, T3, T4>
{
	public Action<T1, T2, T3, T4> Invoke;

	internal Callback<T1, T2, T3, T4> Previous;

	internal Callback<T1, T2, T3, T4> Next;

	internal Event<T1, T2, T3, T4> Handler;

	public Callback(Action<T1, T2, T3, T4> callback)
	{
		Invoke = callback;
	}

	public void Call(T1 arg0, T2 arg1, T3 arg2, T4 arg3)
	{
		Action<T1, T2, T3, T4> invoke = Invoke;
		if (invoke == null)
		{
			return;
		}
		try
		{
			invoke(arg0, arg1, arg2, arg3);
		}
		catch (Exception ex)
		{
			Interface.Oxide.LogException("Exception while invoking event handler", ex);
		}
	}

	public void Remove()
	{
		Event<T1, T2, T3, T4> handler = Handler;
		Callback<T1, T2, T3, T4> next = Next;
		Callback<T1, T2, T3, T4> previous = Previous;
		if (previous == null)
		{
			handler.First = next;
		}
		else
		{
			previous.Next = next;
			if (next == null)
			{
				handler.Last = previous;
			}
		}
		if (next == null)
		{
			handler.Last = previous;
		}
		else
		{
			next.Previous = previous;
			if (previous == null)
			{
				handler.First = next;
			}
		}
		if (handler.Invoking)
		{
			handler.RemovedQueue.Enqueue(this);
		}
		else
		{
			Previous = null;
			Next = null;
		}
		Invoke = null;
		Handler = null;
	}
}


using System;

public class Callback<T1, T2, T3, T4, T5>
{
	public Action<T1, T2, T3, T4, T5> Invoke;

	internal Callback<T1, T2, T3, T4, T5> Previous;

	internal Callback<T1, T2, T3, T4, T5> Next;

	internal Event<T1, T2, T3, T4, T5> Handler;

	public Callback(Action<T1, T2, T3, T4, T5> callback)
	{
		Invoke = callback;
	}

	public void Call(T1 arg0, T2 arg1, T3 arg2, T4 arg3, T5 arg4)
	{
		Action<T1, T2, T3, T4, T5> invoke = Invoke;
		if (invoke == null)
		{
			return;
		}
		try
		{
			invoke(arg0, arg1, arg2, arg3, arg4);
		}
		catch (Exception ex)
		{
			Interface.Oxide.LogException("Exception while invoking event handler", ex);
		}
	}

	public void Remove()
	{
		Event<T1, T2, T3, T4, T5> handler = Handler;
		Callback<T1, T2, T3, T4, T5> next = Next;
		Callback<T1, T2, T3, T4, T5> previous = Previous;
		if (previous == null)
		{
			handler.First = next;
		}
		else
		{
			previous.Next = next;
			if (next == null)
			{
				handler.Last = previous;
			}
		}
		if (next == null)
		{
			handler.Last = previous;
		}
		else
		{
			next.Previous = previous;
			if (previous == null)
			{
				handler.First = next;
			}
		}
		if (handler.Invoking)
		{
			handler.RemovedQueue.Enqueue(this);
		}
		else
		{
			Previous = null;
			Next = null;
		}
		Invoke = null;
		Handler = null;
	}
}


using System.Collections.Generic;
using Newtonsoft.Json;

private class QueuedReport
{
	public readonly Dictionary<string, string> Headers;

	public readonly string Body;

	public QueuedReport(Report report)
	{
		Headers = BuildHeaders();
		Body = JsonConvert.SerializeObject((object)report);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Oxide.Core.Extensions;
using Oxide.Core.Plugins;

public class Report
{
	public string message;

	public string level;

	public string culprit;

	public string platform = "csharp";

	public string release = OxideMod.Version.ToString();

	public Dictionary<string, string> tags = Tags;

	public Dictionary<string, string> modules;

	public Dictionary<string, string> extra;

	private Dictionary<string, string> headers;

	public Report(string level, string culprit, string message, string exception = null)
	{
		headers = BuildHeaders();
		this.level = level;
		this.message = ((message.Length > 1000) ? message.Substring(0, 1000) : message);
		this.culprit = culprit;
		modules = new Dictionary<string, string>();
		foreach (Extension allExtension in Interface.Oxide.GetAllExtensions())
		{
			modules[allExtension.GetType().Assembly.GetName().Name] = allExtension.Version.ToString();
		}
		if (exception == null)
		{
			return;
		}
		extra = new Dictionary<string, string>();
		string[] array = exception.Split(new char[1] { '\n' }).Take(31).ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			string text = array[i].Trim(' ', '\r', '\n').Replace('\t', ' ');
			if (text.Length > 0)
			{
				extra["line_" + i.ToString("00")] = text;
			}
		}
	}

	public void DetectModules(Assembly assembly)
	{
		if (!(assembly.GetTypes().FirstOrDefault((Type t) => t.BaseType == typeof(Extension)) == null))
		{
			return;
		}
		Type type = assembly.GetTypes().FirstOrDefault((Type t) => IsTypeDerivedFrom(t, typeof(Plugin)));
		if (type != null)
		{
			Plugin plugin = Interface.Oxide.RootPluginManager.GetPlugin(type.Name);
			if (plugin != null)
			{
				modules["Plugins." + plugin.Name] = plugin.Version.ToString();
			}
		}
	}

	public void DetectModules(string[] stackTrace)
	{
		foreach (string text in stackTrace)
		{
			if (text.StartsWith("Oxide.Plugins.PluginCompiler") && text.Contains("+"))
			{
				string name = text.Split(new char[1] { '+' })[0];
				Plugin plugin = Interface.Oxide.RootPluginManager.GetPlugin(name);
				if (plugin != null)
				{
					modules["Plugins." + plugin.Name] = plugin.Version.ToString();
				}
				break;
			}
		}
	}

	private static bool IsTypeDerivedFrom(Type type, Type baseType)
	{
		while (type != null && type != baseType)
		{
			if ((type = type.BaseType) == baseType)
			{
				return true;
			}
		}
		return false;
	}
}


using Oxide.Core.Libraries.Covalence;

private struct RconPlayer
{
	private string SteamID { get; }

	private string OwnerSteamID { get; }

	private string DisplayName { get; }

	private string Address { get; }

	private int Ping { get; }

	private int ConnectedSeconds { get; }

	private float VoiationLevel { get; }

	private float CurrentLevel { get; }

	private float UnspentXp { get; }

	private float Health { get; }

	public RconPlayer(IPlayer player)
	{
		SteamID = player.Id;
		OwnerSteamID = "0";
		DisplayName = player.Name;
		Address = player.Address;
		Ping = player.Ping;
		ConnectedSeconds = 0;
		VoiationLevel = 0f;
		CurrentLevel = 0f;
		UnspentXp = 0f;
		Health = player.Health;
	}
}


using System.Net;
using WebSocketSharp;
using WebSocketSharp.Server;

public class RconListener : WebSocketBehavior
{
	private readonly RemoteConsole Parent;

	private IPAddress Address;

	public RconListener(RemoteConsole parent)
	{
		((WebSocketBehavior)this).IgnoreExtensions = true;
		Parent = parent;
	}

	public void SendMessage(RemoteMessage message)
	{
		((WebSocketBehavior)this).Sessions.Broadcast(message.ToJSON());
	}

	protected override void OnClose(CloseEventArgs e)
	{
		string arg = (string.IsNullOrEmpty(e.Reason) ? "Unknown" : e.Reason);
		Interface.Oxide.LogInfo($"[Rcon] Connection from {Address} closed: {arg} ({e.Code})");
	}

	protected override void OnError(ErrorEventArgs e)
	{
		Interface.Oxide.LogException(e.Message, e.Exception);
	}

	protected override void OnMessage(MessageEventArgs e)
	{
		Parent?.OnMessage(e, ((WebSocketBehavior)this).Context);
	}

	protected override void OnOpen()
	{
		Address = ((WebSocketBehavior)this).Context.UserEndPoint.Address;
		Interface.Oxide.LogInfo($"[Rcon] New connection from {Address}");
	}
}


using Oxide.Core.Libraries.Covalence;

private class CommandInfo
{
	public readonly string[] Names;

	public readonly string[] PermissionsRequired;

	public readonly CommandCallback Callback;

	public CommandInfo(string[] names, string[] perms, CommandCallback callback)
	{
		Names = names;
		PermissionsRequired = perms;
		Callback = callback;
	}
}


private enum SubscriptionChangeType : byte
{
	Subscribe,
	Unsubscribe
}


private struct SubscriptionChange
{
	public Plugin Plugin { get; }

	public SubscriptionChangeType Change { get; }

	public SubscriptionChange(Plugin plugin, SubscriptionChangeType type)
	{
		Plugin = plugin;
		Change = type;
	}
}


using System.Collections.Generic;

private class HookSubscriptions
{
	public IList<Plugin> Plugins { get; }

	public int CallDepth { get; set; }

	public Queue<SubscriptionChange> PendingChanges { get; }

	public HookSubscriptions()
	{
		Plugins = new List<Plugin>();
		PendingChanges = new Queue<SubscriptionChange>();
		CallDepth = 0;
	}
}


using System.IO;
using Oxide.Core.Libraries;

private class QueuedChange
{
	internal WatcherChangeTypes type;

	internal Timer.TimerInstance timer;
}


public struct LogMessage
{
	public LogType Type;

	public string ConsoleMessage;

	public string LogfileMessage;
}


using System.Collections.Generic;
using ProtoBuf;

[ProtoContract(/*Could not decode attribute arguments.*/)]
private class LangData
{
	public string Lang = "en";

	public readonly Dictionary<string, string> UserData = new Dictionary<string, string>();
}


using System.Collections.Generic;

public class TimeSlot
{
	public int Count;

	public TimerInstance FirstInstance;

	public TimerInstance LastInstance;

	public void GetExpired(double now, Queue<TimerInstance> queue)
	{
		TimerInstance timerInstance = FirstInstance;
		while (timerInstance != null && !((double)timerInstance.ExpiresAt > now))
		{
			queue.Enqueue(timerInstance);
			timerInstance = timerInstance.NextInstance;
		}
	}

	public void InsertTimer(TimerInstance timer)
	{
		float expiresAt = timer.ExpiresAt;
		TimerInstance firstInstance = FirstInstance;
		TimerInstance lastInstance = LastInstance;
		TimerInstance timerInstance = firstInstance;
		if (firstInstance != null)
		{
			float expiresAt2 = firstInstance.ExpiresAt;
			float expiresAt3 = lastInstance.ExpiresAt;
			if (expiresAt <= expiresAt2)
			{
				timerInstance = firstInstance;
			}
			else if (expiresAt >= expiresAt3)
			{
				timerInstance = null;
			}
			else if (expiresAt3 - expiresAt < expiresAt - expiresAt2)
			{
				timerInstance = lastInstance;
				TimerInstance timerInstance2 = timerInstance;
				while (timerInstance2 != null && !(timerInstance2.ExpiresAt <= expiresAt))
				{
					timerInstance = timerInstance2;
					timerInstance2 = timerInstance2.PreviousInstance;
				}
			}
			else
			{
				while (timerInstance != null && !(timerInstance.ExpiresAt > expiresAt))
				{
					timerInstance = timerInstance.NextInstance;
				}
			}
		}
		if (timerInstance == null)
		{
			timer.NextInstance = null;
			if (lastInstance == null)
			{
				FirstInstance = timer;
				LastInstance = timer;
			}
			else
			{
				lastInstance.NextInstance = timer;
				timer.PreviousInstance = lastInstance;
				LastInstance = timer;
			}
		}
		else
		{
			TimerInstance previousInstance = timerInstance.PreviousInstance;
			if (previousInstance == null)
			{
				FirstInstance = timer;
			}
			else
			{
				previousInstance.NextInstance = timer;
			}
			timerInstance.PreviousInstance = timer;
			timer.PreviousInstance = previousInstance;
			timer.NextInstance = timerInstance;
		}
		timer.Added(this);
	}
}


using System;
using System.Collections.Generic;
using Oxide.Core.Plugins;

public class TimerInstance
{
	public const int MaxPooled = 5000;

	internal static Queue<TimerInstance> Pool = new Queue<TimerInstance>();

	internal float ExpiresAt;

	internal TimeSlot TimeSlot;

	internal TimerInstance NextInstance;

	internal TimerInstance PreviousInstance;

	private Event.Callback<Plugin, PluginManager> removedFromManager;

	private Timer timer;

	public int Repetitions { get; private set; }

	public float Delay { get; private set; }

	public Action Callback { get; private set; }

	public bool Destroyed { get; private set; }

	public Plugin Owner { get; private set; }

	internal TimerInstance(Timer timer, int repetitions, float delay, Action callback, Plugin owner)
	{
		Load(timer, repetitions, delay, callback, owner);
	}

	internal void Load(Timer timer, int repetitions, float delay, Action callback, Plugin owner)
	{
		this.timer = timer;
		Repetitions = repetitions;
		Delay = delay;
		Callback = callback;
		ExpiresAt = Oxide.Now + delay;
		Owner = owner;
		Destroyed = false;
		if (owner != null)
		{
			removedFromManager = owner.OnRemovedFromManager.Add(OnRemovedFromManager);
		}
	}

	public void Reset(float delay = -1f, int repetitions = 1)
	{
		lock (Lock)
		{
			if (delay < 0f)
			{
				delay = Delay;
			}
			else
			{
				Delay = delay;
			}
			Repetitions = repetitions;
			ExpiresAt = Oxide.Now + delay;
			if (Destroyed)
			{
				Destroyed = false;
				Plugin owner = Owner;
				if (owner != null)
				{
					removedFromManager = owner.OnRemovedFromManager.Add(OnRemovedFromManager);
				}
			}
			else
			{
				Remove();
			}
			timer.InsertTimer(this);
		}
	}

	public bool Destroy()
	{
		lock (Lock)
		{
			if (Destroyed)
			{
				return false;
			}
			Destroyed = true;
			Remove();
			Event.Remove(ref removedFromManager);
		}
		return true;
	}

	public bool DestroyToPool()
	{
		lock (Lock)
		{
			if (Destroyed)
			{
				return false;
			}
			Destroyed = true;
			Callback = null;
			Remove();
			Event.Remove(ref removedFromManager);
			Queue<TimerInstance> pool = Pool;
			if (pool.Count < 5000)
			{
				pool.Enqueue(this);
			}
		}
		return true;
	}

	internal void Added(TimeSlot time_slot)
	{
		time_slot.Count++;
		Count++;
		TimeSlot = time_slot;
	}

	internal void Invoke(float now)
	{
		if (Repetitions > 0 && --Repetitions == 0)
		{
			Destroy();
			FireCallback();
			return;
		}
		Remove();
		float num = (ExpiresAt += Delay);
		timer.InsertTimer(this, num < now);
		FireCallback();
	}

	internal void Remove()
	{
		TimeSlot timeSlot = TimeSlot;
		if (timeSlot != null)
		{
			timeSlot.Count--;
			Count--;
			TimerInstance previousInstance = PreviousInstance;
			TimerInstance nextInstance = NextInstance;
			if (nextInstance == null)
			{
				timeSlot.LastInstance = previousInstance;
			}
			else
			{
				nextInstance.PreviousInstance = previousInstance;
			}
			if (previousInstance == null)
			{
				timeSlot.FirstInstance = nextInstance;
			}
			else
			{
				previousInstance.NextInstance = nextInstance;
			}
			TimeSlot = null;
			PreviousInstance = null;
			NextInstance = null;
		}
	}

	private void FireCallback()
	{
		Owner?.TrackStart();
		try
		{
			Callback();
		}
		catch (Exception ex)
		{
			Destroy();
			string text = $"Failed to run a {Delay:0.00} timer";
			if ((bool)Owner && Owner != null)
			{
				text += $" in '{Owner.Name} v{Owner.Version}'";
			}
			Interface.Oxide.LogException(text, ex);
		}
		finally
		{
			Owner?.TrackEnd();
		}
	}

	private void OnRemovedFromManager(Plugin sender, PluginManager manager)
	{
		Destroy();
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Text;
using System.Threading;
using Oxide.Core.Plugins;

public class WebRequest
{
	private HttpWebRequest request;

	private WaitHandle waitHandle;

	private RegisteredWaitHandle registeredWaitHandle;

	private Event.Callback<Plugin, PluginManager> removedFromManager;

	public Action<int, string> Callback { get; }

	public float Timeout { get; set; }

	public string Method { get; set; }

	public string Url { get; }

	public string Body { get; set; }

	public int ResponseCode { get; protected set; }

	public string ResponseText { get; protected set; }

	public Plugin Owner { get; protected set; }

	public Dictionary<string, string> RequestHeaders { get; set; }

	public DecompressionMethods DecompressionMethod { get; set; }

	public WebRequest(string url, Action<int, string> callback, Plugin owner)
	{
		Url = url;
		Callback = callback;
		Owner = owner;
		removedFromManager = Owner?.OnRemovedFromManager.Add(owner_OnRemovedFromManager);
	}

	public void Start()
	{
		try
		{
			request = (HttpWebRequest)System.Net.WebRequest.Create(Url);
			request.Method = Method;
			request.Credentials = CredentialCache.DefaultCredentials;
			request.Proxy = null;
			request.KeepAlive = false;
			request.Timeout = (int)Math.Round((Timeout.Equals(0f) ? WebRequests.Timeout : Timeout) * 1000f);
			if (AllowDecompression && DecompressionMethod == DecompressionMethods.None)
			{
				request.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;
			}
			else
			{
				request.AutomaticDecompression = DecompressionMethod;
			}
			request.ServicePoint.MaxIdleTime = request.Timeout;
			request.ServicePoint.Expect100Continue = ServicePointManager.Expect100Continue;
			request.ServicePoint.ConnectionLimit = ServicePointManager.DefaultConnectionLimit;
			request.UserAgent = $"Oxide Mod (v{OxideMod.Version}; https://umod.org)";
			if (!request.RequestUri.IsLoopback && IPAddress.TryParse(Interface.Oxide.Config.Options.WebRequestIP, out IPAddress address))
			{
				request.ServicePoint.BindIPEndPointDelegate = (ServicePoint servicePoint, IPEndPoint remoteEndPoint, int retryCount) => new IPEndPoint(address, 0);
			}
			byte[] data = new byte[0];
			if (Body != null)
			{
				data = Encoding.UTF8.GetBytes(Body);
				request.ContentLength = data.Length;
				request.ContentType = "application/x-www-form-urlencoded";
			}
			if (RequestHeaders != null)
			{
				request.SetRawHeaders(RequestHeaders);
			}
			if (data.Length != 0)
			{
				request.BeginGetRequestStream(delegate(IAsyncResult result)
				{
					if (request != null)
					{
						try
						{
							using Stream stream = request.EndGetRequestStream(result);
							stream.Write(data, 0, data.Length);
						}
						catch (Exception exception)
						{
							ResponseText = FormatWebException(exception, ResponseText ?? string.Empty);
							request?.Abort();
							OnComplete();
							return;
						}
						WaitForResponse();
					}
				}, null);
			}
			else
			{
				WaitForResponse();
			}
		}
		catch (Exception ex)
		{
			ResponseText = FormatWebException(ex, ResponseText ?? string.Empty);
			string text = "Web request produced exception (Url: " + Url + ")";
			if ((bool)Owner)
			{
				text += $" in '{Owner.Name} v{Owner.Version}' plugin";
			}
			Interface.Oxide.LogException(text, ex);
			request?.Abort();
			OnComplete();
		}
	}

	private void WaitForResponse()
	{
		IAsyncResult asyncResult = request.BeginGetResponse(delegate(IAsyncResult res)
		{
			try
			{
				using HttpWebResponse httpWebResponse = (HttpWebResponse)request.EndGetResponse(res);
				using (Stream stream = httpWebResponse.GetResponseStream())
				{
					using StreamReader streamReader = new StreamReader(stream);
					ResponseText = streamReader.ReadToEnd();
				}
				ResponseCode = (int)httpWebResponse.StatusCode;
			}
			catch (WebException ex)
			{
				ResponseText = FormatWebException(ex, ResponseText ?? string.Empty);
				if (ex.Response is HttpWebResponse httpWebResponse2)
				{
					try
					{
						using Stream stream2 = httpWebResponse2.GetResponseStream();
						using StreamReader streamReader2 = new StreamReader(stream2);
						ResponseText = streamReader2.ReadToEnd();
					}
					catch (Exception)
					{
					}
					ResponseCode = (int)httpWebResponse2.StatusCode;
				}
			}
			catch (Exception ex3)
			{
				ResponseText = FormatWebException(ex3, ResponseText ?? string.Empty);
				string text = "Web request produced exception (Url: " + Url + ")";
				if ((bool)Owner)
				{
					text += $" in '{Owner.Name} v{Owner.Version}' plugin";
				}
				Interface.Oxide.LogException(text, ex3);
			}
			if (request != null)
			{
				request.Abort();
				OnComplete();
			}
		}, null);
		waitHandle = asyncResult.AsyncWaitHandle;
		registeredWaitHandle = ThreadPool.RegisterWaitForSingleObject(waitHandle, OnTimeout, null, request.Timeout, executeOnlyOnce: true);
	}

	private void OnTimeout(object state, bool timedOut)
	{
		if (timedOut)
		{
			request?.Abort();
		}
		if (Owner != null)
		{
			Event.Remove(ref removedFromManager);
			Owner = null;
		}
	}

	private void OnComplete()
	{
		Event.Remove(ref removedFromManager);
		registeredWaitHandle?.Unregister(waitHandle);
		Interface.Oxide.NextTick(delegate
		{
			if (request != null)
			{
				request = null;
				Owner?.TrackStart();
				try
				{
					Callback(ResponseCode, ResponseText);
				}
				catch (Exception ex)
				{
					string text = "Web request callback raised an exception";
					if ((bool)Owner && Owner != null)
					{
						text += $" in '{Owner.Name} v{Owner.Version}' plugin";
					}
					Interface.Oxide.LogException(text, ex);
				}
				Owner?.TrackEnd();
				Owner = null;
			}
		});
	}

	private void owner_OnRemovedFromManager(Plugin sender, PluginManager manager)
	{
		if (request != null)
		{
			HttpWebRequest httpWebRequest = request;
			request = null;
			httpWebRequest.Abort();
		}
	}
}


using System.Collections.Generic;

private class Token : Poolable<Token>
{
	public TokenType Type;

	public object Val;

	public string Pattern;

	private static readonly Stack<Token> pool = new Stack<Token>();

	public static Token TakeFromPool(TokenType type, object val, string pattern)
	{
		Token token = Poolable<Token>.TakeFromPool();
		token.Type = type;
		token.Val = val;
		token.Pattern = pattern;
		return token;
	}

	protected override void Reset()
	{
		Type = TokenType.String;
		Val = null;
		Pattern = null;
	}
}


private enum TokenType
{
	String,
	Bold,
	Italic,
	Color,
	Size,
	CloseBold,
	CloseItalic,
	CloseColor,
	CloseSize
}


using System;
using System.Collections.Generic;

private class Lexer : Poolable<Lexer>
{
	private enum StateType
	{
		Str,
		Tag,
		CloseTag,
		EndTag,
		ParamTag
	}

	private List<Token> tokens = new List<Token>();

	private int patternStart;

	private int tokenStart;

	private int position;

	private string text;

	private StateType state;

	private TokenType currentTokenType;

	private Func<string, object> currentParser;

	private char Current()
	{
		return text[position];
	}

	private void Next()
	{
		position++;
	}

	private void StartNewToken()
	{
		tokenStart = position;
	}

	private void StartNewPattern()
	{
		patternStart = position;
		StartNewToken();
	}

	private void ResetTokenStart()
	{
		tokenStart = patternStart;
	}

	private string Token()
	{
		return text.Substring(tokenStart, position - tokenStart);
	}

	private void Add(TokenType type, object val = null)
	{
		Token item = Formatter.Token.TakeFromPool(type, val, text.Substring(patternStart, position - patternStart));
		tokens.Add(item);
	}

	private void WritePatternString()
	{
		if (patternStart < position)
		{
			int num = tokenStart;
			tokenStart = patternStart;
			Add(TokenType.String, Token());
			tokenStart = num;
		}
	}

	private static bool IsValidColorCode(string val)
	{
		if (val.Length != 6 && val.Length != 8)
		{
			return false;
		}
		foreach (char c in val)
		{
			if ((c < '0' || c > '9') && (c < 'a' || c > 'f') && (c < 'A' || c > 'F'))
			{
				return false;
			}
		}
		return true;
	}

	private static object ParseColor(string val)
	{
		if (!colorNames.TryGetValue(val.ToLower(), out var value) && !IsValidColorCode(val))
		{
			return null;
		}
		value = value ?? val;
		if (value.Length == 6)
		{
			value += "ff";
		}
		return value;
	}

	private static object ParseSize(string val)
	{
		if (int.TryParse(val, out var result))
		{
			return result;
		}
		return null;
	}

	private void EndTag()
	{
		if (Current() == ']')
		{
			Next();
			Add(currentTokenType);
			StartNewPattern();
			state = StateType.Str;
		}
		else
		{
			ResetTokenStart();
			state = StateType.Str;
		}
	}

	private void ParamTag()
	{
		if (Current() != ']')
		{
			Next();
			return;
		}
		object obj = currentParser(Token());
		if (obj == null)
		{
			ResetTokenStart();
			state = StateType.Str;
			return;
		}
		Next();
		Add(currentTokenType, obj);
		StartNewPattern();
		state = StateType.Str;
	}

	private void CloseTag()
	{
		switch (Current())
		{
		case 'b':
			currentTokenType = TokenType.CloseBold;
			Next();
			state = StateType.EndTag;
			break;
		case 'i':
			currentTokenType = TokenType.CloseItalic;
			Next();
			state = StateType.EndTag;
			break;
		case '#':
			currentTokenType = TokenType.CloseColor;
			Next();
			state = StateType.EndTag;
			break;
		case '+':
			currentTokenType = TokenType.CloseSize;
			Next();
			state = StateType.EndTag;
			break;
		default:
			ResetTokenStart();
			state = StateType.Str;
			break;
		}
	}

	private void Tag()
	{
		switch (Current())
		{
		case 'b':
			currentTokenType = TokenType.Bold;
			Next();
			state = StateType.EndTag;
			break;
		case 'i':
			currentTokenType = TokenType.Italic;
			Next();
			state = StateType.EndTag;
			break;
		case '#':
			currentTokenType = TokenType.Color;
			currentParser = ParseColor;
			Next();
			StartNewToken();
			state = StateType.ParamTag;
			break;
		case '+':
			currentTokenType = TokenType.Size;
			currentParser = ParseSize;
			Next();
			StartNewToken();
			state = StateType.ParamTag;
			break;
		case '/':
			Next();
			state = StateType.CloseTag;
			break;
		default:
			ResetTokenStart();
			state = StateType.Str;
			break;
		}
	}

	private void Str()
	{
		if (Current() == '[')
		{
			WritePatternString();
			StartNewPattern();
			Next();
			state = StateType.Tag;
		}
		else
		{
			Next();
		}
	}

	public static List<Token> Lex(string text)
	{
		return new Lexer().TokenizeText(text);
	}

	public List<Token> TokenizeText(string text)
	{
		this.text = text;
		while (position < text.Length)
		{
			switch (state)
			{
			case StateType.Str:
				Str();
				break;
			case StateType.Tag:
				Tag();
				break;
			case StateType.CloseTag:
				CloseTag();
				break;
			case StateType.EndTag:
				EndTag();
				break;
			case StateType.ParamTag:
				ParamTag();
				break;
			}
		}
		WritePatternString();
		return tokens;
	}

	protected override void Reset()
	{
		text = null;
		patternStart = 0;
		tokenStart = 0;
		position = 0;
		Poolable<Formatter.Token>.ReturnToPool(tokens);
		currentTokenType = TokenType.String;
		currentParser = null;
		state = StateType.Str;
	}
}


private class Entry : Poolable<Entry>
{
	public string Pattern;

	public Element Element;

	public static Entry TakeFromPool(string pattern, Element element)
	{
		Entry entry = Poolable<Entry>.TakeFromPool();
		entry.Pattern = pattern;
		entry.Element = element;
		return entry;
	}

	protected override void Reset()
	{
		Pattern = null;
		Element = null;
	}
}


using System.Collections.Generic;

private class ElementTreeBuilder : Poolable<ElementTreeBuilder>
{
	private readonly Stack<Entry> entries = new Stack<Entry>();

	public bool shouldPoolElements;

	public Element ProcessTokens(List<Token> tokens)
	{
		int num = 0;
		entries.Clear();
		entries.Push(Entry.TakeFromPool(null, Element.Tag(ElementType.String, shouldPoolElements)));
		while (num < tokens.Count)
		{
			Token token = tokens[num++];
			Element element = entries.Peek().Element;
			if (token.Type == closeTags[element.Type])
			{
				entries.Pop();
				entries.Peek().Element.Body.Add(element);
				continue;
			}
			switch (token.Type)
			{
			case TokenType.String:
				element.Body.Add(Element.String(token.Val, shouldPoolElements));
				break;
			case TokenType.Bold:
				entries.Push(Entry.TakeFromPool(token.Pattern, Element.Tag(ElementType.Bold, shouldPoolElements)));
				break;
			case TokenType.Italic:
				entries.Push(Entry.TakeFromPool(token.Pattern, Element.Tag(ElementType.Italic, shouldPoolElements)));
				break;
			case TokenType.Color:
				entries.Push(Entry.TakeFromPool(token.Pattern, Element.ParamTag(ElementType.Color, token.Val, shouldPoolElements)));
				break;
			case TokenType.Size:
				entries.Push(Entry.TakeFromPool(token.Pattern, Element.ParamTag(ElementType.Size, token.Val, shouldPoolElements)));
				break;
			default:
				element.Body.Add(Element.String(token.Pattern, shouldPoolElements));
				break;
			}
		}
		while (entries.Count > 1)
		{
			Entry entry = entries.Pop();
			List<Element> body = entries.Peek().Element.Body;
			body.Add(Element.String(entry.Pattern));
			body.AddRange(entry.Element.Body);
			Poolable<Entry>.ReturnToPool(entry);
		}
		Entry entry2 = entries.Pop();
		Element element2 = entry2.Element;
		Poolable<Entry>.ReturnToPool(entry2);
		return element2;
	}

	protected override void Reset()
	{
		shouldPoolElements = false;
		while (entries.Count > 0)
		{
			Poolable<Entry>.ReturnToPool(entries.Pop());
		}
	}
}


private class Tag
{
	public string Open;

	public string Close;

	public Tag(string open, string close)
	{
		Open = open;
		Close = close;
	}
}


using System.Collections.Generic;

public abstract class Poolable<T> where T : Poolable<T>, new()
{
	private static readonly Stack<T> _pool = new Stack<T>();

	private static readonly object _poolLock = new object();

	protected bool isFromPool { get; private set; }

	public static T TakeFromPool()
	{
		T val;
		lock (_poolLock)
		{
			val = ((_pool.Count > 0) ? _pool.Pop() : new T());
		}
		val.isFromPool = true;
		return val;
	}

	public static void ReturnToPool(T obj)
	{
		if (obj == null || !obj.isFromPool)
		{
			return;
		}
		obj.Reset();
		lock (_poolLock)
		{
			_pool.Push(obj);
		}
	}

	public static void ReturnToPool(List<T> objs)
	{
		if (objs != null)
		{
			for (int i = 0; i < objs.Count; i++)
			{
				ReturnToPool(objs[i]);
			}
			objs.Clear();
		}
	}

	protected abstract void Reset();
}


public class SqlJoinClause
{
	private readonly Sql _sql;

	public SqlJoinClause(Sql sql)
	{
		_sql = sql;
	}

	public Sql On(string onClause, params object[] args)
	{
		return _sql.Append("ON " + onClause, args);
	}
}


public class OxideOptions
{
	public bool Modded { get; set; } = true;

	public bool PluginWatchers { get; set; } = true;

	public DefaultGroups DefaultGroups { get; set; } = new DefaultGroups();

	public string WebRequestIP { get; set; } = "0.0.0.0";
}


using System.Collections.Generic;
using Newtonsoft.Json;

public class CommandOptions
{
	[JsonProperty(PropertyName = "Chat command prefixes")]
	public List<string> ChatPrefix { get; set; } = new List<string> { "/" };
}


using System.Collections.Generic;
using Newtonsoft.Json;

public class CompilerOptions
{
	[JsonProperty(PropertyName = "Shutdown on idle")]
	public bool IdleShutdown { get; set; } = true;

	[JsonProperty(PropertyName = "Seconds before idle")]
	public int IdleTimeout { get; set; } = 60;

	[JsonProperty(PropertyName = "Preprocessor directives")]
	public List<string> PreprocessorDirectives { get; set; } = new List<string>();

	[JsonProperty(PropertyName = "Enable Publicizer")]
	public bool? Publicize { get; set; } = true;

	[JsonProperty(PropertyName = "Ignored Publicizer References")]
	public List<string> IgnoredPublicizerReferences { get; set; } = new List<string>();
}


using System.Collections;
using System.Collections.Generic;
using Newtonsoft.Json;

[JsonObject]
public class DefaultGroups : IEnumerable<string>, IEnumerable
{
	public string Players { get; set; } = "default";

	public string Administrators { get; set; } = "admin";

	public IEnumerator<string> GetEnumerator()
	{
		yield return Players;
		yield return Administrators;
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


public class OxideConsole
{
	public bool Enabled { get; set; } = true;

	public bool MinimalistMode { get; set; } = true;

	public bool ShowStatusBar { get; set; } = true;
}


public class OxideRcon
{
	public bool Enabled { get; set; }

	public int Port { get; set; } = 25580;

	public string Password { get; set; } = string.Empty;

	public string ChatPrefix { get; set; } = "[Server Console]";
}


private enum StateType
{
	Str,
	Tag,
	CloseTag,
	EndTag,
	ParamTag
}


