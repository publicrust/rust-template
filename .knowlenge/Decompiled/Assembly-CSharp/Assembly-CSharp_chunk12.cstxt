using System;
using System.Collections.Generic;
using System.Linq;
using Rust;
using UnityEngine;

public class Climate : SingletonComponent<Climate>
{
	[Serializable]
	public class ClimateParameters
	{
		public AnimationCurve Temperature;

		[Horizontal(4, -1)]
		public Float4 AerialDensity;

		[Horizontal(4, -1)]
		public Float4 FogDensity;

		[Horizontal(4, -1)]
		public Color4 FogColorGrad;

		[Horizontal(4, -1)]
		public Float4 FogAmbientIntensity = Float4.One();

		[Range(0f, 1f)]
		[Horizontal(4, -1)]
		public Float4 FogAmbientSaturation = Float4.One();

		[Horizontal(4, -1)]
		public Float4 FogLightBoost = Float4.One();

		public float BiomeWeightExponent = 1f;

		public float FogHeightFalloff = 0.02f;
	}

	[Serializable]
	public class WeatherParameters
	{
		[Range(0f, 1f)]
		public float ClearChance = 1f;

		[Range(0f, 1f)]
		public float DustChance;

		[Range(0f, 1f)]
		public float FogChance;

		[Range(0f, 1f)]
		public float OvercastChance;

		[Range(0f, 1f)]
		public float StormChance;

		[Range(0f, 1f)]
		public float RainChance;
	}

	public class Value4<T>
	{
		public T Dawn;

		public T Noon;

		public T Dusk;

		public T Night;

		public float FindBlendParameters(TOD_Sky sky, out T src, out T dst)
		{
			float num = Mathf.Abs(sky.SunriseTime - sky.Cycle.Hour);
			float num2 = Mathf.Abs(sky.SunsetTime - sky.Cycle.Hour);
			float num3 = (180f - sky.SunZenith) / 180f;
			float num4 = 1f / 9f;
			if (num < num2)
			{
				if (num3 < 0.5f)
				{
					src = Night;
					dst = Dawn;
					return Mathf.InverseLerp(0.5f - num4, 0.5f, num3);
				}
				src = Dawn;
				dst = Noon;
				return Mathf.InverseLerp(0.5f, 0.5f + num4, num3);
			}
			if (num3 > 0.5f)
			{
				src = Noon;
				dst = Dusk;
				return Mathf.InverseLerp(0.5f + num4, 0.5f, num3);
			}
			src = Dusk;
			dst = Night;
			return Mathf.InverseLerp(0.5f, 0.5f - num4, num3);
		}
	}

	[Serializable]
	public class Float4 : Value4<float>
	{
		public static Float4 One()
		{
			return new Float4
			{
				Dawn = 1f,
				Dusk = 1f,
				Noon = 1f,
				Night = 1f
			};
		}
	}

	[Serializable]
	public class Color4 : Value4<Color>
	{
	}

	[Serializable]
	public class Texture2D4 : Value4<Texture2D>
	{
	}

	private const float fadeAngle = 20f;

	private const float defaultTemp = 15f;

	private const int weatherDurationHours = 18;

	private const int weatherFadeHours = 6;

	public float BiomeFogShoreDistanceFalloff = -25f;

	[Range(0f, 1f)]
	public float BlendingSpeed = 1f;

	public float FogDarknessDistance = 200f;

	public bool DebugLUTBlending;

	public WeatherParameters Weather;

	public WeatherPreset[] WeatherPresets;

	public ClimateParameters Arid;

	public ClimateParameters Temperate;

	public ClimateParameters Tundra;

	public ClimateParameters Arctic;

	public ClimateParameters Jungle;

	public float UndergroundFogDensity;

	public Color UndergroundFogColor = Color.black;

	public VolumeCloudsConfig[] DefaultCloudConfigs;

	public VolumeCloudsCirrusConfig[] DefaultCirrusConfigs;

	public VolumeCloudsConfig[] AllCloudConfigs;

	public Dictionary<WeatherPresetType, WeatherPreset[]> presetLookup;

	private ClimateParameters[] climateLookup;

	public float WeatherStateBlend { get; set; }

	public uint WeatherSeedPrevious { get; set; }

	public uint WeatherSeedTarget { get; set; }

	public uint WeatherSeedNext { get; set; }

	public WeatherPreset WeatherStatePrevious { get; set; }

	public WeatherPreset WeatherStateTarget { get; set; }

	public WeatherPreset WeatherStateNext { get; set; }

	public WeatherPreset WeatherState { get; set; }

	public WeatherPreset WeatherClampsMin { get; private set; }

	public WeatherPreset WeatherClampsMax { get; private set; }

	public WeatherPreset WeatherOverrides { get; set; }

	public LegacyWeatherState Overrides { get; set; }

	protected override void Awake()
	{
		((SingletonComponent)this).Awake();
		WeatherState = ScriptableObject.CreateInstance(typeof(WeatherPreset)) as WeatherPreset;
		WeatherClampsMin = ScriptableObject.CreateInstance(typeof(WeatherPreset)) as WeatherPreset;
		WeatherClampsMax = ScriptableObject.CreateInstance(typeof(WeatherPreset)) as WeatherPreset;
		WeatherOverrides = ScriptableObject.CreateInstance(typeof(WeatherPreset)) as WeatherPreset;
		WeatherState.Reset();
		WeatherClampsMin.Reset();
		WeatherClampsMax.Reset();
		WeatherOverrides.Reset();
		Overrides = new LegacyWeatherState(WeatherOverrides);
	}

	protected override void OnDestroy()
	{
		if (!Application.isQuitting)
		{
			((SingletonComponent)this).OnDestroy();
			if ((Object)(object)WeatherState != (Object)null)
			{
				Object.Destroy((Object)(object)WeatherState);
			}
			if ((Object)(object)WeatherClampsMin != (Object)null)
			{
				Object.Destroy((Object)(object)WeatherClampsMin);
			}
			if ((Object)(object)WeatherClampsMax != (Object)null)
			{
				Object.Destroy((Object)(object)WeatherClampsMax);
			}
			if ((Object)(object)WeatherOverrides != (Object)null)
			{
				Object.Destroy((Object)(object)WeatherOverrides);
			}
		}
	}

	private void GetPresetVCloudConfigs(WeatherPreset preset, uint seed, out VolumeCloudsConfig cfg, out VolumeCloudsCirrusConfig cfgCirrus, out VolumeCloudsRadialWeatherLayerConfig cfgStorm)
	{
		if (preset.VolumeCloudsConfigs != null && preset.VolumeCloudsConfigs.Length != 0)
		{
			cfg = preset.VolumeCloudsConfigs[SeedRandom.Range(seed, 0, preset.VolumeCloudsConfigs.Length)];
		}
		else if (DefaultCloudConfigs.Length == 0)
		{
			Debug.LogError((object)"Current weather profile has no cloud config, and default cloud config list is empty!  This shouldn't be so");
			cfg = null;
		}
		else
		{
			cfg = DefaultCloudConfigs[SeedRandom.Range(seed, 0, DefaultCloudConfigs.Length)];
		}
		if (preset.VolumeCloudsCirrusConfigs != null && preset.VolumeCloudsCirrusConfigs.Length != 0)
		{
			cfgCirrus = preset.VolumeCloudsCirrusConfigs[SeedRandom.Range(seed, 0, preset.VolumeCloudsCirrusConfigs.Length)];
		}
		else if (DefaultCirrusConfigs.Length == 0)
		{
			Debug.LogError((object)"Current weather profile has no cirrus cloud config, and default cirrus cloud config list is empty!  This shouldn't be so");
			cfgCirrus = null;
		}
		else
		{
			cfgCirrus = DefaultCirrusConfigs[SeedRandom.Range(seed, 0, DefaultCirrusConfigs.Length)];
		}
		if (preset.VolumeCloudsStormLayers != null && preset.VolumeCloudsStormLayers.Length != 0)
		{
			cfgStorm = preset.VolumeCloudsStormLayers[SeedRandom.Range(seed, 0, preset.VolumeCloudsStormLayers.Length)];
		}
		else
		{
			cfgStorm = null;
		}
	}

	public void Update()
	{
		if (!Application.isReceiving && !Application.isLoading && Object.op_Implicit((Object)(object)TOD_Sky.Instance))
		{
			TOD_Sky instance = TOD_Sky.Instance;
			long num = World.Seed + instance.Cycle.Ticks;
			long num2 = 648000000000L;
			long num3 = 216000000000L;
			long num4 = num / num2;
			WeatherStateBlend = Mathf.InverseLerp(0f, (float)num3, (float)(num % num2));
			uint seed = (WeatherSeedPrevious = GetSeedFromLong(num4));
			WeatherStatePrevious = GetWeatherPreset(seed);
			seed = (WeatherSeedTarget = GetSeedFromLong(num4 + 1));
			WeatherStateTarget = GetWeatherPreset(seed);
			seed = (WeatherSeedNext = GetSeedFromLong(num4 + 2));
			WeatherStateNext = GetWeatherPreset(seed);
			WeatherState.Fade(WeatherStatePrevious, WeatherStateTarget, WeatherStateBlend);
			WeatherState.Override(WeatherOverrides);
		}
	}

	private static bool Initialized()
	{
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherStatePrevious))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherStateTarget))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherStateNext))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherState))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherClampsMin))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherOverrides))
		{
			return false;
		}
		return true;
	}

	public static float GetClouds(Vector3 position)
	{
		if (!Initialized())
		{
			return 0f;
		}
		return SingletonComponent<Climate>.Instance.WeatherState.Clouds.Coverage;
	}

	public static float GetFog(Vector3 position)
	{
		if (!Initialized())
		{
			return 0f;
		}
		return SingletonComponent<Climate>.Instance.WeatherState.Atmosphere.Fogginess;
	}

	public static float GetWind(Vector3 position)
	{
		if (!Initialized())
		{
			return 0f;
		}
		return SingletonComponent<Climate>.Instance.WeatherState.Wind;
	}

	public static float GetThunder(Vector3 position)
	{
		if (!Initialized())
		{
			return 0f;
		}
		float thunder = SingletonComponent<Climate>.Instance.WeatherOverrides.Thunder;
		if (thunder >= 0f)
		{
			return thunder;
		}
		float thunder2 = SingletonComponent<Climate>.Instance.WeatherState.Thunder;
		float thunder3 = SingletonComponent<Climate>.Instance.WeatherStatePrevious.Thunder;
		float thunder4 = SingletonComponent<Climate>.Instance.WeatherStateTarget.Thunder;
		if (thunder3 > 0f && thunder2 > 0.5f * thunder3)
		{
			return thunder2;
		}
		if (thunder4 > 0f && thunder2 > 0.5f * thunder4)
		{
			return thunder2;
		}
		return 0f;
	}

	public static float GetRainbow(Vector3 position)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if (!Initialized())
		{
			return 0f;
		}
		TOD_Sky instance = TOD_Sky.Instance;
		if (!Object.op_Implicit((Object)(object)instance) || !instance.IsDay || instance.LerpValue < 1f)
		{
			return 0f;
		}
		if (GetFog(position) > 0.25f)
		{
			return 0f;
		}
		float num = (Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap) ? TerrainMeta.BiomeMap.GetBiome(position, 3) : 0f);
		if (num <= 0f)
		{
			return 0f;
		}
		float rainbow = SingletonComponent<Climate>.Instance.WeatherOverrides.Rainbow;
		if (rainbow >= 0f)
		{
			return rainbow * num;
		}
		if (SingletonComponent<Climate>.Instance.WeatherState.Rainbow <= 0f)
		{
			return 0f;
		}
		if (SingletonComponent<Climate>.Instance.WeatherStateTarget.Rainbow > 0f)
		{
			return 0f;
		}
		float rainbow2 = SingletonComponent<Climate>.Instance.WeatherStatePrevious.Rainbow;
		float num2 = SeedRandom.Value(SingletonComponent<Climate>.Instance.WeatherSeedPrevious);
		if (rainbow2 < num2)
		{
			return 0f;
		}
		return num;
	}

	public static float GetAurora(Vector3 position)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		if (!Initialized())
		{
			return 0f;
		}
		TOD_Sky instance = TOD_Sky.Instance;
		if (!Object.op_Implicit((Object)(object)instance) || !instance.IsNight || instance.LerpValue > 0f)
		{
			return 0f;
		}
		if (GetClouds(position) > 0.1f)
		{
			return 0f;
		}
		if (GetFog(position) > 0.1f)
		{
			return 0f;
		}
		if (!Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap))
		{
			return 0f;
		}
		return TerrainMeta.BiomeMap.GetBiome(position, 8);
	}

	public static float GetRain(Vector3 position)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if (!Initialized())
		{
			return 0f;
		}
		float num = (Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap) ? TerrainMeta.BiomeMap.GetBiome(position, 1) : 0f);
		float num2 = (Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap) ? TerrainMeta.BiomeMap.GetBiome(position, 8) : 0f);
		return SingletonComponent<Climate>.Instance.WeatherState.Rain * Mathf.Lerp(1f, 0.5f, num) * (1f - num2);
	}

	public static float GetSnow(Vector3 position)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if (!Initialized())
		{
			return 0f;
		}
		float num = (Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap) ? TerrainMeta.BiomeMap.GetBiome(position, 8) : 0f);
		return SingletonComponent<Climate>.Instance.WeatherState.Rain * num;
	}

	public static float GetTemperature(Vector3 position)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (!Initialized())
		{
			return 15f;
		}
		TOD_Sky instance = TOD_Sky.Instance;
		if (!Object.op_Implicit((Object)(object)instance))
		{
			return 15f;
		}
		ClimateParameters src;
		ClimateParameters dst;
		float num = SingletonComponent<Climate>.Instance.FindBlendParameters(position, out src, out dst);
		if (src == null || dst == null)
		{
			return 15f;
		}
		float hour = instance.Cycle.Hour;
		float num2 = src.Temperature.Evaluate(hour);
		float num3 = dst.Temperature.Evaluate(hour);
		return Mathf.Lerp(num2, num3, num);
	}

	private uint GetSeedFromLong(long val)
	{
		uint result = (uint)((val % uint.MaxValue + uint.MaxValue) % uint.MaxValue);
		SeedRandom.Wanghash(ref result);
		SeedRandom.Wanghash(ref result);
		SeedRandom.Wanghash(ref result);
		return result;
	}

	private WeatherPreset GetWeatherPreset(uint seed)
	{
		float num = Weather.ClearChance + Weather.DustChance + Weather.FogChance + Weather.OvercastChance + Weather.StormChance + Weather.RainChance;
		float num2 = SeedRandom.Range(ref seed, 0f, num);
		if (num2 < Weather.RainChance)
		{
			return GetWeatherPreset(seed, WeatherPresetType.Rain);
		}
		if (num2 < Weather.RainChance + Weather.StormChance)
		{
			return GetWeatherPreset(seed, WeatherPresetType.Storm);
		}
		if (num2 < Weather.RainChance + Weather.StormChance + Weather.OvercastChance)
		{
			return GetWeatherPreset(seed, WeatherPresetType.Overcast);
		}
		if (num2 < Weather.RainChance + Weather.StormChance + Weather.OvercastChance + Weather.FogChance)
		{
			return GetWeatherPreset(seed, WeatherPresetType.Fog);
		}
		if (num2 < Weather.RainChance + Weather.StormChance + Weather.OvercastChance + Weather.FogChance + Weather.DustChance)
		{
			return GetWeatherPreset(seed, WeatherPresetType.Dust);
		}
		return GetWeatherPreset(seed, WeatherPresetType.Clear);
	}

	private WeatherPreset GetWeatherPreset(uint seed, WeatherPresetType type)
	{
		if (presetLookup == null)
		{
			presetLookup = new Dictionary<WeatherPresetType, WeatherPreset[]>();
		}
		if (!presetLookup.TryGetValue(type, out var value))
		{
			presetLookup.Add(type, value = CacheWeatherPresets(type));
		}
		return value.GetRandom(ref seed);
	}

	public WeatherPreset[] CacheWeatherPresets(WeatherPresetType type)
	{
		return WeatherPresets.Where((WeatherPreset x) => x.Type == type).ToArray();
	}

	private float FindBlendParameters(Vector3 pos, out ClimateParameters src, out ClimateParameters dst)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		if (climateLookup == null)
		{
			climateLookup = new ClimateParameters[5] { Arid, Temperate, Tundra, Arctic, Jungle };
		}
		if ((Object)(object)TerrainMeta.BiomeMap == (Object)null)
		{
			src = Temperate;
			dst = Temperate;
			return 0.5f;
		}
		int biomeMaxType = TerrainMeta.BiomeMap.GetBiomeMaxType(pos);
		int biomeMaxType2 = TerrainMeta.BiomeMap.GetBiomeMaxType(pos, ~biomeMaxType);
		src = climateLookup[TerrainBiome.TypeToIndex(biomeMaxType)];
		dst = climateLookup[TerrainBiome.TypeToIndex(biomeMaxType2)];
		return TerrainMeta.BiomeMap.GetBiome(pos, biomeMaxType2);
	}
}


using System;
using UnityEngine;

[Serializable]
public class ClimateParameters
{
	public AnimationCurve Temperature;

	[Horizontal(4, -1)]
	public Float4 AerialDensity;

	[Horizontal(4, -1)]
	public Float4 FogDensity;

	[Horizontal(4, -1)]
	public Color4 FogColorGrad;

	[Horizontal(4, -1)]
	public Float4 FogAmbientIntensity = Float4.One();

	[Range(0f, 1f)]
	[Horizontal(4, -1)]
	public Float4 FogAmbientSaturation = Float4.One();

	[Horizontal(4, -1)]
	public Float4 FogLightBoost = Float4.One();

	public float BiomeWeightExponent = 1f;

	public float FogHeightFalloff = 0.02f;
}


using System;
using UnityEngine;

[Serializable]
public class WeatherParameters
{
	[Range(0f, 1f)]
	public float ClearChance = 1f;

	[Range(0f, 1f)]
	public float DustChance;

	[Range(0f, 1f)]
	public float FogChance;

	[Range(0f, 1f)]
	public float OvercastChance;

	[Range(0f, 1f)]
	public float StormChance;

	[Range(0f, 1f)]
	public float RainChance;
}


using UnityEngine;

public class Value4<T>
{
	public T Dawn;

	public T Noon;

	public T Dusk;

	public T Night;

	public float FindBlendParameters(TOD_Sky sky, out T src, out T dst)
	{
		float num = Mathf.Abs(sky.SunriseTime - sky.Cycle.Hour);
		float num2 = Mathf.Abs(sky.SunsetTime - sky.Cycle.Hour);
		float num3 = (180f - sky.SunZenith) / 180f;
		float num4 = 1f / 9f;
		if (num < num2)
		{
			if (num3 < 0.5f)
			{
				src = Night;
				dst = Dawn;
				return Mathf.InverseLerp(0.5f - num4, 0.5f, num3);
			}
			src = Dawn;
			dst = Noon;
			return Mathf.InverseLerp(0.5f, 0.5f + num4, num3);
		}
		if (num3 > 0.5f)
		{
			src = Noon;
			dst = Dusk;
			return Mathf.InverseLerp(0.5f + num4, 0.5f, num3);
		}
		src = Dusk;
		dst = Night;
		return Mathf.InverseLerp(0.5f, 0.5f - num4, num3);
	}
}


using System;

[Serializable]
public class Float4 : Value4<float>
{
	public static Float4 One()
	{
		return new Float4
		{
			Dawn = 1f,
			Dusk = 1f,
			Noon = 1f,
			Night = 1f
		};
	}
}


using System;
using UnityEngine;

[Serializable]
public class Color4 : Value4<Color>
{
}


using System;
using UnityEngine;

[Serializable]
public class Texture2D4 : Value4<Texture2D>
{
}


using System;
using UnityEngine;

public class ColliderInfo : MonoBehaviour
{
	[Flags]
	public enum Flags
	{
		Usable = 1,
		Shootable = 2,
		Melee = 4,
		Opaque = 8,
		Airflow = 0x10,
		OnlyBlockBuildingBlock = 0x20,
		Monument = 0x40,
		Tunnels = 0x80,
		AllowBuildInsideMesh = 0x100
	}

	public const Flags FlagsNone = (Flags)0;

	public const Flags FlagsEverything = (Flags)(-1);

	public const Flags FlagsDefault = Flags.Usable | Flags.Shootable | Flags.Melee | Flags.Opaque;

	[InspectorFlags]
	public Flags flags = Flags.Usable | Flags.Shootable | Flags.Melee | Flags.Opaque;

	public bool HasFlag(Flags f)
	{
		return (flags & f) == f;
	}

	public void SetFlag(Flags f, bool b)
	{
		if (b)
		{
			flags |= f;
		}
		else
		{
			flags &= ~f;
		}
	}

	public bool Filter(HitTest info)
	{
		switch (info.type)
		{
		case HitTest.Type.MeleeAttack:
			if ((flags & Flags.Melee) == 0)
			{
				return false;
			}
			break;
		case HitTest.Type.ProjectileEffect:
		case HitTest.Type.Projectile:
			if ((flags & Flags.Shootable) == 0)
			{
				return false;
			}
			break;
		case HitTest.Type.Use:
			if ((flags & Flags.Usable) == 0)
			{
				return false;
			}
			break;
		}
		return true;
	}
}


using System;

[Flags]
public enum Flags
{
	Usable = 1,
	Shootable = 2,
	Melee = 4,
	Opaque = 8,
	Airflow = 0x10,
	OnlyBlockBuildingBlock = 0x20,
	Monument = 0x40,
	Tunnels = 0x80,
	AllowBuildInsideMesh = 0x100
}


public class ColliderInfo_Pipe : ColliderInfo
{
	public int OutputSlotIndex;

	public IOEntity ParentEntity;
}


using UnityEngine;

public class ConditionalGibbable : MonoBehaviour
{
	[ReadOnly]
	public int id;
}


using UnityEngine;

public class CreateEffect : MonoBehaviour
{
	public GameObjectRef EffectToCreate;

	public void OnEnable()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		Effect.client.Run(EffectToCreate.resourcePath, ((Component)this).transform.position, ((Component)this).transform.up, ((Component)this).transform.forward);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class CreationGibSpawner : BaseMonoBehaviour
{
	[Serializable]
	public class GibReplacement
	{
		public GameObject oldGib;

		public GameObject newGib;
	}

	[Serializable]
	public class EffectMaterialPair
	{
		public PhysicMaterial material;

		public GameObjectRef effect;
	}

	[Serializable]
	public struct ConditionalGibSource
	{
		public GameObject source;

		public Vector3 pos;

		public Quaternion rot;
	}

	private GameObject gibSource;

	public GameObject gibsInstance;

	public float startTime;

	public float duration = 1f;

	public float buildScaleAdditionalAmount = 0.5f;

	[Tooltip("Entire object will be scaled on xyz during duration by this curve")]
	public AnimationCurve scaleCurve;

	[Tooltip("Object will be pushed out along transform.forward/right/up based on build direction by this amount")]
	public AnimationCurve buildCurve;

	[Tooltip("Additional scaling to apply to object based on build direction")]
	public AnimationCurve buildScaleCurve;

	public AnimationCurve xCurve;

	public AnimationCurve yCurve;

	public AnimationCurve zCurve;

	public Vector3[] spawnPositions;

	public GameObject[] particles;

	public float[] gibProgress;

	public PhysicMaterial physMaterial;

	public List<Transform> gibs;

	public bool started;

	public GameObjectRef placeEffect;

	public GameObject smokeEffect;

	public float effectSpacing = 0.2f;

	public bool invert;

	public Vector3 buildDirection;

	[Horizontal(1, 0)]
	public GibReplacement[] GibReplacements;

	public EffectMaterialPair[] effectLookup;

	private float startDelay;

	public List<ConditionalGibSource> conditionalGibSources = new List<ConditionalGibSource>();

	private float nextEffectTime = float.NegativeInfinity;

	public GameObjectRef GetEffectForMaterial(PhysicMaterial mat)
	{
		EffectMaterialPair[] array = effectLookup;
		foreach (EffectMaterialPair effectMaterialPair in array)
		{
			if ((Object)(object)effectMaterialPair.material == (Object)(object)mat)
			{
				return effectMaterialPair.effect;
			}
		}
		return effectLookup[0].effect;
	}

	public void SetDelay(float newDelay)
	{
		startDelay = newDelay;
	}

	public void FinishSpawn()
	{
		if (startDelay == 0f)
		{
			Init();
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)Init, startDelay);
		}
	}

	public float GetProgress(float delay)
	{
		if (!started)
		{
			return 0f;
		}
		if (duration == 0f)
		{
			return 1f;
		}
		return Mathf.Clamp01((Time.time - (startTime + delay)) / duration);
	}

	public void AddConditionalGibSource(GameObject cGibSource, Vector3 pos, Quaternion rot)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		Debug.Log((object)"Adding conditional gib source");
		ConditionalGibSource item = default(ConditionalGibSource);
		item.source = cGibSource;
		item.pos = pos;
		item.rot = rot;
		conditionalGibSources.Add(item);
	}

	public void SetGibSource(GameObject newGibSource)
	{
		GameObject val = newGibSource;
		for (int i = 0; i < GibReplacements.Length; i++)
		{
			if ((Object)(object)GibReplacements[i].oldGib == (Object)(object)newGibSource)
			{
				val = GibReplacements[i].newGib;
				break;
			}
		}
		gibSource = val;
	}

	private int SortsGibs(Transform a, Transform b)
	{
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		MeshRenderer component = ((Component)a).GetComponent<MeshRenderer>();
		MeshRenderer component2 = ((Component)b).GetComponent<MeshRenderer>();
		Bounds bounds;
		if (!invert)
		{
			float y;
			if (!((Object)(object)component == (Object)null))
			{
				bounds = ((Renderer)component).bounds;
				y = ((Bounds)(ref bounds)).center.y;
			}
			else
			{
				y = a.localPosition.y;
			}
			float num = y;
			float y2;
			if (!((Object)(object)component2 == (Object)null))
			{
				bounds = ((Renderer)component2).bounds;
				y2 = ((Bounds)(ref bounds)).center.y;
			}
			else
			{
				y2 = b.localPosition.y;
			}
			float value = y2;
			return num.CompareTo(value);
		}
		float y3;
		if (!((Object)(object)component == (Object)null))
		{
			bounds = ((Renderer)component).bounds;
			y3 = ((Bounds)(ref bounds)).center.y;
		}
		else
		{
			y3 = a.localPosition.y;
		}
		float value2 = y3;
		float y4;
		if (!((Object)(object)component2 == (Object)null))
		{
			bounds = ((Renderer)component2).bounds;
			y4 = ((Bounds)(ref bounds)).center.y;
		}
		else
		{
			y4 = b.localPosition.y;
		}
		float num2 = y4;
		return num2.CompareTo(value2);
	}

	public void Init()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		started = true;
		startTime = Time.time;
		gibsInstance = Object.Instantiate<GameObject>(gibSource, ((Component)this).transform.position, ((Component)this).transform.rotation);
		List<Transform> list = gibsInstance.GetComponentsInChildren<Transform>().ToList();
		list.Remove(gibsInstance.transform);
		list.Sort(SortsGibs);
		gibs = list;
		spawnPositions = (Vector3[])(object)new Vector3[gibs.Count];
		gibProgress = new float[gibs.Count];
		particles = (GameObject[])(object)new GameObject[gibs.Count];
		for (int i = 0; i < gibs.Count; i++)
		{
			Transform val = gibs[i];
			spawnPositions[i] = val.localPosition;
			gibProgress[i] = 0f;
			particles[i] = null;
			val.localScale = Vector3.one * scaleCurve.Evaluate(0f);
			_ = spawnPositions[i].x;
			_ = 0f;
			Transform transform = ((Component)val).transform;
			transform.position += ((Component)this).transform.right * GetPushDir(spawnPositions[i], val) * buildCurve.Evaluate(0f) * buildDirection.x;
			Transform transform2 = ((Component)val).transform;
			transform2.position += ((Component)this).transform.up * yCurve.Evaluate(0f);
			Transform transform3 = ((Component)val).transform;
			transform3.position += ((Component)this).transform.forward * zCurve.Evaluate(0f);
		}
		((FacepunchBehaviour)this).Invoke((Action)DestroyMe, duration + 0.05f);
	}

	public float GetPushDir(Vector3 spawnPos, Transform theGib)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		if (!(spawnPos.x >= 0f))
		{
			return 1f;
		}
		return -1f;
	}

	public void DestroyMe()
	{
		Object.Destroy((Object)(object)gibsInstance);
	}

	public float GetStartDelay(Transform gib)
	{
		return 0f;
	}

	public void Update()
	{
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_031a: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		if (!started)
		{
			return;
		}
		float deltaTime = Time.deltaTime;
		int num = Mathf.CeilToInt((float)gibs.Count / 10f);
		for (int i = 0; i < gibs.Count; i++)
		{
			Transform val = gibs[i];
			if ((Object)(object)val == (Object)(object)((Component)this).transform)
			{
				continue;
			}
			if (deltaTime <= 0f)
			{
				break;
			}
			float num2 = 0.33f;
			float num3 = num2 / ((float)gibs.Count * num2) * (duration - num2);
			float num4 = (float)i * num3;
			if (Time.time - startTime < num4)
			{
				continue;
			}
			MeshFilter component = ((Component)val).GetComponent<MeshFilter>();
			int seed = Random.seed;
			Random.seed = i + gibs.Count;
			bool num5 = num <= 1 || Random.Range(0, num) == 0;
			Random.seed = seed;
			if (num5 && (Object)(object)particles[i] == (Object)null && (Object)(object)component != (Object)null && (Object)(object)component.sharedMesh != (Object)null)
			{
				Bounds bounds = component.sharedMesh.bounds;
				Vector3 size = ((Bounds)(ref bounds)).size;
				if (((Vector3)(ref size)).magnitude == 0f)
				{
					continue;
				}
				GameObject val2 = Object.Instantiate<GameObject>(smokeEffect);
				val2.transform.SetParent(val);
				val2.transform.localPosition = Vector3.zero;
				val2.transform.localScale = Vector3.one;
				val2.transform.localRotation = Quaternion.identity;
				ParticleSystem component2 = val2.GetComponent<ParticleSystem>();
				MeshRenderer component3 = ((Component)component).GetComponent<MeshRenderer>();
				ShapeModule shape = component2.shape;
				((ShapeModule)(ref shape)).shapeType = (ParticleSystemShapeType)5;
				bounds = ((Renderer)component3).bounds;
				((ShapeModule)(ref shape)).boxThickness = ((Bounds)(ref bounds)).extents;
				particles[i] = val2;
			}
			float num6 = Mathf.Clamp01(gibProgress[i] / num2);
			float num7 = Mathf.Clamp01((num6 + Time.deltaTime) / num2);
			gibProgress[i] += Time.deltaTime;
			float num8 = scaleCurve.Evaluate(num7);
			((Component)val).transform.localScale = new Vector3(num8, num8, num8);
			Transform transform = ((Component)val).transform;
			transform.localScale += buildDirection * buildScaleCurve.Evaluate(num7) * buildScaleAdditionalAmount;
			((Component)val).transform.localPosition = spawnPositions[i];
			Transform transform2 = ((Component)val).transform;
			transform2.position += ((Component)this).transform.right * GetPushDir(spawnPositions[i], val) * buildCurve.Evaluate(num7) * buildDirection.x;
			Transform transform3 = ((Component)val).transform;
			transform3.position += ((Component)this).transform.up * buildCurve.Evaluate(num7) * buildDirection.y;
			Transform transform4 = ((Component)val).transform;
			transform4.position += ((Component)this).transform.forward * buildCurve.Evaluate(num7) * buildDirection.z;
			if (num7 >= 1f && num7 > num6 && Time.time > nextEffectTime)
			{
				nextEffectTime = Time.time + effectSpacing;
				if ((Object)(object)particles[i] != (Object)null)
				{
					particles[i].GetComponent<ParticleSystem>();
					particles[i].transform.SetParent((Transform)null, true);
					particles[i].BroadcastOnParentDestroying();
				}
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class GibReplacement
{
	public GameObject oldGib;

	public GameObject newGib;
}


using System;
using UnityEngine;

[Serializable]
public class EffectMaterialPair
{
	public PhysicMaterial material;

	public GameObjectRef effect;
}


using System;
using UnityEngine;

[Serializable]
public struct ConditionalGibSource
{
	public GameObject source;

	public Vector3 pos;

	public Quaternion rot;
}


public class CullingManager : SingletonComponent<CullingManager>
{
}


using System.Collections.Generic;
using UnityEngine;

public class CullingVolume : MonoBehaviour, IClientComponent
{
	[Tooltip("Override occludee root from children of this object (default) to children of any other object.")]
	public GameObject OccludeeRoot;

	[Tooltip("Invert visibility. False will show occludes. True will hide them.")]
	public bool Invert;

	[Tooltip("A portal in the culling volume chain does not toggle objects visible, it merely signals the non-portal volumes to hide their occludees.")]
	public bool Portal;

	[Tooltip("Secondary culling volumes, connected to this one, that will get signaled when this trigger is activated.")]
	public List<CullingVolume> Connections = new List<CullingVolume>();
}


using System;
using UnityEngine;

public class Deployable : PrefabAttribute
{
	public GameObjectRef guidePrefab;

	public Mesh guideMesh;

	public Vector3 guideMeshScale = Vector3.one;

	public bool overrideRotation;

	public Vector3 guideMeshOrientation = Vector3.zero;

	public Vector3 guideMeshPositionOffset = Vector3.zero;

	public bool guideLights = true;

	public bool wantsInstanceData;

	public bool copyInventoryFromItem;

	public bool setSocketParent;

	public bool toSlot;

	public BaseEntity.Slot slot;

	public GameObjectRef placeEffect;

	[Tooltip("Only required if the guideMesh is in a significantly different position or there are multiple meshes")]
	public Transform[] guideTargets;

	[NonSerialized]
	public Bounds bounds;

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		bounds = rootObj.GetComponent<BaseEntity>().bounds;
	}

	protected override Type GetIndexedType()
	{
		return typeof(Deployable);
	}

	public bool IsGuideTarget(Transform t)
	{
		if (guideTargets != null)
		{
			Transform[] array = guideTargets;
			for (int i = 0; i < array.Length; i++)
			{
				if ((Object)(object)array[i] == (Object)(object)t)
				{
					return true;
				}
			}
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DeployableShowVolume : PrefabAttribute, IClientComponent
{
	public enum VolumeType
	{
		PrefabHemisphere,
		PrefabSphere,
		Sphere,
		Hemisphere,
		Cone
	}

	[Serializable]
	public class Volume
	{
		public VolumeType type;

		[Tooltip("Adding a sphere collider here will automatically fill out the fields below in the PreProcess step.")]
		public SphereCollider associatedCollider;

		public Vector3 localPosition;

		public Vector3 rotation;

		public float size;
	}

	public List<Volume> volumes = new List<Volume>();

	protected override Type GetIndexedType()
	{
		return typeof(DeployableShowVolume);
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		if (volumes == null || volumes.Count == 0)
		{
			return;
		}
		foreach (Volume volume in volumes)
		{
			if (volume != null && !((Object)(object)volume.associatedCollider == (Object)null))
			{
				volume.size = volume.associatedCollider.radius * 2f;
				Transform transform = ((Component)volume.associatedCollider).transform;
				volume.localPosition = transform.localPosition;
				volume.rotation = transform.localEulerAngles;
			}
		}
	}
}


public enum VolumeType
{
	PrefabHemisphere,
	PrefabSphere,
	Sphere,
	Hemisphere,
	Cone
}


using System;
using UnityEngine;

[Serializable]
public class Volume
{
	public VolumeType type;

	[Tooltip("Adding a sphere collider here will automatically fill out the fields below in the PreProcess step.")]
	public SphereCollider associatedCollider;

	public Vector3 localPosition;

	public Vector3 rotation;

	public float size;
}


using System;
using UnityEngine;

public class DeployShell : PrefabAttribute
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one);

	public OBB WorldSpaceBounds(Transform transform)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		return new OBB(transform.position, transform.lossyScale, transform.rotation, bounds);
	}

	public float LineOfSightPadding()
	{
		return 0.025f;
	}

	protected override Type GetIndexedType()
	{
		return typeof(DeployShell);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;
using UnityEngine.Serialization;

public abstract class DeployVolume : PrefabAttribute
{
	public enum EntityMode
	{
		ExcludeList,
		IncludeList
	}

	public enum TypeFilterMode
	{
		Include,
		Ignore
	}

	public LayerMask layers = LayerMask.op_Implicit(537001984);

	[InspectorFlags]
	public ColliderInfo.Flags ignore;

	public EntityMode entityMode;

	[FormerlySerializedAs("entities")]
	public BaseEntity[] entityList;

	[SerializeField]
	public EntityListScriptableObject[] entityGroups;

	[SerializeField]
	public bool includeAllDoors;

	public bool IsBuildingBlock { get; set; }

	public static Collider LastDeployHit { get; set; }

	protected override Type GetIndexedType()
	{
		return typeof(DeployVolume);
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		IsBuildingBlock = (Object)(object)rootObj.GetComponent<BuildingBlock>() != (Object)null;
	}

	protected abstract bool Check(Vector3 position, Quaternion rotation, int mask = -1);

	protected abstract bool Check(Vector3 position, Quaternion rotation, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1);

	protected abstract bool Check(Vector3 position, Quaternion rotation, OBB test, int mask = -1);

	public static bool Check(Vector3 position, Quaternion rotation, DeployVolume[] volumes, int mask = -1)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < volumes.Length; i++)
		{
			if (volumes[i].Check(position, rotation, mask))
			{
				return true;
			}
		}
		return false;
	}

	public static bool Check(Vector3 position, Quaternion rotation, DeployVolume[] volumes, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < volumes.Length; i++)
		{
			if (volumes[i].Check(position, rotation, types, filterMode, ignoredEntity, mask))
			{
				return true;
			}
		}
		return false;
	}

	public static bool Check(Vector3 position, Quaternion rotation, List<DeployVolume> volumes, OBB test, int mask = -1)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < volumes.Count; i++)
		{
			if (volumes[i].Check(position, rotation, test, mask))
			{
				return true;
			}
		}
		return false;
	}

	public static bool CheckSphere(Vector3 pos, float radius, int layerMask, DeployVolume volume)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(pos, radius, list, layerMask, (QueryTriggerInteraction)2);
		bool result = CheckFlags(list, volume);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public static bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask, DeployVolume volume)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return CheckCapsule(start, end, radius, layerMask, volume, null, TypeFilterMode.Include);
	}

	public static bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask, DeployVolume volume, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapCapsule(start, end, radius, list, layerMask, (QueryTriggerInteraction)2);
		bool result = CheckFlags(list, volume, types, filterMode, ignoredEntity);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public static bool CheckOBB(OBB obb, int layerMask, DeployVolume volume)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return CheckOBB(obb, layerMask, volume, null, TypeFilterMode.Include);
	}

	public static bool CheckOBB(OBB obb, int layerMask, DeployVolume volume, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapOBB(obb, list, layerMask, (QueryTriggerInteraction)2);
		bool result = CheckFlags(list, volume, types, filterMode, ignoredEntity);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public static bool CheckBounds(Bounds bounds, int layerMask, DeployVolume volume)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapBounds(bounds, list, layerMask, (QueryTriggerInteraction)2);
		bool result = CheckFlags(list, volume);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	private static bool CheckFlags(List<Collider> list, DeployVolume volume, List<Type> types = null, TypeFilterMode filterMode = TypeFilterMode.Include, BaseEntity ignoredEntity = null)
	{
		if (volume == null)
		{
			return true;
		}
		LastDeployHit = null;
		for (int i = 0; i < list.Count; i++)
		{
			LastDeployHit = list[i];
			BaseEntity baseEntity = LastDeployHit.ToBaseEntity();
			if ((Object)(object)ignoredEntity != (Object)null && (Object)(object)baseEntity != (Object)null && (Object)(object)baseEntity == (Object)(object)ignoredEntity)
			{
				continue;
			}
			if (volume.includeAllDoors && (Object)(object)list[i] != (Object)null)
			{
				BaseEntity baseEntity2 = list[i].ToBaseEntity();
				if ((Object)(object)baseEntity2 != (Object)null && baseEntity2 is Door)
				{
					return true;
				}
			}
			if ((Object)(object)baseEntity != (Object)null && types != null)
			{
				Type type = ((object)baseEntity).GetType();
				bool flag = types.Contains(type);
				if ((filterMode == TypeFilterMode.Include && !flag) || (filterMode == TypeFilterMode.Ignore && flag))
				{
					continue;
				}
			}
			GameObject gameObject = ((Component)list[i]).gameObject;
			if (gameObject.CompareTag("DeployVolumeIgnore"))
			{
				continue;
			}
			ColliderInfo component = gameObject.GetComponent<ColliderInfo>();
			if ((Object)(object)component != (Object)null && component.HasFlag(ColliderInfo.Flags.OnlyBlockBuildingBlock) && !volume.IsBuildingBlock)
			{
				continue;
			}
			if (gameObject.HasCustomTag(GameObjectTag.BlockPlacement))
			{
				return true;
			}
			MonumentInfo monument = list[i].GetMonument();
			if ((!((Object)(object)monument != (Object)null) || monument.IsSafeZone || !volume.ignore.HasFlag(ColliderInfo.Flags.Monument)) && (!((Object)(object)component != (Object)null) || (volume.ignore & component.flags) == 0))
			{
				if ((Object)(object)component != (Object)null && volume.ignore != 0 && component.HasFlag(volume.ignore))
				{
					return false;
				}
				if (ShouldApplyVolumeForEntity(volume, baseEntity))
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool ShouldApplyVolumeForEntity(DeployVolume volume, BaseEntity entity)
	{
		if (volume.entityList == null || volume.entityGroups == null || (volume.entityList.Length == 0 && volume.entityGroups.Length == 0))
		{
			return true;
		}
		if (volume.entityGroups.Length != 0)
		{
			EntityListScriptableObject[] array = volume.entityGroups;
			foreach (EntityListScriptableObject entityListScriptableObject in array)
			{
				if (entityListScriptableObject.entities.IsNullOrEmpty())
				{
					Debug.LogWarning((object)("Skipping entity group '" + ((Object)entityListScriptableObject).name + "' when checking volume: there are no entities"));
				}
				else if (CheckEntityList(entity, entityListScriptableObject.entities, trueIfAnyFound: true))
				{
					return true;
				}
			}
		}
		if (volume.entityList.Length != 0 && CheckEntityList(entity, volume.entityList, volume.entityMode == EntityMode.IncludeList))
		{
			return true;
		}
		return false;
	}

	public static bool CheckEntityList(BaseEntity entity, BaseEntity[] entities, bool trueIfAnyFound)
	{
		if (entities == null || entities.Length == 0)
		{
			return true;
		}
		bool flag = false;
		if ((Object)(object)entity != (Object)null)
		{
			foreach (BaseEntity baseEntity in entities)
			{
				if (entity.prefabID == baseEntity.prefabID)
				{
					flag = true;
					break;
				}
				if (entity is ModularCar && baseEntity is ModularCar)
				{
					flag = true;
					break;
				}
			}
		}
		if (trueIfAnyFound)
		{
			return flag;
		}
		return !flag;
	}
}


public enum EntityMode
{
	ExcludeList,
	IncludeList
}


public enum TypeFilterMode
{
	Include,
	Ignore
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DeployVolumeCapsule : DeployVolume
{
	public Vector3 center = Vector3.zero;

	public float radius = 0.5f;

	public float height = 1f;

	protected override bool Check(Vector3 position, Quaternion rotation, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * center + worldPosition);
		Vector3 start = position + rotation * worldRotation * Vector3.up * height * 0.5f;
		Vector3 end = position + rotation * worldRotation * Vector3.down * height * 0.5f;
		if (DeployVolume.CheckCapsule(start, end, radius, LayerMask.op_Implicit(layers) & mask, this))
		{
			return true;
		}
		return false;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * center + worldPosition);
		Vector3 start = position + rotation * worldRotation * Vector3.up * height * 0.5f;
		Vector3 end = position + rotation * worldRotation * Vector3.down * height * 0.5f;
		if (DeployVolume.CheckCapsule(start, end, radius, LayerMask.op_Implicit(layers) & mask, this, types, filterMode, ignoredEntity))
		{
			return true;
		}
		return false;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask = -1)
	{
		return false;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DeployVolumeEntityBounds : DeployVolume
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one);

	protected override bool Check(Vector3 position, Quaternion rotation, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * ((Bounds)(ref bounds)).center;
		if (DeployVolume.CheckOBB(new OBB(position, ((Bounds)(ref bounds)).size, rotation), LayerMask.op_Implicit(layers) & mask, this))
		{
			return true;
		}
		return false;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return Check(position, rotation, mask);
	}

	protected override bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask = -1)
	{
		return false;
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		bounds = rootObj.GetComponent<BaseEntity>().bounds;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class DeployVolumeEntityBoundsReverse : DeployVolume
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one);

	public int layer;

	protected override bool Check(Vector3 position, Quaternion rotation, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * ((Bounds)(ref bounds)).center;
		OBB test = default(OBB);
		((OBB)(ref test))..ctor(position, ((Bounds)(ref bounds)).size, rotation);
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, ((Vector3)(ref test.extents)).magnitude, list, LayerMask.op_Implicit(layers) & mask, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			DeployVolume[] array = PrefabAttribute.server.FindAll<DeployVolume>(item.prefabID);
			List<DeployVolume> list2 = Pool.Get<List<DeployVolume>>();
			DeployVolume[] array2 = array;
			foreach (DeployVolume deployVolume in array2)
			{
				if (DeployVolume.ShouldApplyVolumeForEntity(deployVolume, item))
				{
					list2.Add(deployVolume);
				}
			}
			if (DeployVolume.Check(((Component)item).transform.position, ((Component)item).transform.rotation, list2, test, 1 << layer))
			{
				Pool.FreeUnmanaged<DeployVolume>(ref list2);
				Pool.FreeUnmanaged<BaseEntity>(ref list);
				return true;
			}
			Pool.FreeUnmanaged<DeployVolume>(ref list2);
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return false;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return Check(position, rotation, mask);
	}

	protected override bool Check(Vector3 position, Quaternion rotation, OBB test, int mask = -1)
	{
		return false;
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		bounds = rootObj.GetComponent<BaseEntity>().bounds;
		layer = rootObj.layer;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DeployVolumeOBB : DeployVolume
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one);

	public DeployVolumeOBB(Bounds bounds, LayerMask layers)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		this.bounds = bounds;
		base.layers = layers;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * ((Bounds)(ref bounds)).center + worldPosition);
		if (DeployVolume.CheckOBB(new OBB(position, ((Bounds)(ref bounds)).size, rotation * worldRotation), LayerMask.op_Implicit(layers) & mask, this))
		{
			return true;
		}
		return false;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * ((Bounds)(ref bounds)).center + worldPosition);
		if (DeployVolume.CheckOBB(new OBB(position, ((Bounds)(ref bounds)).size, rotation * worldRotation), LayerMask.op_Implicit(layers) & mask, this, types, filterMode, ignoredEntity))
		{
			return true;
		}
		return false;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, OBB test, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * ((Bounds)(ref bounds)).center + worldPosition);
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(position, ((Bounds)(ref bounds)).size, rotation * worldRotation);
		if ((LayerMask.op_Implicit(layers) & mask) != 0 && ((OBB)(ref val)).Intersects(test))
		{
			return true;
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DeployVolumeSphere : DeployVolume
{
	public Vector3 center = Vector3.zero;

	public float radius = 0.5f;

	protected override bool Check(Vector3 position, Quaternion rotation, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * center + worldPosition);
		if (DeployVolume.CheckSphere(position, radius, LayerMask.op_Implicit(layers) & mask, this))
		{
			return true;
		}
		return false;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return Check(position, rotation, mask);
	}

	protected override bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * center + worldPosition);
		if ((LayerMask.op_Implicit(layers) & mask) != 0 && Vector3.Distance(position, ((OBB)(ref obb)).ClosestPoint(position)) <= radius)
		{
			return true;
		}
		return false;
	}
}


using UnityEngine;

[CreateAssetMenu(fileName = "NewEntityList", menuName = "Rust/EntityList")]
public class EntityListScriptableObject : ScriptableObject
{
	[SerializeField]
	public BaseEntity[] entities;

	public bool blockIfAny;

	public bool IsInList(uint prefabId)
	{
		if (entities == null)
		{
			return false;
		}
		BaseEntity[] array = entities;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].prefabID == prefabId)
			{
				return true;
			}
		}
		return false;
	}
}


using UnityEngine;

public class PreventBuildingMonumentTag : MonoBehaviour
{
	public bool autoFindMonument;

	[SerializeField]
	private MonumentInfo AttachedMonument;

	public MonumentInfo GetAttachedMonument()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (autoFindMonument && (Object)(object)AttachedMonument == (Object)null)
		{
			MonumentInfo attachedMonument = TerrainMeta.Path.FindClosest(TerrainMeta.Path.Monuments, ((Component)this).transform.position);
			AttachedMonument = attachedMonument;
		}
		return AttachedMonument;
	}

	public void SetMonument(MonumentInfo monument)
	{
		AttachedMonument = monument;
	}
}


using ConVar;
using Oxide.Core;
using UnityEngine;

public class DestroyOnGroundMissing : MonoBehaviour, IServerComponent
{
	private void OnGroundMissing()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = ((Component)this).gameObject.ToBaseEntity();
		if ((Object)(object)baseEntity != (Object)null && Interface.CallHook("OnEntityGroundMissing", (object)baseEntity) == null)
		{
			BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
			if (Stability.log_ground_missing_death)
			{
				Debug.Log((object)$"Killing '{((object)baseEntity).ToString()}' at position {((Component)this).transform.position} due to ground missing");
			}
			if ((Object)(object)baseCombatEntity != (Object)null)
			{
				baseCombatEntity.Die();
			}
			else
			{
				baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);
			}
		}
	}
}


using UnityEngine;

public class DetachMonumentChildren : MonoBehaviour
{
	private void Awake()
	{
		((Component)this).transform.DetachChildren();
	}
}


public class EffectBlood : EffectRecycle
{
	public GameObjectRef ReplacementEffect;
}


using System.Collections.Generic;
using Rust;
using UnityEngine;

public class EffectDictionary
{
	private static Dictionary<string, string[]> effectDictionary;

	public static string GetParticle(string impactType, string materialName)
	{
		return LookupEffect("impacts", impactType, materialName);
	}

	public static string GetParticle(DamageType damageType, string materialName)
	{
		return damageType switch
		{
			DamageType.Bullet => GetParticle("bullet", materialName), 
			DamageType.Arrow => GetParticle("bullet", materialName), 
			DamageType.Blunt => GetParticle("blunt", materialName), 
			DamageType.Slash => GetParticle("slash", materialName), 
			DamageType.Stab => GetParticle("stab", materialName), 
			_ => GetParticle("blunt", materialName), 
		};
	}

	public static string GetDecal(string impactType, string materialName)
	{
		return LookupEffect("decals", impactType, materialName);
	}

	public static string GetDecal(DamageType damageType, string materialName)
	{
		return damageType switch
		{
			DamageType.Bullet => GetDecal("bullet", materialName), 
			DamageType.Arrow => GetDecal("bullet", materialName), 
			DamageType.Blunt => GetDecal("blunt", materialName), 
			DamageType.Slash => GetDecal("slash", materialName), 
			DamageType.Stab => GetDecal("stab", materialName), 
			_ => GetDecal("blunt", materialName), 
		};
	}

	public static string GetDisplacement(string impactType, string materialName)
	{
		return LookupEffect("displacement", impactType, materialName);
	}

	private static string LookupEffect(string category, string effect, string material)
	{
		if (effectDictionary == null)
		{
			effectDictionary = GameManifest.LoadEffectDictionary();
		}
		string format = "assets/bundled/prefabs/fx/{0}/{1}/{2}";
		if (!effectDictionary.TryGetValue(StringFormatCache.Get(format, category, effect, material), out var value) && !effectDictionary.TryGetValue(StringFormatCache.Get(format, category, effect, "generic"), out value))
		{
			return string.Empty;
		}
		return value[Random.Range(0, value.Length)];
	}
}


using UnityEngine;
using UnityEngine.Serialization;

public class EffectRecycle : BaseMonoBehaviour, IClientComponent, IRagdollInhert, IEffectRecycle
{
	public enum PlayMode
	{
		Once,
		Looped
	}

	public enum ParentDestroyBehaviour
	{
		Detach,
		Destroy,
		DetachWaitDestroy
	}

	[FormerlySerializedAs("lifeTime")]
	[ReadOnly]
	public float detachTime;

	[FormerlySerializedAs("lifeTime")]
	[ReadOnly]
	public float recycleTime;

	public PlayMode playMode;

	public ParentDestroyBehaviour onParentDestroyed;

	[Range(1f, 50f)]
	public int WarmedUpAmount = 1;
}


public enum PlayMode
{
	Once,
	Looped
}


public enum ParentDestroyBehaviour
{
	Detach,
	Destroy,
	DetachWaitDestroy
}


public class EffectRecycleDetach : BaseMonoBehaviour, IClientComponent, IEffectRecycle
{
	public float recycleTime = 1f;
}


public class EffectRecycleLite : BasePrefab, IClientComponent, IEffectRecycle
{
	private const float lifeTime = 60f;
}


using UnityEngine;

public class EffectSilencerSelect : MonoBehaviour
{
	public GameObjectRef MilitaryEffect;

	public GameObjectRef OilFilterEffect;

	public GameObjectRef SodaCanEffect;

	public bool GetEffectForSilencerType(ProjectileWeaponMod.SilencerType silencerType, out GameObjectRef result)
	{
		result = null;
		switch (silencerType)
		{
		case ProjectileWeaponMod.SilencerType.Military:
			result = MilitaryEffect;
			break;
		case ProjectileWeaponMod.SilencerType.OilFilter:
			result = OilFilterEffect;
			break;
		case ProjectileWeaponMod.SilencerType.SodaCan:
			result = SodaCanEffect;
			break;
		}
		if (result != null)
		{
			return result.isValid;
		}
		return false;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class EnvironmentManager : SingletonComponent<EnvironmentManager>
{
	public static EnvironmentType Get(OBB obb)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		EnvironmentType environmentType = (EnvironmentType)0;
		List<EnvironmentVolume> list = Pool.Get<List<EnvironmentVolume>>();
		GamePhysics.OverlapOBB<EnvironmentVolume>(obb, list, 262144, (QueryTriggerInteraction)2);
		for (int i = 0; i < list.Count; i++)
		{
			environmentType |= list[i].Type;
		}
		Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
		return environmentType;
	}

	public static EnvironmentType Get(Vector3 pos, ref List<EnvironmentVolume> list, float radius = 0.01f)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		EnvironmentType environmentType = (EnvironmentType)0;
		GamePhysics.OverlapSphere<EnvironmentVolume>(pos, radius, list, 262144, (QueryTriggerInteraction)2);
		for (int i = 0; i < list.Count; i++)
		{
			environmentType |= list[i].Type;
		}
		return environmentType;
	}

	public static EnvironmentType Get(Vector3 pos, float radius = 0.01f)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<EnvironmentVolume> list = Pool.Get<List<EnvironmentVolume>>();
		EnvironmentType result = Get(pos, ref list, radius);
		Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
		return result;
	}

	public static bool Check(OBB obb, EnvironmentType type)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return (Get(obb) & type) != 0;
	}

	public static bool Check(Vector3 pos, EnvironmentType type, float radius = 0.01f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return (Get(pos, radius) & type) != 0;
	}
}


using System;

[Flags]
public enum EnvironmentType
{
	Underground = 1,
	Building = 2,
	Outdoor = 4,
	Elevator = 8,
	PlayerConstruction = 0x10,
	TrainTunnels = 0x20,
	UnderwaterLab = 0x40,
	Submarine = 0x80,
	BuildingDark = 0x100,
	BuildingVeryDark = 0x200,
	NoSunlight = 0x400,
	SpatiallyAware = 0x800,
	Entrance = 0x1000
}


using System;

[Flags]
public enum NetworkGroupType
{
	Cave = 1,
	TrainTunnels = 2,
	Canyon = 4
}


using UnityEngine;

[ExecuteInEditMode]
public class EnvironmentVolume : MonoBehaviour, IPrefabPreProcess
{
	public enum VolumeShape
	{
		Cube,
		Sphere,
		Capsule
	}

	private static readonly Vector3[] volumeCorners = (Vector3[])(object)new Vector3[8]
	{
		new Vector3(-0.5f, -0.5f, -0.5f),
		new Vector3(0.5f, -0.5f, -0.5f),
		new Vector3(0.5f, 0.5f, -0.5f),
		new Vector3(-0.5f, 0.5f, -0.5f),
		new Vector3(-0.5f, -0.5f, 0.5f),
		new Vector3(0.5f, -0.5f, 0.5f),
		new Vector3(0.5f, 0.5f, 0.5f),
		new Vector3(-0.5f, 0.5f, 0.5f)
	};

	[InspectorFlags]
	public EnvironmentType Type = EnvironmentType.Underground;

	[InspectorFlags]
	public NetworkGroupType NetworkType;

	public Vector3 Center = Vector3.zero;

	public Vector3 Size = Vector3.one;

	[field: Tooltip("Controls the falloff amount of the positive axes of spatially aware volumes.")]
	[field: SerializeField]
	public Vector3 FalloffPositive { get; private set; } = Vector3.zero;

	[field: Tooltip("Controls the falloff amount of the negative axes of spatially aware volumes.")]
	[field: SerializeField]
	public Vector3 FalloffNegative { get; private set; } = Vector3.zero;

	[field: SerializeField]
	public VolumeShape SpatialVolumeShape { get; private set; }

	public Matrix4x4 VolumeTransformation { get; private set; }

	public Matrix4x4 VolumeTransformationInverse { get; private set; }

	public Vector3 VolumePosition { get; private set; }

	public Bounds VolumeBounds { get; private set; }

	public float AmbientMultiplier { get; private set; }

	public float ReflectionMultiplier { get; private set; }

	public float CombinedMultiplier { get; private set; }

	public bool NoSunlight { get; private set; }

	public bool PropertiesCached { get; private set; }

	public Collider trigger { get; private set; }

	public bool IsSpatialVolume => (Type & EnvironmentType.SpatiallyAware) != 0;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	private void OnValidate()
	{
		PropertiesCached = false;
		UpdateVolumeTransformationAndBounds();
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (clientside && IsSpatialVolume && !((Object)(object)((Component)this).gameObject == (Object)null) && (Object)(object)((Component)this).GetComponent<EnvironmentVolumeLOD>() == (Object)null)
		{
			((Component)this).gameObject.AddComponent<EnvironmentVolumeLOD>();
		}
	}

	protected void Awake()
	{
		UpdateTrigger();
	}

	protected void OnEnable()
	{
		if (Object.op_Implicit((Object)(object)trigger) && !trigger.enabled)
		{
			trigger.enabled = true;
		}
		NetworkVisibilityGrid.RegisterEnvironmentVolume(this);
		UpdateVolumeTransformationAndBounds();
	}

	protected void OnDisable()
	{
		if (Object.op_Implicit((Object)(object)trigger) && trigger.enabled)
		{
			trigger.enabled = false;
		}
	}

	private Bounds CalculateTransformationBounds(Matrix4x4 transformationMatrix)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.positiveInfinity;
		Vector3 val2 = Vector3.negativeInfinity;
		for (int i = 0; i < volumeCorners.Length; i++)
		{
			Vector3 val3 = ((Matrix4x4)(ref transformationMatrix)).MultiplyPoint3x4(volumeCorners[i]);
			val = Vector3.Min(val, val3);
			val2 = Vector3.Max(val2, val3);
		}
		if (IsSpatialVolume && SpatialVolumeShape == VolumeShape.Capsule)
		{
			float num = Mathf.Abs(val2.y - val.y) * 0.5f;
			val.y -= num;
			val2.y += num;
		}
		Bounds result = default(Bounds);
		((Bounds)(ref result))..ctor(Vector3.zero, Vector3.one);
		((Bounds)(ref result)).SetMinMax(val, val2);
		return result;
	}

	public void UpdateVolumeTransformationAndBounds()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Size + new Vector3(0.001f, 0.001f, 0.001f);
		VolumeTransformation = ((Component)this).transform.localToWorldMatrix * Matrix4x4.Translate(Center) * Matrix4x4.Scale(val);
		Matrix4x4 volumeTransformation = VolumeTransformation;
		VolumeTransformationInverse = ((Matrix4x4)(ref volumeTransformation)).inverse;
		volumeTransformation = VolumeTransformation;
		VolumePosition = ((Matrix4x4)(ref volumeTransformation)).GetPosition();
		VolumeBounds = CalculateTransformationBounds(VolumeTransformation);
	}

	public void CacheVolumeProperties(EnvironmentVolumePropertiesCollection properties)
	{
		if (!PropertiesCached)
		{
			PropertiesCached = true;
			NoSunlight = (Type & EnvironmentType.NoSunlight) != 0 || (Type & EnvironmentType.TrainTunnels) != 0;
			CombinedMultiplier = AmbientMultiplier * ReflectionMultiplier;
		}
	}

	public void UpdateTrigger()
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)trigger))
		{
			trigger = ((Component)this).gameObject.GetComponent<Collider>();
		}
		if (!Object.op_Implicit((Object)(object)trigger))
		{
			trigger = (Collider)(object)((Component)this).gameObject.AddComponent<BoxCollider>();
		}
		trigger.isTrigger = true;
		Collider obj = trigger;
		BoxCollider val = (BoxCollider)(object)((obj is BoxCollider) ? obj : null);
		if (Object.op_Implicit((Object)(object)val))
		{
			val.center = Center;
			val.size = Size;
		}
	}
}


public enum VolumeShape
{
	Cube,
	Sphere,
	Capsule
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class EnvironmentVolumeEx
{
	public static bool CheckEnvironmentVolumes(this Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		List<EnvironmentVolume> list = Pool.Get<List<EnvironmentVolume>>();
		((Component)transform).GetComponentsInChildren<EnvironmentVolume>(true, list);
		OBB obb = default(OBB);
		for (int i = 0; i < list.Count; i++)
		{
			EnvironmentVolume environmentVolume = list[i];
			((OBB)(ref obb))..ctor(((Component)environmentVolume).transform, new Bounds(environmentVolume.Center, environmentVolume.Size));
			((OBB)(ref obb)).Transform(pos, scale, rot);
			if (EnvironmentManager.Check(obb, type))
			{
				Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
				return true;
			}
		}
		Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
		return false;
	}

	public static bool CheckEnvironmentVolumes(this Transform transform, EnvironmentType type)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return transform.CheckEnvironmentVolumes(transform.position, transform.rotation, transform.lossyScale, type);
	}

	public static bool CheckEnvironmentVolumesInsideTerrain(this Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType typeRequire, EnvironmentType typeIgnore, float padding = 0f)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.HeightMap == (Object)null)
		{
			return true;
		}
		List<EnvironmentVolume> list = Pool.Get<List<EnvironmentVolume>>();
		((Component)transform).GetComponentsInChildren<EnvironmentVolume>(true, list);
		if (list.Count == 0)
		{
			Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
			return true;
		}
		OBB val = default(OBB);
		for (int i = 0; i < list.Count; i++)
		{
			EnvironmentVolume environmentVolume = list[i];
			if ((environmentVolume.Type & typeRequire) == 0 || (environmentVolume.Type & typeIgnore) != 0)
			{
				continue;
			}
			((OBB)(ref val))..ctor(((Component)environmentVolume).transform, new Bounds(environmentVolume.Center, environmentVolume.Size));
			((OBB)(ref val)).Transform(pos, scale, rot);
			Vector3 point = ((OBB)(ref val)).GetPoint(-1f, 0f, -1f);
			Vector3 point2 = ((OBB)(ref val)).GetPoint(1f, 0f, -1f);
			Vector3 point3 = ((OBB)(ref val)).GetPoint(-1f, 0f, 1f);
			Vector3 point4 = ((OBB)(ref val)).GetPoint(1f, 0f, 1f);
			Bounds val2 = ((OBB)(ref val)).ToBounds();
			float max = ((Bounds)(ref val2)).max.y + padding;
			bool fail = false;
			TerrainMeta.HeightMap.ForEachParallel(point, point2, point3, point4, delegate(int x, int z)
			{
				if (TerrainMeta.HeightMap.GetHeight(x, z) <= max)
				{
					fail = true;
				}
			});
			if (fail)
			{
				Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
				return false;
			}
		}
		Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
		return true;
	}

	public static bool CheckEnvironmentVolumesInsideTerrain(this Transform transform, EnvironmentType typeRequire, EnvironmentType typeIgnore)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return transform.CheckEnvironmentVolumesInsideTerrain(transform.position, transform.rotation, transform.lossyScale, typeRequire, typeIgnore);
	}

	public static bool CheckEnvironmentVolumesOutsideTerrain(this Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType typeRequire, EnvironmentType typeIgnore, float padding = 0f)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.HeightMap == (Object)null)
		{
			return true;
		}
		List<EnvironmentVolume> list = Pool.Get<List<EnvironmentVolume>>();
		((Component)transform).GetComponentsInChildren<EnvironmentVolume>(true, list);
		if (list.Count == 0)
		{
			Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
			return true;
		}
		OBB val = default(OBB);
		for (int i = 0; i < list.Count; i++)
		{
			EnvironmentVolume environmentVolume = list[i];
			if ((environmentVolume.Type & typeRequire) == 0 || (environmentVolume.Type & typeIgnore) != 0)
			{
				continue;
			}
			((OBB)(ref val))..ctor(((Component)environmentVolume).transform, new Bounds(environmentVolume.Center, environmentVolume.Size));
			((OBB)(ref val)).Transform(pos, scale, rot);
			Vector3 point = ((OBB)(ref val)).GetPoint(-1f, 0f, -1f);
			Vector3 point2 = ((OBB)(ref val)).GetPoint(1f, 0f, -1f);
			Vector3 point3 = ((OBB)(ref val)).GetPoint(-1f, 0f, 1f);
			Vector3 point4 = ((OBB)(ref val)).GetPoint(1f, 0f, 1f);
			Bounds val2 = ((OBB)(ref val)).ToBounds();
			float min = ((Bounds)(ref val2)).min.y - padding;
			bool fail = false;
			TerrainMeta.HeightMap.ForEachParallel(point, point2, point3, point4, delegate(int x, int z)
			{
				if (TerrainMeta.HeightMap.GetHeight(x, z) >= min)
				{
					fail = true;
				}
			});
			if (fail)
			{
				Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
				return false;
			}
		}
		Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
		return true;
	}

	public static bool CheckEnvironmentVolumesOutsideTerrain(this Transform transform, EnvironmentType typeRequire, EnvironmentType typeIgnore)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return transform.CheckEnvironmentVolumesOutsideTerrain(transform.position, transform.rotation, transform.lossyScale, typeRequire, typeIgnore);
	}

	public static bool CheckEnvironmentVolumesAboveAltitude(this Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType typeRequire, EnvironmentType typeIgnore, float altitude = 0f)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		List<EnvironmentVolume> list = Pool.GetList<EnvironmentVolume>();
		((Component)transform).GetComponentsInChildren<EnvironmentVolume>(true, list);
		if (list.Count == 0)
		{
			Pool.FreeList<EnvironmentVolume>(ref list);
			return true;
		}
		OBB val = default(OBB);
		for (int i = 0; i < list.Count; i++)
		{
			EnvironmentVolume environmentVolume = list[i];
			if ((environmentVolume.Type & typeRequire) != 0 && (environmentVolume.Type & typeIgnore) == 0)
			{
				((OBB)(ref val))..ctor(((Component)environmentVolume).transform, new Bounds(environmentVolume.Center, environmentVolume.Size));
				((OBB)(ref val)).Transform(pos, scale, rot);
				Bounds val2 = ((OBB)(ref val)).ToBounds();
				if (((Bounds)(ref val2)).min.y <= altitude)
				{
					Pool.FreeList<EnvironmentVolume>(ref list);
					return false;
				}
			}
		}
		Pool.FreeList<EnvironmentVolume>(ref list);
		return true;
	}

	public static bool CheckEnvironmentVolumesAboveAltitude(this Transform transform, EnvironmentType typeRequire, EnvironmentType typeIgnore)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return transform.CheckEnvironmentVolumesAboveAltitude(transform.position, transform.rotation, transform.lossyScale, typeRequire, typeIgnore);
	}

	public static bool CheckEnvironmentVolumesBelowAltitude(this Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType typeRequire, EnvironmentType typeIgnore, float altitude = 0f)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		List<EnvironmentVolume> list = Pool.GetList<EnvironmentVolume>();
		((Component)transform).GetComponentsInChildren<EnvironmentVolume>(true, list);
		if (list.Count == 0)
		{
			Pool.FreeList<EnvironmentVolume>(ref list);
			return true;
		}
		OBB val = default(OBB);
		for (int i = 0; i < list.Count; i++)
		{
			EnvironmentVolume environmentVolume = list[i];
			if ((environmentVolume.Type & typeRequire) != 0 && (environmentVolume.Type & typeIgnore) == 0)
			{
				((OBB)(ref val))..ctor(((Component)environmentVolume).transform, new Bounds(environmentVolume.Center, environmentVolume.Size));
				((OBB)(ref val)).Transform(pos, scale, rot);
				Bounds val2 = ((OBB)(ref val)).ToBounds();
				if (((Bounds)(ref val2)).max.y >= altitude)
				{
					Pool.FreeList<EnvironmentVolume>(ref list);
					return false;
				}
			}
		}
		Pool.FreeList<EnvironmentVolume>(ref list);
		return true;
	}

	public static bool CheckEnvironmentVolumesBelowAltitude(this Transform transform, EnvironmentType typeRequire, EnvironmentType typeIgnore)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return transform.CheckEnvironmentVolumesBelowAltitude(transform.position, transform.rotation, transform.lossyScale, typeRequire, typeIgnore);
	}
}


using UnityEngine;

public class EnvironmentVolumeTrigger : MonoBehaviour
{
	[HideInInspector]
	public Vector3 Center = Vector3.zero;

	[HideInInspector]
	public Vector3 Size = Vector3.one;

	public EnvironmentVolume volume { get; private set; }

	public void Awake()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		volume = ((Component)this).gameObject.GetComponent<EnvironmentVolume>();
		if ((Object)(object)volume == (Object)null)
		{
			volume = ((Component)this).gameObject.AddComponent<EnvironmentVolume>();
			volume.Center = Center;
			volume.Size = Size;
		}
		volume.UpdateTrigger();
		OnVolumeTriggerUpdate();
	}

	protected virtual void OnVolumeTriggerUpdate()
	{
	}
}


using UnityEngine;

[ExecuteAlways]
public class FakePhysicsRope : FacepunchBehaviour, IClientComponent
{
	public enum RenderMode
	{
		LineRenderer2D,
		TubeRenderer3D,
		Both
	}

	[Header("References")]
	public Transform startPoint;

	public Transform endPoint;

	public Transform leadPoint;

	public Vector3 endPointOffset;

	[Header("Settings")]
	[Range(2f, 100f)]
	public int linePoints = 10;

	[Tooltip("Value highly dependent on use case, a metal cable would have high stiffness, a rubber rope would have a low one")]
	public float stiffness = 350f;

	[Tooltip("0 is no damping, 50 is a lot")]
	public float damping = 15f;

	[Tooltip("How long is the rope. It will hang more or less from starting point to end point depending on this value")]
	public float ropeLength = 15f;

	[Tooltip("The Rope width set at start (changing this value during run time will produce no effect)")]
	public float ropeWidth = 0.1f;

	[Tooltip("Adjust the middle control point weight for the Rational Bezier curve")]
	[Range(1f, 15f)]
	public float midPointWeight = 1f;

	[Tooltip("Use local positions instead of world positions (relative to this object)")]
	public bool useLocalPositions;

	[Header("Rendering")]
	public RenderMode renderMode;

	[Header("Wind")]
	public bool AddFakeWind;

	public float windFrequency;

	public float windAmplitude;

	protected Vector3 EndPointPosition => endPoint.position + endPointOffset;

	public static Vector3 GetRationalBezierPoint(Vector3 p0, Vector3 p1, Vector3 p2, float t, float w0 = 1f, float w1 = 1f, float w2 = 1f)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = w0 * p0;
		Vector3 val2 = w1 * p1;
		Vector3 val3 = w2 * p2;
		float num = w0 * Mathf.Pow(1f - t, 2f) + 2f * w1 * (1f - t) * t + w2 * Mathf.Pow(t, 2f);
		return (val * Mathf.Pow(1f - t, 2f) + val2 * 2f * (1f - t) * t + val3 * Mathf.Pow(t, 2f)) / num;
	}
}


public enum RenderMode
{
	LineRenderer2D,
	TubeRenderer3D,
	Both
}


using UnityEngine;
using UnityEngine.Rendering;

[ExecuteAlways]
public class FoliageGrid : SingletonComponent<FoliageGrid>, IClientComponent
{
	private const int GRID_POOL_SIZE = 48;

	private const float FOLIAGE_CULL_RADIUS = 2f;

	private const int COMPUTE_CELL_DIM = 8;

	private const int COMPUTE_TILE_DIM = 5;

	private const int COMPUTE_TILE_HALF = 2;

	private const int COMPUTE_CELL_COUNT = 64;

	private const int GRID_OFFSET = 65536;

	public static bool Paused;

	public static bool RefreshDisabled;

	public GameObjectRef BatchPrefab;

	public float CellSize = 50f;

	private const int InstanceCellSize = 16;

	[SerializeField]
	private ComputeShader foliageCompute;

	public LayerSelect FoliageLayer = 0;

	public ShadowCastingMode FoliageShadows;

	public void OnGlobalTextureMipmapLimitChange()
	{
	}
}


using System;
using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(menuName = "Rust/Foliage Placement")]
public class FoliagePlacement : ScriptableObject
{
	public struct PlacementMeshInfo
	{
		public int placementIdx;

		public int matIdx;

		public int masterIdx;

		public int subMeshIdx;

		public int subFoliageIdx;

		public PlacementMeshInfo(int placementIdx, int matIdx, int masterIdx, int subMeshIdx, int subFoliageIdx)
		{
			this.placementIdx = placementIdx;
			this.matIdx = matIdx;
			this.masterIdx = masterIdx;
			this.subMeshIdx = subMeshIdx;
			this.subFoliageIdx = subFoliageIdx;
		}
	}

	[Header("Placement")]
	public float Density = 2f;

	public float HeightOffset;

	[Header("Filter")]
	public SpawnFilter Filter;

	[FormerlySerializedAs("Cutoff")]
	public float FilterCutoff = 0.5f;

	public float FilterFade = 0.1f;

	[FormerlySerializedAs("Scaling")]
	public float FilterScaling = 1f;

	[Header("Randomization")]
	public float RandomScaling = 0.2f;

	[Header("Placement Range")]
	[MinMax(0f, 1f)]
	public MinMax Range = new MinMax(0f, 1f);

	public float RangeFade = 0.1f;

	[Range(0f, 1f)]
	[Header("LOD")]
	public float DistanceDensity;

	[Range(1f, 2f)]
	public float DistanceScaling = 2f;

	[Header("Visuals")]
	public Material material;

	[FormerlySerializedAs("mesh")]
	public Mesh mesh0;

	[FormerlySerializedAs("mesh")]
	public Mesh mesh1;

	[FormerlySerializedAs("mesh")]
	public Mesh mesh2;

	public const int lods = 5;

	public const int octaves = 1;

	public const float frequency = 0.05f;

	public const float amplitude = 0.5f;

	public const float offset = 0.5f;

	[NonSerialized]
	public uint baseSeed;

	[NonSerialized]
	public int count;

	[NonSerialized]
	public int mergeID;

	[NonSerialized]
	public int vertexOffset;

	public PlacementMeshInfo info;
}


public struct PlacementMeshInfo
{
	public int placementIdx;

	public int matIdx;

	public int masterIdx;

	public int subMeshIdx;

	public int subFoliageIdx;

	public PlacementMeshInfo(int placementIdx, int matIdx, int masterIdx, int subMeshIdx, int subFoliageIdx)
	{
		this.placementIdx = placementIdx;
		this.matIdx = matIdx;
		this.masterIdx = masterIdx;
		this.subMeshIdx = subMeshIdx;
		this.subFoliageIdx = subFoliageIdx;
	}
}


using UnityEngine;

public class FoliageRenderer : MonoBehaviour, IClientComponent
{
	public Material material;

	public Mesh LOD0;

	public Mesh LOD1;
}


using UnityEngine;

public class FoliageSpawn : MonoBehaviour, IClientComponent
{
	public FoliagePlacement Placement;
}


using System;
using ConVar;
using Facepunch;
using Rust;
using UnityEngine;
using UnityEngine.SceneManagement;

public class GameManager
{
	public static GameManager server = new GameManager(clientside: false, serverside: true);

	public PrefabPreProcess preProcessed;

	public PrefabPoolCollection pool;

	public bool Clientside;

	public bool Serverside;

	public void Reset()
	{
		pool.Clear();
	}

	public GameManager(bool clientside, bool serverside)
	{
		Clientside = clientside;
		Serverside = serverside;
		preProcessed = new PrefabPreProcess(clientside, serverside);
		pool = new PrefabPoolCollection(clientside);
	}

	public GameObject FindPrefab(uint prefabID)
	{
		string text = StringPool.Get(prefabID);
		if (string.IsNullOrEmpty(text))
		{
			return null;
		}
		return FindPrefab(text);
	}

	public GameObject FindPrefab(BaseEntity ent)
	{
		if ((Object)(object)ent == (Object)null)
		{
			return null;
		}
		return FindPrefab(ent.PrefabName);
	}

	public GameObject FindPrefab(string strPrefab)
	{
		GameObject val = preProcessed.Find(strPrefab);
		if ((Object)(object)val != (Object)null)
		{
			return val;
		}
		val = FileSystem.LoadPrefab(strPrefab);
		if ((Object)(object)val == (Object)null)
		{
			return null;
		}
		try
		{
			preProcessed.Process(strPrefab, val);
		}
		catch
		{
			Debug.LogError((object)("Failed to preprocess prefab: " + strPrefab));
			throw;
		}
		GameObject val2 = preProcessed.Find(strPrefab);
		if (!((Object)(object)val2 != (Object)null))
		{
			return val;
		}
		return val2;
	}

	public GameObject CreatePrefab(string strPrefab, Vector3 pos, Quaternion rot, Vector3 scale, bool active = true)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		GameObject val = Instantiate(strPrefab, pos, rot);
		if (Object.op_Implicit((Object)(object)val))
		{
			val.transform.localScale = scale;
			if (active)
			{
				val.AwakeFromInstantiate();
			}
		}
		return val;
	}

	public GameObject CreatePrefab(string strPrefab, Vector3 pos, Quaternion rot, bool active = true)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		GameObject val = Instantiate(strPrefab, pos, rot);
		if (Object.op_Implicit((Object)(object)val) && active)
		{
			val.AwakeFromInstantiate();
		}
		return val;
	}

	public GameObject CreatePrefab(string strPrefab, bool active = true)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		GameObject val = Instantiate(strPrefab, Vector3.zero, Quaternion.identity);
		if (Object.op_Implicit((Object)(object)val) && active)
		{
			val.AwakeFromInstantiate();
		}
		return val;
	}

	public GameObject CreatePrefab(string strPrefab, Transform parent, bool active = true, bool resetScale = true)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		GameObject val = Instantiate(strPrefab, parent.position, parent.rotation);
		if (Object.op_Implicit((Object)(object)val))
		{
			val.transform.SetParent(parent, false);
			val.Identity(resetScale);
			if (active)
			{
				val.AwakeFromInstantiate();
			}
		}
		return val;
	}

	public BaseEntity CreateEntity(string strPrefab, Vector3 pos = default(Vector3), Quaternion rot = default(Quaternion), bool startActive = true)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		if (string.IsNullOrEmpty(strPrefab))
		{
			return null;
		}
		GameObject val = CreatePrefab(strPrefab, pos, rot, startActive);
		if ((Object)(object)val == (Object)null)
		{
			return null;
		}
		BaseEntity component = val.GetComponent<BaseEntity>();
		if ((Object)(object)component == (Object)null)
		{
			Debug.LogError((object)("CreateEntity called on a prefab that isn't an entity! " + strPrefab));
			Object.Destroy((Object)(object)val);
			return null;
		}
		if (((Component)component).CompareTag("CannotBeCreated"))
		{
			Debug.LogWarning((object)("CreateEntity called on a prefab that has the CannotBeCreated tag set. " + strPrefab));
			Object.Destroy((Object)(object)val);
			return null;
		}
		return component;
	}

	private GameObject Instantiate(string strPrefab, Vector3 pos, Quaternion rot)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		if (!StringEx.IsLower(strPrefab))
		{
			Debug.LogWarning((object)("Converting prefab name to lowercase: " + strPrefab));
			strPrefab = strPrefab.ToLower();
		}
		GameObject val = FindPrefab(strPrefab);
		if (!Object.op_Implicit((Object)(object)val))
		{
			Debug.LogError((object)("Couldn't find prefab \"" + strPrefab + "\""));
			return null;
		}
		GameObject val2 = pool.Pop(StringPool.Get(strPrefab), pos, rot);
		if ((Object)(object)val2 == (Object)null)
		{
			val2 = Instantiate.GameObject(val, pos, rot);
			((Object)val2).name = strPrefab;
		}
		else
		{
			val2.transform.localScale = val.transform.localScale;
		}
		if (!Clientside && Serverside && (Object)(object)val2.transform.parent == (Object)null && Application.isPlaying)
		{
			Scene entityScene = Rust.Server.EntityScene;
			if (!((Scene)(ref entityScene)).IsValid() || !((Scene)(ref entityScene)).isLoaded)
			{
				Destroy(val2);
				return null;
			}
			SceneManager.MoveGameObjectToScene(val2, entityScene);
		}
		return val2;
	}

	public static void Destroy(Component component, float delay = 0f)
	{
		if ((component as BaseEntity).IsValid())
		{
			Debug.LogError((object)("Trying to destroy an entity without killing it first: " + ((Object)component).name));
		}
		Object.Destroy((Object)(object)component, delay);
	}

	public static void Destroy(GameObject instance, float delay = 0f)
	{
		if (Object.op_Implicit((Object)(object)instance))
		{
			if (instance.GetComponent<BaseEntity>().IsValid())
			{
				Debug.LogError((object)("Trying to destroy an entity without killing it first: " + ((Object)instance).name));
			}
			Object.Destroy((Object)(object)instance, delay);
		}
	}

	public static void DestroyImmediate(Component component, bool allowDestroyingAssets = false)
	{
		if ((component as BaseEntity).IsValid())
		{
			Debug.LogError((object)("Trying to destroy an entity without killing it first: " + ((Object)component).name));
		}
		Object.DestroyImmediate((Object)(object)component, allowDestroyingAssets);
	}

	public static void DestroyImmediate(GameObject instance, bool allowDestroyingAssets = false)
	{
		if (instance.GetComponent<BaseEntity>().IsValid())
		{
			Debug.LogError((object)("Trying to destroy an entity without killing it first: " + ((Object)instance).name));
		}
		Object.DestroyImmediate((Object)(object)instance, allowDestroyingAssets);
	}

	public void Retire(GameObject instance)
	{
		if (!Object.op_Implicit((Object)(object)instance))
		{
			return;
		}
		TimeWarning val = TimeWarning.New("GameManager.Retire", 0);
		try
		{
			if (instance.GetComponent<BaseEntity>().IsValid())
			{
				Debug.LogError((object)("Trying to retire an entity without killing it first: " + ((Object)instance).name));
			}
			if (!Application.isUnloadingWorld && LevelManager.isLoaded && Pool.enabled && instance.SupportsPooling())
			{
				pool.Push(instance);
			}
			else
			{
				Object.Destroy((Object)(object)instance);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using UnityEngine;

public class CapturePointTrigger : TriggerBase
{
	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if ((Object)(object)(baseEntity as BasePlayer) == (Object)null)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using System;
using Facepunch;
using ProtoBuf;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class GameModeCapturePoint : BaseEntity
{
	public CapturePointTrigger captureTrigger;

	public float timeToCapture = 3f;

	public int scorePerSecond = 1;

	public string scoreName = "score";

	private float captureFraction;

	private int captureTeam = -1;

	private int capturingTeam = -1;

	public EntityRef capturingPlayer;

	public EntityRef capturedPlayer;

	public const Flags Flag_Contested = Flags.Busy;

	public RustText capturePointText;

	public RustText captureOwnerName;

	public Image captureProgressImage;

	public GameObjectRef progressBeepEffect;

	public GameObjectRef progressCompleteEffect;

	public Transform computerPoint;

	private float nextBeepTime;

	public bool IsContested()
	{
		return HasFlag(Flags.Busy);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)AssignPoints, 0f, 1f);
	}

	public void Update()
	{
		if (!base.isClient)
		{
			UpdateCaptureAmount();
		}
	}

	public void AssignPoints()
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode == (Object)null || !activeGameMode.IsMatchActive())
		{
			return;
		}
		if (activeGameMode.IsTeamGame())
		{
			if (captureTeam != -1 && captureFraction == 1f)
			{
				activeGameMode.ModifyTeamScore(captureTeam, scorePerSecond);
			}
		}
		else if (capturedPlayer.IsValid(serverside: true))
		{
			activeGameMode.ModifyPlayerGameScore(((Component)capturedPlayer.Get(serverside: true)).GetComponent<BasePlayer>(), "score", scorePerSecond);
		}
	}

	public void DoCaptureEffect()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(progressCompleteEffect.resourcePath, computerPoint.position);
	}

	public void DoProgressEffect()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (!(Time.time < nextBeepTime))
		{
			Effect.server.Run(progressBeepEffect.resourcePath, computerPoint.position);
			nextBeepTime = Time.time + 0.5f;
		}
	}

	public void UpdateCaptureAmount()
	{
		if (base.isClient)
		{
			return;
		}
		float num = captureFraction;
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode == (Object)null)
		{
			return;
		}
		if (captureTrigger.entityContents == null)
		{
			SetFlag(Flags.Busy, b: false, recursive: false, networkupdate: false);
		}
		else
		{
			if (!activeGameMode.IsMatchActive())
			{
				return;
			}
			if (activeGameMode.IsTeamGame())
			{
				int[] array = new int[activeGameMode.GetNumTeams()];
				foreach (BaseEntity entityContent in captureTrigger.entityContents)
				{
					if (!((Object)(object)entityContent == (Object)null) && !entityContent.isClient)
					{
						BasePlayer component = ((Component)entityContent).GetComponent<BasePlayer>();
						if (!((Object)(object)component == (Object)null) && component.IsAlive() && !component.IsNpc && component.gamemodeteam != -1)
						{
							array[component.gamemodeteam]++;
						}
					}
				}
				int num2 = 0;
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i] > 0)
					{
						num2++;
					}
				}
				if (num2 < 2)
				{
					int num3 = -1;
					int num4 = 0;
					for (int j = 0; j < array.Length; j++)
					{
						if (array[j] > num4)
						{
							num4 = array[j];
							num3 = j;
						}
					}
					if (captureTeam == -1 && captureFraction == 0f)
					{
						capturingTeam = num3;
					}
					if (captureFraction > 0f && num3 != captureTeam && num3 != capturingTeam)
					{
						captureFraction = Mathf.Clamp01(captureFraction - Time.deltaTime / timeToCapture);
						if (captureFraction == 0f)
						{
							captureTeam = -1;
						}
					}
					else if (captureTeam == -1 && captureFraction < 1f && capturingTeam == num3)
					{
						DoProgressEffect();
						captureFraction = Mathf.Clamp01(captureFraction + Time.deltaTime / timeToCapture);
						if (captureFraction == 1f)
						{
							DoCaptureEffect();
							captureTeam = num3;
						}
					}
				}
				SetFlag(Flags.Busy, num2 > 1);
			}
			else
			{
				if (!capturingPlayer.IsValid(serverside: true) && !capturedPlayer.IsValid(serverside: true))
				{
					captureFraction = 0f;
				}
				if (captureTrigger.entityContents.Count == 0)
				{
					capturingPlayer.Set(null);
				}
				if (captureTrigger.entityContents.Count == 1)
				{
					foreach (BaseEntity entityContent2 in captureTrigger.entityContents)
					{
						BasePlayer component2 = ((Component)entityContent2).GetComponent<BasePlayer>();
						if ((Object)(object)component2 == (Object)null)
						{
							continue;
						}
						if (!capturedPlayer.IsValid(serverside: true) && captureFraction == 0f)
						{
							capturingPlayer.Set(component2);
						}
						if (captureFraction > 0f && (Object)(object)component2 != (Object)(object)capturedPlayer.Get(serverside: true) && (Object)(object)component2 != (Object)(object)capturingPlayer.Get(serverside: true))
						{
							captureFraction = Mathf.Clamp01(captureFraction - Time.deltaTime / timeToCapture);
							if (captureFraction == 0f)
							{
								capturedPlayer.Set(null);
							}
						}
						else if (!Object.op_Implicit((Object)(object)capturedPlayer.Get(serverside: true)) && captureFraction < 1f && (Object)(object)capturingPlayer.Get(serverside: true) == (Object)(object)component2)
						{
							DoProgressEffect();
							captureFraction = Mathf.Clamp01(captureFraction + Time.deltaTime / timeToCapture);
							if (captureFraction == 1f)
							{
								DoCaptureEffect();
								capturedPlayer.Set(component2);
							}
						}
						break;
					}
				}
				SetFlag(Flags.Busy, captureTrigger.entityContents.Count > 1);
			}
			if (num != captureFraction)
			{
				SendNetworkUpdate();
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.ioEntity = Pool.Get<IOEntity>();
		info.msg.ioEntity.genericFloat1 = captureFraction;
		info.msg.ioEntity.genericInt1 = captureTeam;
		info.msg.ioEntity.genericInt2 = capturingTeam;
		info.msg.ioEntity.genericEntRef1 = capturedPlayer.uid;
		info.msg.ioEntity.genericEntRef2 = capturingPlayer.uid;
	}
}


using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Game Mode Manifest")]
public class GameModeManifest : ScriptableObject
{
	public static GameModeManifest instance;

	public List<GameObjectRef> gameModePrefabs;

	public static GameModeManifest Get()
	{
		if ((Object)(object)instance == (Object)null)
		{
			instance = Resources.Load<GameModeManifest>("GameModeManifest");
		}
		return instance;
	}
}


using System.Linq;
using UnityEngine;

public class GameModeObjectToggle : BaseMonoBehaviour
{
	public string[] gameModeTags;

	public string[] tagsToDisable;

	public GameObject[] toToggle;

	public bool defaultState;

	public void Awake()
	{
		SetToggle(defaultState);
		BaseGameMode.GameModeChanged += OnGameModeChanged;
	}

	public void OnDestroy()
	{
		BaseGameMode.GameModeChanged -= OnGameModeChanged;
	}

	public void OnGameModeChanged(BaseGameMode newGameMode)
	{
		bool toggle = ShouldBeVisible(newGameMode);
		SetToggle(toggle);
	}

	public void SetToggle(bool wantsOn)
	{
		GameObject[] array = toToggle;
		foreach (GameObject val in array)
		{
			if ((Object)(object)val != (Object)null)
			{
				val.SetActive(wantsOn);
			}
		}
	}

	public bool ShouldBeVisible(BaseGameMode newGameMode)
	{
		if ((Object)(object)newGameMode == (Object)null)
		{
			return defaultState;
		}
		if (tagsToDisable.Length != 0 && (newGameMode.HasAnyGameModeTag(tagsToDisable) || tagsToDisable.Contains("*")))
		{
			return false;
		}
		if (gameModeTags.Length != 0 && (newGameMode.HasAnyGameModeTag(gameModeTags) || gameModeTags.Contains("*")))
		{
			return true;
		}
		return defaultState;
	}
}


public class GameModeVanilla : BaseGameMode
{
}


using System;
using ConVar;

public class GameModeHardcore : GameModeVanilla
{
	protected override void OnCreated()
	{
		base.OnCreated();
	}

	public override void InitShared()
	{
		base.InitShared();
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
	}

	protected override float GetCraftingCostConVar(CraftingCostConVar conVar)
	{
		if (conVar == CraftingCostConVar.HardcoreFirearmAmmunition)
		{
			return Server.hardcoreFirearmAmmunitionCraftingMultiplier;
		}
		return base.GetCraftingCostConVar(conVar);
	}

	public override void ServerInit()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				if (enumerator.Current is Recycler recycler)
				{
					recycler.UpdateInSafeZone();
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}
}


public class EraGameMode : BaseGameMode
{
}


public class PrimitiveGameMode : EraGameMode
{
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/WorldConfig")]
public class ScriptableWorldConfig : ScriptableObject
{
	public string[] GameModes;

	public bool UndergroundTrains = true;

	public bool UnderwaterLabs = true;

	public string[] BlacklistedPrefabs;
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust;
using UnityEngine;

public class GameModeSoftcore : GameModeVanilla
{
	public GameObjectRef reclaimManagerPrefab;

	[ServerVar]
	public static float reclaim_fraction_belt = 0.5f;

	[ServerVar]
	public static float reclaim_fraction_wear = 1f;

	[ServerVar]
	public static float reclaim_fraction_main = 0.5f;

	[ServerVar]
	public static bool reclaim_suicide = false;

	[ServerVar]
	public static bool reclaim_building_auth = false;

	private static string[] StartingItems = new string[5] { "rock", "torch", "cakefiveyear", "partyhat", "snowball" };

	protected override void OnCreated()
	{
		base.OnCreated();
		SingletonComponent<ServerMgr>.Instance.CreateImportantEntity<ReclaimManager>(reclaimManagerPrefab.resourcePath);
	}

	public void ReturnItemsTo(List<Item> source, ItemContainer itemContainer)
	{
		foreach (Item item in source)
		{
			item.MoveToContainer(itemContainer);
		}
	}

	public override void OnPlayerDeath(BasePlayer instigator, BasePlayer victim, HitInfo deathInfo = null)
	{
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)victim != (Object)null && (victim.IsInTutorial || (victim.net != null && victim.net.group != null && victim.net.group.restricted) || (deathInfo != null && deathInfo.damageTypes.GetMajorityDamageType() == DamageType.Suicide && !victim.IsWounded() && !reclaim_suicide)))
		{
			return;
		}
		if ((Object)(object)victim != (Object)null && !victim.IsNpc && !victim.IsInTutorial)
		{
			if (!reclaim_building_auth)
			{
				BuildingPrivlidge buildingPrivilege = victim.GetBuildingPrivilege();
				if ((Object)(object)buildingPrivilege != (Object)null && buildingPrivilege.IsAuthed(victim))
				{
					return;
				}
			}
			SetInventoryLocked(victim, wantsLocked: false);
			if ((Object)(object)ReclaimManager.instance == (Object)null)
			{
				Debug.LogWarning((object)"No reclaim manage for softcore");
				return;
			}
			List<Item> list = Pool.Get<List<Item>>();
			List<Item> list2 = Pool.Get<List<Item>>();
			List<Item> list3 = Pool.Get<List<Item>>();
			List<Item> list4 = Pool.Get<List<Item>>();
			List<Item> list5 = Pool.Get<List<Item>>();
			List<Item> list6 = Pool.Get<List<Item>>();
			List<Item> list7 = Pool.Get<List<Item>>();
			List<Item> list8 = Pool.Get<List<Item>>();
			victim.inventory.containerBelt.RemoveItemsFromContainer(list5, StartingItems);
			victim.inventory.containerMain.RemoveItemsFromContainer(list7, StartingItems);
			victim.inventory.containerWear.RemoveItemsFromContainer(list6, StartingItems);
			victim.inventory.containerBelt.RemoveFractionOfContainer(list, 1f - reclaim_fraction_belt);
			victim.inventory.containerMain.RemoveFractionOfContainer(list3, 1f - reclaim_fraction_main);
			Item backpackWithInventory = victim.inventory.GetBackpackWithInventory();
			if (backpackWithInventory != null)
			{
				backpackWithInventory.contents.RemoveItemsFromContainer(list8, StartingItems);
				backpackWithInventory.contents.RemoveFractionOfContainer(list4, 1f - reclaim_fraction_main);
				if (list4.Count > 0)
				{
					backpackWithInventory.contents.MergeAllStacks();
				}
				ReturnItemsTo(list8, backpackWithInventory.contents);
			}
			victim.inventory.containerWear.RemoveFractionOfContainer(list2, 1f - reclaim_fraction_wear);
			if (list.Count > 0 || list2.Count > 0 || list3.Count > 0)
			{
				ReclaimManager.instance.AddPlayerReclaim(victim.userID, list, list2, list3, list4);
			}
			ReturnItemsTo(list5, victim.inventory.containerBelt);
			ReturnItemsTo(list7, victim.inventory.containerMain);
			ReturnItemsTo(list6, victim.inventory.containerWear);
			if (backpackWithInventory != null && list2.Contains(backpackWithInventory))
			{
				victim.inventory.containerMain.MergeAllStacks();
				backpackWithInventory.contents.MoveAllItems(victim.inventory.containerMain);
				backpackWithInventory.contents.MoveAllItems(victim.inventory.containerBelt);
				if (backpackWithInventory.contents.itemList.Count > 0)
				{
					backpackWithInventory.contents.Drop(ReclaimManager.ReclaimCorpsePrefab, victim.GetDropPosition(), ((Component)victim).transform.rotation, 0f);
				}
			}
			Pool.Free<Item>(ref list, false);
			Pool.Free<Item>(ref list2, false);
			Pool.Free<Item>(ref list3, false);
			Pool.Free<Item>(ref list4, false);
			Pool.Free<Item>(ref list5, false);
			Pool.Free<Item>(ref list6, false);
			Pool.Free<Item>(ref list7, false);
			Pool.Free<Item>(ref list8, false);
		}
		base.OnPlayerDeath(instigator, victim, deathInfo);
	}

	public override void OnPlayerRespawn(BasePlayer player)
	{
		base.OnPlayerRespawn(player);
		ReclaimManager.instance.GetReclaim(player.userID)?.GiveToPlayer(player);
	}

	public override PooledList<SleepingBag> FindSleepingBagsForPlayer(ulong playerID, bool ignoreTimers)
	{
		return SleepingBag.FindForPlayer(playerID, ignoreTimers);
	}

	public override float CorpseRemovalTime(BaseCorpse corpse)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			if ((Object)(object)monument != (Object)null && monument.IsSafeZone && ((Bounds)(ref monument.Bounds)).Contains(((Component)corpse).transform.position))
			{
				return 30f;
			}
		}
		return ConVar.Server.corpsedespawn;
	}

	public void SetInventoryLocked(BasePlayer player, bool wantsLocked)
	{
		player.inventory.containerMain.SetLocked(wantsLocked);
		player.inventory.containerBelt.SetLocked(wantsLocked);
		player.inventory.containerWear.SetLocked(wantsLocked);
	}

	public override void OnPlayerWounded(BasePlayer instigator, BasePlayer victim, HitInfo info)
	{
		base.OnPlayerWounded(instigator, victim, info);
		SetInventoryLocked(victim, wantsLocked: true);
	}

	public override void OnPlayerRevived(BasePlayer instigator, BasePlayer victim)
	{
		if (!victim.IsRestrained)
		{
			SetInventoryLocked(victim, wantsLocked: false);
		}
		base.OnPlayerRevived(instigator, victim);
	}

	public override PlayerInventory.CanMoveFromResponse CanMoveItemsFrom(PlayerInventory inv, BaseEntity source, Item item)
	{
		if (item.parent != null && item.parent.HasFlag(ItemContainer.Flag.IsPlayer))
		{
			return new PlayerInventory.CanMoveFromResponse(!item.parent.IsLocked(), PlayerInventoryErrors.InventoryLockedError);
		}
		return base.CanMoveItemsFrom(inv, source, item);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ReclaimManager : BaseEntity
{
	public class PlayerReclaimEntry : IPooled
	{
		public float timeAlive;

		public int id;

		public ulong victimID;

		public ItemContainer mainInventory;

		public ItemContainer wearInventory;

		public ItemContainer beltInventory;

		public ItemContainer backpackInventory;

		public bool HasItems()
		{
			if ((mainInventory == null || mainInventory.itemList.Count <= 0) && (wearInventory == null || wearInventory.itemList.Count <= 0) && (beltInventory == null || beltInventory.itemList.Count <= 0))
			{
				if (backpackInventory != null)
				{
					return backpackInventory.itemList.Count > 0;
				}
				return false;
			}
			return true;
		}

		private ItemContainer CreateContainer()
		{
			ItemContainer itemContainer = Pool.Get<ItemContainer>();
			itemContainer.entityOwner = instance;
			itemContainer.allowedContents = ItemContainer.ContentsType.Generic;
			itemContainer.SetOnlyAllowedItem(null);
			itemContainer.maxStackSize = 0;
			itemContainer.containerVolume = 10;
			itemContainer.ServerInitialize(null, 40);
			itemContainer.canAcceptItem = null;
			itemContainer.GiveUID();
			return itemContainer;
		}

		void IPooled.LeavePool()
		{
			mainInventory = CreateContainer();
			wearInventory = CreateContainer();
			beltInventory = CreateContainer();
			backpackInventory = CreateContainer();
		}

		void IPooled.EnterPool()
		{
			timeAlive = 0f;
			id = -2;
			Pool.Free<ItemContainer>(ref mainInventory);
			Pool.Free<ItemContainer>(ref wearInventory);
			Pool.Free<ItemContainer>(ref beltInventory);
			Pool.Free<ItemContainer>(ref backpackInventory);
		}

		public void GiveToPlayer(BasePlayer player)
		{
			//IL_0113: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0120: Unknown result type (might be due to invalid IL or missing references)
			wearInventory.MoveAllItems(player.inventory.containerWear);
			beltInventory.MoveAllItems(player.inventory.containerBelt);
			mainInventory.MoveAllItems(player.inventory.containerMain);
			if (backpackInventory.itemList.Count > 0)
			{
				Item backpackWithInventory = player.inventory.GetBackpackWithInventory();
				if (backpackWithInventory != null)
				{
					backpackInventory.MoveAllItems(backpackWithInventory.contents);
				}
				if (backpackInventory.itemList.Count > 0)
				{
					backpackInventory.MoveAllItems(player.inventory.containerMain);
				}
				if (backpackInventory.itemList.Count > 0)
				{
					backpackInventory.MoveAllItems(player.inventory.containerBelt);
				}
			}
			if (wearInventory.itemList.Count + beltInventory.itemList.Count + mainInventory.itemList.Count + backpackInventory.itemList.Count > 0)
			{
				ItemContainer.Drop("assets/prefabs/misc/item drop/item_drop_backpack.prefab", player.GetDropPosition(), default(Quaternion), wearInventory, beltInventory, mainInventory, backpackInventory);
			}
		}
	}

	private const int defaultReclaims = 128;

	private const int reclaimSlotCount = 40;

	public static string ReclaimCorpsePrefab = "assets/prefabs/misc/item drop/item_drop_backpack.prefab";

	private int lastReclaimID;

	[ServerVar]
	public static float reclaim_expire_minutes = 120f;

	private static ReclaimManager _instance;

	private Dictionary<ulong, PlayerReclaimEntry> entries = new Dictionary<ulong, PlayerReclaimEntry>();

	private float lastTickTime;

	public static ReclaimManager instance => _instance;

	public int AddPlayerReclaim(ulong victimID, List<Item> belt, List<Item> wear, List<Item> main, List<Item> backpack)
	{
		PlayerReclaimEntry orCreateReclaim = GetOrCreateReclaim(victimID);
		if (belt != null)
		{
			foreach (Item item in belt)
			{
				item.MoveToContainer(orCreateReclaim.beltInventory);
			}
		}
		if (wear != null)
		{
			foreach (Item item2 in wear)
			{
				item2.MoveToContainer(orCreateReclaim.wearInventory);
			}
		}
		if (main != null)
		{
			foreach (Item item3 in main)
			{
				item3.MoveToContainer(orCreateReclaim.mainInventory);
			}
		}
		if (backpack != null)
		{
			foreach (Item item4 in backpack)
			{
				item4.MoveToContainer(orCreateReclaim.backpackInventory);
			}
		}
		lastReclaimID++;
		orCreateReclaim.victimID = victimID;
		orCreateReclaim.id = lastReclaimID;
		orCreateReclaim.timeAlive = 0f;
		return orCreateReclaim.id;
	}

	public void DoCleanup()
	{
		List<PlayerReclaimEntry> list = Pool.Get<List<PlayerReclaimEntry>>();
		foreach (PlayerReclaimEntry value in entries.Values)
		{
			if (!value.HasItems() || value.timeAlive / 60f > reclaim_expire_minutes)
			{
				list.Add(value);
			}
		}
		foreach (PlayerReclaimEntry item in list)
		{
			RemoveEntry(item);
		}
		Pool.Free<PlayerReclaimEntry>(ref list, false);
	}

	public void TickEntries()
	{
		float num = Time.realtimeSinceStartup - lastTickTime;
		foreach (PlayerReclaimEntry value in entries.Values)
		{
			value.timeAlive += num;
		}
		lastTickTime = Time.realtimeSinceStartup;
		DoCleanup();
	}

	public bool HasReclaims(ulong playerID)
	{
		return entries.ContainsKey(playerID);
	}

	public PlayerReclaimEntry GetReclaim(ulong victimId)
	{
		entries.TryGetValue(victimId, out var value);
		return value;
	}

	public PlayerReclaimEntry GetOrCreateReclaim(ulong victimId)
	{
		PlayerReclaimEntry playerReclaimEntry = GetReclaim(victimId);
		if (playerReclaimEntry == null)
		{
			playerReclaimEntry = Pool.Get<PlayerReclaimEntry>();
			playerReclaimEntry.victimID = victimId;
			entries.Add(victimId, playerReclaimEntry);
		}
		return playerReclaimEntry;
	}

	public void RemoveEntry(PlayerReclaimEntry entry)
	{
		entries.Remove(entry.victimID);
		Pool.Free<PlayerReclaimEntry>(ref entry);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (!info.fromDisk || info.msg.reclaimManager == null)
		{
			return;
		}
		lastReclaimID = info.msg.reclaimManager.lastReclaimID;
		foreach (ReclaimInfo reclaimEntry in info.msg.reclaimManager.reclaimEntries)
		{
			PlayerReclaimEntry orCreateReclaim = GetOrCreateReclaim(reclaimEntry.victimID);
			orCreateReclaim.victimID = reclaimEntry.victimID;
			orCreateReclaim.id = reclaimEntry.reclaimId;
			orCreateReclaim.mainInventory.Load(reclaimEntry.mainInventory);
			orCreateReclaim.wearInventory.Load(reclaimEntry.wearInventory);
			orCreateReclaim.beltInventory.Load(reclaimEntry.beltInventory);
			orCreateReclaim.backpackInventory.Load(reclaimEntry.backpackInventory);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk)
		{
			return;
		}
		info.msg.reclaimManager = Pool.Get<ReclaimManager>();
		info.msg.reclaimManager.reclaimEntries = Pool.Get<List<ReclaimInfo>>();
		info.msg.reclaimManager.lastReclaimID = lastReclaimID;
		foreach (PlayerReclaimEntry value in entries.Values)
		{
			ReclaimInfo val = Pool.Get<ReclaimInfo>();
			val.victimID = value.victimID;
			val.reclaimId = value.id;
			val.mainInventory = value.mainInventory.Save();
			val.wearInventory = value.wearInventory.Save();
			val.beltInventory = value.beltInventory.Save();
			val.backpackInventory = value.backpackInventory.Save();
			info.msg.reclaimManager.reclaimEntries.Add(val);
		}
	}

	public override void ServerInit()
	{
		_instance = this;
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)TickEntries, 1f, 60f);
	}

	internal override void DoServerDestroy()
	{
		_instance = null;
		base.DoServerDestroy();
	}
}


using Facepunch;
using UnityEngine;

public class PlayerReclaimEntry : IPooled
{
	public float timeAlive;

	public int id;

	public ulong victimID;

	public ItemContainer mainInventory;

	public ItemContainer wearInventory;

	public ItemContainer beltInventory;

	public ItemContainer backpackInventory;

	public bool HasItems()
	{
		if ((mainInventory == null || mainInventory.itemList.Count <= 0) && (wearInventory == null || wearInventory.itemList.Count <= 0) && (beltInventory == null || beltInventory.itemList.Count <= 0))
		{
			if (backpackInventory != null)
			{
				return backpackInventory.itemList.Count > 0;
			}
			return false;
		}
		return true;
	}

	private ItemContainer CreateContainer()
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		itemContainer.entityOwner = instance;
		itemContainer.allowedContents = ItemContainer.ContentsType.Generic;
		itemContainer.SetOnlyAllowedItem(null);
		itemContainer.maxStackSize = 0;
		itemContainer.containerVolume = 10;
		itemContainer.ServerInitialize(null, 40);
		itemContainer.canAcceptItem = null;
		itemContainer.GiveUID();
		return itemContainer;
	}

	void IPooled.LeavePool()
	{
		mainInventory = CreateContainer();
		wearInventory = CreateContainer();
		beltInventory = CreateContainer();
		backpackInventory = CreateContainer();
	}

	void IPooled.EnterPool()
	{
		timeAlive = 0f;
		id = -2;
		Pool.Free<ItemContainer>(ref mainInventory);
		Pool.Free<ItemContainer>(ref wearInventory);
		Pool.Free<ItemContainer>(ref beltInventory);
		Pool.Free<ItemContainer>(ref backpackInventory);
	}

	public void GiveToPlayer(BasePlayer player)
	{
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		wearInventory.MoveAllItems(player.inventory.containerWear);
		beltInventory.MoveAllItems(player.inventory.containerBelt);
		mainInventory.MoveAllItems(player.inventory.containerMain);
		if (backpackInventory.itemList.Count > 0)
		{
			Item backpackWithInventory = player.inventory.GetBackpackWithInventory();
			if (backpackWithInventory != null)
			{
				backpackInventory.MoveAllItems(backpackWithInventory.contents);
			}
			if (backpackInventory.itemList.Count > 0)
			{
				backpackInventory.MoveAllItems(player.inventory.containerMain);
			}
			if (backpackInventory.itemList.Count > 0)
			{
				backpackInventory.MoveAllItems(player.inventory.containerBelt);
			}
		}
		if (wearInventory.itemList.Count + beltInventory.itemList.Count + mainInventory.itemList.Count + backpackInventory.itemList.Count > 0)
		{
			ItemContainer.Drop("assets/prefabs/misc/item drop/item_drop_backpack.prefab", player.GetDropPosition(), default(Quaternion), wearInventory, beltInventory, mainInventory, backpackInventory);
		}
	}
}


using System;
using System.Collections;
using System.IO;
using ConVar;
using Facepunch;
using Network;
using Rust;
using UnityEngine;
using UnityEngine.SceneManagement;

public class GameSetup : MonoBehaviour
{
	public static bool RunOnce;

	public bool startServer = true;

	public string demoPath;

	public string clientConnectCommand = "client.connect 127.0.0.1:28015";

	public bool loadMenu = true;

	public bool loadLevel;

	public string loadLevelScene = "";

	public bool loadSave;

	public string loadSaveFile = "";

	public string initializationFile = "";

	public string initializationCommands = "";

	public bool normalRendering;

	protected void Awake()
	{
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		if (RunOnce)
		{
			GameManager.Destroy(((Component)this).gameObject);
			return;
		}
		if (!string.IsNullOrEmpty(initializationCommands))
		{
			CommandLine.Force(CommandLine.Full + " " + initializationCommands);
		}
		Render.use_normal_rendering = normalRendering;
		GameManifest.Load();
		GameManifest.LoadAssets();
		RunOnce = true;
		if (Bootstrap.needsSetup)
		{
			Bootstrap.Init_Tier0();
			if (!string.IsNullOrEmpty(initializationFile))
			{
				if (!File.Exists(initializationFile))
				{
					Debug.Log((object)("Unable to load " + initializationFile + ", does not exist"));
				}
				else
				{
					Debug.Log((object)("Loading initialization file: " + initializationFile));
					ConsoleSystem.RunFile(Option.Server, File.ReadAllText(initializationFile));
				}
			}
			if (!string.IsNullOrEmpty(initializationCommands))
			{
				string[] array = initializationCommands.Split(';');
				foreach (string text in array)
				{
					Debug.Log((object)("Running initialization command: " + text));
					string text2 = text.Trim();
					ConsoleSystem.Run(Option.Server, text2, Array.Empty<object>());
				}
			}
			Bootstrap.Init_Systems();
			Bootstrap.Init_Config();
		}
		((MonoBehaviour)this).StartCoroutine(DoGameSetup());
	}

	private IEnumerator DoGameSetup()
	{
		Application.isLoading = true;
		TerrainMeta.InitNoTerrain();
		ItemManager.Initialize();
		Scene activeScene = SceneManager.GetActiveScene();
		LevelManager.CurrentLevelName = ((Scene)(ref activeScene)).name;
		if (startServer)
		{
			yield return ((MonoBehaviour)this).StartCoroutine(Bootstrap.StartNexusServer());
		}
		if (loadLevel && !string.IsNullOrEmpty(loadLevelScene))
		{
			Net.sv.Reset();
			ConVar.Server.level = loadLevelScene;
			LoadingScreen.Update("LOADING SCENE");
			Application.LoadLevelAdditive(loadLevelScene);
			LoadingScreen.Update(loadLevelScene.ToUpper() + " LOADED");
		}
		if (startServer)
		{
			yield return ((MonoBehaviour)this).StartCoroutine(StartServer());
		}
		yield return null;
		Application.isLoading = false;
	}

	private IEnumerator StartServer()
	{
		ConVar.GC.collect();
		ConVar.GC.unload();
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		if (loadSaveFile.StartsWith('"') && loadSaveFile.EndsWith('"'))
		{
			loadSaveFile = loadSaveFile.Substring(1, loadSaveFile.Length - 2);
		}
		yield return ((MonoBehaviour)this).StartCoroutine(Bootstrap.StartServer(loadSave, loadSaveFile, allowOutOfDateSaves: true));
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class Gibbable : PrefabAttribute, IClientComponent
{
	[Serializable]
	public struct OverrideMesh
	{
		public bool enabled;

		public ColliderType ColliderType;

		public Vector3 BoxSize;

		public Vector3 ColliderCentre;

		public float ColliderRadius;

		public float CapsuleHeight;

		public int CapsuleDirection;

		public bool BlockMaterialCopy;
	}

	public enum ColliderType
	{
		Box,
		Sphere,
		Capsule
	}

	public enum ParentingType
	{
		None,
		GibsOnly,
		FXOnly,
		All
	}

	public enum BoundsEffectType
	{
		None,
		Electrical,
		Glass,
		Scrap,
		Stone,
		Wood
	}

	public GameObject gibSource;

	public Material[] customMaterials;

	public GameObject materialSource;

	public bool copyMaterialBlock = true;

	public bool applyDamageTexture;

	public PhysicMaterial physicsMaterial;

	public GameObjectRef fxPrefab;

	public bool spawnFxPrefab = true;

	[Tooltip("If enabled, gibs will spawn even though we've hit a gib limit")]
	public bool important;

	public bool useContinuousCollision;

	public float explodeScale;

	public float scaleOverride = 1f;

	[ReadOnly]
	public int uniqueId;

	public BoundsEffectType boundsEffectType;

	public bool isConditional;

	[ReadOnly]
	public Bounds effectBounds;

	public List<OverrideMesh> MeshOverrides = new List<OverrideMesh>();

	public bool UsePerGibWaterCheck;

	public bool ForceNoParenting;

	protected override Type GetIndexedType()
	{
		return typeof(Gibbable);
	}
}


using System;
using UnityEngine;

[Serializable]
public struct OverrideMesh
{
	public bool enabled;

	public ColliderType ColliderType;

	public Vector3 BoxSize;

	public Vector3 ColliderCentre;

	public float ColliderRadius;

	public float CapsuleHeight;

	public int CapsuleDirection;

	public bool BlockMaterialCopy;
}


public enum ColliderType
{
	Box,
	Sphere,
	Capsule
}


public enum ParentingType
{
	None,
	GibsOnly,
	FXOnly,
	All
}


public enum BoundsEffectType
{
	None,
	Electrical,
	Glass,
	Scrap,
	Stone,
	Wood
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public class GroundWatch : EntityComponent<BaseEntity>, IServerComponent
{
	public Vector3 groundPosition = Vector3.zero;

	public LayerMask layers = LayerMask.op_Implicit(161546240);

	public float radius = 0.1f;

	public bool needBuildingBlock;

	[Tooltip("By default, we consider a deployable as not grounded when at least one AreaCheck fails. This allows you to consider it grounded as long as one AreaCheck passes.")]
	public bool needOnlyOneAreaCheckValid;

	[Header("Whitelist")]
	public BaseEntity[] whitelist;

	public int fails;

	public BaseCombatEntity cachedGround { get; private set; }

	public override void InitShared()
	{
		base.InitShared();
		CacheGround();
	}

	private void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = Color.green;
		Gizmos.DrawSphere(groundPosition, radius);
	}

	public static void PhysicsChanged(GameObject obj)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)obj == (Object)null)
		{
			return;
		}
		Collider component = obj.GetComponent<Collider>();
		if (!Object.op_Implicit((Object)(object)component))
		{
			return;
		}
		Bounds bounds = component.bounds;
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vector3 center = ((Bounds)(ref bounds)).center;
		Vector3 extents = ((Bounds)(ref bounds)).extents;
		Vis.Entities(center, ((Vector3)(ref extents)).magnitude + 1f, list, 2263296, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!item.IsDestroyed && !item.isClient && !(item is BuildingBlock))
			{
				((Component)item).BroadcastMessage("OnPhysicsNeighbourChanged", (SendMessageOptions)1);
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	public static void PhysicsChanged(Vector3 origin, float radius, int layerMask)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(origin, radius, list, layerMask, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!item.IsDestroyed && !item.isClient && !(item is BuildingBlock))
			{
				((Component)item).BroadcastMessage("OnPhysicsNeighbourChanged", (SendMessageOptions)1);
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	public void OnPhysicsNeighbourChanged()
	{
		bool flag = OnGround();
		if (flag && needBuildingBlock)
		{
			flag = HasBuildingBlock();
		}
		if (!flag)
		{
			fails++;
			if (fails >= Physics.groundwatchfails)
			{
				BaseEntity baseEntity = ((Component)this).gameObject.ToBaseEntity();
				if (Object.op_Implicit((Object)(object)baseEntity))
				{
					((Component)((Component)baseEntity).transform).BroadcastMessage("OnGroundMissing", (object)cachedGround, (SendMessageOptions)1);
				}
			}
			else
			{
				if (Physics.groundwatchdebug)
				{
					Debug.Log((object)("GroundWatch retry: " + fails));
				}
				((FacepunchBehaviour)this).Invoke((Action)OnPhysicsNeighbourChanged, Physics.groundwatchdelay);
			}
		}
		else
		{
			fails = 0;
		}
	}

	private bool HasBuildingBlock()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		Vis.Colliders<Collider>(((Component)this).transform.TransformPoint(groundPosition), radius, list, 2097152, (QueryTriggerInteraction)2);
		bool result = false;
		foreach (Collider item in list)
		{
			BaseEntity baseEntity = ((Component)item).gameObject.ToBaseEntity();
			if (!((Object)(object)baseEntity == (Object)null) && !baseEntity.IsDestroyed && !baseEntity.isClient && baseEntity is BuildingBlock)
			{
				result = true;
				break;
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public bool OnGround()
	{
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity component = ((Component)this).GetComponent<BaseEntity>();
		if (Object.op_Implicit((Object)(object)component) && component.isServer)
		{
			if (component.HasParent())
			{
				return true;
			}
			Construction construction = PrefabAttribute.server.Find<Construction>(component.prefabID);
			if ((bool)construction)
			{
				Socket_Base[] allSockets = construction.allSockets;
				for (int i = 0; i < allSockets.Length; i++)
				{
					SocketMod[] socketMods = allSockets[i].socketMods;
					for (int j = 0; j < socketMods.Length; j++)
					{
						SocketMod_AreaCheck socketMod_AreaCheck = socketMods[j] as SocketMod_AreaCheck;
						if (!socketMod_AreaCheck || !socketMod_AreaCheck.wantsInside)
						{
							continue;
						}
						if (needOnlyOneAreaCheckValid)
						{
							if (socketMod_AreaCheck.DoCheck(((Component)component).transform.position, ((Component)component).transform.rotation, component))
							{
								return true;
							}
						}
						else if (!socketMod_AreaCheck.DoCheck(((Component)component).transform.position, ((Component)component).transform.rotation, component))
						{
							if (Physics.groundwatchdebug)
							{
								Debug.Log((object)("GroundWatch failed: " + socketMod_AreaCheck.hierachyName));
							}
							return false;
						}
					}
				}
			}
		}
		if (Physics.groundwatchdebug)
		{
			Debug.Log((object)"GroundWatch failed: Legacy radius check");
		}
		if (LegacyRadiusCheck(component))
		{
			return true;
		}
		return false;
	}

	private void CacheGround()
	{
		BaseEntity baseEntity = GetBaseEntity();
		if ((Object)(object)baseEntity != (Object)null && baseEntity.isServer)
		{
			LegacyRadiusCheck(baseEntity);
		}
	}

	private bool LegacyRadiusCheck(BaseEntity entity)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		List<Collider> list = Pool.Get<List<Collider>>();
		Vis.Colliders<Collider>(((Component)this).transform.TransformPoint(groundPosition), radius, list, LayerMask.op_Implicit(layers), (QueryTriggerInteraction)2);
		foreach (Collider item in list)
		{
			BaseEntity baseEntity = ((Component)item).gameObject.ToBaseEntity();
			if ((Object)(object)baseEntity == (Object)null)
			{
				Pool.FreeUnmanaged<Collider>(ref list);
				return true;
			}
			if ((Object)(object)baseEntity != (Object)null && ((Object)(object)baseEntity == (Object)(object)entity || baseEntity.IsDestroyed || baseEntity.isClient))
			{
				continue;
			}
			if (whitelist != null && whitelist.Length != 0)
			{
				bool flag = false;
				BaseEntity[] array = whitelist;
				foreach (BaseEntity baseEntity2 in array)
				{
					if (baseEntity.prefabID == baseEntity2.prefabID)
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					continue;
				}
			}
			DecayEntity decayEntity = entity as DecayEntity;
			DecayEntity decayEntity2 = baseEntity as DecayEntity;
			if (!((Object)(object)decayEntity != (Object)null) || decayEntity.buildingID == 0 || !((Object)(object)decayEntity2 != (Object)null) || decayEntity2.buildingID == 0 || decayEntity.buildingID == decayEntity2.buildingID)
			{
				cachedGround = baseEntity as BaseCombatEntity;
				Pool.FreeUnmanaged<Collider>(ref list);
				return true;
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return false;
	}
}


using UnityEngine;

public class HideUntilMobile : EntityComponent<BaseEntity>
{
	public GameObject[] visuals;

	[Tooltip("If turned on, the script will use the convar \"server.projectile.camera.clipdistance\" to determine the distance at which the object will be visible. If turned off, it will use the value in \"overrideDistance\".")]
	public bool useConvarDistance = true;

	public float overrideDistance = 0.3f;

	private Vector3 startPos;
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class HitTest : IPooled
{
	public enum Type
	{
		Generic,
		ProjectileEffect,
		Projectile,
		MeleeAttack,
		Use
	}

	public bool hasLifetimeSetup;

	public Type type;

	public Ray AttackRay;

	public float Radius;

	public float Forgiveness;

	public float MaxDistance;

	public RaycastHit RayHit;

	public bool MultiHit;

	public bool BestHit;

	public bool DidHit;

	public DamageProperties damageProperties;

	public GameObject gameObject;

	public Collider collider;

	public BaseEntity ignoreEntity;

	public List<System.Type> ignoredTypes = new List<System.Type>();

	public BaseEntity HitEntity;

	public Vector3 HitPoint;

	public Vector3 HitNormal;

	public float HitDistance;

	public Transform HitTransform;

	public uint HitPart;

	public string HitMaterial;

	public void EnterPool()
	{
		Clear();
	}

	public void LeavePool()
	{
	}

	public void CopyFrom(HitTest other, bool copyHitInfo = false)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		type = other.type;
		AttackRay = other.AttackRay;
		Radius = other.Radius;
		Forgiveness = other.Forgiveness;
		MaxDistance = other.MaxDistance;
		RayHit = other.RayHit;
		damageProperties = other.damageProperties;
		ignoreEntity = other.ignoreEntity;
		ignoredTypes = other.ignoredTypes;
		if (copyHitInfo)
		{
			HitEntity = other.HitEntity;
			HitPoint = other.HitPoint;
			HitNormal = other.HitNormal;
			HitDistance = other.HitDistance;
			HitTransform = other.HitTransform;
			HitPart = other.HitPart;
			HitMaterial = other.HitMaterial;
			MultiHit = other.MultiHit;
			BestHit = other.BestHit;
			DidHit = other.DidHit;
		}
	}

	public Vector3 HitPointWorld()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)HitEntity != (Object)null)
		{
			Transform val = HitTransform;
			if (!Object.op_Implicit((Object)(object)val))
			{
				val = ((Component)HitEntity).transform;
			}
			return val.TransformPoint(HitPoint);
		}
		return HitPoint;
	}

	public Vector3 HitNormalWorld()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)HitEntity != (Object)null)
		{
			Transform val = HitTransform;
			if (!Object.op_Implicit((Object)(object)val))
			{
				val = ((Component)HitEntity).transform;
			}
			return val.TransformDirection(HitNormal);
		}
		return HitNormal;
	}

	public void Clear()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		hasLifetimeSetup = false;
		type = Type.Generic;
		AttackRay = default(Ray);
		Radius = 0f;
		Forgiveness = 0f;
		MaxDistance = 0f;
		RayHit = default(RaycastHit);
		MultiHit = false;
		BestHit = false;
		DidHit = false;
		damageProperties = null;
		gameObject = null;
		collider = null;
		ignoreEntity = null;
		HitEntity = null;
		HitPoint = default(Vector3);
		HitNormal = default(Vector3);
		HitDistance = 0f;
		HitTransform = null;
		HitPart = 0u;
		HitMaterial = null;
		ignoredTypes.Clear();
	}
}


public enum Type
{
	Generic,
	ProjectileEffect,
	Projectile,
	MeleeAttack,
	Use
}


using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;

public class HitInfo : IPooled
{
	public BaseEntity Initiator;

	public BaseEntity WeaponPrefab;

	public AttackEntity Weapon;

	public bool DoHitEffects = true;

	public bool DoDecals = true;

	public bool IsPredicting;

	public bool UseProtection = true;

	public Connection Predicted;

	public bool DidHit;

	public BaseEntity HitEntity;

	public uint HitBone;

	public uint HitPart;

	public uint HitMaterial;

	public Vector3 HitPositionWorld;

	public Vector3 HitPositionLocal;

	public Vector3 HitNormalWorld;

	public Vector3 HitNormalLocal;

	public Vector3 PointStart;

	public Vector3 PointEnd;

	public int ProjectileID;

	public int ProjectileHits;

	public float ProjectileDistance;

	public float ProjectileIntegrity;

	public float ProjectileTravelTime;

	public float ProjectileTrajectoryMismatch;

	public Vector3 ProjectileVelocity;

	public Projectile ProjectilePrefab;

	public PhysicMaterial material;

	public DamageProperties damageProperties;

	public DamageTypeList damageTypes = new DamageTypeList();

	public bool CanGather;

	public bool DidGather;

	public float gatherScale = 1f;

	public BasePlayer InitiatorPlayer
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)Initiator))
			{
				return null;
			}
			return Initiator.ToPlayer();
		}
	}

	public Vector3 attackNormal
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = PointEnd - PointStart;
			return ((Vector3)(ref val)).normalized;
		}
	}

	public bool hasDamage => damageTypes.Total() > 0f;

	public bool InitiatorParented
	{
		get
		{
			if ((Object)(object)Initiator != (Object)null && (Object)(object)Initiator.GetParentEntity() != (Object)null)
			{
				return Initiator.GetParentEntity().IsValid();
			}
			return false;
		}
	}

	public bool HitEntityParented
	{
		get
		{
			if ((Object)(object)HitEntity != (Object)null && (Object)(object)HitEntity.GetParentEntity() != (Object)null)
			{
				return HitEntity.GetParentEntity().IsValid();
			}
			return false;
		}
	}

	public bool isHeadshot
	{
		get
		{
			if ((Object)(object)HitEntity == (Object)null)
			{
				return false;
			}
			BaseCombatEntity baseCombatEntity = HitEntity as BaseCombatEntity;
			if ((Object)(object)baseCombatEntity == (Object)null)
			{
				return false;
			}
			if ((Object)(object)baseCombatEntity.skeletonProperties == (Object)null)
			{
				return false;
			}
			SkeletonProperties.BoneProperty boneProperty = baseCombatEntity.skeletonProperties.FindBone(HitBone);
			if (boneProperty == null)
			{
				return false;
			}
			return boneProperty.area == HitArea.Head;
		}
	}

	public string boneName
	{
		get
		{
			if ((Object)(object)HitEntity == (Object)null)
			{
				return null;
			}
			BaseCombatEntity baseCombatEntity = HitEntity as BaseCombatEntity;
			if ((Object)(object)baseCombatEntity == (Object)null)
			{
				return null;
			}
			if ((Object)(object)baseCombatEntity.skeletonProperties == (Object)null)
			{
				return null;
			}
			return baseCombatEntity.skeletonProperties.FindBone(HitBone)?.boneName;
		}
	}

	public HitArea boneArea
	{
		get
		{
			if ((Object)(object)HitEntity == (Object)null)
			{
				return (HitArea)(-1);
			}
			BaseCombatEntity baseCombatEntity = HitEntity as BaseCombatEntity;
			if ((Object)(object)baseCombatEntity == (Object)null)
			{
				return (HitArea)(-1);
			}
			return baseCombatEntity.SkeletonLookup(HitBone);
		}
	}

	public void EnterPool()
	{
		Clear();
	}

	public void LeavePool()
	{
	}

	public void Clear()
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		Initiator = null;
		WeaponPrefab = null;
		Weapon = null;
		DoHitEffects = true;
		DoDecals = true;
		IsPredicting = false;
		UseProtection = true;
		Predicted = null;
		DidHit = false;
		HitEntity = null;
		HitBone = 0u;
		HitPart = 0u;
		HitMaterial = 0u;
		HitPositionWorld = default(Vector3);
		HitPositionLocal = default(Vector3);
		HitNormalWorld = default(Vector3);
		HitNormalLocal = default(Vector3);
		PointStart = default(Vector3);
		PointEnd = default(Vector3);
		ProjectileID = 0;
		ProjectileHits = 0;
		ProjectileDistance = 0f;
		ProjectileIntegrity = 0f;
		ProjectileTravelTime = 0f;
		ProjectileTrajectoryMismatch = 0f;
		ProjectileVelocity = default(Vector3);
		ProjectilePrefab = null;
		material = null;
		damageProperties = null;
		damageTypes.Clear();
		CanGather = false;
		DidGather = false;
		gatherScale = 1f;
	}

	public void CopyFrom(HitInfo other)
	{
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		Initiator = other.Initiator;
		WeaponPrefab = other.WeaponPrefab;
		Weapon = other.Weapon;
		DoHitEffects = other.DoHitEffects;
		DoDecals = other.DoDecals;
		IsPredicting = other.IsPredicting;
		UseProtection = other.UseProtection;
		Predicted = other.Predicted;
		DidHit = other.DidHit;
		HitEntity = other.HitEntity;
		HitBone = other.HitBone;
		HitPart = other.HitPart;
		HitMaterial = other.HitMaterial;
		HitPositionWorld = other.HitPositionWorld;
		HitPositionLocal = other.HitPositionLocal;
		HitNormalWorld = other.HitNormalWorld;
		HitNormalLocal = other.HitNormalLocal;
		PointStart = other.PointStart;
		PointEnd = other.PointEnd;
		ProjectileID = other.ProjectileID;
		ProjectileHits = other.ProjectileHits;
		ProjectileDistance = other.ProjectileDistance;
		ProjectileIntegrity = other.ProjectileIntegrity;
		ProjectileTravelTime = other.ProjectileTravelTime;
		ProjectileTrajectoryMismatch = other.ProjectileTrajectoryMismatch;
		ProjectileVelocity = other.ProjectileVelocity;
		ProjectilePrefab = other.ProjectilePrefab;
		material = other.material;
		damageProperties = other.damageProperties;
		for (int i = 0; i < damageTypes.types.Length; i++)
		{
			damageTypes.types[i] = other.damageTypes.types[i];
		}
		CanGather = other.CanGather;
		DidGather = other.DidGather;
		gatherScale = other.gatherScale;
	}

	public bool IsProjectile()
	{
		return ProjectileID != 0;
	}

	public void Init(BaseEntity attacker, BaseEntity target, DamageType type, float damageAmount, Vector3 vhitPosition)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		Initiator = attacker;
		HitEntity = target;
		HitPositionWorld = vhitPosition;
		if ((Object)(object)attacker != (Object)null)
		{
			PointStart = ((Component)attacker).transform.position;
		}
		damageTypes.Add(type, damageAmount);
	}

	public HitInfo()
	{
	}

	public HitInfo(BaseEntity attacker, BaseEntity target, DamageType type, float damageAmount, Vector3 vhitPosition)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		Init(attacker, target, type, damageAmount, vhitPosition);
	}

	public HitInfo(BaseEntity attacker, BaseEntity target, DamageType type, float damageAmount)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Init(attacker, target, type, damageAmount, ((Component)target).transform.position);
	}

	public void LoadFromAttack(Attack attack, bool serverSide)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		HitEntity = null;
		PointStart = attack.pointStart;
		PointEnd = attack.pointEnd;
		if (((NetworkableId)(ref attack.hitID)).IsValid)
		{
			DidHit = true;
			if (serverSide)
			{
				HitEntity = BaseNetworkable.serverEntities.Find(attack.hitID) as BaseEntity;
			}
			if (Object.op_Implicit((Object)(object)HitEntity))
			{
				HitBone = attack.hitBone;
				HitPart = attack.hitPartID;
			}
		}
		DidHit = true;
		HitPositionLocal = attack.hitPositionLocal;
		HitPositionWorld = attack.hitPositionWorld;
		HitNormalLocal = ((Vector3)(ref attack.hitNormalLocal)).normalized;
		HitNormalWorld = ((Vector3)(ref attack.hitNormalWorld)).normalized;
		HitMaterial = attack.hitMaterialID;
		if (((NetworkableId)(ref attack.srcParentID)).IsValid)
		{
			BaseEntity baseEntity = null;
			if (serverSide)
			{
				baseEntity = BaseNetworkable.serverEntities.Find(attack.srcParentID) as BaseEntity;
			}
			if (baseEntity.IsValid())
			{
				PointStart = ((Component)baseEntity).transform.TransformPoint(PointStart);
			}
		}
		if (((NetworkableId)(ref attack.dstParentID)).IsValid)
		{
			BaseEntity baseEntity2 = null;
			if (serverSide)
			{
				baseEntity2 = BaseNetworkable.serverEntities.Find(attack.dstParentID) as BaseEntity;
			}
			if (baseEntity2.IsValid())
			{
				PointEnd = ((Component)baseEntity2).transform.TransformPoint(PointEnd);
				HitPositionWorld = ((Component)baseEntity2).transform.TransformPoint(HitPositionWorld);
				HitNormalWorld = ((Component)baseEntity2).transform.TransformDirection(HitNormalWorld);
			}
		}
	}

	public Vector3 PositionOnRay(Vector3 position)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		Ray val = default(Ray);
		((Ray)(ref val))..ctor(PointStart, attackNormal);
		if ((Object)(object)ProjectilePrefab == (Object)null)
		{
			return val.ClosestPoint(position);
		}
		Sphere val2 = default(Sphere);
		((Sphere)(ref val2))..ctor(position, ProjectilePrefab.thickness);
		RaycastHit val3 = default(RaycastHit);
		if (((Sphere)(ref val2)).Trace(val, ref val3, float.PositiveInfinity))
		{
			return ((RaycastHit)(ref val3)).point;
		}
		return position;
	}

	public Vector3 HitPositionOnRay()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return PositionOnRay(HitPositionWorld);
	}

	public bool IsNaNOrInfinity()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3Ex.IsNaNOrInfinity(PointStart))
		{
			return true;
		}
		if (Vector3Ex.IsNaNOrInfinity(PointEnd))
		{
			return true;
		}
		if (Vector3Ex.IsNaNOrInfinity(HitPositionWorld))
		{
			return true;
		}
		if (Vector3Ex.IsNaNOrInfinity(HitPositionLocal))
		{
			return true;
		}
		if (Vector3Ex.IsNaNOrInfinity(HitNormalWorld))
		{
			return true;
		}
		if (Vector3Ex.IsNaNOrInfinity(HitNormalLocal))
		{
			return true;
		}
		if (Vector3Ex.IsNaNOrInfinity(ProjectileVelocity))
		{
			return true;
		}
		if (float.IsNaN(ProjectileDistance))
		{
			return true;
		}
		if (float.IsInfinity(ProjectileDistance))
		{
			return true;
		}
		if (float.IsNaN(ProjectileIntegrity))
		{
			return true;
		}
		if (float.IsInfinity(ProjectileIntegrity))
		{
			return true;
		}
		if (float.IsNaN(ProjectileTravelTime))
		{
			return true;
		}
		if (float.IsInfinity(ProjectileTravelTime))
		{
			return true;
		}
		if (float.IsNaN(ProjectileTrajectoryMismatch))
		{
			return true;
		}
		if (float.IsInfinity(ProjectileTrajectoryMismatch))
		{
			return true;
		}
		return false;
	}
}


using System;

[Flags]
public enum HitArea
{
	Head = 1,
	Chest = 2,
	Stomach = 4,
	Arm = 8,
	Hand = 0x10,
	Leg = 0x20,
	Foot = 0x40
}


public static class HitAreaConst
{
	public const HitArea Nothing = (HitArea)0;

	public const HitArea Everything = (HitArea)(-1);
}


public static class HitAreaUtil
{
	public static string Format(HitArea area)
	{
		return area switch
		{
			(HitArea)0 => "None", 
			(HitArea)(-1) => "Generic", 
			_ => area.ToString(), 
		};
	}
}


using System;
using UnityEngine;

public class IgnoreRotation : MonoBehaviour
{
	[Serializable]
	public enum RotationType
	{
		None,
		X,
		Y,
		Z
	}

	public RotationType ignoreType;

	public Transform parent;

	private void LateUpdate()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		if (ignoreType != 0)
		{
			Quaternion localRotation;
			if (ignoreType == RotationType.X)
			{
				Transform transform = ((Component)this).transform;
				localRotation = parent.localRotation;
				float y = ((Quaternion)(ref localRotation)).eulerAngles.y;
				localRotation = parent.localRotation;
				transform.localRotation = Quaternion.Euler(0f, y, ((Quaternion)(ref localRotation)).eulerAngles.z);
			}
			else if (ignoreType == RotationType.Y)
			{
				Transform transform2 = ((Component)this).transform;
				localRotation = parent.localRotation;
				float x = ((Quaternion)(ref localRotation)).eulerAngles.x;
				localRotation = parent.localRotation;
				transform2.localRotation = Quaternion.Euler(x, 0f, ((Quaternion)(ref localRotation)).eulerAngles.z);
			}
			else if (ignoreType == RotationType.Z)
			{
				Transform transform3 = ((Component)this).transform;
				localRotation = parent.localRotation;
				float x2 = ((Quaternion)(ref localRotation)).eulerAngles.x;
				localRotation = parent.localRotation;
				transform3.localRotation = Quaternion.Euler(x2, ((Quaternion)(ref localRotation)).eulerAngles.y, 0f);
			}
		}
	}
}


using System;

[Serializable]
public enum RotationType
{
	None,
	X,
	Y,
	Z
}


using ProtoBuf;

public interface IInstanceDataReceiver
{
	void ReceiveInstanceData(InstanceData data);
}


public interface IOnParentDestroying
{
	void OnParentDestroying();
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class OnParentDestroyingEx
{
	public static void BroadcastOnParentDestroying(this GameObject go)
	{
		List<IOnParentDestroying> list = Pool.Get<List<IOnParentDestroying>>();
		go.GetComponentsInChildren<IOnParentDestroying>(list);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].OnParentDestroying();
		}
		Pool.FreeUnmanaged<IOnParentDestroying>(ref list);
	}

	public static void SendOnParentDestroying(this GameObject go)
	{
		List<IOnParentDestroying> list = Pool.Get<List<IOnParentDestroying>>();
		go.GetComponents<IOnParentDestroying>(list);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].OnParentDestroying();
		}
		Pool.FreeUnmanaged<IOnParentDestroying>(ref list);
	}
}


public interface IOnParentSpawning
{
	void OnParentSpawning();
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class OnParentSpawningEx
{
	public static void BroadcastOnParentSpawning(this GameObject go)
	{
		List<IOnParentSpawning> list = Pool.Get<List<IOnParentSpawning>>();
		go.GetComponentsInChildren<IOnParentSpawning>(list);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].OnParentSpawning();
		}
		Pool.FreeUnmanaged<IOnParentSpawning>(ref list);
	}

	public static void SendOnParentSpawning(this GameObject go)
	{
		List<IOnParentSpawning> list = Pool.Get<List<IOnParentSpawning>>();
		go.GetComponents<IOnParentSpawning>(list);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].OnParentSpawning();
		}
		Pool.FreeUnmanaged<IOnParentSpawning>(ref list);
	}
}


public interface IOnPostNetworkUpdate
{
	void OnPostNetworkUpdate(BaseEntity entity);
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class OnPostNetworkUpdateEx
{
	public static void BroadcastOnPostNetworkUpdate(this GameObject go, BaseEntity entity)
	{
		List<IOnPostNetworkUpdate> list = Pool.Get<List<IOnPostNetworkUpdate>>();
		go.GetComponentsInChildren<IOnPostNetworkUpdate>(list);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].OnPostNetworkUpdate(entity);
		}
		Pool.FreeUnmanaged<IOnPostNetworkUpdate>(ref list);
	}

	public static void SendOnPostNetworkUpdate(this GameObject go, BaseEntity entity)
	{
		List<IOnPostNetworkUpdate> list = Pool.Get<List<IOnPostNetworkUpdate>>();
		go.GetComponents<IOnPostNetworkUpdate>(list);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].OnPostNetworkUpdate(entity);
		}
		Pool.FreeUnmanaged<IOnPostNetworkUpdate>(ref list);
	}
}


public interface IOnSendNetworkUpdate
{
	void OnSendNetworkUpdate(BaseEntity entity);
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class OnSendNetworkUpdateEx
{
	public static void BroadcastOnSendNetworkUpdate(this GameObject go, BaseEntity entity)
	{
		List<IOnSendNetworkUpdate> list = Pool.Get<List<IOnSendNetworkUpdate>>();
		go.GetComponentsInChildren<IOnSendNetworkUpdate>(list);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].OnSendNetworkUpdate(entity);
		}
		Pool.FreeUnmanaged<IOnSendNetworkUpdate>(ref list);
	}

	public static void SendOnSendNetworkUpdate(this GameObject go, BaseEntity entity)
	{
		List<IOnSendNetworkUpdate> list = Pool.Get<List<IOnSendNetworkUpdate>>();
		go.GetComponents<IOnSendNetworkUpdate>(list);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].OnSendNetworkUpdate(entity);
		}
		Pool.FreeUnmanaged<IOnSendNetworkUpdate>(ref list);
	}
}


using UnityEngine;

public class LakeInfo : MonoBehaviour
{
	protected void Awake()
	{
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.LakeObjs.Add(this);
		}
	}
}


using UnityEngine;

public class LandmarkInfo : MonoBehaviour
{
	[Header("LandmarkInfo")]
	public bool shouldDisplayOnMap;

	public bool isLayerSpecific;

	public Phrase displayPhrase;

	public Sprite mapIcon;

	public virtual MapLayer MapLayer => MapLayer.Overworld;

	protected virtual void Awake()
	{
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.Landmarks.Add(this);
		}
	}
}


using UnityEngine;

public class LevelInfo : SingletonComponent<LevelInfo>
{
	public string shortName;

	public string displayName;

	[TextArea]
	public string description;

	[Tooltip("A background image to be shown when loading the map")]
	public Texture2D image;

	[Tooltip("You should incrememnt this version when you make changes to the map that will invalidate old saves")]
	[Space(10f)]
	public int version = 1;
}


using System;
using System.Collections;
using System.Collections.Generic;
using Facepunch;
using Facepunch.Extend;
using Network;
using UnityEngine;
using UnityEngine.SceneManagement;

public static class LevelManager
{
	public static string CurrentLevelName;

	private static readonly Queue<int> taskQueue = new Queue<int>();

	private static int nextTaskId = 0;

	private const string emptySceneName = "EmptyLastScene";

	public static bool isLoaded
	{
		get
		{
			if (CurrentLevelName == null)
			{
				return false;
			}
			if (CurrentLevelName == "")
			{
				return false;
			}
			if (CurrentLevelName == "Empty")
			{
				return false;
			}
			if (CurrentLevelName == "MenuBackground")
			{
				return false;
			}
			return true;
		}
	}

	public static bool IsValid(string strName)
	{
		return Application.CanStreamedLevelBeLoaded(strName);
	}

	public static IEnumerator LoadLevelAsync(string strName, bool keepLoadingScreenOpen = true, bool showLoadingScreen = true)
	{
		int taskId = nextTaskId++;
		taskQueue.Enqueue(taskId);
		while (taskQueue.Peek() != taskId)
		{
			yield return null;
		}
		try
		{
			if (strName == "proceduralmap")
			{
				strName = "Procedural Map";
			}
			Log("Loading level: " + strName);
			Scene sceneByName = SceneManager.GetSceneByName("EmptyLastScene");
			if (!((Scene)(ref sceneByName)).IsValid())
			{
				SceneManager.CreateScene("EmptyLastScene");
			}
			List<string> list = new List<string>();
			int sceneCount = SceneManager.sceneCount;
			for (int i = 0; i < sceneCount; i++)
			{
				Scene sceneAt = SceneManager.GetSceneAt(i);
				string name = ((Scene)(ref sceneAt)).name;
				if (CanUnloadScene(name))
				{
					list.Add(name);
				}
			}
			int num = List.FindIndex<string>((IReadOnlyList<string>)list, CurrentLevelName, (IEqualityComparer<string>)StringComparer.OrdinalIgnoreCase);
			if (num >= 0)
			{
				string item = list[num];
				list.RemoveAt(num);
				list.Add(item);
			}
			List<GameObject> list2 = Pool.Get<List<GameObject>>();
			foreach (string item2 in list)
			{
				Log("Disabling all objects in scene: " + item2);
				Scene sceneByName2 = SceneManager.GetSceneByName(item2);
				if (!((Scene)(ref sceneByName2)).IsValid())
				{
					Debug.LogWarning((object)("Cannot disable objects in scene because it was not found: " + item2));
					continue;
				}
				list2.Clear();
				((Scene)(ref sceneByName2)).GetRootGameObjects(list2);
				foreach (GameObject item3 in list2)
				{
					if (!((Object)(object)item3 == (Object)null))
					{
						item3.SetActive(false);
					}
				}
			}
			Pool.FreeUnmanaged<GameObject>(ref list2);
			List<AsyncOperation> list3 = new List<AsyncOperation>();
			foreach (string item4 in list)
			{
				AsyncOperation val = SceneManager.UnloadSceneAsync(item4);
				if (val == null)
				{
					Debug.LogError((object)("Failed to unload scene: " + item4));
					continue;
				}
				Log("Unloading scene: " + item4);
				list3.Add(val);
			}
			foreach (AsyncOperation item5 in list3)
			{
				yield return item5;
			}
			Net.sv.Reset();
			Log("Loading scene: " + strName);
			AsyncOperation loadOp = SceneManager.LoadSceneAsync(strName, (LoadSceneMode)1);
			if (loadOp == null)
			{
				Debug.LogError((object)("Failed to load level: " + strName));
				yield break;
			}
			loadOp.allowSceneActivation = false;
			Scene newScene = SceneManager.GetSceneByName(strName);
			while (!loadOp.isDone)
			{
				if (loadOp.progress >= 0.9f)
				{
					Log("Level " + strName + " loaded, activating...");
					loadOp.allowSceneActivation = true;
					CurrentLevelName = strName;
				}
				yield return null;
			}
			Log("Making " + strName + " the default scene");
			SceneManager.SetActiveScene(newScene);
			Log("Level " + strName + " loaded successfully.");
		}
		finally
		{
			taskQueue.Dequeue();
		}
		static bool CanUnloadScene(string sceneName)
		{
			if (string.Equals(sceneName, "DontDestroyOnLoad", StringComparison.OrdinalIgnoreCase) || string.Equals(sceneName, "EmptyLastScene", StringComparison.OrdinalIgnoreCase))
			{
				return false;
			}
			if (AssetBundleBackend.Enabled)
			{
				foreach (Entry scene in AssetSceneManifest.Current.Scenes)
				{
					if (string.Equals(sceneName, scene.Name, StringComparison.OrdinalIgnoreCase))
					{
						return false;
					}
				}
			}
			return true;
		}
	}

	public static IEnumerator UnloadLevelAsync(bool loadingScreen = true)
	{
		yield return LoadLevelAsync("Empty", keepLoadingScreenOpen: false, showLoadingScreen: false);
	}

	private static void Log(string message)
	{
	}
}


public class AnimatorLOD : LODComponent
{
	public float Distance = 100f;
}


public static class BatchingToggleEx
{
}


public interface IBatchingHandler
{
}


public interface IBatchingToggle
{
	void Toggle(bool state);
}


using Rust.Workshop;
using UnityEngine;

public class RendererBatch : MonoBehaviour, IClientComponent, ICustomMaterialReplacer, IWorkshopPreview
{
}


public class RendererGrid : SingletonComponent<RendererGrid>, IClientComponent
{
	public static bool Paused;

	public GameObjectRef BatchPrefab;

	public float CellSize = 50f;

	public float MaxMilliseconds = 0.1f;

	public const float MinTimeBetweenRefreshes = 1f;
}


public class CanvasLOD : LODComponent
{
	public float Distance = 100f;
}


using UnityEngine;

public class ClothLOD : FacepunchBehaviour
{
	[ServerVar(Help = "distance cloth will simulate until")]
	public static float clothLODDist = 20f;

	public Cloth cloth;
}


using UnityEngine;

public class CopyLODValues : MonoBehaviour, IEditorComponent
{
	[SerializeField]
	private LODGroup source;

	[SerializeField]
	private LODGroup destination;

	[SerializeField]
	[Tooltip("Is false, exact values are copied. If true, values are scaled based on LODGroup size, so the changeover point will match.")]
	private bool scale = true;

	public bool CanCopy()
	{
		if ((Object)(object)source != (Object)null)
		{
			return (Object)(object)destination != (Object)null;
		}
		return false;
	}

	public void Copy()
	{
		if (!CanCopy())
		{
			return;
		}
		LOD[] lODs = source.GetLODs();
		if (scale)
		{
			float num = destination.size / source.size;
			for (int i = 0; i < lODs.Length; i++)
			{
				lODs[i].screenRelativeTransitionHeight *= num;
			}
		}
		LOD[] lODs2 = destination.GetLODs();
		for (int j = 0; j < lODs2.Length && j < lODs.Length; j++)
		{
			int num2 = ((j == lODs2.Length - 1) ? (lODs.Length - 1) : j);
			lODs2[j].screenRelativeTransitionHeight = lODs[num2].screenRelativeTransitionHeight;
			Debug.Log((object)$"Set destination LOD {j} to {lODs2[j].screenRelativeTransitionHeight}");
		}
		destination.SetLODs(lODs2);
	}
}


public class DecalCull : LODComponent
{
	public float Distance = 20f;
}


public class EnvironmentVolumeLOD : LODComponent
{
	public float Distance = 500f;
}


using UnityEngine;

public class GameObjectLOD : LODComponent
{
	public float Distance = 100f;

	public GameObject TargetGameObject;
}


using UnityEngine;

public class HLODBounds : MonoBehaviour, IEditorComponent
{
	[Tooltip("The bounds that this HLOD will cover. This should not overlap with any other HLODs")]
	public Bounds MeshBounds = new Bounds(Vector3.zero, new Vector3(50f, 25f, 50f));

	[Tooltip("Assets created will use this prefix. Make sure multiple HLODS in a scene have different prefixes")]
	public string MeshPrefix = "root";

	[Tooltip("The point from which to calculate the HLOD. Any RendererLODs that are visible at this distance will baked into the HLOD mesh")]
	public float CullDistance = 100f;

	[Tooltip("If set, the lod will take over at this distance instead of the CullDistance (eg. we make a model based on what this area looks like at 200m but we actually want it take over rendering at 300m)")]
	public float OverrideLodDistance;

	[Tooltip("Any renderers below this height will considered culled even if they are visible from a distance. Good for underground areas")]
	public float CullBelowHeight;

	[Tooltip("Optimises the mesh produced by removing non-visible and small faces. Can turn it off during dev but should be on for final builds")]
	public bool ApplyMeshTrimming = true;

	public MeshTrimSettings Settings = MeshTrimSettings.Default;

	public LODComponent DebugComponent;

	public bool ShowTrimSettings;

	[Tooltip("Prints out information about what the baker is doing, helpful for diagnosing errors")]
	public bool DebugMode;
}


public interface IHLODMeshSource
{
}


public interface ILOD
{
}


public interface IRefreshable
{
	void Refresh();
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

internal static class RefreshableEx
{
	public static void BroadcastRefresh(this GameObject go)
	{
		List<IRefreshable> list = Pool.Get<List<IRefreshable>>();
		go.GetComponentsInChildren<IRefreshable>(list);
		for (int i = 0; i < list.Count; i++)
		{
			list[i].Refresh();
		}
		Pool.FreeUnmanaged<IRefreshable>(ref list);
	}
}


using System;
using Rust.Workshop;
using UnityEngine;

public abstract class LODComponent : BaseMonoBehaviour, IClientComponent, ILOD, IWorkshopPreview
{
	[Serializable]
	public struct OccludeeParameters
	{
		[Tooltip("Is Occludee dynamic or static?")]
		public bool isDynamic;

		[Tooltip("Dynamic occludee update interval in seconds; 0 = every frame")]
		public float dynamicUpdateInterval;

		[Tooltip("Distance scale combined with occludee max bounds size at which culled occludee shadows are still visible")]
		public float shadowRangeScale;

		[Tooltip("Show culling bounds via gizmos; editor only")]
		public bool showBounds;

		[Tooltip("Force Occludee always visible?")]
		public bool forceVisible;
	}

	public LODDistanceMode DistanceMode;

	public OccludeeParameters OccludeeParams = new OccludeeParameters
	{
		isDynamic = false,
		dynamicUpdateInterval = 0.2f,
		shadowRangeScale = 3f,
		showBounds = false,
		forceVisible = false
	};
}


using System;
using UnityEngine;

[Serializable]
public struct OccludeeParameters
{
	[Tooltip("Is Occludee dynamic or static?")]
	public bool isDynamic;

	[Tooltip("Dynamic occludee update interval in seconds; 0 = every frame")]
	public float dynamicUpdateInterval;

	[Tooltip("Distance scale combined with occludee max bounds size at which culled occludee shadows are still visible")]
	public float shadowRangeScale;

	[Tooltip("Show culling bounds via gizmos; editor only")]
	public bool showBounds;

	[Tooltip("Force Occludee always visible?")]
	public bool forceVisible;
}


using UnityEngine;

public abstract class LODComponentParticleSystem : LODComponent
{
	[Tooltip("Automatically call Play() the particle system when it's shown via LOD")]
	public bool playOnShow = true;

	public bool disableSubEmittersOnShow;
}


public class LODGrid : SingletonComponent<LODGrid>, IClientComponent
{
	public static bool Paused = false;

	public static bool RefreshDisabled = false;

	public float CellSize = 50f;

	public const float MaxRefreshDistance = 500f;

	public static float TreeMeshDistance = 500f;

	public const float MinTimeBetweenRefreshes = 1f;
}


public class LODManager : SingletonComponent<LODManager>
{
	public float MaxMilliseconds = 1f;
}


using UnityEngine;

public class LODMasterMesh : LODComponent
{
	public MeshRenderer ReplacementMesh;

	public float Distance = 100f;

	public LODComponent[] ChildComponents;

	public bool Block;

	public Bounds MeshBounds;
}


using UnityEngine;

public static class LODUtil
{
	public const float DefaultDistance = 1000f;

	public const float FarCameraDistance = 30f;

	public static float GetDistance(Transform transform, LODDistanceMode mode = LODDistanceMode.XYZ)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GetDistance(transform.position, mode);
	}

	public static float GetDistance(Vector3 meshPos, LODDistanceMode mode = LODDistanceMode.XYZ)
	{
		return 1000f;
	}

	private static float GetDistanceInternal(Vector3 cameraPos, Vector3 worldPos, LODDistanceMode mode)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		return mode switch
		{
			LODDistanceMode.XYZ => Vector3.Distance(cameraPos, worldPos), 
			LODDistanceMode.XZ => Vector3Ex.Distance2D(cameraPos, worldPos), 
			LODDistanceMode.Y => Mathf.Abs(cameraPos.y - worldPos.y), 
			_ => 1000f, 
		};
	}

	public static float VerifyDistance(float distance)
	{
		return Mathf.Min(500f, distance);
	}

	public static LODEnvironmentMode DetermineEnvironmentMode(Transform transform)
	{
		if (((Component)transform).CompareTag("OnlyVisibleUnderground") || ((Component)transform.root).CompareTag("OnlyVisibleUnderground"))
		{
			return LODEnvironmentMode.Underground;
		}
		return LODEnvironmentMode.Default;
	}
}


public enum LODDistanceMode
{
	XYZ,
	XZ,
	Y
}


public enum LODEnvironmentMode
{
	Default,
	Underground
}


using Rust.Rendering.IndirectInstancing;

public class MeshCull : InstancedLODComponent, IBatchingHandler
{
	public float Distance = 100f;
}


public class MeshGroupCull : LODComponent
{
	public float Distance = 100f;
}


using System;
using Rust.Rendering.IndirectInstancing;
using UnityEngine;

public class MeshLOD : InstancedLODComponent, IBatchingHandler, IHLODMeshSource
{
	[Serializable]
	public class State
	{
		[Range(1f, 1000f)]
		public float distance;

		public Mesh mesh;
	}

	[Horizontal(1, 0)]
	public State[] States;

	public Mesh GetHighestDetailMesh()
	{
		if (States != null && States.Length != 0)
		{
			return States[0].mesh;
		}
		return null;
	}
}


using System;
using UnityEngine;

[Serializable]
public class State
{
	[Range(1f, 1000f)]
	public float distance;

	public Mesh mesh;
}


public class MeshTreeLOD : MeshLOD
{
}


using UnityEngine;

public class NotifyLOD : LODComponent
{
	public float Distance = 100f;

	public float MinDistanceMultiplier = 0.2f;

	public GameObject TargetGameObject;
}


public interface INotifyLOD
{
}


using System;

public class ParticleCollisionLOD : LODComponentParticleSystem
{
	public enum QualityLevel
	{
		Disabled = -1,
		HighQuality,
		MediumQuality,
		LowQuality
	}

	[Serializable]
	public class State
	{
		public float distance;

		public QualityLevel quality = QualityLevel.Disabled;
	}

	[Horizontal(1, 0)]
	public State[] States;
}


public enum QualityLevel
{
	Disabled = -1,
	HighQuality,
	MediumQuality,
	LowQuality
}


using System;

[Serializable]
public class State
{
	public float distance;

	public QualityLevel quality = QualityLevel.Disabled;
}


public class ParticleSystemCull : LODComponentParticleSystem
{
	public float Distance = 100f;
}


public class ParticleSystemLightCull : LODComponent
{
	public float LightCullDistance = 5f;
}


using System;
using UnityEngine;

public class ParticleSystemLOD : LODComponentParticleSystem
{
	[Serializable]
	public class State
	{
		public float distance;

		[Range(0f, 1f)]
		public float emission;
	}

	[Horizontal(1, 0)]
	public State[] States;
}


using System;
using UnityEngine;

[Serializable]
public class State
{
	public float distance;

	[Range(0f, 1f)]
	public float emission;
}


using System;
using Rust.Rendering.IndirectInstancing;
using UnityEngine;
using UnityEngine.Rendering;

public class RendererLOD : InstancedLODComponent, IBatchingHandler, IPrefabPreProcess, ICustomMaterialReplacer, IHLODMeshSource
{
	[Serializable]
	public class State
	{
		public float distance;

		public Renderer renderer;

		[NonSerialized]
		public MeshFilter filter;

		[NonSerialized]
		public ShadowCastingMode shadowMode;

		[NonSerialized]
		public bool isImpostor;

		[ReadOnly]
		public bool hasCached;

		[ReadOnly]
		public Mesh stateMesh;

		[ReadOnly]
		public Material[] stateMaterials;

		[ReadOnly]
		public ShadowCastingMode cachedShadowMode;
	}

	public float minDistanceMultiplier;

	public State[] States;

	public bool shouldNotifyOnLODChange;

	[ReadOnly]
	public MeshRenderer collapsedRenderer;

	[ReadOnly]
	public MeshFilter collapsedFilter;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public Mesh GetFinalLodMesh(out Matrix4x4 localToWorldMatrix)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		localToWorldMatrix = ((Component)this).transform.localToWorldMatrix;
		MeshFilter val2 = default(MeshFilter);
		for (int num = States.Length - 1; num >= 0; num--)
		{
			Mesh val = null;
			if ((Object)(object)States[num].renderer != (Object)null && ((Component)States[num].renderer).TryGetComponent<MeshFilter>(ref val2))
			{
				val = val2.sharedMesh;
			}
			if ((Object)(object)val != (Object)null)
			{
				localToWorldMatrix = ((Component)States[num].renderer).transform.localToWorldMatrix;
				return val;
			}
		}
		return null;
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering;

[Serializable]
public class State
{
	public float distance;

	public Renderer renderer;

	[NonSerialized]
	public MeshFilter filter;

	[NonSerialized]
	public ShadowCastingMode shadowMode;

	[NonSerialized]
	public bool isImpostor;

	[ReadOnly]
	public bool hasCached;

	[ReadOnly]
	public Mesh stateMesh;

	[ReadOnly]
	public Material[] stateMaterials;

	[ReadOnly]
	public ShadowCastingMode cachedShadowMode;
}


public static class RendererToggleDynamicEx
{
}


public class RigidbodyLOD : LODComponent
{
	public float Distance = 100f;
}


using UnityEngine;

public class SwitchLODMaterials : MonoBehaviour, IEditorComponent
{
	public Material[] materialSet1;

	public Material[] materialSet2;
}


using System;
using UnityEngine;
using UnityEngine.Rendering;

public class TreeLOD : LODComponent
{
	[Serializable]
	public class State
	{
		public float distance;

		public Renderer renderer;

		[NonSerialized]
		public MeshFilter filter;

		[NonSerialized]
		public ShadowCastingMode shadowMode;

		[NonSerialized]
		public bool isImpostor;
	}

	[Horizontal(1, 0)]
	public State[] States;

	public bool GetClosestPointOnBounds;
}


using System;
using UnityEngine;
using UnityEngine.Rendering;

[Serializable]
public class State
{
	public float distance;

	public Renderer renderer;

	[NonSerialized]
	public MeshFilter filter;

	[NonSerialized]
	public ShadowCastingMode shadowMode;

	[NonSerialized]
	public bool isImpostor;
}


using UnityEngine;

public class UndergroundLODSwitcher : MonoBehaviour, IClientComponent
{
	public LODComponent TargetComponent;
}


using UnityEngine;

public class MeshReplacement : MonoBehaviour
{
	public SkinnedMeshRenderer Female;

	internal static void Process(GameObject go, bool IsFemale)
	{
	}
}


using UnityEngine;

public class MonumentInfo : LandmarkInfo, IPrefabPreProcess
{
	[Header("MonumentInfo")]
	public MonumentType Type = MonumentType.Building;

	[InspectorFlags]
	public MonumentTier Tier = (MonumentTier)(-1);

	public int MinWorldSize;

	public Bounds Bounds = new Bounds(Vector3.zero, Vector3.zero);

	public bool HasNavmesh;

	public bool IsSafeZone;

	public bool AllowPatrolHeliCrash;

	[HideInInspector]
	public bool WantsDungeonLink;

	[HideInInspector]
	public bool HasDungeonLink;

	[HideInInspector]
	public DungeonGridInfo DungeonEntrance;

	private OBB obbBounds;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	protected override void Awake()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Awake();
		obbBounds = new OBB(((Component)this).transform.position, ((Component)this).transform.rotation, Bounds);
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.Monuments.Add(this);
		}
	}

	private void Start()
	{
	}

	public bool CheckPlacement(Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(pos, scale, rot, Bounds);
		Vector3 point = ((OBB)(ref val)).GetPoint(-1f, 0f, -1f);
		Vector3 point2 = ((OBB)(ref val)).GetPoint(-1f, 0f, 1f);
		Vector3 point3 = ((OBB)(ref val)).GetPoint(1f, 0f, -1f);
		Vector3 point4 = ((OBB)(ref val)).GetPoint(1f, 0f, 1f);
		int topology = TerrainMeta.TopologyMap.GetTopology(point);
		int topology2 = TerrainMeta.TopologyMap.GetTopology(point2);
		int topology3 = TerrainMeta.TopologyMap.GetTopology(point3);
		int topology4 = TerrainMeta.TopologyMap.GetTopology(point4);
		int num = TierToMask(Tier);
		int num2 = 0;
		if ((num & topology) != 0)
		{
			num2++;
		}
		if ((num & topology2) != 0)
		{
			num2++;
		}
		if ((num & topology3) != 0)
		{
			num2++;
		}
		if ((num & topology4) != 0)
		{
			num2++;
		}
		if (num2 < 3)
		{
			return false;
		}
		WaterBody componentInChildren = ((Component)this).GetComponentInChildren<WaterBody>();
		if ((Object)(object)componentInChildren == (Object)null || componentInChildren.Type != WaterBodyType.Lake)
		{
			return true;
		}
		if (pos.y + componentInChildren.MinWaterLevel() < 1f)
		{
			return false;
		}
		return true;
	}

	public float Distance(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((OBB)(ref obbBounds)).Distance(position);
	}

	public float SqrDistance(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((OBB)(ref obbBounds)).SqrDistance(position);
	}

	public float Distance(OBB obb)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((OBB)(ref obbBounds)).Distance(obb);
	}

	public float SqrDistance(OBB obb)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((OBB)(ref obbBounds)).SqrDistance(obb);
	}

	public bool IsInBounds(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((OBB)(ref obbBounds)).Contains(position);
	}

	public Vector3 ClosestPointOnBounds(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return ((OBB)(ref obbBounds)).ClosestPoint(position);
	}

	public PathFinder.Point GetPathFinderPoint(int res)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		float num = TerrainMeta.NormalizeX(position.x);
		float num2 = TerrainMeta.NormalizeZ(position.z);
		PathFinder.Point result = default(PathFinder.Point);
		result.x = Mathf.Clamp((int)(num * (float)res), 0, res - 1);
		result.y = Mathf.Clamp((int)(num2 * (float)res), 0, res - 1);
		return result;
	}

	public int GetPathFinderRadius(int res)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		float num = ((Bounds)(ref Bounds)).extents.x * TerrainMeta.OneOverSize.x;
		float num2 = ((Bounds)(ref Bounds)).extents.z * TerrainMeta.OneOverSize.z;
		return Mathf.CeilToInt(Mathf.Max(num, num2) * (float)res);
	}

	public float GetWidest2DBound()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		float x = ((Bounds)(ref Bounds)).size.x;
		float z = ((Bounds)(ref Bounds)).size.z;
		return Mathf.Max(x, z);
	}

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = new Color(0f, 0.7f, 1f, 0.1f);
		Gizmos.DrawCube(((Bounds)(ref Bounds)).center, ((Bounds)(ref Bounds)).size);
		Gizmos.color = new Color(0f, 0.7f, 1f, 1f);
		Gizmos.DrawWireCube(((Bounds)(ref Bounds)).center, ((Bounds)(ref Bounds)).size);
	}

	public MonumentNavMesh GetMonumentNavMesh()
	{
		return ((Component)this).GetComponent<MonumentNavMesh>();
	}

	public static int TierToMask(MonumentTier tier)
	{
		int num = 0;
		if ((tier & MonumentTier.Tier0) != 0)
		{
			num |= 0x4000000;
		}
		if ((tier & MonumentTier.Tier1) != 0)
		{
			num |= 0x8000000;
		}
		if ((tier & MonumentTier.Tier2) != 0)
		{
			num |= 0x10000000;
		}
		return num;
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		HasDungeonLink = DetermineHasDungeonLink();
		WantsDungeonLink = DetermineWantsDungeonLink();
		DungeonEntrance = FindDungeonEntrance();
	}

	private DungeonGridInfo FindDungeonEntrance()
	{
		return ((Component)this).GetComponentInChildren<DungeonGridInfo>();
	}

	private bool DetermineHasDungeonLink()
	{
		return (Object)(object)((Component)this).GetComponentInChildren<DungeonGridLink>() != (Object)null;
	}

	private bool DetermineWantsDungeonLink()
	{
		if (Type == MonumentType.WaterWell)
		{
			return false;
		}
		if (Type == MonumentType.Building && displayPhrase.token.StartsWith("mining_quarry"))
		{
			return false;
		}
		if (Type == MonumentType.Radtown && displayPhrase.token.StartsWith("swamp"))
		{
			return false;
		}
		return true;
	}

	public bool IsOilRig()
	{
		if (displayPhrase.IsValid())
		{
			return displayPhrase.english.ToLower().Contains("oil rig");
		}
		return false;
	}
}


public enum MonumentType
{
	Cave,
	Airport,
	Building,
	Town,
	Radtown,
	Lighthouse,
	WaterWell,
	Roadside,
	Mountain,
	Lake,
	Oasis,
	Canyon
}


public enum MonumentTier
{
	Tier0 = 1,
	Tier1 = 2,
	Tier2 = 4
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class PickupVolume : PrefabAttribute
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one);

	protected override Type GetIndexedType()
	{
		return typeof(PickupVolume);
	}

	public static bool Check(Vector3 position, Quaternion rotation, PickupVolume[] volumes, BaseEntity ignoreEntity = null)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < volumes.Length; i++)
		{
			if (volumes[i].CheckInternal(position, rotation, 256, ignoreEntity))
			{
				return true;
			}
		}
		return false;
	}

	protected bool CheckInternal(Vector3 position, Quaternion rotation, int mask = -1, BaseEntity ignoreEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * ((Bounds)(ref bounds)).center + worldPosition);
		if (CheckOBB(new OBB(position, ((Bounds)(ref bounds)).size, rotation * worldRotation), mask, this, ignoreEntity))
		{
			return true;
		}
		return false;
	}

	private static bool CheckOBB(OBB obb, int layerMask, PickupVolume volume)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return CheckOBB(obb, layerMask, volume, null);
	}

	private static bool CheckOBB(OBB obb, int layerMask, PickupVolume volume, BaseEntity ignoredEntity = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapOBB(obb, list, layerMask, (QueryTriggerInteraction)2);
		bool result = CheckFlags(list, volume, ignoredEntity);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public static bool CheckFlags(List<Collider> colliders, PickupVolume volume, BaseEntity ignoredEntity = null)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		foreach (Collider collider in colliders)
		{
			BaseEntity baseEntity = collider.ToBaseEntity();
			if ((!((Object)(object)baseEntity != (Object)null) || !((Object)(object)ignoredEntity != (Object)null) || !(baseEntity.net.ID == ignoredEntity.net.ID)) && (Object)(object)baseEntity != (Object)null && (Object)(object)baseEntity != (Object)(object)ignoredEntity)
			{
				return true;
			}
		}
		return false;
	}
}


using System;
using UnityEngine;

public class Prefab<T> : Prefab, IComparable<Prefab<T>> where T : Component
{
	public T Component;

	public Prefab(string name, GameObject prefab, T component, GameManager manager, PrefabAttribute.Library attribute)
		: base(name, prefab, manager, attribute)
	{
		Component = component;
	}

	public int CompareTo(Prefab<T> that)
	{
		return CompareTo((Prefab)that);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using UnityEngine;

public class Prefab : IComparable<Prefab>
{
	public uint ID;

	public string Name;

	public string Folder;

	public GameObject Object;

	public GameManager Manager;

	public PrefabAttribute.Library Attribute;

	public PrefabParameters Parameters;

	public PrefabWeight Weight;

	public int SpawnedCount;

	private TerrainAnchor[] cachedTerrainAnchors;

	private TerrainCheck[] cachedTerrainChecks;

	private TerrainFilter[] cachedTerrainFilters;

	private TerrainModifier[] cachedTerrainModifiers;

	private TerrainPlacement[] cachedTerrainPlacements;

	private WaterCheck[] cachedWaterChecks;

	private BoundsCheck[] cachedBoundsChecks;

	private DecorComponent[] cachedDecorComponents;

	private EnvironmentVolumeCheck[] cachedEnvironmentVolumeChecks;

	public static PrefabAttribute.Library DefaultAttribute => PrefabAttribute.server;

	public static GameManager DefaultManager => GameManager.server;

	public Prefab(string name, GameObject prefab, GameManager manager, PrefabAttribute.Library attribute)
	{
		ID = StringPool.Get(name);
		Name = name;
		Folder = (string.IsNullOrWhiteSpace(name) ? "" : Path.GetDirectoryName(name));
		Object = prefab;
		Manager = manager;
		Attribute = attribute;
		Parameters = (Object.op_Implicit((Object)(object)prefab) ? prefab.GetComponent<PrefabParameters>() : null);
		Weight = attribute?.Find<PrefabWeight>(ID);
	}

	public static implicit operator GameObject(Prefab prefab)
	{
		return prefab.Object;
	}

	public int CompareTo(Prefab that)
	{
		return that?.PriorityCompare(this) ?? 1;
	}

	private int PriorityCompare(Prefab that)
	{
		int num = (int)(((Object)(object)Parameters != (Object)null) ? Parameters.Priority : PrefabPriority.Default);
		int num2 = (int)(((Object)(object)that.Parameters != (Object)null) ? that.Parameters.Priority : PrefabPriority.Default);
		if (num == num2)
		{
			int spawnedCount = SpawnedCount;
			int spawnedCount2 = that.SpawnedCount;
			if (spawnedCount == spawnedCount2)
			{
				return 0;
			}
			if (spawnedCount >= spawnedCount2)
			{
				return -1;
			}
			return 1;
		}
		if (num <= num2)
		{
			return -1;
		}
		return 1;
	}

	public bool ApplyTerrainAnchors(ref Vector3 pos, Quaternion rot, Vector3 scale, TerrainAnchorMode mode, SpawnFilter filter = null)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (cachedTerrainAnchors == null)
		{
			cachedTerrainAnchors = Attribute.FindAll<TerrainAnchor>(ID);
		}
		return Object.transform.ApplyTerrainAnchors(cachedTerrainAnchors, ref pos, rot, scale, mode, filter);
	}

	public bool ApplyTerrainAnchors(ref Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter = null)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (cachedTerrainAnchors == null)
		{
			cachedTerrainAnchors = Attribute.FindAll<TerrainAnchor>(ID);
		}
		return Object.transform.ApplyTerrainAnchors(cachedTerrainAnchors, ref pos, rot, scale, filter);
	}

	public bool ApplyTerrainChecks(Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter = null)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (cachedTerrainChecks == null)
		{
			cachedTerrainChecks = Attribute.FindAll<TerrainCheck>(ID);
		}
		return Object.transform.ApplyTerrainChecks(cachedTerrainChecks, pos, rot, scale, filter);
	}

	public bool ApplyTerrainFilters(Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter = null)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (cachedTerrainFilters == null)
		{
			cachedTerrainFilters = Attribute.FindAll<TerrainFilter>(ID);
		}
		return Object.transform.ApplyTerrainFilters(cachedTerrainFilters, pos, rot, scale, filter);
	}

	public void ApplyTerrainModifiers(Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (cachedTerrainModifiers == null)
		{
			cachedTerrainModifiers = Attribute.FindAll<TerrainModifier>(ID);
		}
		Object.transform.ApplyTerrainModifiers(cachedTerrainModifiers, pos, rot, scale);
	}

	public void ApplyTerrainPlacements(Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (cachedTerrainPlacements == null)
		{
			cachedTerrainPlacements = Attribute.FindAll<TerrainPlacement>(ID);
		}
		Object.transform.ApplyTerrainPlacements(cachedTerrainPlacements, pos, rot, scale);
	}

	public bool ApplyWaterChecks(Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (cachedWaterChecks == null)
		{
			cachedWaterChecks = Attribute.FindAll<WaterCheck>(ID);
		}
		return Object.transform.ApplyWaterChecks(cachedWaterChecks, pos, rot, scale);
	}

	public bool ApplyBoundsChecks(Vector3 pos, Quaternion rot, Vector3 scale, LayerMask rejectOnLayer)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (cachedBoundsChecks == null)
		{
			cachedBoundsChecks = Attribute.FindAll<BoundsCheck>(ID);
		}
		BaseEntity component = Object.GetComponent<BaseEntity>();
		if ((Object)(object)component != (Object)null)
		{
			return component.ApplyBoundsChecks(cachedBoundsChecks, pos, rot, scale, rejectOnLayer);
		}
		return true;
	}

	public void ApplyDecorComponents(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		if (cachedDecorComponents == null)
		{
			cachedDecorComponents = Attribute.FindAll<DecorComponent>(ID);
		}
		Object.transform.ApplyDecorComponents(cachedDecorComponents, ref pos, ref rot, ref scale);
	}

	public bool ApplyEnvironmentVolumeChecks(Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (cachedEnvironmentVolumeChecks == null)
		{
			cachedEnvironmentVolumeChecks = Attribute.FindAll<EnvironmentVolumeCheck>(ID);
		}
		return Object.transform.ApplyEnvironmentVolumeChecks(cachedEnvironmentVolumeChecks, pos, rot, scale);
	}

	public bool CheckEnvironmentVolumes(Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return Object.transform.CheckEnvironmentVolumes(pos, rot, scale, type);
	}

	public bool CheckEnvironmentVolumesInsideTerrain(Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType typeRequire, EnvironmentType typeIgnore, float padding = 0f)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return Object.transform.CheckEnvironmentVolumesInsideTerrain(pos, rot, scale, typeRequire, typeIgnore, padding);
	}

	public bool CheckEnvironmentVolumesOutsideTerrain(Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType typeRequire, EnvironmentType typeIgnore, float padding = 0f)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return Object.transform.CheckEnvironmentVolumesOutsideTerrain(pos, rot, scale, typeRequire, typeIgnore, padding);
	}

	public bool CheckEnvironmentVolumesAboveAltitude(Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType typeRequire, EnvironmentType typeIgnore, float altitude = 0f)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return Object.transform.CheckEnvironmentVolumesAboveAltitude(pos, rot, scale, typeRequire, typeIgnore, altitude);
	}

	public bool CheckEnvironmentVolumesBelowAltitude(Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType typeRequire, EnvironmentType typeIgnore, float altitude = 0f)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return Object.transform.CheckEnvironmentVolumesBelowAltitude(pos, rot, scale, typeRequire, typeIgnore, altitude);
	}

	public void ApplySequenceReplacement(List<Prefab> sequence, ref Prefab replacement, Prefab[] possibleReplacements, int pathLength, int pathIndex, Vector3 position)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		PathSequence pathSequence = Attribute.Find<PathSequence>(ID);
		if (pathSequence != null)
		{
			pathSequence.ApplySequenceReplacement(sequence, ref replacement, possibleReplacements, pathLength, pathIndex, position);
		}
	}

	public GameObject Spawn(Transform transform, bool active = true)
	{
		return Manager.CreatePrefab(Name, transform, active);
	}

	public GameObject Spawn(Vector3 pos, Quaternion rot, bool active = true)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return Manager.CreatePrefab(Name, pos, rot, active);
	}

	public GameObject Spawn(Vector3 pos, Quaternion rot, Vector3 scale, bool active = true)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return Manager.CreatePrefab(Name, pos, rot, scale, active);
	}

	public BaseEntity SpawnEntity(Vector3 pos, Quaternion rot, bool active = true)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return Manager.CreateEntity(Name, pos, rot, active);
	}

	public static Prefab<T> Load<T>(uint id, GameManager manager = null, PrefabAttribute.Library attribute = null) where T : Component
	{
		if (manager == null)
		{
			manager = DefaultManager;
		}
		if (attribute == null)
		{
			attribute = DefaultAttribute;
		}
		string text = StringPool.Get(id);
		if (string.IsNullOrWhiteSpace(text))
		{
			Debug.LogWarning((object)$"Could not find path for prefab ID {id}");
			return null;
		}
		GameObject val = manager.FindPrefab(text);
		T component = val.GetComponent<T>();
		return new Prefab<T>(text, val, component, manager, attribute);
	}

	public static Prefab Load(uint id, GameManager manager = null, PrefabAttribute.Library attribute = null)
	{
		if (manager == null)
		{
			manager = DefaultManager;
		}
		if (attribute == null)
		{
			attribute = DefaultAttribute;
		}
		string text = StringPool.Get(id);
		if (string.IsNullOrWhiteSpace(text))
		{
			Debug.LogWarning((object)$"Could not find path for prefab ID {id}");
			return null;
		}
		GameObject prefab = manager.FindPrefab(text);
		return new Prefab(text, prefab, manager, attribute);
	}

	public static Prefab[] Load(string folder, GameManager manager = null, PrefabAttribute.Library attribute = null, bool useProbabilities = true, bool useWorldConfig = true)
	{
		if (string.IsNullOrEmpty(folder))
		{
			return null;
		}
		if (manager == null)
		{
			manager = DefaultManager;
		}
		if (attribute == null)
		{
			attribute = DefaultAttribute;
		}
		string[] array = FindPrefabNames(folder, useProbabilities, useWorldConfig);
		Prefab[] array2 = new Prefab[array.Length];
		for (int i = 0; i < array2.Length; i++)
		{
			string text = array[i];
			GameObject prefab = manager.FindPrefab(text);
			array2[i] = new Prefab(text, prefab, manager, attribute);
		}
		return array2;
	}

	public static Prefab<T>[] Load<T>(string folder, GameManager manager = null, PrefabAttribute.Library attribute = null, bool useProbabilities = true, bool useWorldConfig = true) where T : Component
	{
		if (string.IsNullOrEmpty(folder))
		{
			return null;
		}
		return Load<T>(FindPrefabNames(folder, useProbabilities, useWorldConfig), manager, attribute);
	}

	public static Prefab<T>[] Load<T>(string[] names, GameManager manager = null, PrefabAttribute.Library attribute = null) where T : Component
	{
		if (manager == null)
		{
			manager = DefaultManager;
		}
		if (attribute == null)
		{
			attribute = DefaultAttribute;
		}
		Prefab<T>[] array = new Prefab<T>[names.Length];
		for (int i = 0; i < array.Length; i++)
		{
			string text = names[i];
			GameObject val = manager.FindPrefab(text);
			if ((Object)(object)val == (Object)null)
			{
				Debug.LogError((object)("Can't find prefab '" + text + "'"));
			}
			T component = val.GetComponent<T>();
			array[i] = new Prefab<T>(text, val, component, manager, attribute);
		}
		return array;
	}

	public static Prefab LoadRandom(string folder, ref uint seed, GameManager manager = null, PrefabAttribute.Library attribute = null, bool useProbabilities = true)
	{
		if (string.IsNullOrEmpty(folder))
		{
			return null;
		}
		if (manager == null)
		{
			manager = DefaultManager;
		}
		if (attribute == null)
		{
			attribute = DefaultAttribute;
		}
		string[] array = FindPrefabNames(folder, useProbabilities);
		if (array.Length == 0)
		{
			return null;
		}
		string text = array[SeedRandom.Range(ref seed, 0, array.Length)];
		GameObject prefab = manager.FindPrefab(text);
		return new Prefab(text, prefab, manager, attribute);
	}

	public static Prefab<T> LoadRandom<T>(string folder, ref uint seed, GameManager manager = null, PrefabAttribute.Library attribute = null, bool useProbabilities = true) where T : Component
	{
		if (string.IsNullOrEmpty(folder))
		{
			return null;
		}
		if (manager == null)
		{
			manager = DefaultManager;
		}
		if (attribute == null)
		{
			attribute = DefaultAttribute;
		}
		string[] array = FindPrefabNames(folder, useProbabilities);
		if (array.Length == 0)
		{
			return null;
		}
		string text = array[SeedRandom.Range(ref seed, 0, array.Length)];
		GameObject val = manager.FindPrefab(text);
		T component = val.GetComponent<T>();
		return new Prefab<T>(text, val, component, manager, attribute);
	}

	private static string[] FindPrefabNames(string strPrefab, bool useProbabilities = false, bool useWorldConfig = false)
	{
		strPrefab = strPrefab.TrimEnd('/').ToLower();
		GameObject[] array = FileSystem.LoadPrefabs(strPrefab + "/");
		List<string> list = new List<string>(array.Length);
		GameObject[] array2 = array;
		foreach (GameObject val in array2)
		{
			string text = strPrefab + "/" + ((Object)val).name.ToLower() + ".prefab";
			if (useWorldConfig && !World.Config.IsPrefabAllowed(text))
			{
				continue;
			}
			if (!useProbabilities)
			{
				list.Add(text);
				continue;
			}
			PrefabParameters component = val.GetComponent<PrefabParameters>();
			float num = (Object.op_Implicit((Object)(object)component) ? component.Count : 1f);
			for (int j = 0; (float)j < num; j++)
			{
				list.Add(text);
			}
		}
		list.Sort();
		return list.ToArray();
	}
}


using System;
using UnityEngine;

public class PrefabInformation : PrefabAttribute
{
	public ItemDefinition associatedItemDefinition;

	public Phrase title;

	public Phrase description;

	public Sprite sprite;

	public bool shownOnDeathScreen;

	protected override Type GetIndexedType()
	{
		return typeof(PrefabInformation);
	}
}


using UnityEngine;

public class PrefabInstantiate : MonoBehaviour, IClientComponent
{
	public GameObjectRef Prefab;
}


public enum PrefabPriority
{
	Lowest,
	Low,
	Default,
	High,
	Highest
}


using UnityEngine;

public class PrefabParameters : MonoBehaviour
{
	public PrefabPriority Priority = PrefabPriority.Default;

	public float Count = 1f;
}


public struct PreProcessPrefabOptions
{
	public static readonly PreProcessPrefabOptions Default;

	public static readonly PreProcessPrefabOptions Default_NoResetPosition;

	public static readonly PreProcessPrefabOptions AssetSceneBundling;

	public static readonly PreProcessPrefabOptions AssetSceneRuntime;

	public bool ResetLocalTransform;

	public bool StripComponents;

	public bool StripEmptyChildren;

	public bool PreProcess;

	public bool PostProcess;

	public bool UpdateMeshCooking;

	static PreProcessPrefabOptions()
	{
		Default = new PreProcessPrefabOptions
		{
			ResetLocalTransform = true,
			StripComponents = true,
			StripEmptyChildren = true,
			PreProcess = true,
			PostProcess = true,
			UpdateMeshCooking = true
		};
		AssetSceneBundling = new PreProcessPrefabOptions
		{
			ResetLocalTransform = true,
			StripComponents = true,
			StripEmptyChildren = true,
			PreProcess = true,
			PostProcess = false,
			UpdateMeshCooking = true
		};
		AssetSceneRuntime = new PreProcessPrefabOptions
		{
			ResetLocalTransform = false,
			StripComponents = false,
			StripEmptyChildren = false,
			PreProcess = true,
			PostProcess = true,
			UpdateMeshCooking = false
		};
		Default_NoResetPosition = Default;
		Default_NoResetPosition.ResetLocalTransform = false;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.BurstCloth;
using Rust.UI;
using TMPro;
using Unity.AI.Navigation;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using UnityStandardAssets.ImageEffects;
using VLB;

public class PrefabPreProcess : IPrefabProcessor
{
	public static Type[] clientsideOnlyTypes = new Type[40]
	{
		typeof(IClientComponent),
		typeof(SkeletonSkinLod),
		typeof(ImageEffectLayer),
		typeof(NGSS_Directional),
		typeof(VolumetricDustParticles),
		typeof(VolumetricLightBeam),
		typeof(Cloth),
		typeof(TextMeshPro),
		typeof(MeshFilter),
		typeof(Renderer),
		typeof(AudioLowPassFilter),
		typeof(AudioSource),
		typeof(AudioListener),
		typeof(ParticleSystemRenderer),
		typeof(ParticleSystem),
		typeof(ParticleEmitFromParentObject),
		typeof(ImpostorShadows),
		typeof(Light),
		typeof(LODGroup),
		typeof(Animator),
		typeof(AnimationEvents),
		typeof(PlayerVoiceSpeaker),
		typeof(VoiceProcessor),
		typeof(PlayerVoiceRecorder),
		typeof(ParticleScaler),
		typeof(PostEffectsBase),
		typeof(TOD_ImageEffect),
		typeof(TOD_Scattering),
		typeof(TOD_Rays),
		typeof(Tree),
		typeof(Projector),
		typeof(HttpImage),
		typeof(EventTrigger),
		typeof(StandaloneInputModule),
		typeof(UIBehaviour),
		typeof(Canvas),
		typeof(CanvasRenderer),
		typeof(CanvasGroup),
		typeof(GraphicRaycaster),
		typeof(BurstClothConstraint)
	};

	public static Type[] serversideOnlyTypes = new Type[5]
	{
		typeof(IServerComponent),
		typeof(NavMeshLink),
		typeof(NavMeshSurface),
		typeof(NavMeshObstacle),
		typeof(NavMeshModifierVolume)
	};

	public bool isClientside;

	public bool isServerside;

	public bool isBundling;

	public Dictionary<string, GameObject> prefabList = new Dictionary<string, GameObject>(StringComparer.OrdinalIgnoreCase);

	private GameObject parentObject;

	public List<Component> destroyList = new List<Component>();

	public List<GameObject> cleanupList = new List<GameObject>();

	public PrefabPreProcess(bool clientside, bool serverside, bool bundling = false)
	{
		isClientside = clientside;
		isServerside = serverside;
		isBundling = bundling;
	}

	public GameObject Find(string strPrefab)
	{
		if (prefabList.TryGetValue(strPrefab, out var value))
		{
			if ((Object)(object)value == (Object)null)
			{
				prefabList.Remove(strPrefab);
				return null;
			}
			return value;
		}
		return null;
	}

	public bool NeedsProcessing(GameObject go, PreProcessPrefabOptions options)
	{
		if (go.CompareTag("NoPreProcessing"))
		{
			return false;
		}
		if (options.PreProcess && HasComponents<IPrefabPreProcess>(go.transform))
		{
			return true;
		}
		if (options.PostProcess && HasComponents<IPrefabPostProcess>(go.transform))
		{
			return true;
		}
		if (options.StripComponents && HasComponents<IEditorComponent>(go.transform))
		{
			return true;
		}
		if (!isClientside)
		{
			if (options.StripComponents && clientsideOnlyTypes.Any((Type type) => HasComponents(go.transform, type)))
			{
				return true;
			}
			if (options.StripComponents && HasComponents<IClientComponentEx>(go.transform))
			{
				return true;
			}
		}
		if (!isServerside)
		{
			if (options.StripComponents && serversideOnlyTypes.Any((Type type) => HasComponents(go.transform, type)))
			{
				return true;
			}
			if (options.StripComponents && HasComponents<IServerComponentEx>(go.transform))
			{
				return true;
			}
		}
		return false;
	}

	public void ProcessObject(string name, GameObject go, PreProcessPrefabOptions options)
	{
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Expected O, but got Unknown
		StringPool.Get(name);
		StripEmptyChildren stripEmptyChildren = default(StripEmptyChildren);
		bool flag = go.TryGetComponent<StripEmptyChildren>(ref stripEmptyChildren) && Render.IsInstancingEnabled;
		if (options.StripComponents)
		{
			if (!isClientside)
			{
				Type[] array = clientsideOnlyTypes;
				foreach (Type t in array)
				{
					DestroyComponents(t, go, isClientside, isServerside);
				}
				foreach (IClientComponentEx item in FindIComponents<IClientComponentEx>(go.transform))
				{
					item.PreClientComponentCull((IPrefabProcessor)(object)this);
				}
			}
			if (!isServerside)
			{
				Type[] array = serversideOnlyTypes;
				foreach (Type t2 in array)
				{
					DestroyComponents(t2, go, isClientside, isServerside);
				}
				foreach (IServerComponentEx item2 in FindIComponents<IServerComponentEx>(go.transform))
				{
					item2.PreServerComponentCull((IPrefabProcessor)(object)this);
				}
			}
			DestroyComponents(typeof(IEditorComponent), go, isClientside, isServerside);
		}
		if (options.ResetLocalTransform)
		{
			go.transform.localPosition = Vector3.zero;
			go.transform.localRotation = Quaternion.identity;
		}
		List<Transform> list = this.FindComponents<Transform>(go.transform);
		list.Reverse();
		if (options.UpdateMeshCooking)
		{
			MeshColliderCookingOptions val = (MeshColliderCookingOptions)14;
			MeshColliderCookingOptions cookingOptions = (MeshColliderCookingOptions)30;
			MeshColliderCookingOptions val2 = (MeshColliderCookingOptions)(-1);
			foreach (MeshCollider item3 in this.FindComponents<MeshCollider>(go.transform))
			{
				if (item3.cookingOptions == val || item3.cookingOptions == val2)
				{
					item3.cookingOptions = cookingOptions;
				}
			}
		}
		if (options.PreProcess)
		{
			foreach (IPrefabPreProcess item4 in FindIComponents<IPrefabPreProcess>(go.transform))
			{
				if (!isBundling || item4.CanRunDuringBundling)
				{
					item4.PreProcess((IPrefabProcessor)(object)this, go, name, isServerside, isClientside, isBundling);
					MarkPropertiesDirty((Object)item4);
				}
			}
		}
		if (options.StripEmptyChildren)
		{
			BaseEntity baseEntity = default(BaseEntity);
			foreach (Transform item5 in list)
			{
				if (!Object.op_Implicit((Object)(object)item5) || !Object.op_Implicit((Object)(object)((Component)item5).gameObject))
				{
					continue;
				}
				if (isServerside && ((Component)item5).gameObject.CompareTag("Server Cull"))
				{
					RemoveComponents(((Component)item5).gameObject);
					NominateForDeletion(((Component)item5).gameObject);
				}
				if (isClientside)
				{
					bool num = ((Component)item5).gameObject.CompareTag("Client Cull");
					bool flag2 = (Object)(object)item5 != (Object)(object)go.transform && ((Component)item5).gameObject.TryGetComponent<BaseEntity>(ref baseEntity);
					if (num || flag2)
					{
						RemoveComponents(((Component)item5).gameObject);
						NominateForDeletion(((Component)item5).gameObject);
					}
					else if (flag)
					{
						NominateForDeletion(((Component)item5).gameObject);
					}
				}
			}
		}
		RunCleanupQueue(go);
		if (!options.PostProcess)
		{
			return;
		}
		foreach (IPrefabPostProcess item6 in FindIComponents<IPrefabPostProcess>(go.transform))
		{
			item6.PostProcess((IPrefabProcessor)(object)this, go, name, isServerside, isClientside, isBundling);
		}
	}

	public void Process(string name, GameObject go)
	{
		PreProcessPrefabOptions assetSceneRuntime = PreProcessPrefabOptions.AssetSceneRuntime;
		GameObject val = go;
		if (Application.isPlaying && !val.CompareTag("NoPreProcessing"))
		{
			bool num = PrefabNeedsCopy(val);
			bool flag = NeedsProcessing(val, assetSceneRuntime);
			if (num && flag)
			{
				GameObject obj2;
				Transform val2 = (TryGetHierarchyGroup(out obj2) ? obj2.transform : null);
				go = Instantiate.GameObject(val, val2);
				((Object)go).name = ((Object)val).name;
			}
			if (flag)
			{
				ProcessObject(name, go, assetSceneRuntime);
			}
			AddPrefab(name, go);
		}
		static bool PrefabNeedsCopy(GameObject obj)
		{
			Wearable wearable = default(Wearable);
			if (obj.TryGetComponent<Wearable>(ref wearable) && !wearable.disableRigStripping)
			{
				return true;
			}
			return false;
		}
	}

	public void Invalidate(string name)
	{
		if (prefabList.TryGetValue(name, out var value))
		{
			prefabList.Remove(name);
			if ((Object)(object)value != (Object)null)
			{
				Object.DestroyImmediate((Object)(object)value, true);
			}
		}
	}

	public void InvalidateAll()
	{
		foreach (var (_, val2) in prefabList)
		{
			if ((Object)(object)val2 != (Object)null)
			{
				Object.DestroyImmediate((Object)(object)val2, true);
			}
		}
		prefabList.Clear();
	}

	private bool TryGetHierarchyGroup(out GameObject obj)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Expected O, but got Unknown
		if (isBundling || !Application.isPlaying)
		{
			obj = null;
			return false;
		}
		if ((Object)(object)parentObject == (Object)null)
		{
			string text = ((isClientside && isServerside) ? "PrefabPreProcess - Generic" : (isServerside ? "PrefabPreProcess - Server" : "PrefabPreProcess - Client"));
			parentObject = new GameObject(text);
			parentObject.SetActive(false);
			Object.DontDestroyOnLoad((Object)(object)parentObject);
		}
		obj = parentObject;
		return true;
	}

	public void AddPrefab(string name, GameObject go)
	{
		go.SetActive(false);
		prefabList.Add(name, go);
	}

	private void DestroyComponents(Type t, GameObject go, bool client, bool server)
	{
		List<Component> list = new List<Component>();
		FindComponents(go.transform, list, t);
		list.Reverse();
		RealmedRemove realmedRemove = default(RealmedRemove);
		foreach (Component item in list)
		{
			if (!item.TryGetComponent<RealmedRemove>(ref realmedRemove) || realmedRemove.ShouldDelete(item, client, server))
			{
				if (!item.gameObject.CompareTag("persist"))
				{
					NominateForDeletion(item.gameObject);
				}
				Object.DestroyImmediate((Object)(object)item, true);
			}
		}
	}

	private bool ShouldExclude(Transform transform)
	{
		BaseEntity baseEntity = default(BaseEntity);
		if (((Component)transform).TryGetComponent<BaseEntity>(ref baseEntity))
		{
			return true;
		}
		return false;
	}

	private void GatherExcludedTransf(Transform root, HashSet<Transform> excludeSet)
	{
		List<BaseEntity> list = new List<BaseEntity>();
		((Component)root).GetComponentsInChildren<BaseEntity>(true, list);
		int i = 0;
		if (list.Count > 0 && (Object)(object)((Component)list[0]).transform == (Object)(object)root)
		{
			i = 1;
		}
		for (; i < list.Count; i++)
		{
			ExcludeChildHierarchy(((Component)list[i]).transform, excludeSet);
		}
		static void ExcludeChildHierarchy(Transform transf, HashSet<Transform> set)
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Expected O, but got Unknown
			set.Add(transf);
			foreach (Transform item in transf)
			{
				ExcludeChildHierarchy(item, set);
			}
		}
	}

	private bool HasComponents<T>(Transform transform)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Expected O, but got Unknown
		T val = default(T);
		if (((Component)transform).TryGetComponent<T>(ref val))
		{
			return true;
		}
		foreach (Transform item in transform)
		{
			Transform transform2 = item;
			if (!ShouldExclude(transform2) && HasComponents<T>(transform2))
			{
				return true;
			}
		}
		return false;
	}

	private bool HasComponents(Transform transform, Type t)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Expected O, but got Unknown
		Component val = default(Component);
		if (((Component)transform).TryGetComponent(t, ref val))
		{
			return true;
		}
		foreach (Transform item in transform)
		{
			Transform transform2 = item;
			if (!ShouldExclude(transform2) && HasComponents(transform2, t))
			{
				return true;
			}
		}
		return false;
	}

	public List<T> FindComponents<T>(Transform transform) where T : Component
	{
		List<T> list = new List<T>();
		FindComponents(transform, list);
		return list;
	}

	public void FindComponents<T>(Transform transform, List<T> list) where T : Component
	{
		List<T> list2 = new List<T>();
		((Component)transform).GetComponentsInChildren<T>(true, list2);
		HashSet<Transform> hashSet = new HashSet<Transform>();
		GatherExcludedTransf(transform, hashSet);
		try
		{
			foreach (T item in list2)
			{
				Transform transform2 = ((Component)item).transform;
				if (!hashSet.Contains(transform2))
				{
					list.Add(item);
				}
			}
		}
		catch
		{
			throw;
		}
	}

	public List<T> FindIComponents<T>(Transform transform)
	{
		List<T> list = new List<T>();
		FindIComponents(transform, list);
		return list;
	}

	public void FindIComponents<T>(Transform transform, List<T> list)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Expected O, but got Unknown
		list.AddRange(((Component)transform).GetComponents<T>());
		foreach (Transform item in transform)
		{
			Transform transform2 = item;
			if (!ShouldExclude(transform2))
			{
				FindIComponents(transform2, list);
			}
		}
	}

	public List<Component> FindComponents(Transform transform, Type t)
	{
		List<Component> list = new List<Component>();
		FindComponents(transform, list, t);
		return list;
	}

	public void FindComponents(Transform transform, List<Component> list, Type t)
	{
		Component[] componentsInChildren = ((Component)transform).GetComponentsInChildren(t, true);
		HashSet<Transform> hashSet = new HashSet<Transform>();
		GatherExcludedTransf(transform, hashSet);
		Component[] array = componentsInChildren;
		foreach (Component val in array)
		{
			Transform transform2 = val.transform;
			if (!hashSet.Contains(transform2))
			{
				list.Add(val);
			}
		}
	}

	public void RemoveComponent(Component c)
	{
		if (!((Object)(object)c == (Object)null))
		{
			destroyList.Add(c);
		}
	}

	public void RemoveComponents(GameObject gameObj)
	{
		Component[] components = gameObj.GetComponents<Component>();
		foreach (Component val in components)
		{
			if (!(val is Transform))
			{
				destroyList.Add(val);
			}
		}
	}

	public void NominateForDeletion(GameObject gameObj)
	{
		cleanupList.Add(gameObj);
	}

	public void MarkPropertiesDirty(Object obj)
	{
	}

	public void RunCleanupQueue(GameObject rootGo)
	{
		foreach (Component destroy in destroyList)
		{
			Object.DestroyImmediate((Object)(object)destroy, true);
		}
		destroyList.Clear();
		foreach (GameObject cleanup in cleanupList)
		{
			if (cleanup != rootGo)
			{
				DoCleanup(cleanup);
			}
		}
		cleanupList.Clear();
	}

	public void DoCleanup(GameObject go)
	{
		if (!((Object)(object)go == (Object)null) && go.GetComponentsInChildren<Component>(true).Length <= 1)
		{
			Object.DestroyImmediate((Object)(object)go, true);
		}
	}
}


using System;
using ConVar;
using Rust;

public class PrefabWeight : PrefabAttribute
{
	public float Scale = 1f;

	public Era Era;

	protected override Type GetIndexedType()
	{
		return typeof(PrefabWeight);
	}

	public bool IsActiveInEra()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((int)Era != 0)
		{
			return Era == ConVar.Server.Era;
		}
		return true;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Armor Properties")]
public class ArmorProperties : ScriptableObject
{
	[InspectorFlags]
	public HitArea area;

	public bool Contains(HitArea hitArea)
	{
		return (area & hitArea) != 0;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Clothing Movement Properties")]
public class ClothingMovementProperties : ScriptableObject
{
	public float speedReduction;

	public float waterSpeedBonus;
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Damage Properties")]
public class DamageProperties : ScriptableObject
{
	[Serializable]
	public class HitAreaProperty
	{
		public HitArea area = HitArea.Head;

		public float damage = 1f;
	}

	public DamageProperties fallback;

	[Horizontal(1, 0)]
	public HitAreaProperty[] bones;

	public float GetMultiplier(HitArea area)
	{
		for (int i = 0; i < bones.Length; i++)
		{
			HitAreaProperty hitAreaProperty = bones[i];
			if (hitAreaProperty.area == area)
			{
				return hitAreaProperty.damage;
			}
		}
		if (!Object.op_Implicit((Object)(object)fallback))
		{
			return 1f;
		}
		return fallback.GetMultiplier(area);
	}

	public void ScaleDamage(HitInfo info)
	{
		HitArea boneArea = info.boneArea;
		if (boneArea != (HitArea)(-1) && boneArea != 0)
		{
			info.damageTypes.ScaleAll(GetMultiplier(boneArea));
		}
	}
}


using System;

[Serializable]
public class HitAreaProperty
{
	public HitArea area = HitArea.Head;

	public float damage = 1f;
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/LazyAim Properties")]
public class LazyAimProperties : ScriptableObject
{
	[Range(0f, 10f)]
	public float snapStrength = 6f;

	[Range(0f, 45f)]
	public float deadzoneAngle = 1f;
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Skeleton Properties")]
public class SkeletonProperties : ScriptableObject
{
	[Serializable]
	public class BoneProperty
	{
		public GameObject bone;

		public string boneName;

		public HitArea area;
	}

	public GameObject boneReference;

	[BoneProperty]
	public BoneProperty[] bones;

	[NonSerialized]
	private Dictionary<uint, BoneProperty> quickLookup;

	public void OnValidate()
	{
		if ((Object)(object)boneReference == (Object)null)
		{
			Debug.LogWarning((object)("boneReference is null on " + ((Object)this).name), (Object)(object)this);
			return;
		}
		List<BoneProperty> list = bones.ToList();
		foreach (Transform child in boneReference.transform.GetAllChildren())
		{
			if (list.All((BoneProperty x) => (Object)(object)x.bone != (Object)(object)((Component)child).gameObject))
			{
				list.Add(new BoneProperty
				{
					bone = ((Component)child).gameObject,
					boneName = ((Object)child).name.ToLower()
				});
			}
		}
		bones = list.ToArray();
	}

	private void BuildDictionary()
	{
		quickLookup = new Dictionary<uint, BoneProperty>();
		if ((Object)(object)boneReference == (Object)null)
		{
			Debug.LogWarning((object)("boneReference is null on " + ((Object)this).name), (Object)(object)this);
			return;
		}
		BoneProperty[] array = bones;
		foreach (BoneProperty boneProperty in array)
		{
			if (boneProperty == null || (Object)(object)boneProperty.bone == (Object)null || ((Object)boneProperty.bone).name == null)
			{
				Debug.LogWarning((object)("Bone error in SkeletonProperties.BuildDictionary for " + ((Object)boneReference).name));
				continue;
			}
			uint key = StringPool.Get(((Object)boneProperty.bone).name);
			if (!quickLookup.ContainsKey(key))
			{
				quickLookup.Add(key, boneProperty);
				continue;
			}
			string name = ((Object)boneProperty.bone).name;
			string name2 = ((Object)quickLookup[key].bone).name;
			Debug.LogWarning((object)("Duplicate bone id " + key + " for " + name + " and " + name2));
		}
	}

	public BoneProperty FindBone(uint id)
	{
		if (quickLookup == null)
		{
			BuildDictionary();
		}
		BoneProperty value = null;
		if (!quickLookup.TryGetValue(id, out value))
		{
			return null;
		}
		return value;
	}
}


using System;
using UnityEngine;

[Serializable]
public class BoneProperty
{
	public GameObject bone;

	public string boneName;

	public HitArea area;
}


using UnityEngine;

public class BonePropertyAttribute : PropertyAttribute
{
}


using UnityEngine;

public static class Radiation
{
	public enum Tier
	{
		MINIMAL,
		LOW,
		MEDIUM,
		HIGH,
		NONE
	}

	[ServerVar]
	public static bool water_loot_damage = true;

	[ServerVar]
	public static bool water_inventory_damage = true;

	public static float MaterialToRadsRatio = 0.0044f;

	[ServerVar]
	public static float materialToRadsRatio
	{
		get
		{
			return MaterialToRadsRatio;
		}
		set
		{
			MaterialToRadsRatio = value;
		}
	}

	public static float MaxExposureProtection => 0.5f;

	public static float GetRadiation(Tier tier)
	{
		return tier switch
		{
			Tier.NONE => 0f, 
			Tier.MINIMAL => 2f, 
			Tier.LOW => 10f, 
			Tier.MEDIUM => 25f, 
			Tier.HIGH => 51f, 
			_ => 1f, 
		};
	}

	public static float GetRadiationAfterProtection(float radiationAmount, float radiationProtection)
	{
		return Mathf.Clamp(radiationAmount - radiationProtection, 0f, radiationAmount);
	}
}


public enum Tier
{
	MINIMAL,
	LOW,
	MEDIUM,
	HIGH,
	NONE
}


using ConVar;
using UnityEngine;

public class RealmedCollider : BasePrefab
{
	public Collider ServerCollider;

	public Collider ClientCollider;

	public override void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(process, rootObj, name, serverside, clientside, bundling);
		if (serverside && (Object)(object)ServerCollider != (Object)(object)ClientCollider)
		{
			if (Tree.simplified_collider)
			{
				if (Object.op_Implicit((Object)(object)ClientCollider))
				{
					process.RemoveComponent((Component)(object)ClientCollider);
					ClientCollider = ServerCollider;
				}
			}
			else if (Object.op_Implicit((Object)(object)ServerCollider))
			{
				process.RemoveComponent((Component)(object)ServerCollider);
				ServerCollider = ClientCollider;
			}
		}
		process.RemoveComponent((Component)(object)this);
	}
}


using System.Linq;
using UnityEngine;

public class RealmedRemove : MonoBehaviour, IPrefabPreProcess
{
	public GameObject[] removedFromClient;

	public Component[] removedComponentFromClient;

	public GameObject[] removedFromServer;

	public Component[] removedComponentFromServer;

	public Component[] doNotRemoveFromServer;

	public Component[] doNotRemoveFromClient;

	bool IPrefabPreProcess.CanRunDuringBundling => true;

	public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (clientside)
		{
			GameObject[] array = removedFromClient;
			for (int i = 0; i < array.Length; i++)
			{
				Object.DestroyImmediate((Object)(object)array[i], true);
			}
			Component[] array2 = removedComponentFromClient;
			for (int i = 0; i < array2.Length; i++)
			{
				Object.DestroyImmediate((Object)(object)array2[i], true);
			}
		}
		if (serverside)
		{
			GameObject[] array = removedFromServer;
			for (int i = 0; i < array.Length; i++)
			{
				Object.DestroyImmediate((Object)(object)array[i], true);
			}
			Component[] array2 = removedComponentFromServer;
			for (int i = 0; i < array2.Length; i++)
			{
				Object.DestroyImmediate((Object)(object)array2[i], true);
			}
		}
		process.RemoveComponent((Component)(object)this);
	}

	public bool ShouldDelete(Component comp, bool client, bool server)
	{
		if (client && doNotRemoveFromClient != null && doNotRemoveFromClient.Contains(comp))
		{
			return false;
		}
		if (server && doNotRemoveFromServer != null && doNotRemoveFromServer.Contains(comp))
		{
			return false;
		}
		return true;
	}
}


using System;
using UnityEngine;

public class RepositionOnGroundMissing : EntityComponent<BaseEntity>, IServerComponent
{
	public GameObjectRef originalPrefab;

	public bool killIfInvalid;

	public LayerMask castLayers = LayerMask.op_Implicit(10551552);

	private void OnGroundMissing()
	{
		((FacepunchBehaviour)this).Invoke((Action)Process, 0.1f);
	}

	private void Process()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = ((Component)this).gameObject.ToBaseEntity();
		if (!((Object)(object)baseEntity == (Object)null))
		{
			BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
			Vector3 position = ((Component)baseCombatEntity).transform.position;
			Quaternion rotation = ((Component)baseCombatEntity).transform.rotation;
			if (GamePhysics.Trace(new Ray(((Component)this).transform.position, Vector3.down), 0f, out var hitInfo, 100f, LayerMask.op_Implicit(castLayers), (QueryTriggerInteraction)0))
			{
				position = ((RaycastHit)(ref hitInfo)).point;
				rotation = Quaternion.FromToRotation(((Component)baseEntity).transform.up, ((RaycastHit)(ref hitInfo)).normal) * ((Component)baseCombatEntity).transform.rotation;
			}
			else
			{
				float height = TerrainMeta.HeightMap.GetHeight(((Component)this).transform.position);
				Vector3 normal = TerrainMeta.HeightMap.GetNormal(((Component)this).transform.position);
				position = Vector3Ex.WithY(baseEntity.ServerPosition, height);
				rotation = Quaternion.LookRotation(((Component)baseEntity).transform.forward, normal);
			}
			uint prefabID = (originalPrefab.isValid ? originalPrefab.resourceID : baseEntity.prefabID);
			if (baseEntity is ContainerCorpse containerCorpse)
			{
				prefabID = containerCorpse.entityToSpawn.resourceID;
			}
			if (!ContainerCorpse.IsValidPointForEntity(prefabID, position, rotation, baseEntity) && killIfInvalid)
			{
				Debug.LogWarning((object)$"Killing {baseCombatEntity.ShortPrefabName} instead of repositioning as we couldn't find a valid position for {position}");
				baseCombatEntity.Kill();
			}
			else
			{
				baseEntity.ServerPosition = position;
				baseEntity.ServerRotation = rotation;
				baseEntity.SendNetworkUpdate();
			}
		}
	}
}


using UnityEngine;

public class RiverInfo : MonoBehaviour
{
	protected void Awake()
	{
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.RiverObjs.Add(this);
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Facepunch.Math;
using Facepunch.Rust;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using ProtoBuf;
using Rust;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;
using UnityEngine.Assertions;

public class SaveRestore : SingletonComponent<SaveRestore>
{
	[JsonModel]
	public class SaveExtraData
	{
		public string WipeId;
	}

	[CompilerGenerated]
	private sealed class <DoAutomatedSave>d__20 : IEnumerator<object>, IEnumerator, IDisposable
	{
		private int <>1__state;

		private object <>2__current;

		public bool AndWait;

		public SaveRestore <>4__this;

		private string <folder>5__2;

		object IEnumerator<object>.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		object IEnumerator.Current
		{
			[DebuggerHidden]
			get
			{
				return <>2__current;
			}
		}

		[DebuggerHidden]
		public <DoAutomatedSave>d__20(int <>1__state)
		{
			this.<>1__state = <>1__state;
		}

		[DebuggerHidden]
		void IDisposable.Dispose()
		{
		}

		private bool MoveNext()
		{
			int num = <>1__state;
			SaveRestore saveRestore = <>4__this;
			switch (num)
			{
			default:
				return false;
			case 0:
				<>1__state = -1;
				IsSaving = true;
				<folder>5__2 = ConVar.Server.rootFolder;
				if (!AndWait)
				{
					<>2__current = CoroutineEx.waitForEndOfFrame;
					<>1__state = 1;
					return true;
				}
				goto IL_0061;
			case 1:
				<>1__state = -1;
				goto IL_0061;
			case 2:
				<>1__state = -1;
				goto IL_00d0;
			case 3:
				{
					<>1__state = -1;
					break;
				}
				IL_0061:
				if (AndWait)
				{
					IEnumerator enumerator = Save(<folder>5__2 + "/" + World.SaveFileName, AndWait);
					while (enumerator.MoveNext())
					{
					}
					goto IL_00d0;
				}
				<>2__current = ((MonoBehaviour)saveRestore).StartCoroutine(Save(<folder>5__2 + "/" + World.SaveFileName, AndWait));
				<>1__state = 2;
				return true;
				IL_00d0:
				if (!AndWait)
				{
					<>2__current = CoroutineEx.waitForEndOfFrame;
					<>1__state = 3;
					return true;
				}
				break;
			}
			Debug.Log((object)"Saving complete");
			IsSaving = false;
			return false;
		}

		bool IEnumerator.MoveNext()
		{
			//ILSpy generated this explicit interface implementation from .override directive in MoveNext
			return this.MoveNext();
		}

		[DebuggerHidden]
		void IEnumerator.Reset()
		{
			throw new NotSupportedException();
		}
	}

	public static bool IsSaving = false;

	public static DateTime SaveCreatedTime;

	private static RealTimeSince TimeSinceLastSave;

	private static MemoryStream SaveBuffer = new MemoryStream(33554432);

	private static Action<Stream> onSaveComplete;

	private static object callbackLock = new object();

	private static Queue<Stream> saveQueue = new Queue<Stream>();

	private static object saveQueueLock = new object();

	public static string WipeId { get; private set; }

	public static void AddOnSaveCallback(Action<Stream> callback)
	{
		lock (callbackLock)
		{
			onSaveComplete = (Action<Stream>)Delegate.Combine(onSaveComplete, callback);
		}
	}

	public static void RemoveOnSaveCallback(Action<Stream> callback)
	{
		lock (callbackLock)
		{
			onSaveComplete = (Action<Stream>)Delegate.Remove(onSaveComplete, callback);
		}
	}

	public static IEnumerator Save(string strFilename, bool AndWait = false)
	{
		if (Application.isQuitting)
		{
			yield break;
		}
		Stopwatch timerCache = new Stopwatch();
		Stopwatch timerWrite = new Stopwatch();
		Stopwatch timerDisk = new Stopwatch();
		SaveBuffer.Position = 0L;
		SaveBuffer.SetLength(0L);
		InitializeWipeId();
		if (AndWait)
		{
			IEnumerator enumerator = WarmUpEntityCaches(AndWait, timerCache);
			while (enumerator.MoveNext())
			{
			}
		}
		else
		{
			yield return ((MonoBehaviour)SingletonComponent<SaveRestore>.Instance).StartCoroutine(WarmUpEntityCaches(AndWait, timerCache));
		}
		timerWrite.Start();
		int iEnts = 0;
		TimeWarning val = TimeWarning.New("SaveWrite", 100);
		try
		{
			BinaryWriter writer = new BinaryWriter(SaveBuffer);
			WriteHeader(writer);
			if (!AndWait)
			{
				yield return CoroutineEx.waitForEndOfFrame;
			}
			iEnts = WriteEntities(writer);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		timerWrite.Stop();
		if (!AndWait)
		{
			yield return CoroutineEx.waitForEndOfFrame;
		}
		timerDisk.Start();
		TimeWarning val2 = TimeWarning.New("SaveBackup", 100);
		try
		{
			ShiftSaveBackups(strFilename);
		}
		finally
		{
			((IDisposable)val2)?.Dispose();
		}
		val2 = TimeWarning.New("SaveDisk", 100);
		try
		{
			string text = strFilename + ".new";
			if (File.Exists(text))
			{
				File.Delete(text);
			}
			try
			{
				using FileStream destination = File.OpenWrite(text);
				SaveBuffer.Position = 0L;
				SaveBuffer.CopyTo(destination);
			}
			catch (Exception ex)
			{
				Debug.LogError((object)("Couldn't write save file! We got an exception: " + ex));
				if (File.Exists(text))
				{
					File.Delete(text);
				}
				yield break;
			}
			File.Copy(text, strFilename, overwrite: true);
			File.Delete(text);
		}
		catch (Exception ex2)
		{
			Debug.LogError((object)("Error when saving to disk: " + ex2));
			yield break;
		}
		finally
		{
			((IDisposable)val2)?.Dispose();
		}
		timerDisk.Stop();
		Debug.LogFormat("Saved {0} ents, cache({1}), write({2}), disk({3}).", new object[4]
		{
			iEnts.ToString("N0"),
			timerCache.Elapsed.TotalSeconds.ToString("0.00"),
			timerWrite.Elapsed.TotalSeconds.ToString("0.00"),
			timerDisk.Elapsed.TotalSeconds.ToString("0.00")
		});
		PerformanceLogging.server?.SetTiming("save.cache", timerCache.Elapsed);
		PerformanceLogging.server?.SetTiming("save.write", timerWrite.Elapsed);
		PerformanceLogging.server?.SetTiming("save.disk", timerDisk.Elapsed);
		NexusServer.PostGameSaved();
	}

	private static IEnumerator SaveToStream(Stream stream)
	{
		InitializeWipeId();
		yield return ((MonoBehaviour)SingletonComponent<SaveRestore>.Instance).StartCoroutine(WarmUpEntityCaches());
		TimeWarning val = TimeWarning.New("SaveWrite", 100);
		try
		{
			BinaryWriter writer = new BinaryWriter(stream);
			WriteHeader(writer);
			yield return CoroutineEx.waitForEndOfFrame;
			WriteEntities(writer);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		Action<Stream> action;
		lock (callbackLock)
		{
			action = onSaveComplete;
		}
		action(stream);
	}

	private static void ShiftSaveBackups(string fileName)
	{
		int num = Mathf.Max(ConVar.Server.saveBackupCount, 2);
		if (!File.Exists(fileName))
		{
			return;
		}
		try
		{
			int num2 = 0;
			for (int j = 1; j <= num; j++)
			{
				if (!File.Exists(fileName + "." + j))
				{
					break;
				}
				num2++;
			}
			string text = GetBackupName(num2 + 1);
			for (int num3 = num2; num3 > 0; num3--)
			{
				string text2 = GetBackupName(num3);
				if (num3 == num)
				{
					File.Delete(text2);
				}
				else if (File.Exists(text2))
				{
					if (File.Exists(text))
					{
						File.Delete(text);
					}
					File.Move(text2, text);
				}
				text = text2;
			}
			File.Copy(fileName, text, overwrite: true);
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Error while backing up old saves: " + ex.Message));
			Debug.LogException(ex);
			throw;
		}
		string GetBackupName(int i)
		{
			return $"{fileName}.{i}";
		}
	}

	private void Start()
	{
		((MonoBehaviour)this).StartCoroutine(SaveRegularly());
		((MonoBehaviour)this).StartCoroutine(ProcessStreamRequests());
	}

	private IEnumerator SaveRegularly()
	{
		while (true)
		{
			yield return CoroutineEx.waitForSeconds(1f);
			if (RealTimeSince.op_Implicit(TimeSinceLastSave) >= (float)ConVar.Server.saveinterval || NexusServer.NeedsJournalFlush || NexusServer.NeedTransferFlush)
			{
				yield return ((MonoBehaviour)this).StartCoroutine(DoAutomatedSave());
				TimeSinceLastSave = RealTimeSince.op_Implicit(0f);
			}
		}
	}

	private IEnumerator ProcessStreamRequests()
	{
		while (true)
		{
			yield return CoroutineEx.waitForEndOfFrame;
			bool flag = false;
			Stream result = null;
			lock (saveQueueLock)
			{
				flag = saveQueue.TryDequeue(out result);
			}
			if (flag)
			{
				((MonoBehaviour)this).StartCoroutine(SaveToStream(result));
			}
		}
	}

	[IteratorStateMachine(typeof(<DoAutomatedSave>d__20))]
	private IEnumerator DoAutomatedSave(bool AndWait = false)
	{
		Interface.CallHook("OnServerSave");
		return new <DoAutomatedSave>d__20(0)
		{
			<>4__this = this,
			AndWait = AndWait
		};
	}

	public static bool Save(bool AndWait)
	{
		if ((Object)(object)SingletonComponent<SaveRestore>.Instance == (Object)null)
		{
			return false;
		}
		if (IsSaving)
		{
			return false;
		}
		IEnumerator enumerator = SingletonComponent<SaveRestore>.Instance.DoAutomatedSave(AndWait: true);
		while (enumerator.MoveNext())
		{
		}
		return true;
	}

	public static void RequestSave(Stream stream)
	{
		lock (saveQueueLock)
		{
			saveQueue.Enqueue(stream);
		}
	}

	private static IEnumerator WarmUpEntityCaches(bool isBlocking = false, Stopwatch cacheTimer = null)
	{
		cacheTimer?.Start();
		TimeWarning val = TimeWarning.New("SaveCache", 100);
		try
		{
			Stopwatch sw = Stopwatch.StartNew();
			BaseEntity[] array = BaseEntity.saveList.ToArray();
			foreach (BaseEntity baseEntity in array)
			{
				if ((Object)(object)baseEntity == (Object)null || !baseEntity.IsValid())
				{
					continue;
				}
				try
				{
					baseEntity.GetSaveCache();
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
				}
				if (sw.Elapsed.TotalMilliseconds > (double)ConVar.Server.saveframebudget)
				{
					if (!isBlocking)
					{
						yield return CoroutineEx.waitForEndOfFrame;
					}
					sw.Reset();
					sw.Start();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		cacheTimer?.Stop();
	}

	private static void WriteHeader(BinaryWriter writer)
	{
		writer.Write((sbyte)83);
		writer.Write((sbyte)65);
		writer.Write((sbyte)86);
		writer.Write((sbyte)82);
		SaveExtraData saveExtraData = new SaveExtraData();
		saveExtraData.WipeId = WipeId;
		writer.Write((sbyte)74);
		writer.Write(JsonConvert.SerializeObject((object)saveExtraData));
		writer.Write((sbyte)68);
		writer.Write(Epoch.FromDateTime(SaveCreatedTime));
		writer.Write(272u);
	}

	private static int WriteEntities(BinaryWriter writer)
	{
		int num = 0;
		foreach (BaseEntity save in BaseEntity.saveList)
		{
			if ((Object)(object)save == (Object)null || save.IsDestroyed)
			{
				Debug.LogWarning((object)("Entity is NULL but is still in saveList - not destroyed properly? " + (object)save), (Object)(object)save);
				continue;
			}
			MemoryStream memoryStream = null;
			try
			{
				memoryStream = save.GetSaveCache();
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
			if (memoryStream == null || memoryStream.Length <= 0)
			{
				Debug.LogWarningFormat("Skipping saving entity {0} - because {1}", new object[2]
				{
					save,
					(memoryStream == null) ? "savecache is null" : "savecache is 0"
				});
			}
			else
			{
				writer.Write((uint)memoryStream.Length);
				writer.Write(memoryStream.GetBuffer(), 0, (int)memoryStream.Length);
				num++;
			}
		}
		return num;
	}

	public static List<BaseEntity> FindMapEntities()
	{
		return new List<BaseEntity>(Object.FindObjectsOfType<BaseEntity>());
	}

	public static void ClearMapEntities(List<BaseEntity> entities)
	{
		int count = entities.Count;
		DebugEx.Log((object)("Destroying " + count + " old entities"), (StackTraceLogType)0);
		Stopwatch stopwatch = Stopwatch.StartNew();
		for (int num = count - 1; num >= 0; num--)
		{
			BaseEntity baseEntity = entities[num];
			if (baseEntity.enableSaving || !((Object)(object)((Component)baseEntity).GetComponent<DisableSave>() != (Object)null))
			{
				baseEntity.KillAsMapEntity();
				if (stopwatch.Elapsed.TotalMilliseconds > 2000.0)
				{
					stopwatch.Reset();
					stopwatch.Start();
					DebugEx.Log((object)("\t" + (count - num) + " / " + count), (StackTraceLogType)0);
				}
				entities.RemoveAt(num);
			}
		}
		ItemManager.Heartbeat();
		DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
	}

	public static void SpawnMapEntities(List<BaseEntity> entities)
	{
		DebugEx.Log((object)("Spawning " + entities.Count + " entities from map"), (StackTraceLogType)0);
		foreach (BaseEntity entity in entities)
		{
			if (!((Object)(object)entity == (Object)null))
			{
				entity.SpawnAsMapEntity();
			}
		}
		DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
		DebugEx.Log((object)("Postprocessing " + entities.Count + " entities from map"), (StackTraceLogType)0);
		foreach (BaseEntity entity2 in entities)
		{
			if (!((Object)(object)entity2 == (Object)null))
			{
				entity2.PostMapEntitySpawn();
			}
		}
		DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
	}

	public static bool Load(string strFilename = "", bool allowOutOfDateSaves = false)
	{
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0380: Unknown result type (might be due to invalid IL or missing references)
		//IL_0301: Unknown result type (might be due to invalid IL or missing references)
		//IL_0306: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ec: Unknown result type (might be due to invalid IL or missing references)
		SaveCreatedTime = DateTime.UtcNow;
		try
		{
			if (strFilename == "")
			{
				strFilename = World.SaveFolderName + "/" + World.SaveFileName;
			}
			if (!File.Exists(strFilename))
			{
				Interface.CallHook("OnNewSave", (object)strFilename);
				if (!File.Exists("TestSaves/" + strFilename))
				{
					Debug.LogWarning((object)("Couldn't load " + strFilename + " - file doesn't exist"));
					return false;
				}
				strFilename = "TestSaves/" + strFilename;
			}
			List<BaseEntity> list = FindMapEntities();
			Dictionary<BaseEntity, Entity> dictionary = new Dictionary<BaseEntity, Entity>();
			using (FileStream fileStream = File.OpenRead(strFilename))
			{
				using BinaryReader binaryReader = new BinaryReader(fileStream);
				SaveCreatedTime = File.GetCreationTime(strFilename);
				if (binaryReader.ReadSByte() != 83 || binaryReader.ReadSByte() != 65 || binaryReader.ReadSByte() != 86 || binaryReader.ReadSByte() != 82)
				{
					Debug.LogWarning((object)"Invalid save (missing header)");
					return false;
				}
				if (binaryReader.PeekChar() == 74)
				{
					binaryReader.ReadChar();
					WipeId = JsonConvert.DeserializeObject<SaveExtraData>(binaryReader.ReadString()).WipeId;
				}
				if (binaryReader.PeekChar() == 68)
				{
					binaryReader.ReadChar();
					SaveCreatedTime = Epoch.ToDateTime((long)binaryReader.ReadInt32());
				}
				if (binaryReader.ReadUInt32() != 272)
				{
					if (allowOutOfDateSaves)
					{
						Debug.LogWarning((object)"This save is from an older (possibly incompatible) version!");
					}
					else
					{
						Debug.LogWarning((object)"This save is from an older version. It might not load properly.");
					}
				}
				ClearMapEntities(list);
				Assert.IsTrue(BaseEntity.saveList.Count == 0, "BaseEntity.saveList isn't empty!");
				Net.sv.Reset();
				Application.isLoadingSave = true;
				HashSet<NetworkableId> hashSet = new HashSet<NetworkableId>();
				while (fileStream.Position < fileStream.Length)
				{
					RCon.Update();
					uint num = binaryReader.ReadUInt32();
					long position = fileStream.Position;
					Entity entData = Pool.Get<Entity>();
					try
					{
						ProtoStreamExtensions.ReadFromStream((IProto)(object)entData, (Stream)fileStream, (int)num, false);
					}
					catch (Exception ex)
					{
						Debug.LogWarning((object)("Skipping entity since it could not be deserialized - stream position: " + position + " size: " + num));
						Debug.LogException(ex);
						fileStream.Position = position + num;
						Pool.Free<Entity>(ref entData);
						continue;
					}
					NetworkableId uid;
					if (entData.basePlayer != null && dictionary.Any((KeyValuePair<BaseEntity, Entity> x) => x.Value.basePlayer != null && x.Value.basePlayer.userid == entData.basePlayer.userid))
					{
						string[] obj = new string[5] { "Skipping entity ", null, null, null, null };
						uid = entData.baseNetworkable.uid;
						obj[1] = ((object)(NetworkableId)(ref uid)/*cast due to .constrained prefix*/).ToString();
						obj[2] = " - it's a player ";
						obj[3] = entData.basePlayer.userid.ToString();
						obj[4] = " who is in the save multiple times";
						Debug.LogWarning((object)string.Concat(obj));
						Pool.Free<Entity>(ref entData);
					}
					else if (((NetworkableId)(ref entData.baseNetworkable.uid)).IsValid && hashSet.Contains(entData.baseNetworkable.uid))
					{
						string[] obj2 = new string[5] { "Skipping entity ", null, null, null, null };
						uid = entData.baseNetworkable.uid;
						obj2[1] = ((object)(NetworkableId)(ref uid)/*cast due to .constrained prefix*/).ToString();
						obj2[2] = " ";
						obj2[3] = StringPool.Get(entData.baseNetworkable.prefabID);
						obj2[4] = " - uid is used multiple times";
						Debug.LogWarning((object)string.Concat(obj2));
						Pool.Free<Entity>(ref entData);
					}
					else
					{
						if (((NetworkableId)(ref entData.baseNetworkable.uid)).IsValid)
						{
							hashSet.Add(entData.baseNetworkable.uid);
						}
						BaseEntity baseEntity = GameManager.server.CreateEntity(StringPool.Get(entData.baseNetworkable.prefabID), entData.baseEntity.pos, Quaternion.Euler(entData.baseEntity.rot));
						if (Object.op_Implicit((Object)(object)baseEntity))
						{
							baseEntity.InitLoad(entData.baseNetworkable.uid);
							baseEntity.PreServerLoad();
							dictionary.Add(baseEntity, entData);
						}
					}
				}
			}
			DebugEx.Log((object)("Spawning " + list.Count + " entities from map"), (StackTraceLogType)0);
			foreach (BaseEntity item in list)
			{
				if (!((Object)(object)item == (Object)null))
				{
					item.SpawnAsMapEntity();
				}
			}
			DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
			DebugEx.Log((object)("Spawning " + dictionary.Count + " entities from save"), (StackTraceLogType)0);
			object obj3 = Interface.CallHook("OnSaveLoad", (object)dictionary);
			if (obj3 is bool)
			{
				return (bool)obj3;
			}
			BaseNetworkable.LoadInfo info = default(BaseNetworkable.LoadInfo);
			info.fromDisk = true;
			Stopwatch stopwatch = Stopwatch.StartNew();
			int num2 = 0;
			foreach (KeyValuePair<BaseEntity, Entity> item2 in dictionary)
			{
				BaseEntity key = item2.Key;
				if ((Object)(object)key == (Object)null)
				{
					continue;
				}
				RCon.Update();
				info.msg = item2.Value;
				key.Spawn();
				key.Load(info);
				if (key.IsValid())
				{
					num2++;
					if (stopwatch.Elapsed.TotalMilliseconds > 2000.0)
					{
						stopwatch.Reset();
						stopwatch.Start();
						DebugEx.Log((object)("\t" + num2 + " / " + dictionary.Count), (StackTraceLogType)0);
					}
				}
			}
			DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
			DebugEx.Log((object)("Postprocessing " + list.Count + " entities from map"), (StackTraceLogType)0);
			foreach (BaseEntity item3 in list)
			{
				if (!((Object)(object)item3 == (Object)null))
				{
					item3.PostMapEntitySpawn();
				}
			}
			DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
			DebugEx.Log((object)("Postprocessing " + list.Count + " entities from save"), (StackTraceLogType)0);
			foreach (KeyValuePair<BaseEntity, Entity> item4 in dictionary)
			{
				BaseEntity key2 = item4.Key;
				if (!((Object)(object)key2 == (Object)null))
				{
					RCon.Update();
					if (key2.IsValid())
					{
						key2.UpdateNetworkGroup();
						key2.PostServerLoad();
					}
				}
			}
			DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
			foreach (KeyValuePair<BaseEntity, Entity> item5 in dictionary)
			{
				Entity value = item5.Value;
				Pool.Free<Entity>(ref value);
			}
			dictionary.Clear();
			if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
			{
				DebugEx.Log((object)"Enforcing SpawnPopulation Limits", (StackTraceLogType)0);
				SingletonComponent<SpawnHandler>.Instance.EnforceLimits();
				DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
			}
			InitializeWipeId();
			Application.isLoadingSave = false;
			return true;
		}
		catch (Exception ex2)
		{
			Debug.LogWarning((object)("Error loading save (" + strFilename + ")"));
			Debug.LogException(ex2);
			return false;
		}
	}

	public static void GetSaveCache()
	{
		BaseEntity[] array = BaseEntity.saveList.ToArray();
		if (array.Length == 0)
		{
			return;
		}
		DebugEx.Log((object)("Initializing " + array.Length + " entity save caches"), (StackTraceLogType)0);
		Stopwatch stopwatch = Stopwatch.StartNew();
		for (int i = 0; i < array.Length; i++)
		{
			BaseEntity baseEntity = array[i];
			if (baseEntity.IsValid())
			{
				baseEntity.GetSaveCache();
				if (stopwatch.Elapsed.TotalMilliseconds > 2000.0)
				{
					stopwatch.Reset();
					stopwatch.Start();
					DebugEx.Log((object)("\t" + (i + 1) + " / " + array.Length), (StackTraceLogType)0);
				}
			}
		}
		DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
	}

	public static void InitializeEntityLinks()
	{
		BaseEntity[] array = (from x in BaseNetworkable.serverEntities
			where x is BaseEntity
			select x as BaseEntity).ToArray();
		if (array.Length == 0)
		{
			return;
		}
		DebugEx.Log((object)("Initializing " + array.Length + " entity links"), (StackTraceLogType)0);
		Stopwatch stopwatch = Stopwatch.StartNew();
		for (int i = 0; i < array.Length; i++)
		{
			RCon.Update();
			array[i].RefreshEntityLinks();
			if (stopwatch.Elapsed.TotalMilliseconds > 2000.0)
			{
				stopwatch.Reset();
				stopwatch.Start();
				DebugEx.Log((object)("\t" + (i + 1) + " / " + array.Length), (StackTraceLogType)0);
			}
		}
		DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
	}

	public static void InitializeEntitySupports()
	{
		if (!ConVar.Server.stability)
		{
			return;
		}
		StabilityEntity[] array = (from x in BaseNetworkable.serverEntities
			where x is StabilityEntity
			select x as StabilityEntity).ToArray();
		if (array.Length == 0)
		{
			return;
		}
		DebugEx.Log((object)("Initializing " + array.Length + " stability supports"), (StackTraceLogType)0);
		Stopwatch stopwatch = Stopwatch.StartNew();
		for (int i = 0; i < array.Length; i++)
		{
			RCon.Update();
			array[i].InitializeSupports();
			if (stopwatch.Elapsed.TotalMilliseconds > 2000.0)
			{
				stopwatch.Reset();
				stopwatch.Start();
				DebugEx.Log((object)("\t" + (i + 1) + " / " + array.Length), (StackTraceLogType)0);
			}
		}
		DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
	}

	public static void InitializeEntityConditionals()
	{
		BuildingBlock[] array = (from x in BaseNetworkable.serverEntities
			where x is BuildingBlock
			select x as BuildingBlock).ToArray();
		if (array.Length == 0)
		{
			return;
		}
		DebugEx.Log((object)("Initializing " + array.Length + " conditional models"), (StackTraceLogType)0);
		Stopwatch stopwatch = Stopwatch.StartNew();
		for (int i = 0; i < array.Length; i++)
		{
			RCon.Update();
			array[i].UpdateSkin(force: true);
			if (stopwatch.Elapsed.TotalMilliseconds > 2000.0)
			{
				stopwatch.Reset();
				stopwatch.Start();
				DebugEx.Log((object)("\t" + (i + 1) + " / " + array.Length), (StackTraceLogType)0);
			}
		}
		DebugEx.Log((object)"\tdone.", (StackTraceLogType)0);
	}

	public static void InitializeWipeId()
	{
		if (WipeId == null)
		{
			WipeId = Guid.NewGuid().ToString("N");
		}
	}
}


[JsonModel]
public class SaveExtraData
{
	public string WipeId;
}


using UnityEngine;

public class SceneToPrefab : MonoBehaviour, IEditorComponent
{
	public bool flattenHierarchy;

	public GameObject outputPrefab;

	[Tooltip("If true the HLOD generation will be skipped and the previous results will be used, good to use if non-visual changes were made (eg.triggers)")]
	public bool skipAllHlod;
}


using UnityEngine;

public class SceneToPrefabTag : MonoBehaviour, IEditorComponent
{
	public enum TagType
	{
		ForceInclude,
		ForceExclude,
		SingleMaterial,
		UseSpecificLOD
	}

	public TagType Type;

	public int SpecificLOD;
}


public enum TagType
{
	ForceInclude,
	ForceExclude,
	SingleMaterial,
	UseSpecificLOD
}


using System;
using Facepunch;
using UnityEngine;
using UnityEngine.UI;

public class SkinViewer : FacepunchBehaviour
{
	[Serializable]
	public class SkinViewItem
	{
		public RawImage target;

		public ItemDefinition itemDef;

		public ulong skinID;
	}

	[SerializeField]
	private Camera cam;

	[SerializeField]
	private Transform positionParent;

	[SerializeField]
	private Transform modelParent;

	[SerializeField]
	private GameObject[] lights;

	[SerializeField]
	private SkinSetCollection skin;

	[SerializeField]
	private float rotateResetSpeed = 200f;

	[SerializeField]
	private float dragSpeed = 0.33f;

	[SerializeField]
	private bool autoSpin;

	[SerializeField]
	private float timeoutSeconds = 15f;

	[SerializeField]
	private Skeleton skinViewerSkeleton;
}


using System;
using UnityEngine.UI;

[Serializable]
public class SkinViewItem
{
	public RawImage target;

	public ItemDefinition itemDef;

	public ulong skinID;
}


using UnityEngine;

public class SkinViewerTesting : FacepunchBehaviour
{
	[SerializeField]
	private GameObjectRef skinViewerPrefab;

	[SerializeField]
	private SkinViewer.SkinViewItem[] panels;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class ConvarControlledSpawnPointPopulation : ConvarControlledSpawnPopulation
{
	public BaseSpawnPoint.SpawnPointType spawnPointType;

	[NonSerialized]
	private List<BaseSpawnPoint> spawnPoints;

	protected override bool Initialize()
	{
		TryGetSpawnPoints(out spawnPoints);
		return base.Initialize();
	}

	public override bool GetSpawnPosOverride(Prefab<Spawnable> prefab, ref Vector3 newPos, ref Quaternion newRot)
	{
		if (spawnPoints == null || spawnPoints.Count == 0)
		{
			return false;
		}
		int num = Random.Range(0, spawnPoints.Count);
		for (int i = 0; i < spawnPoints.Count; i++)
		{
			num++;
			if (num >= spawnPoints.Count)
			{
				num = 0;
			}
			BaseSpawnPoint baseSpawnPoint = spawnPoints[num];
			prefab = Prefabs[Random.Range(0, Prefabs.Length)];
			if ((Object)(object)baseSpawnPoint != (Object)null && baseSpawnPoint.IsAvailableTo(prefab.Object))
			{
				baseSpawnPoint.GetLocation(out newPos, out newRot);
				return true;
			}
		}
		return false;
	}

	private bool TryGetSpawnPoints(out List<BaseSpawnPoint> result)
	{
		return BaseSpawnPoint.spawnPoints.TryGetValue(spawnPointType, out result);
	}
}


using UnityEngine;
using UnityEngine.Assertions;

[CreateAssetMenu(menuName = "Rust/Convar Controlled Spawn Population")]
public class ConvarControlledSpawnPopulation : DensitySpawnPopulation
{
	[Header("Convars")]
	public string PopulationConvar;

	private Command _command;

	protected Command Command
	{
		get
		{
			if (_command == null)
			{
				_command = Server.Find(PopulationConvar);
				Assert.IsNotNull<Command>(_command, $"{this} has missing convar {PopulationConvar}");
			}
			return _command;
		}
	}

	public override float TargetDensity => Command.AsFloat;
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class ConvarControlledSpawnPopulationRail : ConvarControlledSpawnPopulation
{
	private const float MIN_MARGIN = 75f;

	public override bool GetSpawnPosOverride(Prefab<Spawnable> prefab, ref Vector3 newPos, ref Quaternion newRot)
	{
		if (TrainTrackSpline.SidingSplines.Count <= 0)
		{
			return false;
		}
		TrainCar component = prefab.Object.GetComponent<TrainCar>();
		if ((Object)(object)component == (Object)null)
		{
			Debug.LogError((object)(((object)this).GetType().Name + ": Train prefab has no TrainCar component: " + ((Object)prefab.Object).name));
			return false;
		}
		int num = 0;
		foreach (TrainTrackSpline sidingSpline in TrainTrackSpline.SidingSplines)
		{
			if (sidingSpline.HasAnyUsersOfType(TrainCar.TrainCarType.Engine))
			{
				num++;
			}
		}
		bool flag = component.CarType == TrainCar.TrainCarType.Engine;
		int num2 = 0;
		while (num2 < 20)
		{
			num2++;
			TrainTrackSpline trainTrackSpline = null;
			if (flag)
			{
				foreach (TrainTrackSpline sidingSpline2 in TrainTrackSpline.SidingSplines)
				{
					if (!sidingSpline2.HasAnyUsersOfType(TrainCar.TrainCarType.Engine))
					{
						trainTrackSpline = sidingSpline2;
						break;
					}
				}
			}
			if ((Object)(object)trainTrackSpline == (Object)null)
			{
				int index = Random.Range(0, TrainTrackSpline.SidingSplines.Count);
				trainTrackSpline = TrainTrackSpline.SidingSplines[index];
			}
			if ((Object)(object)trainTrackSpline != (Object)null && TryGetRandomPointOnSpline(trainTrackSpline, component, out newPos, out newRot))
			{
				return true;
			}
		}
		return false;
	}

	public override void SubFill(SpawnHandler spawnHandler, SpawnDistribution distribution, int numToFill, bool initialSpawn)
	{
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		base.SubFill(spawnHandler, distribution, numToFill, initialSpawn);
		List<Prefab<Spawnable>> list = Pool.Get<List<Prefab<Spawnable>>>();
		Prefab<Spawnable>[] prefabs = Prefabs;
		foreach (Prefab<Spawnable> prefab in prefabs)
		{
			TrainCar component = prefab.Object.GetComponent<TrainCar>();
			if ((Object)(object)component != (Object)null && component.CarType == TrainCar.TrainCarType.Engine)
			{
				list.Add(prefab);
			}
		}
		foreach (TrainTrackSpline sidingSpline in TrainTrackSpline.SidingSplines)
		{
			if (sidingSpline.HasAnyUsersOfType(TrainCar.TrainCarType.Engine))
			{
				continue;
			}
			int num = Random.Range(0, list.Count);
			Prefab<Spawnable> prefab2 = Prefabs[num];
			TrainCar component2 = prefab2.Object.GetComponent<TrainCar>();
			if ((Object)(object)component2 == (Object)null)
			{
				continue;
			}
			int num2 = 0;
			while (num2 < 20)
			{
				num2++;
				if (TryGetRandomPointOnSpline(sidingSpline, component2, out var pos, out var rot))
				{
					spawnHandler.Spawn(this, prefab2, pos, rot);
					break;
				}
			}
		}
		Pool.FreeUnmanaged<Prefab<Spawnable>>(ref list);
	}

	protected override float GetPrefabWeight(Prefab<Spawnable> prefab)
	{
		float num = (Object.op_Implicit((Object)(object)prefab.Parameters) ? prefab.Parameters.Count : 1f);
		TrainCar component = prefab.Object.GetComponent<TrainCar>();
		if ((Object)(object)component != (Object)null)
		{
			if (component.CarType == TrainCar.TrainCarType.Wagon)
			{
				num *= (float)TrainCar.wagons_per_engine;
			}
		}
		else
		{
			Debug.LogError((object)(((object)this).GetType().Name + ": No TrainCar script on train prefab " + ((Object)prefab.Object).name));
		}
		return num;
	}

	private bool TryGetRandomPointOnSpline(TrainTrackSpline spline, TrainCar trainCar, out Vector3 pos, out Quaternion rot)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		float length = spline.GetLength();
		if (length < 80f)
		{
			pos = Vector3.zero;
			rot = Quaternion.identity;
			return false;
		}
		float distance = Random.Range(75f, length - 75f);
		pos = spline.GetPointAndTangentCubicHermiteWorld(distance, out var tangent) + Vector3.up * 0.5f;
		rot = Quaternion.LookRotation(tangent);
		float radius = Vector3Ex.Max(((Bounds)(ref trainCar.bounds)).extents);
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(pos, radius, list, 32768, (QueryTriggerInteraction)1);
		bool result = true;
		foreach (Collider item in list)
		{
			if (!trainCar.ColliderIsPartOfTrain(item))
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}
}


using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(menuName = "Rust/Density Spawn Population")]
public class DensitySpawnPopulation : SpawnPopulationBase
{
	[FormerlySerializedAs("TargetDensity")]
	[Tooltip("Usually per square km")]
	[Header("Spawn Info")]
	[SerializeField]
	public float _targetDensity = 1f;

	public int ClusterSizeMin = 1;

	public int ClusterSizeMax = 1;

	public int ClusterDithering;

	public int SpawnAttemptsInitial = 20;

	public int SpawnAttemptsRepeating = 10;

	public bool ScaleWithLargeMaps = true;

	public bool ScaleWithSpawnFilter = true;

	public bool AlignToNormal;

	public SpawnFilter Filter = new SpawnFilter();

	public float FilterCutoff;

	public float FilterRadius;

	public bool FilterOutTutorialIslands;

	public MonumentType[] FilterOutMonuments;

	public float NpcRadiusCheckDistance;

	private int sumToSpawn;

	public virtual float TargetDensity => _targetDensity;

	public override void SubFill(SpawnHandler spawnHandler, SpawnDistribution distribution, int numToFill, bool initialSpawn)
	{
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Max((float)ClusterSizeMax, distribution.GetGridCellArea() * GetMaximumSpawnDensity());
		UpdateWeights(distribution, GetTargetCount(distribution));
		int num2 = (initialSpawn ? (numToFill * SpawnAttemptsInitial) : (numToFill * SpawnAttemptsRepeating));
		while (numToFill >= ClusterSizeMax && num2 > 0)
		{
			ByteQuadtree.Element node = distribution.SampleNode();
			int num3 = Random.Range(ClusterSizeMin, ClusterSizeMax + 1);
			num3 = Mathx.Min(num2, numToFill, num3);
			for (int i = 0; i < num3; i++)
			{
				Vector3 spawnPos;
				Quaternion spawnRot;
				bool flag = distribution.Sample(out spawnPos, out spawnRot, node, AlignToNormal, ClusterDithering, 0f, Filter, FilterCutoff);
				if (flag && FilterOutTutorialIslands && ((Bounds)(ref TutorialIsland.WorldBoundsMinusTutorialIslands)).size != Vector3.zero)
				{
					flag = ((Bounds)(ref TutorialIsland.WorldBoundsMinusTutorialIslands)).Contains(spawnPos);
				}
				if (flag && FilterRadius > 0f)
				{
					flag = Filter.GetFactor(spawnPos + Vector3.forward * FilterRadius) > 0f && Filter.GetFactor(spawnPos - Vector3.forward * FilterRadius) > 0f && Filter.GetFactor(spawnPos + Vector3.right * FilterRadius) > 0f && Filter.GetFactor(spawnPos - Vector3.right * FilterRadius) > 0f;
				}
				if (flag && NpcRadiusCheckDistance > 0f)
				{
					PooledList<BaseNPC2> val = Pool.Get<PooledList<BaseNPC2>>();
					try
					{
						BaseEntity.Query.Server.GetBrainsInSphere(spawnPos, NpcRadiusCheckDistance, (List<BaseNPC2>)(object)val);
						flag = ((List<BaseNPC2>)(object)val).Count == 0;
					}
					finally
					{
						((IDisposable)val)?.Dispose();
					}
				}
				if (flag && FilterOutMonuments != null && FilterOutMonuments.Length != 0)
				{
					flag = (Object)(object)TerrainMeta.Path.FindMonumentWithBoundsOverlap(spawnPos, FilterOutMonuments) == (Object)null;
				}
				if (flag && TryTakeRandomPrefab(out var result))
				{
					if (GetSpawnPosOverride(result, ref spawnPos, ref spawnRot) && (float)distribution.GetCount(spawnPos) < num)
					{
						if ((Object)(object)spawnHandler.Spawn(this, result, spawnPos, spawnRot) != (Object)null)
						{
							numToFill--;
						}
					}
					else
					{
						ReturnPrefab(result);
					}
				}
				num2--;
			}
		}
	}

	public void UpdateWeights(SpawnDistribution distribution, int targetCount)
	{
		float num = 0f;
		for (int i = 0; i < Prefabs.Length; i++)
		{
			Prefab<Spawnable> prefab = Prefabs[i];
			float prefabWeight = GetPrefabWeight(prefab);
			num += prefabWeight;
		}
		int num2 = Mathf.CeilToInt((float)targetCount / num);
		sumToSpawn = 0;
		for (int j = 0; j < Prefabs.Length; j++)
		{
			Prefab<Spawnable> prefab2 = Prefabs[j];
			float num3 = GetPrefabWeight(prefab2);
			if (prefab2.Weight != null && prefab2.Weight.IsActiveInEra())
			{
				num3 *= prefab2.Weight.Scale;
			}
			int count = distribution.GetCount(prefab2.ID);
			int num4 = Mathf.Max(Mathf.FloorToInt(num3 * (float)num2 - (float)count), 0);
			numToSpawn[j] = num4;
			sumToSpawn += num4;
		}
	}

	protected virtual float GetPrefabWeight(Prefab<Spawnable> prefab)
	{
		if (!Object.op_Implicit((Object)(object)prefab.Parameters))
		{
			return 1f;
		}
		return prefab.Parameters.Count;
	}

	public bool TryTakeRandomPrefab(out Prefab<Spawnable> result)
	{
		int num = Random.Range(0, sumToSpawn);
		for (int i = 0; i < Prefabs.Length; i++)
		{
			if ((num -= numToSpawn[i]) < 0)
			{
				numToSpawn[i]--;
				sumToSpawn--;
				result = Prefabs[i];
				return true;
			}
		}
		result = null;
		return false;
	}

	public void ReturnPrefab(Prefab<Spawnable> prefab)
	{
		if (prefab == null)
		{
			return;
		}
		for (int i = 0; i < Prefabs.Length; i++)
		{
			if (Prefabs[i] == prefab)
			{
				numToSpawn[i]++;
				sumToSpawn++;
			}
		}
	}

	public float GetCurrentSpawnDensity()
	{
		if (ScaleWithServerPopulation)
		{
			return TargetDensity * SpawnHandler.PlayerLerp(Spawn.min_density, Spawn.max_density) * 1E-06f;
		}
		return TargetDensity * Spawn.max_density * 1E-06f;
	}

	public float GetMaximumSpawnDensity()
	{
		if (ScaleWithServerPopulation)
		{
			return 2f * TargetDensity * SpawnHandler.PlayerLerp(Spawn.min_density, Spawn.max_density) * 1E-06f;
		}
		return 2f * TargetDensity * Spawn.max_density * 1E-06f;
	}

	public virtual bool GetSpawnPosOverride(Prefab<Spawnable> prefab, ref Vector3 newPos, ref Quaternion newRot)
	{
		return true;
	}

	public override byte[] GetBaseMapValues(int populationRes)
	{
		byte[] baseValues = new byte[populationRes * populationRes];
		SpawnFilter filter = Filter;
		float cutoff = FilterCutoff;
		Parallel.For(0, populationRes, delegate(int z)
		{
			for (int i = 0; i < populationRes; i++)
			{
				float normX = ((float)i + 0.5f) / (float)populationRes;
				float normZ = ((float)z + 0.5f) / (float)populationRes;
				float factor = filter.GetFactor(normX, normZ);
				baseValues[z * populationRes + i] = (byte)((factor > cutoff) ? (255f * factor) : 0f);
			}
		});
		return baseValues;
	}

	public override int GetTargetCount(SpawnDistribution distribution)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		float num = TerrainMeta.Size.x * TerrainMeta.Size.z;
		float num2 = GetCurrentSpawnDensity();
		if (!ScaleWithLargeMaps)
		{
			num = Mathf.Min(num, 16000000f);
		}
		if (ScaleWithSpawnFilter)
		{
			num2 *= distribution.Density;
		}
		float num3 = 1f;
		if (Prefabs != null && Prefabs.Length != 0)
		{
			float num4 = 0f;
			Prefab<Spawnable>[] prefabs = Prefabs;
			foreach (Prefab<Spawnable> prefab in prefabs)
			{
				num4 = ((prefab == null || !(prefab.Weight != null) || !prefab.Weight.IsActiveInEra()) ? (num4 + 1f) : (num4 + prefab.Weight.Scale));
			}
			num3 = num4 / (float)Prefabs.Length;
		}
		return Mathf.RoundToInt(num * num2 * num3);
	}

	public override SpawnFilter GetSpawnFilter()
	{
		return Filter;
	}
}


using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class Spawnable : MonoBehaviour, IServerComponent
{
	[ReadOnly]
	public SpawnPopulationBase Population;

	[SerializeField]
	private bool ForceSpawnOnly;

	[SerializeField]
	private string ForceSpawnInfoMessage = string.Empty;

	internal bool SpawnIndividual;

	internal Vector3 SpawnPosition;

	internal Quaternion SpawnRotation;

	protected void OnEnable()
	{
		if (!Application.isLoadingSave)
		{
			Add();
		}
	}

	protected void OnDisable()
	{
		if (!Application.isQuitting && !Application.isLoadingSave)
		{
			Remove();
		}
	}

	private void Add()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		SpawnPosition = ((Component)this).transform.position;
		SpawnRotation = ((Component)this).transform.rotation;
		if (!Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			return;
		}
		if (Population != null)
		{
			SingletonComponent<SpawnHandler>.Instance.AddInstance(this);
		}
		else if (Application.isLoading && !Application.isLoadingSave)
		{
			BaseEntity component = ((Component)this).GetComponent<BaseEntity>();
			if ((Object)(object)component != (Object)null && component.enableSaving && !component.syncPosition)
			{
				SingletonComponent<SpawnHandler>.Instance.AddRespawn(new SpawnIndividual(component.prefabID, SpawnPosition, SpawnRotation));
			}
		}
	}

	private void Remove()
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance) && Population != null)
		{
			SingletonComponent<SpawnHandler>.Instance.RemoveInstance(this);
		}
	}

	internal void Save(BaseNetworkable.SaveInfo info)
	{
		if (!(Population == null))
		{
			info.msg.spawnable = Pool.Get<Spawnable>();
			info.msg.spawnable.population = Population.FilenameStringId;
		}
	}

	internal void Load(BaseNetworkable.LoadInfo info)
	{
		if (info.msg.spawnable != null)
		{
			Population = FileSystem.Load<SpawnPopulationBase>(StringPool.Get(info.msg.spawnable.population), true);
		}
		Add();
	}

	protected void OnValidate()
	{
		Population = null;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class SpawnDistribution
{
	internal SpawnHandler Handler;

	public float Density;

	public int Count;

	private WorldSpaceGrid<int> grid;

	private Dictionary<uint, int> dict = new Dictionary<uint, int>();

	private ByteQuadtree quadtree = new ByteQuadtree();

	private Vector3 origin;

	private Vector3 area;

	public SpawnDistribution(SpawnHandler handler, byte[] baseValues, Vector3 origin, Vector3 area)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		Handler = handler;
		quadtree.UpdateValues(baseValues);
		this.origin = origin;
		float num = 0f;
		for (int i = 0; i < baseValues.Length; i++)
		{
			num += (float)(int)baseValues[i];
		}
		Density = num / (float)(255 * baseValues.Length);
		Count = 0;
		this.area = new Vector3(area.x / (float)quadtree.Size, area.y, area.z / (float)quadtree.Size);
		grid = new WorldSpaceGrid<int>(area.x, 20f, (RoundingMode)0);
	}

	public bool Sample(out Vector3 spawnPos, out Quaternion spawnRot, bool alignToNormal = false, float dithering = 0f, float radius = 0f, SpawnFilter filter = null, float cutoff = 0f)
	{
		return Sample(out spawnPos, out spawnRot, SampleNode(), alignToNormal, dithering, radius, filter, cutoff);
	}

	public bool Sample(out Vector3 spawnPos, out Quaternion spawnRot, ByteQuadtree.Element node, bool alignToNormal = false, float dithering = 0f, float radius = 0f, SpawnFilter filter = null, float cutoff = 0f)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_02af: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Handler == (Object)null || (Object)(object)TerrainMeta.HeightMap == (Object)null)
		{
			spawnPos = Vector3.zero;
			spawnRot = Quaternion.identity;
			return false;
		}
		LayerMask placementMask = Handler.PlacementMask;
		LayerMask placementCheckMask = Handler.PlacementCheckMask;
		float placementCheckHeight = Handler.PlacementCheckHeight;
		LayerMask radiusCheckMask = Handler.RadiusCheckMask;
		float radiusCheckDistance = Handler.RadiusCheckDistance;
		Vector3 val = default(Vector3);
		RaycastHit val2 = default(RaycastHit);
		for (int i = 0; i < 15; i++)
		{
			spawnPos = origin;
			spawnPos.x += node.Coords.x * area.x;
			spawnPos.z += node.Coords.y * area.z;
			spawnPos.x += Random.value * area.x;
			spawnPos.z += Random.value * area.z;
			spawnPos.x += Random.Range(0f - dithering, dithering);
			spawnPos.z += Random.Range(0f - dithering, dithering);
			((Vector3)(ref val))..ctor(spawnPos.x, TerrainMeta.HeightMap.GetHeight(spawnPos), spawnPos.z);
			if (val.y <= spawnPos.y || (filter != null && filter.GetFactor(spawnPos) <= cutoff))
			{
				continue;
			}
			if (LayerMask.op_Implicit(placementCheckMask) != 0)
			{
				bool flag = false;
				if ((radius != 0f) ? Physics.SphereCast(val + Vector3.up * placementCheckHeight, radius, Vector3.down, ref val2, placementCheckHeight, LayerMask.op_Implicit(placementCheckMask)) : Physics.Raycast(val + Vector3.up * placementCheckHeight, Vector3.down, ref val2, placementCheckHeight, LayerMask.op_Implicit(placementCheckMask)))
				{
					if (((1 << ((Component)((RaycastHit)(ref val2)).transform).gameObject.layer) & LayerMask.op_Implicit(placementMask)) == 0)
					{
						continue;
					}
					val.y = ((RaycastHit)(ref val2)).point.y;
				}
			}
			if (LayerMask.op_Implicit(radiusCheckMask) == 0 || !Physics.CheckSphere(val, radiusCheckDistance, LayerMask.op_Implicit(radiusCheckMask)))
			{
				spawnPos.y = val.y;
				spawnRot = Quaternion.Euler(new Vector3(0f, Random.Range(0f, 360f), 0f));
				if (alignToNormal)
				{
					Vector3 normal = TerrainMeta.HeightMap.GetNormal(spawnPos);
					spawnRot = QuaternionEx.LookRotationForcedUp(spawnRot * Vector3.forward, normal);
				}
				return true;
			}
		}
		spawnPos = Vector3.zero;
		spawnRot = Quaternion.identity;
		return false;
	}

	public ByteQuadtree.Element SampleNode()
	{
		ByteQuadtree.Element result = quadtree.Root;
		while (!result.IsLeaf)
		{
			result = result.RandChild;
		}
		return result;
	}

	public void AddInstance(Spawnable spawnable)
	{
		UpdateCount(spawnable, 1);
	}

	public void RemoveInstance(Spawnable spawnable)
	{
		UpdateCount(spawnable, -1);
	}

	private void UpdateCount(Spawnable spawnable, int delta)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Count += delta;
		WorldSpaceGrid<int> val = grid;
		Vector3 spawnPosition = spawnable.SpawnPosition;
		val[spawnPosition] += delta;
		BaseEntity component = ((Component)spawnable).GetComponent<BaseEntity>();
		if (Object.op_Implicit((Object)(object)component))
		{
			if (dict.TryGetValue(component.prefabID, out var value))
			{
				dict[component.prefabID] = value + delta;
				return;
			}
			value = delta;
			dict.Add(component.prefabID, value);
		}
	}

	public int GetCount(uint prefabID)
	{
		dict.TryGetValue(prefabID, out var value);
		return value;
	}

	public int GetCount(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return grid[position];
	}

	public float GetGridCellArea()
	{
		return grid.CellArea;
	}
}


using UnityEngine;

public struct SpawnIndividual
{
	public uint PrefabID;

	public Vector3 Position;

	public Quaternion Rotation;

	public SpawnIndividual(uint prefabID, Vector3 position, Quaternion rotation)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		PrefabID = prefabID;
		Position = position;
		Rotation = rotation;
	}
}


using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Spawn Point Spawn Population")]
public class SpawnPointSpawnPopulation : SpawnPopulationBase
{
	[SerializeField]
	private BaseSpawnPoint.SpawnPointType spawnPointType;

	private SpawnFilter Filter = new SpawnFilter();

	public override void SubFill(SpawnHandler spawnHandler, SpawnDistribution distribution, int numToFill, bool initialSpawn)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		if (numToFill == 0)
		{
			return;
		}
		if (!TryGetSpawnPoints(out var result))
		{
			Debug.LogWarning((object)(((Object)this).name + " couldn't find any spawn points of type: " + spawnPointType), (Object)(object)this);
			return;
		}
		foreach (BaseSpawnPoint item in result)
		{
			Prefab<Spawnable> prefab = Prefabs[Random.Range(0, Prefabs.Length)];
			if ((Object)(object)item != (Object)null && item.IsAvailableTo(prefab.Object))
			{
				item.GetLocation(out var pos, out var rot);
				spawnHandler.Spawn(this, prefab, pos, rot);
				numToFill--;
				if (numToFill == 0)
				{
					break;
				}
			}
		}
	}

	public override byte[] GetBaseMapValues(int populationRes)
	{
		return new byte[0];
	}

	public override SpawnFilter GetSpawnFilter()
	{
		return Filter;
	}

	public override int GetTargetCount(SpawnDistribution distribution)
	{
		if (TryGetSpawnPoints(out var result))
		{
			return result.Count;
		}
		return 0;
	}

	private bool TryGetSpawnPoints(out List<BaseSpawnPoint> result)
	{
		return BaseSpawnPoint.spawnPoints.TryGetValue(spawnPointType, out result);
	}
}


using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using ConVar;
using UnityEngine;

public abstract class SpawnPopulationBase : BaseScriptableObject
{
	public string ResourceFolder = string.Empty;

	public GameObjectRef[] ResourceList;

	public bool EnforcePopulationLimits = true;

	public float SpawnRate = 1f;

	public bool ScaleWithServerPopulation;

	public Prefab<Spawnable>[] Prefabs;

	public int[] numToSpawn;

	private HashSet<Spawnable> spawnables = new HashSet<Spawnable>();

	public ICollection<Spawnable> GetSpawnables()
	{
		return spawnables;
	}

	public virtual bool Initialize()
	{
		if (Prefabs == null || Prefabs.Length == 0)
		{
			if (!string.IsNullOrEmpty(ResourceFolder))
			{
				Prefabs = Prefab.Load<Spawnable>("assets/bundled/prefabs/autospawn/" + ResourceFolder, GameManager.server, PrefabAttribute.server, useProbabilities: false, useWorldConfig: true);
			}
			if (ResourceList != null && ResourceList.Length != 0)
			{
				List<string> list = new List<string>();
				GameObjectRef[] resourceList = ResourceList;
				foreach (GameObjectRef gameObjectRef in resourceList)
				{
					string resourcePath = gameObjectRef.resourcePath;
					if (string.IsNullOrEmpty(resourcePath))
					{
						Debug.LogWarning((object)(((Object)this).name + " resource list contains invalid resource path for GUID " + gameObjectRef.guid), (Object)(object)this);
					}
					else
					{
						list.Add(resourcePath);
					}
				}
				Prefabs = Prefab.Load<Spawnable>(list.ToArray(), GameManager.server, PrefabAttribute.server);
			}
			if (Prefabs == null || Prefabs.Length == 0)
			{
				return false;
			}
			numToSpawn = new int[Prefabs.Length];
		}
		return true;
	}

	public float GetCurrentSpawnRate()
	{
		if (ScaleWithServerPopulation)
		{
			return SpawnRate * SpawnHandler.PlayerLerp(Spawn.min_rate, Spawn.max_rate);
		}
		return SpawnRate * Spawn.max_rate;
	}

	public void Fill(SpawnHandler spawnHandler, SpawnDistribution distribution, int numToFill, bool initialSpawn)
	{
		if (GetTargetCount(distribution) == 0)
		{
			return;
		}
		if (!Initialize())
		{
			Debug.LogError((object)("[Spawn] No prefabs to spawn: " + ((Object)this).name), (Object)(object)this);
			return;
		}
		if (Global.developer > 1)
		{
			Debug.Log((object)("[Spawn] Population " + ((Object)this).name + " needs to spawn " + numToFill));
		}
		SubFill(spawnHandler, distribution, numToFill, initialSpawn);
	}

	public abstract void SubFill(SpawnHandler spawnHandler, SpawnDistribution distribution, int numToFill, bool initialSpawn);

	public void DeleteEntities()
	{
		Spawnable[] array = GetSpawnables().ToArray();
		foreach (Spawnable spawnable in array)
		{
			if ((Object)(object)((Component)spawnable).gameObject == (Object)null)
			{
				Debug.LogWarning((object)("Trying to delete spawnable that has already been destroyed: " + ((Object)this).name));
				continue;
			}
			BaseEntity baseEntity = ((Component)spawnable).gameObject.ToBaseEntity();
			if (!baseEntity.IsValid())
			{
				Debug.LogWarning((object)("Trying to delete spawnable that is invalid: " + ((Object)this).name));
			}
			else
			{
				baseEntity.Kill();
			}
		}
	}

	public abstract byte[] GetBaseMapValues(int populationRes);

	public abstract int GetTargetCount(SpawnDistribution distribution);

	public abstract SpawnFilter GetSpawnFilter();

	public void GetReportString(StringBuilder sb, bool detailed)
	{
		if (!string.IsNullOrEmpty(ResourceFolder))
		{
			sb.AppendLine(((Object)this).name + " (autospawn/" + ResourceFolder + ")");
		}
		else
		{
			sb.AppendLine(((Object)this).name);
		}
		if (!detailed)
		{
			return;
		}
		sb.AppendLine("\tPrefabs:");
		if (Prefabs != null)
		{
			Prefab<Spawnable>[] prefabs = Prefabs;
			foreach (Prefab<Spawnable> prefab in prefabs)
			{
				int num = spawnables.Count((Spawnable x) => (((Component)x).GetComponent<BaseNetworkable>()?.prefabID ?? 0) == prefab.ID);
				sb.AppendLine($"\t\t{Path.GetFileNameWithoutExtension(prefab.Name)} : {num}");
			}
		}
		else
		{
			sb.AppendLine("\t\tN/A");
		}
	}

	public void AddInstance(Spawnable spawnable)
	{
		spawnables.Add(spawnable);
	}

	public void RemoveInstance(Spawnable spawnable)
	{
		spawnables.Remove(spawnable);
	}
}


using System;
using UnityEngine;

public static class FloodedSpawnHandler
{
	private static readonly int[] SpreadSteps = new int[7] { 0, 1, -1, 2, -2, 3, -3 };

	public static bool GetSpawnPoint(BasePlayer.SpawnPoint spawnPoint, float searchHeight)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		SpawnHandler instance = SingletonComponent<SpawnHandler>.Instance;
		if ((Object)(object)TerrainMeta.HeightMap == (Object)null || (Object)(object)instance == (Object)null)
		{
			return false;
		}
		LayerMask placementMask = instance.PlacementMask;
		LayerMask placementCheckMask = instance.PlacementCheckMask;
		float placementCheckHeight = instance.PlacementCheckHeight;
		LayerMask radiusCheckMask = instance.RadiusCheckMask;
		float radiusCheckDistance = instance.RadiusCheckDistance;
		RaycastHit val2 = default(RaycastHit);
		for (int i = 0; i < 10; i++)
		{
			Vector3 val = FindSpawnPoint(searchHeight);
			if (LayerMask.op_Implicit(placementCheckMask) != 0 && Physics.Raycast(val + Vector3.up * placementCheckHeight, Vector3.down, ref val2, placementCheckHeight, LayerMask.op_Implicit(placementCheckMask)))
			{
				if (((1 << ((Component)((RaycastHit)(ref val2)).transform).gameObject.layer) & LayerMask.op_Implicit(placementMask)) == 0)
				{
					continue;
				}
				val.y = ((RaycastHit)(ref val2)).point.y;
			}
			if (LayerMask.op_Implicit(radiusCheckMask) == 0 || !Physics.CheckSphere(val, radiusCheckDistance, LayerMask.op_Implicit(radiusCheckMask)))
			{
				spawnPoint.pos = val;
				spawnPoint.rot = Quaternion.Euler(0f, Random.Range(0f, 360f), 0f);
				return true;
			}
		}
		return false;
	}

	private static Vector3 FindSpawnPoint(float searchHeight)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3Ex.WithY(TerrainMeta.Size / 2f, 0f);
		float magnitude = ((Vector3)(ref val)).magnitude;
		float distance = magnitude / 50f;
		float num = RandomAngle();
		float num2 = num + MathF.PI;
		Vector3 val2 = TerrainMeta.Position + val + Step(num, magnitude);
		for (int i = 0; i < 50; i++)
		{
			float num3 = float.MinValue;
			Vector3 val3 = Vector3.zero;
			float num4 = 0f;
			int[] spreadSteps = SpreadSteps;
			foreach (int num5 in spreadSteps)
			{
				float num6 = num2 + (float)num5 * 0.17453292f;
				Vector3 val4 = val2 + Step(num6, distance);
				float height = TerrainMeta.HeightMap.GetHeight(val4);
				if (height > num3)
				{
					num3 = height;
					val3 = val4;
					num4 = num6;
				}
			}
			val2 = Vector3Ex.WithY(val3, num3);
			num2 = (num2 + num4) / 2f;
			if (num3 >= searchHeight)
			{
				break;
			}
		}
		return val2;
	}

	private static Vector3 Step(float angle, float distance)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(distance * Mathf.Cos(angle), 0f, distance * (0f - Mathf.Sin(angle)));
	}

	private static float RandomAngle()
	{
		return Random.value * (MathF.PI * 2f);
	}
}


using System.Collections.Generic;
using UnityEngine;

public abstract class BaseSpawnPoint : MonoBehaviour, IServerComponent
{
	public enum SpawnPointType
	{
		Normal,
		Tugboat,
		Motorbike,
		Bicycle
	}

	public SpawnPointType spawnPointType;

	[SerializeField]
	[Range(1f, 25f)]
	[Tooltip("Min distance between the spawn area and any human players")]
	protected float playerCheckMargin = 2f;

	public static Dictionary<SpawnPointType, List<BaseSpawnPoint>> spawnPoints = new Dictionary<SpawnPointType, List<BaseSpawnPoint>>();

	private bool spawningActive;

	public abstract void GetLocation(out Vector3 pos, out Quaternion rot);

	public abstract void ObjectSpawned(SpawnPointInstance instance);

	public abstract void ObjectRetired(SpawnPointInstance instance);

	protected void OnEnable()
	{
		spawningActive = true;
		if (spawnPointType != 0)
		{
			if (spawnPoints.TryGetValue(spawnPointType, out var value))
			{
				value.Add(this);
				return;
			}
			spawnPoints[spawnPointType] = new List<BaseSpawnPoint> { this };
		}
	}

	protected void OnDisable()
	{
		spawningActive = false;
		if (spawnPointType != 0 && spawnPoints.TryGetValue(spawnPointType, out var value))
		{
			value.Remove(this);
		}
	}

	protected void SetSpawningActive(bool newState)
	{
		spawningActive = newState;
		((Component)this).gameObject.SetActive(newState);
	}

	public virtual bool IsAvailableTo(GameObject prefab)
	{
		return spawningActive;
	}

	public virtual bool HasPlayersIntersecting()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return BaseNetworkable.HasCloseConnections(((Component)this).transform.position, playerCheckMargin);
	}

	protected void DropToGround(ref Vector3 pos, ref Quaternion rot)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap) && Object.op_Implicit((Object)(object)TerrainMeta.Collision) && !TerrainMeta.Collision.GetIgnore(pos))
		{
			float height = TerrainMeta.HeightMap.GetHeight(pos);
			pos.y = Mathf.Max(pos.y, height);
		}
		if (TransformUtil.GetGroundInfo(pos, out var hitOut, 20f, LayerMask.op_Implicit(1235288065)))
		{
			pos = ((RaycastHit)(ref hitOut)).point;
			rot = Quaternion.LookRotation(rot * Vector3.forward, ((RaycastHit)(ref hitOut)).normal);
		}
	}
}


public enum SpawnPointType
{
	Normal,
	Tugboat,
	Motorbike,
	Bicycle
}


using UnityEngine;

public class GameModeSpawnGroup : SpawnGroup
{
	public string[] gameModeTags;

	protected override bool AllowOverlappingSpawns => true;

	protected override bool BlockSpawnedEntitySaving => false;

	public void ResetSpawnGroup()
	{
		Clear();
		SpawnInitial();
	}

	public bool ShouldSpawn()
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode == (Object)null && HasTag("vanilla"))
		{
			return true;
		}
		if ((Object)(object)activeGameMode == (Object)null)
		{
			return false;
		}
		if (gameModeTags.Length == 0)
		{
			return true;
		}
		if (activeGameMode.HasAnyGameModeTag(gameModeTags))
		{
			return true;
		}
		return false;
	}

	private bool HasTag(string tag)
	{
		string[] array = gameModeTags;
		for (int i = 0; i < array.Length; i++)
		{
			if (string.Equals(array[i], tag))
			{
				return true;
			}
		}
		return false;
	}

	protected override void Spawn(int numToSpawn)
	{
		if (ShouldSpawn())
		{
			base.Spawn(numToSpawn);
		}
	}
}


using UnityEngine;
using UnityEngine.Events;

public class GenericSpawnPoint : BaseSpawnPoint
{
	public bool dropToGround = true;

	public bool randomRot;

	[Range(1f, 180f)]
	public float randomRotSnapDegrees = 1f;

	public GameObjectRef spawnEffect;

	public UnityEvent OnObjectSpawnedEvent = new UnityEvent();

	public UnityEvent OnObjectRetiredEvent = new UnityEvent();

	public Quaternion GetRandomRotation()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		if (!randomRot)
		{
			return Quaternion.identity;
		}
		int num = Mathf.FloorToInt(360f / randomRotSnapDegrees);
		int num2 = Random.Range(0, num);
		return Quaternion.Euler(0f, (float)num2 * randomRotSnapDegrees, 0f);
	}

	public override void GetLocation(out Vector3 pos, out Quaternion rot)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		pos = ((Component)this).transform.position;
		if (randomRot)
		{
			rot = ((Component)this).transform.rotation * GetRandomRotation();
		}
		else
		{
			rot = ((Component)this).transform.rotation;
		}
		if (dropToGround)
		{
			DropToGround(ref pos, ref rot);
		}
	}

	public override void ObjectSpawned(SpawnPointInstance instance)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (spawnEffect.isValid)
		{
			Effect.server.Run(spawnEffect.resourcePath, ((Component)instance).GetComponent<BaseEntity>(), 0u, Vector3.zero, Vector3.up);
		}
		OnObjectSpawnedEvent.Invoke();
		SetSpawningActive(newState: false);
	}

	public override void ObjectRetired(SpawnPointInstance instance)
	{
		OnObjectRetiredEvent.Invoke();
		SetSpawningActive(newState: true);
	}
}


using UnityEngine;

public class IndividualSpawner : BaseMonoBehaviour, IServerComponent, ISpawnPointUser, ISpawnGroup
{
	public GameObjectRef entityPrefab;

	public float respawnDelayMin = 10f;

	public float respawnDelayMax = 20f;

	public bool useCustomBoundsCheckMask;

	public LayerMask customBoundsCheckMask;

	[Tooltip("Simply spawns the entity once. No respawning. Entity can be saved if desired.")]
	[SerializeField]
	public bool oneTimeSpawner;

	internal bool isSpawnerActive = true;

	public SpawnPointInstance spawnInstance;

	public float nextSpawnTime = -1f;

	public int currentPopulation
	{
		get
		{
			if (!((Object)(object)spawnInstance == (Object)null))
			{
				return 1;
			}
			return 0;
		}
	}

	public bool IsSpawned => (Object)(object)spawnInstance != (Object)null;

	protected void Awake()
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.SpawnGroups.Add((ISpawnGroup)this);
		}
		else
		{
			Debug.LogWarning((object)(((object)this).GetType().Name + ": SpawnHandler instance not found."));
		}
	}

	protected void OnDestroy()
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.SpawnGroups.Remove((ISpawnGroup)this);
		}
		else
		{
			Debug.LogWarning((object)(((object)this).GetType().Name + ": SpawnHandler instance not found."));
		}
	}

	protected void OnDrawGizmosSelected()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if (TryGetEntityBounds(out var result))
		{
			Gizmos.color = Color.yellow;
			Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
			Gizmos.DrawCube(((Bounds)(ref result)).center, ((Bounds)(ref result)).size);
		}
	}

	public void ObjectSpawned(SpawnPointInstance instance)
	{
		spawnInstance = instance;
	}

	public void ObjectRetired(SpawnPointInstance instance)
	{
		spawnInstance = null;
		nextSpawnTime = Time.time + Random.Range(respawnDelayMin, respawnDelayMax);
	}

	public void Fill()
	{
		if (!oneTimeSpawner)
		{
			TrySpawnEntity();
		}
	}

	public void SpawnInitial()
	{
		TrySpawnEntity();
	}

	public void Clear()
	{
		if (IsSpawned)
		{
			BaseEntity baseEntity = ((Component)spawnInstance).gameObject.ToBaseEntity();
			if ((Object)(object)baseEntity != (Object)null)
			{
				baseEntity.Kill();
			}
		}
	}

	public void SpawnRepeating()
	{
		if (!IsSpawned && !oneTimeSpawner && Time.time >= nextSpawnTime)
		{
			TrySpawnEntity();
		}
	}

	public bool HasSpaceToSpawn()
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (useCustomBoundsCheckMask)
		{
			return SpawnHandler.CheckBounds(entityPrefab.Get(), ((Component)this).transform.position, ((Component)this).transform.rotation, Vector3.one, customBoundsCheckMask);
		}
		return SingletonComponent<SpawnHandler>.Instance.CheckBounds(entityPrefab.Get(), ((Component)this).transform.position, ((Component)this).transform.rotation, Vector3.one);
	}

	public virtual void TrySpawnEntity()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		if (!isSpawnerActive || IsSpawned)
		{
			return;
		}
		if (!HasSpaceToSpawn())
		{
			nextSpawnTime = Time.time + Random.Range(respawnDelayMin, respawnDelayMax);
			return;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(entityPrefab.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation, startActive: false);
		if ((Object)(object)baseEntity != (Object)null)
		{
			if (!oneTimeSpawner)
			{
				baseEntity.enableSaving = false;
			}
			((Component)baseEntity).gameObject.AwakeFromInstantiate();
			baseEntity.Spawn();
			SpawnPointInstance spawnPointInstance = ((Component)baseEntity).gameObject.AddComponent<SpawnPointInstance>();
			spawnPointInstance.parentSpawnPointUser = this;
			spawnPointInstance.Notify();
		}
		else
		{
			Debug.LogError((object)"IndividualSpawner failed to spawn entity.", (Object)(object)((Component)this).gameObject);
		}
	}

	public bool TryGetEntityBounds(out Bounds result)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (entityPrefab != null)
		{
			GameObject val = entityPrefab.Get();
			if ((Object)(object)val != (Object)null)
			{
				BaseEntity component = val.GetComponent<BaseEntity>();
				if ((Object)(object)component != (Object)null)
				{
					result = component.bounds;
					return true;
				}
			}
		}
		result = default(Bounds);
		return false;
	}
}


public class IndividualSpawnerNexusOnly : IndividualSpawner
{
	protected override void TrySpawnEntity()
	{
		isSpawnerActive = NexusServer.Started;
		base.TrySpawnEntity();
	}
}


public interface ISpawnGroup
{
	int currentPopulation { get; }

	void Clear();

	void Fill();

	void SpawnInitial();

	void SpawnRepeating();
}


public interface ISpawnPointUser
{
	void ObjectSpawned(SpawnPointInstance instance);

	void ObjectRetired(SpawnPointInstance instance);
}


using ConVar;
using UnityEngine;

public class JunkpileNPCSpawner : NPCSpawner
{
	[Header("Junkpile NPC Spawner")]
	public bool UseSpawnChance;

	protected override void Spawn(int numToSpawn)
	{
		if (!UseSpawnChance || !(Random.value > AI.npc_junkpilespawn_chance))
		{
			base.Spawn(numToSpawn);
		}
	}
}


using System;
using ConVar;
using UnityEngine;

public class NPCSpawner : SpawnGroup
{
	public int AdditionalLOSBlockingLayer;

	public MonumentNavMesh monumentNavMesh;

	public bool shouldFillOnSpawn;

	[Header("InfoZone Config")]
	public AIInformationZone VirtualInfoZone;

	[Header("Navigator Config")]
	public AIMovePointPath Path;

	public BasePath AStarGraph;

	[Header("Human Stat Replacements")]
	public bool UseStatModifiers;

	public float SenseRange = 30f;

	public bool CheckLOS = true;

	public float TargetLostRange = 50f;

	public float AttackRangeMultiplier = 1f;

	public float ListenRange = 10f;

	public float CanUseHealingItemsChance;

	[Header("Loadout Replacements")]
	public PlayerInventoryProperties[] Loadouts;

	public override void SpawnInitial()
	{
		if (!AI.npc_spawn_on_cargo_ship && ((Component)this).transform.root.ToBaseEntity() is CargoShip)
		{
			((Behaviour)this).enabled = false;
			return;
		}
		if (!AI.npc_spawn_on_junkpile && ((Component)this).transform.root.ToBaseEntity() is JunkPile)
		{
			((Behaviour)this).enabled = false;
			return;
		}
		fillOnSpawn = shouldFillOnSpawn;
		if (WaitingForNavMesh())
		{
			((FacepunchBehaviour)this).Invoke((Action)LateSpawn, 10f);
		}
		else
		{
			base.SpawnInitial();
		}
	}

	public bool WaitingForNavMesh()
	{
		if ((Object)(object)monumentNavMesh != (Object)null)
		{
			return monumentNavMesh.IsBuilding;
		}
		if (!DungeonNavmesh.NavReady())
		{
			return true;
		}
		return !AI.move;
	}

	public void LateSpawn()
	{
		if (!WaitingForNavMesh())
		{
			SpawnInitial();
			Debug.Log((object)"Navmesh complete, spawning");
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)LateSpawn, 5f);
		}
	}

	protected override void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
	{
		base.PostSpawnProcess(entity, spawnPoint);
		BaseNavigator component = ((Component)entity).GetComponent<BaseNavigator>();
		if (AdditionalLOSBlockingLayer != 0 && (Object)(object)entity != (Object)null && entity is HumanNPC humanNPC)
		{
			humanNPC.AdditionalLosBlockingLayer = AdditionalLOSBlockingLayer;
		}
		HumanNPC humanNPC2 = entity as HumanNPC;
		if ((Object)(object)humanNPC2 != (Object)null)
		{
			if (Loadouts != null && Loadouts.Length != 0)
			{
				humanNPC2.EquipLoadout(Loadouts);
			}
			ModifyHumanBrainStats(humanNPC2.Brain);
		}
		if ((Object)(object)VirtualInfoZone != (Object)null)
		{
			if (VirtualInfoZone.Virtual)
			{
				NPCPlayer nPCPlayer = entity as NPCPlayer;
				if ((Object)(object)nPCPlayer != (Object)null)
				{
					nPCPlayer.VirtualInfoZone = VirtualInfoZone;
					if ((Object)(object)humanNPC2 != (Object)null)
					{
						humanNPC2.VirtualInfoZone.RegisterSleepableEntity(humanNPC2.Brain);
					}
				}
			}
			else
			{
				Debug.LogError((object)"NPCSpawner trying to set a virtual info zone without the Virtual property!");
			}
		}
		if ((Object)(object)component != (Object)null)
		{
			component.Path = Path;
			component.AStarGraph = AStarGraph;
		}
	}

	private void ModifyHumanBrainStats(BaseAIBrain brain)
	{
		if (UseStatModifiers && !((Object)(object)brain == (Object)null))
		{
			brain.SenseRange = SenseRange;
			brain.TargetLostRange *= TargetLostRange;
			brain.AttackRangeMultiplier = AttackRangeMultiplier;
			brain.ListenRange = ListenRange;
			brain.CheckLOS = CheckLOS;
			if (CanUseHealingItemsChance > 0f)
			{
				brain.CanUseHealingItems = Random.Range(0f, 1f) <= CanUseHealingItemsChance;
			}
		}
	}
}


using UnityEngine;

public class RadialSpawnPoint : BaseSpawnPoint
{
	[Tooltip("Circle to spawn within")]
	[SerializeField]
	public float radius = 10f;

	public override void GetLocation(out Vector3 pos, out Quaternion rot)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = Random.insideUnitCircle * radius;
		pos = ((Component)this).transform.position + new Vector3(val.x, 0f, val.y);
		rot = Quaternion.Euler(0f, Random.Range(0f, 360f), 0f);
		DropToGround(ref pos, ref rot);
	}

	public override bool HasPlayersIntersecting()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return BaseNetworkable.HasCloseConnections(((Component)this).transform.position, radius + playerCheckMargin);
	}

	public override void ObjectSpawned(SpawnPointInstance instance)
	{
	}

	public override void ObjectRetired(SpawnPointInstance instance)
	{
	}
}


using System;

public class SingleSpawn : SpawnGroup
{
	public override bool WantsInitialSpawn()
	{
		return false;
	}

	public void FillDelay(float delay)
	{
		((FacepunchBehaviour)this).Invoke((Action)Fill, delay);
	}
}


using UnityEngine;

public class SpaceCheckingSpawnPoint : GenericSpawnPoint
{
	public bool useCustomBoundsCheckMask;

	public LayerMask customBoundsCheckMask;

	public float customBoundsCheckScale = 1f;

	public override bool IsAvailableTo(GameObject prefab)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		if (!base.IsAvailableTo(prefab))
		{
			return false;
		}
		if (useCustomBoundsCheckMask)
		{
			return SpawnHandler.CheckBounds(prefab, ((Component)this).transform.position, ((Component)this).transform.rotation, Vector3.one * customBoundsCheckScale, customBoundsCheckMask);
		}
		return SingletonComponent<SpawnHandler>.Instance.CheckBounds(prefab, ((Component)this).transform.position, ((Component)this).transform.rotation, Vector3.one * customBoundsCheckScale);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

public class SpawnGroup : BaseMonoBehaviour, IServerComponent, ISpawnPointUser, ISpawnGroup
{
	[Serializable]
	public class SpawnEntry
	{
		public GameObjectRef prefab;

		public int weight = 1;

		public bool mobile;
	}

	[InspectorFlags]
	public MonumentTier Tier = (MonumentTier)(-1);

	public List<SpawnEntry> prefabs;

	public int maxPopulation = 5;

	public int numToSpawnPerTickMin = 1;

	public int numToSpawnPerTickMax = 2;

	public float respawnDelayMin = 10f;

	public float respawnDelayMax = 20f;

	public bool wantsInitialSpawn = true;

	public bool temporary;

	public bool forceInitialSpawn;

	public bool preventDuplicates;

	public bool isSpawnerActive = true;

	public BoxCollider setFreeIfMovedBeyond;

	public string category;

	[NonSerialized]
	public MonumentInfo Monument;

	public bool fillOnSpawn;

	public BaseSpawnPoint[] spawnPoints;

	public List<SpawnPointInstance> spawnInstances = new List<SpawnPointInstance>();

	public LocalClock spawnClock = new LocalClock();

	public int currentPopulation => spawnInstances.Count;

	public IEnumerable<SpawnPointInstance> SpawnInstances => spawnInstances;

	public int ObjectsAdded { get; private set; }

	public int ObjectsRemoved { get; private set; }

	protected virtual bool BlockSpawnedEntitySaving => true;

	protected virtual bool AllowOverlappingSpawns => false;

	public bool DoesGroupContainNPCs()
	{
		foreach (SpawnEntry prefab in prefabs)
		{
			GameObject val = prefab.prefab?.Get();
			if (!((Object)(object)val == (Object)null))
			{
				BaseCombatEntity component = val.GetComponent<BaseCombatEntity>();
				if (!((Object)(object)component == (Object)null) && component.IsNpc)
				{
					return true;
				}
			}
		}
		return false;
	}

	public virtual bool WantsInitialSpawn()
	{
		return wantsInitialSpawn;
	}

	public virtual bool WantsTimedSpawn()
	{
		return respawnDelayMax != float.PositiveInfinity;
	}

	public float GetSpawnDelta()
	{
		return (respawnDelayMax + respawnDelayMin) * 0.5f / SpawnHandler.PlayerScale(ConVar.Spawn.player_scale);
	}

	public float GetSpawnVariance()
	{
		return (respawnDelayMax - respawnDelayMin) * 0.5f / SpawnHandler.PlayerScale(ConVar.Spawn.player_scale);
	}

	protected void Awake()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.TopologyMap == (Object)null)
		{
			return;
		}
		int topology = TerrainMeta.TopologyMap.GetTopology(((Component)this).transform.position);
		int num = 469762048;
		int num2 = MonumentInfo.TierToMask(Tier);
		if (num2 == num || (num2 & topology) != 0)
		{
			spawnPoints = ((Component)this).GetComponentsInChildren<BaseSpawnPoint>();
			if (WantsTimedSpawn())
			{
				spawnClock.Add(GetSpawnDelta(), GetSpawnVariance(), Spawn);
			}
			if (!temporary && Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
			{
				SingletonComponent<SpawnHandler>.Instance.SpawnGroups.Add((ISpawnGroup)this);
			}
			if (forceInitialSpawn)
			{
				((FacepunchBehaviour)this).Invoke((Action)SpawnInitial, 1f);
			}
			Monument = FindMonument();
		}
	}

	protected void OnDestroy()
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.SpawnGroups.Remove((ISpawnGroup)this);
		}
		else
		{
			Debug.LogWarning((object)(((object)this).GetType().Name + ": SpawnHandler instance not found."));
		}
	}

	public void Fill()
	{
		if (isSpawnerActive)
		{
			Spawn(maxPopulation);
		}
	}

	public void Clear()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		for (int num = spawnInstances.Count - 1; num >= 0; num--)
		{
			SpawnPointInstance spawnPointInstance = spawnInstances[num];
			BaseEntity baseEntity = ((Component)spawnPointInstance).gameObject.ToBaseEntity();
			if ((Object)(object)setFreeIfMovedBeyond != (Object)null)
			{
				Bounds bounds = ((Collider)setFreeIfMovedBeyond).bounds;
				if (!((Bounds)(ref bounds)).Contains(((Component)baseEntity).transform.position))
				{
					spawnPointInstance.Retire();
					continue;
				}
			}
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.Kill();
			}
		}
		spawnInstances.Clear();
	}

	public bool HasSpawned(uint prefabID)
	{
		foreach (SpawnPointInstance spawnInstance in spawnInstances)
		{
			BaseEntity baseEntity = ((Component)spawnInstance).gameObject.ToBaseEntity();
			if (Object.op_Implicit((Object)(object)baseEntity) && baseEntity.prefabID == prefabID)
			{
				return true;
			}
		}
		return false;
	}

	public virtual void SpawnInitial()
	{
		if (wantsInitialSpawn && isSpawnerActive)
		{
			if (fillOnSpawn)
			{
				Spawn(maxPopulation);
			}
			else
			{
				Spawn();
			}
		}
	}

	public void SpawnRepeating()
	{
		for (int i = 0; i < spawnClock.events.Count; i++)
		{
			LocalClock.TimedEvent value = spawnClock.events[i];
			if (Time.time > value.time)
			{
				value.delta = GetSpawnDelta();
				value.variance = GetSpawnVariance();
				spawnClock.events[i] = value;
			}
		}
		spawnClock.Tick();
	}

	public void ObjectSpawned(SpawnPointInstance instance)
	{
		spawnInstances.Add(instance);
		ObjectsAdded++;
	}

	public void ObjectRetired(SpawnPointInstance instance)
	{
		spawnInstances.Remove(instance);
		ObjectsRemoved++;
	}

	public void DelayedSpawn()
	{
		((FacepunchBehaviour)this).Invoke((Action)Spawn, 1f);
	}

	public void Spawn()
	{
		if (isSpawnerActive)
		{
			Spawn(Random.Range(numToSpawnPerTickMin, numToSpawnPerTickMax + 1));
		}
	}

	protected virtual void Spawn(int numToSpawn)
	{
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.scientist_spawners_enabled && prefabs != null)
		{
			foreach (SpawnEntry prefab2 in prefabs)
			{
				BaseEntity baseEntity = prefab2?.prefab?.GetEntity();
				if (baseEntity is ScientistNPC || baseEntity is TunnelDweller || baseEntity is UnderwaterDweller)
				{
					((Behaviour)this).enabled = false;
					return;
				}
			}
		}
		numToSpawn = Mathf.Min(numToSpawn, maxPopulation - currentPopulation);
		for (int i = 0; i < numToSpawn; i++)
		{
			GameObjectRef prefab = GetPrefab();
			if (prefab == null || string.IsNullOrEmpty(prefab.guid))
			{
				continue;
			}
			Vector3 pos;
			Quaternion rot;
			BaseSpawnPoint spawnPoint = GetSpawnPoint(prefab, out pos, out rot);
			if (!Object.op_Implicit((Object)(object)spawnPoint))
			{
				continue;
			}
			BaseEntity baseEntity2 = GameManager.server.CreateEntity(prefab.resourcePath, pos, rot, startActive: false);
			if (Object.op_Implicit((Object)(object)baseEntity2))
			{
				if (baseEntity2.enableSaving && BlockSpawnedEntitySaving && !(spawnPoint is SpaceCheckingSpawnPoint))
				{
					baseEntity2.enableSaving = false;
				}
				((Component)baseEntity2).gameObject.AwakeFromInstantiate();
				baseEntity2.Spawn();
				PostSpawnProcess(baseEntity2, spawnPoint);
				SpawnPointInstance spawnPointInstance = ((Component)baseEntity2).gameObject.AddComponent<SpawnPointInstance>();
				spawnPointInstance.parentSpawnPointUser = this;
				spawnPointInstance.parentSpawnPoint = spawnPoint;
				spawnPointInstance.Entity = baseEntity2;
				spawnPointInstance.Notify();
			}
		}
	}

	protected virtual void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (entity is HumanNPC humanNPC)
		{
			Vector3 position = ((Component)spawnPoint).transform.position;
			bool num = TerrainMeta.BiomeMap.GetBiomeMaxType(position) == 16;
			bool flag = EnvironmentManager.Check(position, EnvironmentType.TrainTunnels | EnvironmentType.UnderwaterLab | EnvironmentType.Submarine);
			bool topology = TerrainMeta.TopologyMap.GetTopology(position, 128);
			if (num && !flag && !topology && SingletonComponent<SpawnHandler>.Instance.JungleLoadouts != null && SingletonComponent<SpawnHandler>.Instance.JungleLoadouts.Length != 0)
			{
				humanNPC.EquipLoadout(SingletonComponent<SpawnHandler>.Instance.JungleLoadouts);
			}
		}
	}

	protected GameObjectRef GetPrefab()
	{
		float num = prefabs.Sum((SpawnEntry x) => (!preventDuplicates || !HasSpawned(x.prefab.resourceID)) ? x.weight : 0);
		if (num == 0f)
		{
			return null;
		}
		float num2 = Random.Range(0f, num);
		foreach (SpawnEntry prefab in prefabs)
		{
			int num3 = ((!preventDuplicates || !HasSpawned(prefab.prefab.resourceID)) ? prefab.weight : 0);
			if ((num2 -= (float)num3) <= 0f)
			{
				return prefab.prefab;
			}
		}
		return prefabs[prefabs.Count - 1].prefab;
	}

	protected virtual BaseSpawnPoint GetSpawnPoint(GameObjectRef prefabRef, out Vector3 pos, out Quaternion rot)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		pos = Vector3.zero;
		rot = Quaternion.identity;
		int num = Random.Range(0, spawnPoints.Length);
		NavMeshHit val = default(NavMeshHit);
		for (int i = 0; i < spawnPoints.Length; i++)
		{
			BaseSpawnPoint baseSpawnPoint = spawnPoints[(num + i) % spawnPoints.Length];
			if (!((Object)(object)baseSpawnPoint == (Object)null) && (baseSpawnPoint.IsAvailableTo(prefabRef.Get()) || AllowOverlappingSpawns) && !baseSpawnPoint.HasPlayersIntersecting())
			{
				baseSpawnPoint.GetLocation(out pos, out rot);
				if (!DoesRequireNavmeshToSpawn(prefabRef.Get()))
				{
					return baseSpawnPoint;
				}
				if (NavMesh.SamplePosition(pos, ref val, 2f, -1))
				{
					pos = ((NavMeshHit)(ref val)).position;
					rot = Quaternion.LookRotation(rot * Vector3.forward, ((NavMeshHit)(ref val)).normal);
					return baseSpawnPoint;
				}
				if (AI.logIssues)
				{
					Debug.LogWarning((object)$"Failed to spawn {prefabRef.Get()} at {pos} - no navmesh found");
				}
			}
		}
		return null;
	}

	private static bool DoesRequireNavmeshToSpawn(GameObject prefab)
	{
		if (!AI.npc_check_spawner_is_on_navmesh)
		{
			return false;
		}
		if (((Object)(object)prefab.GetComponent<BaseNavigator>()).Is<BaseNavigator>(out BaseNavigator entAsT) && entAsT.CanUseNavMesh)
		{
			return true;
		}
		if ((Object)(object)prefab.GetComponent<LimitedTurnNavAgent>() != (Object)null)
		{
			return true;
		}
		return false;
	}

	private MonumentInfo FindMonument()
	{
		return ((Component)this).GetComponentInParent<MonumentInfo>();
	}

	protected virtual void OnDrawGizmos()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = new Color(1f, 1f, 0f, 1f);
		Gizmos.DrawSphere(((Component)this).transform.position, 0.25f);
	}
}


using System;

[Serializable]
public class SpawnEntry
{
	public GameObjectRef prefab;

	public int weight = 1;

	public bool mobile;
}


using Rust;
using UnityEngine;

public class SpawnPointInstance : MonoBehaviour
{
	internal BaseEntity Entity;

	public ISpawnPointUser parentSpawnPointUser;

	public BaseSpawnPoint parentSpawnPoint;

	public void Notify()
	{
		if (!parentSpawnPointUser.IsUnityNull())
		{
			parentSpawnPointUser.ObjectSpawned(this);
		}
		if (Object.op_Implicit((Object)(object)parentSpawnPoint))
		{
			parentSpawnPoint.ObjectSpawned(this);
		}
	}

	public void Retire()
	{
		if (!parentSpawnPointUser.IsUnityNull())
		{
			parentSpawnPointUser.ObjectRetired(this);
		}
		if (Object.op_Implicit((Object)(object)parentSpawnPoint))
		{
			parentSpawnPoint.ObjectRetired(this);
		}
	}

	protected void OnDestroy()
	{
		if (!Application.isQuitting)
		{
			Retire();
		}
	}
}


using UnityEngine;

public class VehicleSpawnPoint : SpaceCheckingSpawnPoint
{
	public override void ObjectSpawned(SpawnPointInstance instance)
	{
		base.ObjectSpawned(instance);
		AddStartingFuel(((Component)instance).gameObject.ToBaseEntity() as VehicleSpawner.IVehicleSpawnUser);
	}

	public static void AddStartingFuel(VehicleSpawner.IVehicleSpawnUser vehicle)
	{
		vehicle?.GetFuelSystem()?.AddFuel(vehicle.StartingFuelUnits());
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using ConVar;
using UnityEngine;

public class SpawnHandler : SingletonComponent<SpawnHandler>
{
	public float TickInterval = 60f;

	public int MinSpawnsPerTick = 100;

	public int MaxSpawnsPerTick = 100;

	public LayerMask PlacementMask;

	public LayerMask PlacementCheckMask;

	public float PlacementCheckHeight = 25f;

	public LayerMask RadiusCheckMask;

	public float RadiusCheckDistance = 5f;

	public LayerMask BoundsCheckMask;

	public SpawnFilter CharacterSpawn;

	public float CharacterSpawnCutoff;

	public SpawnPopulationBase[] SpawnPopulations;

	public SpawnDistribution[] SpawnDistributions;

	public SpawnDistribution CharDistribution;

	public ListHashSet<ISpawnGroup> SpawnGroups = new ListHashSet<ISpawnGroup>();

	internal List<SpawnIndividual> SpawnIndividuals = new List<SpawnIndividual>();

	[Header("Scientist Outfits")]
	public PlayerInventoryProperties[] JungleLoadouts;

	[ReadOnly]
	public SpawnPopulationBase[] ConvarSpawnPopulations;

	public Dictionary<SpawnPopulationBase, SpawnDistribution> population2distribution;

	private bool spawnTick;

	public SpawnPopulationBase[] AllSpawnPopulations;

	private static int PlayerCount
	{
		get
		{
			if (ConVar.Spawn.loot_population_test <= 0)
			{
				return BasePlayer.activePlayerList.Count;
			}
			return ConVar.Spawn.loot_population_test;
		}
	}

	protected void OnEnable()
	{
		AllSpawnPopulations = SpawnPopulations.Concat(ConvarSpawnPopulations).ToArray();
		((MonoBehaviour)this).StartCoroutine(SpawnTick());
		((MonoBehaviour)this).StartCoroutine(SpawnGroupTick());
		((MonoBehaviour)this).StartCoroutine(SpawnIndividualTick());
	}

	public static BasePlayer.SpawnPoint GetSpawnPoint()
	{
		if ((Object)(object)SingletonComponent<SpawnHandler>.Instance == (Object)null || SingletonComponent<SpawnHandler>.Instance.CharDistribution == null)
		{
			return null;
		}
		BasePlayer.SpawnPoint spawnPoint = new BasePlayer.SpawnPoint();
		if (!((WaterSystem.OceanLevel < 0.5f) ? GetSpawnPointStandard(spawnPoint) : FloodedSpawnHandler.GetSpawnPoint(spawnPoint, WaterSystem.OceanLevel + 1f)))
		{
			return null;
		}
		return spawnPoint;
	}

	public static BasePlayer.SpawnPoint GetSpawnPointForTeam(ulong teamId)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (teamId == 0L)
		{
			return null;
		}
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(teamId);
		if (playerTeam == null)
		{
			return null;
		}
		if (!playerTeam.usePartySpawn)
		{
			return null;
		}
		if (playerTeam.firstSpawnLocation == default(Vector3))
		{
			return null;
		}
		float num = 100000f;
		BasePlayer.SpawnPoint spawnPoint = null;
		for (int i = 0; i < party.maxpartyspawnattempts; i++)
		{
			BasePlayer.SpawnPoint spawnPoint2 = GetSpawnPoint();
			float num2 = Vector3Ex.Distance2D(spawnPoint2.pos, playerTeam.firstSpawnLocation);
			if (num2 < num || spawnPoint == null)
			{
				spawnPoint = spawnPoint2;
				num = num2;
			}
			if (num2 < (float)party.maxpartyspawndistance)
			{
				return spawnPoint2;
			}
		}
		return spawnPoint;
	}

	private static bool GetSpawnPointStandard(BasePlayer.SpawnPoint spawnPoint)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < 60; i++)
		{
			if (!SingletonComponent<SpawnHandler>.Instance.CharDistribution.Sample(out spawnPoint.pos, out spawnPoint.rot, alignToNormal: false, 0f, 0.5f, SingletonComponent<SpawnHandler>.Instance.CharacterSpawn, SingletonComponent<SpawnHandler>.Instance.CharacterSpawnCutoff))
			{
				continue;
			}
			bool flag = true;
			if ((Object)(object)TerrainMeta.Path != (Object)null)
			{
				foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
				{
					if (monument.Distance(spawnPoint.pos) < 50f)
					{
						flag = false;
						break;
					}
				}
			}
			if (flag)
			{
				return true;
			}
		}
		return false;
	}

	public void UpdateDistributions()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		if (World.Size == 0)
		{
			return;
		}
		SpawnDistributions = new SpawnDistribution[AllSpawnPopulations.Length];
		population2distribution = new Dictionary<SpawnPopulationBase, SpawnDistribution>();
		Vector3 size = TerrainMeta.Size;
		Vector3 position = TerrainMeta.Position;
		int populationRes = Mathf.NextPowerOfTwo((int)((float)World.Size * 0.25f));
		for (int i = 0; i < AllSpawnPopulations.Length; i++)
		{
			SpawnPopulationBase spawnPopulationBase = AllSpawnPopulations[i];
			if (spawnPopulationBase == null)
			{
				Debug.LogError((object)"Spawn handler contains null spawn population.");
				continue;
			}
			byte[] baseMapValues = spawnPopulationBase.GetBaseMapValues(populationRes);
			SpawnDistribution value = (SpawnDistributions[i] = new SpawnDistribution(this, baseMapValues, position, size));
			population2distribution.Add(spawnPopulationBase, value);
		}
		int char_res = Mathf.NextPowerOfTwo((int)((float)World.Size * 0.5f));
		byte[] map = new byte[char_res * char_res];
		SpawnFilter filter = CharacterSpawn;
		float cutoff = CharacterSpawnCutoff;
		Parallel.For(0, char_res, delegate(int z)
		{
			for (int j = 0; j < char_res; j++)
			{
				float normX = ((float)j + 0.5f) / (float)char_res;
				float normZ = ((float)z + 0.5f) / (float)char_res;
				float factor = filter.GetFactor(normX, normZ);
				map[z * char_res + j] = (byte)((factor > cutoff) ? (255f * factor) : 0f);
			}
		});
		CharDistribution = new SpawnDistribution(this, map, position, size);
	}

	public void FillPopulations()
	{
		if (SpawnDistributions == null)
		{
			return;
		}
		for (int i = 0; i < AllSpawnPopulations.Length; i++)
		{
			if (!(AllSpawnPopulations[i] == null))
			{
				SpawnInitial(AllSpawnPopulations[i], SpawnDistributions[i]);
			}
		}
	}

	public void DeletePopulation(string name)
	{
		SpawnPopulationBase[] allSpawnPopulations = AllSpawnPopulations;
		foreach (SpawnPopulationBase spawnPopulationBase in allSpawnPopulations)
		{
			if (((Object)spawnPopulationBase).name == name)
			{
				spawnPopulationBase.DeleteEntities();
				break;
			}
		}
	}

	public void DeleteAllPopulations()
	{
		SpawnPopulationBase[] allSpawnPopulations = AllSpawnPopulations;
		for (int i = 0; i < allSpawnPopulations.Length; i++)
		{
			allSpawnPopulations[i].DeleteEntities();
		}
	}

	public void FillGroups()
	{
		for (int i = 0; i < SpawnGroups.Count; i++)
		{
			SpawnGroups[i].Fill();
		}
	}

	public void FillIndividuals()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < SpawnIndividuals.Count; i++)
		{
			SpawnIndividual spawnIndividual = SpawnIndividuals[i];
			Spawn(Prefab.Load<Spawnable>(spawnIndividual.PrefabID, (GameManager)null, (PrefabAttribute.Library)null), spawnIndividual.Position, spawnIndividual.Rotation);
		}
	}

	public void InitialSpawn()
	{
		if (ConVar.Spawn.respawn_populations && SpawnDistributions != null)
		{
			for (int i = 0; i < AllSpawnPopulations.Length; i++)
			{
				if (!(AllSpawnPopulations[i] == null))
				{
					SpawnInitial(AllSpawnPopulations[i], SpawnDistributions[i]);
				}
			}
		}
		if (ConVar.Spawn.respawn_groups)
		{
			for (int j = 0; j < SpawnGroups.Count; j++)
			{
				SpawnGroups[j].SpawnInitial();
			}
		}
	}

	public void StartSpawnTick()
	{
		spawnTick = true;
	}

	private IEnumerator SpawnTick()
	{
		while (true)
		{
			yield return CoroutineEx.waitForEndOfFrame;
			if (!spawnTick || !ConVar.Spawn.respawn_populations)
			{
				continue;
			}
			yield return CoroutineEx.waitForSeconds(ConVar.Spawn.tick_populations);
			for (int i = 0; i < AllSpawnPopulations.Length; i++)
			{
				SpawnPopulationBase spawnPopulationBase = AllSpawnPopulations[i];
				if (spawnPopulationBase == null)
				{
					continue;
				}
				SpawnDistribution spawnDistribution = SpawnDistributions[i];
				if (spawnDistribution == null)
				{
					continue;
				}
				try
				{
					if (SpawnDistributions != null)
					{
						SpawnRepeating(spawnPopulationBase, spawnDistribution);
					}
				}
				catch (Exception ex)
				{
					Debug.LogError((object)ex);
				}
				yield return CoroutineEx.waitForEndOfFrame;
			}
		}
	}

	private IEnumerator SpawnGroupTick()
	{
		while (true)
		{
			yield return CoroutineEx.waitForEndOfFrame;
			if (!spawnTick || !ConVar.Spawn.respawn_groups)
			{
				continue;
			}
			yield return CoroutineEx.waitForSeconds(1f);
			for (int i = 0; i < SpawnGroups.Count; i++)
			{
				ISpawnGroup spawnGroup = SpawnGroups[i];
				if (spawnGroup != null)
				{
					try
					{
						spawnGroup.SpawnRepeating();
					}
					catch (Exception ex)
					{
						Debug.LogError((object)ex);
					}
					yield return CoroutineEx.waitForEndOfFrame;
				}
			}
		}
	}

	private IEnumerator SpawnIndividualTick()
	{
		while (true)
		{
			yield return CoroutineEx.waitForEndOfFrame;
			if (!spawnTick || !ConVar.Spawn.respawn_individuals)
			{
				continue;
			}
			yield return CoroutineEx.waitForSeconds(ConVar.Spawn.tick_individuals);
			for (int i = 0; i < SpawnIndividuals.Count; i++)
			{
				SpawnIndividual spawnIndividual = SpawnIndividuals[i];
				try
				{
					Spawn(Prefab.Load<Spawnable>(spawnIndividual.PrefabID, (GameManager)null, (PrefabAttribute.Library)null), spawnIndividual.Position, spawnIndividual.Rotation);
				}
				catch (Exception ex)
				{
					Debug.LogError((object)ex);
				}
				yield return CoroutineEx.waitForEndOfFrame;
			}
		}
	}

	public void SpawnInitial(SpawnPopulationBase population, SpawnDistribution distribution)
	{
		int targetCount = population.GetTargetCount(distribution);
		int count = distribution.Count;
		int numToFill = targetCount - count;
		population.Fill(this, distribution, numToFill, initialSpawn: true);
	}

	public void SpawnRepeating(SpawnPopulationBase population, SpawnDistribution distribution)
	{
		int targetCount = population.GetTargetCount(distribution);
		int count = distribution.Count;
		int num = targetCount - count;
		num = Mathf.RoundToInt((float)num * population.GetCurrentSpawnRate());
		num = Random.Range(Mathf.Min(num, MinSpawnsPerTick), Mathf.Min(num, MaxSpawnsPerTick));
		population.Fill(this, distribution, num, initialSpawn: false);
	}

	public GameObject Spawn(SpawnPopulationBase population, Prefab<Spawnable> prefab, Vector3 pos, Quaternion rot)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		if (prefab == null)
		{
			return null;
		}
		if ((Object)(object)prefab.Component == (Object)null)
		{
			Debug.LogError((object)("[Spawn] Missing component 'Spawnable' on " + prefab.Name));
			return null;
		}
		Vector3 scale = Vector3.one;
		DecorComponent[] components = PrefabAttribute.server.FindAll<DecorComponent>(prefab.ID);
		prefab.Object.transform.ApplyDecorComponents(components, ref pos, ref rot, ref scale);
		if (!prefab.ApplyTerrainFilters(pos, rot, scale))
		{
			return null;
		}
		if (!prefab.ApplyTerrainAnchors(ref pos, rot, scale, TerrainAnchorMode.MinimizeMovement, population.GetSpawnFilter()))
		{
			return null;
		}
		if (!prefab.ApplyTerrainChecks(pos, rot, scale, population.GetSpawnFilter()))
		{
			return null;
		}
		if (!prefab.ApplyWaterChecks(pos, rot, scale))
		{
			return null;
		}
		if (!prefab.ApplyEnvironmentVolumeChecks(pos, rot, scale))
		{
			return null;
		}
		if (!prefab.ApplyBoundsChecks(pos, rot, scale, BoundsCheckMask))
		{
			return null;
		}
		if (Global.developer > 1)
		{
			Debug.Log((object)("[Spawn] Spawning " + prefab.Name));
		}
		BaseEntity baseEntity = prefab.SpawnEntity(pos, rot, active: false);
		if ((Object)(object)baseEntity == (Object)null)
		{
			Debug.LogWarning((object)("[Spawn] Couldn't create prefab as entity - " + prefab.Name));
			return null;
		}
		Spawnable component = ((Component)baseEntity).GetComponent<Spawnable>();
		if (component.Population != population)
		{
			component.Population = population;
		}
		((Component)baseEntity).gameObject.AwakeFromInstantiate();
		baseEntity.Spawn();
		return ((Component)baseEntity).gameObject;
	}

	private GameObject Spawn(Prefab<Spawnable> prefab, Vector3 pos, Quaternion rot)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (!CheckBounds(prefab.Object, pos, rot, Vector3.one))
		{
			return null;
		}
		BaseEntity baseEntity = prefab.SpawnEntity(pos, rot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			Debug.LogWarning((object)("[Spawn] Couldn't create prefab as entity - " + prefab.Name));
			return null;
		}
		baseEntity.Spawn();
		return ((Component)baseEntity).gameObject;
	}

	public bool CheckBounds(GameObject gameObject, Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return CheckBounds(gameObject, pos, rot, scale, BoundsCheckMask);
	}

	public static bool CheckBounds(GameObject gameObject, Vector3 pos, Quaternion rot, Vector3 scale, LayerMask mask)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)gameObject == (Object)null)
		{
			return true;
		}
		if (LayerMask.op_Implicit(mask) != 0)
		{
			BaseEntity component = gameObject.GetComponent<BaseEntity>();
			if ((Object)(object)component != (Object)null && Physics.CheckBox(pos + rot * Vector3.Scale(((Bounds)(ref component.bounds)).center, scale), Vector3.Scale(((Bounds)(ref component.bounds)).extents, scale), rot, LayerMask.op_Implicit(mask)))
			{
				return false;
			}
		}
		return true;
	}

	public void EnforceLimits(bool forceAll = false)
	{
		if (SpawnDistributions == null)
		{
			return;
		}
		for (int i = 0; i < AllSpawnPopulations.Length; i++)
		{
			if (!(AllSpawnPopulations[i] == null))
			{
				SpawnPopulationBase spawnPopulationBase = AllSpawnPopulations[i];
				SpawnDistribution distribution = SpawnDistributions[i];
				if (forceAll || spawnPopulationBase.EnforcePopulationLimits)
				{
					EnforceLimits(spawnPopulationBase, distribution);
				}
			}
		}
	}

	public void EnforceLimits(SpawnPopulationBase population, SpawnDistribution distribution)
	{
		int targetCount = population.GetTargetCount(distribution);
		Spawnable[] array = FindAll(population);
		if (array.Length <= targetCount)
		{
			return;
		}
		Debug.Log((object)(((object)population)?.ToString() + " has " + array.Length + " objects, but max allowed is " + targetCount));
		int count = array.Length - targetCount;
		Debug.Log((object)(" - deleting " + count + " objects"));
		foreach (Spawnable item in array.Take(count))
		{
			BaseEntity baseEntity = ((Component)item).gameObject.ToBaseEntity();
			if (baseEntity.IsValid())
			{
				baseEntity.Kill();
			}
			else
			{
				GameManager.Destroy(((Component)item).gameObject);
			}
		}
	}

	public Spawnable[] FindAll(SpawnPopulationBase population)
	{
		return (from x in Object.FindObjectsOfType<Spawnable>()
			where ((Component)x).gameObject.activeInHierarchy && x.Population == population
			select x).ToArray();
	}

	public void AddRespawn(SpawnIndividual individual)
	{
		SpawnIndividuals.Add(individual);
	}

	public void AddInstance(Spawnable spawnable)
	{
		if (spawnable.Population != null)
		{
			spawnable.Population.AddInstance(spawnable);
			if (!population2distribution.TryGetValue(spawnable.Population, out var value))
			{
				Debug.LogWarning((object)("[SpawnHandler] trying to add instance to invalid population: " + (object)spawnable.Population));
			}
			else
			{
				value.AddInstance(spawnable);
			}
		}
	}

	public void RemoveInstance(Spawnable spawnable)
	{
		if (spawnable.Population != null)
		{
			spawnable.Population.RemoveInstance(spawnable);
			if (!population2distribution.TryGetValue(spawnable.Population, out var value))
			{
				Debug.LogWarning((object)("[SpawnHandler] trying to remove instance from invalid population: " + (object)spawnable.Population));
			}
			else
			{
				value.RemoveInstance(spawnable);
			}
		}
	}

	public static float PlayerFraction()
	{
		float num = Mathf.Max(Server.maxplayers, 1);
		if (ConVar.Spawn.population_cap_rate > 0 && Server.maxplayers > ConVar.Spawn.population_cap_rate)
		{
			num = ConVar.Spawn.population_cap_rate;
		}
		return Mathf.Clamp01((float)PlayerCount / num);
	}

	public static float PlayerLerp(float min, float max)
	{
		return Mathf.Lerp(min, max, PlayerFraction());
	}

	public static float PlayerExcess()
	{
		float num = Mathf.Max(ConVar.Spawn.player_base, 1f);
		float num2 = PlayerCount;
		if (num2 > (float)ConVar.Spawn.population_cap_rate && ConVar.Spawn.population_cap_rate > 0)
		{
			num2 = ConVar.Spawn.population_cap_rate;
		}
		if (num2 <= num)
		{
			return 0f;
		}
		return (num2 - num) / num;
	}

	public static float PlayerScale(float scalar)
	{
		return Mathf.Max(1f, PlayerExcess() * scalar);
	}

	public void DumpReport(string filename)
	{
		File.AppendAllText(filename, "\r\n\r\nSpawnHandler Report:\r\n\r\n" + GetReport());
	}

	public string GetReport(bool detailed = true, string filter = null)
	{
		StringBuilder stringBuilder = new StringBuilder();
		if (AllSpawnPopulations == null)
		{
			stringBuilder.AppendLine("Spawn population array is null.");
		}
		if (SpawnDistributions == null)
		{
			stringBuilder.AppendLine("Spawn distribution array is null.");
		}
		if (AllSpawnPopulations != null && SpawnDistributions != null)
		{
			for (int i = 0; i < AllSpawnPopulations.Length; i++)
			{
				if (AllSpawnPopulations[i] == null)
				{
					continue;
				}
				SpawnPopulationBase spawnPopulationBase = AllSpawnPopulations[i];
				SpawnDistribution spawnDistribution = SpawnDistributions[i];
				if (filter != null && !((Object)spawnPopulationBase).name.Contains(filter))
				{
					continue;
				}
				if (spawnPopulationBase != null)
				{
					spawnPopulationBase.GetReportString(stringBuilder, detailed);
					if (spawnDistribution != null)
					{
						int count = spawnDistribution.Count;
						int targetCount = spawnPopulationBase.GetTargetCount(spawnDistribution);
						stringBuilder.AppendLine("\tPopulation: " + count + "/" + targetCount);
					}
					else
					{
						stringBuilder.AppendLine("\tDistribution #" + i + " is not set.");
					}
				}
				else
				{
					stringBuilder.AppendLine("Population #" + i + " is not set.");
				}
				stringBuilder.AppendLine();
			}
		}
		return stringBuilder.ToString();
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class StripRig : MonoBehaviour, IPrefabPreProcess
{
	public Transform root;

	public bool fromClient;

	public bool fromServer;

	bool IPrefabPreProcess.CanRunDuringBundling => true;

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (Object.op_Implicit((Object)(object)root) && ((serverside && fromServer) || (clientside && fromClient)))
		{
			SkinnedMeshRenderer component = ((Component)this).GetComponent<SkinnedMeshRenderer>();
			Strip(preProcess, component);
		}
		preProcess.RemoveComponent((Component)(object)this);
	}

	public void Strip(IPrefabProcessor preProcess, SkinnedMeshRenderer skinnedMeshRenderer)
	{
		List<Transform> list = Pool.Get<List<Transform>>();
		((Component)root).GetComponentsInChildren<Transform>(list);
		for (int num = list.Count - 1; num >= 0; num--)
		{
			if (preProcess != null)
			{
				preProcess.NominateForDeletion(((Component)list[num]).gameObject);
			}
			else
			{
				Object.DestroyImmediate((Object)(object)((Component)list[num]).gameObject);
			}
		}
		Pool.FreeUnmanaged<Transform>(ref list);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Oxide.Core;
using Rust;
using UnityEngine;

[CreateAssetMenu(fileName = "NewTechTree", menuName = "Rust/Tech Tree", order = 2)]
public class TechTreeData : ScriptableObject
{
	[Serializable]
	public class NodeInstance
	{
		public int id;

		public ItemDefinition itemDef;

		public Vector2 graphPosition;

		public List<int> outputs = new List<int>();

		public List<int> inputs = new List<int>();

		public string groupName;

		public int costOverride = -1;

		public bool IsGroup()
		{
			if ((Object)(object)itemDef == (Object)null && groupName != "Entry")
			{
				return !string.IsNullOrEmpty(groupName);
			}
			return false;
		}
	}

	public string shortname;

	public int nextID;

	public int techTreeLevel;

	public SoundDefinition openSound;

	public SoundDefinition closeSound;

	public List<Era> AllowedEras;

	[Tooltip("If true, this tech tree will only appear in a gamemode if it is assigned as allowed on the gamemode asset.")]
	public bool RequireGameMode;

	private Dictionary<int, NodeInstance> _idToNode;

	private NodeInstance _entryNode;

	public List<NodeInstance> nodes = new List<NodeInstance>();

	public NodeInstance GetByID(int id)
	{
		if (Application.isPlaying)
		{
			if (_idToNode == null)
			{
				_idToNode = nodes.ToDictionary((NodeInstance n) => n.id, (NodeInstance n) => n);
			}
			_idToNode.TryGetValue(id, out var value);
			return value;
		}
		_idToNode = null;
		foreach (NodeInstance node in nodes)
		{
			if (node.id == id)
			{
				return node;
			}
		}
		return null;
	}

	public NodeInstance GetEntryNode()
	{
		if (Application.isPlaying && _entryNode != null && _entryNode.groupName == "Entry")
		{
			return _entryNode;
		}
		_entryNode = null;
		foreach (NodeInstance node in nodes)
		{
			if (node.groupName == "Entry")
			{
				_entryNode = node;
				return node;
			}
		}
		Debug.LogError((object)"NO ENTRY NODE FOR TECH TREE, This will Fail hard");
		return null;
	}

	public void ClearInputs(NodeInstance node)
	{
		foreach (int output in node.outputs)
		{
			NodeInstance byID = GetByID(output);
			byID.inputs.Clear();
			ClearInputs(byID);
		}
	}

	public void SetupInputs(NodeInstance node)
	{
		foreach (int output in node.outputs)
		{
			NodeInstance byID = GetByID(output);
			if (!byID.inputs.Contains(node.id))
			{
				byID.inputs.Add(node.id);
			}
			SetupInputs(byID);
		}
	}

	public bool PlayerHasPathForUnlock(BasePlayer player, NodeInstance node)
	{
		object obj = Interface.CallHook("CanUnlockTechTreeNodePath", (object)player, (object)node, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		NodeInstance entryNode = GetEntryNode();
		if (entryNode == null)
		{
			return false;
		}
		return CheckChainRecursive(player, entryNode, node);
	}

	public bool CheckChainRecursive(BasePlayer player, NodeInstance start, NodeInstance target)
	{
		if (start.groupName != "Entry")
		{
			if (start.IsGroup())
			{
				foreach (int input in start.inputs)
				{
					if (!PlayerHasPathForUnlock(player, GetByID(input)))
					{
						return false;
					}
				}
			}
			else if (start.itemDef.IsAllowed((EraRestriction)4) && !HasPlayerUnlocked(player, start))
			{
				return false;
			}
		}
		bool result = false;
		foreach (int output in start.outputs)
		{
			if (output == target.id)
			{
				return true;
			}
			if (CheckChainRecursive(player, GetByID(output), target))
			{
				result = true;
			}
		}
		return result;
	}

	public bool PlayerCanUnlock(BasePlayer player, NodeInstance node)
	{
		object obj = Interface.CallHook("CanUnlockTechTreeNode", (object)player, (object)node, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PlayerHasPathForUnlock(player, node))
		{
			return !HasPlayerUnlocked(player, node);
		}
		return false;
	}

	public bool HasPlayerUnlocked(BasePlayer player, NodeInstance node)
	{
		if (node.IsGroup())
		{
			bool result = true;
			{
				foreach (int output in node.outputs)
				{
					NodeInstance byID = GetByID(output);
					if (!HasPlayerUnlocked(player, byID))
					{
						result = false;
					}
				}
				return result;
			}
		}
		return player.blueprints.HasUnlocked(node.itemDef);
	}

	public void GetNodesRequiredToUnlock(BasePlayer player, NodeInstance node, List<NodeInstance> foundNodes)
	{
		foundNodes.Add(node);
		if (node == GetEntryNode())
		{
			return;
		}
		if (node.inputs.Count == 1)
		{
			GetNodesRequiredToUnlock(player, GetByID(node.inputs[0]), foundNodes);
			return;
		}
		List<NodeInstance> list = Pool.Get<List<NodeInstance>>();
		int num = int.MaxValue;
		foreach (int input in node.inputs)
		{
			List<NodeInstance> list2 = Pool.Get<List<NodeInstance>>();
			GetNodesRequiredToUnlock(player, GetByID(input), list2);
			int num2 = 0;
			foreach (NodeInstance item in list2)
			{
				if (!((Object)(object)item.itemDef == (Object)null) && !HasPlayerUnlocked(player, item))
				{
					num2 += Workbench.ScrapForResearch(item.itemDef, 0, out var _);
				}
			}
			if (num2 < num)
			{
				list.Clear();
				list.AddRange(list2);
				num = num2;
			}
			Pool.FreeUnmanaged<NodeInstance>(ref list2);
		}
		foundNodes.AddRange(list);
		Pool.FreeUnmanaged<NodeInstance>(ref list);
	}

	public bool IsAllowedInEra(Era era)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if (AllowedEras == null || AllowedEras.Count == 0)
		{
			return true;
		}
		return AllowedEras.Contains(era);
	}

	public bool IsAllowedInGameMode(bool isServer)
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(isServer);
		if ((Object)(object)activeGameMode == (Object)null)
		{
			return !RequireGameMode;
		}
		return activeGameMode.IsAllowed(this);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeInstance
{
	public int id;

	public ItemDefinition itemDef;

	public Vector2 graphPosition;

	public List<int> outputs = new List<int>();

	public List<int> inputs = new List<int>();

	public string groupName;

	public int costOverride = -1;

	public bool IsGroup()
	{
		if ((Object)(object)itemDef == (Object)null && groupName != "Entry")
		{
			return !string.IsNullOrEmpty(groupName);
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class TriggerAchievement : TriggerBase
{
	public string statToIncrease = "";

	public string achievementOnEnter = "";

	public string requiredVehicleName = "";

	[Tooltip("Always set to true, clientside does not work, currently")]
	public bool serverSide = true;

	public bool allowDuringTutorial;

	[NonSerialized]
	private List<ulong> triggeredPlayers = new List<ulong>();

	public void OnPuzzleReset()
	{
		Reset();
	}

	public void Reset()
	{
		triggeredPlayers.Clear();
	}

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient && serverSide)
		{
			return null;
		}
		if (baseEntity.isServer && !serverSide)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if ((Object)(object)ent == (Object)null)
		{
			return;
		}
		BasePlayer component = ((Component)ent).GetComponent<BasePlayer>();
		if ((Object)(object)component == (Object)null || !component.IsAlive() || component.IsSleeping() || component.IsNpc || triggeredPlayers.Contains(component.userID))
		{
			return;
		}
		if (!string.IsNullOrEmpty(requiredVehicleName))
		{
			BaseVehicle mountedVehicle = component.GetMountedVehicle();
			if ((Object)(object)mountedVehicle == (Object)null || !mountedVehicle.ShortPrefabName.Contains(requiredVehicleName))
			{
				return;
			}
		}
		if (serverSide)
		{
			if (!string.IsNullOrEmpty(achievementOnEnter))
			{
				component.GiveAchievement(achievementOnEnter, allowDuringTutorial);
			}
			if (!string.IsNullOrEmpty(statToIncrease))
			{
				component.stats.Add(statToIncrease, 1);
				component.stats.Save(forceSteamSave: true);
			}
			triggeredPlayers.Add(component.userID);
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class TriggerAnalytic : TriggerBase, IServerComponent
{
	private struct RecentPlayerEntrance
	{
		public BasePlayer Player;

		public TimeSince Time;
	}

	public string AnalyticMessage;

	public float Timeout = 120f;

	private List<RecentPlayerEntrance> recentEntrances = new List<RecentPlayerEntrance>();

	internal override GameObject InterestedInObject(GameObject obj)
	{
		if (obj.ToBaseEntity() is BasePlayer { IsNpc: false, isServer: not false } basePlayer)
		{
			return ((Component)basePlayer).gameObject;
		}
		return null;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		base.OnEntityEnter(ent);
		BasePlayer basePlayer = ent.ToPlayer();
		if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsNpc)
		{
			CheckTimeouts();
			if (IsPlayerValid(basePlayer))
			{
				recentEntrances.Add(new RecentPlayerEntrance
				{
					Player = basePlayer,
					Time = TimeSince.op_Implicit(0f)
				});
			}
		}
	}

	private void CheckTimeouts()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		for (int num = recentEntrances.Count - 1; num >= 0; num--)
		{
			if (TimeSince.op_Implicit(recentEntrances[num].Time) > Timeout)
			{
				recentEntrances.RemoveAt(num);
			}
		}
	}

	private bool IsPlayerValid(BasePlayer p)
	{
		for (int i = 0; i < recentEntrances.Count; i++)
		{
			if ((Object)(object)recentEntrances[i].Player == (Object)(object)p)
			{
				return false;
			}
		}
		return true;
	}
}


private struct RecentPlayerEntrance
{
	public BasePlayer Player;

	public TimeSince Time;
}


using UnityEngine;

public class TriggerBanditZone : TriggerBase
{
	public float GetBanditZoneLevel(Vector3 pos)
	{
		return 1f;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Oxide.Core;
using Rust;
using UnityEngine;

public class TriggerBase : BaseMonoBehaviour
{
	[SerializeField]
	private LayerMask interestLayers;

	[NonSerialized]
	public HashSet<GameObject> contents;

	[NonSerialized]
	public HashSet<BaseEntity> entityContents;

	public Action<BaseNetworkable> OnEntityEnterTrigger;

	public Action<BaseNetworkable> OnEntityLeaveTrigger;

	private static bool _useExcludeLayers;

	private static readonly List<TriggerBase> _allTriggerBase = new List<TriggerBase>();

	public LayerMask InterestLayers
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return interestLayers;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			interestLayers = value;
			UpdateExcludeLayers();
		}
	}

	public bool HasAnyContents => !contents.IsNullOrEmpty();

	public bool HasAnyEntityContents => !entityContents.IsNullOrEmpty();

	[ClientVar]
	[ServerVar]
	public static bool UseExcludeLayers
	{
		get
		{
			return _useExcludeLayers;
		}
		set
		{
			if (_useExcludeLayers != value)
			{
				if (_useExcludeLayers)
				{
					ClearExcludeLayers();
				}
				if (!_useExcludeLayers)
				{
					SetExcludeLayers();
				}
			}
			_useExcludeLayers = value;
		}
	}

	protected virtual void Awake()
	{
		_allTriggerBase.Add(this);
		UpdateExcludeLayers();
	}

	private void UpdateExcludeLayers()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		if (!UseExcludeLayers)
		{
			return;
		}
		List<Collider> list = Pool.Get<List<Collider>>();
		((Component)this).gameObject.GetComponentsInChildren<Collider>(list);
		int num = ~LayerMask.op_Implicit(interestLayers);
		foreach (Collider item in list)
		{
			if (item.isTrigger)
			{
				item.excludeLayers = LayerMask.op_Implicit(LayerMask.op_Implicit(item.excludeLayers) | num);
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
	}

	[ServerVar]
	public static void ClearExcludeLayers()
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		Debug.Log((object)$"Clearing ExcludeLayers for {_allTriggerBase.Count} triggers");
		List<Collider> list = Pool.Get<List<Collider>>();
		foreach (TriggerBase item in _allTriggerBase)
		{
			if ((Object)(object)item == (Object)null)
			{
				continue;
			}
			((Component)item).gameObject.GetComponentsInChildren<Collider>(list);
			foreach (Collider item2 in list)
			{
				if (item2.isTrigger)
				{
					item2.excludeLayers = LayerMask.op_Implicit(0);
				}
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
	}

	[ServerVar]
	public static void SetExcludeLayers()
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		Debug.Log((object)$"Setting ExcludeLayers for {_allTriggerBase.Count} triggers");
		List<Collider> list = Pool.Get<List<Collider>>();
		foreach (TriggerBase item in _allTriggerBase)
		{
			if ((Object)(object)item == (Object)null)
			{
				continue;
			}
			((Component)item).gameObject.GetComponentsInChildren<Collider>(list);
			int num = ~LayerMask.op_Implicit(item.interestLayers);
			foreach (Collider item2 in list)
			{
				if (item2.isTrigger)
				{
					item2.excludeLayers = LayerMask.op_Implicit(num);
				}
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
	}

	public virtual GameObject InterestedInObject(GameObject obj)
	{
		int num = 1 << obj.layer;
		if ((((LayerMask)(ref interestLayers)).value & num) != num)
		{
			return null;
		}
		return obj;
	}

	internal virtual GameObject InterestedInObjectExitOnly(GameObject obj)
	{
		return InterestedInObject(obj);
	}

	internal virtual GameObject InterestedInObjectEnterOnly(GameObject obj)
	{
		return InterestedInObject(obj);
	}

	protected virtual void OnDisable()
	{
		if (!Application.isQuitting && contents != null)
		{
			GameObject[] array = contents.ToArray();
			foreach (GameObject targetObj in array)
			{
				OnTriggerExitImpl(targetObj);
			}
			contents = null;
		}
	}

	public virtual void OnEntityEnter(BaseEntity ent)
	{
		if (!((Object)(object)ent == (Object)null))
		{
			if (entityContents == null)
			{
				entityContents = new HashSet<BaseEntity>();
			}
			if (Interface.CallHook("OnEntityEnter", (object)this, (object)ent) == null)
			{
				entityContents.Add(ent);
				OnEntityEnterTrigger?.Invoke(ent);
			}
		}
	}

	public virtual void OnEntityLeave(BaseEntity ent)
	{
		if (entityContents != null && Interface.CallHook("OnEntityLeave", (object)this, (object)ent) == null)
		{
			entityContents.Remove(ent);
			OnEntityLeaveTrigger?.Invoke(ent);
		}
	}

	public virtual void OnObjectAdded(GameObject obj, Collider col)
	{
		if (!((Object)(object)obj == (Object)null))
		{
			BaseEntity baseEntity = obj.ToBaseEntity();
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.EnterTrigger(this);
				OnEntityEnter(baseEntity);
			}
		}
	}

	public virtual void OnObjectRemoved(GameObject obj)
	{
		if ((Object)(object)obj == (Object)null)
		{
			return;
		}
		BaseEntity baseEntity = obj.ToBaseEntity(allowDestroyed: true);
		if (!Object.op_Implicit((Object)(object)baseEntity))
		{
			return;
		}
		bool flag = false;
		foreach (GameObject content in contents)
		{
			if ((Object)(object)content == (Object)null)
			{
				Debug.LogWarning((object)("Trigger " + ((object)this).ToString() + " contains null object."));
			}
			else if ((Object)(object)content.ToBaseEntity(allowDestroyed: true) == (Object)(object)baseEntity)
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			baseEntity.LeaveTrigger(this);
			OnEntityLeave(baseEntity);
		}
	}

	public void RemoveInvalidEntities()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		if (entityContents.IsNullOrEmpty())
		{
			return;
		}
		Collider component = ((Component)this).GetComponent<Collider>();
		if ((Object)(object)component == (Object)null)
		{
			return;
		}
		Bounds bounds = component.bounds;
		((Bounds)(ref bounds)).Expand(1f);
		List<BaseEntity> list = null;
		foreach (BaseEntity entityContent in entityContents)
		{
			if ((Object)(object)entityContent == (Object)null)
			{
				if (Debugging.checktriggers)
				{
					Debug.LogWarning((object)("Trigger " + ((object)this).ToString() + " contains destroyed entity."));
				}
				if (list == null)
				{
					list = Pool.Get<List<BaseEntity>>();
				}
				list.Add(entityContent);
			}
			else if (!((Bounds)(ref bounds)).Contains(entityContent.ClosestPoint(((Component)this).transform.position)))
			{
				if (Debugging.checktriggers)
				{
					Debug.LogWarning((object)("Trigger " + ((object)this).ToString() + " contains entity that is too far away: " + ((object)entityContent).ToString()));
				}
				if (list == null)
				{
					list = Pool.Get<List<BaseEntity>>();
				}
				list.Add(entityContent);
			}
		}
		if (list == null)
		{
			return;
		}
		foreach (BaseEntity item in list)
		{
			RemoveEntity(item);
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	public bool CheckEntity(BaseEntity ent)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ent == (Object)null)
		{
			return true;
		}
		Collider component = ((Component)this).GetComponent<Collider>();
		if ((Object)(object)component == (Object)null)
		{
			return true;
		}
		Bounds bounds = component.bounds;
		((Bounds)(ref bounds)).Expand(1f);
		return ((Bounds)(ref bounds)).Contains(ent.ClosestPoint(((Component)this).transform.position));
	}

	public virtual void OnObjects()
	{
	}

	public virtual void OnEmpty()
	{
		contents = null;
		entityContents = null;
	}

	public void RemoveObject(GameObject obj)
	{
		if (!((Object)(object)obj == (Object)null))
		{
			Collider component = obj.GetComponent<Collider>();
			if (!((Object)(object)component == (Object)null))
			{
				OnTriggerExit(component);
			}
		}
	}

	public void RemoveEntity(BaseEntity ent)
	{
		if ((Object)(object)this == (Object)null || contents == null || (Object)(object)ent == (Object)null)
		{
			return;
		}
		List<GameObject> list = Pool.Get<List<GameObject>>();
		foreach (GameObject content in contents)
		{
			if ((Object)(object)content != (Object)null && (Object)(object)content.ToBaseEntity(allowDestroyed: true) == (Object)(object)ent)
			{
				list.Add(content);
			}
		}
		foreach (GameObject item in list)
		{
			OnTriggerExitImpl(item);
		}
		Pool.FreeUnmanaged<GameObject>(ref list);
	}

	public void OnTriggerEnter(Collider collider)
	{
		if ((Object)(object)this == (Object)null || !((Behaviour)this).enabled)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("TriggerBase.OnTriggerEnter", 0);
		try
		{
			GameObject val2 = InterestedInObjectEnterOnly(((Component)collider).gameObject);
			if ((Object)(object)val2 == (Object)null)
			{
				return;
			}
			if (contents == null)
			{
				contents = new HashSet<GameObject>();
			}
			if (contents.Contains(val2))
			{
				return;
			}
			int count = contents.Count;
			contents.Add(val2);
			OnObjectAdded(val2, collider);
			if (count == 0 && contents.Count == 1)
			{
				OnObjects();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		if (Debugging.checktriggers)
		{
			RemoveInvalidEntities();
		}
	}

	internal virtual bool SkipOnTriggerExit(Collider collider)
	{
		return false;
	}

	public void OnTriggerExit(Collider collider)
	{
		if ((Object)(object)this == (Object)null || (Object)(object)collider == (Object)null || SkipOnTriggerExit(collider))
		{
			return;
		}
		GameObject val = InterestedInObjectExitOnly(((Component)collider).gameObject);
		if (!((Object)(object)val == (Object)null))
		{
			OnTriggerExitImpl(val);
			if (Debugging.checktriggers)
			{
				RemoveInvalidEntities();
			}
		}
	}

	public void OnTriggerExitImpl(GameObject targetObj)
	{
		if (contents != null && contents.Contains(targetObj))
		{
			contents.Remove(targetObj);
			OnObjectRemoved(targetObj);
			if (contents == null || contents.Count == 0)
			{
				OnEmpty();
			}
		}
	}
}


using UnityEngine;

public class TriggerClanModify : TriggerBase
{
	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

public class TriggerComfort : TriggerBase
{
	public float triggerSize;

	public float baseComfort = 0.5f;

	public float minComfortRange = 2.5f;

	public bool applyToHorses;

	private const float perPlayerComfortBonus = 0.25f;

	private const float horseComfortBonus = 0.5f;

	private const float bonusComfort = 0f;

	private List<BaseEntity> _entities = new List<BaseEntity>();

	private void OnValidate()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		triggerSize = ((Component)this).GetComponent<SphereCollider>().radius * ((Component)this).transform.localScale.y;
	}

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public float CalculateComfort(Vector3 position, BasePlayer forPlayer = null)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3.Distance(((Component)this).gameObject.transform.position, position);
		float num2 = 1f - Mathf.Clamp(num - minComfortRange, 0f, num / (triggerSize - minComfortRange));
		bool flag = false;
		float num3 = 0f;
		foreach (BaseEntity entity in _entities)
		{
			if ((Object)(object)entity == (Object)(object)forPlayer)
			{
				continue;
			}
			if (entity is BasePlayer { IsNpc: false } basePlayer)
			{
				float num4 = 1f;
				if (basePlayer.IsSleeping())
				{
					num4 = 0.5f;
				}
				else if (!basePlayer.IsAlive())
				{
					num4 = 0f;
				}
				num3 += 0.25f * num4;
			}
			if (applyToHorses && (entity is RidableHorse || entity is RidableHorse) && !flag)
			{
				num3 += 0.5f;
				flag = true;
			}
		}
		float num5 = 0f + num3;
		return (baseComfort + num5) * num2;
	}

	public override void OnEntityEnter(BaseEntity ent)
	{
		if ((ent is BasePlayer || ent is RidableHorse || ent is RidableHorse) && Interface.CallHook("OnEntityEnter", (object)this, (object)ent) == null)
		{
			_entities.Add(ent);
		}
	}

	public override void OnEntityLeave(BaseEntity ent)
	{
		if ((ent is BasePlayer || ent is RidableHorse || ent is RidableHorse) && Interface.CallHook("OnEntityLeave", (object)this, (object)ent) == null)
		{
			_entities.Remove(ent);
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class TriggerDanceAchievement : TriggerBase
{
	public int RequiredPlayerCount = 3;

	public string AchievementName;

	[NonSerialized]
	private List<NetworkableId> triggeredPlayers = new List<NetworkableId>();

	public void OnPuzzleReset()
	{
		Reset();
	}

	public void Reset()
	{
		triggeredPlayers.Clear();
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (!(baseEntity is BasePlayer))
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public void NotifyDanceStarted()
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		if (entityContents == null)
		{
			return;
		}
		int num = 0;
		foreach (BaseEntity entityContent in entityContents)
		{
			if ((Object)(object)entityContent.ToPlayer() != (Object)null && entityContent.ToPlayer().CurrentGestureIsDance)
			{
				num++;
				if (num >= RequiredPlayerCount)
				{
					break;
				}
			}
		}
		if (num < RequiredPlayerCount)
		{
			return;
		}
		foreach (BaseEntity entityContent2 in entityContents)
		{
			if (!triggeredPlayers.Contains(entityContent2.net.ID) && (Object)(object)entityContent2.ToPlayer() != (Object)null)
			{
				entityContent2.ToPlayer().GiveAchievement(AchievementName);
				triggeredPlayers.Add(entityContent2.net.ID);
			}
		}
	}
}


using UnityEngine;

public class TriggerEnsnare : TriggerBase
{
	public bool blockHands = true;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


public class TriggerEnterTimer : TriggerBase
{
	public TimeSince EnterTime { get; private set; }

	internal override void OnEntityEnter(BaseEntity ent)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		bool hasAnyEntityContents = base.HasAnyEntityContents;
		base.OnEntityEnter(ent);
		if (!hasAnyEntityContents && base.HasAnyEntityContents)
		{
			EnterTime = TimeSince.op_Implicit(0f);
		}
	}
}


using UnityEngine;

public class TriggerForce : TriggerBase, IServerComponent
{
	public const float GravityMultiplier = 0.1f;

	public const float VelocityLerp = 10f;

	public const float AngularDrag = 10f;

	public Vector3 velocity = Vector3.forward;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public override void OnEntityEnter(BaseEntity ent)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		base.OnEntityEnter(ent);
		Vector3 val = ((Component)this).transform.TransformDirection(velocity);
		ent.ApplyInheritedVelocity(val);
	}

	public override void OnEntityLeave(BaseEntity ent)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		base.OnEntityLeave(ent);
		ent.ApplyInheritedVelocity(Vector3.zero);
	}

	protected void FixedUpdate()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (entityContents == null)
		{
			return;
		}
		Vector3 val = ((Component)this).transform.TransformDirection(velocity);
		foreach (BaseEntity entityContent in entityContents)
		{
			if ((Object)(object)entityContent != (Object)null)
			{
				entityContent.ApplyInheritedVelocity(val);
			}
		}
	}
}


public interface IHostileWarningEntity
{
	bool WarningEnabled(BaseEntity forEntity);

	float WarningRange();
}


using UnityEngine;

public class TriggerHostileWarningZone : TriggerBase
{
	public GameObject TargetGameObject;

	public Collider triggerCollider { get; private set; }

	protected override void Awake()
	{
		base.Awake();
		triggerCollider = ((Component)this).GetComponent<Collider>();
	}

	protected void OnEnable()
	{
		ResizeTrigger();
	}

	public void ResizeTrigger()
	{
		if ((Object)(object)TargetGameObject == (Object)null)
		{
			return;
		}
		BaseEntity baseEntity = TargetGameObject.ToBaseEntity();
		if (!((Object)(object)baseEntity == (Object)null) && baseEntity is IHostileWarningEntity hostileWarningEntity)
		{
			Collider obj = triggerCollider;
			SphereCollider val = (SphereCollider)(object)((obj is SphereCollider) ? obj : null);
			if ((Object)(object)val != (Object)null)
			{
				val.radius = hostileWarningEntity.WarningRange();
			}
		}
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public bool WarningEnabled(BaseEntity forEntity)
	{
		if ((Object)(object)TargetGameObject == (Object)null)
		{
			return true;
		}
		BaseEntity baseEntity = TargetGameObject.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return true;
		}
		if (baseEntity is IHostileWarningEntity hostileWarningEntity)
		{
			return hostileWarningEntity.WarningEnabled(forEntity);
		}
		return true;
	}
}


public interface IHurtTrigger
{
}


using System;
using System.Linq;
using Rust;
using UnityEngine;

public class TriggerHurt : TriggerBase, IServerComponent, IHurtTrigger
{
	public float DamagePerSecond = 1f;

	public float DamageTickRate = 4f;

	public DamageType damageType;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public override void OnObjects()
	{
		((FacepunchBehaviour)this).InvokeRepeating((Action)OnTick, 0f, 1f / DamageTickRate);
	}

	public override void OnEmpty()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)OnTick);
	}

	private void OnTick()
	{
		BaseEntity attacker = ((Component)this).gameObject.ToBaseEntity();
		if (entityContents == null)
		{
			return;
		}
		BaseEntity[] array = entityContents.ToArray();
		foreach (BaseEntity baseEntity in array)
		{
			if (baseEntity.IsValid())
			{
				BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
				if (!((Object)(object)baseCombatEntity == (Object)null) && CanHurt(baseCombatEntity))
				{
					baseCombatEntity.Hurt(DamagePerSecond * (1f / DamageTickRate), damageType, attacker);
				}
			}
		}
	}

	protected virtual bool CanHurt(BaseCombatEntity ent)
	{
		return true;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust;
using UnityEngine;

public class TriggerHurtNotChild : TriggerBase, IServerComponent, IHurtTrigger
{
	public interface IHurtTriggerUser
	{
		BasePlayer GetPlayerDamageInitiator();

		float GetDamageMultiplier(BaseEntity ent);

		void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal);
	}

	public float DamagePerSecond = 1f;

	public float DamageTickRate = 4f;

	public float DamageDelay;

	public DamageType damageType;

	public bool ignoreNPC = true;

	public float npcMultiplier = 1f;

	public float resourceMultiplier = 1f;

	public float lootContainerMultiplier = 1f;

	public bool triggerHitImpacts = true;

	public bool RequireUpAxis;

	public BaseEntity SourceEntity;

	public bool UseSourceEntityDamageMultiplier = true;

	public bool ignoreAllVehicleMounted;

	public float activationDelay;

	private Dictionary<BaseEntity, float> entryTimes;

	private TimeSince timeSinceAcivation;

	private IHurtTriggerUser hurtTiggerUser;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (ignoreNPC && baseEntity.IsNpc)
		{
			return null;
		}
		if (!Physics.treecollision && obj.layer == 30)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public override void OnObjects()
	{
		((FacepunchBehaviour)this).InvokeRepeating((Action)OnTick, 0f, 1f / DamageTickRate);
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if ((Object)(object)ent != (Object)null && DamageDelay > 0f)
		{
			if (entryTimes == null)
			{
				entryTimes = new Dictionary<BaseEntity, float>();
			}
			entryTimes.Add(ent, Time.time);
		}
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		if ((Object)(object)ent != (Object)null && entryTimes != null)
		{
			entryTimes.Remove(ent);
		}
		base.OnEntityLeave(ent);
	}

	public override void OnEmpty()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)OnTick);
	}

	protected void OnEnable()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		timeSinceAcivation = TimeSince.op_Implicit(0f);
		hurtTiggerUser = SourceEntity as IHurtTriggerUser;
	}

	public new void OnDisable()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)OnTick);
		base.OnDisable();
	}

	private bool IsInterested(BaseEntity ent)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		if (TimeSince.op_Implicit(timeSinceAcivation) < activationDelay)
		{
			return false;
		}
		BasePlayer basePlayer = ent.ToPlayer();
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (basePlayer.isMounted)
			{
				BaseVehicle mountedVehicle = basePlayer.GetMountedVehicle();
				if ((Object)(object)SourceEntity != (Object)null && (Object)(object)mountedVehicle == (Object)(object)SourceEntity)
				{
					return false;
				}
				if (ignoreAllVehicleMounted && (Object)(object)mountedVehicle != (Object)null)
				{
					return false;
				}
			}
			if ((Object)(object)SourceEntity != (Object)null && basePlayer.HasEntityInParents(SourceEntity))
			{
				return false;
			}
		}
		return true;
	}

	private void OnTick()
	{
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		if (entityContents.IsNullOrEmpty())
		{
			return;
		}
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		list.AddRange(entityContents);
		foreach (BaseEntity item in list)
		{
			if (item.IsValid() && IsInterested(item) && (!(DamageDelay > 0f) || entryTimes == null || !entryTimes.TryGetValue(item, out var value) || !(value + DamageDelay > Time.time)) && (!RequireUpAxis || !(Vector3.Dot(((Component)item).transform.up, ((Component)this).transform.up) < 0f)))
			{
				float num = DamagePerSecond * 1f / DamageTickRate;
				if (UseSourceEntityDamageMultiplier && hurtTiggerUser != null)
				{
					num *= hurtTiggerUser.GetDamageMultiplier(item);
				}
				if (item.IsNpc)
				{
					num *= npcMultiplier;
				}
				if (item is ResourceEntity)
				{
					num *= resourceMultiplier;
				}
				if (item is LootContainer)
				{
					num *= lootContainerMultiplier;
				}
				Vector3 val = ((Component)item).transform.position + Vector3.up * 1f;
				bool flag = item is BasePlayer || item is BaseNpc;
				BaseEntity baseEntity = null;
				BaseEntity weaponPrefab = null;
				if (hurtTiggerUser != null)
				{
					baseEntity = hurtTiggerUser.GetPlayerDamageInitiator();
					weaponPrefab = SourceEntity.LookupPrefab();
				}
				if ((Object)(object)baseEntity == (Object)null)
				{
					baseEntity = ((!((Object)(object)SourceEntity != (Object)null)) ? ((Component)this).gameObject.ToBaseEntity() : SourceEntity);
				}
				HitInfo hitInfo = new HitInfo
				{
					DoHitEffects = true,
					HitEntity = item,
					HitPositionWorld = val,
					HitPositionLocal = ((Component)item).transform.InverseTransformPoint(val),
					HitNormalWorld = Vector3.up,
					HitMaterial = (flag ? StringPool.Get("Flesh") : 0u),
					WeaponPrefab = weaponPrefab,
					Initiator = baseEntity
				};
				hitInfo.damageTypes = new DamageTypeList();
				hitInfo.damageTypes.Set(damageType, num);
				item.OnAttacked(hitInfo);
				if (hurtTiggerUser != null)
				{
					hurtTiggerUser.OnHurtTriggerOccupant(item, damageType, num);
				}
				if (triggerHitImpacts)
				{
					Effect.server.ImpactEffect(hitInfo);
				}
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		RemoveInvalidEntities();
	}
}


using Rust;

public interface IHurtTriggerUser
{
	BasePlayer GetPlayerDamageInitiator();

	float GetDamageMultiplier(BaseEntity ent);

	void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal);
}


using UnityEngine;

public class TriggerLadder : TriggerBase
{
	public enum LadderType
	{
		Rungs,
		Rope
	}

	public LadderType Type;

	public bool ForceLookAt;

	public bool RequireJumpToMount;

	public SoundDefinition ClimbFootstepSound;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if ((Object)(object)(baseEntity as BasePlayer) == (Object)null)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	internal override GameObject InterestedInObjectEnterOnly(GameObject obj)
	{
		obj = base.InterestedInObjectEnterOnly(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((baseEntity as BasePlayer).IsWounded())
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


public enum LadderType
{
	Rungs,
	Rope
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class TriggerMount : TriggerBase, IServerComponent
{
	private class EntryInfo
	{
		public float entryTime;

		public Vector3 entryPos;

		public EntryInfo(float entryTime, Vector3 entryPos)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			this.entryTime = entryTime;
			this.entryPos = entryPos;
		}

		public void Set(float entryTime, Vector3 entryPos)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			this.entryTime = entryTime;
			this.entryPos = entryPos;
		}
	}

	private const float MOUNT_DELAY = 3.5f;

	private const float MAX_MOVE = 0.5f;

	private Dictionary<BaseEntity, EntryInfo> entryInfo;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		BasePlayer basePlayer = baseEntity.ToPlayer();
		if ((Object)(object)basePlayer == (Object)null || basePlayer.IsNpc)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		base.OnEntityEnter(ent);
		if (entryInfo == null)
		{
			entryInfo = new Dictionary<BaseEntity, EntryInfo>();
		}
		entryInfo.Add(ent, new EntryInfo(Time.time, ((Component)ent).transform.position));
		((FacepunchBehaviour)this).Invoke((Action)CheckForMount, 3.6f);
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		if ((Object)(object)ent != (Object)null && entryInfo != null)
		{
			entryInfo.Remove(ent);
		}
		base.OnEntityLeave(ent);
	}

	private void CheckForMount()
	{
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		if (entityContents == null || entryInfo == null)
		{
			return;
		}
		foreach (KeyValuePair<BaseEntity, EntryInfo> item in entryInfo)
		{
			BaseEntity key = item.Key;
			if (!key.IsValid())
			{
				continue;
			}
			EntryInfo value = item.Value;
			BasePlayer basePlayer = key.ToPlayer();
			bool flag = (basePlayer.IsAdmin || basePlayer.IsDeveloper) && basePlayer.IsFlying;
			if (!((Object)(object)basePlayer != (Object)null) || !basePlayer.IsAlive() || flag)
			{
				continue;
			}
			bool flag2 = false;
			if (!basePlayer.isMounted && !basePlayer.IsSleeping() && value.entryTime + 3.5f < Time.time && Vector3.Distance(((Component)key).transform.position, value.entryPos) < 0.5f)
			{
				BaseVehicle componentInParent = ((Component)this).GetComponentInParent<BaseVehicle>();
				if ((Object)(object)componentInParent != (Object)null && !componentInParent.IsDead())
				{
					componentInParent.AttemptMount(basePlayer);
					flag2 = true;
				}
			}
			if (!flag2)
			{
				value.Set(Time.time, ((Component)key).transform.position);
				((FacepunchBehaviour)this).Invoke((Action)CheckForMount, 3.6f);
			}
		}
	}
}


using UnityEngine;

private class EntryInfo
{
	public float entryTime;

	public Vector3 entryPos;

	public EntryInfo(float entryTime, Vector3 entryPos)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		this.entryTime = entryTime;
		this.entryPos = entryPos;
	}

	public void Set(float entryTime, Vector3 entryPos)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		this.entryTime = entryTime;
		this.entryPos = entryPos;
	}
}


using System.Collections.Generic;
using UnityEngine;

[RequireComponent(typeof(SphereCollider))]
public class TriggerNoRespawnZone : TriggerBase
{
	public static List<TriggerNoRespawnZone> allNRZones = new List<TriggerNoRespawnZone>();

	public float maxDepth = 20f;

	public float maxAltitude = -1f;

	private SphereCollider sphereCollider;

	private float radiusSqr;

	protected override void Awake()
	{
		base.Awake();
		sphereCollider = ((Component)this).GetComponent<SphereCollider>();
		radiusSqr = sphereCollider.radius * sphereCollider.radius;
	}

	protected void OnEnable()
	{
		allNRZones.Add(this);
	}

	protected override void OnDisable()
	{
		base.OnDisable();
		allNRZones.Remove(this);
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BasePlayer basePlayer = obj.ToBaseEntity() as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null)
		{
			return null;
		}
		if (basePlayer.isClient)
		{
			return null;
		}
		return ((Component)basePlayer).gameObject;
	}

	public static bool InAnyNoRespawnZone(Vector3 theirPos)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < allNRZones.Count; i++)
		{
			if (allNRZones[i].InNoRespawnZone(theirPos, checkRadius: true))
			{
				return true;
			}
		}
		return false;
	}

	public bool InNoRespawnZone(Vector3 theirPos, bool checkRadius)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position + sphereCollider.center;
		if (checkRadius && Vector3.SqrMagnitude(val - theirPos) > radiusSqr)
		{
			return false;
		}
		float num = Mathf.Abs(val.y - theirPos.y);
		if (maxDepth != -1f && theirPos.y < val.y && num > maxDepth)
		{
			return false;
		}
		if (maxAltitude != -1f && theirPos.y > val.y && num > maxAltitude)
		{
			return false;
		}
		return true;
	}
}


using UnityEngine;

public class TriggerNoSpray : TriggerBase
{
	public BoxCollider TriggerCollider;

	private OBB cachedBounds;

	private Transform cachedTransform;

	private void OnEnable()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		cachedTransform = ((Component)this).transform;
		cachedBounds = new OBB(cachedTransform, new Bounds(TriggerCollider.center, TriggerCollider.size));
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if ((Object)(object)baseEntity.ToPlayer() == (Object)null)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public bool IsPositionValid(Vector3 worldPosition)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return !((OBB)(ref cachedBounds)).Contains(worldPosition);
	}
}


using UnityEngine;

public class TriggerNotify : TriggerBase, IPrefabPreProcess
{
	public GameObject notifyTarget;

	private INotifyTrigger toNotify;

	public bool runClientside = true;

	public bool runServerside = true;

	public bool HasContents
	{
		get
		{
			if (contents != null)
			{
				return contents.Count > 0;
			}
			return false;
		}
	}

	bool IPrefabPreProcess.CanRunDuringBundling => true;

	internal override void OnObjects()
	{
		base.OnObjects();
		if (toNotify != null || ((Object)(object)notifyTarget != (Object)null && notifyTarget.TryGetComponent<INotifyTrigger>(ref toNotify)))
		{
			toNotify.OnObjects(this);
		}
	}

	internal override void OnEmpty()
	{
		base.OnEmpty();
		if (toNotify != null || ((Object)(object)notifyTarget != (Object)null && notifyTarget.TryGetComponent<INotifyTrigger>(ref toNotify)))
		{
			toNotify.OnEmpty();
		}
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if ((!clientside || !runClientside) && (!serverside || !runServerside))
		{
			preProcess.RemoveComponent((Component)(object)this);
		}
	}
}


public interface INotifyTrigger
{
	void OnObjects(TriggerNotify trigger);

	void OnEmpty();
}


using UnityEngine;

public class TriggerNotifyEntity : TriggerBase, IPrefabPreProcess
{
	public GameObject notifyTarget;

	private INotifyEntityTrigger toNotify;

	public bool runClientside = true;

	public bool runServerside = true;

	public bool HasContents
	{
		get
		{
			if (contents != null)
			{
				return contents.Count > 0;
			}
			return false;
		}
	}

	bool IPrefabPreProcess.CanRunDuringBundling => true;

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if (toNotify != null || ((Object)(object)notifyTarget != (Object)null && notifyTarget.TryGetComponent<INotifyEntityTrigger>(ref toNotify)))
		{
			toNotify.OnEntityEnter(ent);
		}
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
		if (toNotify != null || ((Object)(object)notifyTarget != (Object)null && notifyTarget.TryGetComponent<INotifyEntityTrigger>(ref toNotify)))
		{
			toNotify.OnEntityLeave(ent);
		}
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if ((!clientside || !runClientside) && (!serverside || !runServerside))
		{
			preProcess.RemoveComponent((Component)(object)this);
		}
	}
}


public interface INotifyEntityTrigger
{
	void OnEntityEnter(BaseEntity ent);

	void OnEntityLeave(BaseEntity ent);
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust;
using UnityEngine;

[RequireComponent(typeof(Collider))]
public class TriggerParent : TriggerBase, IServerComponent
{
	[Header("General")]
	[Tooltip("Deparent if the parented entity clips into an obstacle")]
	[SerializeField]
	public bool doClippingCheck;

	[Tooltip("If deparenting via clipping, this will be used (if assigned) to also move the entity to a valid dismount position")]
	public BaseMountable associatedMountable;

	[Tooltip("Needed if the player might dismount inside the trigger and the trigger might be moving. Being mounting inside the trigger lets them dismount in local trigger-space, which means client and server will sync up.Otherwise the client/server delay can have them dismounting into invalid space.")]
	public bool parentMountedPlayers;

	[Tooltip("Sleepers don't have all the checks (e.g. clipping) that awake players get. If that might be a problem,sleeper parenting can be disabled. You'll need an associatedMountable though so that the sleeper can be dismounted.")]
	public bool parentSleepers = true;

	[Tooltip("This was added to allow parenting in some cases with sinking tugboats, it's generally not needed")]
	public bool parentSwimmers;

	[Header("NPC")]
	public bool ParentNPCPlayers;

	[Tooltip("When parenting an NPC don't check if they are shop keepers or mission providers.")]
	public bool SkipNPCChecks;

	[Tooltip("If the player is already parented to something else, they'll switch over to another parent only if this is true")]
	[Header("Other")]
	public bool overrideOtherTriggers;

	[Tooltip("Requires associatedMountable to be set. Prevents players entering the trigger if there's something between their feet and the bottom of the parent trigger")]
	public bool checkForObjUnderFeet;

	public const int CLIP_CHECK_MASK = 1218511105;

	protected float triggerHeight;

	private BasePlayer killPlayerTemp;

	protected override void Awake()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		base.Awake();
		Collider component = ((Component)this).GetComponent<Collider>();
		Bounds bounds = component.bounds;
		triggerHeight = ((Bounds)(ref bounds)).size.y;
	}

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public override void OnEntityEnter(BaseEntity ent)
	{
		if (!(ent is NPCPlayer npcPly) || (ParentNPCPlayers && CanParentNPC(npcPly)))
		{
			if (ShouldParent(ent))
			{
				Parent(ent);
			}
			base.OnEntityEnter(ent);
			if (entityContents != null && entityContents.Count == 1)
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)OnTick, 0f, 0f);
			}
		}
	}

	public override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
		if (entityContents == null || entityContents.Count == 0)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)OnTick);
		}
		BasePlayer basePlayer = ent.ToPlayer();
		if (!parentSleepers || !((Object)(object)basePlayer != (Object)null) || !basePlayer.IsSleeping())
		{
			Unparent(ent);
		}
	}

	internal virtual bool CanParentNPC(NPCPlayer npcPly)
	{
		if (SkipNPCChecks)
		{
			return true;
		}
		if (npcPly is NPCShopKeeper)
		{
			return false;
		}
		return true;
	}

	public virtual bool ShouldParent(BaseEntity ent, bool bypassOtherTriggerCheck = false)
	{
		if (!ent.canTriggerParent)
		{
			return false;
		}
		if (!bypassOtherTriggerCheck && !overrideOtherTriggers)
		{
			BaseEntity parentEntity = ent.GetParentEntity();
			if (parentEntity.IsValid() && (Object)(object)parentEntity != (Object)(object)((Component)this).gameObject.ToBaseEntity())
			{
				return false;
			}
		}
		if ((Object)(object)ent.FindTrigger<TriggerParentExclusion>() != (Object)null && (!ent.FindTrigger<TriggerParentExclusion>().IgnoreIfOnLadder || !(ent is BasePlayer basePlayer) || !basePlayer.OnLadder()))
		{
			return false;
		}
		if (doClippingCheck && IsClipping(ent) && !(ent is BaseCorpse))
		{
			return false;
		}
		if (checkForObjUnderFeet && HasObjUnderFeet(ent))
		{
			return false;
		}
		BasePlayer basePlayer2 = ent.ToPlayer();
		if ((Object)(object)basePlayer2 != (Object)null)
		{
			if (!parentSwimmers && basePlayer2.IsSwimming())
			{
				return false;
			}
			if (!parentMountedPlayers && basePlayer2.isMounted)
			{
				return false;
			}
			if (!parentSleepers && basePlayer2.IsSleeping())
			{
				return false;
			}
			if (basePlayer2.isMounted && (Object)(object)associatedMountable != (Object)null && !IsParentedToUs(basePlayer2) && !associatedMountable.HasValidDismountPosition(basePlayer2))
			{
				return false;
			}
		}
		return true;
	}

	public void ForceParentEarly(BaseEntity ent)
	{
		OnEntityEnter(ent);
		((FacepunchBehaviour)this).Invoke((Action)CheckAllParenting, 0.1f);
	}

	private void CheckAllParenting()
	{
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		if (contents != null)
		{
			foreach (GameObject content in contents)
			{
				if (!((Object)(object)content == (Object)null))
				{
					BaseEntity baseEntity = content.ToBaseEntity();
					if ((Object)(object)baseEntity != (Object)null && !list.Contains(baseEntity))
					{
						list.Add(baseEntity);
					}
				}
			}
		}
		List<BaseEntity> list2 = Pool.Get<List<BaseEntity>>();
		foreach (BaseEntity entityContent in entityContents)
		{
			if (!list.Contains(entityContent))
			{
				list2.Add(entityContent);
			}
		}
		foreach (BaseEntity item in list2)
		{
			OnEntityLeave(item);
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list2);
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	protected void Parent(BaseEntity ent)
	{
		BaseEntity baseEntity = ((Component)this).gameObject.ToBaseEntity();
		if (!((Object)(object)ent.GetParentEntity() == (Object)(object)baseEntity) && !((Object)(object)baseEntity.GetParentEntity() == (Object)(object)ent))
		{
			ent.SetParent(((Component)this).gameObject.ToBaseEntity(), worldPositionStays: true, sendImmediate: true);
		}
	}

	protected void Unparent(BaseEntity ent)
	{
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ent.GetParentEntity() != (Object)(object)((Component)this).gameObject.ToBaseEntity())
		{
			return;
		}
		if (ent.IsValid() && !ent.IsDestroyed)
		{
			TriggerParent triggerParent = ent.FindSuitableParent();
			if ((Object)(object)triggerParent != (Object)null && ((Component)triggerParent).gameObject.ToBaseEntity().IsValid())
			{
				triggerParent.Parent(ent);
				return;
			}
		}
		ent.SetParent(null, worldPositionStays: true, sendImmediate: true);
		BasePlayer basePlayer = ent.ToPlayer();
		if (!((Object)(object)basePlayer != (Object)null))
		{
			return;
		}
		basePlayer.unparentTime = Time.time;
		basePlayer.PauseFlyHackDetection(5f);
		basePlayer.PauseSpeedHackDetection(5f);
		basePlayer.PauseTickDistanceDetection(5f);
		if (AntiHack.TestNoClipping(basePlayer, ((Component)basePlayer).transform.position, ((Component)basePlayer).transform.position, BasePlayer.NoClipRadius(ConVar.AntiHack.noclip_margin), ConVar.AntiHack.noclip_backtracking, out var _, vehicleLayer: true))
		{
			basePlayer.PauseVehicleNoClipDetection(5f);
		}
		if ((Object)(object)associatedMountable != (Object)null && ((doClippingCheck && IsClipping(ent)) || basePlayer.IsSleeping()))
		{
			if (associatedMountable.GetDismountPosition(basePlayer, out var res))
			{
				basePlayer.MovePosition(res, forceUpdateTriggers: false);
				((Component)basePlayer).transform.rotation = Quaternion.identity;
				basePlayer.SendNetworkUpdateImmediate();
				basePlayer.ClientRPC(RpcTarget.Player("ForcePositionTo", basePlayer), res);
			}
			else
			{
				killPlayerTemp = basePlayer;
				((FacepunchBehaviour)this).Invoke((Action)KillPlayerDelayed, 0f);
			}
		}
	}

	private bool IsParentedToUs(BaseEntity ent)
	{
		BaseEntity baseEntity = ((Component)this).gameObject.ToBaseEntity();
		return (Object)(object)ent.GetParentEntity() == (Object)(object)baseEntity;
	}

	private void KillPlayerDelayed()
	{
		if (killPlayerTemp.IsValid() && !killPlayerTemp.IsDead())
		{
			killPlayerTemp.Hurt(1000f, DamageType.Suicide, killPlayerTemp, useProtection: false);
		}
		killPlayerTemp = null;
	}

	private void OnTick()
	{
		if (entityContents == null)
		{
			return;
		}
		BaseEntity baseEntity = ((Component)this).gameObject.ToBaseEntity();
		if (!baseEntity.IsValid() || baseEntity.IsDestroyed)
		{
			return;
		}
		foreach (BaseEntity entityContent in entityContents)
		{
			if (entityContent.IsValid() && !entityContent.IsDestroyed)
			{
				if (ShouldParent(entityContent))
				{
					Parent(entityContent);
				}
				else
				{
					Unparent(entityContent);
				}
			}
		}
	}

	protected virtual bool IsClipping(BaseEntity ent)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GamePhysics.CheckOBB(ent.WorldSpaceBounds(), 1218511105, (QueryTriggerInteraction)1);
	}

	private bool HasObjUnderFeet(BaseEntity ent)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ent.PivotPoint() + ((Component)ent).transform.up * 0.1f;
		float maxDistance = triggerHeight + 0.1f;
		if (GamePhysics.Trace(new Ray(val, -((Component)this).transform.up), 0f, out var hitInfo, maxDistance, 1503731969, (QueryTriggerInteraction)1, ent) && (Object)(object)((RaycastHit)(ref hitInfo)).collider != (Object)null)
		{
			BaseEntity toFind = ((Component)this).gameObject.ToBaseEntity();
			BaseEntity baseEntity = ((RaycastHit)(ref hitInfo)).collider.ToBaseEntity();
			if ((Object)(object)baseEntity == (Object)null || !baseEntity.HasEntityInParents(toFind))
			{
				return true;
			}
		}
		return false;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class TriggerParentElevator : TriggerParentEnclosed
{
	public bool AllowHorsesToBypassClippingChecks = true;

	public bool AllowBikesToBypassClippingChecks = true;

	public bool IgnoreParentEntityColliders;

	protected override bool IsClipping(BaseEntity ent)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		if (AllowHorsesToBypassClippingChecks && ent is RidableHorse)
		{
			return false;
		}
		if ((AllowBikesToBypassClippingChecks && ent is Bike) || ent is Snowmobile)
		{
			return false;
		}
		if (IgnoreParentEntityColliders)
		{
			List<Collider> list = Pool.Get<List<Collider>>();
			GamePhysics.OverlapOBB(ent.WorldSpaceBounds(), list, 1218511105, (QueryTriggerInteraction)1);
			BaseEntity baseEntity = ((Component)this).gameObject.ToBaseEntity();
			foreach (Collider item in list)
			{
				BaseEntity baseEntity2 = item.ToBaseEntity();
				if ((Object)(object)baseEntity2 != (Object)null)
				{
					if (!((Object)(object)baseEntity2 == (Object)(object)baseEntity) && !(baseEntity2 is Elevator))
					{
					}
					continue;
				}
				return true;
			}
			Pool.FreeUnmanaged<Collider>(ref list);
			return false;
		}
		return base.IsClipping(ent);
	}
}


using ConVar;
using UnityEngine;

public class TriggerParentEnclosed : TriggerParent
{
	public enum TriggerMode
	{
		TriggerPoint,
		PivotPoint
	}

	public float Padding;

	[Tooltip("AnyIntersect: Look for any intersection with the trigger. OriginIntersect: Only consider objects in the trigger if their origin is inside")]
	public TriggerMode intersectionMode;

	public bool CheckBoundsOnUnparent;

	public BoxCollider boxCollider;

	protected void OnEnable()
	{
		boxCollider = ((Component)this).GetComponent<BoxCollider>();
	}

	public override bool ShouldParent(BaseEntity ent, bool bypassOtherTriggerCheck = false)
	{
		if (!base.ShouldParent(ent, bypassOtherTriggerCheck))
		{
			return false;
		}
		return IsInside(ent, Padding);
	}

	internal override bool SkipOnTriggerExit(Collider collider)
	{
		if (!CheckBoundsOnUnparent)
		{
			return false;
		}
		if (!Debugging.checkparentingtriggers)
		{
			return false;
		}
		BaseEntity baseEntity = collider.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return false;
		}
		return IsInside(baseEntity, 0f);
	}

	public bool IsInside(BaseEntity ent, float padding)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		Bounds val = default(Bounds);
		((Bounds)(ref val))..ctor(boxCollider.center, boxCollider.size);
		if (padding > 0f)
		{
			((Bounds)(ref val)).Expand(padding);
		}
		OBB val2 = default(OBB);
		((OBB)(ref val2))..ctor(((Component)boxCollider).transform, val);
		Vector3 val3 = ((intersectionMode == TriggerMode.TriggerPoint) ? ent.TriggerPoint() : ent.PivotPoint());
		return ((OBB)(ref val2)).Contains(val3);
	}
}


public enum TriggerMode
{
	TriggerPoint,
	PivotPoint
}


using UnityEngine;

public class TriggerParentExclusion : TriggerBase, IServerComponent
{
	public bool IgnoreIfOnLadder;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (IgnoreIfOnLadder && baseEntity is BasePlayer basePlayer && basePlayer.OnLadder())
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


public interface IPathListener
{
	void OnSplinePathTrigger(int pathId, WorldSpline spline, int direction);

	void OnBasePathTrigger(int pathId, BasePath path);
}


using UnityEngine;

public class TriggerPath : TriggerBase, IServerComponent
{
	public int pathTriggerId;

	[Header("Path")]
	public BasePath path;

	[Header("Spline")]
	public WorldSpline spline;

	public int splineDirection = 1;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isServer)
		{
			return ((Component)baseEntity).gameObject;
		}
		return null;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		IPathListener pathListener = default(IPathListener);
		if (((Component)ent).TryGetComponent<IPathListener>(ref pathListener))
		{
			if (Object.op_Implicit((Object)(object)spline))
			{
				pathListener.OnSplinePathTrigger(pathTriggerId, spline, splineDirection);
			}
			if (Object.op_Implicit((Object)(object)path))
			{
				pathListener.OnBasePathTrigger(pathTriggerId, path);
			}
		}
	}
}


using System;
using UnityEngine;

public class TriggerPlayerForce : TriggerBase, IServerComponent
{
	public BoxCollider triggerCollider;

	public float pushVelocity = 5f;

	public bool requireUpAxis;

	private const float HACK_DISABLE_TIME = 4f;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			return ((Component)baseEntity).gameObject;
		}
		return null;
	}

	internal override void OnObjects()
	{
		((FacepunchBehaviour)this).InvokeRepeating((Action)HackDisableTick, 0f, 3.75f);
	}

	internal override void OnEmpty()
	{
		base.OnEmpty();
		((FacepunchBehaviour)this).CancelInvoke((Action)HackDisableTick);
	}

	protected override void OnDisable()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)HackDisableTick);
		base.OnDisable();
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		base.OnEntityLeave(ent);
		ent.ApplyInheritedVelocity(Vector3.zero);
	}

	private void HackDisableTick()
	{
		if (entityContents == null || !((Behaviour)this).enabled)
		{
			return;
		}
		foreach (BaseEntity entityContent in entityContents)
		{
			if (IsInterested(entityContent))
			{
				BasePlayer basePlayer = entityContent.ToPlayer();
				if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsNpc)
				{
					basePlayer.PauseVehicleNoClipDetection(4f);
					basePlayer.PauseSpeedHackDetection(4f);
				}
			}
		}
	}

	protected void FixedUpdate()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		if (entityContents == null)
		{
			return;
		}
		foreach (BaseEntity entityContent in entityContents)
		{
			if ((!requireUpAxis || !(Vector3.Dot(((Component)entityContent).transform.up, ((Component)this).transform.up) < 0f)) && IsInterested(entityContent))
			{
				Vector3 velocity = GetPushVelocity(((Component)entityContent).gameObject);
				entityContent.ApplyInheritedVelocity(velocity);
			}
		}
	}

	private Vector3 GetPushVelocity(GameObject obj)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		Bounds bounds = ((Collider)triggerCollider).bounds;
		Vector3 val = -(((Bounds)(ref bounds)).center - obj.transform.position);
		((Vector3)(ref val)).Normalize();
		val.y = 0.2f;
		((Vector3)(ref val)).Normalize();
		return val * pushVelocity;
	}

	private bool IsInterested(BaseEntity entity)
	{
		if ((Object)(object)entity == (Object)null || entity.isClient)
		{
			return false;
		}
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer != (Object)null)
		{
			if ((basePlayer.IsAdmin || basePlayer.IsDeveloper) && basePlayer.IsFlying)
			{
				return false;
			}
			if ((Object)(object)basePlayer != (Object)null && basePlayer.IsAlive())
			{
				return !basePlayer.isMounted;
			}
			return false;
		}
		return true;
	}
}


using System;
using UnityEngine;

public class TriggerPlayerMovePos : TriggerBase, IServerComponent
{
	public BoxCollider triggerCollider;

	public Vector3 relativeMoveVector = Vector3.up;

	public bool shouldPauseMarkHostile;

	private const float HACK_DISABLE_TIME = 1.5f;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			return ((Component)baseEntity).gameObject;
		}
		return null;
	}

	internal override void OnObjects()
	{
		((FacepunchBehaviour)this).InvokeRepeating((Action)HackDisableTick, 0f, 1.25f);
	}

	internal override void OnEmpty()
	{
		base.OnEmpty();
		((FacepunchBehaviour)this).CancelInvoke((Action)HackDisableTick);
	}

	protected override void OnDisable()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)HackDisableTick);
		base.OnDisable();
	}

	private void HackDisableTick()
	{
		if (entityContents == null || !((Behaviour)this).enabled)
		{
			return;
		}
		foreach (BaseEntity entityContent in entityContents)
		{
			if (IsInterested(entityContent))
			{
				BasePlayer basePlayer = entityContent.ToPlayer();
				if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsNpc)
				{
					basePlayer.PauseVehicleNoClipDetection(1.5f);
					basePlayer.PauseSpeedHackDetection(1.5f);
				}
			}
		}
	}

	protected void FixedUpdate()
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (entityContents == null)
		{
			return;
		}
		foreach (BaseEntity entityContent in entityContents)
		{
			if (IsInterested(entityContent))
			{
				BasePlayer basePlayer = entityContent.ToPlayer();
				if ((Object)(object)basePlayer != (Object)null && shouldPauseMarkHostile)
				{
					basePlayer.SetHostilePauseTime();
				}
				Transform transform = ((Component)entityContent).transform;
				Bounds bounds = ((Collider)triggerCollider).bounds;
				transform.position = ((Bounds)(ref bounds)).center + relativeMoveVector;
			}
		}
	}

	private bool IsInterested(BaseEntity entity)
	{
		if ((Object)(object)entity == (Object)null || entity.isClient)
		{
			return false;
		}
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer != (Object)null)
		{
			if ((basePlayer.IsAdmin || basePlayer.IsDeveloper) && basePlayer.IsFlying)
			{
				return false;
			}
			if ((Object)(object)basePlayer != (Object)null && basePlayer.IsAlive())
			{
				return !basePlayer.isMounted;
			}
			return false;
		}
		return true;
	}
}


using System;
using Rust;
using UnityEngine;

public class TriggerPlayerTimer : TriggerBase, IServerComponent
{
	public BaseEntity TargetEntity;

	public float DamageAmount = 20f;

	public float TimeToDamage = 3f;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj != (Object)null)
		{
			BaseEntity baseEntity = obj.ToBaseEntity();
			if (baseEntity is BasePlayer basePlayer && baseEntity.isServer && !basePlayer.isMounted)
			{
				return ((Component)baseEntity).gameObject;
			}
		}
		return obj;
	}

	internal override void OnObjects()
	{
		base.OnObjects();
		((FacepunchBehaviour)this).Invoke((Action)DamageTarget, TimeToDamage);
	}

	internal override void OnEmpty()
	{
		base.OnEmpty();
		((FacepunchBehaviour)this).CancelInvoke((Action)DamageTarget);
	}

	private void DamageTarget()
	{
		bool flag = false;
		foreach (BaseEntity entityContent in entityContents)
		{
			if (entityContent is BasePlayer { isMounted: false })
			{
				flag = true;
			}
		}
		if (flag && (Object)(object)TargetEntity != (Object)null)
		{
			TargetEntity.OnAttacked(new HitInfo(null, TargetEntity, DamageType.Generic, DamageAmount));
		}
		((FacepunchBehaviour)this).Invoke((Action)DamageTarget, TimeToDamage);
	}
}


using ConVar;
using Rust.Ai;
using UnityEngine;

public class TriggerQTE : TriggerBase, IServerComponent
{
	public WildlifeHazard Entity;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if ((Object)(object)(baseEntity as BasePlayer) == (Object)null)
		{
			return null;
		}
		if (baseEntity.IsNpc)
		{
			return null;
		}
		if (AI.ignoreplayers)
		{
			return null;
		}
		if (SimpleAIMemory.PlayerIgnoreList.Contains(baseEntity as BasePlayer))
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if ((Object)(object)Entity == (Object)null)
		{
			Debug.LogWarning((object)"TriggerQTE with no Entity linked", (Object)(object)((Component)this).gameObject);
		}
		else
		{
			Entity.TriggeredByPlayer(ent as BasePlayer);
		}
	}
}


using UnityEngine;
using UnityEngine.Serialization;

public class TriggerRadiation : TriggerBase
{
	[Tooltip("Higher the tier, higher the radiations.")]
	public Radiation.Tier radiationTier = Radiation.Tier.LOW;

	[Tooltip("The radiation amount is determined by the radiation tier, setting this will ignore the tier and use that value instead.")]
	public float RadiationAmountOverride;

	public bool BypassArmor;

	[Tooltip("The fraction of the radius where we fade in from 0-1 dosage.")]
	[Min(0f)]
	[Space]
	public float falloff = 0.1f;

	public bool usePerAxisFalloff;

	public Vector3 falloffPerAxis;

	[Space]
	[Tooltip("Use sphere collider size instead of the transform scale. For sphere triggers only (doesn't make sense for boxes)")]
	[FormerlySerializedAs("UseColliderRadius")]
	public bool DontScaleRadiationSize;

	public bool UseLOSCheck;

	[Tooltip("For sphere triggers only. If enabled, player will take more rads when close to the center of the volume.")]
	public bool IncreaseDamageNearCenter = true;

	public bool ApplyLocalHeightCheck;

	[Tooltip("For sprinklers needing an half sphere trigger.")]
	public float MinLocalHeight;

	private SphereCollider sphereCollider;

	private BoxCollider boxCollider;

	public bool UseColliderScale => DontScaleRadiationSize;

	private bool UseSphere
	{
		get
		{
			if ((Object)(object)sphereCollider == (Object)null)
			{
				sphereCollider = ((Component)this).GetComponent<SphereCollider>();
			}
			return (Object)(object)sphereCollider != (Object)null;
		}
	}

	private bool UseBox
	{
		get
		{
			if ((Object)(object)boxCollider == (Object)null)
			{
				boxCollider = ((Component)this).GetComponent<BoxCollider>();
			}
			return (Object)(object)boxCollider != (Object)null;
		}
	}

	protected override void Awake()
	{
		base.Awake();
		boxCollider = ((Component)this).GetComponent<BoxCollider>();
		sphereCollider = ((Component)this).GetComponent<SphereCollider>();
	}

	private float GetRadiationRadius()
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)sphereCollider != (Object)null)
		{
			if (UseColliderScale)
			{
				return sphereCollider.radius;
			}
			return sphereCollider.radius * Vector3Ex.Max(((Component)this).transform.localScale);
		}
		return 0f;
	}

	private (Vector3 center, Vector3 extents) GetRadiationBounds()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)boxCollider == (Object)null)
		{
			return (center: Vector3.zero, extents: Vector3.zero);
		}
		Vector3 item = ((Component)this).transform.TransformPoint(boxCollider.center);
		Vector3 item2 = Vector3.Scale(boxCollider.size * 0.5f, ((Component)this).transform.lossyScale);
		return (center: item, extents: item2);
	}

	private float GetRadiationAmount()
	{
		if (RadiationAmountOverride > 0f)
		{
			return RadiationAmountOverride;
		}
		return Radiation.GetRadiation(radiationTier);
	}

	public float GetRadiationForPosition(Vector3 position, float radProtection)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		if (ApplyLocalHeightCheck && ((Component)this).transform.InverseTransformPoint(position).y < MinLocalHeight)
		{
			return 0f;
		}
		if (UseLOSCheck && !GamePhysics.LineOfSight(((Component)this).gameObject.transform.position, position, 2097152))
		{
			return 0f;
		}
		float radiationAmount = GetRadiationAmount();
		float num = 0f;
		if (UseSphere)
		{
			float radiationRadius = GetRadiationRadius();
			float num2 = (IncreaseDamageNearCenter ? Vector3.Distance(((Component)this).gameObject.transform.position, position) : 0f);
			num = Mathf.InverseLerp(radiationRadius, radiationRadius * (1f - falloff), num2);
		}
		else if (UseBox)
		{
			(Vector3, Vector3) radiationBounds = GetRadiationBounds();
			Vector3 val = Quaternion.Inverse(((Component)this).transform.rotation) * (position - radiationBounds.Item1);
			Vector3 val2 = default(Vector3);
			((Vector3)(ref val2))..ctor(Mathf.Abs(val.x), Mathf.Abs(val.y), Mathf.Abs(val.z));
			Vector3 item = radiationBounds.Item2;
			Vector3 val3 = radiationBounds.Item2;
			if (usePerAxisFalloff)
			{
				val3.x = Mathf.Max(0f, item.x - falloffPerAxis.x);
				val3.y = Mathf.Max(0f, item.y - falloffPerAxis.y);
				val3.z = Mathf.Max(0f, item.z - falloffPerAxis.z);
			}
			else
			{
				val3 = item * (1f - falloff);
			}
			if (val2.x <= val3.x && val2.y <= val3.y && val2.z <= val3.z)
			{
				num = 1f;
			}
			else if (val2.x <= item.x && val2.y <= item.y && val2.z <= item.z)
			{
				float num3 = ((item.x == val3.x) ? 1f : Mathf.Clamp01(Mathf.InverseLerp(item.x, val3.x, val2.x)));
				float num4 = ((item.y == val3.y) ? 1f : Mathf.Clamp01(Mathf.InverseLerp(item.y, val3.y, val2.y)));
				float num5 = ((item.z == val3.z) ? 1f : Mathf.Clamp01(Mathf.InverseLerp(item.z, val3.z, val2.z)));
				num = Mathf.Min(num3, Mathf.Min(num4, num5));
			}
			else
			{
				num = 0f;
			}
		}
		float num6 = radiationAmount;
		if (!BypassArmor)
		{
			num6 = Radiation.GetRadiationAfterProtection(radiationAmount, radProtection);
		}
		return num6 * num;
	}

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (!(baseEntity is BaseCombatEntity))
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using UnityEngine;

public class TriggerRagdollRelocate : TriggerBase
{
	public Transform targetLocation;

	internal override void OnObjectAdded(GameObject obj, Collider col)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		base.OnObjectAdded(obj, col);
		BaseEntity baseEntity = obj.transform.ToBaseEntity();
		if ((Object)(object)baseEntity != (Object)null && baseEntity.isServer)
		{
			RepositionTransform(((Component)baseEntity).transform);
		}
		Ragdoll componentInParent = obj.GetComponentInParent<Ragdoll>();
		if (!((Object)(object)componentInParent != (Object)null))
		{
			return;
		}
		RepositionTransform(((Component)componentInParent).transform);
		foreach (Rigidbody rigidbody in componentInParent.rigidbodies)
		{
			if (((Component)rigidbody).transform.position.y < ((Component)this).transform.position.y)
			{
				RepositionTransform(((Component)rigidbody).transform);
			}
		}
	}

	private void RepositionTransform(Transform t)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = targetLocation.InverseTransformPoint(t.position);
		val.y = 0f;
		val = targetLocation.TransformPoint(val);
		t.position = val;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class TriggerSafeZone : TriggerBase
{
	public static List<TriggerSafeZone> allSafeZones = new List<TriggerSafeZone>();

	public float maxDepth = 20f;

	public float maxAltitude = -1f;

	public Collider triggerCollider { get; private set; }

	protected override void Awake()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		base.Awake();
		triggerCollider = ((Component)this).GetComponent<Collider>();
		base.InterestLayers = LayerMask.op_Implicit(LayerMask.op_Implicit(base.InterestLayers) | 0x200);
	}

	protected void OnEnable()
	{
		allSafeZones.Add(this);
	}

	protected override void OnDisable()
	{
		base.OnDisable();
		allSafeZones.Remove(this);
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public bool PassesHeightChecks(Vector3 entPos)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		float num = Mathf.Abs(position.y - entPos.y);
		if (maxDepth != -1f && entPos.y < position.y && num > maxDepth)
		{
			return false;
		}
		if (maxAltitude != -1f && entPos.y > position.y && num > maxAltitude)
		{
			return false;
		}
		return true;
	}

	public float GetSafeLevel(Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		if (!PassesHeightChecks(pos))
		{
			return 0f;
		}
		return 1f;
	}
}


using UnityEngine;

public class TriggerSnowmobileAchievement : TriggerBase
{
	internal override GameObject InterestedInObject(GameObject obj)
	{
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity != (Object)null && baseEntity.isServer && (Object)(object)baseEntity.ToPlayer() != (Object)null)
		{
			return ((Component)baseEntity).gameObject;
		}
		return null;
	}
}


using UnityEngine;

public class TriggerStashPlayer : TriggerBase
{
	public StashContainer Stash;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BasePlayer basePlayer = obj.ToBaseEntity() as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null)
		{
			return null;
		}
		if (basePlayer.isClient)
		{
			return null;
		}
		return ((Component)basePlayer).gameObject;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		if (entityContents == null || !entityContents.Contains(ent))
		{
			base.OnEntityEnter(ent);
			if (ent is BasePlayer basePlayer)
			{
				basePlayer.AddNeabyStash(Stash);
			}
		}
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
		if (ent is BasePlayer basePlayer)
		{
			basePlayer.RemoveNearbyStash(Stash);
		}
	}
}


using UnityEngine;

public class TriggerSubmarineMoonpool : TriggerBase, IServerComponent
{
	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isServer && baseEntity is BaseSubmarine baseSubmarine)
		{
			return ((Component)baseSubmarine).gameObject;
		}
		return null;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if (ent is BaseSubmarine baseSubmarine)
		{
			baseSubmarine.OnSurfacedInMoonpool();
		}
	}
}


using ConVar;
using UnityEngine;

public class TriggerTemperature : TriggerBase
{
	public float Temperature = 50f;

	public float triggerSize;

	public float minSize;

	public bool sunlightBlocker;

	public float sunlightBlockAmount;

	[Range(0f, 24f)]
	public float blockMinHour = 8.5f;

	[Range(0f, 24f)]
	public float blockMaxHour = 18.5f;

	private void OnValidate()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)((Component)this).GetComponent<SphereCollider>() != (Object)null)
		{
			triggerSize = ((Component)this).GetComponent<SphereCollider>().radius * ((Component)this).transform.localScale.y;
			return;
		}
		Vector3 val = Vector3.Scale(((Component)this).GetComponent<BoxCollider>().size, ((Component)this).transform.localScale);
		triggerSize = Vector3Ex.Max(val) * 0.5f;
	}

	public float WorkoutTemperature(Vector3 position, float oldTemperature)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (sunlightBlocker)
		{
			float time = Env.time;
			if (time >= blockMinHour && time <= blockMaxHour)
			{
				Vector3 position2 = TOD_Sky.Instance.Components.SunTransform.position;
				if (!GamePhysics.LineOfSight(position, position2, 256))
				{
					return oldTemperature - sunlightBlockAmount;
				}
			}
			return oldTemperature;
		}
		float num = Vector3.Distance(((Component)this).gameObject.transform.position, position);
		float num2 = Mathf.InverseLerp(triggerSize, minSize, num);
		return Mathf.Lerp(oldTemperature, Temperature, num2);
	}

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class TriggerWakeAIZ : TriggerBase, IServerComponent
{
	public float SleepDelaySeconds = 30f;

	public List<AIInformationZone> zones = new List<AIInformationZone>();

	private AIInformationZone aiz;

	public void Init(AIInformationZone zone = null)
	{
		if ((Object)(object)zone != (Object)null)
		{
			aiz = zone;
		}
		else if (zones == null || zones.Count == 0)
		{
			Transform val = ((Component)this).transform.parent;
			if ((Object)(object)val == (Object)null)
			{
				val = ((Component)this).transform;
			}
			aiz = ((Component)val).GetComponentInChildren<AIInformationZone>();
		}
		SetZonesSleeping(flag: true);
	}

	protected override void Awake()
	{
		base.Awake();
		Init();
	}

	private void SetZonesSleeping(bool flag)
	{
		if ((Object)(object)aiz != (Object)null)
		{
			if (flag)
			{
				aiz.SleepAI();
			}
			else
			{
				aiz.WakeAI();
			}
		}
		if (zones == null || zones.Count <= 0)
		{
			return;
		}
		foreach (AIInformationZone zone in zones)
		{
			if ((Object)(object)zone != (Object)null)
			{
				if (flag)
				{
					zone.SleepAI();
				}
				else
				{
					zone.WakeAI();
				}
			}
		}
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		BasePlayer basePlayer = baseEntity as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null && basePlayer.IsNpc)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if (!((Object)(object)aiz == (Object)null) || (zones != null && zones.Count != 0))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SleepAI);
			SetZonesSleeping(flag: false);
		}
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
		if ((!((Object)(object)aiz == (Object)null) || (zones != null && zones.Count != 0)) && (entityContents == null || entityContents.Count == 0))
		{
			DelayedSleepAI();
		}
	}

	private void DelayedSleepAI()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)SleepAI);
		((FacepunchBehaviour)this).Invoke((Action)SleepAI, SleepDelaySeconds);
	}

	private void SleepAI()
	{
		SetZonesSleeping(flag: true);
	}
}


using UnityEngine;

public class TriggerWetness : TriggerBase
{
	public float Wetness = 0.25f;

	public SphereCollider TargetCollider;

	public Transform OriginTransform;

	public bool ApplyLocalHeightCheck;

	public float MinLocalHeight;

	public float WorkoutWetness(Vector3 position)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (ApplyLocalHeightCheck && ((Component)this).transform.InverseTransformPoint(position).y < MinLocalHeight)
		{
			return 0f;
		}
		float num = Vector3Ex.Distance2D(OriginTransform.position, position) / TargetCollider.radius;
		num = Mathf.Clamp01(num);
		num = 1f - num;
		return Mathf.Lerp(0f, Wetness, num);
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using UnityEngine;

public class TriggerWorkbench : TriggerBase
{
	public Workbench parentBench;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public float WorkbenchLevel()
	{
		return parentBench.Workbenchlevel;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if (ent is BasePlayer basePlayer)
		{
			basePlayer.metabolism.ForceUpdateWorkbenchFlags();
		}
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
		if (ent is BasePlayer basePlayer)
		{
			basePlayer.metabolism.ForceUpdateWorkbenchFlags();
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class TubeRenderer : FacepunchBehaviour
{
	[Range(3f, 64f)]
	[Header("Settings")]
	public int Segments = 12;

	public float Radius = 0.1f;

	public bool useLocalPositions;

	[Header("Caps")]
	public bool EnableCaps = true;

	[Range(1f, 8f)]
	public int HemisphereRings = 4;

	[NonSerialized]
	public List<Vector3> points = new List<Vector3>();

	private Mesh mesh;

	public void ClearPositions()
	{
		points.Clear();
	}

	public void SetPosition(int index, Vector3 position)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (index >= 0 && index < points.Count)
		{
			points[index] = position;
		}
	}

	public void SetPositions(List<Vector3> positions)
	{
		points.Clear();
		points.AddRange(positions);
	}

	public void UpdateRenderer()
	{
		GenerateTube(points, Radius, Segments, HemisphereRings);
	}

	private void SetupMesh()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Expected O, but got Unknown
		mesh = new Mesh
		{
			name = "Tube Mesh"
		};
		mesh.MarkDynamic();
		MeshFilter val = ((Component)this).GetComponent<MeshFilter>();
		if ((Object)(object)val == (Object)null)
		{
			val = ((Component)this).gameObject.AddComponent<MeshFilter>();
		}
		val.mesh = mesh;
		if ((Object)(object)((Component)this).GetComponent<MeshRenderer>() == (Object)null)
		{
			((Component)this).gameObject.AddComponent<MeshRenderer>();
		}
	}

	private void GenerateTube(List<Vector3> points, float radius, int segments, int rings)
	{
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		if (points == null || points.Count < 2)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("TubeRenderer.GenerateTube", 0);
		try
		{
			if ((Object)(object)mesh == (Object)null)
			{
				SetupMesh();
			}
			List<Vector3> list = Pool.Get<List<Vector3>>();
			List<int> list2 = Pool.Get<List<int>>();
			List<Vector2> list3 = Pool.Get<List<Vector2>>();
			List<Quaternion> list4 = Pool.Get<List<Quaternion>>();
			List<float> list5 = Pool.Get<List<float>>();
			int vertOffset = 0;
			ComputeParallelTransportFrames(points, list4);
			list5.Add(0f);
			float num = 0f;
			for (int i = 1; i < points.Count; i++)
			{
				float num2 = Vector3.Distance(points[i - 1], points[i]);
				num += num2;
				list5.Add(num);
			}
			for (int j = 0; j < points.Count; j++)
			{
				Vector3 center = (useLocalPositions ? points[j] : ((Component)this).transform.InverseTransformPoint(points[j]));
				float v = ((num > 0f) ? (list5[j] / num) : 0f);
				AppendRing(list, list3, list4[j], center, radius, segments, v);
				if (j > 0)
				{
					BridgeLastTwoRings(list2, vertOffset, segments);
				}
				vertOffset += segments + 1;
			}
			if (EnableCaps)
			{
				AppendHemisphereCap(list, list2, list3, ref vertOffset, points[0], list4[0], radius, segments, rings, -1);
				List<Vector3> verts = list;
				List<int> tris = list2;
				List<Vector2> uvs = list3;
				Vector3 position = points[points.Count - 1];
				List<Quaternion> list6 = list4;
				AppendHemisphereCap(verts, tris, uvs, ref vertOffset, position, list6[list6.Count - 1], radius, segments, rings, 1);
			}
			else
			{
				AppendFlatCap(list, list2, list3, ref vertOffset, points[0], list4[0], radius, segments, -1);
				List<Vector3> verts2 = list;
				List<int> tris2 = list2;
				List<Vector2> uvs2 = list3;
				Vector3 position2 = points[points.Count - 1];
				List<Quaternion> list7 = list4;
				AppendFlatCap(verts2, tris2, uvs2, ref vertOffset, position2, list7[list7.Count - 1], radius, segments, 1);
			}
			mesh.Clear();
			mesh.SetVertices(list);
			mesh.SetUVs(0, list3);
			mesh.SetTriangles(list2, 0);
			mesh.RecalculateNormals();
			mesh.RecalculateBounds();
			Pool.FreeUnmanaged<Vector3>(ref list);
			Pool.FreeUnmanaged<int>(ref list2);
			Pool.FreeUnmanaged<Quaternion>(ref list4);
			Pool.FreeUnmanaged<Vector2>(ref list3);
			Pool.FreeUnmanaged<float>(ref list5);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void ComputeParallelTransportFrames(List<Vector3> points, List<Quaternion> rotations)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		rotations.Clear();
		if (points.Count >= 2)
		{
			Vector3 val = points[1] - points[0];
			Vector3 val2 = ((Vector3)(ref val)).normalized;
			Vector3 val3 = ((Mathf.Abs(Vector3.Dot(val2, Vector3.up)) < 0.99f) ? Vector3.up : Vector3.right);
			val = Vector3.Cross(val2, val3);
			Vector3 val4 = ((Vector3)(ref val)).normalized;
			val = Vector3.Cross(val2, val4);
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			rotations.Add(Quaternion.LookRotation(val2, normalized));
			for (int i = 1; i < points.Count; i++)
			{
				val = points[i] - points[i - 1];
				Vector3 normalized2 = ((Vector3)(ref val)).normalized;
				Vector3 val5 = Quaternion.FromToRotation(val2, normalized2) * val4;
				val = Vector3.Cross(normalized2, val5);
				Vector3 normalized3 = ((Vector3)(ref val)).normalized;
				rotations.Add(Quaternion.LookRotation(normalized2, normalized3));
				val2 = normalized2;
				val4 = val5;
			}
		}
	}

	private void AppendRing(List<Vector3> verts, List<Vector2> uvs, Quaternion rotation, Vector3 center, float radius, int segments, float v)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = rotation * Vector3.right;
		Vector3 val2 = rotation * Vector3.up;
		for (int i = 0; i <= segments; i++)
		{
			float num = (float)i / (float)segments * MathF.PI * 2f;
			Vector3 val3 = Mathf.Cos(num) * val + Mathf.Sin(num) * val2;
			verts.Add(center + val3 * radius);
			uvs.Add(new Vector2((float)i / (float)segments, v));
		}
	}

	private void BridgeLastTwoRings(List<int> tris, int vertOffset, int segments)
	{
		int num = vertOffset - (segments + 1);
		for (int i = 0; i < segments; i++)
		{
			int item = num + i;
			int item2 = num + i + 1;
			int item3 = vertOffset + i;
			int item4 = vertOffset + i + 1;
			tris.Add(item);
			tris.Add(item2);
			tris.Add(item3);
			tris.Add(item2);
			tris.Add(item4);
			tris.Add(item3);
		}
	}

	private void AppendFlatCap(List<Vector3> verts, List<int> tris, List<Vector2> uvs, ref int vertOffset, Vector3 position, Quaternion rotation, float radius, int segments, int direction)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		position = (useLocalPositions ? position : ((Component)this).transform.InverseTransformPoint(position));
		Vector3 val = rotation * Vector3.right;
		Vector3 val2 = rotation * Vector3.up;
		int count = verts.Count;
		verts.Add(position);
		uvs.Add(new Vector2(0.5f, 0.5f));
		for (int i = 0; i <= segments; i++)
		{
			float num = (float)i / (float)segments * MathF.PI * 2f;
			Vector3 val3 = Mathf.Cos(num) * val + Mathf.Sin(num) * val2;
			verts.Add(position + val3 * radius);
			float num2 = Mathf.Cos(num) * 0.5f + 0.5f;
			float num3 = Mathf.Sin(num) * 0.5f + 0.5f;
			uvs.Add(new Vector2(num2, num3));
		}
		for (int j = 0; j < segments; j++)
		{
			int item = count + j + 1;
			int item2 = count + j + 2;
			if (direction == 1)
			{
				tris.Add(count);
				tris.Add(item);
				tris.Add(item2);
			}
			else
			{
				tris.Add(count);
				tris.Add(item2);
				tris.Add(item);
			}
		}
		vertOffset += segments + 2;
	}

	private void AppendHemisphereCap(List<Vector3> verts, List<int> tris, List<Vector2> uvs, ref int vertOffset, Vector3 position, Quaternion rotation, float radius, int segments, int rings, int direction)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		position = (useLocalPositions ? position : ((Component)this).transform.InverseTransformPoint(position));
		List<Vector3> list = Pool.Get<List<Vector3>>();
		List<Vector2> list2 = Pool.Get<List<Vector2>>();
		Vector3 val = default(Vector3);
		for (int i = 0; i <= rings; i++)
		{
			float num = (float)i / (float)rings * MathF.PI / 2f;
			for (int j = 0; j <= segments; j++)
			{
				float num2 = (float)j / (float)segments * MathF.PI * 2f;
				float num3 = Mathf.Sin(num);
				((Vector3)(ref val))..ctor(Mathf.Cos(num2) * num3, Mathf.Sin(num2) * num3, Mathf.Cos(num) * (float)direction);
				Vector3 item = rotation * (val * radius) + position;
				list.Add(item);
				float num4 = Mathf.Cos(num2) * num3 * 0.5f + 0.5f;
				float num5 = Mathf.Sin(num2) * num3 * 0.5f + 0.5f;
				list2.Add(new Vector2(num4, num5));
			}
		}
		int count = verts.Count;
		verts.AddRange(list);
		uvs.AddRange(list2);
		for (int k = 0; k < rings; k++)
		{
			for (int l = 0; l < segments; l++)
			{
				int num6 = count + k * (segments + 1) + l;
				int item2 = num6 + 1;
				int num7 = num6 + (segments + 1);
				int item3 = num7 + 1;
				if (direction == 0)
				{
					tris.Add(num6);
					tris.Add(item2);
					tris.Add(num7);
					tris.Add(item2);
					tris.Add(item3);
					tris.Add(num7);
				}
				else
				{
					tris.Add(num6);
					tris.Add(num7);
					tris.Add(item2);
					tris.Add(item2);
					tris.Add(num7);
					tris.Add(item3);
				}
			}
		}
		vertOffset += list.Count;
		Pool.FreeUnmanaged<Vector3>(ref list);
		Pool.FreeUnmanaged<Vector2>(ref list2);
	}
}


using UnityEngine;

public class ValidBounds : SingletonComponent<ValidBounds>
{
	public Bounds worldBounds;

	public static bool Test(BaseEntity entity, Vector3 vPos)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)SingletonComponent<ValidBounds>.Instance))
		{
			return true;
		}
		if ((Object)(object)entity != (Object)null && entity.net != null && entity.net.group != null && TutorialIsland.IsTutorialNetworkGroup(entity.net.group.ID))
		{
			return SingletonComponent<ValidBounds>.Instance.IsInsideOuterBounds(vPos);
		}
		return SingletonComponent<ValidBounds>.Instance.IsInsideInnerBounds(vPos);
	}

	public static float TestDist(BaseEntity entity, Vector3 vPos)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)SingletonComponent<ValidBounds>.Instance))
		{
			return float.MaxValue;
		}
		if ((Object)(object)entity != (Object)null && entity.net != null && entity.net.group != null && TutorialIsland.IsTutorialNetworkGroup(entity.net.group.ID))
		{
			return float.MaxValue;
		}
		return SingletonComponent<ValidBounds>.Instance.DistToWorldEdge2D(vPos);
	}

	public static bool TestInnerBounds(Vector3 vPos)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)SingletonComponent<ValidBounds>.Instance))
		{
			return true;
		}
		return SingletonComponent<ValidBounds>.Instance.IsInsideInnerBounds(vPos);
	}

	public static bool TestOuterBounds(Vector3 vPos)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)SingletonComponent<ValidBounds>.Instance))
		{
			return true;
		}
		return SingletonComponent<ValidBounds>.Instance.IsInsideOuterBounds(vPos);
	}

	internal bool IsInsideInnerBounds(Vector3 vPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3Ex.IsNaNOrInfinity(vPos))
		{
			return false;
		}
		if (!((Bounds)(ref worldBounds)).Contains(vPos))
		{
			return false;
		}
		if ((Object)(object)TerrainMeta.Terrain != (Object)null)
		{
			if (World.Procedural && vPos.y < TerrainMeta.Position.y)
			{
				return false;
			}
			if (TerrainMeta.OutOfMargin(vPos))
			{
				return false;
			}
		}
		return true;
	}

	internal bool IsInsideOuterBounds(Vector3 vPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3Ex.IsNaNOrInfinity(vPos))
		{
			return false;
		}
		Bounds val = default(Bounds);
		((Bounds)(ref val))..ctor(((Bounds)(ref worldBounds)).center, new Vector3(((Bounds)(ref worldBounds)).size.x + TutorialIsland.TutorialBoundsSize * 2f, ((Bounds)(ref worldBounds)).size.y, ((Bounds)(ref worldBounds)).size.z + TutorialIsland.TutorialBoundsSize * 2f));
		if (!((Bounds)(ref val)).Contains(vPos))
		{
			return false;
		}
		if ((Object)(object)TerrainMeta.Terrain != (Object)null)
		{
			if (World.Procedural && vPos.y < TerrainMeta.Position.y)
			{
				return false;
			}
			if (TerrainMeta.OutOfMarginPlusTutorialBounds(vPos))
			{
				return false;
			}
		}
		return true;
	}

	public static float GetMaximumPointTutorial()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)SingletonComponent<ValidBounds>.Instance == (Object)null)
		{
			return 0f;
		}
		return Mathf.Min(TerrainMeta.Position.x + TerrainMeta.Size.x * 2f + TutorialIsland.TutorialBoundsSize, ((Bounds)(ref SingletonComponent<ValidBounds>.Instance.worldBounds)).extents.x + TutorialIsland.TutorialBoundsSize);
	}

	public static float GetMaximumPoint()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)SingletonComponent<ValidBounds>.Instance == (Object)null)
		{
			return 0f;
		}
		float num = ((Bounds)(ref SingletonComponent<ValidBounds>.Instance.worldBounds)).max.x;
		if ((Object)(object)TerrainMeta.Terrain != (Object)null)
		{
			num = Mathf.Min(TerrainMeta.Position.x + TerrainMeta.Size.x, num);
		}
		return num;
	}

	internal float DistToWorldEdge2D(Vector3 vPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (!IsInsideInnerBounds(vPos))
		{
			return -1f;
		}
		float num = worldBounds.InnerDistToEdge2D(vPos);
		if ((Object)(object)TerrainMeta.Terrain != (Object)null)
		{
			float num2 = TerrainMeta.InnerDistToEdge2D(vPos);
			return Mathf.Min(num, num2);
		}
		return num;
	}
}


using System.Collections.Generic;
using UnityEngine;

public static class Vis
{
	private static int colCount = 0;

	public static Collider[] colBuffer = (Collider[])(object)new Collider[32768];

	private static HashSet<object> hashSet = new HashSet<object>();

	private static void Buffer(Vector3 position, float radius, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		layerMask = GamePhysics.HandleIgnoreCollision(position, layerMask);
		int num = colCount;
		colCount = Physics.OverlapSphereNonAlloc(position, radius, colBuffer, layerMask, triggerInteraction);
		for (int i = colCount; i < num; i++)
		{
			colBuffer[i] = null;
		}
		if (colCount >= colBuffer.Length)
		{
			Debug.LogWarning((object)"Vis query is exceeding collider buffer length.");
			colCount = colBuffer.Length;
		}
	}

	public static bool AnyColliders(Vector3 position, float radius, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		Buffer(position, radius, layerMask, triggerInteraction);
		return colCount > 0;
	}

	public static void Colliders<T>(Vector3 position, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : Collider
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		Buffer(position, radius, layerMask, triggerInteraction);
		for (int i = 0; i < colCount; i++)
		{
			Collider obj = colBuffer[i];
			T val = (T)(object)((obj is T) ? obj : null);
			if (!((Object)(object)val == (Object)null) && ((Collider)val).enabled)
			{
				list.Add(val);
			}
		}
	}

	public static void Components<T>(Vector3 position, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : Component
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		Buffer(position, radius, layerMask, triggerInteraction);
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if (!((Object)(object)val == (Object)null) && val.enabled)
			{
				T component = ((Component)val).GetComponent<T>();
				if (!((Object)(object)component == (Object)null))
				{
					list.Add(component);
				}
			}
		}
	}

	public static void Entities<T>(Vector3 position, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : class
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		Buffer(position, radius, layerMask, triggerInteraction);
		hashSet.Clear();
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if (!((Object)(object)val == (Object)null) && val.enabled && val.ToBaseEntity() is T item && !hashSet.Contains(item))
			{
				hashSet.Add(item);
				list.Add(item);
			}
		}
	}

	public static void EntityComponents<T>(Vector3 position, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : EntityComponentBase
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		Buffer(position, radius, layerMask, triggerInteraction);
		hashSet.Clear();
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if ((Object)(object)val == (Object)null || !val.enabled)
			{
				continue;
			}
			BaseEntity baseEntity = val.ToBaseEntity();
			if (!((Object)(object)baseEntity == (Object)null) && !hashSet.Contains(baseEntity))
			{
				hashSet.Add(baseEntity);
				T component = ((Component)baseEntity).GetComponent<T>();
				if (!((Object)(object)component == (Object)null))
				{
					list.Add(component);
				}
			}
		}
	}

	private static void Buffer(OBB bounds, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		layerMask = GamePhysics.HandleIgnoreCollision(bounds.position, layerMask);
		int num = colCount;
		colCount = Physics.OverlapBoxNonAlloc(bounds.position, bounds.extents, colBuffer, bounds.rotation, layerMask, triggerInteraction);
		for (int i = colCount; i < num; i++)
		{
			colBuffer[i] = null;
		}
		if (colCount >= colBuffer.Length)
		{
			Debug.LogWarning((object)"Vis query is exceeding collider buffer length.");
			colCount = colBuffer.Length;
		}
	}

	public static void Colliders<T>(OBB bounds, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : Collider
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Buffer(bounds, layerMask, triggerInteraction);
		for (int i = 0; i < colCount; i++)
		{
			Collider obj = colBuffer[i];
			T val = (T)(object)((obj is T) ? obj : null);
			if (!((Object)(object)val == (Object)null) && ((Collider)val).enabled)
			{
				list.Add(val);
			}
		}
	}

	public static void Components<T>(OBB bounds, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : Component
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Buffer(bounds, layerMask, triggerInteraction);
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if (!((Object)(object)val == (Object)null) && val.enabled)
			{
				T component = ((Component)val).GetComponent<T>();
				if (!((Object)(object)component == (Object)null))
				{
					list.Add(component);
				}
			}
		}
	}

	public static void Entities<T>(OBB bounds, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : class
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Buffer(bounds, layerMask, triggerInteraction);
		hashSet.Clear();
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if (!((Object)(object)val == (Object)null) && val.enabled && val.ToBaseEntity() is T item && !hashSet.Contains(item))
			{
				hashSet.Add(item);
				list.Add(item);
			}
		}
	}

	public static void EntityComponents<T>(OBB bounds, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : EntityComponentBase
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Buffer(bounds, layerMask, triggerInteraction);
		hashSet.Clear();
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if ((Object)(object)val == (Object)null || !val.enabled)
			{
				continue;
			}
			BaseEntity baseEntity = val.ToBaseEntity();
			if (!((Object)(object)baseEntity == (Object)null) && !hashSet.Contains(baseEntity))
			{
				hashSet.Add(baseEntity);
				T component = ((Component)baseEntity).GetComponent<T>();
				if (!((Object)(object)component == (Object)null))
				{
					list.Add(component);
				}
			}
		}
	}

	private static void Buffer(Vector3 startPosition, Vector3 endPosition, float radius, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		layerMask = GamePhysics.HandleIgnoreCollision(startPosition, layerMask);
		int num = colCount;
		colCount = Physics.OverlapCapsuleNonAlloc(startPosition, endPosition, radius, colBuffer, layerMask, triggerInteraction);
		for (int i = colCount; i < num; i++)
		{
			colBuffer[i] = null;
		}
		if (colCount >= colBuffer.Length)
		{
			Debug.LogWarning((object)"Vis query is exceeding collider buffer length.");
			colCount = colBuffer.Length;
		}
	}

	public static void Colliders<T>(Vector3 startPosition, Vector3 endPosition, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : Collider
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		Buffer(startPosition, endPosition, radius, layerMask, triggerInteraction);
		for (int i = 0; i < colCount; i++)
		{
			Collider obj = colBuffer[i];
			T val = (T)(object)((obj is T) ? obj : null);
			if (!((Object)(object)val == (Object)null) && ((Collider)val).enabled)
			{
				list.Add(val);
			}
		}
	}

	public static void Components<T>(Vector3 startPosition, Vector3 endPosition, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : Component
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		Buffer(startPosition, endPosition, radius, layerMask, triggerInteraction);
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if (!((Object)(object)val == (Object)null) && val.enabled)
			{
				T component = ((Component)val).GetComponent<T>();
				if (!((Object)(object)component == (Object)null))
				{
					list.Add(component);
				}
			}
		}
	}

	public static void Entities<T>(Vector3 startPosition, Vector3 endPosition, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : class
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		Buffer(startPosition, endPosition, radius, layerMask, triggerInteraction);
		hashSet.Clear();
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if (!((Object)(object)val == (Object)null) && val.enabled && val.ToBaseEntity() is T item && !hashSet.Contains(item))
			{
				hashSet.Add(item);
				list.Add(item);
			}
		}
	}

	public static void EntityComponents<T>(Vector3 startPosition, Vector3 endPosition, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : EntityComponentBase
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		Buffer(startPosition, endPosition, radius, layerMask, triggerInteraction);
		hashSet.Clear();
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if ((Object)(object)val == (Object)null || !val.enabled)
			{
				continue;
			}
			BaseEntity baseEntity = val.ToBaseEntity();
			if (!((Object)(object)baseEntity == (Object)null) && !hashSet.Contains(baseEntity))
			{
				hashSet.Add(baseEntity);
				T component = ((Component)baseEntity).GetComponent<T>();
				if (!((Object)(object)component == (Object)null))
				{
					list.Add(component);
				}
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;
using UtilityJobs;
using WaterLevelJobs;

public static class WaterLevel
{
	public struct WaterInfo
	{
		public bool isValid;

		public float currentDepth;

		public float overallDepth;

		public float surfaceLevel;

		public float terrainHeight;

		public bool artificalWater;

		public int topology;
	}

	public const float InvalidWaterHeight = -1000f;

	private static NativeReference<int> CounterRef;

	private static NativeArray<Vector3> Centers;

	private static NativeArray<float> WaterHeights;

	private static NativeArray<float> TerrainHeights;

	private static NativeArray<int> Indices;

	private static NativeArray<bool> GetIgnoreResults;

	private static NativeArray<Vector3> GetIgnoreHeadStarts;

	private static NativeArray<float> GetIgnoreHeadRadii;

	private static NativeArray<Vector2> UVs;

	private static NativeArray<int> Topologies;

	private static NativeArray<float> ShoreDists;

	private static NativeArray<float> WaveHeights;

	public static float Factor(Vector3 start, Vector3 end, float radius, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.Factor", 0);
		try
		{
			return Factor(GetWaterInfo(start, end, radius, waves, volumes, forEntity), start, end, radius);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float Factor(in WaterInfo info, Vector3 start, Vector3 end, float radius)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!info.isValid)
		{
			return 0f;
		}
		return Mathf.InverseLerp(Mathf.Min(start.y, end.y) - radius, Mathf.Max(start.y, end.y) + radius, info.surfaceLevel);
	}

	public static float Factor(Bounds bounds, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.Factor", 0);
		try
		{
			if (((Bounds)(ref bounds)).size == Vector3.zero)
			{
				((Bounds)(ref bounds)).size = new Vector3(0.1f, 0.1f, 0.1f);
			}
			WaterInfo waterInfo = GetWaterInfo(bounds, waves, volumes, forEntity);
			return waterInfo.isValid ? Mathf.InverseLerp(((Bounds)(ref bounds)).min.y, ((Bounds)(ref bounds)).max.y, waterInfo.surfaceLevel) : 0f;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float Factor(in WaterInfo info, Bounds bounds)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if (((Bounds)(ref bounds)).size == Vector3.zero)
		{
			((Bounds)(ref bounds)).size = new Vector3(0.1f, 0.1f, 0.1f);
		}
		if (!info.isValid)
		{
			return 0f;
		}
		return Mathf.InverseLerp(((Bounds)(ref bounds)).min.y, ((Bounds)(ref bounds)).max.y, info.surfaceLevel);
	}

	public static bool Test(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.Test", 0);
		try
		{
			return GetWaterInfo(pos, waves, volumes, forEntity).isValid;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool Test(in WaterInfo info, bool volumes, Vector3 pos, BaseEntity forEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		bool flag = pos.y >= info.terrainHeight - 1f && pos.y <= info.surfaceLevel;
		if (!flag && volumes)
		{
			flag = GetWaterInfoFromVolumes(pos, forEntity).isValid;
		}
		return flag;
	}

	public static (float, float) GetWaterAndTerrainSurface(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterDepth", 0);
		try
		{
			WaterInfo waterInfo = GetWaterInfo(pos, waves, volumes, forEntity);
			return (waterInfo.surfaceLevel, waterInfo.terrainHeight);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float GetWaterOrTerrainSurface(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterDepth", 0);
		try
		{
			WaterInfo waterInfo = GetWaterInfo(pos, waves, volumes, forEntity);
			return Mathf.Max(waterInfo.surfaceLevel, waterInfo.terrainHeight);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float GetWaterSurface(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterDepth", 0);
		try
		{
			return GetWaterInfo(pos, waves, volumes, forEntity).surfaceLevel;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float GetWaterDepth(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterDepth", 0);
		try
		{
			return GetWaterInfo(pos, waves, volumes, forEntity).currentDepth;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float GetOverallWaterDepth(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetOverallWaterDepth", 0);
		try
		{
			return GetWaterInfo(pos, waves, volumes, forEntity).overallDepth;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static Vector3 GetWaterFlowDirection(Vector3 worldPosition)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.WaterFlowMap == (Object)null)
		{
			return Vector3.zero;
		}
		return TerrainMeta.WaterFlowMap.GetFlowDirection(worldPosition);
	}

	public static Vector3 GetWaterNormal(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.up;
	}

	public static WaterInfo GetBuoyancyWaterInfo(Vector3 pos, Vector2 posUV, float terrainHeight, float waterHeight, bool doDeepwaterChecks, BaseEntity forEntity)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterInfo", 0);
		try
		{
			WaterInfo result = default(WaterInfo);
			if (pos.y > waterHeight)
			{
				return GetWaterInfoFromVolumes(pos, forEntity);
			}
			bool flag = pos.y < terrainHeight - 1f;
			if (flag)
			{
				return GetWaterInfoFromVolumes(pos, forEntity);
			}
			bool flag2 = doDeepwaterChecks && (pos.y < waterHeight - 10f || TerrainMeta.OutOfBounds(pos));
			int num = (Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap) ? TerrainMeta.TopologyMap.GetTopologyFast(posUV) : 0);
			if ((flag || flag2 || (num & 0x3C180) == 0) && Object.op_Implicit((Object)(object)WaterSystem.Collision) && WaterSystem.Collision.GetIgnore(pos))
			{
				return result;
			}
			RaycastHit val2 = default(RaycastHit);
			if (flag2 && Physics.Raycast(pos, Vector3.up, ref val2, 5f, 16, (QueryTriggerInteraction)2))
			{
				float num2 = waterHeight;
				Bounds bounds = ((RaycastHit)(ref val2)).collider.bounds;
				waterHeight = Mathf.Min(num2, ((Bounds)(ref bounds)).max.y);
			}
			result.isValid = true;
			result.currentDepth = Mathf.Max(0f, waterHeight - pos.y);
			result.overallDepth = Mathf.Max(0f, waterHeight - terrainHeight);
			result.surfaceLevel = waterHeight;
			result.terrainHeight = terrainHeight;
			result.topology = num;
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static WaterInfo GetWaterInfo(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterInfo", 0);
		try
		{
			WaterInfo result = default(WaterInfo);
			float num = GetWaterLevel(pos, waves);
			float num2 = ((Object.op_Implicit((Object)(object)TerrainMeta.HeightMap) && TerrainMeta.HeightMap.isInitialized) ? TerrainMeta.HeightMap.GetHeight(pos) : 0f);
			result.isValid = true;
			if (pos.y > num)
			{
				result.isValid = false;
			}
			else if (pos.y < num2 - 1f)
			{
				result.isValid = false;
			}
			bool flag = false;
			if (!result.isValid && volumes)
			{
				result = GetWaterInfoFromVolumes(pos, forEntity);
				if (result.isValid)
				{
					flag = true;
					num = result.surfaceLevel;
				}
			}
			if (result.isValid && Object.op_Implicit((Object)(object)WaterSystem.Collision) && WaterSystem.Collision.GetIgnore(pos))
			{
				result.isValid = false;
				num = -1000f;
			}
			result.currentDepth = Mathf.Max(0f, num - pos.y);
			if (!flag)
			{
				result.overallDepth = Mathf.Max(0f, num - num2);
			}
			result.surfaceLevel = num;
			result.terrainHeight = num2;
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static WaterInfo GetWaterInfo(Bounds bounds, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterInfo", 0);
		try
		{
			WaterInfo result = default(WaterInfo);
			float num = GetWaterLevel(((Bounds)(ref bounds)).center, waves);
			float num2 = (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap) ? TerrainMeta.HeightMap.GetHeight(((Bounds)(ref bounds)).center) : 0f);
			result.isValid = true;
			if (((Bounds)(ref bounds)).min.y > num)
			{
				result.isValid = false;
			}
			else if (((Bounds)(ref bounds)).max.y < num2 - 1f)
			{
				result.isValid = false;
			}
			if (!result.isValid && volumes)
			{
				result = GetWaterInfoFromVolumes(bounds, forEntity);
				if (result.isValid)
				{
					num = result.surfaceLevel;
				}
			}
			if (result.isValid && Object.op_Implicit((Object)(object)WaterSystem.Collision) && WaterSystem.Collision.GetIgnore(bounds))
			{
				result.isValid = false;
				num = -1000f;
			}
			result.currentDepth = Mathf.Max(0f, num - ((Bounds)(ref bounds)).min.y);
			result.overallDepth = Mathf.Max(0f, num - num2);
			result.surfaceLevel = num;
			result.terrainHeight = num2;
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void InitInternalState(int initCap)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		DisposeInternalState();
		CounterRef = new NativeReference<int>(AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)0);
		Centers = new NativeArray<Vector3>(initCap, (Allocator)4, (NativeArrayOptions)0);
		WaterHeights = new NativeArray<float>(initCap, (Allocator)4, (NativeArrayOptions)0);
		TerrainHeights = new NativeArray<float>(initCap, (Allocator)4, (NativeArrayOptions)0);
		Indices = new NativeArray<int>(initCap, (Allocator)4, (NativeArrayOptions)0);
		GetIgnoreResults = new NativeArray<bool>(initCap, (Allocator)4, (NativeArrayOptions)0);
		GetIgnoreHeadStarts = new NativeArray<Vector3>(initCap, (Allocator)4, (NativeArrayOptions)0);
		GetIgnoreHeadRadii = new NativeArray<float>(initCap, (Allocator)4, (NativeArrayOptions)0);
		UVs = new NativeArray<Vector2>(initCap, (Allocator)4, (NativeArrayOptions)0);
		Topologies = new NativeArray<int>(initCap, (Allocator)4, (NativeArrayOptions)0);
		ShoreDists = new NativeArray<float>(initCap, (Allocator)4, (NativeArrayOptions)0);
		WaveHeights = new NativeArray<float>(initCap, (Allocator)4, (NativeArrayOptions)0);
	}

	public static void DisposeInternalState()
	{
		NativeReferenceEx.SafeDispose(ref CounterRef);
		Centers.SafeDispose<Vector3>();
		NativeArrayEx.SafeDispose(ref WaterHeights);
		NativeArrayEx.SafeDispose(ref TerrainHeights);
		NativeArrayEx.SafeDispose(ref Indices);
		NativeArrayEx.SafeDispose(ref GetIgnoreResults);
		GetIgnoreHeadStarts.SafeDispose<Vector3>();
		NativeArrayEx.SafeDispose(ref GetIgnoreHeadRadii);
		UVs.SafeDispose<Vector2>();
		NativeArrayEx.SafeDispose(ref Topologies);
		NativeArrayEx.SafeDispose(ref ShoreDists);
		NativeArrayEx.SafeDispose(ref WaveHeights);
	}

	public static void GetWaterInfos(ReadOnly<Vector3> starts, ReadOnly<Vector3> ends, ReadOnly<float> radii, ReadOnlySpan<BaseEntity> entities, ReadOnly<int> indices, bool waves, bool volumes, NativeArray<WaterInfo> results)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_043a: Unknown result type (might be due to invalid IL or missing references)
		//IL_043c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0443: Unknown result type (might be due to invalid IL or missing references)
		//IL_0444: Unknown result type (might be due to invalid IL or missing references)
		//IL_044b: Unknown result type (might be due to invalid IL or missing references)
		//IL_044c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0453: Unknown result type (might be due to invalid IL or missing references)
		//IL_0454: Unknown result type (might be due to invalid IL or missing references)
		//IL_0460: Unknown result type (might be due to invalid IL or missing references)
		//IL_0465: Unknown result type (might be due to invalid IL or missing references)
		//IL_0471: Unknown result type (might be due to invalid IL or missing references)
		//IL_0476: Unknown result type (might be due to invalid IL or missing references)
		//IL_047d: Unknown result type (might be due to invalid IL or missing references)
		//IL_047f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		//IL_02af: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_030a: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0316: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0333: Unknown result type (might be due to invalid IL or missing references)
		//IL_0334: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0343: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_037d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0382: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0398: Unknown result type (might be due to invalid IL or missing references)
		//IL_039f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f6: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetWaterInfos", 0);
		try
		{
			Centers.Expand<Vector3>(starts.Length, (NativeArrayOptions)0, copyContents: false, usePowerOfTwo: false);
			CalcCenterJobIndirect calcCenterJobIndirect = default(CalcCenterJobIndirect);
			calcCenterJobIndirect.Results = Centers;
			calcCenterJobIndirect.Starts = starts;
			calcCenterJobIndirect.Ends = ends;
			calcCenterJobIndirect.Indices = indices;
			CalcCenterJobIndirect calcCenterJobIndirect2 = calcCenterJobIndirect;
			IJobExtensions.RunByRef<CalcCenterJobIndirect>(ref calcCenterJobIndirect2);
			NativeArrayEx.Expand(ref WaterHeights, starts.Length, (NativeArrayOptions)0, copyContents: false);
			GetWaterLevels(Centers.AsReadOnly(), indices, waves, WaterHeights);
			NativeArrayEx.Expand(ref TerrainHeights, starts.Length, (NativeArrayOptions)0, copyContents: false);
			TerrainMeta.HeightMap?.GetHeightsIndirect(Centers.AsReadOnly(), indices, TerrainHeights);
			NativeArrayEx.Expand(ref Indices, starts.Length, (NativeArrayOptions)0, copyContents: false);
			InitialValidateInfoJobIndirect initialValidateInfoJobIndirect = default(InitialValidateInfoJobIndirect);
			initialValidateInfoJobIndirect.Results = results;
			initialValidateInfoJobIndirect.Starts = starts;
			initialValidateInfoJobIndirect.Ends = ends;
			initialValidateInfoJobIndirect.Radii = radii;
			initialValidateInfoJobIndirect.WaterHeights = WaterHeights.AsReadOnly();
			initialValidateInfoJobIndirect.TerrainHeights = TerrainHeights.AsReadOnly();
			initialValidateInfoJobIndirect.Indices = indices;
			InitialValidateInfoJobIndirect initialValidateInfoJobIndirect2 = initialValidateInfoJobIndirect;
			IJobExtensions.RunByRef<InitialValidateInfoJobIndirect>(ref initialValidateInfoJobIndirect2);
			if (volumes)
			{
				TimeWarning val2 = TimeWarning.New("WaterTestFromVolumes", 0);
				try
				{
					GatherInvalidInfosJobIndirect gatherInvalidInfosJobIndirect = default(GatherInvalidInfosJobIndirect);
					gatherInvalidInfosJobIndirect.InvalidIndices = Indices;
					gatherInvalidInfosJobIndirect.InvalidIndexCount = CounterRef;
					gatherInvalidInfosJobIndirect.Infos = results.AsReadOnly();
					gatherInvalidInfosJobIndirect.Indices = indices;
					GatherInvalidInfosJobIndirect gatherInvalidInfosJobIndirect2 = gatherInvalidInfosJobIndirect;
					IJobExtensions.RunByRef<GatherInvalidInfosJobIndirect>(ref gatherInvalidInfosJobIndirect2);
					int value = CounterRef.Value;
					if (value > 0)
					{
						NativeArray<int> subArray = Indices.GetSubArray(0, value);
						BaseEntity.WaterTestFromVolumesIndirect(entities, ReadOnly<Vector3>.op_Implicit(ref starts), ReadOnly<Vector3>.op_Implicit(ref ends), ReadOnly<float>.op_Implicit(ref radii), NativeArray<int>.op_Implicit(ref subArray), NativeArray<WaterInfo>.op_Implicit(ref results));
						UpdateWaterHeightsJobIndirect updateWaterHeightsJobIndirect = default(UpdateWaterHeightsJobIndirect);
						updateWaterHeightsJobIndirect.WaterHeights = WaterHeights;
						updateWaterHeightsJobIndirect.Infos = results;
						updateWaterHeightsJobIndirect.Indices = subArray;
						UpdateWaterHeightsJobIndirect updateWaterHeightsJobIndirect2 = updateWaterHeightsJobIndirect;
						IJobExtensions.RunByRef<UpdateWaterHeightsJobIndirect>(ref updateWaterHeightsJobIndirect2);
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			if (Object.op_Implicit((Object)(object)WaterSystem.Collision))
			{
				TimeWarning val3 = TimeWarning.New("WaterSystem.Collision", 0);
				try
				{
					GatherValidInfosJobIndirect gatherValidInfosJobIndirect = default(GatherValidInfosJobIndirect);
					gatherValidInfosJobIndirect.ValidIndices = Indices;
					gatherValidInfosJobIndirect.ValidIndexCount = CounterRef;
					gatherValidInfosJobIndirect.Infos = results.AsReadOnly();
					gatherValidInfosJobIndirect.Indices = indices;
					GatherValidInfosJobIndirect gatherValidInfosJobIndirect2 = gatherValidInfosJobIndirect;
					IJobExtensions.RunByRef<GatherValidInfosJobIndirect>(ref gatherValidInfosJobIndirect2);
					int value2 = CounterRef.Value;
					if (value2 > 0)
					{
						TimeWarning val4 = TimeWarning.New("WaterSystem.Collision.Entity", 0);
						try
						{
							NativeArray<int> subArray2 = Indices.GetSubArray(0, value2);
							NativeArrayEx.Expand(ref GetIgnoreResults, starts.Length, (NativeArrayOptions)0, copyContents: false);
							WaterSystem.Collision.GetIgnoreIndirect(starts, ends, radii, subArray2.AsReadOnly(), GetIgnoreResults);
							GetIgnoreHeadStarts.Expand<Vector3>(starts.Length, (NativeArrayOptions)0, copyContents: false, usePowerOfTwo: false);
							NativeArrayEx.Expand(ref GetIgnoreHeadRadii, starts.Length, (NativeArrayOptions)0, copyContents: false);
							SetupHeadQueryJobIndirect setupHeadQueryJobIndirect = default(SetupHeadQueryJobIndirect);
							setupHeadQueryJobIndirect.Indices = subArray2;
							setupHeadQueryJobIndirect.QueryIndexCount = CounterRef;
							setupHeadQueryJobIndirect.QueryStarts = GetIgnoreHeadStarts;
							setupHeadQueryJobIndirect.QueryRadii = GetIgnoreHeadRadii;
							setupHeadQueryJobIndirect.ValidInfos = GetIgnoreResults.AsReadOnly();
							setupHeadQueryJobIndirect.Starts = starts;
							setupHeadQueryJobIndirect.Ends = ends;
							setupHeadQueryJobIndirect.Radii = radii;
							SetupHeadQueryJobIndirect setupHeadQueryJobIndirect2 = setupHeadQueryJobIndirect;
							IJobExtensions.RunByRef<SetupHeadQueryJobIndirect>(ref setupHeadQueryJobIndirect2);
							int value3 = CounterRef.Value;
							if (value3 > 0)
							{
								TimeWarning val5 = TimeWarning.New("WaterSystem.Collision.Head", 0);
								try
								{
									NativeArray<int> subArray3 = Indices.GetSubArray(0, value3);
									WaterSystem.Collision.GetIgnoreIndirect(GetIgnoreHeadStarts.AsReadOnly(), GetIgnoreHeadRadii.AsReadOnly(), subArray3.AsReadOnly(), GetIgnoreResults);
									ApplyHeadQueryResultsJobIndirect applyHeadQueryResultsJobIndirect = default(ApplyHeadQueryResultsJobIndirect);
									applyHeadQueryResultsJobIndirect.WaterHeights = WaterHeights;
									applyHeadQueryResultsJobIndirect.Infos = results;
									applyHeadQueryResultsJobIndirect.Indices = subArray3.AsReadOnly();
									applyHeadQueryResultsJobIndirect.ValidInfos = GetIgnoreResults.AsReadOnly();
									applyHeadQueryResultsJobIndirect.Starts = GetIgnoreHeadStarts.AsReadOnly();
									ApplyHeadQueryResultsJobIndirect applyHeadQueryResultsJobIndirect2 = applyHeadQueryResultsJobIndirect;
									IJobExtensions.RunByRef<ApplyHeadQueryResultsJobIndirect>(ref applyHeadQueryResultsJobIndirect2);
								}
								finally
								{
									((IDisposable)val5)?.Dispose();
								}
							}
						}
						finally
						{
							((IDisposable)val4)?.Dispose();
						}
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
			ResolveWaterInfosJobIndirect resolveWaterInfosJobIndirect = default(ResolveWaterInfosJobIndirect);
			resolveWaterInfosJobIndirect.Infos = results;
			resolveWaterInfosJobIndirect.Starts = starts;
			resolveWaterInfosJobIndirect.Ends = ends;
			resolveWaterInfosJobIndirect.Radii = radii;
			resolveWaterInfosJobIndirect.WaterHeights = WaterHeights.AsReadOnly();
			resolveWaterInfosJobIndirect.TerrainHeights = TerrainHeights.AsReadOnly();
			resolveWaterInfosJobIndirect.Indices = indices;
			ResolveWaterInfosJobIndirect resolveWaterInfosJobIndirect2 = resolveWaterInfosJobIndirect;
			IJobExtensions.RunByRef<ResolveWaterInfosJobIndirect>(ref resolveWaterInfosJobIndirect2);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static WaterInfo GetWaterInfo(Vector3 start, Vector3 end, float radius, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterInfo", 0);
		try
		{
			WaterInfo result = default(WaterInfo);
			Vector3 val2 = (start + end) * 0.5f;
			float num = Mathf.Min(start.y, end.y) - radius;
			float num2 = Mathf.Max(start.y, end.y) + radius;
			float num3 = GetWaterLevel(val2, waves);
			float num4 = (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap) ? TerrainMeta.HeightMap.GetHeight(val2) : 0f);
			result.isValid = true;
			if (num > num3)
			{
				result.isValid = false;
			}
			else if (num2 < num4 - 1f)
			{
				result.isValid = false;
			}
			if (result.isValid && num4 >= num3 + 0.015f)
			{
				result.isValid = false;
			}
			if (!result.isValid && volumes)
			{
				result = GetWaterInfoFromVolumes(start, end, radius, forEntity);
				if (result.isValid)
				{
					num3 = result.surfaceLevel;
				}
			}
			if (result.isValid && Object.op_Implicit((Object)(object)WaterSystem.Collision) && WaterSystem.Collision.GetIgnore(start, end, radius))
			{
				Vector3 val3 = Vector3Ex.WithY(val2, Mathf.Lerp(num, num2, 0.75f));
				if (!WaterSystem.Collision.GetIgnore(val3))
				{
					num3 = Mathf.Min(num3, val3.y);
				}
				else
				{
					result.isValid = false;
					num3 = -1000f;
				}
			}
			result.currentDepth = Mathf.Max(0f, num3 - num);
			result.overallDepth = Mathf.Max(0f, num3 - num4);
			result.surfaceLevel = num3;
			result.terrainHeight = num4;
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static WaterInfo GetWaterInfo(Camera cam, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterInfo", 0);
		try
		{
			waves = waves && (Object)(object)WaterSystem.Instance != (Object)null;
			float num = WaterSystem.OceanLevel;
			if (waves)
			{
				num += WaterSystem.Instance.oceanSimulation.MinLevel();
			}
			if (((Component)cam).transform.position.y < num - 1f)
			{
				return GetWaterInfo(((Component)cam).transform.position, waves, volumes, forEntity);
			}
			return GetWaterInfo(((Component)cam).transform.position - Vector3.up, waves, volumes, forEntity);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float GetWaterLevel(Vector3 pos, bool waves)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		waves = waves && (Object)(object)WaterSystem.Instance != (Object)null;
		float normX = TerrainMeta.NormalizeX(pos.x);
		float normZ = TerrainMeta.NormalizeZ(pos.z);
		float num = (Object.op_Implicit((Object)(object)TerrainMeta.WaterMap) ? TerrainMeta.WaterMap.GetHeight(normX, normZ) : TerrainMeta.Position.y);
		float num2 = WaterSystem.OceanLevel;
		if (waves)
		{
			num2 += WaterSystem.Instance.oceanSimulation.MaxLevel();
		}
		if (num < num2 && (!Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap) || TerrainMeta.TopologyMap.GetTopology(normX, normZ, 384)))
		{
			float num3 = WaterSystem.OceanLevel;
			if (waves)
			{
				num3 += WaterSystem.Instance.oceanSimulation.GetHeight(pos);
			}
			return Mathf.Max(num, num3);
		}
		return num;
	}

	public static float RaycastWaterColliders(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (!Physics.Raycast(Vector3Ex.WithY(pos, TerrainMeta.Max.y), Vector3.down, ref val, TerrainMeta.Size.y, 16, (QueryTriggerInteraction)2))
		{
			return WaterSystem.OceanLevel;
		}
		return ((RaycastHit)(ref val)).point.y;
	}

	public static void GetWaterLevels(ReadOnly<Vector3> positions, ReadOnly<int> indices, bool waves, NativeArray<float> heights)
	{
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_0346: Unknown result type (might be due to invalid IL or missing references)
		//IL_034c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0356: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_037e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0383: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_038c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevels", 0);
		try
		{
			waves = waves && (Object)(object)WaterSystem.Instance != (Object)null;
			float num = WaterSystem.OceanLevel;
			if (waves)
			{
				num += WaterSystem.Instance.oceanSimulation.MaxLevel();
			}
			UVs.Expand<Vector2>(positions.Length, (NativeArrayOptions)0, copyContents: false, usePowerOfTwo: false);
			NativeArray<Vector2> subArray = UVs.GetSubArray(0, positions.Length);
			ToUVJobIndirect toUVJobIndirect = default(ToUVJobIndirect);
			toUVJobIndirect.UV = subArray;
			toUVJobIndirect.Pos = positions;
			toUVJobIndirect.Indices = indices;
			toUVJobIndirect.TerrainPos = Vector3Ex.XZ2D(TerrainMeta.Position);
			toUVJobIndirect.TerrainOneOverSize = Vector3Ex.XZ2D(TerrainMeta.OneOverSize);
			ToUVJobIndirect toUVJobIndirect2 = toUVJobIndirect;
			IJobExtensions.RunByRef<ToUVJobIndirect>(ref toUVJobIndirect2);
			if (Object.op_Implicit((Object)(object)TerrainMeta.WaterMap))
			{
				TerrainMeta.WaterMap.GetHeightsIndirect(subArray.AsReadOnly(), indices, heights);
			}
			else
			{
				FillJob<float> fillJob = default(FillJob<float>);
				fillJob.Values = heights;
				fillJob.Value = TerrainMeta.Position.y;
				FillJob<float> fillJob2 = fillJob;
				IJobExtensions.RunByRef<FillJob<float>>(ref fillJob2);
			}
			NativeArrayEx.Expand(ref Topologies, positions.Length, (NativeArrayOptions)0, copyContents: false);
			NativeArray<int> subArray2 = Topologies.GetSubArray(0, positions.Length);
			if (Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap))
			{
				TerrainMeta.TopologyMap.GetTopologiesIndirect(subArray.AsReadOnly(), indices, subArray2);
			}
			else
			{
				FillJob<int> fillJob3 = default(FillJob<int>);
				fillJob3.Values = subArray2;
				fillJob3.Value = 384;
				FillJob<int> fillJob4 = fillJob3;
				IJobExtensions.RunByRef<FillJob<int>>(ref fillJob4);
			}
			if (!waves)
			{
				ApplyMaxHeightsJobIndirect applyMaxHeightsJobIndirect = default(ApplyMaxHeightsJobIndirect);
				applyMaxHeightsJobIndirect.Heights = heights;
				applyMaxHeightsJobIndirect.Topologies = subArray2.AsReadOnly();
				applyMaxHeightsJobIndirect.Indices = indices;
				applyMaxHeightsJobIndirect.WaterLevel = num;
				applyMaxHeightsJobIndirect.OceanLevel = WaterSystem.OceanLevel;
				ApplyMaxHeightsJobIndirect applyMaxHeightsJobIndirect2 = applyMaxHeightsJobIndirect;
				IJobExtensions.RunByRef<ApplyMaxHeightsJobIndirect>(ref applyMaxHeightsJobIndirect2);
				return;
			}
			NativeArrayEx.Expand(ref Indices, positions.Length, (NativeArrayOptions)0, copyContents: false);
			GatherWavesIndicesJobIndirect gatherWavesIndicesJobIndirect = default(GatherWavesIndicesJobIndirect);
			gatherWavesIndicesJobIndirect.WaveIndices = Indices;
			gatherWavesIndicesJobIndirect.WaveIndexCount = CounterRef;
			gatherWavesIndicesJobIndirect.Topologies = subArray2.AsReadOnly();
			gatherWavesIndicesJobIndirect.Heights = heights.AsReadOnly();
			gatherWavesIndicesJobIndirect.Indices = indices;
			gatherWavesIndicesJobIndirect.WaterLevel = num;
			GatherWavesIndicesJobIndirect gatherWavesIndicesJobIndirect2 = gatherWavesIndicesJobIndirect;
			IJobExtensions.RunByRef<GatherWavesIndicesJobIndirect>(ref gatherWavesIndicesJobIndirect2);
			int value = CounterRef.Value;
			if (value == 0)
			{
				return;
			}
			TimeWarning val2 = TimeWarning.New("Waves", 0);
			try
			{
				NativeArrayEx.Expand(ref TerrainHeights, positions.Length, (NativeArrayOptions)0, copyContents: false);
				NativeArrayEx.Expand(ref ShoreDists, positions.Length, (NativeArrayOptions)0, copyContents: false);
				NativeArrayEx.Expand(ref WaveHeights, positions.Length, (NativeArrayOptions)0, copyContents: false);
				ReadOnly<int> indices2 = Indices.GetSubArray(0, value).AsReadOnly();
				if (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap))
				{
					TerrainMeta.HeightMap.GetHeightsFastIndirect(subArray.AsReadOnly(), indices2, TerrainHeights);
				}
				else
				{
					FillJob<float> fillJob = default(FillJob<float>);
					fillJob.Values = TerrainHeights;
					fillJob.Value = 0f;
					FillJob<float> fillJob5 = fillJob;
					IJobExtensions.RunByRef<FillJob<float>>(ref fillJob5);
				}
				if (Object.op_Implicit((Object)(object)TerrainTexturing.Instance))
				{
					TerrainTexturing.Instance.GetCoarseDistancesToShoreIndirect(subArray.AsReadOnly(), indices2, ShoreDists);
				}
				else
				{
					FillJob<float> fillJob = default(FillJob<float>);
					fillJob.Values = ShoreDists;
					fillJob.Value = 0f;
					FillJob<float> fillJob6 = fillJob;
					IJobExtensions.RunByRef<FillJob<float>>(ref fillJob6);
				}
				WaterSystem.Instance.oceanSimulation.GetHeightsIndirect(positions, ShoreDists.AsReadOnly(), TerrainHeights.AsReadOnly(), indices2, WaveHeights);
				SelectMaxWaterLevelJobIndirect selectMaxWaterLevelJobIndirect = default(SelectMaxWaterLevelJobIndirect);
				selectMaxWaterLevelJobIndirect.Heights = heights;
				selectMaxWaterLevelJobIndirect.DynamicHeights = WaveHeights.AsReadOnly();
				selectMaxWaterLevelJobIndirect.Indices = indices2;
				selectMaxWaterLevelJobIndirect.OceanLevel = WaterSystem.OceanLevel;
				SelectMaxWaterLevelJobIndirect selectMaxWaterLevelJobIndirect2 = selectMaxWaterLevelJobIndirect;
				IJobExtensions.RunByRef<SelectMaxWaterLevelJobIndirect>(ref selectMaxWaterLevelJobIndirect2);
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static WaterInfo GetWaterInfoFromVolumes(Bounds bounds, BaseEntity forEntity)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		WaterInfo info = default(WaterInfo);
		if ((Object)(object)forEntity == (Object)null)
		{
			List<WaterVolume> list = Pool.Get<List<WaterVolume>>();
			Vis.Components<WaterVolume>(new OBB(bounds), list, 262144, (QueryTriggerInteraction)2);
			using (List<WaterVolume>.Enumerator enumerator = list.GetEnumerator())
			{
				while (enumerator.MoveNext() && !enumerator.Current.Test(bounds, out info))
				{
				}
			}
			Pool.FreeUnmanaged<WaterVolume>(ref list);
			return info;
		}
		forEntity.WaterTestFromVolumes(bounds, out info);
		return info;
	}

	private static WaterInfo GetWaterInfoFromVolumes(Vector3 pos, BaseEntity forEntity)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		WaterInfo info = default(WaterInfo);
		if ((Object)(object)forEntity == (Object)null)
		{
			List<WaterVolume> list = Pool.Get<List<WaterVolume>>();
			Vis.Components<WaterVolume>(pos, 0.1f, list, 262144, (QueryTriggerInteraction)2);
			foreach (WaterVolume item in list)
			{
				if (item.Test(pos, out info))
				{
					info.artificalWater = !item.naturalSource;
					break;
				}
			}
			Pool.FreeUnmanaged<WaterVolume>(ref list);
			return info;
		}
		forEntity.WaterTestFromVolumes(pos, out info);
		return info;
	}

	private static WaterInfo GetWaterInfoFromVolumes(Vector3 start, Vector3 end, float radius, BaseEntity forEntity)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		WaterInfo info = default(WaterInfo);
		if ((Object)(object)forEntity == (Object)null)
		{
			List<WaterVolume> list = Pool.Get<List<WaterVolume>>();
			Vis.Components<WaterVolume>(start, end, radius, list, 262144, (QueryTriggerInteraction)2);
			using (List<WaterVolume>.Enumerator enumerator = list.GetEnumerator())
			{
				while (enumerator.MoveNext() && !enumerator.Current.Test(start, end, radius, out info))
				{
				}
			}
			Pool.FreeUnmanaged<WaterVolume>(ref list);
			return info;
		}
		forEntity.WaterTestFromVolumes(start, end, radius, out info);
		return info;
	}

	public static WaterInfo InitialValidate(Vector3 start, Vector3 end, float radius, float waterHeight, float terrainHeight)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		WaterInfo result = default(WaterInfo);
		result.isValid = true;
		float num = Mathf.Min(start.y, end.y) - radius;
		float num2 = Mathf.Max(start.y, end.y) + radius;
		if (num > waterHeight)
		{
			result.isValid = false;
		}
		else if (num2 < terrainHeight - 1f)
		{
			result.isValid = false;
		}
		return result;
	}
}


public struct WaterInfo
{
	public bool isValid;

	public float currentDepth;

	public float overallDepth;

	public float surfaceLevel;

	public float terrainHeight;

	public bool artificalWater;

	public int topology;
}


using UnityEngine;

public class WaterResource
{
	public static ItemDefinition SV_GetAtPoint(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (IsRadioactive(pos))
		{
			return WaterTypes.RadioactiveWaterItemDef;
		}
		if (!IsFreshWater(pos))
		{
			return WaterTypes.SaltWaterItemDef;
		}
		return WaterTypes.WaterItemDef;
	}

	public static WaterBody FindWaterBodyAtPos(Vector3 pos)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		float num = 1.5f;
		RaycastHit hitInfo;
		bool num2 = GamePhysics.Trace(new Ray(pos + Vector3.up * num, Vector3.down), 0f, out hitInfo, 3f, 16, (QueryTriggerInteraction)0);
		WaterBody result = null;
		if (num2)
		{
			result = hitInfo.GetWaterBody();
		}
		return result;
	}

	public static bool IsRadioactive(WaterBody body)
	{
		return body.Type == WaterBodyType.Radioactive;
	}

	public static bool IsRadioactive(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		WaterBody waterBody = FindWaterBodyAtPos(pos);
		if (Object.op_Implicit((Object)(object)waterBody))
		{
			return waterBody.Type == WaterBodyType.Radioactive;
		}
		return false;
	}

	public static bool IsFreshWater(Vector3 pos)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.TopologyMap == (Object)null)
		{
			return false;
		}
		return TerrainMeta.TopologyMap.GetTopology(pos, 245760);
	}

	public static ItemDefinition Merge(ItemDefinition first, ItemDefinition second)
	{
		if ((Object)(object)first == (Object)(object)second)
		{
			return first;
		}
		if ((Object)(object)first == (Object)(object)WaterTypes.RadioactiveWaterItemDef || (Object)(object)second == (Object)(object)WaterTypes.RadioactiveWaterItemDef)
		{
			return WaterTypes.RadioactiveWaterItemDef;
		}
		if ((Object)(object)first == (Object)(object)WaterTypes.SaltWaterItemDef || (Object)(object)second == (Object)(object)WaterTypes.SaltWaterItemDef)
		{
			return WaterTypes.SaltWaterItemDef;
		}
		return WaterTypes.WaterItemDef;
	}
}


using UnityEngine;

public static class WaterTypes
{
	private static ItemDefinition _waterItemDef;

	private static ItemDefinition _saltWaterItemDef;

	private static ItemDefinition _radioactiveWaterItemDef;

	public static ItemDefinition WaterItemDef
	{
		get
		{
			if ((Object)(object)_waterItemDef == (Object)null)
			{
				_waterItemDef = ItemManager.FindItemDefinition("water");
			}
			return _waterItemDef;
		}
	}

	public static ItemDefinition SaltWaterItemDef
	{
		get
		{
			if ((Object)(object)_saltWaterItemDef == (Object)null)
			{
				_saltWaterItemDef = ItemManager.FindItemDefinition("water.salt");
			}
			return _saltWaterItemDef;
		}
	}

	public static ItemDefinition RadioactiveWaterItemDef
	{
		get
		{
			if ((Object)(object)_radioactiveWaterItemDef == (Object)null)
			{
				_radioactiveWaterItemDef = ItemManager.FindItemDefinition("water.radioactive");
			}
			return _radioactiveWaterItemDef;
		}
	}
}


using UnityEngine;

public class WaterVolume : TriggerBase
{
	public Bounds WaterBounds = new Bounds(Vector3.zero, Vector3.one);

	private OBB cachedBounds;

	private Transform cachedTransform;

	public Transform[] cutOffPlanes = (Transform[])(object)new Transform[0];

	[Tooltip("Allows filling bota bags, jugs, etc. Don't turn this on if the player is responsible for filling this water volume as that will allow water duplication")]
	public bool naturalSource;

	public bool waterEnabled = true;

	private void OnEnable()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		cachedTransform = ((Component)this).transform;
		cachedBounds = new OBB(cachedTransform, WaterBounds);
	}

	private Plane GetWaterPlane()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		return new Plane(cachedBounds.up, cachedBounds.position);
	}

	public bool Test(Vector3 pos, out WaterLevel.WaterInfo info)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		if (!waterEnabled)
		{
			info = default(WaterLevel.WaterInfo);
			return false;
		}
		UpdateCachedTransform();
		if (((OBB)(ref cachedBounds)).Contains(pos))
		{
			if (!CheckCutOffPlanes(pos, out var bottomCutY))
			{
				info = default(WaterLevel.WaterInfo);
				return false;
			}
			Plane waterPlane = GetWaterPlane();
			Vector3 val = ((Plane)(ref waterPlane)).ClosestPointOnPlane(pos);
			float y = (val + cachedBounds.up * cachedBounds.extents.y).y;
			float y2 = (val + -cachedBounds.up * cachedBounds.extents.y).y;
			y2 = Mathf.Max(y2, bottomCutY);
			info = default(WaterLevel.WaterInfo);
			info.isValid = true;
			info.artificalWater = !naturalSource;
			info.currentDepth = Mathf.Max(0f, y - pos.y);
			info.overallDepth = Mathf.Max(0f, y - y2);
			info.surfaceLevel = y;
			return true;
		}
		info = default(WaterLevel.WaterInfo);
		return false;
	}

	public bool Test(Bounds bounds, out WaterLevel.WaterInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		if (!waterEnabled)
		{
			info = default(WaterLevel.WaterInfo);
			return false;
		}
		UpdateCachedTransform();
		if (((OBB)(ref cachedBounds)).Contains(((Bounds)(ref bounds)).ClosestPoint(cachedBounds.position)))
		{
			if (!CheckCutOffPlanes(((Bounds)(ref bounds)).center, out var bottomCutY))
			{
				info = default(WaterLevel.WaterInfo);
				return false;
			}
			Plane waterPlane = GetWaterPlane();
			Vector3 val = ((Plane)(ref waterPlane)).ClosestPointOnPlane(((Bounds)(ref bounds)).center);
			float y = (val + cachedBounds.up * cachedBounds.extents.y).y;
			float y2 = (val + -cachedBounds.up * cachedBounds.extents.y).y;
			y2 = Mathf.Max(y2, bottomCutY);
			info = default(WaterLevel.WaterInfo);
			info.isValid = true;
			info.artificalWater = !naturalSource;
			info.currentDepth = Mathf.Max(0f, y - ((Bounds)(ref bounds)).min.y);
			info.overallDepth = Mathf.Max(0f, y - y2);
			info.surfaceLevel = y;
			return true;
		}
		info = default(WaterLevel.WaterInfo);
		return false;
	}

	public bool Test(Vector3 start, Vector3 end, float radius, out WaterLevel.WaterInfo info)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		if (!waterEnabled)
		{
			info = default(WaterLevel.WaterInfo);
			return false;
		}
		UpdateCachedTransform();
		Vector3 val = (start + end) * 0.5f;
		float num = Mathf.Min(start.y, end.y) - radius;
		if (((OBB)(ref cachedBounds)).Distance(start) < radius || ((OBB)(ref cachedBounds)).Distance(end) < radius)
		{
			if (!CheckCutOffPlanes(val, out var bottomCutY))
			{
				info = default(WaterLevel.WaterInfo);
				return false;
			}
			Plane waterPlane = GetWaterPlane();
			Vector3 val2 = ((Plane)(ref waterPlane)).ClosestPointOnPlane(val);
			float y = (val2 + cachedBounds.up * cachedBounds.extents.y).y;
			float y2 = (val2 + -cachedBounds.up * cachedBounds.extents.y).y;
			y2 = Mathf.Max(y2, bottomCutY);
			info = default(WaterLevel.WaterInfo);
			info.isValid = true;
			info.artificalWater = !naturalSource;
			info.currentDepth = Mathf.Max(0f, y - num);
			info.overallDepth = Mathf.Max(0f, y - y2);
			info.surfaceLevel = y;
			return true;
		}
		info = default(WaterLevel.WaterInfo);
		return false;
	}

	private bool CheckCutOffPlanes(Vector3 pos, out float bottomCutY)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		int num = cutOffPlanes.Length;
		bottomCutY = float.MaxValue;
		bool flag = true;
		for (int i = 0; i < num; i++)
		{
			if ((Object)(object)cutOffPlanes[i] != (Object)null)
			{
				Vector3 val = cutOffPlanes[i].InverseTransformPoint(pos);
				Vector3 position = cutOffPlanes[i].position;
				if (Vector3.Dot(cutOffPlanes[i].up, cachedBounds.up) < -0.1f)
				{
					bottomCutY = Mathf.Min(bottomCutY, position.y);
				}
				if (val.y > 0f)
				{
					flag = false;
					break;
				}
			}
		}
		if (!flag)
		{
			return false;
		}
		return true;
	}

	private void UpdateCachedTransform()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)cachedTransform != (Object)null && cachedTransform.hasChanged)
		{
			cachedBounds = new OBB(cachedTransform, WaterBounds);
			cachedTransform.hasChanged = false;
		}
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using UnityEngine;

public class Wearable : MonoBehaviour, IItemSetup, IPrefabPreProcess
{
	[Flags]
	public enum RemoveSkin
	{
		Torso = 1,
		Feet = 2,
		Hands = 4,
		Legs = 8,
		Head = 0x10
	}

	[Flags]
	public enum RemoveHair
	{
		Head = 1,
		Eyebrow = 2,
		Facial = 4,
		Armpit = 8,
		Pubic = 0x10
	}

	[Flags]
	public enum DeformHair
	{
		None = 0,
		BaseballCap = 1,
		BoonieHat = 2,
		CandleHat = 3,
		MinersHat = 4,
		WoodHelmet = 5
	}

	[Flags]
	public enum OccupationSlots
	{
		HeadTop = 1,
		Face = 2,
		HeadBack = 4,
		TorsoFront = 8,
		TorsoBack = 0x10,
		LeftShoulder = 0x20,
		RightShoulder = 0x40,
		LeftArm = 0x80,
		RightArm = 0x100,
		LeftHand = 0x200,
		RightHand = 0x400,
		Groin = 0x800,
		Bum = 0x1000,
		LeftKnee = 0x2000,
		RightKnee = 0x4000,
		LeftLeg = 0x8000,
		RightLeg = 0x10000,
		LeftFoot = 0x20000,
		RightFoot = 0x40000,
		Mouth = 0x80000,
		Eyes = 0x100000,
		Back = 0x200000
	}

	[Serializable]
	public struct PartRandomizer
	{
		public PartCollection[] groups;
	}

	[Serializable]
	public struct PartCollection
	{
		public GameObject[] parts;
	}

	[InspectorFlags]
	public RemoveSkin removeSkin;

	[InspectorFlags]
	public RemoveSkin removeSkinFirstPerson;

	[InspectorFlags]
	public RemoveHair removeHair;

	[InspectorFlags]
	public DeformHair deformHair;

	[InspectorFlags]
	public OccupationSlots occupationUnder;

	[InspectorFlags]
	public OccupationSlots occupationOver;

	[InspectorFlags]
	public OccupationSlots stripOccupation;

	public bool IsBackpack;

	public bool HideInPlayerPreview;

	public bool OnlyShowOnPlayerPreview;

	public bool showCensorshipCube;

	public bool showCensorshipCubeBreasts;

	public bool forceHideCensorshipBreasts;

	public string followBone;

	public bool disableRigStripping;

	public bool overrideDownLimit;

	public float downLimit = 70f;

	[NonSerialized]
	public bool hasClothingUnderNotifier;

	[Range(0f, 1f)]
	public float handcuffsSize;

	[HideInInspector]
	public PlayerModelHair playerModelHair;

	[HideInInspector]
	public PlayerModelHairCap playerModelHairCap;

	[HideInInspector]
	public WearableReplacementByRace wearableReplacementByRace;

	[HideInInspector]
	public WearableShadowLod wearableShadowLod;

	[HideInInspector]
	public List<Renderer> renderers = new List<Renderer>();

	[HideInInspector]
	public List<PlayerModelSkin> playerModelSkins = new List<PlayerModelSkin>();

	[HideInInspector]
	public List<BoneRetarget> boneRetargets = new List<BoneRetarget>();

	[HideInInspector]
	public List<SkinnedMeshRenderer> skinnedRenderers = new List<SkinnedMeshRenderer>();

	[HideInInspector]
	public List<SkeletonSkin> skeletonSkins = new List<SkeletonSkin>();

	[HideInInspector]
	public List<ComponentInfo> componentInfos = new List<ComponentInfo>();

	[HideInInspector]
	public List<WearableNotify> notifies = new List<WearableNotify>();

	public bool HideInEyesView;

	[Header("First Person Legs")]
	[Tooltip("If this is true, we'll hide this item in the first person view. Usually done for items that you definitely won't see in first person view, like facemasks and hats.")]
	public bool HideInFirstPerson;

	[Tooltip("Use this if the clothing item clips into the player view. It'll push the chest legs model backwards.")]
	[Range(0f, 5f)]
	public float ExtraLeanBack;

	[Tooltip("Enable this to check for BoneRetargets which need to be preserved in first person view")]
	public bool PreserveBones;

	public Renderer[] RenderersLod0;

	public bool LegFade;

	public Renderer[] RenderersLod1;

	public Renderer[] RenderersLod2;

	public Renderer[] RenderersLod3;

	public Renderer[] SkipInFirstPersonLegs;

	public Renderer[] RenderersLod4;

	private static LOD[] emptyLOD = (LOD[])(object)new LOD[1];

	public PartRandomizer[] randomParts;

	public bool stripOccupationCollisions => stripOccupation != (OccupationSlots)0;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public void OnItemSetup(Item item)
	{
	}

	public void OnSetupSkin(ulong skin, ItemDefinition definition)
	{
	}

	public virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		LODGroup[] componentsInChildren = ((Component)this).GetComponentsInChildren<LODGroup>(true);
		foreach (LODGroup val in componentsInChildren)
		{
			val.SetLODs(emptyLOD);
			preProcess.RemoveComponent((Component)(object)val);
		}
	}

	public void CacheComponents()
	{
		playerModelHairCap = ((Component)this).GetComponent<PlayerModelHairCap>();
		playerModelHair = ((Component)this).GetComponent<PlayerModelHair>();
		wearableReplacementByRace = ((Component)this).GetComponent<WearableReplacementByRace>();
		wearableShadowLod = ((Component)this).GetComponent<WearableShadowLod>();
		((Component)this).GetComponentsInChildren<Renderer>(true, renderers);
		((Component)this).GetComponentsInChildren<PlayerModelSkin>(true, playerModelSkins);
		((Component)this).GetComponentsInChildren<BoneRetarget>(true, boneRetargets);
		((Component)this).GetComponentsInChildren<SkinnedMeshRenderer>(true, skinnedRenderers);
		((Component)this).GetComponentsInChildren<SkeletonSkin>(true, skeletonSkins);
		((Component)this).GetComponentsInChildren<ComponentInfo>(true, componentInfos);
		((Component)this).GetComponentsInChildren<WearableNotify>(true, notifies);
		RenderersLod0 = renderers.Where((Renderer x) => ((Object)((Component)x).gameObject).name.EndsWith("0")).ToArray();
		RenderersLod1 = renderers.Where((Renderer x) => ((Object)((Component)x).gameObject).name.EndsWith("1")).ToArray();
		RenderersLod2 = renderers.Where((Renderer x) => ((Object)((Component)x).gameObject).name.EndsWith("2")).ToArray();
		RenderersLod3 = renderers.Where((Renderer x) => ((Object)((Component)x).gameObject).name.EndsWith("3")).ToArray();
		RenderersLod4 = renderers.Where((Renderer x) => ((Object)((Component)x).gameObject).name.EndsWith("4")).ToArray();
		foreach (Renderer renderer in renderers)
		{
			((Component)renderer).gameObject.AddComponent<ObjectMotionVectorFix>();
			renderer.motionVectorGenerationMode = (MotionVectorGenerationMode)2;
		}
	}

	public void StripRig(IPrefabProcessor preProcess, SkinnedMeshRenderer skinnedMeshRenderer)
	{
		if (disableRigStripping)
		{
			return;
		}
		Transform val = skinnedMeshRenderer.FindRig();
		if (!((Object)(object)val != (Object)null))
		{
			return;
		}
		List<Transform> list = Pool.Get<List<Transform>>();
		((Component)val).GetComponentsInChildren<Transform>(list);
		for (int num = list.Count - 1; num >= 0; num--)
		{
			if (preProcess != null)
			{
				preProcess.NominateForDeletion(((Component)list[num]).gameObject);
			}
			else
			{
				Object.DestroyImmediate((Object)(object)((Component)list[num]).gameObject);
			}
		}
		Pool.FreeUnmanaged<Transform>(ref list);
	}

	public void SetupRendererCache(IPrefabProcessor preProcess)
	{
	}
}


using System;

[Flags]
public enum RemoveSkin
{
	Torso = 1,
	Feet = 2,
	Hands = 4,
	Legs = 8,
	Head = 0x10
}


using System;

[Flags]
public enum RemoveHair
{
	Head = 1,
	Eyebrow = 2,
	Facial = 4,
	Armpit = 8,
	Pubic = 0x10
}


using System;

[Flags]
public enum DeformHair
{
	None = 0,
	BaseballCap = 1,
	BoonieHat = 2,
	CandleHat = 3,
	MinersHat = 4,
	WoodHelmet = 5
}


using System;

[Flags]
public enum OccupationSlots
{
	HeadTop = 1,
	Face = 2,
	HeadBack = 4,
	TorsoFront = 8,
	TorsoBack = 0x10,
	LeftShoulder = 0x20,
	RightShoulder = 0x40,
	LeftArm = 0x80,
	RightArm = 0x100,
	LeftHand = 0x200,
	RightHand = 0x400,
	Groin = 0x800,
	Bum = 0x1000,
	LeftKnee = 0x2000,
	RightKnee = 0x4000,
	LeftLeg = 0x8000,
	RightLeg = 0x10000,
	LeftFoot = 0x20000,
	RightFoot = 0x40000,
	Mouth = 0x80000,
	Eyes = 0x100000,
	Back = 0x200000
}


using System;

[Serializable]
public struct PartRandomizer
{
	public PartCollection[] groups;
}


using System;
using UnityEngine;

[Serializable]
public struct PartCollection
{
	public GameObject[] parts;
}


using UnityEngine;

public class WearableEyeViewAdjustment : MonoBehaviour
{
}


using UnityEngine;

public class WearableEyeViewAdjustment_Submesh : WearableEyeViewAdjustment
{
	public int TargetSubmesh;

	public Material HideMaterial;

	public Material DefaultMaterial;
}


using UnityEngine;

public class WearableFadeToggle : MonoBehaviour, IClientComponent
{
}


using System;
using UnityEngine;

public class WearableHolsterOffset : MonoBehaviour
{
	[Serializable]
	public class offsetInfo
	{
		public enum OverrideBone
		{
			None,
			Spine4
		}

		public HeldEntity.HolsterInfo.HolsterSlot type;

		public Vector3 offset;

		public Vector3 rotationOffset;

		public int priority;

		public Vector3 rightBackpackSlotOffset;

		public Vector3 rightBackpackSlotRotationOffset;

		public OverrideBone overrideBone;
	}

	public offsetInfo[] Offsets;
}


using System;
using UnityEngine;

[Serializable]
public class offsetInfo
{
	public enum OverrideBone
	{
		None,
		Spine4
	}

	public HeldEntity.HolsterInfo.HolsterSlot type;

	public Vector3 offset;

	public Vector3 rotationOffset;

	public int priority;

	public Vector3 rightBackpackSlotOffset;

	public Vector3 rightBackpackSlotRotationOffset;

	public OverrideBone overrideBone;
}


public enum OverrideBone
{
	None,
	Spine4
}


using UnityEngine;

public class WearableNotify : MonoBehaviour
{
}


using System.Collections.Generic;
using UnityEngine;

public class WearableNotifyConditionalClothing : WearableNotify
{
	public List<GameObject> MinClothing = new List<GameObject>();

	public List<GameObject> MaxClothing = new List<GameObject>();
}


using UnityEngine;

public class WearableNotifyHasBackpack : WearableNotify
{
	public GameObject[] ObjectsToHide = (GameObject[])(object)new GameObject[0];
}


using UnityEngine.Events;

public class WearableNotifyLifestate : WearableNotify
{
	public BaseCombatEntity.LifeState TargetState;

	public UnityEvent OnTargetState = new UnityEvent();

	public UnityEvent OnTargetStateFailed = new UnityEvent();
}


using Facepunch.BurstCloth;
using UnityEngine;
using UnityEngine.Events;

public class WearableNotifyTrophyMounted : WearableNotify
{
	public UnityEvent OnMounted = new UnityEvent();

	public Renderer[] EmissionToggles;

	public BurstCloth[] BurstCloths;
}


using System;
using UnityEngine;

public class WearableRandomMaterial : MonoBehaviour
{
	[Serializable]
	public struct MaterialOption
	{
		public int Chance;

		public Material ToApply;
	}

	[Serializable]
	public struct TargetRenderer
	{
		public Renderer Renderer;

		public int MaterialIndex;
	}

	public TargetRenderer[] TargetRenderers;

	public MaterialOption[] MaterialOptions;

	public bool RunRandomisation;
}


using System;
using UnityEngine;

[Serializable]
public struct MaterialOption
{
	public int Chance;

	public Material ToApply;
}


using System;
using UnityEngine;

[Serializable]
public struct TargetRenderer
{
	public Renderer Renderer;

	public int MaterialIndex;
}


using UnityEngine;

public class WearableReplacementByRace : MonoBehaviour
{
	public GameObjectRef[] replacements;

	public GameObjectRef GetReplacement(int meshIndex)
	{
		int num = Mathf.Clamp(meshIndex, 0, replacements.Length - 1);
		return replacements[num];
	}
}


using UnityEngine;

public class WearableShadowLod : MonoBehaviour, IClientComponent
{
	public Renderer[] DisableShadows;
}


using UnityEngine;

public abstract class WeatherEffect : BaseMonoBehaviour, IClientComponent
{
	public ParticleSystem[] emitOnStart;

	public ParticleSystem[] emitOnStop;

	public ParticleSystem[] emitOnLoop;
}


public class AuroraEffect : WeatherEffect
{
}


public class RainbowEffect : WeatherEffect
{
}


public class RainEffect : WeatherEffect
{
	public int FadeStartDistance = 10;

	public int FadeEndDistance = 50;

	public int FadeFalloff = 3;

	public bool Stormy;
}


public class SnowEffect : WeatherEffect
{
	public int FadeStartDistance = 10;

	public int FadeEndDistance = 50;

	public int FadeFalloff = 3;

	public bool Stormy;
}


public class UnderwaterEffect : WeatherEffect
{
}


public abstract class WeatherEffectSting : BaseMonoBehaviour, IClientComponent
{
	public float frequency = 600f;

	public float variance = 300f;

	public GameObjectRef[] effects;
}


public class RainEffectSting : WeatherEffectSting
{
}


public enum WeatherPresetType
{
	Clear,
	Overcast,
	Storm,
	Dust,
	Fog,
	Rain,
	Cinematic
}


using System;
using System.Collections.Generic;
using System.Text;
using Facepunch.Extend;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/WeatherPreset")]
public class WeatherPreset : ScriptableObject
{
	[Serializable]
	public struct BiomeFogMults
	{
		public float AmbientIntensityMult;

		public float LightBoostMult;

		public float FogRampStartDist;

		public float FogRampEndDist;

		public void Reset()
		{
			AmbientIntensityMult = -1f;
			LightBoostMult = -1f;
			FogRampStartDist = -1f;
			FogRampEndDist = -1f;
		}

		public static BiomeFogMults Default()
		{
			BiomeFogMults result = default(BiomeFogMults);
			result.AmbientIntensityMult = 1f;
			result.LightBoostMult = 1f;
			result.FogRampStartDist = 0f;
			result.FogRampEndDist = 0.0001f;
			return result;
		}
	}

	public WeatherPresetType Type;

	public float Wind;

	public float Rain;

	public float Thunder;

	public float Rainbow;

	public TOD_AtmosphereParameters Atmosphere;

	public TOD_CloudParameters Clouds;

	public float AmbientLightMultiplier = 1f;

	public float DirectionalLightMultiplier = 1f;

	public float ReflectionMultiplier = 1f;

	public float SunMeshBrightnessMultiplier = 1f;

	public float MoonMeshBrightnessMultiplier = 1f;

	public float FogMultiplier = 5f;

	public float BiomeFogDistanceCurve = 1f;

	public float BiomeFogAmbientSaturationMult = 1f;

	public float AtmosphereFogHeightFalloff;

	public float AtmosphereFogRampStartDistance;

	public float AtmosphereFogRampEndDistance = 0.0001f;

	[Range(0f, 10f)]
	public float OceanScale;

	public BiomeFogMults AridFogMults = BiomeFogMults.Default();

	public BiomeFogMults TemperateFogMults = BiomeFogMults.Default();

	public BiomeFogMults TundraFogMults = BiomeFogMults.Default();

	public BiomeFogMults ArcticFogMults = BiomeFogMults.Default();

	public BiomeFogMults JungleFogMults = BiomeFogMults.Default();

	public VolumeCloudsConfig[] VolumeCloudsConfigs;

	public VolumeCloudsCirrusConfig[] VolumeCloudsCirrusConfigs;

	public VolumeCloudsRadialWeatherLayerConfig[] VolumeCloudsStormLayers;

	public float VolumeCloudsSunColorScale = -1f;

	public float VolumeCloudsMoonColorScale = -1f;

	public float VolumeCloudsAtmosphericHaze = -1f;

	public float VolumeCloudsSkyOcclusion = -1f;

	public int OverrideCloudConfig = -1;

	public void Apply(TOD_Sky sky)
	{
		sky.Atmosphere.RayleighMultiplier = Atmosphere.RayleighMultiplier;
		sky.Atmosphere.MieMultiplier = Atmosphere.MieMultiplier;
		sky.Atmosphere.Brightness = Atmosphere.Brightness;
		sky.Atmosphere.Contrast = Atmosphere.Contrast;
		sky.Atmosphere.Directionality = Atmosphere.Directionality;
		sky.Atmosphere.Fogginess = Atmosphere.Fogginess;
		sky.Atmosphere.NightContrast = Atmosphere.NightContrast;
		sky.Atmosphere.NightBrightness = Atmosphere.NightBrightness;
		sky.Clouds.Size = Clouds.Size;
		sky.Clouds.Opacity = Clouds.Opacity;
		sky.Clouds.Coverage = Clouds.Coverage;
		sky.Clouds.Sharpness = Clouds.Sharpness;
		sky.Clouds.Coloring = Clouds.Coloring;
		sky.Clouds.Attenuation = Clouds.Attenuation;
		sky.Clouds.Saturation = Clouds.Saturation;
		sky.Clouds.Scattering = Clouds.Scattering;
		sky.Clouds.Brightness = Clouds.Brightness;
	}

	public void Copy(TOD_Sky sky)
	{
		Atmosphere.RayleighMultiplier = sky.Atmosphere.RayleighMultiplier;
		Atmosphere.MieMultiplier = sky.Atmosphere.MieMultiplier;
		Atmosphere.Brightness = sky.Atmosphere.Brightness;
		Atmosphere.Contrast = sky.Atmosphere.Contrast;
		Atmosphere.Directionality = sky.Atmosphere.Directionality;
		Atmosphere.Fogginess = sky.Atmosphere.Fogginess;
		Atmosphere.NightBrightness = sky.Atmosphere.NightBrightness;
		Atmosphere.NightContrast = sky.Atmosphere.NightContrast;
		Clouds.Size = sky.Clouds.Size;
		Clouds.Opacity = sky.Clouds.Opacity;
		Clouds.Coverage = sky.Clouds.Coverage;
		Clouds.Sharpness = sky.Clouds.Sharpness;
		Clouds.Coloring = sky.Clouds.Coloring;
		Clouds.Attenuation = sky.Clouds.Attenuation;
		Clouds.Saturation = sky.Clouds.Saturation;
		Clouds.Scattering = sky.Clouds.Scattering;
		Clouds.Brightness = sky.Clouds.Brightness;
	}

	public void Reset()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Expected O, but got Unknown
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Expected O, but got Unknown
		Wind = -1f;
		Rain = -1f;
		Thunder = -1f;
		Rainbow = -1f;
		Atmosphere = new TOD_AtmosphereParameters();
		Atmosphere.RayleighMultiplier = -1f;
		Atmosphere.MieMultiplier = -1f;
		Atmosphere.Brightness = -1f;
		Atmosphere.Contrast = -1f;
		Atmosphere.Directionality = -1f;
		Atmosphere.Fogginess = -1f;
		Atmosphere.NightContrast = -1f;
		Atmosphere.NightBrightness = -1f;
		Clouds = new TOD_CloudParameters();
		Clouds.Size = -1f;
		Clouds.Opacity = -1f;
		Clouds.Coverage = -1f;
		Clouds.Sharpness = -1f;
		Clouds.Coloring = -1f;
		Clouds.Attenuation = -1f;
		Clouds.Saturation = -1f;
		Clouds.Scattering = -1f;
		Clouds.Brightness = -1f;
		AmbientLightMultiplier = -1f;
		DirectionalLightMultiplier = -1f;
		ReflectionMultiplier = -1f;
		SunMeshBrightnessMultiplier = -1f;
		MoonMeshBrightnessMultiplier = -1f;
		FogMultiplier = -1f;
		OceanScale = -1f;
		VolumeCloudsSunColorScale = -1f;
		VolumeCloudsMoonColorScale = -1f;
		VolumeCloudsSkyOcclusion = -1f;
		VolumeCloudsAtmosphericHaze = -1f;
		BiomeFogDistanceCurve = -1f;
		BiomeFogAmbientSaturationMult = -1f;
		AtmosphereFogHeightFalloff = -1f;
		AtmosphereFogRampStartDistance = -1f;
		AtmosphereFogRampEndDistance = -1f;
		AridFogMults.Reset();
		TemperateFogMults.Reset();
		TundraFogMults.Reset();
		ArcticFogMults.Reset();
		JungleFogMults.Reset();
		OverrideCloudConfig = -1;
	}

	public void Set(WeatherPreset other)
	{
		Wind = other.Wind;
		Rain = other.Rain;
		Thunder = other.Thunder;
		Rainbow = other.Rainbow;
		Atmosphere.RayleighMultiplier = other.Atmosphere.RayleighMultiplier;
		Atmosphere.MieMultiplier = other.Atmosphere.MieMultiplier;
		Atmosphere.Brightness = other.Atmosphere.Brightness;
		Atmosphere.Contrast = other.Atmosphere.Contrast;
		Atmosphere.Directionality = other.Atmosphere.Directionality;
		Atmosphere.Fogginess = other.Atmosphere.Fogginess;
		Atmosphere.NightContrast = other.Atmosphere.NightContrast;
		Atmosphere.NightBrightness = other.Atmosphere.NightBrightness;
		Clouds.Size = other.Clouds.Size;
		Clouds.Opacity = other.Clouds.Opacity;
		Clouds.Coverage = other.Clouds.Coverage;
		Clouds.Sharpness = other.Clouds.Sharpness;
		Clouds.Coloring = other.Clouds.Coloring;
		Clouds.Attenuation = other.Clouds.Attenuation;
		Clouds.Saturation = other.Clouds.Saturation;
		Clouds.Scattering = other.Clouds.Scattering;
		Clouds.Brightness = other.Clouds.Brightness;
		AmbientLightMultiplier = other.AmbientLightMultiplier;
		DirectionalLightMultiplier = other.DirectionalLightMultiplier;
		ReflectionMultiplier = other.ReflectionMultiplier;
		SunMeshBrightnessMultiplier = other.SunMeshBrightnessMultiplier;
		MoonMeshBrightnessMultiplier = other.MoonMeshBrightnessMultiplier;
		FogMultiplier = other.FogMultiplier;
		BiomeFogDistanceCurve = other.BiomeFogDistanceCurve;
		BiomeFogAmbientSaturationMult = other.BiomeFogAmbientSaturationMult;
		AtmosphereFogHeightFalloff = other.AtmosphereFogHeightFalloff;
		AtmosphereFogRampStartDistance = other.AtmosphereFogRampStartDistance;
		AtmosphereFogRampEndDistance = other.AtmosphereFogRampEndDistance;
		OceanScale = other.OceanScale;
		VolumeCloudsAtmosphericHaze = other.VolumeCloudsAtmosphericHaze;
		VolumeCloudsSunColorScale = other.VolumeCloudsSunColorScale;
		VolumeCloudsSkyOcclusion = other.VolumeCloudsSkyOcclusion;
		VolumeCloudsMoonColorScale = other.VolumeCloudsMoonColorScale;
		AridFogMults = other.AridFogMults;
		TemperateFogMults = other.TemperateFogMults;
		TundraFogMults = other.TundraFogMults;
		ArcticFogMults = other.ArcticFogMults;
		OverrideCloudConfig = other.OverrideCloudConfig;
	}

	public void SetVolumeCloudsConfigs(WeatherPreset other)
	{
		if (other.VolumeCloudsConfigs == null)
		{
			VolumeCloudsConfigs = null;
			OverrideCloudConfig = -1;
			return;
		}
		VolumeCloudsConfigs = new VolumeCloudsConfig[other.VolumeCloudsConfigs.Length];
		for (int i = 0; i < other.VolumeCloudsConfigs.Length; i++)
		{
			VolumeCloudsConfigs[i] = other.VolumeCloudsConfigs[i];
		}
		if (VolumeCloudsConfigs.Length != 0)
		{
			OverrideCloudConfig = List.FindIndex<VolumeCloudsConfig>((IReadOnlyList<VolumeCloudsConfig>)SingletonComponent<Climate>.Instance.AllCloudConfigs, VolumeCloudsConfigs[0], (IEqualityComparer<VolumeCloudsConfig>)null);
		}
		else
		{
			OverrideCloudConfig = -1;
		}
	}

	public override string ToString()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"Wind {Wind}");
		stringBuilder.AppendLine($"Rain {Rain}");
		stringBuilder.AppendLine($"Thunder {Thunder}");
		stringBuilder.AppendLine($"Rainbow {Rainbow}");
		stringBuilder.AppendLine($"RayleighMultiplier {Atmosphere.RayleighMultiplier}");
		stringBuilder.AppendLine($"MieMultiplier {Atmosphere.MieMultiplier}");
		stringBuilder.AppendLine($"Brightness {Atmosphere.Brightness}");
		stringBuilder.AppendLine($"Contrast {Atmosphere.Contrast}");
		stringBuilder.AppendLine($"Directionality {Atmosphere.Directionality}");
		stringBuilder.AppendLine($"Fogginess {Atmosphere.Fogginess}");
		stringBuilder.AppendLine($"Night Brightness {Atmosphere.NightBrightness}");
		stringBuilder.AppendLine($"Night Contrast {Atmosphere.NightContrast}");
		stringBuilder.AppendLine($"Size {Clouds.Size}");
		stringBuilder.AppendLine($"Opacity {Clouds.Opacity}");
		stringBuilder.AppendLine($"Coverage {Clouds.Coverage}");
		stringBuilder.AppendLine($"Sharpness {Clouds.Sharpness}");
		stringBuilder.AppendLine($"Coloring {Clouds.Coloring}");
		stringBuilder.AppendLine($"Attenuation {Clouds.Attenuation}");
		stringBuilder.AppendLine($"Saturation {Clouds.Saturation}");
		stringBuilder.AppendLine($"Scattering {Clouds.Scattering}");
		stringBuilder.AppendLine($"Brightness {Clouds.Brightness}");
		stringBuilder.AppendLine($"AmbientLightMultiplier {AmbientLightMultiplier}");
		stringBuilder.AppendLine($"DirectionalLightMultiplier {DirectionalLightMultiplier}");
		stringBuilder.AppendLine($"ReflectionMultiplier {ReflectionMultiplier}");
		stringBuilder.AppendLine($"SunMeshBrightnessMultiplier {SunMeshBrightnessMultiplier}");
		stringBuilder.AppendLine($"MoonMeshBrightnessMultiplier {MoonMeshBrightnessMultiplier}");
		stringBuilder.AppendLine($"FogMultiplier {FogMultiplier}");
		stringBuilder.AppendLine($"BiomeFogDistanceCurve {BiomeFogDistanceCurve}");
		stringBuilder.AppendLine($"BiomeFogAmbientSaturationMult {BiomeFogAmbientSaturationMult}");
		stringBuilder.AppendLine($"AtmosphereFogHeightFalloff {AtmosphereFogHeightFalloff}");
		stringBuilder.AppendLine($"AtmosphereFogRampStartDistance {AtmosphereFogRampStartDistance}");
		stringBuilder.AppendLine($"AtmosphereFogRampEndDistance {AtmosphereFogRampEndDistance}");
		stringBuilder.AppendLine($"Ocean {OceanScale}");
		return stringBuilder.ToString();
	}

	public void Fade(WeatherPreset a, WeatherPreset b, float t)
	{
		Fade(ref Wind, a.Wind, b.Wind, t);
		Fade(ref Rain, a.Rain, b.Rain, t);
		Fade(ref Thunder, a.Thunder, b.Thunder, t);
		Fade(ref Rainbow, a.Rainbow, b.Rainbow, t);
		Fade(ref Atmosphere.RayleighMultiplier, a.Atmosphere.RayleighMultiplier, b.Atmosphere.RayleighMultiplier, t);
		Fade(ref Atmosphere.MieMultiplier, a.Atmosphere.MieMultiplier, b.Atmosphere.MieMultiplier, t);
		Fade(ref Atmosphere.Brightness, a.Atmosphere.Brightness, b.Atmosphere.Brightness, t);
		Fade(ref Atmosphere.Contrast, a.Atmosphere.Contrast, b.Atmosphere.Contrast, t);
		Fade(ref Atmosphere.Directionality, a.Atmosphere.Directionality, b.Atmosphere.Directionality, t);
		Fade(ref Atmosphere.Fogginess, a.Atmosphere.Fogginess, b.Atmosphere.Fogginess, t);
		Fade(ref Atmosphere.NightContrast, a.Atmosphere.NightContrast, b.Atmosphere.NightContrast, t);
		Fade(ref Atmosphere.NightBrightness, a.Atmosphere.NightBrightness, b.Atmosphere.NightBrightness, t);
		Fade(ref Clouds.Size, a.Clouds.Size, b.Clouds.Size, t);
		Fade(ref Clouds.Opacity, a.Clouds.Opacity, b.Clouds.Opacity, t);
		Fade(ref Clouds.Coverage, a.Clouds.Coverage, b.Clouds.Coverage, t);
		Fade(ref Clouds.Sharpness, a.Clouds.Sharpness, b.Clouds.Sharpness, t);
		Fade(ref Clouds.Coloring, a.Clouds.Coloring, b.Clouds.Coloring, t);
		Fade(ref Clouds.Attenuation, a.Clouds.Attenuation, b.Clouds.Attenuation, t);
		Fade(ref Clouds.Saturation, a.Clouds.Saturation, b.Clouds.Saturation, t);
		Fade(ref Clouds.Scattering, a.Clouds.Scattering, b.Clouds.Scattering, t);
		Fade(ref Clouds.Brightness, a.Clouds.Brightness, b.Clouds.Brightness, t);
		Fade(ref AmbientLightMultiplier, a.AmbientLightMultiplier, b.AmbientLightMultiplier, t);
		Fade(ref DirectionalLightMultiplier, a.DirectionalLightMultiplier, b.DirectionalLightMultiplier, t);
		Fade(ref ReflectionMultiplier, a.ReflectionMultiplier, b.ReflectionMultiplier, t);
		Fade(ref SunMeshBrightnessMultiplier, a.SunMeshBrightnessMultiplier, b.SunMeshBrightnessMultiplier, t);
		Fade(ref MoonMeshBrightnessMultiplier, a.MoonMeshBrightnessMultiplier, b.MoonMeshBrightnessMultiplier, t);
		Fade(ref FogMultiplier, a.FogMultiplier, b.FogMultiplier, t);
		Fade(ref BiomeFogDistanceCurve, a.BiomeFogDistanceCurve, b.BiomeFogDistanceCurve, t);
		Fade(ref BiomeFogAmbientSaturationMult, a.BiomeFogAmbientSaturationMult, b.BiomeFogAmbientSaturationMult, t);
		Fade(ref AtmosphereFogHeightFalloff, a.AtmosphereFogHeightFalloff, b.AtmosphereFogHeightFalloff, t);
		Fade(ref AtmosphereFogRampStartDistance, a.AtmosphereFogRampStartDistance, b.AtmosphereFogRampStartDistance, t);
		Fade(ref AtmosphereFogRampEndDistance, a.AtmosphereFogRampEndDistance, b.AtmosphereFogRampEndDistance, t);
		Fade(ref OceanScale, a.OceanScale, b.OceanScale, t);
		Fade(ref VolumeCloudsSunColorScale, a.VolumeCloudsSunColorScale, b.VolumeCloudsSunColorScale, t);
		Fade(ref VolumeCloudsMoonColorScale, a.VolumeCloudsMoonColorScale, b.VolumeCloudsMoonColorScale, t);
		Fade(ref VolumeCloudsSkyOcclusion, a.VolumeCloudsSkyOcclusion, b.VolumeCloudsSkyOcclusion, t);
		Fade(ref VolumeCloudsAtmosphericHaze, a.VolumeCloudsAtmosphericHaze, b.VolumeCloudsAtmosphericHaze, t);
		Fade(ref AridFogMults, a.AridFogMults, b.AridFogMults, t);
		Fade(ref TemperateFogMults, a.TemperateFogMults, b.TemperateFogMults, t);
		Fade(ref TundraFogMults, a.TundraFogMults, b.TundraFogMults, t);
		Fade(ref ArcticFogMults, a.ArcticFogMults, b.ArcticFogMults, t);
		Fade(ref JungleFogMults, a.JungleFogMults, b.JungleFogMults, t);
	}

	public void Override(WeatherPreset other)
	{
		Override(ref Wind, other.Wind);
		Override(ref Rain, other.Rain);
		Override(ref Thunder, other.Thunder);
		Override(ref Rainbow, other.Rainbow);
		Override(ref Atmosphere.RayleighMultiplier, other.Atmosphere.RayleighMultiplier);
		Override(ref Atmosphere.MieMultiplier, other.Atmosphere.MieMultiplier);
		Override(ref Atmosphere.Brightness, other.Atmosphere.Brightness);
		Override(ref Atmosphere.Contrast, other.Atmosphere.Contrast);
		Override(ref Atmosphere.Directionality, other.Atmosphere.Directionality);
		Override(ref Atmosphere.Fogginess, other.Atmosphere.Fogginess);
		Override(ref Atmosphere.NightBrightness, other.Atmosphere.NightBrightness);
		Override(ref Atmosphere.NightContrast, other.Atmosphere.NightContrast);
		Override(ref Clouds.Size, other.Clouds.Size);
		Override(ref Clouds.Opacity, other.Clouds.Opacity);
		Override(ref Clouds.Coverage, other.Clouds.Coverage);
		Override(ref Clouds.Sharpness, other.Clouds.Sharpness);
		Override(ref Clouds.Coloring, other.Clouds.Coloring);
		Override(ref Clouds.Attenuation, other.Clouds.Attenuation);
		Override(ref Clouds.Saturation, other.Clouds.Saturation);
		Override(ref Clouds.Scattering, other.Clouds.Scattering);
		Override(ref Clouds.Brightness, other.Clouds.Brightness);
		Override(ref AmbientLightMultiplier, other.AmbientLightMultiplier);
		Override(ref DirectionalLightMultiplier, other.DirectionalLightMultiplier);
		Override(ref ReflectionMultiplier, other.ReflectionMultiplier);
		Override(ref SunMeshBrightnessMultiplier, other.SunMeshBrightnessMultiplier);
		Override(ref MoonMeshBrightnessMultiplier, other.MoonMeshBrightnessMultiplier);
		Override(ref FogMultiplier, other.FogMultiplier);
		Override(ref BiomeFogDistanceCurve, other.BiomeFogDistanceCurve);
		Override(ref BiomeFogAmbientSaturationMult, other.BiomeFogAmbientSaturationMult);
		Override(ref AtmosphereFogHeightFalloff, other.AtmosphereFogHeightFalloff);
		Override(ref AtmosphereFogRampStartDistance, other.AtmosphereFogRampStartDistance);
		Override(ref AtmosphereFogRampEndDistance, other.AtmosphereFogRampEndDistance);
		Override(ref OceanScale, other.OceanScale);
		Override(ref VolumeCloudsSunColorScale, other.VolumeCloudsSunColorScale);
		Override(ref VolumeCloudsMoonColorScale, other.VolumeCloudsMoonColorScale);
		Override(ref VolumeCloudsSkyOcclusion, other.VolumeCloudsSkyOcclusion);
		Override(ref VolumeCloudsAtmosphericHaze, other.VolumeCloudsAtmosphericHaze);
		Override(ref AridFogMults, other.AridFogMults);
		Override(ref TemperateFogMults, other.TemperateFogMults);
		Override(ref TundraFogMults, other.TundraFogMults);
		Override(ref ArcticFogMults, other.ArcticFogMults);
		Override(ref JungleFogMults, other.JungleFogMults);
		OverrideCloudConfig = other.OverrideCloudConfig;
	}

	public void Max(WeatherPreset other)
	{
		Max(ref Wind, other.Wind);
		Max(ref Rain, other.Rain);
		Max(ref Thunder, other.Thunder);
		Max(ref Rainbow, other.Rainbow);
		Max(ref Atmosphere.RayleighMultiplier, other.Atmosphere.RayleighMultiplier);
		Max(ref Atmosphere.MieMultiplier, other.Atmosphere.MieMultiplier);
		Max(ref Atmosphere.Brightness, other.Atmosphere.Brightness);
		Max(ref Atmosphere.Contrast, other.Atmosphere.Contrast);
		Max(ref Atmosphere.Directionality, other.Atmosphere.Directionality);
		Max(ref Atmosphere.Fogginess, other.Atmosphere.Fogginess);
		Max(ref Atmosphere.NightContrast, other.Atmosphere.NightContrast);
		Max(ref Atmosphere.NightBrightness, other.Atmosphere.NightBrightness);
		Max(ref Clouds.Size, other.Clouds.Size);
		Max(ref Clouds.Opacity, other.Clouds.Opacity);
		Max(ref Clouds.Coverage, other.Clouds.Coverage);
		Max(ref Clouds.Sharpness, other.Clouds.Sharpness);
		Max(ref Clouds.Coloring, other.Clouds.Coloring);
		Max(ref Clouds.Attenuation, other.Clouds.Attenuation);
		Max(ref Clouds.Saturation, other.Clouds.Saturation);
		Max(ref Clouds.Scattering, other.Clouds.Scattering);
		Max(ref Clouds.Brightness, other.Clouds.Brightness);
		Max(ref AmbientLightMultiplier, other.AmbientLightMultiplier);
		Max(ref DirectionalLightMultiplier, other.DirectionalLightMultiplier);
		Max(ref ReflectionMultiplier, other.ReflectionMultiplier);
		Max(ref SunMeshBrightnessMultiplier, other.SunMeshBrightnessMultiplier);
		Max(ref MoonMeshBrightnessMultiplier, other.MoonMeshBrightnessMultiplier);
		Max(ref FogMultiplier, other.FogMultiplier);
		Max(ref BiomeFogDistanceCurve, other.BiomeFogDistanceCurve);
		Max(ref BiomeFogAmbientSaturationMult, other.BiomeFogAmbientSaturationMult);
		Max(ref AtmosphereFogHeightFalloff, other.AtmosphereFogHeightFalloff);
		Max(ref AtmosphereFogRampStartDistance, other.AtmosphereFogRampStartDistance);
		Max(ref AtmosphereFogRampEndDistance, other.AtmosphereFogRampEndDistance);
		Max(ref OceanScale, other.OceanScale);
		Max(ref VolumeCloudsSunColorScale, other.VolumeCloudsSunColorScale);
		Max(ref VolumeCloudsMoonColorScale, other.VolumeCloudsMoonColorScale);
		Max(ref VolumeCloudsSkyOcclusion, other.VolumeCloudsSkyOcclusion);
		Max(ref VolumeCloudsAtmosphericHaze, other.VolumeCloudsAtmosphericHaze);
		Max(ref AridFogMults, other.AridFogMults);
		Max(ref TemperateFogMults, other.TemperateFogMults);
		Max(ref TundraFogMults, other.TundraFogMults);
		Max(ref ArcticFogMults, other.ArcticFogMults);
		Max(ref JungleFogMults, other.JungleFogMults);
	}

	public void Min(WeatherPreset other)
	{
		Min(ref Wind, other.Wind);
		Min(ref Rain, other.Rain);
		Min(ref Thunder, other.Thunder);
		Min(ref Rainbow, other.Rainbow);
		Min(ref Atmosphere.RayleighMultiplier, other.Atmosphere.RayleighMultiplier);
		Min(ref Atmosphere.MieMultiplier, other.Atmosphere.MieMultiplier);
		Min(ref Atmosphere.Brightness, other.Atmosphere.Brightness);
		Min(ref Atmosphere.Contrast, other.Atmosphere.Contrast);
		Min(ref Atmosphere.Directionality, other.Atmosphere.Directionality);
		Min(ref Atmosphere.Fogginess, other.Atmosphere.Fogginess);
		Min(ref Atmosphere.NightContrast, other.Atmosphere.NightContrast);
		Min(ref Atmosphere.NightBrightness, other.Atmosphere.NightBrightness);
		Min(ref Clouds.Size, other.Clouds.Size);
		Min(ref Clouds.Opacity, other.Clouds.Opacity);
		Min(ref Clouds.Coverage, other.Clouds.Coverage);
		Min(ref Clouds.Sharpness, other.Clouds.Sharpness);
		Min(ref Clouds.Coloring, other.Clouds.Coloring);
		Min(ref Clouds.Attenuation, other.Clouds.Attenuation);
		Min(ref Clouds.Saturation, other.Clouds.Saturation);
		Min(ref Clouds.Scattering, other.Clouds.Scattering);
		Min(ref Clouds.Brightness, other.Clouds.Brightness);
		Min(ref AmbientLightMultiplier, other.AmbientLightMultiplier);
		Min(ref DirectionalLightMultiplier, other.DirectionalLightMultiplier);
		Min(ref ReflectionMultiplier, other.ReflectionMultiplier);
		Min(ref SunMeshBrightnessMultiplier, other.SunMeshBrightnessMultiplier);
		Min(ref MoonMeshBrightnessMultiplier, other.MoonMeshBrightnessMultiplier);
		Min(ref FogMultiplier, other.FogMultiplier);
		Min(ref BiomeFogDistanceCurve, other.BiomeFogDistanceCurve);
		Min(ref BiomeFogAmbientSaturationMult, other.BiomeFogAmbientSaturationMult);
		Min(ref AtmosphereFogHeightFalloff, other.AtmosphereFogHeightFalloff);
		Min(ref AtmosphereFogRampStartDistance, other.AtmosphereFogRampStartDistance);
		Min(ref AtmosphereFogRampEndDistance, other.AtmosphereFogRampEndDistance);
		Min(ref OceanScale, other.OceanScale);
		Min(ref VolumeCloudsSunColorScale, other.VolumeCloudsSunColorScale);
		Min(ref VolumeCloudsMoonColorScale, other.VolumeCloudsMoonColorScale);
		Min(ref VolumeCloudsSkyOcclusion, other.VolumeCloudsSkyOcclusion);
		Min(ref VolumeCloudsAtmosphericHaze, other.VolumeCloudsAtmosphericHaze);
		Min(ref AridFogMults, other.AridFogMults);
		Min(ref TemperateFogMults, other.TemperateFogMults);
		Min(ref TundraFogMults, other.TundraFogMults);
		Min(ref ArcticFogMults, other.ArcticFogMults);
		Min(ref JungleFogMults, other.JungleFogMults);
	}

	private void Fade(ref float x, float a, float b, float t)
	{
		x = Mathf.SmoothStep(a, b, t);
	}

	private void Override(ref float x, float other)
	{
		if (other >= 0f)
		{
			x = other;
		}
	}

	private void Max(ref float x, float other)
	{
		x = Mathf.Max(x, other);
	}

	private void Min(ref float x, float other)
	{
		if (other >= 0f)
		{
			x = Mathf.Min(x, other);
		}
	}

	private void Fade(ref BiomeFogMults x, BiomeFogMults a, BiomeFogMults b, float t)
	{
		Fade(ref x.AmbientIntensityMult, a.AmbientIntensityMult, b.AmbientIntensityMult, t);
		Fade(ref x.LightBoostMult, a.LightBoostMult, b.LightBoostMult, t);
		Fade(ref x.FogRampStartDist, a.FogRampStartDist, b.FogRampStartDist, t);
		Fade(ref x.FogRampEndDist, a.FogRampEndDist, b.FogRampEndDist, t);
	}

	private void Override(ref BiomeFogMults x, BiomeFogMults other)
	{
		Override(ref x.AmbientIntensityMult, other.AmbientIntensityMult);
		Override(ref x.LightBoostMult, other.LightBoostMult);
		Override(ref x.FogRampStartDist, other.FogRampStartDist);
		Override(ref x.FogRampEndDist, other.FogRampEndDist);
	}

	private void Max(ref BiomeFogMults x, BiomeFogMults other)
	{
		Max(ref x.AmbientIntensityMult, other.AmbientIntensityMult);
		Max(ref x.LightBoostMult, other.LightBoostMult);
		Max(ref x.FogRampStartDist, other.FogRampStartDist);
		Max(ref x.FogRampEndDist, other.FogRampEndDist);
	}

	private void Min(ref BiomeFogMults x, BiomeFogMults other)
	{
		Min(ref x.AmbientIntensityMult, other.AmbientIntensityMult);
		Min(ref x.LightBoostMult, other.LightBoostMult);
		Min(ref x.FogRampStartDist, other.FogRampStartDist);
		Min(ref x.FogRampEndDist, other.FogRampEndDist);
	}
}


using System;

[Serializable]
public struct BiomeFogMults
{
	public float AmbientIntensityMult;

	public float LightBoostMult;

	public float FogRampStartDist;

	public float FogRampEndDist;

	public void Reset()
	{
		AmbientIntensityMult = -1f;
		LightBoostMult = -1f;
		FogRampStartDist = -1f;
		FogRampEndDist = -1f;
	}

	public static BiomeFogMults Default()
	{
		BiomeFogMults result = default(BiomeFogMults);
		result.AmbientIntensityMult = 1f;
		result.LightBoostMult = 1f;
		result.FogRampStartDist = 0f;
		result.FogRampEndDist = 0.0001f;
		return result;
	}
}


using UnityEngine;

public class LegacyWeatherState
{
	private WeatherPreset preset;

	public float Wind
	{
		get
		{
			return preset.Wind;
		}
		set
		{
			preset.Wind = value;
		}
	}

	public float Rain
	{
		get
		{
			return preset.Rain;
		}
		set
		{
			preset.Rain = value;
		}
	}

	public float Clouds
	{
		get
		{
			return preset.Clouds.Coverage;
		}
		set
		{
			preset.Clouds.Opacity = Mathf.Sign(value);
			preset.Clouds.Coverage = value;
		}
	}

	public float Fog
	{
		get
		{
			return preset.Atmosphere.Fogginess;
		}
		set
		{
			preset.Atmosphere.Fogginess = value;
		}
	}

	public LegacyWeatherState(WeatherPreset preset)
	{
		this.preset = preset;
	}
}


public static class WordFilter
{
	public static string Filter(string str)
	{
		return str;
	}
}


public class WorldGrid : SingletonComponent<WorldGrid>, IClientComponent
{
	public static bool Paused;

	public float CellSize = 50f;

	public float MaxMilliseconds = 0.1f;

	public const float MaxRefreshDistance = 500f;

	public const float MinTimeBetweenRefreshes = 1f;
}


using UnityEngine;

public class WorldModel : MonoBehaviour
{
	public float mass = 1f;
}


using System;
using UnityEngine;

[Serializable]
public class PegConfig
{
	public enum PegType
	{
		Small,
		Large
	}

	public PegType Type;

	public Vector3 VerticalMountLocalRotation;

	public Vector3 VerticalMountLocalOffset;

	public void Init(PegType t, Vector3 localRot, Vector3 localOffset)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Type = t;
		VerticalMountLocalRotation = localRot;
		VerticalMountLocalOffset = localOffset;
	}
}


public enum PegType
{
	Small,
	Large
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class WorldModelRackMountConfig : MonoBehaviour
{
	[Serializable]
	public class CustomPosition
	{
		public WeaponRack.SpecialRackType RackType;

		public Vector3 CenterOffset;

		public Vector3 Rotation;
	}

	public List<WeaponRack.RackType> ExcludedRackTypes = new List<WeaponRack.RackType>();

	public Vector3 CenterOffsfet;

	public Vector3 LeftOffset;

	public Vector3 VerticalMountLocalRotation;

	public Vector3 VerticalMountLocalOffset;

	public int XSize = 3;

	public int YSize = 2;

	public int ZSize = 1;

	public List<PegConfig> Pegs = new List<PegConfig>();

	public List<PegConfig> VerticalPegs = new List<PegConfig>();

	public bool OverrideScale;

	public Vector3 Scale = Vector3.one;

	public bool UseManualRenderBounds;

	public Bounds ManualRenderBounds;

	public bool CanReloadOnWeaponRack = true;

	[Header("Special Rack Types")]
	public List<CustomPosition> CustomPositions = new List<CustomPosition>();

	public static WorldModelRackMountConfig GetForItemDef(ItemDefinition itemDef)
	{
		GameObjectRef worldModelPrefab = itemDef.worldModelPrefab;
		if (!worldModelPrefab.isValid)
		{
			return null;
		}
		return worldModelPrefab.Get().GetComponent<WorldModelRackMountConfig>();
	}

	public void ApplyTransformDefaults(Transform displayItem)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)displayItem == (Object)null))
		{
			if (OverrideScale)
			{
				displayItem.localScale = Scale;
			}
			displayItem.localPosition = VerticalMountLocalOffset;
			displayItem.localEulerAngles = VerticalMountLocalRotation;
		}
	}

	public CustomPosition FindCustomRackPosition(WeaponRack.SpecialRackType rackType)
	{
		if (CustomPositions == null)
		{
			return null;
		}
		foreach (CustomPosition customPosition in CustomPositions)
		{
			if (customPosition.RackType == rackType)
			{
				return customPosition;
			}
		}
		return null;
	}
}


using System;
using UnityEngine;

[Serializable]
public class CustomPosition
{
	public WeaponRack.SpecialRackType RackType;

	public Vector3 CenterOffset;

	public Vector3 Rotation;
}


using UnityEngine;

public class WorldModelRandomiser : MonoBehaviour
{
	public Wearable.PartRandomizer[] randomParts;
}


using UnityEngine;

public class WorldModelVisualConfig : MonoBehaviour, IClientComponent
{
	public FoodViewModel.FoodVisualConfig VisualConfig;

	public void Init(ItemDefinition itemDef)
	{
		if (VisualConfig != null && !((Object)(object)itemDef == (Object)null))
		{
			VisualConfig.InitForItemDef(itemDef);
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Gestures/Gesture Collection")]
public class GestureCollection : BaseScriptableObject
{
	public static uint HeavyLandingId = 3204230781u;

	private static GestureCollection _instance = null;

	public GestureConfig[] AllGestures;

	public float GestureVmInDuration = 0.25f;

	public AnimationCurve GestureInCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public float GestureVmOutDuration = 0.25f;

	public AnimationCurve GestureOutCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public float GestureViewmodelDeployDelay = 0.25f;

	public Sprite EmptyGestureSlotSprite;

	public Phrase EmptySlotTitle;

	public Phrase EmptySlotDescription;

	public static GestureCollection Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = FileSystem.Load<GestureCollection>("assets/prefabs/player/gestures/gesturecollection.asset", true);
			}
			return _instance;
		}
	}

	public GestureConfig IdToGesture(uint id)
	{
		GestureConfig[] allGestures = AllGestures;
		foreach (GestureConfig gestureConfig in allGestures)
		{
			if (gestureConfig.gestureId == id)
			{
				return gestureConfig;
			}
		}
		return null;
	}

	public GestureConfig StringToGesture(string gestureName)
	{
		if (string.IsNullOrEmpty(gestureName))
		{
			return null;
		}
		GestureConfig[] allGestures = AllGestures;
		foreach (GestureConfig gestureConfig in allGestures)
		{
			if (gestureConfig.convarName == gestureName)
			{
				return gestureConfig;
			}
		}
		return null;
	}
}


using ConVar;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Video;

[CreateAssetMenu(menuName = "Rust/Gestures/Gesture Config")]
public class GestureConfig : ScriptableObject
{
	public enum GestureType
	{
		Player,
		NPC,
		Cinematic
	}

	public enum PlayerModelLayer
	{
		UpperBody = 3,
		FullBody
	}

	public enum MovementCapabilities
	{
		FullMovement,
		NoMovement
	}

	public enum AnimationType
	{
		OneShot,
		Loop
	}

	public enum GestureActionType
	{
		None,
		ShowNameTag,
		DanceAchievement,
		Surrender,
		RockPaperScissors
	}

	[ReadOnly]
	public uint gestureId;

	public string gestureCommand;

	public string convarName;

	public Phrase gestureName;

	public Phrase gestureDescription;

	public Sprite icon;

	public AnimationType animationType;

	public float duration = 1.5f;

	public bool canCancel = true;

	public MovementCapabilities movementMode;

	public BasePlayer.CameraMode viewMode;

	public bool hideInWheel;

	public VideoClip previewClip;

	[Header("Player model setup")]
	public PlayerModelLayer playerModelLayer = PlayerModelLayer.UpperBody;

	public GestureType gestureType;

	public bool hideHeldEntity = true;

	public bool unequipHeldEntity;

	public bool canDuckDuringGesture;

	public bool hasViewmodelAnimation = true;

	public float viewmodelHolsterDelay;

	public bool useRootMotion;

	public bool forceForwardRotation;

	[Header("Interaction")]
	public bool hasMultiplayerInteraction;

	public Phrase joinPlayerPhrase = new Phrase("", "");

	public Phrase joinPlayerDescPhrase = new Phrase("", "");

	[Header("Ownership")]
	public GestureActionType actionType;

	public bool forceUnlock;

	public SteamDLCItem dlcItem;

	public SteamInventoryItem inventoryItem;

	public int GetItemId()
	{
		if ((Object)(object)dlcItem != (Object)null)
		{
			return dlcItem.dlcAppID;
		}
		if ((Object)(object)inventoryItem != (Object)null)
		{
			return inventoryItem.id;
		}
		return 0;
	}

	public Phrase GetSteamItemName()
	{
		if ((Object)(object)dlcItem != (Object)null)
		{
			return dlcItem.dlcName;
		}
		if ((Object)(object)inventoryItem != (Object)null)
		{
			return inventoryItem.displayName;
		}
		return null;
	}

	public bool IsOwnedBy(BasePlayer player, bool allowCinematic = false)
	{
		object obj = Interface.CallHook("CanUseGesture", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (forceUnlock)
		{
			return true;
		}
		if (gestureType == GestureType.NPC)
		{
			if ((Object)(object)player != (Object)null)
			{
				return player.IsNpc;
			}
			return false;
		}
		if (gestureType == GestureType.Cinematic)
		{
			if (!allowCinematic && (!((Object)(object)player != (Object)null) || !player.IsAdmin))
			{
				return Server.cinematic;
			}
			return true;
		}
		return IsUnlockedBy(player);
	}

	public bool IsUnlockedBy(BasePlayer player)
	{
		if (forceUnlock)
		{
			return true;
		}
		if ((Object)(object)dlcItem != (Object)null && (Object)(object)player != (Object)null)
		{
			return dlcItem.CanUse(player);
		}
		if ((Object)(object)inventoryItem != (Object)null && (Object)(object)player != (Object)null && player.blueprints.steamInventory.HasItem(inventoryItem.id))
		{
			return true;
		}
		return false;
	}

	public bool CanBeUsedBy(BasePlayer player)
	{
		if (player.isMounted)
		{
			if (playerModelLayer == PlayerModelLayer.FullBody)
			{
				return false;
			}
			if (player.GetMounted().allowedGestures == BaseMountable.MountGestureType.None)
			{
				return false;
			}
		}
		if (player.IsSwimming() && playerModelLayer == PlayerModelLayer.FullBody)
		{
			return false;
		}
		if (playerModelLayer == PlayerModelLayer.FullBody && player.modelState.ducked)
		{
			return false;
		}
		return true;
	}
}


public enum GestureType
{
	Player,
	NPC,
	Cinematic
}


public enum PlayerModelLayer
{
	UpperBody = 3,
	FullBody
}


public enum MovementCapabilities
{
	FullMovement,
	NoMovement
}


public enum AnimationType
{
	OneShot,
	Loop
}


public enum GestureActionType
{
	None,
	ShowNameTag,
	DanceAchievement,
	Surrender,
	RockPaperScissors
}


using Rust.UI;
using UnityEngine;

public class RockPaperScissorsDialog : SingletonComponent<RockPaperScissorsDialog>
{
	public RustText[] InputTexts;

	public RustSlider TimerBar;

	public GameObject ActiveRoot;

	public GameObject[] MadeSelection;
}


using System.Collections.Generic;
using UnityEngine;

public class OutlineManager : MonoBehaviour, IClientComponent
{
	public static Material blurMat;

	public List<OutlineObject> objectsToRender;

	public float blurAmount = 2f;

	public Material glowSolidMaterial;

	public Material blendGlowMaterial;
}


using UnityEngine;

public class OutlineObject : MonoBehaviour, IClientComponent
{
	public Mesh[] meshes;

	public Transform[] meshTransforms;
}


public class WorldModelOutline : OutlineObject
{
	public bool AlwaysRender;
}


using UnityEngine;

[ExecuteInEditMode]
public class LinearFog : MonoBehaviour
{
	public Material fogMaterial;

	public Color fogColor = Color.white;

	public float fogStart;

	public float fogRange = 1f;

	public float fogDensity = 1f;

	public bool fogSky;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)fogMaterial))
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		fogMaterial.SetColor("_FogColor", fogColor);
		fogMaterial.SetFloat("_Start", fogStart);
		fogMaterial.SetFloat("_Range", fogRange);
		fogMaterial.SetFloat("_Density", fogDensity);
		if (fogSky)
		{
			fogMaterial.SetFloat("_CutOff", 2f);
		}
		else
		{
			fogMaterial.SetFloat("_CutOff", 1f);
		}
		for (int i = 0; i < fogMaterial.passCount; i++)
		{
			Graphics.Blit((Texture)(object)source, destination, fogMaterial, i);
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class MaterialOverlay : MonoBehaviour
{
	public Material material;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (!Object.op_Implicit((Object)(object)material))
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		for (int i = 0; i < material.passCount; i++)
		{
			Graphics.Blit((Texture)(object)source, destination, material, i);
		}
	}
}


using UnityEngine;

[RequireComponent(typeof(Camera))]
[AddComponentMenu("Image Effects/Natural Bloom and Dirty Lens")]
[ExecuteInEditMode]
public class NaturalBloomAndDirtyLens : MonoBehaviour
{
	public Shader shader;

	public Texture2D lensDirtTexture;

	public float range = 10000f;

	public float cutoff = 1f;

	[Range(0f, 1f)]
	public float bloomIntensity = 0.05f;

	[Range(0f, 1f)]
	public float lensDirtIntensity = 0.05f;

	[Range(0f, 4f)]
	public float spread = 1f;

	[Range(0f, 4f)]
	public int iterations = 1;

	[Range(1f, 10f)]
	public int mips = 6;

	public float[] mipWeights = new float[6] { 0.5f, 0.6f, 0.6f, 0.45f, 0.35f, 0.23f };

	public bool highPrecision;

	public bool downscaleSource;

	public bool debug;

	public bool temporalFilter;

	[Range(0.01f, 1f)]
	public float temporalFilterWeight = 0.75f;
}


using UnityEngine;

public class ImageRenderController : SingletonComponent<ImageRenderController>
{
	public Camera Camera;
}


public enum BUTTON
{
	FORWARD = 2,
	BACKWARD = 4,
	LEFT = 8,
	RIGHT = 0x10,
	JUMP = 0x20,
	DUCK = 0x40,
	SPRINT = 0x80,
	USE = 0x100,
	FIRE_PRIMARY = 0x400,
	FIRE_SECONDARY = 0x800,
	RELOAD = 0x2000,
	FIRE_THIRD = 0x8000000
}


using UnityEngine;

public class InputState
{
	public InputMessage current = new InputMessage
	{
		ShouldPool = false
	};

	public InputMessage previous = new InputMessage
	{
		ShouldPool = false
	};

	private int SwallowedButtons;

	public bool IsDown(BUTTON btn)
	{
		if (current == null)
		{
			return false;
		}
		if (((uint)SwallowedButtons & (uint)btn) == (uint)btn)
		{
			return false;
		}
		return ((uint)current.buttons & (uint)btn) == (uint)btn;
	}

	public bool WasDown(BUTTON btn)
	{
		if (previous == null)
		{
			return false;
		}
		return ((uint)previous.buttons & (uint)btn) == (uint)btn;
	}

	public bool IsAnyDown()
	{
		if (current == null)
		{
			return false;
		}
		return (float)(current.buttons & ~SwallowedButtons) > 0f;
	}

	public bool WasJustPressed(BUTTON btn)
	{
		if (IsDown(btn))
		{
			return !WasDown(btn);
		}
		return false;
	}

	public bool WasJustReleased(BUTTON btn)
	{
		if (!IsDown(btn))
		{
			return WasDown(btn);
		}
		return false;
	}

	public void SwallowButton(BUTTON btn)
	{
		if (current != null)
		{
			SwallowedButtons |= (int)btn;
		}
	}

	public Quaternion AimAngle()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		if (current == null)
		{
			return Quaternion.identity;
		}
		return Quaternion.Euler(current.aimAngles);
	}

	public Vector3 MouseDelta()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		if (current == null)
		{
			return Vector3.zero;
		}
		return current.mouseDelta;
	}

	public void Flip(InputMessage newcurrent)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		SwallowedButtons = 0;
		previous.aimAngles = current.aimAngles;
		previous.buttons = current.buttons;
		previous.mouseDelta = current.mouseDelta;
		current.aimAngles = newcurrent.aimAngles;
		current.buttons = newcurrent.buttons;
		current.mouseDelta = newcurrent.mouseDelta;
	}

	public void Clear()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		current.buttons = 0;
		previous.buttons = 0;
		SetMouseDelta(Vector3.zero);
		SwallowedButtons = 0;
	}

	public void SetMouseDelta(Vector3 d)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		previous.mouseDelta = d;
		current.mouseDelta = d;
	}
}


using System.Collections.Generic;
using ProtoBuf;

public class ItemCraftTask
{
	public ItemBlueprint blueprint;

	public float endTime;

	public int taskUID;

	public bool cancelled;

	public InstanceData instanceData;

	public int amount = 1;

	public int skinID;

	public List<Item> takenItems;

	public int numCrafted;

	public float conditionScale = 1f;

	public BaseEntity workbenchEntity;
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class ItemCrafter : EntityComponent<BasePlayer>
{
	public List<ItemContainer> containers = new List<ItemContainer>();

	public LinkedList<ItemCraftTask> queue = new LinkedList<ItemCraftTask>();

	public int taskUID;

	[NonSerialized]
	public BasePlayer owner;

	public void AddContainer(ItemContainer container)
	{
		containers.Add(container);
	}

	public static float GetScaledDuration(ItemBlueprint bp, float workbenchLevel, bool isInTutorial)
	{
		float num = workbenchLevel - (float)bp.GetWorkbenchLevel();
		if (isInTutorial)
		{
			return bp.GetCraftTime() * 0.25f;
		}
		if (num == 1f)
		{
			return bp.GetCraftTime() * 0.5f;
		}
		if (num >= 2f)
		{
			return bp.GetCraftTime() * 0.25f;
		}
		return bp.GetCraftTime();
	}

	public void ServerUpdate(float delta)
	{
		if (queue.Count == 0)
		{
			return;
		}
		ItemCraftTask value = queue.First.Value;
		if (value.cancelled)
		{
			owner.Command("note.craft_done", value.taskUID, 0);
			queue.RemoveFirst();
			return;
		}
		float currentCraftLevel = owner.currentCraftLevel;
		if (value.endTime > Time.realtimeSinceStartup)
		{
			return;
		}
		if (value.endTime == 0f)
		{
			float scaledDuration = GetScaledDuration(value.blueprint, currentCraftLevel, owner.IsInTutorial);
			value.endTime = Time.realtimeSinceStartup + scaledDuration;
			value.workbenchEntity = owner.GetCachedCraftLevelWorkbench();
			if ((Object)(object)owner != (Object)null)
			{
				owner.Command("note.craft_start", value.taskUID, scaledDuration, value.amount);
				if (owner.IsAdmin && Craft.instant)
				{
					value.endTime = Time.realtimeSinceStartup + 1f;
				}
			}
		}
		else
		{
			FinishCrafting(value);
			if (value.amount <= 0)
			{
				queue.RemoveFirst();
			}
			else
			{
				value.endTime = 0f;
			}
		}
	}

	private void CollectIngredient(int item, int amount, List<Item> collect, bool takeBroken = true)
	{
		foreach (ItemContainer container in containers)
		{
			amount -= container.Take(collect, item, amount, takeBroken);
			if (amount <= 0)
			{
				break;
			}
		}
	}

	private void CollectIngredients(ItemBlueprint bp, ItemCraftTask task, int amount = 1, BasePlayer player = null, bool takeBroken = true)
	{
		if (Interface.CallHook("OnIngredientsCollect", (object)this, (object)bp, (object)task, (object)amount, (object)player, (object)takeBroken) != null)
		{
			return;
		}
		List<Item> list = new List<Item>();
		foreach (ItemAmount ingredient in bp.GetIngredients())
		{
			CollectIngredient(ingredient.itemid, (int)ingredient.amount * amount, list, takeBroken);
		}
		foreach (Item item in list)
		{
			item.CollectedForCrafting(player);
		}
		task.takenItems = list;
	}

	public bool CraftItem(ItemBlueprint bp, BasePlayer owner, InstanceData instanceData = null, int amount = 1, int skinID = 0, Item fromTempBlueprint = null, bool free = false)
	{
		if ((Object)(object)owner != (Object)null && (owner.IsTransferring() || owner.IsSleeping()))
		{
			return false;
		}
		if (!CanCraft(bp, amount, free))
		{
			return false;
		}
		taskUID++;
		ItemCraftTask itemCraftTask = Pool.Get<ItemCraftTask>();
		itemCraftTask.blueprint = bp;
		if (!free)
		{
			CollectIngredients(bp, itemCraftTask, amount, owner, takeBroken: false);
		}
		itemCraftTask.endTime = 0f;
		itemCraftTask.taskUID = taskUID;
		itemCraftTask.instanceData = instanceData;
		if (itemCraftTask.instanceData != null)
		{
			itemCraftTask.instanceData.ShouldPool = false;
		}
		itemCraftTask.amount = amount;
		itemCraftTask.skinID = skinID;
		if (fromTempBlueprint != null && itemCraftTask.takenItems != null)
		{
			fromTempBlueprint.RemoveFromContainer();
			itemCraftTask.takenItems.Add(fromTempBlueprint);
			itemCraftTask.conditionScale = 0.5f;
		}
		object obj = Interface.CallHook("OnItemCraft", (object)itemCraftTask, (object)owner, (object)fromTempBlueprint);
		if (obj is bool)
		{
			if (fromTempBlueprint != null && itemCraftTask.instanceData != null)
			{
				fromTempBlueprint.instanceData = itemCraftTask.instanceData;
			}
			return (bool)obj;
		}
		queue.AddLast(itemCraftTask);
		if ((Object)(object)owner != (Object)null)
		{
			owner.Command("note.craft_add", itemCraftTask.taskUID, itemCraftTask.blueprint.targetItem.itemid, amount, itemCraftTask.skinID);
		}
		return true;
	}

	public void FinishCrafting(ItemCraftTask task)
	{
		//IL_0370: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_037e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0384: Unknown result type (might be due to invalid IL or missing references)
		task.amount--;
		task.numCrafted++;
		ulong skin = ItemDefinition.FindSkin(task.blueprint.targetItem.itemid, task.skinID);
		Item item2 = ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, 1, skin);
		item2.amount = task.blueprint.amountToCreate;
		int amount = item2.amount;
		_ = owner.currentCraftLevel;
		bool inSafezone = owner.InSafeZone();
		if (item2.hasCondition && task.conditionScale != 1f)
		{
			item2.maxCondition *= task.conditionScale;
			item2.condition = item2.maxCondition;
		}
		item2.OnVirginSpawn(owner);
		item2.SetItemOwnership(owner, ItemOwnershipPhrases.CraftedPhrase);
		foreach (ItemAmount ingredient in task.blueprint.GetIngredients())
		{
			int num = (int)ingredient.amount;
			if (task.takenItems == null)
			{
				continue;
			}
			foreach (Item takenItem in task.takenItems)
			{
				if ((Object)(object)takenItem.info == (Object)(object)ingredient.itemDef)
				{
					int num2 = Mathf.Min(takenItem.amount, num);
					Analytics.Azure.OnCraftMaterialConsumed(takenItem.info.shortname, num, base.baseEntity, task.workbenchEntity, inSafezone, item2.info.shortname);
					takenItem.UseItem(num);
					num -= num2;
				}
				if (num <= 0)
				{
					break;
				}
			}
		}
		task.takenItems?.RemoveAll((Item item) => item.amount == 0);
		Analytics.Azure.OnCraftItem(item2.info.shortname, item2.amount, base.baseEntity, task.workbenchEntity, inSafezone);
		owner.Command("note.craft_done", task.taskUID, 1, task.amount);
		Interface.CallHook("OnItemCraftFinished", (object)task, (object)item2, (object)this);
		if (task.instanceData != null)
		{
			item2.instanceData = task.instanceData;
		}
		if (!string.IsNullOrEmpty(task.blueprint.UnlockAchievment))
		{
			owner.GiveAchievement(task.blueprint.UnlockAchievment);
		}
		owner.ProcessMissionEvent(BaseMission.MissionEventType.CRAFT_ITEM, item2.info.itemid, amount);
		if (owner.inventory.GiveItem(item2))
		{
			owner.Command("note.inv", item2.info.itemid, amount);
			return;
		}
		ItemContainer itemContainer = containers.First();
		owner.Command("note.inv", item2.info.itemid, amount);
		owner.Command("note.inv", item2.info.itemid, -item2.amount);
		item2.Drop(itemContainer.dropPosition, itemContainer.dropVelocity);
	}

	public bool CancelTask(int iID)
	{
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		if (queue.Count == 0)
		{
			return false;
		}
		if ((Object)(object)owner != (Object)null && owner.IsTransferring())
		{
			return false;
		}
		ItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) => x.taskUID == iID && !x.cancelled);
		if (itemCraftTask == null)
		{
			return false;
		}
		itemCraftTask.cancelled = true;
		if ((Object)(object)owner == (Object)null)
		{
			return true;
		}
		Interface.CallHook("OnItemCraftCancelled", (object)itemCraftTask, (object)this);
		owner.Command("note.craft_done", itemCraftTask.taskUID, 0);
		if (itemCraftTask.takenItems != null && itemCraftTask.takenItems.Count > 0)
		{
			foreach (Item takenItem in itemCraftTask.takenItems)
			{
				if (takenItem != null && takenItem.amount > 0)
				{
					if (takenItem.IsBlueprint() && (Object)(object)takenItem.blueprintTargetDef == (Object)(object)itemCraftTask.blueprint.targetItem)
					{
						takenItem.UseItem(itemCraftTask.numCrafted);
					}
					if (takenItem.amount > 0 && !takenItem.MoveToContainer(owner.inventory.containerMain))
					{
						takenItem.Drop(owner.inventory.containerMain.dropPosition + Random.value * Vector3.down + Random.insideUnitSphere, owner.inventory.containerMain.dropVelocity);
						owner.Command("note.inv", takenItem.info.itemid, -takenItem.amount);
					}
				}
			}
			itemCraftTask.takenItems.Clear();
		}
		return true;
	}

	public bool CancelBlueprint(int itemid)
	{
		if (queue.Count == 0)
		{
			return false;
		}
		if ((Object)(object)owner != (Object)null && owner.IsTransferring())
		{
			return false;
		}
		ItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) => x.blueprint.targetItem.itemid == itemid && !x.cancelled);
		if (itemCraftTask == null)
		{
			return false;
		}
		return CancelTask(itemCraftTask.taskUID);
	}

	public void CancelAll()
	{
		foreach (ItemCraftTask item in queue)
		{
			CancelTask(item.taskUID);
		}
	}

	private bool DoesHaveOKConditionItem(int item, int iAmount = 1)
	{
		int num = 0;
		foreach (ItemContainer container in containers)
		{
			num += container.GetOkConditionAmount(item, onlyUsableAmounts: true);
		}
		return num >= iAmount;
	}

	public bool DoesHaveUsableItem(int item, int iAmount)
	{
		int num = 0;
		foreach (ItemContainer container in containers)
		{
			num += container.GetAmount(item, onlyUsableAmounts: true);
		}
		return num >= iAmount;
	}

	public bool CanCraft(ItemBlueprint bp, int amount = 1, bool free = false)
	{
		if (!bp.targetItem.IsAllowed((EraRestriction)4))
		{
			return false;
		}
		if ((Object)(object)base.baseEntity != (Object)null && base.baseEntity.IsRestrained)
		{
			Handcuffs restraintItem = base.baseEntity.Belt.GetRestraintItem();
			if ((Object)(object)restraintItem != (Object)null && restraintItem.BlockCrafting)
			{
				return false;
			}
		}
		float num = (float)amount / (float)bp.targetItem.craftingStackable;
		foreach (ItemCraftTask item in queue)
		{
			if (!item.cancelled)
			{
				num += (float)item.amount / (float)item.blueprint.targetItem.craftingStackable;
			}
		}
		if (num > 8f)
		{
			return false;
		}
		object obj = Interface.CallHook("CanCraft", (object)this, (object)bp, (object)amount, (object)free);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (amount < 1 || amount > bp.targetItem.craftingStackable)
		{
			return false;
		}
		foreach (ItemAmount ingredient in bp.GetIngredients())
		{
			if (!DoesHaveUsableItem(ingredient.itemid, (int)ingredient.amount * amount))
			{
				return false;
			}
			if (ingredient.itemDef.condition.enabled && !DoesHaveOKConditionItem(ingredient.itemid, (int)ingredient.amount * amount))
			{
				return false;
			}
		}
		return true;
	}

	public bool CanCraft(ItemDefinition def, int amount = 1, bool free = false)
	{
		ItemBlueprint component = ((Component)def).GetComponent<ItemBlueprint>();
		if (CanCraft(component, amount, free))
		{
			return true;
		}
		return false;
	}

	public bool FastTrackTask(int taskID)
	{
		int taskID2 = taskID;
		if (queue.Count == 0)
		{
			return false;
		}
		if ((Object)(object)owner != (Object)null && owner.IsTransferring())
		{
			return false;
		}
		ItemCraftTask value = queue.First.Value;
		if (value == null)
		{
			return false;
		}
		ItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) => x.taskUID == taskID2 && !x.cancelled);
		if (itemCraftTask == null)
		{
			return false;
		}
		if (itemCraftTask == value)
		{
			return false;
		}
		object obj = Interface.CallHook("CanFastTrackCraftTask", (object)this, (object)itemCraftTask, (object)taskID);
		if (obj is bool)
		{
			return (bool)obj;
		}
		value.endTime = 0f;
		queue.Remove(itemCraftTask);
		queue.AddFirst(itemCraftTask);
		owner.Command("note.craft_fasttracked", taskID2);
		return true;
	}

	public ItemCrafter Save()
	{
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		ItemCrafter val = Pool.Get<ItemCrafter>();
		val.queue = Pool.Get<List<Task>>();
		foreach (ItemCraftTask item in queue)
		{
			Task val2 = Pool.Get<Task>();
			val2.itemID = item.blueprint.targetItem.itemid;
			val2.remainingTime = ((item.endTime > 0f) ? (item.endTime - Time.realtimeSinceStartup) : 0f);
			val2.taskUID = item.taskUID;
			val2.cancelled = item.cancelled;
			InstanceData instanceData = item.instanceData;
			val2.instanceData = ((instanceData != null) ? instanceData.Copy() : null);
			val2.amount = item.amount;
			val2.skinID = item.skinID;
			val2.takenItems = SaveItems(item.takenItems);
			val2.numCrafted = item.numCrafted;
			val2.conditionScale = item.conditionScale;
			val2.workbenchEntity = (NetworkableId)(item.workbenchEntity.IsValid() ? item.workbenchEntity.net.ID : default(NetworkableId));
			val.queue.Add(val2);
		}
		return val;
		static List<Item> SaveItems(List<Item> items)
		{
			List<Item> list = Pool.Get<List<Item>>();
			if (items != null)
			{
				foreach (Item item2 in items)
				{
					list.Add(item2.Save(bIncludeContainer: true));
				}
			}
			return list;
		}
	}

	public void Load(ItemCrafter proto)
	{
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		if (proto?.queue == null)
		{
			return;
		}
		queue.Clear();
		ItemBlueprint blueprint = default(ItemBlueprint);
		foreach (Task item in proto.queue)
		{
			ItemDefinition itemDefinition = ItemManager.FindItemDefinition(item.itemID);
			if ((Object)(object)itemDefinition == (Object)null || !((Component)itemDefinition).TryGetComponent<ItemBlueprint>(ref blueprint))
			{
				Debug.LogWarning((object)$"ItemCrafter has queue task for item ID {item.itemID}, but it was not found or has no blueprint. Skipping it");
				continue;
			}
			ItemCraftTask itemCraftTask = Pool.Get<ItemCraftTask>();
			itemCraftTask.blueprint = blueprint;
			itemCraftTask.endTime = ((item.remainingTime > 0f) ? (Time.realtimeSinceStartup + item.remainingTime) : 0f);
			itemCraftTask.taskUID = item.taskUID;
			itemCraftTask.cancelled = item.cancelled;
			InstanceData instanceData = item.instanceData;
			itemCraftTask.instanceData = ((instanceData != null) ? instanceData.Copy() : null);
			itemCraftTask.amount = item.amount;
			itemCraftTask.skinID = item.skinID;
			itemCraftTask.takenItems = LoadItems(item.takenItems);
			itemCraftTask.numCrafted = item.numCrafted;
			itemCraftTask.conditionScale = item.conditionScale;
			itemCraftTask.workbenchEntity = new EntityRef<BaseEntity>
			{
				uid = item.workbenchEntity
			}.Get(serverside: true);
			queue.AddLast(itemCraftTask);
			taskUID = Mathf.Max(taskUID, itemCraftTask.taskUID);
		}
		static List<Item> LoadItems(List<Item> itemProtos)
		{
			List<Item> list = new List<Item>();
			if (itemProtos != null)
			{
				foreach (Item itemProto in itemProtos)
				{
					list.Add(ItemManager.Load(itemProto, null, isServer: true));
				}
			}
			return list;
		}
	}

	public void SendToOwner()
	{
		if (!owner.IsValid() || !owner.IsConnected)
		{
			return;
		}
		foreach (ItemCraftTask item in queue)
		{
			owner.Command("note.craft_add", item.taskUID, item.blueprint.targetItem.itemid, item.amount, item.skinID);
		}
	}
}


using UnityEngine;
using UnityEngine.Events;

public class ItemEventFlag : MonoBehaviour, IItemUpdate
{
	public Item.Flag flag;

	public UnityEvent onEnabled = new UnityEvent();

	public UnityEvent onDisable = new UnityEvent();

	internal bool firstRun = true;

	internal bool lastState;

	public virtual void OnItemUpdate(Item item)
	{
		bool flag = item.HasFlag(this.flag);
		if (firstRun || flag != lastState)
		{
			if (flag)
			{
				onEnabled.Invoke();
			}
			else
			{
				onDisable.Invoke();
			}
			lastState = flag;
			firstRun = false;
		}
	}
}


using System.Collections.Generic;
using Rust;

public interface IAmmoContainer
{
	Item FindAmmo(AmmoTypes ammoType);

	void FindAmmo(List<Item> list, AmmoTypes ammoType);

	Item FindItemByItemID(int id);

	void FindItemsByItemID(List<Item> list, int id);

	Item FindItemByItemName(string name);

	bool HasAmmo(AmmoTypes ammoType);

	Item FindItemByUID(ItemId iUID);

	bool GiveItem(Item item, ItemContainer container = null);
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class Item : IPooled
{
	[Flags]
	public enum Flag
	{
		None = 0,
		Placeholder = 1,
		IsOn = 2,
		OnFire = 4,
		IsLocked = 8,
		Cooking = 0x10,
		Radioactive = 0x20,
		Refrigerated = 0x40
	}

	private const string DefaultArmourBreakEffectPath = "assets/bundled/prefabs/fx/armor_break.prefab";

	public float _condition;

	public float _maxCondition = 100f;

	public ItemDefinition info;

	public ItemId uid;

	public bool dirty;

	public int amount = 1;

	public int position;

	public float busyTime;

	public float removeTime;

	public float fuel;

	public bool isServer;

	public InstanceData instanceData;

	public ulong skin;

	public string name;

	public string streamerName;

	public string text;

	public float cookTimeLeft;

	public float radioactivity;

	public List<ItemOwnershipShare> ownershipShares;

	public uint iconImageId;

	public Flag flags;

	public ItemContainer contents;

	public ItemContainer parent;

	private EntityRef worldEnt;

	private EntityRef heldEntity;

	public float condition
	{
		get
		{
			return _condition;
		}
		set
		{
			float num = _condition;
			_condition = Mathf.Clamp(value, 0f, maxCondition);
			if (isServer && Mathf.Ceil(value) != Mathf.Ceil(num))
			{
				MarkDirty();
			}
		}
	}

	public float maxCondition
	{
		get
		{
			return _maxCondition;
		}
		set
		{
			_maxCondition = Mathf.Clamp(value, 0f, info.condition.max);
			if (isServer)
			{
				MarkDirty();
			}
		}
	}

	public float maxConditionNormalized => _maxCondition / info.condition.max;

	public float conditionNormalized
	{
		get
		{
			if (!hasCondition)
			{
				return 1f;
			}
			return condition / maxCondition;
		}
		set
		{
			if (hasCondition)
			{
				condition = value * maxCondition;
			}
		}
	}

	public bool hasCondition
	{
		get
		{
			if ((Object)(object)info != (Object)null && info.condition.enabled)
			{
				return info.condition.max > 0f;
			}
			return false;
		}
	}

	public bool isBroken
	{
		get
		{
			if (hasCondition)
			{
				return condition <= 0f;
			}
			return false;
		}
	}

	public int despawnMultiplier
	{
		get
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Expected I4, but got Unknown
			Rarity val = info.despawnRarity;
			if ((int)val == 0)
			{
				val = info.rarity;
			}
			if (!((Object)(object)info != (Object)null))
			{
				return 1;
			}
			return Mathf.Clamp((val - 1) * 4, 1, 100);
		}
	}

	public ItemDefinition blueprintTargetDef
	{
		get
		{
			if (!IsBlueprint())
			{
				return null;
			}
			return ItemManager.FindItemDefinition(blueprintTarget);
		}
	}

	public int blueprintTarget
	{
		get
		{
			if (instanceData == null)
			{
				return 0;
			}
			return instanceData.blueprintTarget;
		}
		set
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Expected O, but got Unknown
			if (instanceData == null)
			{
				instanceData = new InstanceData();
			}
			instanceData.ShouldPool = false;
			instanceData.blueprintTarget = value;
		}
	}

	public int blueprintAmount
	{
		get
		{
			return amount;
		}
		set
		{
			amount = value;
		}
	}

	public Item parentItem
	{
		get
		{
			if (parent == null)
			{
				return null;
			}
			return parent.parent;
		}
	}

	public float temperature
	{
		get
		{
			if (parent != null)
			{
				return parent.GetTemperature(position);
			}
			return 15f;
		}
	}

	public BaseEntity.TraitFlag Traits => info.Traits;

	public event Action<Item> OnDirty;

	public event Action<Item, float> onCycle;

	public void LoseCondition(float amount)
	{
		if (hasCondition && !Debugging.disablecondition && Interface.CallHook("IOnLoseCondition", (object)this, (object)amount) == null)
		{
			float num = condition;
			condition -= amount;
			if (Global.developer > 0)
			{
				Debug.Log((object)(info.shortname + " was damaged by: " + amount + "cond is: " + condition + "/" + maxCondition));
			}
			if (condition <= 0f && condition < num)
			{
				OnBroken();
			}
		}
	}

	public void RepairCondition(float amount)
	{
		if (hasCondition)
		{
			condition += amount;
		}
	}

	public void DoRepair(float maxLossFraction)
	{
		if (hasCondition)
		{
			if (info.condition.maintainMaxCondition)
			{
				maxLossFraction = 0f;
			}
			float num = 1f - condition / maxCondition;
			maxLossFraction = Mathf.Clamp(maxLossFraction, 0f, info.condition.max);
			maxCondition *= 1f - maxLossFraction * num;
			condition = maxCondition;
			BaseEntity baseEntity = GetHeldEntity();
			if ((Object)(object)baseEntity != (Object)null)
			{
				baseEntity.SetFlag(BaseEntity.Flags.Broken, b: false);
			}
			if (Global.developer > 0)
			{
				Debug.Log((object)(info.shortname + " was repaired! new cond is: " + condition + "/" + maxCondition));
			}
		}
	}

	public ItemContainer GetRootContainer()
	{
		ItemContainer itemContainer = parent;
		int num = 0;
		while (itemContainer != null && num <= 8 && itemContainer.parent != null && itemContainer.parent.parent != null)
		{
			itemContainer = itemContainer.parent.parent;
			num++;
		}
		if (num == 8)
		{
			Debug.LogWarning((object)"GetRootContainer failed with 8 iterations");
		}
		return itemContainer;
	}

	public virtual void OnBroken()
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		if (!hasCondition)
		{
			return;
		}
		BaseEntity baseEntity = GetHeldEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			baseEntity.SetFlag(BaseEntity.Flags.Broken, b: true);
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (Object.op_Implicit((Object)(object)ownerPlayer))
		{
			if (ownerPlayer.GetActiveItem() == this)
			{
				Effect.server.Run("assets/bundled/prefabs/fx/item_break.prefab", ownerPlayer, 0u, Vector3.zero, Vector3.zero);
				ownerPlayer.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ActiveItemBroken, false);
			}
			ItemModWearable itemModWearable = default(ItemModWearable);
			if (((Component)info).TryGetComponent<ItemModWearable>(ref itemModWearable) && ownerPlayer.inventory.containerWear.itemList.Contains(this))
			{
				if (itemModWearable.breakEffect.isValid)
				{
					Effect.server.Run(itemModWearable.breakEffect.resourcePath, ownerPlayer, 0u, Vector3.zero, Vector3.zero);
				}
				else
				{
					Effect.server.Run("assets/bundled/prefabs/fx/armor_break.prefab", ownerPlayer, 0u, Vector3.zero, Vector3.zero);
				}
			}
		}
		if (info.condition.breakEffect != null && info.condition.breakEffect.isValid)
		{
			BasePlayer playerOwner = GetRootContainer().playerOwner;
			if ((Object)(object)playerOwner != (Object)null)
			{
				Effect.server.Run(info.condition.breakEffect.resourcePath, playerOwner, 0u, Vector3.zero, Vector3.zero);
			}
		}
		if ((!info.condition.repairable && !Object.op_Implicit((Object)(object)((Component)info).GetComponent<ItemModRepair>())) || maxCondition <= 5f)
		{
			UnloadAmmo();
			Remove();
		}
		else if (parent != null && parent.HasFlag(ItemContainer.Flag.NoBrokenItems))
		{
			ItemContainer rootContainer = GetRootContainer();
			if (rootContainer.HasFlag(ItemContainer.Flag.NoBrokenItems))
			{
				Remove();
			}
			else
			{
				BasePlayer playerOwner2 = rootContainer.playerOwner;
				if ((Object)(object)playerOwner2 != (Object)null && !MoveToContainer(playerOwner2.inventory.containerMain))
				{
					Drop(((Component)playerOwner2).transform.position, playerOwner2.eyes.BodyForward() * 1.5f);
				}
			}
		}
		ItemModEntity itemModEntity = default(ItemModEntity);
		if (((Component)info).TryGetComponent<ItemModEntity>(ref itemModEntity) && itemModEntity.destroyEntityWhenBroken)
		{
			baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);
		}
		MarkDirty();
	}

	void IPooled.EnterPool()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		info = null;
		uid = default(ItemId);
		dirty = false;
		amount = 1;
		position = 0;
		busyTime = 0f;
		removeTime = 0f;
		fuel = 0f;
		isServer = false;
		instanceData = null;
		skin = 0uL;
		name = null;
		streamerName = null;
		text = null;
		cookTimeLeft = 0f;
		radioactivity = 0f;
		flags = Flag.None;
		if (contents != null)
		{
			Pool.Free<ItemContainer>(ref contents);
		}
		parent = null;
		heldEntity = default(EntityRef);
		worldEnt = default(EntityRef);
		this.onCycle = null;
		this.OnDirty = null;
		_condition = 0f;
		_maxCondition = 100f;
		ownershipShares = null;
	}

	void IPooled.LeavePool()
	{
	}

	public string GetName(bool? streamerModeOverride = null)
	{
		if (streamerModeOverride.HasValue)
		{
			if (!streamerModeOverride.Value)
			{
				return name;
			}
			return streamerName ?? name;
		}
		return name;
	}

	public bool IsBlueprint()
	{
		return blueprintTarget != 0;
	}

	public bool HasFlag(Flag f)
	{
		return (flags & f) == f;
	}

	public void SetFlag(Flag f, bool b)
	{
		if (b)
		{
			flags |= f;
		}
		else
		{
			flags &= ~f;
		}
	}

	public bool IsOn()
	{
		return HasFlag(Flag.IsOn);
	}

	public bool IsOnFire()
	{
		return HasFlag(Flag.OnFire);
	}

	public bool IsCooking()
	{
		return HasFlag(Flag.Cooking);
	}

	public bool IsLocked()
	{
		if (!HasFlag(Flag.IsLocked))
		{
			if (parent != null)
			{
				return parent.IsLocked();
			}
			return false;
		}
		return true;
	}

	public bool IsRadioactive()
	{
		return HasFlag(Flag.Radioactive);
	}

	public bool IsRefrigerated()
	{
		return HasFlag(Flag.Refrigerated);
	}

	public void MarkDirty()
	{
		OnChanged();
		dirty = true;
		if (parent != null)
		{
			parent.MarkDirty();
		}
		if (this.OnDirty != null)
		{
			this.OnDirty(this);
		}
	}

	public void OnChanged()
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].OnChanged(this);
		}
		if (contents != null)
		{
			contents.OnChanged();
		}
	}

	public void CollectedForCrafting(BasePlayer crafter)
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].CollectedForCrafting(this, crafter);
		}
	}

	public void ReturnedFromCancelledCraft(BasePlayer crafter)
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].ReturnedFromCancelledCraft(this, crafter);
		}
	}

	public void Initialize(ItemDefinition template)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		uid = new ItemId(Net.sv.TakeUID());
		float num = (maxCondition = info.condition.max);
		condition = num;
		SetRadioactivity(template);
		InitializeItemOwnership();
		OnItemCreated();
	}

	public void OnItemCreated()
	{
		this.onCycle = null;
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].OnItemCreated(this);
		}
	}

	public void OnVirginSpawn(BasePlayer creatingPlayer = null)
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].OnVirginItem(this, creatingPlayer);
		}
	}

	public float GetDespawnDuration()
	{
		if (info.quickDespawn)
		{
			return ConVar.Server.itemdespawn_quick;
		}
		int num = 0;
		if (contents != null && contents.itemList != null)
		{
			foreach (Item item in contents.itemList)
			{
				num += item.despawnMultiplier;
			}
		}
		return (float)Mathf.Min(Mathf.Max(despawnMultiplier, num), ConVar.Server.itemdespawn_container_max_multiplier) * ConVar.Server.itemdespawn;
	}

	public void RemoveFromWorld()
	{
		BaseEntity worldEntity = GetWorldEntity();
		if ((Object)(object)worldEntity == (Object)null)
		{
			return;
		}
		SetWorldEntity(null);
		OnRemovedFromWorld();
		if (contents != null)
		{
			contents.OnRemovedFromWorld();
		}
		if (worldEntity.IsValid())
		{
			if (worldEntity is WorldItem worldItem)
			{
				worldItem.RemoveItem();
			}
			worldEntity.Kill();
		}
	}

	public void OnRemovedFromWorld()
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].OnRemovedFromWorld(this);
		}
	}

	public void RemoveFromContainer()
	{
		if (parent != null)
		{
			SetParent(null);
		}
	}

	public bool DoItemSlotsConflict(Item other)
	{
		return (info.occupySlots & other.info.occupySlots) != 0;
	}

	public void AddItemOwnership(string username, string reason, int shareAmount)
	{
		if (ownershipShares == null)
		{
			return;
		}
		if (ownershipShares.Count > 0)
		{
			for (int i = 0; i < ownershipShares.Count; i++)
			{
				ItemOwnershipShare value = ownershipShares[i];
				if (value.username == username && value.reason == reason)
				{
					value.amount += shareAmount;
					ownershipShares[i] = value;
					shareAmount = 0;
					break;
				}
			}
		}
		if (shareAmount > 0)
		{
			ItemOwnershipShare itemOwnershipShare = default(ItemOwnershipShare);
			itemOwnershipShare.username = username;
			itemOwnershipShare.reason = reason;
			itemOwnershipShare.amount = shareAmount;
			ItemOwnershipShare item = itemOwnershipShare;
			ownershipShares.Add(item);
		}
		MarkDirty();
	}

	public void MigrateItemOwnership(Item targetItem, int amount)
	{
		if (ownershipShares != null && targetItem.ownershipShares != null)
		{
			TransferOwnership(targetItem, amount);
		}
	}

	public ItemOwnershipShare TakeOwnershipShare()
	{
		if (!HasItemOwnership())
		{
			return default(ItemOwnershipShare);
		}
		ItemOwnershipShare itemOwnershipShare = ownershipShares[0];
		itemOwnershipShare.amount--;
		ownershipShares[0] = itemOwnershipShare;
		if (itemOwnershipShare.amount <= 0)
		{
			ownershipShares.RemoveAt(0);
		}
		return itemOwnershipShare;
	}

	public void ReduceItemOwnership(int amount)
	{
		if (ownershipShares != null)
		{
			TransferOwnership(null, amount);
		}
	}

	private void TransferOwnership(Item targetItem, int amount)
	{
		for (int num = ownershipShares.Count - 1; num >= 0; num--)
		{
			if (amount <= 0)
			{
				return;
			}
			ItemOwnershipShare value = ownershipShares[num];
			int num2 = Mathf.Min(value.amount, amount);
			targetItem?.AddItemOwnership(value.username, value.reason, num2);
			amount -= num2;
			value.amount -= num2;
			if (value.amount == 0)
			{
				ownershipShares.RemoveAt(num);
			}
			else
			{
				ownershipShares[num] = value;
			}
		}
		MarkDirty();
	}

	public bool HasItemOwnership()
	{
		if (ownershipShares != null)
		{
			return ownershipShares.Count > 0;
		}
		return false;
	}

	public void AddItemOwnership(BasePlayer player, Phrase reason)
	{
		AddItemOwnership(((Object)(object)player != (Object)null && !player.IsDestroyed) ? player.displayName : "", reason.token, amount);
	}

	public Item SetItemOwnership(BasePlayer player, Phrase reason)
	{
		return SetItemOwnership(((Object)(object)player != (Object)null && !player.IsDestroyed) ? player.displayName : "", reason.token);
	}

	public Item SetItemOwnership(ItemOwnershipShare ownership)
	{
		return SetItemOwnership(ownership.username, ownership.reason);
	}

	public Item SetItemOwnership(BasePlayer player, string reason)
	{
		return SetItemOwnership(((Object)(object)player != (Object)null && !player.IsDestroyed) ? player.displayName : "", reason);
	}

	public Item SetItemOwnership(string username, Phrase reason)
	{
		return SetItemOwnership(username, reason?.token ?? "");
	}

	public Item SetItemOwnership(string username, string reason)
	{
		if (ownershipShares == null)
		{
			return this;
		}
		ownershipShares?.Clear();
		AddItemOwnership(username, reason, amount);
		return this;
	}

	public void InitializeItemOwnership()
	{
		if (!((Object)(object)info == (Object)null) && info.SupportsItemOwnership() && ownershipShares == null)
		{
			ownershipShares = Pool.Get<List<ItemOwnershipShare>>();
		}
	}

	public void SetParent(ItemContainer target)
	{
		if (target == parent)
		{
			return;
		}
		if (parent != null)
		{
			parent.Remove(this);
			parent = null;
		}
		if (target == null)
		{
			position = 0;
		}
		else
		{
			parent = target;
			if (!parent.Insert(this))
			{
				Remove();
				Debug.LogError((object)"Item.SetParent caused remove - this shouldn't ever happen");
			}
		}
		MarkDirty();
		RecalulateParentEntity(children: false);
		if (parent != null)
		{
			ItemContainer itemContainer = parent;
			BasePlayer basePlayer = null;
			do
			{
				basePlayer = itemContainer.GetOwnerPlayer();
				itemContainer = itemContainer?.parent?.parent;
			}
			while (itemContainer != null && (Object)(object)basePlayer == (Object)null);
			if ((Object)(object)basePlayer != (Object)null)
			{
				if (!basePlayer.enableSaving)
				{
					ForbidHeldEntitySaving();
				}
				else
				{
					RestoreHeldEntitySaving();
				}
			}
		}
		else
		{
			RestoreHeldEntitySaving();
		}
	}

	public void RecalulateParentEntity(bool children)
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].OnParentChanged(this);
		}
		if (!children || contents == null)
		{
			return;
		}
		foreach (Item item in contents.itemList)
		{
			item.RecalulateParentEntity(children: false);
		}
	}

	private void ForbidHeldEntitySaving()
	{
		if (heldEntity.IsValid(serverside: true))
		{
			heldEntity.Get(serverside: true).EnableSaving(wants: false);
		}
		if (contents == null)
		{
			return;
		}
		foreach (Item item in contents.itemList)
		{
			item.ForbidHeldEntitySaving();
		}
	}

	private void RestoreHeldEntitySaving()
	{
		if (heldEntity.IsValid(serverside: true))
		{
			heldEntity.Get(serverside: true).RestoreCanSave();
		}
		if (contents == null)
		{
			return;
		}
		foreach (Item item in contents.itemList)
		{
			item.RestoreHeldEntitySaving();
		}
	}

	public void OnAttacked(HitInfo hitInfo)
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].OnAttacked(this, hitInfo);
		}
	}

	public BaseEntity GetEntityOwner()
	{
		return parent?.GetEntityOwner();
	}

	public bool IsChildContainer(ItemContainer c)
	{
		if (contents == null)
		{
			return false;
		}
		if (contents == c)
		{
			return true;
		}
		foreach (Item item in contents.itemList)
		{
			if (item.IsChildContainer(c))
			{
				return true;
			}
		}
		return false;
	}

	public bool CanMoveTo(ItemContainer newcontainer, int iTargetPos = -1)
	{
		if (IsChildContainer(newcontainer))
		{
			return false;
		}
		if (newcontainer.CanAcceptItem(this, iTargetPos) != 0)
		{
			return false;
		}
		if (iTargetPos >= newcontainer.capacity)
		{
			return false;
		}
		if (parent != null && newcontainer == parent && iTargetPos == position)
		{
			return false;
		}
		return true;
	}

	public bool MoveToContainer(ItemContainer newcontainer, int iTargetPos = -1, bool allowStack = true, bool ignoreStackLimit = false, BasePlayer sourcePlayer = null, bool allowSwap = true)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0584: Unknown result type (might be due to invalid IL or missing references)
		//IL_058a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0591: Unknown result type (might be due to invalid IL or missing references)
		//IL_0597: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("MoveToContainer", 0);
		try
		{
			BasePlayer playerOwner = newcontainer.playerOwner;
			if ((Object)(object)playerOwner != (Object)null && playerOwner.IsDead() && parent != null)
			{
				return false;
			}
			bool flag = iTargetPos == -1;
			ItemContainer itemContainer = parent;
			if (iTargetPos == -1)
			{
				if (allowStack && info.stackable > 1)
				{
					BufferList<Item> val2 = Pool.Get<BufferList<Item>>();
					newcontainer.FindItemsByItemID(info.itemid, val2);
					Enumerator<Item> enumerator = val2.GetEnumerator();
					try
					{
						while (enumerator.MoveNext())
						{
							Item current = enumerator.Current;
							if (current.position > iTargetPos && current.CanStack(this) && (ignoreStackLimit || current.amount < current.MaxStackable()))
							{
								iTargetPos = current.position;
							}
						}
					}
					finally
					{
						((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
					}
					Pool.Free<Item>(ref val2, false);
				}
				if (iTargetPos == -1 && newcontainer.GetEntityOwner(returnHeldEntity: true) is IIdealSlotEntity idealSlotEntity)
				{
					iTargetPos = idealSlotEntity.GetIdealSlot(sourcePlayer, newcontainer, this);
					if (iTargetPos == int.MinValue)
					{
						return false;
					}
				}
				if (iTargetPos == -1)
				{
					if (newcontainer == parent)
					{
						return false;
					}
					bool flag2 = newcontainer.HasFlag(ItemContainer.Flag.Clothing) && info.isWearable;
					ItemModWearable itemModWearable = info.ItemModWearable;
					for (int i = 0; i < newcontainer.capacity; i++)
					{
						Item slot = newcontainer.GetSlot(i);
						if (slot == null)
						{
							if (CanMoveTo(newcontainer, i))
							{
								iTargetPos = i;
								break;
							}
							continue;
						}
						if (flag2 && slot != null && !slot.info.ItemModWearable.CanExistWith(itemModWearable))
						{
							iTargetPos = i;
							break;
						}
						if (newcontainer.HasAvailableSlotsDefined && DoItemSlotsConflict(slot))
						{
							iTargetPos = i;
							break;
						}
					}
					if (flag2 && iTargetPos == -1)
					{
						iTargetPos = newcontainer.capacity - 1;
					}
				}
			}
			if (iTargetPos == -1)
			{
				return false;
			}
			if (!CanMoveTo(newcontainer, iTargetPos))
			{
				return false;
			}
			if (iTargetPos >= 0 && newcontainer.SlotTaken(this, iTargetPos))
			{
				Item slot2 = newcontainer.GetSlot(iTargetPos);
				if (slot2 == this)
				{
					return false;
				}
				if (allowStack && slot2 != null)
				{
					int num = slot2.MaxStackable();
					if (slot2.CanStack(this))
					{
						if (ignoreStackLimit)
						{
							num = int.MaxValue;
						}
						if (slot2.amount >= num)
						{
							return false;
						}
						int num2 = Mathf.Min(num - slot2.amount, amount);
						slot2.amount += num2;
						if (slot2.instanceData != null && instanceData != null && Object.op_Implicit((Object)(object)((Component)info).GetComponent<ItemModFoodSpoiling>()))
						{
							slot2.instanceData.dataFloat = Mathf.Min(slot2.instanceData.dataFloat, instanceData.dataFloat);
						}
						newcontainer.onItemAddedToStack?.Invoke(slot2, num2);
						amount -= num2;
						slot2.MarkDirty();
						Interface.CallHook("OnItemStacked", (object)slot2, (object)this, (object)newcontainer, (object)num2);
						MarkDirty();
						MigrateItemOwnership(slot2, num2);
						if (amount <= 0)
						{
							RemoveFromWorld();
							RemoveFromContainer();
							Remove();
							return true;
						}
						if (flag)
						{
							return MoveToContainer(newcontainer, -1, allowStack, ignoreStackLimit, sourcePlayer);
						}
						return false;
					}
				}
				if (parent != null && allowSwap && slot2 != null)
				{
					ItemContainer itemContainer2 = parent;
					int iTargetPos2 = position;
					ItemContainer newcontainer2 = slot2.parent;
					int num3 = slot2.position;
					if (!slot2.CanMoveTo(itemContainer2, iTargetPos2))
					{
						return false;
					}
					if (itemContainer2.maxStackSize > 0 && slot2.amount > itemContainer2.maxStackSize)
					{
						Item item = slot2.SplitItem(slot2.amount - itemContainer2.maxStackSize);
						if (item == null || !item.MoveToContainer(newcontainer2, -1, allowStack: false, ignoreStackLimit: false, sourcePlayer, allowSwap: false))
						{
							slot2.amount += item.amount;
							item.MigrateItemOwnership(slot2, item.amount);
							item.Remove();
							return false;
						}
					}
					BaseEntity entityOwner = GetEntityOwner();
					BaseEntity entityOwner2 = slot2.GetEntityOwner();
					RemoveFromContainer();
					slot2.RemoveFromContainer();
					RemoveConflictingSlots(newcontainer, entityOwner, sourcePlayer);
					slot2.RemoveConflictingSlots(itemContainer2, entityOwner2, sourcePlayer);
					if (!slot2.MoveToContainer(itemContainer2, iTargetPos2, allowStack: true, ignoreStackLimit: false, sourcePlayer) || !MoveToContainer(newcontainer, iTargetPos, allowStack: true, ignoreStackLimit: false, sourcePlayer))
					{
						RemoveFromContainer();
						slot2.RemoveFromContainer();
						SetParent(itemContainer2);
						position = iTargetPos2;
						slot2.SetParent(newcontainer2);
						slot2.position = num3;
						return true;
					}
					return true;
				}
				return false;
			}
			if (parent == newcontainer)
			{
				if (iTargetPos >= 0 && iTargetPos != position && !parent.SlotTaken(this, iTargetPos))
				{
					newcontainer.onItemPositionChanged?.Invoke(this, position, iTargetPos);
					position = iTargetPos;
					MarkDirty();
					return true;
				}
				return false;
			}
			if (newcontainer.maxStackSize > 0 && newcontainer.maxStackSize < amount)
			{
				Item item2 = SplitItem(newcontainer.maxStackSize);
				if (item2 != null && !item2.MoveToContainer(newcontainer, iTargetPos, allowStack: false, ignoreStackLimit: false, sourcePlayer) && (itemContainer == null || !item2.MoveToContainer(itemContainer, -1, allowStack: true, ignoreStackLimit: false, sourcePlayer)))
				{
					DroppedItem droppedItem = item2.Drop(newcontainer.dropPosition, newcontainer.dropVelocity) as DroppedItem;
					if ((Object)(object)droppedItem != (Object)null)
					{
						droppedItem.DroppedBy = sourcePlayer?.userID ?? ((EncryptedValue<ulong>)0uL);
					}
				}
				Interface.CallHook("OnItemStacked", (object)item2, (object)this, (object)newcontainer);
				return true;
			}
			if (!newcontainer.CanAccept(this))
			{
				return false;
			}
			BaseEntity entityOwner3 = GetEntityOwner();
			RemoveFromContainer();
			RemoveFromWorld();
			RemoveConflictingSlots(newcontainer, entityOwner3, sourcePlayer);
			position = iTargetPos;
			SetParent(newcontainer);
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void RemoveConflictingSlots(ItemContainer container, BaseEntity entityOwner, BasePlayer sourcePlayer)
	{
		if (!isServer || !container.HasAvailableSlotsDefined)
		{
			return;
		}
		List<Item> list = Pool.Get<List<Item>>();
		list.AddRange(container.itemList);
		foreach (Item item in list)
		{
			if (item.DoItemSlotsConflict(this))
			{
				item.RemoveFromContainer();
				if (entityOwner is BasePlayer basePlayer)
				{
					basePlayer.GiveItem(item);
				}
				else if (entityOwner is IItemContainerEntity itemContainerEntity)
				{
					item.MoveToContainer(itemContainerEntity.inventory, -1, allowStack: true, ignoreStackLimit: false, sourcePlayer);
				}
			}
		}
		Pool.Free<Item>(ref list, false);
	}

	public BaseEntity CreateWorldObject(Vector3 pos, Quaternion rotation = default(Quaternion), BaseEntity parentEnt = null, uint parentBone = 0u)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity worldEntity = GetWorldEntity();
		if ((Object)(object)worldEntity != (Object)null)
		{
			return worldEntity;
		}
		worldEntity = GameManager.server.CreateEntity("assets/prefabs/misc/burlap sack/generic_world.prefab", pos, rotation);
		if ((Object)(object)worldEntity == (Object)null)
		{
			Debug.LogWarning((object)"Couldn't create world object for prefab: items/generic_world");
			return null;
		}
		WorldItem worldItem = worldEntity as WorldItem;
		if ((Object)(object)worldItem != (Object)null)
		{
			worldItem.InitializeItem(this);
		}
		if ((Object)(object)parentEnt != (Object)null)
		{
			worldEntity.SetParent(parentEnt, parentBone);
		}
		worldEntity.Spawn();
		SetWorldEntity(worldEntity);
		return GetWorldEntity();
	}

	public BaseEntity Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation = default(Quaternion))
	{
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		ulong droppedBy = GetRootContainer()?.playerOwner?.userID ?? ((EncryptedValue<ulong>)0uL);
		RemoveFromWorld();
		if (info.AlignWorldModelOnDrop)
		{
			Quaternion val = Quaternion.LookRotation(((Vector3)(ref vVelocity)).normalized, Vector3.up);
			rotation = Quaternion.Euler(0f, ((Quaternion)(ref val)).eulerAngles.y, 0f);
			rotation = Quaternion.Euler(info.WorldModelDropOffset) * rotation;
		}
		BaseEntity baseEntity = null;
		if (vPos != Vector3.zero && !info.HasFlag(ItemDefinition.Flag.NoDropping))
		{
			baseEntity = CreateWorldObject(vPos, rotation);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.SetVelocity(vVelocity);
			}
			if (baseEntity is DroppedItem droppedItem)
			{
				droppedItem.DroppedBy = droppedBy;
				if (info.AdjustCenterOfMassOnDrop)
				{
					droppedItem.Rigidbody.centerOfMass = info.DropCenterOfMass;
				}
			}
		}
		else
		{
			Remove();
		}
		Interface.CallHook("OnItemDropped", (object)this, (object)baseEntity);
		RemoveFromContainer();
		return baseEntity;
	}

	public BaseEntity DropAndTossUpwards(Vector3 vPos, float force = 2f)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		float num = Random.value * MathF.PI * 2f;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(Mathf.Sin(num), 1f, Mathf.Cos(num));
		return Drop(vPos + Vector3.up * 0.1f, val * force);
	}

	public bool IsBusy()
	{
		if (busyTime > Time.time)
		{
			return true;
		}
		return false;
	}

	public void BusyFor(float fTime)
	{
		busyTime = Time.time + fTime;
	}

	public bool IsRemoved()
	{
		return removeTime > 0f;
	}

	public void Remove(float fTime = 0f)
	{
		if (removeTime > 0f || Interface.CallHook("OnItemRemove", (object)this) != null)
		{
			return;
		}
		if (isServer)
		{
			ItemMod[] itemMods = info.itemMods;
			for (int i = 0; i < itemMods.Length; i++)
			{
				itemMods[i].OnRemove(this);
			}
		}
		this.onCycle = null;
		removeTime = Time.time + fTime;
		this.OnDirty = null;
		position = -1;
		ItemManager.RemoveItem(this, fTime);
	}

	public void DoRemove()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		this.OnDirty = null;
		this.onCycle = null;
		if (isServer && ((ItemId)(ref uid)).IsValid && Net.sv != null)
		{
			Net.sv.ReturnUID(uid.Value);
			uid = default(ItemId);
		}
		if (contents != null)
		{
			Pool.Free<ItemContainer>(ref contents);
		}
		if (isServer)
		{
			RemoveFromWorld();
			RemoveFromContainer();
		}
		BaseEntity baseEntity = GetHeldEntity();
		if (baseEntity.IsValid())
		{
			Debug.LogWarning((object)("Item's Held Entity not removed!" + info.displayName.english + " -> " + (object)baseEntity), (Object)(object)baseEntity);
		}
	}

	public void SwitchOnOff(bool bNewState)
	{
		if (HasFlag(Flag.IsOn) != bNewState)
		{
			SetFlag(Flag.IsOn, bNewState);
			MarkDirty();
		}
	}

	public void LockUnlock(bool bNewState)
	{
		if (HasFlag(Flag.IsLocked) != bNewState && (!bNewState || Interface.CallHook("OnItemLock", (object)this) == null) && (bNewState || Interface.CallHook("OnItemUnlock", (object)this) == null))
		{
			SetFlag(Flag.IsLocked, bNewState);
			MarkDirty();
		}
	}

	public BasePlayer GetOwnerPlayer()
	{
		if (parent == null)
		{
			return null;
		}
		return parent.GetOwnerPlayer();
	}

	public bool IsBackpack()
	{
		if ((Object)(object)info != (Object)null)
		{
			return (info.flags & ItemDefinition.Flag.Backpack) != 0;
		}
		return false;
	}

	public int GetChildItemCount()
	{
		return (contents?.itemList?.Count).GetValueOrDefault();
	}

	public int GetItemVolume()
	{
		if (IsBackpack() && (contents?.itemList?.Count).GetValueOrDefault() > 0)
		{
			ItemModBackpack component = ((Component)info).GetComponent<ItemModBackpack>();
			if ((Object)(object)component != (Object)null)
			{
				return component.containerVolumeWhenFilled;
			}
		}
		return info.volume;
	}

	public Item SplitItem(int split_Amount)
	{
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Expected O, but got Unknown
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Expected O, but got Unknown
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Expected O, but got Unknown
		Assert.IsTrue(split_Amount > 0, "split_Amount <= 0");
		if (split_Amount <= 0)
		{
			return null;
		}
		if (split_Amount >= amount)
		{
			return null;
		}
		object obj = Interface.CallHook("OnItemSplit", (object)this, (object)split_Amount);
		if (obj is Item)
		{
			return (Item)obj;
		}
		amount -= split_Amount;
		Item item = ItemManager.CreateByItemID(info.itemid, 1, 0uL);
		item.amount = split_Amount;
		item.skin = skin;
		MigrateItemOwnership(item, split_Amount);
		if (IsBlueprint())
		{
			item.blueprintTarget = blueprintTarget;
		}
		if (info.amountType == ItemDefinition.AmountType.Genetics && instanceData != null && instanceData.dataInt != 0)
		{
			item.instanceData = new InstanceData();
			item.instanceData.dataInt = instanceData.dataInt;
			item.instanceData.ShouldPool = false;
		}
		if (instanceData != null && instanceData.dataInt > 0 && (Object)(object)info != (Object)null && (Object)(object)info.Blueprint != (Object)null && info.Blueprint.GetWorkbenchLevel() == 3)
		{
			item.instanceData = new InstanceData();
			item.instanceData.dataInt = instanceData.dataInt;
			item.instanceData.ShouldPool = false;
			item.SetFlag(Flag.IsOn, IsOn());
		}
		if (instanceData != null && Object.op_Implicit((Object)(object)((Component)info).GetComponent<ItemModFoodSpoiling>()))
		{
			item.instanceData = new InstanceData();
			item.instanceData.dataFloat = instanceData.dataFloat;
			item.instanceData.ShouldPool = false;
		}
		MarkDirty();
		return item;
	}

	public void UnloadAmmo()
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		BaseProjectile baseProjectile = GetHeldEntity() as BaseProjectile;
		if ((Object)(object)baseProjectile == (Object)null)
		{
			return;
		}
		while (baseProjectile.primaryMagazine.contents > 0)
		{
			int num = Mathf.Min(baseProjectile.primaryMagazine.contents, baseProjectile.primaryMagazine.ammoType.stackable);
			baseProjectile.primaryMagazine.contents -= num;
			Item item = ItemManager.Create(baseProjectile.primaryMagazine.ammoType, num, 0uL);
			BasePlayer basePlayer = GetRootContainer()?.playerOwner;
			if ((Object)(object)basePlayer != (Object)null)
			{
				basePlayer.GiveItem(item);
			}
			else if (!item.MoveToContainer(parent) && (Object)(object)item.Drop(parent.dropPosition, parent.dropVelocity) == (Object)null)
			{
				item.Remove();
			}
		}
	}

	public bool CanBeHeld()
	{
		if (isBroken)
		{
			return false;
		}
		if ((Object)(object)((Component)info).GetComponent<ItemModShield>() != (Object)null)
		{
			return false;
		}
		return true;
	}

	public bool CanStack(Item item)
	{
		object obj = Interface.CallHook("CanStackItem", (object)this, (object)item);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (item == this)
		{
			return false;
		}
		if (MaxStackable() <= 1)
		{
			return false;
		}
		if (item.info.stackable <= 1)
		{
			return false;
		}
		if (item.info.itemid != info.itemid)
		{
			return false;
		}
		if (hasCondition && condition != item.info.condition.max)
		{
			return false;
		}
		if (item.hasCondition && item.condition != item.info.condition.max)
		{
			return false;
		}
		if (!IsValid())
		{
			return false;
		}
		if (IsBlueprint() && blueprintTarget != item.blueprintTarget)
		{
			return false;
		}
		if (item.skin != skin)
		{
			return false;
		}
		if (item.info.amountType == ItemDefinition.AmountType.Genetics || info.amountType == ItemDefinition.AmountType.Genetics)
		{
			int num = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));
			int num2 = ((instanceData != null) ? instanceData.dataInt : (-1));
			if (num != num2)
			{
				return false;
			}
		}
		if (item.instanceData != null && instanceData != null && (item.IsOn() != IsOn() || (item.instanceData.dataInt != instanceData.dataInt && (Object)(object)item.info.Blueprint != (Object)null && item.info.Blueprint.GetWorkbenchLevel() == 3)))
		{
			return false;
		}
		if (instanceData != null && ((NetworkableId)(ref instanceData.subEntity)).IsValid && Object.op_Implicit((Object)(object)((Component)info).GetComponent<ItemModSign>()))
		{
			return false;
		}
		if (item.instanceData != null && ((NetworkableId)(ref item.instanceData.subEntity)).IsValid && Object.op_Implicit((Object)(object)((Component)item.info).GetComponent<ItemModSign>()))
		{
			return false;
		}
		if (BlockStackFoodItem(item, this))
		{
			return false;
		}
		return true;
	}

	public static bool BlockStackFoodItem(Item a, Item b)
	{
		ItemModFoodSpoiling itemModFoodSpoiling = default(ItemModFoodSpoiling);
		if (a.instanceData != null && b.instanceData != null && ((Component)a.info).TryGetComponent<ItemModFoodSpoiling>(ref itemModFoodSpoiling))
		{
			bool flag = false;
			float dataFloat = a.instanceData.dataFloat;
			float dataFloat2 = b.instanceData.dataFloat;
			if (Mathf.Abs(dataFloat - dataFloat2) < ConVar.Server.maxFoodSpoilTimeDiffForItemStack)
			{
				flag = true;
			}
			float num = itemModFoodSpoiling.TotalSpoilTimeHours * 60f * 60f;
			float num2 = a.instanceData.dataFloat / num;
			float num3 = b.instanceData.dataFloat / num;
			if (num2 > ConVar.Server.normalisedFoodSpoilTimeStackThreshold && num3 > ConVar.Server.normalisedFoodSpoilTimeStackThreshold)
			{
				flag = true;
			}
			if (!flag)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsValid()
	{
		if (removeTime > 0f)
		{
			return false;
		}
		return true;
	}

	public bool IsDroppedInWorld(bool serverside)
	{
		return worldEnt.IsValid(serverside);
	}

	public void SetWorldEntity(BaseEntity ent)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (!ent.IsValid())
		{
			worldEnt.Set(null);
			MarkDirty();
		}
		else if (!(worldEnt.uid == ent.net.ID))
		{
			worldEnt.Set(ent);
			MarkDirty();
			OnMovedToWorld();
			if (contents != null)
			{
				contents.OnMovedToWorld();
			}
		}
	}

	public void OnMovedToWorld()
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].OnMovedToWorld(this);
		}
	}

	public BaseEntity GetWorldEntity()
	{
		return worldEnt.Get(isServer);
	}

	public void SetHeldEntity(BaseEntity ent)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (!ent.IsValid())
		{
			this.heldEntity.Set(null);
			MarkDirty();
		}
		else
		{
			if (this.heldEntity.uid == ent.net.ID)
			{
				return;
			}
			this.heldEntity.Set(ent);
			MarkDirty();
			if (ent.IsValid())
			{
				HeldEntity heldEntity = ent as HeldEntity;
				if ((Object)(object)heldEntity != (Object)null)
				{
					heldEntity.SetupHeldEntity(this);
				}
			}
		}
	}

	public BaseEntity GetHeldEntity()
	{
		return heldEntity.Get(isServer);
	}

	public void OnCycle(float delta)
	{
		if (this.onCycle != null)
		{
			this.onCycle(this, delta);
		}
	}

	public void ServerCommand(string command, BasePlayer player)
	{
		HeldEntity heldEntity = GetHeldEntity() as HeldEntity;
		if ((Object)(object)heldEntity != (Object)null)
		{
			heldEntity.ServerCommand(this, command, player);
		}
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].ServerCommand(this, command, player);
		}
	}

	public void UseItem(int amountToConsume = 1)
	{
		if (amountToConsume > 0)
		{
			object obj = Interface.CallHook("OnItemUse", (object)this, (object)amountToConsume);
			if (obj is int)
			{
				amountToConsume = (int)obj;
			}
			amount -= amountToConsume;
			ReduceItemOwnership(amountToConsume);
			if (amount <= 0)
			{
				amount = 0;
				Remove();
			}
			else
			{
				MarkDirty();
			}
		}
	}

	public bool HasAmmo(AmmoTypes ammoType)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		ItemModProjectile itemModProjectile = default(ItemModProjectile);
		if (((Component)info).TryGetComponent<ItemModProjectile>(ref itemModProjectile) && itemModProjectile.IsAmmo(ammoType))
		{
			return true;
		}
		if (contents != null)
		{
			ItemModContainer itemModContainer = default(ItemModContainer);
			if ((Object)(object)info != (Object)null && ((Component)info).TryGetComponent<ItemModContainer>(ref itemModContainer) && itemModContainer.blockAmmoSource)
			{
				return false;
			}
			return contents.HasAmmo(ammoType);
		}
		return false;
	}

	public Item FindAmmo(AmmoTypes ammoType)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		ItemModProjectile itemModProjectile = default(ItemModProjectile);
		if (((Component)info).TryGetComponent<ItemModProjectile>(ref itemModProjectile) && itemModProjectile.IsAmmo(ammoType))
		{
			return this;
		}
		if (contents != null)
		{
			return contents.FindAmmo(ammoType);
		}
		return null;
	}

	public void FindAmmo(List<Item> list, AmmoTypes ammoType)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		ItemModProjectile itemModProjectile = default(ItemModProjectile);
		if (((Component)info).TryGetComponent<ItemModProjectile>(ref itemModProjectile) && itemModProjectile.IsAmmo(ammoType))
		{
			list.Add(this);
		}
		else if (contents != null)
		{
			contents.FindAmmo(list, ammoType);
		}
	}

	public int GetAmmoAmount(AmmoTypes ammoType)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		ItemModProjectile itemModProjectile = default(ItemModProjectile);
		if (((Component)info).TryGetComponent<ItemModProjectile>(ref itemModProjectile) && itemModProjectile.IsAmmo(ammoType))
		{
			num += amount;
		}
		if (contents != null)
		{
			num += contents.GetAmmoAmount(ammoType);
		}
		return num;
	}

	public int GetAmmoAmount(List<AmmoTypes> ammoTypes)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		ItemModProjectile itemModProjectile = default(ItemModProjectile);
		if (((Component)info).TryGetComponent<ItemModProjectile>(ref itemModProjectile))
		{
			foreach (AmmoTypes ammoType in ammoTypes)
			{
				if (itemModProjectile.IsAmmo(ammoType))
				{
					num += amount;
				}
			}
		}
		if (contents != null)
		{
			foreach (AmmoTypes ammoType2 in ammoTypes)
			{
				num += contents.GetAmmoAmount(ammoType2);
			}
		}
		return num;
	}

	public override string ToString()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		string[] obj = new string[6]
		{
			"Item.",
			info.shortname,
			"x",
			amount.ToString(),
			".",
			null
		};
		ItemId val = uid;
		obj[5] = ((object)(ItemId)(ref val)/*cast due to .constrained prefix*/).ToString();
		return string.Concat(obj);
	}

	public Item FindItem(ItemId iUID)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (uid == iUID)
		{
			return this;
		}
		if (contents == null)
		{
			return null;
		}
		return contents.FindItemByUID(iUID);
	}

	public int MaxStackable()
	{
		int num = info.stackable;
		if (parent != null && parent.maxStackSize > 0)
		{
			num = Mathf.Min(parent.maxStackSize, num);
		}
		object obj = Interface.CallHook("OnMaxStackable", (object)this);
		if (obj is int)
		{
			return (int)obj;
		}
		return num;
	}

	private void SetRadioactivity(ItemDefinition template)
	{
		if (!((Object)(object)template == (Object)null))
		{
			radioactivity = template.baseRadioactivity;
			if (radioactivity > 0f)
			{
				SetFlag(Flag.Radioactive, b: true);
			}
		}
	}

	public GameObjectRef GetWorldModel()
	{
		return info.GetWorldModel(amount);
	}

	public virtual Item Save(bool bIncludeContainer = false, bool bIncludeOwners = true)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		dirty = false;
		Item val = Pool.Get<Item>();
		val.UID = uid;
		val.itemid = info.itemid;
		val.slot = position;
		val.amount = amount;
		val.flags = (int)flags;
		val.removetime = removeTime;
		val.locktime = busyTime;
		val.instanceData = instanceData;
		val.worldEntity = worldEnt.uid;
		val.heldEntity = heldEntity.uid;
		val.skinid = skin;
		val.name = name;
		val.streamerName = streamerName;
		val.text = text;
		val.cooktime = cookTimeLeft;
		val.iconImageId = iconImageId;
		if (ownershipShares != null)
		{
			val.ownership = Pool.Get<List<ItemOwnershipAmount>>();
			foreach (ItemOwnershipShare ownershipShare in ownershipShares)
			{
				ItemOwnershipAmount val2 = Pool.Get<ItemOwnershipAmount>();
				val2.username = ownershipShare.username;
				val2.reason = ownershipShare.reason;
				val2.amount = ownershipShare.amount;
				val.ownership.Add(val2);
			}
		}
		val.ammoCount = 0;
		NetworkableId val3 = heldEntity.uid;
		if (((NetworkableId)(ref val3)).IsValid)
		{
			BaseEntity baseEntity = GetHeldEntity();
			if (baseEntity is BaseProjectile baseProjectile)
			{
				val.ammoCount = baseProjectile.primaryMagazine.contents + 1;
			}
			else if (baseEntity is Chainsaw chainsaw)
			{
				val.ammoCount = chainsaw.ammo + 1;
			}
			else if (baseEntity is FlameThrower flameThrower)
			{
				val.ammoCount = flameThrower.ammo + 1;
			}
		}
		if (hasCondition)
		{
			val.conditionData = Pool.Get<ConditionData>();
			val.conditionData.maxCondition = _maxCondition;
			val.conditionData.condition = _condition;
		}
		if (contents != null && bIncludeContainer)
		{
			val.contents = contents.Save(bIncludeContainer);
		}
		return val;
	}

	public virtual void Load(Item load)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)info == (Object)null || info.itemid != load.itemid)
		{
			info = ItemManager.FindItemDefinition(load.itemid);
		}
		if ((Object)(object)info == (Object)null)
		{
			Debug.LogError((object)$"Load invalid item id {load.itemid} from item {load.UID} (no ItemDefinition found)");
			return;
		}
		uid = load.UID;
		name = load.name;
		streamerName = load.streamerName;
		text = load.text;
		cookTimeLeft = load.cooktime;
		amount = load.amount;
		position = load.slot;
		busyTime = load.locktime;
		removeTime = load.removetime;
		flags = (Flag)load.flags;
		worldEnt.uid = load.worldEntity;
		heldEntity.uid = load.heldEntity;
		iconImageId = load.iconImageId;
		if (load.ownership != null && load.ownership.Count > 0)
		{
			if (ownershipShares == null)
			{
				ownershipShares = Pool.Get<List<ItemOwnershipShare>>();
			}
			else
			{
				ownershipShares.Clear();
			}
			foreach (ItemOwnershipAmount item2 in load.ownership)
			{
				ItemOwnershipShare itemOwnershipShare = default(ItemOwnershipShare);
				itemOwnershipShare.username = item2.username;
				itemOwnershipShare.reason = item2.reason;
				itemOwnershipShare.amount = item2.amount;
				ItemOwnershipShare item = itemOwnershipShare;
				ownershipShares.Add(item);
			}
		}
		else if (ownershipShares != null)
		{
			Pool.FreeUnmanaged<ItemOwnershipShare>(ref ownershipShares);
		}
		SetRadioactivity(info);
		InitializeItemOwnership();
		if (isServer)
		{
			Net.sv.RegisterUID(uid.Value);
		}
		if (instanceData != null && load.instanceData != instanceData)
		{
			instanceData.ShouldPool = true;
			instanceData.ResetToPool();
			instanceData = null;
		}
		instanceData = load.instanceData;
		if (instanceData != null)
		{
			instanceData.ShouldPool = false;
		}
		skin = load.skinid;
		_condition = 0f;
		_maxCondition = 0f;
		if (load.conditionData != null)
		{
			_condition = load.conditionData.condition;
			_maxCondition = load.conditionData.maxCondition;
		}
		else if (info.condition.enabled)
		{
			_condition = info.condition.max;
			_maxCondition = info.condition.max;
		}
		if (load.contents != null)
		{
			if (contents == null)
			{
				contents = Pool.Get<ItemContainer>();
				if (isServer)
				{
					contents.ServerInitialize(this, load.contents.slots);
				}
			}
			contents.Load(load.contents);
		}
		if (isServer)
		{
			removeTime = 0f;
			OnItemCreated();
		}
	}
}


using System;

[Flags]
public enum Flag
{
	None = 0,
	Placeholder = 1,
	IsOn = 2,
	OnFire = 4,
	IsLocked = 8,
	Cooking = 0x10,
	Radioactive = 0x20,
	Refrigerated = 0x40
}


public interface IItemUpdate
{
	void OnItemUpdate(Item item);
}


public interface IItemSetup
{
	void OnItemSetup(Item item);

	void OnSetupSkin(ulong skin, ItemDefinition definition);
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public sealed class ItemContainer : IAmmoContainer, IPooled
{
	[Flags]
	public enum Flag
	{
		IsPlayer = 1,
		Clothing = 2,
		Belt = 4,
		SingleType = 8,
		IsLocked = 0x10,
		ShowSlotsOnIcon = 0x20,
		NoBrokenItems = 0x40,
		NoItemInput = 0x80,
		ContentsHidden = 0x100,
		IsArmor = 0x200
	}

	[Flags]
	public enum ContentsType
	{
		Generic = 1,
		Liquid = 2
	}

	public enum LimitStack
	{
		None,
		Existing,
		All
	}

	public enum CanAcceptResult
	{
		CanAccept,
		CannotAccept,
		CannotAcceptRightNow
	}

	public const int BackpackSlotIndex = 7;

	public Flag flags;

	public ContentsType allowedContents;

	public ItemDefinition[] onlyAllowedItems;

	public HashSet<ItemDefinition> blockedItems;

	public List<ItemSlot> availableSlots = new List<ItemSlot>();

	public int capacity = 2;

	public ItemContainerId uid;

	public bool dirty;

	public List<Item> itemList = new List<Item>();

	public float temperature = 15f;

	public Item parent;

	public BasePlayer playerOwner;

	public BaseEntity entityOwner;

	public bool isServer;

	public int maxStackSize;

	public int containerVolume;

	public Func<Item, int, bool> canAcceptItem;

	public Func<Item, int, bool> slotIsReserved;

	public Action<Item, bool> onItemAddedRemoved;

	public Action<Item, int, int> onItemPositionChanged;

	public Action<Item, bool> onItemContentsChanged;

	public Action<Item, int> onItemAddedToStack;

	public Action<Item, int> onItemRemovedFromStack;

	public Action<Item> onPreItemRemove;

	public Action<Item, float> onItemRadiationChanged;

	public Action<Item, Item> onItemParentChanged;

	public bool HasAvailableSlotsDefined => !availableSlots.IsEmpty();

	public bool HasLimitedAllowedItems
	{
		get
		{
			if (onlyAllowedItems != null)
			{
				return onlyAllowedItems.Length != 0;
			}
			return false;
		}
	}

	public Vector3 dropPosition
	{
		get
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)playerOwner))
			{
				return playerOwner.GetDropPosition();
			}
			if (Object.op_Implicit((Object)(object)entityOwner))
			{
				return entityOwner.GetDropPosition();
			}
			if (parent != null)
			{
				BaseEntity worldEntity = parent.GetWorldEntity();
				if ((Object)(object)worldEntity != (Object)null)
				{
					return worldEntity.GetDropPosition();
				}
			}
			Debug.LogWarning((object)"ItemContainer.dropPosition dropped through");
			return Vector3.zero;
		}
	}

	public Vector3 dropVelocity
	{
		get
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)playerOwner))
			{
				return playerOwner.GetDropVelocity();
			}
			if (Object.op_Implicit((Object)(object)entityOwner))
			{
				return entityOwner.GetDropVelocity();
			}
			if (parent != null)
			{
				BaseEntity worldEntity = parent.GetWorldEntity();
				if ((Object)(object)worldEntity != (Object)null)
				{
					return worldEntity.GetDropVelocity();
				}
			}
			Debug.LogWarning((object)"ItemContainer.dropVelocity dropped through");
			return Vector3.zero;
		}
	}

	public event Action onDirty;

	public void UpdateAvailableSlots(List<ItemSlot> newSlots)
	{
		availableSlots.Clear();
		if (newSlots != null)
		{
			availableSlots.AddRange(newSlots);
		}
	}

	public bool HasFlag(Flag f)
	{
		return (flags & f) == f;
	}

	public void SetFlag(Flag f, bool b)
	{
		if (b)
		{
			flags |= f;
		}
		else
		{
			flags &= ~f;
		}
	}

	public bool IsLocked()
	{
		return HasFlag(Flag.IsLocked);
	}

	public bool PlayerItemInputBlocked()
	{
		return HasFlag(Flag.NoItemInput);
	}

	void IPooled.EnterPool()
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		flags = (Flag)0;
		allowedContents = (ContentsType)0;
		onlyAllowedItems = null;
		blockedItems = null;
		availableSlots.Clear();
		capacity = 2;
		if (((ItemContainerId)(ref uid)).IsValid && Net.sv != null)
		{
			Net.sv.ReturnUID(uid.Value);
		}
		uid = default(ItemContainerId);
		temperature = 15f;
		parent = null;
		playerOwner = null;
		entityOwner = null;
		isServer = false;
		maxStackSize = 0;
		containerVolume = 0;
		this.onDirty = null;
		canAcceptItem = null;
		slotIsReserved = null;
		onItemAddedRemoved = null;
		onItemContentsChanged = null;
		onItemAddedToStack = null;
		onItemRemovedFromStack = null;
		onPreItemRemove = null;
		onItemRadiationChanged = null;
		onItemParentChanged = null;
		Clear();
		dirty = false;
	}

	void IPooled.LeavePool()
	{
	}

	public float GetTemperature(int slot)
	{
		if (entityOwner is BaseOven baseOven)
		{
			return baseOven.GetTemperature(slot);
		}
		return temperature;
	}

	public void ServerInitialize(Item parentItem, int iMaxCapacity)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		parent = parentItem;
		capacity = iMaxCapacity;
		uid = default(ItemContainerId);
		isServer = true;
		if (allowedContents == (ContentsType)0)
		{
			allowedContents = ContentsType.Generic;
		}
		onItemRadiationChanged = (Action<Item, float>)Delegate.Combine(onItemRadiationChanged, new Action<Item, float>(BubbleUpRadiationChanged));
		MarkDirty();
	}

	public void GiveUID()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsTrue(!((ItemContainerId)(ref uid)).IsValid, "Calling GiveUID - but already has a uid!");
		uid = new ItemContainerId(Net.sv.TakeUID());
	}

	public void MarkDirty()
	{
		dirty = true;
		parent?.MarkDirty();
		this.onDirty?.Invoke();
	}

	public DroppedItemContainer Drop(string prefab, Vector3 pos, Quaternion rot, float destroyPercent)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (itemList == null || itemList.Count == 0)
		{
			return null;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefab, pos, rot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		DroppedItemContainer droppedItemContainer = baseEntity as DroppedItemContainer;
		if ((Object)(object)droppedItemContainer != (Object)null)
		{
			droppedItemContainer.TakeFrom(new ItemContainer[1] { this }, destroyPercent);
		}
		droppedItemContainer.Spawn();
		return droppedItemContainer;
	}

	public static DroppedItemContainer Drop(string prefab, Vector3 pos, Quaternion rot, params ItemContainer[] containers)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		foreach (ItemContainer itemContainer in containers)
		{
			num += ((itemContainer.itemList != null) ? itemContainer.itemList.Count : 0);
		}
		if (num == 0)
		{
			return null;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefab, pos, rot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		DroppedItemContainer droppedItemContainer = baseEntity as DroppedItemContainer;
		if ((Object)(object)droppedItemContainer != (Object)null)
		{
			droppedItemContainer.TakeFrom(containers, 0f);
		}
		droppedItemContainer.Spawn();
		return droppedItemContainer;
	}

	public BaseEntity GetEntityOwner(bool returnHeldEntity = false)
	{
		ItemContainer itemContainer = this;
		for (int i = 0; i < 10; i++)
		{
			if ((Object)(object)itemContainer.entityOwner != (Object)null)
			{
				return itemContainer.entityOwner;
			}
			if ((Object)(object)itemContainer.playerOwner != (Object)null)
			{
				return itemContainer.playerOwner;
			}
			if (returnHeldEntity)
			{
				BaseEntity baseEntity = itemContainer.parent?.GetHeldEntity();
				if ((Object)(object)baseEntity != (Object)null)
				{
					return baseEntity;
				}
			}
			ItemContainer itemContainer2 = itemContainer.parent?.parent;
			if (itemContainer2 == null || itemContainer2 == itemContainer)
			{
				return null;
			}
			itemContainer = itemContainer2;
		}
		return null;
	}

	public void OnChanged()
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			itemList[i].OnChanged();
		}
	}

	public Item FindItemByUID(ItemId iUID)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < itemList.Count; i++)
		{
			Item item = itemList[i];
			if (item.IsValid())
			{
				Item item2 = item.FindItem(iUID);
				if (item2 != null)
				{
					return item2;
				}
			}
		}
		return null;
	}

	public bool IsFull(bool checkForPartialStacks = false)
	{
		if (!checkForPartialStacks)
		{
			return itemList.Count >= capacity;
		}
		if (itemList.Count < capacity)
		{
			return false;
		}
		foreach (Item item in itemList)
		{
			if (item.IsValid() && item.amount < item.MaxStackable())
			{
				return false;
			}
		}
		return true;
	}

	public bool HasSpaceFor(Item item)
	{
		if (!IsFull())
		{
			return true;
		}
		return HasPartialStack(item);
	}

	public bool IsEmpty()
	{
		return itemList.Count == 0;
	}

	public bool HasPartialStack(Item toStack, out int slot)
	{
		slot = -1;
		foreach (Item item in itemList)
		{
			if (item.info.itemid == toStack.info.itemid && item.amount < item.MaxStackable() && toStack.CanStack(item))
			{
				slot = item.position;
				return true;
			}
		}
		return false;
	}

	public float GetRadioactiveMaterialInContainer()
	{
		float num = 0f;
		foreach (Item item in itemList)
		{
			num += item.radioactivity;
		}
		return num;
	}

	public bool HasPartialStack(Item toStack)
	{
		int slot;
		return HasPartialStack(toStack, out slot);
	}

	public bool CanAccept(Item item)
	{
		if (IsFull())
		{
			return false;
		}
		return true;
	}

	public int GetMaxTransferAmount(ItemDefinition def)
	{
		int num = ContainerMaxStackSize();
		foreach (Item item in itemList)
		{
			if ((Object)(object)item.info == (Object)(object)def)
			{
				num -= item.amount;
				if (num <= 0)
				{
					return 0;
				}
			}
		}
		return num;
	}

	public void SetOnlyAllowedItem(ItemDefinition def)
	{
		SetOnlyAllowedItems(def);
	}

	public void SetOnlyAllowedItems(ItemDefinition[] baseItems, params ItemDefinition[] additionalItems)
	{
		onlyAllowedItems = (from item in baseItems.Concat(additionalItems)
			where (Object)(object)item != (Object)null
			select item).ToArray();
	}

	public void SetOnlyAllowedItems(params ItemDefinition[] defs)
	{
		int num = 0;
		ItemDefinition[] array = defs;
		for (int i = 0; i < array.Length; i++)
		{
			if ((Object)(object)array[i] != (Object)null)
			{
				num++;
			}
		}
		onlyAllowedItems = new ItemDefinition[num];
		int num2 = 0;
		array = defs;
		foreach (ItemDefinition itemDefinition in array)
		{
			if ((Object)(object)itemDefinition != (Object)null)
			{
				onlyAllowedItems[num2] = itemDefinition;
				num2++;
			}
		}
	}

	public void SetBlacklist(ItemDefinition[] defs)
	{
		if (defs != null && defs.Length != 0)
		{
			blockedItems = new HashSet<ItemDefinition>(defs);
		}
	}

	public bool Insert(Item item)
	{
		if (itemList.Contains(item))
		{
			return false;
		}
		if (IsFull())
		{
			return false;
		}
		itemList.Add(item);
		item.parent = this;
		if (!FindPosition(item))
		{
			return false;
		}
		MarkDirty();
		if (onItemAddedRemoved != null)
		{
			onItemAddedRemoved(item, arg2: true);
		}
		ItemContainer itemContainer = parent?.parent;
		if (itemContainer != null && itemContainer.onItemContentsChanged != null)
		{
			itemContainer.onItemContentsChanged(item, arg2: true);
		}
		Interface.CallHook("OnItemAddedToContainer", (object)this, (object)item);
		return true;
	}

	public bool SlotTaken(Item item, int i)
	{
		if (slotIsReserved != null && slotIsReserved(item, i))
		{
			return true;
		}
		return GetSlot(i) != null;
	}

	public Item GetSlot(int slot)
	{
		if (slot == -1)
		{
			return null;
		}
		_ = itemList.Count;
		foreach (Item item in itemList)
		{
			if (item.position == slot)
			{
				return item;
			}
		}
		return null;
	}

	public bool QuickIndustrialPreCheck(Item toTransfer, Vector2i range, int fakeSlots, out int foundSlot)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		int num = range.y - range.x + 1;
		int count = itemList.Count;
		int num2 = 0;
		foundSlot = -1;
		for (int i = 0; i < count; i++)
		{
			Item item = itemList[i];
			int position = item.position;
			if (position < range.x || position > range.y)
			{
				continue;
			}
			num2++;
			if (item.amount >= item.info.stackable || item.IsRemoved())
			{
				continue;
			}
			if (toTransfer.IsBlueprint())
			{
				if (item.blueprintTarget != toTransfer.blueprintTarget)
				{
					continue;
				}
			}
			else if ((Object)(object)item.info != (Object)(object)toTransfer.info)
			{
				continue;
			}
			if (item.instanceData == null || item.CanStack(toTransfer))
			{
				foundSlot = position;
				return true;
			}
		}
		return num2 + fakeSlots < num;
	}

	public bool FindPosition(Item item)
	{
		int position = item.position;
		item.position = -1;
		if (position >= 0 && !SlotTaken(item, position))
		{
			item.position = position;
			return true;
		}
		for (int i = 0; i < capacity; i++)
		{
			if (!SlotTaken(item, i))
			{
				item.position = i;
				return true;
			}
		}
		return false;
	}

	public bool HasItem(ItemDefinition searchFor)
	{
		if ((Object)(object)searchFor == (Object)null)
		{
			return false;
		}
		foreach (Item item in itemList)
		{
			if (item != null && (Object)(object)item.info == (Object)(object)searchFor)
			{
				return true;
			}
		}
		return false;
	}

	public void SetLocked(bool isLocked, bool lockSubItems = false)
	{
		SetFlag(Flag.IsLocked, isLocked);
		if (lockSubItems)
		{
			SetSubItemsLocked(isLocked);
		}
		MarkDirty();
	}

	private void SetSubItemsLocked(bool isLocked)
	{
		if (itemList == null)
		{
			return;
		}
		foreach (Item item in itemList)
		{
			if (item != null && item.contents != null)
			{
				item.contents.SetLocked(isLocked);
			}
		}
	}

	public bool Remove(Item item)
	{
		if (!itemList.Contains(item))
		{
			return false;
		}
		onPreItemRemove?.Invoke(item);
		itemList.Remove(item);
		item.parent = null;
		onItemParentChanged?.Invoke(parent, item);
		onItemAddedRemoved?.Invoke(item, arg2: false);
		ItemContainer itemContainer = parent?.parent;
		if (itemContainer != null && itemContainer.onItemContentsChanged != null)
		{
			itemContainer.onItemContentsChanged(item, arg2: false);
		}
		MarkDirty();
		Interface.CallHook("OnItemRemovedFromContainer", (object)this, (object)item);
		return true;
	}

	public void Clear()
	{
		if (itemList.Count == 0)
		{
			return;
		}
		foreach (Item item in itemList)
		{
			onPreItemRemove?.Invoke(item);
			item.parent = null;
			item.Remove();
			onItemAddedRemoved?.Invoke(item, arg2: false);
			ItemContainer itemContainer = parent?.parent;
			if (itemContainer != null && itemContainer.onItemContentsChanged != null)
			{
				itemContainer.onItemContentsChanged(item, arg2: false);
			}
		}
		itemList.Clear();
		MarkDirty();
	}

	public void Kill()
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		parent = null;
		this.onDirty = null;
		canAcceptItem = null;
		slotIsReserved = null;
		onItemAddedRemoved = null;
		onItemContentsChanged = null;
		onPreItemRemove = null;
		if (((ItemContainerId)(ref uid)).IsValid && Net.sv != null)
		{
			Net.sv.ReturnUID(uid.Value);
			uid = default(ItemContainerId);
		}
		Clear();
	}

	public int GetAmount(int itemid, bool onlyUsableAmounts)
	{
		int num = 0;
		foreach (Item item in itemList)
		{
			if (item.info.itemid == itemid && (!onlyUsableAmounts || !item.IsBusy()))
			{
				num += item.amount;
			}
		}
		return num;
	}

	public int GetAmount(int blueprintBaseId, int itemId, bool onlyUsableAmounts)
	{
		int num = 0;
		foreach (Item item in itemList)
		{
			if (item.info.itemid == blueprintBaseId && item.blueprintTarget == itemId && (!onlyUsableAmounts || !item.IsBusy()))
			{
				num += item.amount;
			}
		}
		return num;
	}

	public int GetOkConditionAmount(int itemid, bool onlyUsableAmounts)
	{
		int num = 0;
		foreach (Item item in itemList)
		{
			if (item.info.itemid == itemid && (!onlyUsableAmounts || !item.IsBusy()) && !(item.condition <= 0f))
			{
				num += item.amount;
			}
		}
		return num;
	}

	public Item FindItemByItemID(int itemid)
	{
		foreach (Item item in itemList)
		{
			if (item.info.itemid == itemid)
			{
				return item;
			}
		}
		return null;
	}

	public Item FindItemByItemName(string name)
	{
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(name);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return null;
		}
		for (int i = 0; i < itemList.Count; i++)
		{
			if ((Object)(object)itemList[i].info == (Object)(object)itemDefinition)
			{
				return itemList[i];
			}
		}
		return null;
	}

	public Item FindBySubEntityID(NetworkableId subEntityID)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (!((NetworkableId)(ref subEntityID)).IsValid)
		{
			return null;
		}
		foreach (Item item in itemList)
		{
			if (item.instanceData != null && item.instanceData.subEntity == subEntityID)
			{
				return item;
			}
		}
		return null;
	}

	public void FindItemsByItemID(List<Item> list, int itemid)
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			Item item = itemList[i];
			if (item.info.itemid == itemid)
			{
				list.Add(item);
			}
		}
	}

	public void FindItemsByItemID(int itemId, BufferList<Item> found)
	{
		found.Clear();
		foreach (Item item in itemList)
		{
			if (item.info.itemid == itemId)
			{
				found.Add(item);
			}
		}
	}

	public ItemContainer Save(bool bIncludeContainer = true)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		ItemContainer val = Pool.Get<ItemContainer>();
		val.contents = Pool.Get<List<Item>>();
		val.UID = uid;
		val.slots = capacity;
		val.temperature = temperature;
		val.allowedContents = (int)allowedContents;
		if (HasLimitedAllowedItems)
		{
			val.allowedItems = Pool.Get<List<int>>();
			for (int i = 0; i < onlyAllowedItems.Length; i++)
			{
				if ((Object)(object)onlyAllowedItems[i] != (Object)null)
				{
					val.allowedItems.Add(onlyAllowedItems[i].itemid);
				}
			}
		}
		val.flags = (int)flags;
		val.maxStackSize = maxStackSize;
		val.volume = containerVolume;
		if (availableSlots != null && availableSlots.Count > 0)
		{
			val.availableSlots = Pool.Get<List<int>>();
			for (int j = 0; j < availableSlots.Count; j++)
			{
				val.availableSlots.Add((int)availableSlots[j]);
			}
		}
		for (int k = 0; k < itemList.Count; k++)
		{
			Item item = itemList[k];
			if (item.IsValid())
			{
				val.contents.Add(item.Save(bIncludeContainer));
			}
		}
		return val;
	}

	public void Load(ItemContainer container)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("ItemContainer.Load", 0);
		try
		{
			uid = container.UID;
			capacity = container.slots;
			List<Item> list = itemList;
			itemList = Pool.Get<List<Item>>();
			temperature = container.temperature;
			flags = (Flag)container.flags;
			allowedContents = ((container.allowedContents == 0) ? ContentsType.Generic : ((ContentsType)container.allowedContents));
			if (container.allowedItems != null && container.allowedItems.Count > 0)
			{
				onlyAllowedItems = new ItemDefinition[container.allowedItems.Count];
				for (int i = 0; i < container.allowedItems.Count; i++)
				{
					onlyAllowedItems[i] = ItemManager.FindItemDefinition(container.allowedItems[i]);
				}
			}
			else
			{
				onlyAllowedItems = null;
			}
			maxStackSize = container.maxStackSize;
			containerVolume = container.volume;
			availableSlots.Clear();
			if (container.availableSlots != null)
			{
				for (int j = 0; j < container.availableSlots.Count; j++)
				{
					availableSlots.Add((ItemSlot)container.availableSlots[j]);
				}
			}
			TimeWarning val2 = TimeWarning.New("container.contents", 0);
			try
			{
				foreach (Item content in container.contents)
				{
					Item created = null;
					foreach (Item item in list)
					{
						if (item.uid == content.UID)
						{
							created = item;
							break;
						}
					}
					created = ItemManager.Load(content, created, isServer);
					if (created != null)
					{
						created.parent = this;
						created.position = content.slot;
						Insert(created);
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			val2 = TimeWarning.New("Delete old items", 0);
			try
			{
				foreach (Item item2 in list)
				{
					if (!itemList.Contains(item2))
					{
						item2.Remove();
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			dirty = true;
			Pool.Free<Item>(ref list, false);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public BasePlayer GetOwnerPlayer()
	{
		return playerOwner;
	}

	public int ContainerMaxStackSize()
	{
		if (maxStackSize <= 0)
		{
			return int.MaxValue;
		}
		return maxStackSize;
	}

	public int Take(List<Item> collect, int itemid, int iAmount, bool takeBroken = true)
	{
		int num = 0;
		if (iAmount == 0)
		{
			return num;
		}
		List<Item> list = Pool.Get<List<Item>>();
		foreach (Item item2 in itemList)
		{
			if (item2.info.itemid != itemid || (!takeBroken && item2.info.condition.enabled && item2.condition <= 0f))
			{
				continue;
			}
			int num2 = iAmount - num;
			if (num2 <= 0)
			{
				continue;
			}
			if (item2.amount > num2)
			{
				num += num2;
				Item item = item2.SplitItem(num2);
				if (item != null)
				{
					item.CollectedForCrafting(playerOwner);
					collect?.Add(item);
				}
				break;
			}
			if (item2.amount <= num2)
			{
				num += item2.amount;
				list.Add(item2);
				collect?.Add(item2);
			}
			if (num == iAmount)
			{
				break;
			}
		}
		foreach (Item item3 in list)
		{
			item3.RemoveFromContainer();
		}
		Pool.Free<Item>(ref list, false);
		return num;
	}

	public bool TryTakeOne(int itemid, out Item item)
	{
		item = null;
		foreach (Item item3 in itemList)
		{
			if (item3.info.itemid == itemid)
			{
				if (item3.amount > 1)
				{
					item3.MarkDirty();
					item3.amount--;
					Item item2 = ItemManager.CreateByItemID(itemid, 1, 0uL);
					item2.amount = 1;
					item2.CollectedForCrafting(playerOwner);
					item = item2;
				}
				else
				{
					item = item3;
				}
				break;
			}
		}
		if (item != null)
		{
			item.RemoveFromContainer();
			return true;
		}
		return false;
	}

	public bool GiveItem(Item item, ItemContainer container = null)
	{
		if (item == null)
		{
			return false;
		}
		if (container != null && item.MoveToContainer(container))
		{
			return true;
		}
		return item.MoveToContainer(this);
	}

	public void OnCycle(float delta)
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			if (itemList[i].IsValid())
			{
				itemList[i].OnCycle(delta);
			}
		}
	}

	public Item FindAmmo(AmmoTypes ammoType)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < itemList.Count; i++)
		{
			Item item = itemList[i].FindAmmo(ammoType);
			if (item != null)
			{
				return item;
			}
		}
		return null;
	}

	public void FindAmmo(List<Item> list, AmmoTypes ammoType)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < itemList.Count; i++)
		{
			itemList[i].FindAmmo(list, ammoType);
		}
	}

	public bool HasAmmo(AmmoTypes ammoType)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < itemList.Count; i++)
		{
			if (itemList[i].HasAmmo(ammoType))
			{
				return true;
			}
		}
		return false;
	}

	public int GetAmmoAmount(ItemDefinition specificAmmo)
	{
		int num = 0;
		for (int i = 0; i < itemList.Count; i++)
		{
			num += (((Object)(object)itemList[i].info == (Object)(object)specificAmmo) ? itemList[i].amount : 0);
		}
		return num;
	}

	public int GetAmmoAmount(AmmoTypes ammoType)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		for (int i = 0; i < itemList.Count; i++)
		{
			num += itemList[i].GetAmmoAmount(ammoType);
		}
		return num;
	}

	public int TotalItemAmount()
	{
		int num = 0;
		for (int i = 0; i < itemList.Count; i++)
		{
			num += itemList[i].amount;
		}
		return num;
	}

	public bool HasAny(ItemDefinition itemDef)
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			Item item = itemList[i];
			if ((Object)(object)item.info == (Object)(object)itemDef && item.amount > 0)
			{
				return true;
			}
		}
		return false;
	}

	public bool HasAnyWithSpace(ItemDefinition itemDef)
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			Item item = itemList[i];
			if ((Object)(object)item.info == (Object)(object)itemDef && item.amount > 0 && item.amount < item.info.stackable)
			{
				return true;
			}
		}
		return false;
	}

	public int GetTotalItemAmount(Item item, int slotStartInclusive, int slotEndInclusive)
	{
		int num = 0;
		for (int i = slotStartInclusive; i <= slotEndInclusive; i++)
		{
			Item slot = GetSlot(i);
			if (slot == null)
			{
				continue;
			}
			if (item.IsBlueprint())
			{
				if (slot.IsBlueprint() && slot.blueprintTarget == item.blueprintTarget)
				{
					num += slot.amount;
				}
			}
			else if ((Object)(object)slot.info == (Object)(object)item.info || (Object)(object)slot.info.isRedirectOf == (Object)(object)item.info || (Object)(object)item.info.isRedirectOf == (Object)(object)slot.info)
			{
				num += slot.amount;
			}
			else if ((Object)(object)slot.info.isRedirectOf != (Object)null && (Object)(object)slot.info.isRedirectOf == (Object)(object)item.info.isRedirectOf)
			{
				num += slot.amount;
			}
		}
		return num;
	}

	public int TotalItemAmount(ItemDefinition itemDef)
	{
		int num = 0;
		for (int i = 0; i < itemList.Count; i++)
		{
			Item item = itemList[i];
			if ((Object)(object)item.info == (Object)(object)itemDef)
			{
				num += item.amount;
			}
		}
		return num;
	}

	public int GetTotalCategoryAmount(ItemCategory category, int slotStartInclusive, int slotEndInclusive)
	{
		int num = 0;
		for (int i = slotStartInclusive; i <= slotEndInclusive; i++)
		{
			Item slot = GetSlot(i);
			if (slot != null && slot.info.category == category)
			{
				num += slot.amount;
			}
		}
		return num;
	}

	public void AddItem(ItemDefinition itemToCreate, int amount, ulong skin = 0uL, LimitStack limitStack = LimitStack.Existing)
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			if (amount == 0)
			{
				return;
			}
			if ((Object)(object)itemList[i].info != (Object)(object)itemToCreate)
			{
				continue;
			}
			int num = itemList[i].MaxStackable();
			if (num <= itemList[i].amount && limitStack != 0)
			{
				continue;
			}
			MarkDirty();
			itemList[i].amount += amount;
			amount -= amount;
			if (itemList[i].amount > num && limitStack != 0)
			{
				amount = itemList[i].amount - num;
				if (amount > 0)
				{
					itemList[i].amount -= amount;
				}
			}
		}
		if (amount == 0)
		{
			return;
		}
		int num2 = ((limitStack == LimitStack.All) ? Mathf.Min(itemToCreate.stackable, ContainerMaxStackSize()) : int.MaxValue);
		if (num2 <= 0)
		{
			return;
		}
		while (amount > 0)
		{
			int num3 = Mathf.Min(amount, num2);
			Item item = ItemManager.Create(itemToCreate, num3, skin);
			amount -= num3;
			if (!item.MoveToContainer(this))
			{
				item.Remove();
			}
		}
	}

	public bool TryMoveAllItems(ItemContainer target)
	{
		for (int num = itemList.Count - 1; num >= 0; num--)
		{
			if (!itemList[num].MoveToContainer(target))
			{
				return false;
			}
		}
		return true;
	}

	public void MoveAllItems(ItemContainer target)
	{
		for (int num = itemList.Count - 1; num >= 0; num--)
		{
			itemList[num].MoveToContainer(target);
		}
	}

	public void RemoveFractionOfContainer(List<Item> removedItems, float removeFraction)
	{
		removeFraction = Mathf.Clamp01(removeFraction);
		if (itemList.Count == 0 || removeFraction == 0f)
		{
			return;
		}
		List<Item> list = Pool.Get<List<Item>>();
		Dictionary<ItemDefinition, float> dictionary = Pool.Get<Dictionary<ItemDefinition, float>>();
		for (int num = itemList.Count - 1; num >= 0; num--)
		{
			Item item = itemList[num];
			if (item.amount == 1)
			{
				list.Add(item);
			}
			else
			{
				float num2 = (float)item.amount * removeFraction;
				int num3 = Mathf.FloorToInt(num2);
				float num4 = num2 - (float)num3;
				if (num4 > 0f)
				{
					if (!dictionary.TryGetValue(item.info, out var value))
					{
						float num5 = num4;
						if (Random.Range(0f, 1f) < num5)
						{
							num4 = -1f + num5;
							num3++;
						}
						else
						{
							num4 += removeFraction;
						}
						dictionary.Add(item.info, num4);
					}
					else
					{
						num4 += value;
						if (num4 > 1f)
						{
							num3++;
							num4 -= 1f;
						}
						dictionary[item.info] = num4;
					}
				}
				if (num3 > 0)
				{
					if (num3 == item.amount)
					{
						removedItems.Add(item);
						item.RemoveFromContainer();
					}
					else
					{
						removedItems.Add(item.SplitItem(num3));
					}
				}
			}
		}
		int num6 = Mathf.RoundToInt((float)list.Count * removeFraction);
		ListEx.Shuffle<Item>(list, (uint)Random.Range(0, 1000000000));
		for (int i = 0; i < num6; i++)
		{
			Item item2 = list[i];
			removedItems.Add(item2);
			item2.RemoveFromContainer();
		}
		Pool.FreeUnmanaged<Item>(ref list);
		Pool.FreeUnmanaged<ItemDefinition, float>(ref dictionary);
	}

	public void RemoveItemsFromContainer(List<Item> removedItems, string[] targetItems)
	{
		for (int num = itemList.Count - 1; num >= 0; num--)
		{
			Item item = itemList[num];
			foreach (string text in targetItems)
			{
				if (item.info.shortname == text)
				{
					item.RemoveFromContainer();
					removedItems.Add(item);
					break;
				}
			}
		}
	}

	public void MergeAllStacks()
	{
		List<Item> list = Pool.Get<List<Item>>();
		list.AddRange(itemList);
		foreach (Item item in list)
		{
			item.RemoveFromContainer();
		}
		foreach (Item item2 in list)
		{
			item2.MoveToContainer(this);
		}
		Pool.Free<Item>(ref list, false);
	}

	public void OnMovedToWorld()
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			itemList[i].OnMovedToWorld();
		}
	}

	public void OnRemovedFromWorld()
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			itemList[i].OnRemovedFromWorld();
		}
	}

	public uint ContentsDeepHash(bool ignoreBackContents = false)
	{
		uint num = 0u;
		for (int i = 0; i < capacity; i++)
		{
			Item slot = GetSlot(i);
			if (slot == null)
			{
				continue;
			}
			num = CRC.Compute32(num, slot.info.itemid);
			num = CRC.Compute32(num, slot.skin);
			num = CRC.Compute32(num, slot.uid.Value);
			if ((slot.IsBackpack() && ignoreBackContents) || slot.contents == null)
			{
				continue;
			}
			for (int j = 0; j < slot.contents.capacity; j++)
			{
				if (slot.contents.GetSlot(j) != null)
				{
					num = CRC.Compute32(num, slot.info.itemid);
				}
			}
		}
		return num;
	}

	public ItemContainer FindContainer(ItemContainerId id)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (id == uid)
		{
			return this;
		}
		for (int i = 0; i < itemList.Count; i++)
		{
			Item item = itemList[i];
			if (item.contents != null)
			{
				ItemContainer itemContainer = item.contents.FindContainer(id);
				if (itemContainer != null)
				{
					return itemContainer;
				}
			}
		}
		return null;
	}

	public CanAcceptResult CanAcceptItem(Item item, int targetPos)
	{
		if (canAcceptItem != null && !canAcceptItem(item, targetPos))
		{
			return CanAcceptResult.CannotAccept;
		}
		if (isServer && availableSlots != null && availableSlots.Count > 0)
		{
			if (item.info.occupySlots == (ItemSlot)0 || item.info.occupySlots == ItemSlot.None)
			{
				return CanAcceptResult.CannotAccept;
			}
			if (item.isBroken)
			{
				return CanAcceptResult.CannotAccept;
			}
			int num = 0;
			foreach (ItemSlot availableSlot in availableSlots)
			{
				num |= (int)availableSlot;
			}
			if (((uint)num & (uint)item.info.occupySlots) != (uint)item.info.occupySlots)
			{
				return CanAcceptResult.CannotAcceptRightNow;
			}
		}
		if ((allowedContents & item.info.itemType) != item.info.itemType)
		{
			return CanAcceptResult.CannotAccept;
		}
		if (HasLimitedAllowedItems)
		{
			bool flag = false;
			for (int i = 0; i < onlyAllowedItems.Length; i++)
			{
				if ((Object)(object)onlyAllowedItems[i] == (Object)(object)item.info)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return CanAcceptResult.CannotAccept;
			}
		}
		object obj = Interface.CallHook("CanAcceptItem", (object)this, (object)item, (object)targetPos);
		if (obj is CanAcceptResult)
		{
			return (CanAcceptResult)obj;
		}
		if (blockedItems != null && blockedItems.Contains(item.info))
		{
			return CanAcceptResult.CannotAccept;
		}
		if (item.GetItemVolume() > containerVolume)
		{
			return CanAcceptResult.CannotAccept;
		}
		return CanAcceptResult.CanAccept;
	}

	public bool HasBackpackItem()
	{
		foreach (Item item in itemList)
		{
			if (!item.isBroken && item.IsBackpack())
			{
				return true;
			}
		}
		return false;
	}

	public void BubbleUpRadiationChanged(Item item, float amount)
	{
		if (parent != null && parent.parent != null)
		{
			parent?.parent?.onItemRadiationChanged?.Invoke(parent, 0f);
		}
	}
}


using System;

[Flags]
public enum Flag
{
	IsPlayer = 1,
	Clothing = 2,
	Belt = 4,
	SingleType = 8,
	IsLocked = 0x10,
	ShowSlotsOnIcon = 0x20,
	NoBrokenItems = 0x40,
	NoItemInput = 0x80,
	ContentsHidden = 0x100,
	IsArmor = 0x200
}


using System;

[Flags]
public enum ContentsType
{
	Generic = 1,
	Liquid = 2
}


public enum LimitStack
{
	None,
	Existing,
	All
}


public enum CanAcceptResult
{
	CanAccept,
	CannotAccept,
	CannotAcceptRightNow
}


using UnityEngine;

public class ItemCorpseOverride : MonoBehaviour
{
	public GameObjectRef MaleCorpse;

	public GameObjectRef FemaleCorpse;

	public bool BlockWearableCopy;
}


using System;
using System.Collections.Generic;
using ConVar;
using Rust;
using UnityEngine;

public class ItemBlueprint : MonoBehaviour
{
	[Serializable]
	public struct BlueprintOverride
	{
		public Era TargetEra;

		public List<ItemAmount> Ingredients;

		public float craftTime;

		public int workbenchLevel;

		public BlueprintOverride(ItemBlueprint bp)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			TargetEra = (Era)0;
			Ingredients = bp.ingredients;
			craftTime = bp.time;
			workbenchLevel = bp.workbenchLevelRequired;
		}
	}

	private ItemDefinition _targetItem;

	public List<ItemAmount> ingredients = new List<ItemAmount>();

	public List<ItemDefinition> additionalUnlocks = new List<ItemDefinition>();

	public bool defaultBlueprint;

	public bool userCraftable = true;

	public bool isResearchable = true;

	public bool forceShowInConveyorFilter;

	public Rarity rarity;

	[Header("Workbench")]
	public int workbenchLevelRequired;

	[Header("Scrap")]
	public int scrapRequired;

	public int scrapFromRecycle;

	[Tooltip("This item won't show anywhere unless you have the corresponding SteamItem in your inventory - which is defined on the ItemDefinition")]
	[Header("Unlocking")]
	public bool NeedsSteamItem;

	public ItemDefinition RequireUnlockedItem;

	public int blueprintStackSize = -1;

	public float time = 1f;

	public int amountToCreate = 1;

	public bool ForceThisCraftTime;

	public string UnlockAchievment;

	public string RecycleStat;

	public List<BlueprintOverride> Overrides = new List<BlueprintOverride>();

	public ItemDefinition targetItem
	{
		get
		{
			if (_targetItem == null)
			{
				_targetItem = ((Component)this).GetComponent<ItemDefinition>();
			}
			return _targetItem;
		}
	}

	public bool NeedsSteamDLC => (Object)(object)targetItem.steamDlc != (Object)null;

	public List<ItemAmount> GetIngredients()
	{
		BlueprintOverride recipeOverride = GetRecipeOverride();
		float multiplier = 1f;
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode != (Object)null)
		{
			multiplier = activeGameMode.GetCraftingCostModifier(targetItem);
		}
		if (recipeOverride.Ingredients != null && recipeOverride.Ingredients.Count > 0)
		{
			ApplyMultiplierToIngredients(recipeOverride.Ingredients, multiplier);
			return recipeOverride.Ingredients;
		}
		ApplyMultiplierToIngredients(ingredients, multiplier);
		return ingredients;
	}

	private void ApplyMultiplierToIngredients(List<ItemAmount> ingredients, float multiplier)
	{
		foreach (ItemAmount ingredient in ingredients)
		{
			ingredient.amount = Mathf.RoundToInt(ingredient.startAmount * multiplier);
		}
	}

	public float GetCraftTime()
	{
		float craftTime = time;
		float num = 5f;
		ItemDefinition itemDefinition = targetItem;
		if ((Object)(object)itemDefinition != (Object)null && (itemDefinition.stackable == 1 || itemDefinition.isHoldable || itemDefinition.isWearable || itemDefinition.isUsable || itemDefinition.category == ItemCategory.Construction || itemDefinition.category == ItemCategory.Traps))
		{
			num += (float)Mathf.Max(workbenchLevelRequired, 1) * 10f;
		}
		BlueprintOverride recipeOverride = GetRecipeOverride();
		if (recipeOverride.craftTime > 0f)
		{
			craftTime = recipeOverride.craftTime;
		}
		if (ForceThisCraftTime)
		{
			return craftTime;
		}
		return Mathf.Min(num, craftTime);
	}

	public BlueprintOverride GetRecipeOverride()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (Overrides.Count == 0)
		{
			return new BlueprintOverride(this);
		}
		foreach (BlueprintOverride @override in Overrides)
		{
			if (@override.TargetEra == ConVar.Server.Era)
			{
				return @override;
			}
		}
		return new BlueprintOverride(this);
	}

	public int GetWorkbenchLevel()
	{
		BlueprintOverride recipeOverride = GetRecipeOverride();
		if (recipeOverride.workbenchLevel != 0)
		{
			return Mathf.Max(0, recipeOverride.workbenchLevel);
		}
		return workbenchLevelRequired;
	}
}


using System;
using System.Collections.Generic;
using Rust;

[Serializable]
public struct BlueprintOverride
{
	public Era TargetEra;

	public List<ItemAmount> Ingredients;

	public float craftTime;

	public int workbenchLevel;

	public BlueprintOverride(ItemBlueprint bp)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		TargetEra = (Era)0;
		Ingredients = bp.ingredients;
		craftTime = bp.time;
		workbenchLevel = bp.workbenchLevelRequired;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Rust;
using UnityEngine;

public class ItemDefinition : MonoBehaviour
{
	[Flags]
	public enum LootDistributionModifierType
	{
		None = 0,
		Firearm = 1,
		FirearmAmmunition = 2,
		Unused = int.MinValue
	}

	[Serializable]
	public struct Condition
	{
		[Serializable]
		public class WorldSpawnCondition
		{
			public float fractionMin = 1f;

			public float fractionMax = 1f;
		}

		public bool enabled;

		[Tooltip("The maximum condition this item type can have, new items will start with this value")]
		public float max;

		[Tooltip("If false then item will destroy when condition reaches 0")]
		public bool repairable;

		[Tooltip("If true, never lose max condition when repaired")]
		public bool maintainMaxCondition;

		public bool ovenCondition;

		public WorldSpawnCondition foundCondition;

		public bool hideConditionBar;

		public GameObjectRef breakEffect;
	}

	[Serializable]
	public struct OverrideWorldModel
	{
		public GameObjectRef worldModel;

		public int minStackSize;
	}

	public enum RedirectVendingBehaviour
	{
		NoListing,
		ListAsUniqueItem
	}

	[Flags]
	public enum Flag
	{
		NoDropping = 1,
		NotStraightToBelt = 2,
		NotAllowedInBelt = 4,
		Backpack = 8
	}

	public enum AmountType
	{
		Count,
		Millilitre,
		Feet,
		Genetics,
		OxygenSeconds,
		Frequency,
		Generic,
		BagLimit,
		ShelterLimit,
		ContentCount,
		TurretLimit,
		NucleusGrades
	}

	[Header("Item")]
	[ReadOnly]
	public int itemid;

	[Tooltip("The shortname should be unique. A hash will be generated from it to identify the item type. If this name changes at any point it will make all saves incompatible")]
	public string shortname;

	public Era era;

	public EraRestriction eraRestrictions;

	public LootDistributionModifierType lootDistributionType;

	[Header("Appearance")]
	public Phrase displayName;

	public Phrase displayDescription;

	public Sprite iconSprite;

	public ItemCategory category;

	public ItemSelectionPanel selectionPanel;

	[Header("Containment")]
	public int maxDraggable;

	public ItemContainer.ContentsType itemType = ItemContainer.ContentsType.Generic;

	public AmountType amountType;

	[InspectorFlags]
	public ItemSlot occupySlots = ItemSlot.None;

	public int stackable;

	public int volume;

	public float baseRadioactivity;

	public bool quickDespawn;

	public bool blockStealingInSafeZone;

	[Tooltip("Should this item be blocked from being burried and found by other players? Off by default to allow most items.")]
	public bool allowBurying;

	public BasePlayer.TutorialItemAllowance tutorialAllowance;

	[Tooltip("If true, this item will support item ownership even if it's stacksize is >1")]
	public bool supportsStackableOwnership;

	[Header("Spawn Tables")]
	[Tooltip("How rare this item is and how much it costs to research")]
	public Rarity rarity;

	public Rarity despawnRarity;

	public bool spawnAsBlueprint;

	[Header("Sounds")]
	public SoundDefinition inventoryGrabSound;

	public SoundDefinition inventoryDropSound;

	public SoundDefinition physImpactSoundDef;

	public Condition condition;

	[Header("Misc")]
	public bool hidden;

	[InspectorFlags]
	public Flag flags;

	public bool hideSelectedPanel;

	[Tooltip("User can craft this item on any server if they have this steam item")]
	public SteamInventoryItem steamItem;

	[Tooltip("User can craft this item if they have this DLC purchased")]
	public SteamDLCItem steamDlc;

	[Tooltip("Can only craft this item if the parent is craftable (tech tree)")]
	public ItemDefinition Parent;

	[Header("World Model")]
	public GameObjectRef worldModelPrefab;

	public OverrideWorldModel[] worldModelOverrides;

	public bool treatAsComponentForRepairs;

	public bool AlignWorldModelOnDrop;

	public Vector3 WorldModelDropOffset;

	public bool AdjustCenterOfMassOnDrop;

	public Vector3 DropCenterOfMass;

	public ItemDefinition isRedirectOf;

	public RedirectVendingBehaviour redirectVendingBehaviour;

	[NonSerialized]
	public ItemMod[] itemMods;

	public BaseEntity.TraitFlag Traits;

	[NonSerialized]
	public ItemSkinDirectory.Skin[] skins;

	[NonSerialized]
	public IPlayerItemDefinition[] _skins2;

	private float _worldModelMass;

	[Tooltip("Panel to show in the inventory menu when selected")]
	public GameObject panel;

	[NonSerialized]
	public ItemDefinition[] Children = new ItemDefinition[0];

	public IPlayerItemDefinition[] skins2
	{
		get
		{
			if (_skins2 != null)
			{
				return _skins2;
			}
			if (PlatformService.Instance.IsValid && PlatformService.Instance.ItemDefinitions != null)
			{
				string prefabname = ((Object)this).name;
				_skins2 = PlatformService.Instance.ItemDefinitions.Where((IPlayerItemDefinition x) => (x.ItemShortName == shortname || x.ItemShortName == prefabname) && x.WorkshopId != 0).ToArray();
			}
			return _skins2;
		}
	}

	public ItemBlueprint Blueprint { get; private set; }

	public int craftingStackable => Mathf.Max(10, stackable);

	public bool isWearable => (Object)(object)ItemModWearable != (Object)null;

	public ItemModWearable ItemModWearable { get; set; }

	public ItemModBurnable ItemModBurnable { get; set; }

	public ItemModCookable ItemModCookable { get; set; }

	public bool isHoldable { get; private set; }

	public bool isUsable { get; private set; }

	public bool HasSkins
	{
		get
		{
			if (skins2 != null && skins2.Length != 0)
			{
				return true;
			}
			if (skins != null && skins.Length != 0)
			{
				return true;
			}
			return false;
		}
	}

	public bool CraftableWithSkin { get; private set; }

	public bool Hidden()
	{
		return hidden;
	}

	public void InvalidateWorkshopSkinCache()
	{
		_skins2 = null;
	}

	public bool IsAllowed(EraRestriction targetRestriction)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode != (Object)null && !activeGameMode.IsAllowed(this, targetRestriction))
		{
			return false;
		}
		return IsAllowedInEra(targetRestriction);
	}

	public bool IsAllowed(EraRestriction targetRestriction, Era serverEra)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode != (Object)null && !activeGameMode.IsAllowed(this, targetRestriction))
		{
			return false;
		}
		return IsAllowedInEra(targetRestriction, serverEra);
	}

	public bool IsAllowedInEra(EraRestriction targetRestriction)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		if ((int)ConVar.Server.Era == 0)
		{
			return true;
		}
		return IsAllowedInEra(targetRestriction, ConVar.Server.Era);
	}

	private bool IsAllowedInEra(EraRestriction targetRestriction, Era serverEra)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Invalid comparison between Unknown and I4
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if ((int)serverEra == 0)
		{
			return true;
		}
		if ((Object)(object)isRedirectOf != (Object)null)
		{
			return isRedirectOf.IsAllowedInEra(targetRestriction);
		}
		Era val = era;
		if ((int)val != 0)
		{
			if ((int)val == 1)
			{
				return true;
			}
			if (era <= serverEra)
			{
				if ((int)targetRestriction != 0 && (int)eraRestrictions != 0 && (EraRestriction)(eraRestrictions & targetRestriction) != eraRestrictions)
				{
					return false;
				}
				return true;
			}
			return false;
		}
		return true;
	}

	public static ulong FindSkin(int itemID, int skinID)
	{
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemID);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return 0uL;
		}
		IPlayerItemDefinition itemDefinition2 = PlatformService.Instance.GetItemDefinition(skinID);
		if (itemDefinition2 != null)
		{
			ulong workshopDownload = itemDefinition2.WorkshopDownload;
			if (workshopDownload != 0L)
			{
				string itemShortName = itemDefinition2.ItemShortName;
				if (itemShortName == itemDefinition.shortname || itemShortName == ((Object)itemDefinition).name)
				{
					return workshopDownload;
				}
			}
		}
		for (int i = 0; i < itemDefinition.skins.Length; i++)
		{
			if (itemDefinition.skins[i].id == skinID)
			{
				return (ulong)skinID;
			}
		}
		return 0uL;
	}

	public float GetWorldModelMass()
	{
		if (_worldModelMass != 0f)
		{
			return _worldModelMass;
		}
		GameObject val = worldModelPrefab?.Get();
		if ((Object)(object)val != (Object)null)
		{
			WorldModel component = val.GetComponent<WorldModel>();
			if ((Object)(object)component != (Object)null && component.mass != 0f)
			{
				_worldModelMass = component.mass;
				return _worldModelMass;
			}
		}
		_worldModelMass = 1f;
		return _worldModelMass;
	}

	public bool HasFlag(Flag f)
	{
		return (flags & f) == f;
	}

	public void Initialize(List<ItemDefinition> itemList)
	{
		if (itemMods != null)
		{
			Debug.LogError((object)("Item Definition Initializing twice: " + ((Object)this).name));
		}
		skins = ItemSkinDirectory.ForItem(this);
		itemMods = ((Component)this).GetComponentsInChildren<ItemMod>(true);
		ItemMod[] array = itemMods;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].ModInit();
		}
		Children = itemList.Where((ItemDefinition x) => (Object)(object)x.Parent == (Object)(object)this).ToArray();
		ItemModWearable = ((Component)this).GetComponent<ItemModWearable>();
		ItemModBurnable = ((Component)this).GetComponent<ItemModBurnable>();
		ItemModCookable = ((Component)this).GetComponent<ItemModCookable>();
		isHoldable = (Object)(object)((Component)this).GetComponent<ItemModEntity>() != (Object)null;
		isUsable = (Object)(object)((Component)this).GetComponent<ItemModEntity>() != (Object)null || (Object)(object)((Component)this).GetComponent<ItemModConsume>() != (Object)null;
		Blueprint = ((Component)this).GetComponent<ItemBlueprint>();
	}

	public GameObjectRef GetWorldModel(int amount)
	{
		if (worldModelOverrides == null || worldModelOverrides.Length == 0)
		{
			return worldModelPrefab;
		}
		for (int num = worldModelOverrides.Length - 1; num >= 0; num--)
		{
			if (amount >= worldModelOverrides[num].minStackSize)
			{
				return worldModelOverrides[num].worldModel;
			}
		}
		return worldModelPrefab;
	}

	public int GetWorldModelIndex(int amount)
	{
		if (worldModelOverrides == null || worldModelOverrides.Length == 0)
		{
			return -1;
		}
		for (int num = worldModelOverrides.Length - 1; num >= 0; num--)
		{
			if (amount >= worldModelOverrides[num].minStackSize)
			{
				return num;
			}
		}
		return -1;
	}

	public bool SupportsItemOwnership()
	{
		if (stackable != 1)
		{
			if (supportsStackableOwnership)
			{
				return Inventory.stackable_item_ownership;
			}
			return false;
		}
		return true;
	}
}


using System;

[Flags]
public enum LootDistributionModifierType
{
	None = 0,
	Firearm = 1,
	FirearmAmmunition = 2,
	Unused = int.MinValue
}


using System;
using UnityEngine;

[Serializable]
public struct Condition
{
	[Serializable]
	public class WorldSpawnCondition
	{
		public float fractionMin = 1f;

		public float fractionMax = 1f;
	}

	public bool enabled;

	[Tooltip("The maximum condition this item type can have, new items will start with this value")]
	public float max;

	[Tooltip("If false then item will destroy when condition reaches 0")]
	public bool repairable;

	[Tooltip("If true, never lose max condition when repaired")]
	public bool maintainMaxCondition;

	public bool ovenCondition;

	public WorldSpawnCondition foundCondition;

	public bool hideConditionBar;

	public GameObjectRef breakEffect;
}


using System;

[Serializable]
public class WorldSpawnCondition
{
	public float fractionMin = 1f;

	public float fractionMax = 1f;
}


using System;

[Serializable]
public struct OverrideWorldModel
{
	public GameObjectRef worldModel;

	public int minStackSize;
}


public enum RedirectVendingBehaviour
{
	NoListing,
	ListAsUniqueItem
}


using System;

[Flags]
public enum Flag
{
	NoDropping = 1,
	NotStraightToBelt = 2,
	NotAllowedInBelt = 4,
	Backpack = 8
}


public enum AmountType
{
	Count,
	Millilitre,
	Feet,
	Genetics,
	OxygenSeconds,
	Frequency,
	Generic,
	BagLimit,
	ShelterLimit,
	ContentCount,
	TurretLimit,
	NucleusGrades
}


public enum ItemCategory
{
	Weapon,
	Construction,
	Items,
	Resources,
	Attire,
	Tool,
	Medical,
	Food,
	Ammunition,
	Traps,
	Misc,
	All,
	Common,
	Component,
	Search,
	Favourite,
	Electrical,
	Fun
}


using System;

[Flags]
public enum ItemSlot
{
	None = 1,
	Barrel = 2,
	Silencer = 4,
	Scope = 8,
	UnderBarrel = 0x10,
	Magazine = 0x20,
	Internal = 0x40,
	InternalTargeting = 0x80
}


public enum ItemSelectionPanel
{
	None,
	Vessel,
	Modifications,
	GunInformation
}


using UnityEngine;

public class ItemSelector : PropertyAttribute
{
}


using UnityEngine;

public class ItemMod : MonoBehaviour
{
	protected ItemMod[] siblingMods;

	public virtual void ModInit()
	{
		siblingMods = ((Component)this).GetComponents<ItemMod>();
	}

	public virtual void OnItemCreated(Item item)
	{
	}

	public virtual void OnVirginItem(Item item, BasePlayer creatingPlayer)
	{
	}

	public virtual void ServerCommand(Item item, string command, BasePlayer player)
	{
	}

	public virtual void DoAction(Item item, BasePlayer player)
	{
	}

	public virtual void OnRemove(Item item)
	{
	}

	public virtual void OnParentChanged(Item item)
	{
	}

	public virtual void CollectedForCrafting(Item item, BasePlayer crafter)
	{
	}

	public virtual void ReturnedFromCancelledCraft(Item item, BasePlayer crafter)
	{
	}

	public virtual void OnAttacked(Item item, HitInfo info)
	{
	}

	public virtual void OnChanged(Item item)
	{
	}

	public virtual bool CanDoAction(Item item, BasePlayer player)
	{
		ItemMod[] array = siblingMods;
		for (int i = 0; i < array.Length; i++)
		{
			if (!array[i].Passes(item))
			{
				return false;
			}
		}
		return true;
	}

	public virtual bool Passes(Item item)
	{
		return true;
	}

	public virtual void OnRemovedFromWorld(Item item)
	{
	}

	public virtual void OnMovedToWorld(Item item)
	{
	}
}


using UnityEngine;

public class ItemModActionChange : ItemMod
{
	public ItemMod[] actions;

	public override void OnChanged(Item item)
	{
		if (!item.isServer)
		{
			return;
		}
		BasePlayer ownerPlayer = item.GetOwnerPlayer();
		ItemMod[] array = actions;
		foreach (ItemMod itemMod in array)
		{
			if (itemMod.CanDoAction(item, ownerPlayer))
			{
				itemMod.DoAction(item, ownerPlayer);
			}
		}
	}

	private void OnValidate()
	{
		if (actions == null)
		{
			Debug.LogWarning((object)"ItemModMenuOption: actions is null!", (Object)(object)((Component)this).gameObject);
		}
	}
}


using UnityEngine;

public class ItemModActionContainerChange : ItemMod
{
	public ItemMod[] actions;

	public override void OnParentChanged(Item item)
	{
		if (!item.isServer)
		{
			return;
		}
		BasePlayer ownerPlayer = item.GetOwnerPlayer();
		ItemMod[] array = actions;
		foreach (ItemMod itemMod in array)
		{
			if (itemMod.CanDoAction(item, ownerPlayer))
			{
				itemMod.DoAction(item, ownerPlayer);
			}
		}
	}

	private void OnValidate()
	{
		if (actions == null)
		{
			Debug.LogWarning((object)"ItemModMenuOption: actions is null!", (Object)(object)((Component)this).gameObject);
		}
	}
}


public class ItemModAlterCondition : ItemMod
{
	public float conditionChange;

	public override void DoAction(Item item, BasePlayer player)
	{
		if (item.amount >= 1)
		{
			if (conditionChange < 0f)
			{
				item.LoseCondition(conditionChange * -1f);
			}
			else
			{
				item.RepairCondition(conditionChange);
			}
		}
	}
}


public class ItemModAnimalEquipment : ItemMod
{
	public enum SlotType
	{
		Basic,
		Armor,
		Saddle,
		Bit,
		Feet,
		SaddleDouble
	}

	public BaseEntity.Flags WearableFlag;

	public bool hideHair;

	public ProtectionProperties animalProtection;

	public ProtectionProperties riderProtection;

	public int additionalInventorySlots;

	public float speedModifier;

	public float staminaUseModifier;

	public SlotType slot;
}


public enum SlotType
{
	Basic,
	Armor,
	Saddle,
	Bit,
	Feet,
	SaddleDouble
}


public class ItemModArmorInsert : ItemMod
{
	public ProtectionProperties protectionProperties;

	public float SpeedReduction;
}


using ProtoBuf;
using UnityEngine;

public abstract class ItemModAssociatedEntity<T> : ItemMod where T : BaseEntity
{
	public GameObjectRef entityPrefab;

	protected virtual bool AllowNullParenting => false;

	protected virtual bool AllowHeldEntityParenting => false;

	protected virtual bool ShouldAutoCreateEntity => true;

	protected virtual bool OwnedByParentPlayer => false;

	public override void OnItemCreated(Item item)
	{
		base.OnItemCreated(item);
		if (ShouldAutoCreateEntity)
		{
			CreateAssociatedEntity(item);
		}
	}

	public T CreateAssociatedEntity(Item item)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Expected O, but got Unknown
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		if (item.instanceData != null)
		{
			return null;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(entityPrefab.resourcePath, Vector3.zero);
		T component = ((Component)baseEntity).GetComponent<T>();
		OnAssociatedItemCreated(component);
		baseEntity.Spawn();
		item.instanceData = new InstanceData();
		item.instanceData.ShouldPool = false;
		item.instanceData.subEntity = baseEntity.net.ID;
		item.MarkDirty();
		return component;
	}

	protected virtual void OnAssociatedItemCreated(T ent)
	{
	}

	public override void OnRemove(Item item)
	{
		base.OnRemove(item);
		T associatedEntity = GetAssociatedEntity(item);
		if (Object.op_Implicit((Object)(object)associatedEntity))
		{
			associatedEntity.Kill();
		}
	}

	public override void OnMovedToWorld(Item item)
	{
		UpdateParent(item);
		base.OnMovedToWorld(item);
	}

	public override void OnRemovedFromWorld(Item item)
	{
		UpdateParent(item);
		base.OnRemovedFromWorld(item);
	}

	public void UpdateParent(Item item)
	{
		T associatedEntity = GetAssociatedEntity(item);
		if ((Object)(object)associatedEntity == (Object)null)
		{
			return;
		}
		BaseEntity entityForParenting = GetEntityForParenting(item);
		if ((Object)(object)entityForParenting == (Object)null)
		{
			if (AllowNullParenting)
			{
				associatedEntity.SetParent(null, worldPositionStays: false, sendImmediate: true);
			}
			if (OwnedByParentPlayer)
			{
				associatedEntity.OwnerID = 0uL;
			}
		}
		else if (entityForParenting.isServer && entityForParenting.IsFullySpawned())
		{
			associatedEntity.SetParent(entityForParenting, worldPositionStays: false, sendImmediate: true);
			if (OwnedByParentPlayer && entityForParenting is BasePlayer basePlayer)
			{
				associatedEntity.OwnerID = basePlayer.userID;
			}
		}
	}

	public override void OnParentChanged(Item item)
	{
		base.OnParentChanged(item);
		UpdateParent(item);
	}

	public BaseEntity GetEntityForParenting(Item item = null)
	{
		if (item != null)
		{
			Item item2 = item;
			Item parentItem = item.parentItem;
			if (parentItem != null && parentItem.IsBackpack())
			{
				item2 = item.parentItem;
			}
			BasePlayer ownerPlayer = item2.GetOwnerPlayer();
			if (Object.op_Implicit((Object)(object)ownerPlayer))
			{
				return ownerPlayer;
			}
			BaseEntity baseEntity = ((item2.parent == null) ? null : item2.parent.entityOwner);
			if ((Object)(object)baseEntity != (Object)null)
			{
				return baseEntity;
			}
			BaseEntity worldEntity = item2.GetWorldEntity();
			if (Object.op_Implicit((Object)(object)worldEntity))
			{
				return worldEntity;
			}
			if (AllowHeldEntityParenting && item.parentItem != null && (Object)(object)item.parentItem.GetHeldEntity() != (Object)null)
			{
				return item.parentItem.GetHeldEntity();
			}
			return null;
		}
		return null;
	}

	public static bool GetAssociatedEntity(Item item, out T result, bool isServer = true)
	{
		result = GetAssociatedEntity(item, isServer);
		return (Object)(object)result != (Object)null;
	}

	public static T GetAssociatedEntity(Item item, bool isServer = true)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if (item?.instanceData == null)
		{
			return null;
		}
		BaseNetworkable baseNetworkable = null;
		if (isServer)
		{
			baseNetworkable = BaseNetworkable.serverEntities.Find(item.instanceData.subEntity);
		}
		if (Object.op_Implicit((Object)(object)baseNetworkable))
		{
			return ((Component)baseNetworkable).GetComponent<T>();
		}
		return null;
	}
}


using System;
using UnityEngine;

public class ItemModBackpack : ItemMod
{
	public SoundDefinition ZipSound;

	[Header("Should the 'selected' panel be hidden when the backpack is selected when equipped")]
	public bool hideSelectedPanel;

	[Header("Backpack's item volume when items are in it")]
	public int containerVolumeWhenFilled = 1;

	public bool DropWhenDowned;

	public override void OnItemCreated(Item item)
	{
		base.OnItemCreated(item);
		if (item.contents != null)
		{
			ItemContainer contents = item.contents;
			contents.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(contents.canAcceptItem, (Func<Item, int, bool>)((Item subItem, int slot) => CanAcceptItem(item, subItem, slot)));
		}
	}

	public bool CanAcceptItem(Item backpack, Item item, int slot)
	{
		if (backpack.parent == null)
		{
			return true;
		}
		if (backpack.parent.HasFlag(ItemContainer.Flag.Clothing))
		{
			return true;
		}
		return false;
	}
}


using UnityEngine;

public class ItemModBaitContainer : ItemModContainer
{
	protected override bool ForceAcceptItemCheck => true;

	protected override bool CanAcceptItem(Item item, int count)
	{
		ItemModCompostable component = ((Component)item.info).GetComponent<ItemModCompostable>();
		if ((Object)(object)component != (Object)null)
		{
			return component.BaitValue > 0f;
		}
		return false;
	}

	protected override void SetAllowedItems(ItemContainer container)
	{
		FishLookup.LoadFish();
		container.SetOnlyAllowedItems(FishLookup.BaitItems);
	}
}


using UnityEngine;

public class ItemModBlueprintCraft : ItemMod
{
	public static readonly Phrase CraftItemTitle = new Phrase("craft_item", "Craft");

	public static readonly Phrase CraftItemDesc = new Phrase("craft_item_desc", "Create the item the blueprint is referring to");

	public static readonly Phrase CraftAllTitle = new Phrase("craft_all", "Craft All");

	public static readonly Phrase CraftAllDesc = new Phrase("craft_all_desc", "Craft all available blueprints into items");

	public GameObjectRef successEffect;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)item.GetOwnerPlayer() != (Object)(object)player)
		{
			return;
		}
		if (command == "craft")
		{
			if (!item.IsBlueprint() || !player.inventory.crafting.CanCraft(item.blueprintTargetDef.Blueprint))
			{
				return;
			}
			Item fromTempBlueprint = item;
			if (item.amount > 1)
			{
				fromTempBlueprint = item.SplitItem(1);
			}
			player.inventory.crafting.CraftItem(item.blueprintTargetDef.Blueprint, player, null, 1, 0, fromTempBlueprint);
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
		if (command == "craft_all" && item.IsBlueprint() && player.inventory.crafting.CanCraft(item.blueprintTargetDef.Blueprint, item.amount))
		{
			player.inventory.crafting.CraftItem(item.blueprintTargetDef.Blueprint, player, null, item.amount, 0, item);
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}
}


public class ItemModBurnable : ItemMod
{
	public float fuelAmount = 10f;

	[ItemSelector]
	public ItemDefinition byproductItem;

	public int byproductAmount = 1;

	public float byproductChance = 0.5f;

	public override void OnItemCreated(Item item)
	{
		item.fuel = fuelAmount;
	}
}


public class ItemModCassetteContainer : ItemModContainer
{
	public ItemDefinition[] CassetteItems;

	protected override bool ForceAcceptItemCheck => true;

	protected override void SetAllowedItems(ItemContainer container)
	{
		container.SetOnlyAllowedItems(CassetteItems);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class ItemModCatapultBoulder : MonoBehaviour
{
	[Serializable]
	public struct ProjectileSettings
	{
		public GameObjectRef prefab;

		public int count;

		public float gravityModifier;
	}

	[SerializeField]
	public List<ProjectileSettings> projectileSettings = new List<ProjectileSettings>();

	public float spreadAngle = 6f;
}


using System;

[Serializable]
public struct ProjectileSettings
{
	public GameObjectRef prefab;

	public int count;

	public float gravityModifier;
}


public class ItemModChildIO : ItemMod
{
	public GameObjectRef TargetChildIO;
}


using UnityEngine;

public class ItemModCompostable : MonoBehaviour
{
	public float TotalFertilizerProduced = 0.2f;

	public float BaitValue = 1f;

	public int MaxBaitStack;
}


public class ItemModConditionContainerFlag : ItemMod
{
	public ItemContainer.Flag flag;

	public bool requiredState;

	public override bool Passes(Item item)
	{
		if (item.parent == null)
		{
			return !requiredState;
		}
		if (!item.parent.HasFlag(flag))
		{
			return !requiredState;
		}
		return requiredState;
	}
}


using UnityEngine;

public class ItemModConditionHasCondition : ItemMod
{
	public float conditionTarget = 1f;

	[Tooltip("If set to above 0 will check for fraction instead of raw value")]
	public float conditionFractionTarget = -1f;

	public bool lessThan;

	public override bool Passes(Item item)
	{
		if (!item.hasCondition)
		{
			return false;
		}
		if (conditionFractionTarget > 0f)
		{
			if (lessThan || !(item.conditionNormalized > conditionFractionTarget))
			{
				if (lessThan)
				{
					return item.conditionNormalized < conditionFractionTarget;
				}
				return false;
			}
			return true;
		}
		if (lessThan || !(item.condition >= conditionTarget))
		{
			if (lessThan)
			{
				return item.condition < conditionTarget;
			}
			return false;
		}
		return true;
	}
}


using System.Linq;
using UnityEngine;

public class ItemModConditionHasContents : ItemMod
{
	[Tooltip("Can be null to mean any item")]
	public ItemDefinition itemDef;

	public bool requiredState;

	public override bool Passes(Item item)
	{
		if (item.contents == null)
		{
			return !requiredState;
		}
		if (item.contents.itemList.Count == 0)
		{
			return !requiredState;
		}
		if (Object.op_Implicit((Object)(object)itemDef) && !item.contents.itemList.Any((Item x) => (Object)(object)x.info == (Object)(object)itemDef))
		{
			return !requiredState;
		}
		return requiredState;
	}
}


public class ItemModConditionHasFlag : ItemMod
{
	public Item.Flag flag;

	public bool requiredState;

	public override bool Passes(Item item)
	{
		return item.HasFlag(flag) == requiredState;
	}
}


using UnityEngine;

public class ItemModConditionInWater : ItemMod
{
	public bool requiredState;

	public override bool Passes(Item item)
	{
		BasePlayer ownerPlayer = item.GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null)
		{
			return false;
		}
		return ownerPlayer.IsHeadUnderwater() == requiredState;
	}
}


using UnityEngine;

public class ItemModConditionIsSleeping : ItemMod
{
	public bool requiredState;

	public override bool Passes(Item item)
	{
		BasePlayer ownerPlayer = item.GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null)
		{
			return false;
		}
		return ownerPlayer.IsSleeping() == requiredState;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class ItemModConsumable : MonoBehaviour
{
	[Serializable]
	public class ConsumableEffect
	{
		public MetabolismAttribute.Type type;

		public float amount;

		public float time;

		public float onlyIfHealthLessThan = 1f;
	}

	public int amountToConsume = 1;

	public float conditionFractionToLose;

	public string achievementWhenEaten;

	public bool chickenCoopFood;

	public List<ConsumableEffect> effects = new List<ConsumableEffect>();

	public List<ModifierDefintion> modifiers = new List<ModifierDefintion>();

	public float GetIfType(MetabolismAttribute.Type typeToPick)
	{
		for (int i = 0; i < effects.Count; i++)
		{
			if (effects[i].type == typeToPick)
			{
				return effects[i].amount;
			}
		}
		return 0f;
	}
}


using System;

[Serializable]
public class ConsumableEffect
{
	public MetabolismAttribute.Type type;

	public float amount;

	public float time;

	public float onlyIfHealthLessThan = 1f;
}


using Facepunch.Rust;
using Oxide.Core;
using Rust;
using UnityEngine;

[RequireComponent(typeof(ItemModConsumable))]
public class ItemModConsume : ItemMod
{
	public GameObjectRef consumeEffect;

	public string eatGesture = "eat_2hand";

	[Tooltip("Items that are given on consumption of this item")]
	public ItemAmountRandom[] product;

	public ItemModConsumable primaryConsumable;

	public virtual ItemModConsumable GetConsumable()
	{
		if (Object.op_Implicit((Object)(object)primaryConsumable))
		{
			return primaryConsumable;
		}
		return ((Component)this).GetComponent<ItemModConsumable>();
	}

	public virtual GameObjectRef GetConsumeEffect()
	{
		return consumeEffect;
	}

	public override void DoAction(Item item, BasePlayer player)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		if (item.amount < 1)
		{
			return;
		}
		GameObjectRef gameObjectRef = GetConsumeEffect();
		if (gameObjectRef.isValid)
		{
			Vector3 posLocal = (player.IsDucked() ? new Vector3(0f, 1f, 0f) : new Vector3(0f, 2f, 0f));
			Effect.server.Run(gameObjectRef.resourcePath, player, 0u, posLocal, Vector3.zero);
		}
		player.metabolism.MarkConsumption();
		ItemModConsumable consumable = GetConsumable();
		if (!string.IsNullOrEmpty(consumable.achievementWhenEaten))
		{
			player.GiveAchievement(consumable.achievementWhenEaten);
		}
		Analytics.Azure.OnConsumableUsed(player, item);
		float num = Mathf.Max(consumable.amountToConsume, 1);
		float num2 = Mathf.Min((float)item.amount, num);
		float num3 = num2 / num;
		float num4 = item.conditionNormalized;
		if (consumable.conditionFractionToLose > 0f)
		{
			num4 = consumable.conditionFractionToLose;
		}
		foreach (ItemModConsumable.ConsumableEffect effect in consumable.effects)
		{
			if (Mathf.Clamp01(player.healthFraction + player.metabolism.pending_health.Fraction()) > effect.onlyIfHealthLessThan)
			{
				continue;
			}
			if (effect.type == MetabolismAttribute.Type.Health)
			{
				if (effect.amount < 0f)
				{
					player.OnAttacked(new HitInfo(player, player, DamageType.Generic, (0f - effect.amount) * num3 * num4, ((Component)player).transform.position + ((Component)player).transform.forward * 1f));
				}
				else
				{
					player.health += effect.amount * num3 * num4;
				}
			}
			else
			{
				player.metabolism.ApplyChange(effect.type, effect.amount * num3 * num4, effect.time * num3 * num4);
			}
		}
		player.ProcessMissionEvent(BaseMission.MissionEventType.CONSUME, item.info.itemid, 1f);
		if ((Object)(object)player.modifiers != (Object)null && Interface.CallHook("OnPlayerAddModifiers", (object)player, (object)item, (object)consumable) == null)
		{
			player.modifiers.Add(consumable.modifiers);
		}
		if (product != null)
		{
			ItemAmountRandom[] array = product;
			foreach (ItemAmountRandom itemAmountRandom in array)
			{
				int num5 = Mathf.RoundToInt((float)itemAmountRandom.RandomAmount() * num4);
				if (num5 > 0)
				{
					Item item2 = ItemManager.Create(itemAmountRandom.itemDef, num5, 0uL);
					player.GiveItem(item2);
				}
			}
		}
		if (string.IsNullOrEmpty(eatGesture))
		{
			player.SignalBroadcast(BaseEntity.Signal.Gesture, eatGesture);
		}
		if (consumable.conditionFractionToLose > 0f)
		{
			item.LoseCondition(consumable.conditionFractionToLose * item.maxCondition);
		}
		else
		{
			item.UseItem((int)num2);
		}
	}

	public override bool CanDoAction(Item item, BasePlayer player)
	{
		return player.metabolism.CanConsume();
	}
}


using UnityEngine;

public class ItemModConsumeChance : ItemModConsume
{
	public float chanceForSecondaryConsume = 0.5f;

	public GameObjectRef secondaryConsumeEffect;

	public ItemModConsumable secondaryConsumable;

	private bool GetChance()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		State state = Random.state;
		Random.InitState(Time.frameCount);
		bool result = Random.Range(0f, 1f) <= chanceForSecondaryConsume;
		Random.state = state;
		return result;
	}

	public override ItemModConsumable GetConsumable()
	{
		if (GetChance())
		{
			return secondaryConsumable;
		}
		return base.GetConsumable();
	}

	public override GameObjectRef GetConsumeEffect()
	{
		if (GetChance())
		{
			return secondaryConsumeEffect;
		}
		return base.GetConsumeEffect();
	}
}


using UnityEngine;

public class ItemModConsumeContents : ItemMod
{
	public GameObjectRef consumeEffect;

	public override void DoAction(Item item, BasePlayer player)
	{
		foreach (Item item2 in item.contents.itemList)
		{
			ItemModConsume component = ((Component)item2.info).GetComponent<ItemModConsume>();
			if (!((Object)(object)component == (Object)null) && component.CanDoAction(item2, player))
			{
				component.DoAction(item2, player);
				item.contents?.onItemRemovedFromStack?.Invoke(item2, 0);
				break;
			}
		}
	}

	public override bool CanDoAction(Item item, BasePlayer player)
	{
		if (!player.metabolism.CanConsume())
		{
			return false;
		}
		if (item.contents == null)
		{
			return false;
		}
		foreach (Item item2 in item.contents.itemList)
		{
			ItemModConsume component = ((Component)item2.info).GetComponent<ItemModConsume>();
			if (!((Object)(object)component == (Object)null) && component.CanDoAction(item2, player))
			{
				return true;
			}
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

public class ItemModContainer : ItemMod
{
	public int capacity = 6;

	public int maxStackSize;

	public int containerVolume;

	public bool canLootInWorld;

	public float pickupInWorldDelay;

	public float maxWeight = -1f;

	public float worldWeightScale = 1f;

	[InspectorFlags]
	public ItemContainer.Flag containerFlags;

	public ItemContainer.ContentsType onlyAllowedContents = ItemContainer.ContentsType.Generic;

	public ItemDefinition onlyAllowedItemType;

	public List<ItemSlot> availableSlots = new List<ItemSlot>();

	public ItemDefinition[] validItemWhitelist = new ItemDefinition[0];

	public bool openInDeployed = true;

	public bool openInInventory = true;

	public List<ItemAmount> defaultContents = new List<ItemAmount>();

	[Tooltip("If true items in this container won't be usable as ammo for reloads")]
	public bool blockAmmoSource;

	[Header("Sounds")]
	public SoundDefinition openSound;

	public SoundDefinition closeSound;

	protected virtual bool ForceAcceptItemCheck => false;

	public override void OnItemCreated(Item item)
	{
		CreateContents(item);
	}

	protected void CreateContents(Item item)
	{
		if (!item.isServer || capacity <= 0)
		{
			return;
		}
		if (item.contents != null)
		{
			if (validItemWhitelist != null && validItemWhitelist.Length != 0)
			{
				item.contents.canAcceptItem = CanAcceptItem;
			}
			return;
		}
		Debug.Assert(item.contents == null, "Double init of contents!");
		item.contents = Pool.Get<ItemContainer>();
		item.contents.flags = containerFlags;
		item.contents.allowedContents = ((onlyAllowedContents == (ItemContainer.ContentsType)0) ? ItemContainer.ContentsType.Generic : onlyAllowedContents);
		SetAllowedItems(item.contents);
		item.contents.UpdateAvailableSlots(availableSlots);
		ItemContainer contents = item.contents;
		contents.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(contents.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedOrRemoved));
		if ((validItemWhitelist != null && validItemWhitelist.Length != 0) || ForceAcceptItemCheck)
		{
			item.contents.canAcceptItem = CanAcceptItem;
		}
		item.contents.ServerInitialize(item, capacity);
		item.contents.containerVolume = containerVolume;
		item.contents.maxStackSize = maxStackSize;
		item.contents.GiveUID();
	}

	protected virtual void SetAllowedItems(ItemContainer container)
	{
		container.SetOnlyAllowedItem(onlyAllowedItemType);
	}

	protected virtual bool CanAcceptItem(Item item, int count)
	{
		ItemDefinition[] array = validItemWhitelist;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].itemid == item.info.itemid)
			{
				return true;
			}
		}
		return false;
	}

	private void OnItemAddedOrRemoved(Item item, bool added)
	{
		if (!Application.isLoadingSave)
		{
			DroppedItem droppedItem = item.parentItem?.GetWorldEntity() as DroppedItem;
			if (!((Object)(object)droppedItem == (Object)null))
			{
				droppedItem.UpdateItemMass();
			}
		}
	}

	public override void OnVirginItem(Item item, BasePlayer creatingPlayer)
	{
		base.OnVirginItem(item, creatingPlayer);
		foreach (ItemAmount defaultContent in defaultContents)
		{
			ItemManager.Create(defaultContent.itemDef, (int)defaultContent.amount, 0uL)?.MoveToContainer(item.contents);
		}
	}

	public override void CollectedForCrafting(Item item, BasePlayer crafter)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (item.contents == null)
		{
			return;
		}
		for (int num = item.contents.itemList.Count - 1; num >= 0; num--)
		{
			Item item2 = item.contents.itemList[num];
			if (!item2.MoveToContainer(crafter.inventory.containerMain))
			{
				item2.Drop(crafter.GetDropPosition(), crafter.GetDropVelocity());
			}
		}
	}
}


using Rust;
using UnityEngine;

public class ItemModContainerArmorSlot : ItemModContainer
{
	public int MinSlots;

	public int MaxSlots = 3;

	public bool CraftedItemsOnly = true;

	private static float[] RollChances = new float[3] { 0.25f, 0.1f, 0.05f };

	public override void OnVirginItem(Item item, BasePlayer creatingPlayer)
	{
		if (item.isServer)
		{
			base.OnVirginItem(item, creatingPlayer);
			CreateForPlayer(item, creatingPlayer);
		}
	}

	private static int GetRandomSlotCount(float improveChance, int min, int max)
	{
		float num = Random.Range(0f, 1f - improveChance);
		int num2 = 0;
		if (num <= 0.5f || improveChance > 0f)
		{
			num2 = min;
			for (int i = 0; i < max - min && num <= RollChances[Mathf.Clamp(i, 0, RollChances.Length)]; i++)
			{
				num2++;
			}
		}
		return num2;
	}

	public void CreateForPlayer(Item item, BasePlayer player)
	{
		if (!((Object)(object)player == (Object)null) || !CraftedItemsOnly)
		{
			int cap = 0;
			if ((Object)(object)player != (Object)null)
			{
				cap = GetRandomSlotCount(Mathf.Clamp01(player.modifiers.GetValue(Modifier.ModifierType.Crafting_Quality)), MinSlots, MaxSlots);
			}
			CreateAtCapacity(cap, item);
		}
	}

	public void SetSlotAmount(Item item, int amount)
	{
		if (item.contents != null)
		{
			item.contents.capacity = amount;
			item.MarkDirty();
		}
		else
		{
			CreateAtCapacity(amount, item);
		}
	}

	public void CreateAtCapacity(int cap, Item item)
	{
		capacity = cap;
		if (capacity != 0)
		{
			CreateContents(item);
			if (item != null && item.contents != null)
			{
				item.contents.canAcceptItem = CanAcceptArmorItem;
			}
		}
	}

	public override void OnItemCreated(Item item)
	{
		if (capacity > 0 && item != null && item.contents != null)
		{
			item.contents.canAcceptItem = CanAcceptArmorItem;
		}
	}

	protected bool CanAcceptArmorItem(Item item, int count)
	{
		if (item == null || (Object)(object)item.info == (Object)null)
		{
			return false;
		}
		if ((Object)(object)((Component)item.info).GetComponent<ItemModArmorInsert>() == (Object)null)
		{
			return false;
		}
		return true;
	}

	public float TotalSpeedReduction(Item item)
	{
		if (item == null)
		{
			return 0f;
		}
		if (item.contents == null)
		{
			return 0f;
		}
		if (item.contents.itemList == null)
		{
			return 0f;
		}
		float num = 0f;
		ItemModArmorInsert itemModArmorInsert = default(ItemModArmorInsert);
		foreach (Item item2 in item.contents.itemList)
		{
			if (((Component)item2.info).TryGetComponent<ItemModArmorInsert>(ref itemModArmorInsert))
			{
				num += itemModArmorInsert.SpeedReduction;
			}
		}
		return num;
	}

	public float GetProtection(Item item, DamageType damageType)
	{
		if (item == null)
		{
			return 0f;
		}
		if (item.contents == null)
		{
			return 0f;
		}
		if (item.contents.itemList == null)
		{
			return 0f;
		}
		float num = 0f;
		ItemModArmorInsert itemModArmorInsert = default(ItemModArmorInsert);
		foreach (Item item2 in item.contents.itemList)
		{
			if (((Component)item2.info).TryGetComponent<ItemModArmorInsert>(ref itemModArmorInsert))
			{
				num += itemModArmorInsert.protectionProperties.amounts[(int)damageType];
			}
		}
		return num;
	}

	public void CollectProtection(Item item, ProtectionProperties protection)
	{
		if (item == null || item.contents == null || (Object)(object)protection == (Object)null)
		{
			return;
		}
		ItemModArmorInsert itemModArmorInsert = default(ItemModArmorInsert);
		foreach (Item item2 in item.contents.itemList)
		{
			if (((Component)item2.info).TryGetComponent<ItemModArmorInsert>(ref itemModArmorInsert) && !((Object)(object)itemModArmorInsert.protectionProperties == (Object)null))
			{
				protection.Add(itemModArmorInsert.protectionProperties, 1f);
			}
		}
	}
}


using System;

public class ItemModContainerRads : ItemModContainer
{
	public override void OnItemCreated(Item item)
	{
		base.OnItemCreated(item);
		if (item != null && item.contents != null)
		{
			CountRads(item.contents);
			ItemContainer contents = item.contents;
			contents.onItemParentChanged = (Action<Item, Item>)Delegate.Combine(contents.onItemParentChanged, new Action<Item, Item>(OnItemParentChanged));
			ItemContainer contents2 = item.contents;
			contents2.onItemRadiationChanged = (Action<Item, float>)Delegate.Combine(contents2.onItemRadiationChanged, new Action<Item, float>(OnItemRadiationChanged));
			ItemContainer contents3 = item.contents;
			contents3.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(contents3.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
			ItemContainer contents4 = item.contents;
			contents4.onItemAddedToStack = (Action<Item, int>)Delegate.Combine(contents4.onItemAddedToStack, new Action<Item, int>(OnItemAddedToStack));
			ItemContainer contents5 = item.contents;
			contents5.onItemRemovedFromStack = (Action<Item, int>)Delegate.Combine(contents5.onItemRemovedFromStack, new Action<Item, int>(OnItemRemovedFromStack));
		}
	}

	public override void OnRemove(Item item)
	{
		base.OnRemove(item);
		if (item != null && item.contents != null)
		{
			ItemContainer contents = item.contents;
			contents.onItemParentChanged = (Action<Item, Item>)Delegate.Remove(contents.onItemParentChanged, new Action<Item, Item>(OnItemParentChanged));
			ItemContainer contents2 = item.contents;
			contents2.onItemRadiationChanged = (Action<Item, float>)Delegate.Remove(contents2.onItemRadiationChanged, new Action<Item, float>(OnItemRadiationChanged));
			ItemContainer contents3 = item.contents;
			contents3.onItemAddedRemoved = (Action<Item, bool>)Delegate.Remove(contents3.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
			ItemContainer contents4 = item.contents;
			contents4.onItemAddedToStack = (Action<Item, int>)Delegate.Remove(contents4.onItemAddedToStack, new Action<Item, int>(OnItemAddedToStack));
			ItemContainer contents5 = item.contents;
			contents5.onItemRemovedFromStack = (Action<Item, int>)Delegate.Remove(contents5.onItemRemovedFromStack, new Action<Item, int>(OnItemRemovedFromStack));
		}
	}

	public override void OnParentChanged(Item item)
	{
		ProcessRadCountFromParent(item);
	}

	private void OnItemParentChanged(Item parent, Item child)
	{
		ProcessRadCountFromParent(parent);
	}

	private void OnItemRadiationChanged(Item item, float rads)
	{
		ProcessRadCountFromChild(item);
	}

	private void OnItemAddedRemoved(Item childItem, bool added)
	{
		if (childItem != null)
		{
			ProcessRadCountFromChild(childItem);
		}
	}

	private void OnItemRemovedFromStack(Item childItem, int amount)
	{
		ProcessRadCountFromChild(childItem);
	}

	private void OnItemAddedToStack(Item childItem, int amount)
	{
		ProcessRadCountFromChild(childItem);
	}

	private void ProcessRadCountFromChild(Item childItem)
	{
		ItemContainer parent = childItem.parent;
		if (parent != null)
		{
			CountRads(parent);
		}
	}

	private void ProcessRadCountFromParent(Item item, bool skipEvent = false)
	{
		ItemContainer contents = item.contents;
		if (contents != null)
		{
			CountRads(contents, skipEvent);
		}
	}

	private void CountRads(ItemContainer container, bool skipEvent = false)
	{
		Item parent = container.parent;
		if (container?.itemList == null)
		{
			return;
		}
		if (container.itemList.Count == 0)
		{
			parent.radioactivity = 0f;
			if (!skipEvent)
			{
				parent.parent?.onItemRadiationChanged?.Invoke(parent, 0f);
			}
		}
		else
		{
			if (container.itemList[0] == null)
			{
				return;
			}
			float num = 0f;
			foreach (Item item in container.itemList)
			{
				num += (float)item.amount * item.radioactivity;
			}
			if (parent == null)
			{
				return;
			}
			if (num > 0f)
			{
				if (!parent.HasFlag(Item.Flag.Radioactive))
				{
					parent.SetFlag(Item.Flag.Radioactive, b: true);
				}
			}
			else if (parent.HasFlag(Item.Flag.Radioactive))
			{
				parent.SetFlag(Item.Flag.Radioactive, b: false);
			}
			parent.radioactivity = num;
			if (parent.parent != null && !skipEvent)
			{
				parent.parent.onItemRadiationChanged?.Invoke(parent, num);
			}
		}
	}
}


using System;
using UnityEngine;

public class ItemModContainerRestriction : ItemMod
{
	[Flags]
	public enum SlotFlags
	{
		Map = 1
	}

	[InspectorFlags]
	public SlotFlags slotFlags;

	public bool CanExistWith(ItemModContainerRestriction other)
	{
		if ((Object)(object)other == (Object)null)
		{
			return true;
		}
		if ((slotFlags & other.slotFlags) != 0)
		{
			return false;
		}
		return true;
	}
}


using System;

[Flags]
public enum SlotFlags
{
	Map = 1
}


using UnityEngine;

public class ItemModConversation : ItemMod
{
	public static readonly Phrase SquakTitle = new Phrase("squak", "MISSING SQUAK PHRASE");

	public static readonly Phrase SquakDesc = new Phrase("squak_desc", "MISSING SQUAK DESC PHRASE");

	public ConversationData conversationData;

	public GameObjectRef conversationEntity;

	public GameObjectRef squakEffect;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		if (command == "squak")
		{
			if (squakEffect.isValid)
			{
				Effect.server.Run(squakEffect.resourcePath, player.eyes.position);
			}
			Debug.Log((object)"Starting conversation");
			BaseEntity baseEntity = GameManager.server.CreateEntity(conversationEntity.resourcePath, ((Component)player).transform.position + Vector3.up * -2f);
			((Component)baseEntity).GetComponent<NPCMissionProvider>().conversations[0] = conversationData;
			baseEntity.Spawn();
			((MonoBehaviour)baseEntity).Invoke("Kill", 600f);
		}
	}
}


public class ItemModConveyorOptions : ItemMod
{
	public bool ForceShowInConveyorFilter;
}


using Facepunch.Rust;
using UnityEngine;

public class ItemModCookable : ItemMod
{
	[ItemSelector]
	public ItemDefinition becomeOnCooked;

	public float cookTime = 30f;

	public int amountOfBecome = 1;

	public int lowTemp;

	public int highTemp;

	public bool setCookingFlag;

	public void OnValidate()
	{
		if (amountOfBecome < 1)
		{
			amountOfBecome = 1;
		}
		if ((Object)(object)becomeOnCooked == (Object)null)
		{
			Debug.LogWarning((object)("[ItemModCookable] becomeOnCooked is unset! [" + ((Object)this).name + "]"), (Object)(object)((Component)this).gameObject);
		}
	}

	public bool CanBeCookedByAtTemperature(float temperature)
	{
		if (temperature > (float)lowTemp)
		{
			return temperature < (float)highTemp;
		}
		return false;
	}

	private void CycleCooking(Item item, float delta)
	{
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		if (!CanBeCookedByAtTemperature(item.temperature) || item.cookTimeLeft < 0f)
		{
			if (setCookingFlag && item.HasFlag(Item.Flag.Cooking))
			{
				item.SetFlag(Item.Flag.Cooking, b: false);
				item.MarkDirty();
			}
			return;
		}
		if (setCookingFlag && !item.HasFlag(Item.Flag.Cooking))
		{
			item.SetFlag(Item.Flag.Cooking, b: true);
			item.MarkDirty();
		}
		item.cookTimeLeft -= delta;
		if (item.cookTimeLeft > 0f)
		{
			item.MarkDirty();
			return;
		}
		float num = item.cookTimeLeft * -1f;
		int num2 = 1 + Mathf.FloorToInt(num / cookTime);
		item.cookTimeLeft = cookTime - num % cookTime;
		BaseOven baseOven = item.GetEntityOwner() as BaseOven;
		num2 = Mathf.Min(num2, item.amount);
		if (item.amount > num2)
		{
			item.amount -= num2;
			item.MarkDirty();
		}
		else
		{
			item.Remove();
		}
		Analytics.Azure.AddPendingItems(baseOven, item.info.shortname, num2, "smelt");
		if (!((Object)(object)becomeOnCooked != (Object)null))
		{
			return;
		}
		Item item2 = ItemManager.Create(becomeOnCooked, amountOfBecome * num2, 0uL);
		Analytics.Azure.AddPendingItems(baseOven, item2.info.shortname, item2.amount, "smelt", consumed: false);
		if ((Object)(object)item.parent.entityOwner != (Object)null && item.parent.entityOwner.net.group.restricted)
		{
			TutorialIsland closestTutorialIsland = TutorialIsland.GetClosestTutorialIsland(((Component)item.parent.entityOwner).transform.position, 50f);
			if ((Object)(object)closestTutorialIsland != (Object)null)
			{
				BasePlayer basePlayer = closestTutorialIsland.ForPlayer.Get(serverside: true);
				if ((Object)(object)basePlayer != (Object)null)
				{
					basePlayer.ProcessMissionEvent(BaseMission.MissionEventType.COOK, new BaseMission.MissionEventPayload
					{
						IntIdentifier = item2.info.itemid,
						WorldPosition = ((Component)item.parent.entityOwner).transform.position,
						NetworkIdentifier = item.parent.entityOwner.net.ID
					}, item2.amount);
				}
			}
		}
		if (item2 != null && !item2.MoveToContainer(item.parent) && !item2.MoveToContainer(item.parent))
		{
			item2.Drop(item.parent.dropPosition, item.parent.dropVelocity);
			if (Object.op_Implicit((Object)(object)item.parent.entityOwner) && (Object)(object)baseOven != (Object)null)
			{
				baseOven.OvenFull();
			}
		}
	}

	public override void OnItemCreated(Item itemcreated)
	{
		itemcreated.cookTimeLeft = cookTime;
		itemcreated.onCycle += CycleCooking;
	}
}


using UnityEngine;

public class ItemModCycle : ItemMod
{
	public ItemMod[] actions;

	public float timeBetweenCycles = 1f;

	public float timerStart;

	public bool onlyAdvanceTimerWhenPass;

	public override void OnItemCreated(Item itemcreated)
	{
		float timeTaken = timerStart;
		itemcreated.onCycle += delegate(Item item, float delta)
		{
			if (!onlyAdvanceTimerWhenPass || CanCycle(item))
			{
				timeTaken += delta;
				if (!(timeTaken < timeBetweenCycles))
				{
					timeTaken = 0f;
					if (onlyAdvanceTimerWhenPass || CanCycle(item))
					{
						CustomCycle(item, delta);
					}
				}
			}
		};
	}

	private bool CanCycle(Item item)
	{
		ItemMod[] array = actions;
		for (int i = 0; i < array.Length; i++)
		{
			if (!array[i].CanDoAction(item, item.GetOwnerPlayer()))
			{
				return false;
			}
		}
		return true;
	}

	public void CustomCycle(Item item, float delta)
	{
		BasePlayer ownerPlayer = item.GetOwnerPlayer();
		ItemMod[] array = actions;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].DoAction(item, ownerPlayer);
		}
	}

	private void OnValidate()
	{
		if (actions == null)
		{
			Debug.LogWarning((object)"ItemModMenuOption: actions is null", (Object)(object)((Component)this).gameObject);
		}
	}
}


using Oxide.Core;
using UnityEngine;

public class ItemModDeployable : MonoBehaviour
{
	public GameObjectRef entityPrefab = new GameObjectRef();

	[Header("Tooltips")]
	public bool showCrosshair;

	public string UnlockAchievement;

	public Deployable GetDeployable(BaseEntity entity)
	{
		if ((Object)(object)entity.gameManager.FindPrefab(entityPrefab.resourcePath) == (Object)null)
		{
			return null;
		}
		return entity.prefabAttribute.Find<Deployable>(entityPrefab.resourceID);
	}

	internal void OnDeployed(BaseEntity ent, BasePlayer player)
	{
		if (player.IsValid() && !string.IsNullOrEmpty(UnlockAchievement))
		{
			player.GiveAchievement(UnlockAchievement);
		}
		if (ent is BuildingPrivlidge buildingPrivlidge && Interface.CallHook("OnCupboardAuthorize", (object)buildingPrivlidge, (object)player) == null)
		{
			buildingPrivlidge.AddPlayer(player, player.userID);
		}
	}
}


using UnityEngine;

public class ItemModEntity : ItemMod
{
	public GameObjectRef entityPrefab = new GameObjectRef();

	public string defaultBone;

	public bool playerOnlyEntity;

	public bool destroyEntityWhenBroken;

	public override void OnChanged(Item item)
	{
		HeldEntity heldEntity = item.GetHeldEntity() as HeldEntity;
		if ((Object)(object)heldEntity != (Object)null)
		{
			heldEntity.OnItemChanged(item);
		}
		base.OnChanged(item);
	}

	public override void OnItemCreated(Item item)
	{
		if ((Object)(object)item.GetHeldEntity() == (Object)null && !playerOnlyEntity)
		{
			CreateEntity(item);
		}
	}

	private void CreateEntity(Item item)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (!destroyEntityWhenBroken || !item.isBroken)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(entityPrefab.resourcePath);
			if ((Object)(object)baseEntity == (Object)null)
			{
				Debug.LogWarning((object)("Couldn't create item entity " + item.info.displayName.english + " (" + entityPrefab.resourcePath + ")"));
			}
			else
			{
				baseEntity.skinID = item.skin;
				baseEntity.limitNetworking = true;
				baseEntity.Spawn();
				item.SetHeldEntity(baseEntity);
			}
		}
	}

	public override void OnRemove(Item item)
	{
		BaseEntity heldEntity = item.GetHeldEntity();
		if (!((Object)(object)heldEntity == (Object)null))
		{
			heldEntity.Kill();
			item.SetHeldEntity(null);
		}
	}

	private bool ParentToParent(Item item, BaseEntity ourEntity)
	{
		Item parentItem = item.parentItem;
		if (parentItem == null)
		{
			return false;
		}
		if (parentItem.IsBackpack())
		{
			return false;
		}
		BaseEntity baseEntity = parentItem.GetWorldEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			baseEntity = item.parentItem.GetHeldEntity();
		}
		ourEntity.SetFlag(BaseEntity.Flags.Disabled, b: false);
		ourEntity.limitNetworking = false;
		ourEntity.SetParent(baseEntity, defaultBone);
		return true;
	}

	private bool ParentToPlayer(Item item, BaseEntity ourEntity)
	{
		HeldEntity heldEntity = ourEntity as HeldEntity;
		if ((Object)(object)heldEntity == (Object)null)
		{
			return false;
		}
		BasePlayer basePlayer = item.GetRootContainer()?.GetOwnerPlayer();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			heldEntity.SetOwnerPlayer(basePlayer);
			return true;
		}
		heldEntity.ClearOwnerPlayer();
		return true;
	}

	public override void OnParentChanged(Item item)
	{
		BaseEntity baseEntity = item.GetHeldEntity();
		if (playerOnlyEntity)
		{
			BasePlayer ownerPlayer = item.GetOwnerPlayer();
			if ((Object)(object)ownerPlayer == (Object)null && (Object)(object)baseEntity != (Object)null)
			{
				baseEntity.Kill();
				baseEntity = null;
				item.SetHeldEntity(null);
			}
			else if ((Object)(object)ownerPlayer != (Object)null && (Object)(object)baseEntity == (Object)null)
			{
				CreateEntity(item);
				baseEntity = item.GetHeldEntity();
			}
		}
		if (!((Object)(object)baseEntity == (Object)null) && !ParentToParent(item, baseEntity) && !ParentToPlayer(item, baseEntity))
		{
			baseEntity.SetParent(null);
			baseEntity.limitNetworking = true;
			baseEntity.SetFlag(BaseEntity.Flags.Disabled, b: true);
		}
	}

	public override void CollectedForCrafting(Item item, BasePlayer crafter)
	{
		BaseEntity heldEntity = item.GetHeldEntity();
		if (!((Object)(object)heldEntity == (Object)null))
		{
			HeldEntity heldEntity2 = heldEntity as HeldEntity;
			if (!((Object)(object)heldEntity2 == (Object)null))
			{
				heldEntity2.CollectedForCrafting(item, crafter);
			}
		}
	}

	public override void ReturnedFromCancelledCraft(Item item, BasePlayer crafter)
	{
		BaseEntity heldEntity = item.GetHeldEntity();
		if (!((Object)(object)heldEntity == (Object)null))
		{
			HeldEntity heldEntity2 = heldEntity as HeldEntity;
			if (!((Object)(object)heldEntity2 == (Object)null))
			{
				heldEntity2.ReturnedFromCancelledCraft(item, crafter);
			}
		}
	}
}


using UnityEngine;

public class ItemModEntityReference : MonoBehaviour
{
	public GameObjectRef entityPrefab;
}


public class ItemModEntityThrow : ItemMod
{
	public GameObjectRef entityPrefab;

	public float throwVelocity = 5f;

	public bool consumeOnThrow = true;
}


using UnityEngine;

public class ItemModFishable : ItemMod
{
	public bool CanBeFished = true;

	[Header("Catching Behaviour")]
	public float StrainModifier = 1f;

	public float MoveMultiplier = 1f;

	public float ReelInSpeedMultiplier = 1f;

	public float CatchWaitTimeMultiplier = 1f;

	[Header("Catch Criteria")]
	public float MinimumBaitLevel;

	public float MaximumBaitLevel;

	public float MinimumWaterDepth;

	public float MaximumWaterDepth;

	[InspectorFlags]
	public WaterBody.FishingTag RequiredTag;

	[Range(0f, 1f)]
	public float Chance;

	public string SteamStatName;

	[Header("Mounting")]
	public bool CanBeMounted;

	public int FishMountIndex;
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ItemModFoodSpoiling : ItemMod
{
	public class FoodSpoilingWorkQueue : PersistentObjectWorkQueue<Item>
	{
		private Dictionary<ItemId, TimeSince> lastUpdated = new Dictionary<ItemId, TimeSince>();

		protected override void RunJob(Item foodItem)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			float timeToApply = 0f;
			if (lastUpdated.TryGetValue(foodItem.uid, out var value))
			{
				timeToApply = TimeSince.op_Implicit(value);
				lastUpdated[foodItem.uid] = TimeSince.op_Implicit(0f);
			}
			else
			{
				lastUpdated.Add(foodItem.uid, TimeSince.op_Implicit(0f));
			}
			DeductTimeFromFoodItem(foodItem, timeToApply, setDirty: false);
		}

		public static void DeductTimeFromFoodItem(Item foodItem, float timeToApply, bool setDirty)
		{
			//IL_019b: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_0128: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_013e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0148: Unknown result type (might be due to invalid IL or missing references)
			//IL_014d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0152: Unknown result type (might be due to invalid IL or missing references)
			//IL_0159: Unknown result type (might be due to invalid IL or missing references)
			//IL_015f: Unknown result type (might be due to invalid IL or missing references)
			if (foodItem.instanceData != null)
			{
				float dataFloat = foodItem.instanceData.dataFloat;
				float num = 1f;
				IFoodSpoilModifier foodSpoilModifier = default(IFoodSpoilModifier);
				if (foodItem.parent != null && (Object)(object)foodItem.parent.entityOwner != (Object)null && ((Component)foodItem.parent.entityOwner).TryGetComponent<IFoodSpoilModifier>(ref foodSpoilModifier))
				{
					num = foodSpoilModifier.GetSpoilMultiplier(foodItem);
				}
				bool flag = num != 1f;
				if (foodItem.HasFlag(Item.Flag.Refrigerated) != flag)
				{
					foodItem.SetFlag(Item.Flag.Refrigerated, flag);
					foodItem.MarkDirty();
					if ((Object)(object)foodItem.GetEntityOwner() != (Object)null)
					{
						foodItem.GetEntityOwner().SendNetworkUpdate();
					}
				}
				InstanceData instanceData = foodItem.instanceData;
				instanceData.dataFloat -= timeToApply * num;
				if (!(foodItem.instanceData.dataFloat <= 0f) || !(dataFloat > 0f))
				{
					return;
				}
				int amount = foodItem.amount;
				ItemContainer parent = foodItem.parent;
				foodItem.RemoveFromContainer();
				Item item = ItemManager.Create(((Component)foodItem.info).GetComponent<ItemModFoodSpoiling>().SpoilItem, amount, 0uL);
				if (parent != null && !parent.GiveItem(item))
				{
					if ((Object)(object)parent.entityOwner != (Object)null)
					{
						item.Drop(((Component)parent.entityOwner).transform.position + Vector3.up * ((Bounds)(ref parent.entityOwner.bounds)).size.y, Vector3.zero);
					}
					else
					{
						item.Remove();
					}
				}
				else if (item.parent == null)
				{
					BaseEntity worldEntity = foodItem.GetWorldEntity();
					if ((Object)(object)worldEntity != (Object)null)
					{
						item.Drop(((Component)worldEntity).transform.position, Vector3.zero, ((Component)worldEntity).transform.rotation);
					}
					else
					{
						item.Remove();
					}
				}
				foodItem.Remove();
				ItemManager.DoRemoves();
			}
			else if (setDirty)
			{
				foodItem.MarkDirty();
				if ((Object)(object)foodItem.GetEntityOwner() != (Object)null)
				{
					foodItem.GetEntityOwner().SendNetworkUpdate();
				}
			}
		}
	}

	public float TotalSpoilTimeHours = 12f;

	public ItemDefinition SpoilItem;

	public static FoodSpoilingWorkQueue foodSpoilItems = new FoodSpoilingWorkQueue();

	public override void OnItemCreated(Item item)
	{
		base.OnItemCreated(item);
		if (item.instanceData == null)
		{
			item.instanceData = Pool.Get<InstanceData>();
			item.instanceData.dataFloat = 3600f * TotalSpoilTimeHours;
			item.instanceData.ShouldPool = false;
		}
		((PersistentObjectWorkQueue<Item>)foodSpoilItems).Add(item);
	}

	public override void OnRemove(Item item)
	{
		base.OnRemove(item);
		((PersistentObjectWorkQueue<Item>)foodSpoilItems).Remove(item);
	}

	public static void DeductTimeFromAll(TimeSpan span)
	{
		((PersistentObjectWorkQueue<Item>)foodSpoilItems).RunOnAll((Action<Item>)delegate(Item foodItem)
		{
			FoodSpoilingWorkQueue.DeductTimeFromFoodItem(foodItem, (float)span.TotalSeconds, setDirty: true);
		});
	}
}


using System.Collections.Generic;
using ProtoBuf;
using UnityEngine;

public class FoodSpoilingWorkQueue : PersistentObjectWorkQueue<Item>
{
	private Dictionary<ItemId, TimeSince> lastUpdated = new Dictionary<ItemId, TimeSince>();

	protected override void RunJob(Item foodItem)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		float timeToApply = 0f;
		if (lastUpdated.TryGetValue(foodItem.uid, out var value))
		{
			timeToApply = TimeSince.op_Implicit(value);
			lastUpdated[foodItem.uid] = TimeSince.op_Implicit(0f);
		}
		else
		{
			lastUpdated.Add(foodItem.uid, TimeSince.op_Implicit(0f));
		}
		DeductTimeFromFoodItem(foodItem, timeToApply, setDirty: false);
	}

	public static void DeductTimeFromFoodItem(Item foodItem, float timeToApply, bool setDirty)
	{
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		if (foodItem.instanceData != null)
		{
			float dataFloat = foodItem.instanceData.dataFloat;
			float num = 1f;
			IFoodSpoilModifier foodSpoilModifier = default(IFoodSpoilModifier);
			if (foodItem.parent != null && (Object)(object)foodItem.parent.entityOwner != (Object)null && ((Component)foodItem.parent.entityOwner).TryGetComponent<IFoodSpoilModifier>(ref foodSpoilModifier))
			{
				num = foodSpoilModifier.GetSpoilMultiplier(foodItem);
			}
			bool flag = num != 1f;
			if (foodItem.HasFlag(Item.Flag.Refrigerated) != flag)
			{
				foodItem.SetFlag(Item.Flag.Refrigerated, flag);
				foodItem.MarkDirty();
				if ((Object)(object)foodItem.GetEntityOwner() != (Object)null)
				{
					foodItem.GetEntityOwner().SendNetworkUpdate();
				}
			}
			InstanceData instanceData = foodItem.instanceData;
			instanceData.dataFloat -= timeToApply * num;
			if (!(foodItem.instanceData.dataFloat <= 0f) || !(dataFloat > 0f))
			{
				return;
			}
			int amount = foodItem.amount;
			ItemContainer parent = foodItem.parent;
			foodItem.RemoveFromContainer();
			Item item = ItemManager.Create(((Component)foodItem.info).GetComponent<ItemModFoodSpoiling>().SpoilItem, amount, 0uL);
			if (parent != null && !parent.GiveItem(item))
			{
				if ((Object)(object)parent.entityOwner != (Object)null)
				{
					item.Drop(((Component)parent.entityOwner).transform.position + Vector3.up * ((Bounds)(ref parent.entityOwner.bounds)).size.y, Vector3.zero);
				}
				else
				{
					item.Remove();
				}
			}
			else if (item.parent == null)
			{
				BaseEntity worldEntity = foodItem.GetWorldEntity();
				if ((Object)(object)worldEntity != (Object)null)
				{
					item.Drop(((Component)worldEntity).transform.position, Vector3.zero, ((Component)worldEntity).transform.rotation);
				}
				else
				{
					item.Remove();
				}
			}
			foodItem.Remove();
			ItemManager.DoRemoves();
		}
		else if (setDirty)
		{
			foodItem.MarkDirty();
			if ((Object)(object)foodItem.GetEntityOwner() != (Object)null)
			{
				foodItem.GetEntityOwner().SendNetworkUpdate();
			}
		}
	}
}


public interface IFoodSpoilModifier
{
	float GetSpoilMultiplier(Item item);
}


public class ItemModForceSelectFromBelt : ItemMod
{
	public bool IfIsOn = true;

	public bool IfPlayerRestrained = true;
}


public class ItemModForceWearFromBelt : ItemMod
{
	public bool IfPlayerRestrained = true;
}


public interface IAirSupply
{
	ItemModGiveOxygen.AirSupplyType AirType { get; }

	float GetAirTimeRemaining(Item forItem);
}


using UnityEngine;

public class ItemModGiveOxygen : ItemMod, IAirSupply
{
	public enum AirSupplyType
	{
		Lungs,
		ScubaTank,
		Submarine
	}

	public AirSupplyType airType = AirSupplyType.ScubaTank;

	public int amountToConsume = 1;

	public GameObjectRef inhaleEffect;

	public GameObjectRef exhaleEffect;

	public GameObjectRef bubblesEffect;

	private float cycleTime;

	private bool inhaled;

	public AirSupplyType AirType => airType;

	public float GetAirTimeRemaining(Item forItem)
	{
		return ConditionToTime(forItem);
	}

	public override void ModInit()
	{
		base.ModInit();
		cycleTime = 1f;
		ItemMod[] array = siblingMods;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] is ItemModCycle itemModCycle)
			{
				cycleTime = itemModCycle.timeBetweenCycles;
			}
		}
	}

	public override void DoAction(Item item, BasePlayer player)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		if (!item.hasCondition || item.conditionNormalized == 0f || (Object)(object)player == (Object)null)
		{
			return;
		}
		float num = Mathf.Clamp01(0.525f);
		if (!(player.AirFactor() > num) && item.parent != null && item.parent == player.inventory.containerWear)
		{
			Effect.server.Run((!inhaled) ? inhaleEffect.resourcePath : exhaleEffect.resourcePath, player, StringPool.Get("jaw"), Vector3.zero, Vector3.forward);
			inhaled = !inhaled;
			if (!inhaled && WaterLevel.GetWaterDepth(player.eyes.position, waves: true, volumes: true, player) > 3f)
			{
				Effect.server.Run(bubblesEffect.resourcePath, player, StringPool.Get("jaw"), Vector3.zero, Vector3.forward);
			}
			item.LoseCondition(amountToConsume);
			player.metabolism.oxygen.Add(1f);
		}
	}

	private float ConditionToTime(Item item)
	{
		if (item == null || !item.hasCondition)
		{
			return 0f;
		}
		return item.condition * ((float)amountToConsume / cycleTime);
	}
}


public enum AirSupplyType
{
	Lungs,
	ScubaTank,
	Submarine
}


using UnityEngine;

public class ItemModHABEquipment : ItemMod
{
	public enum SlotType
	{
		Basic,
		Armor
	}

	public SlotType slot;

	public GameObjectRef Prefab;

	public int MaxEquipCount = 1;

	public bool GroundEquipOnly = true;

	public float DelayNextUpgradeOnRemoveDuration = 60f;

	public Phrase MenuOptionTitle;

	public Phrase MenuOptionDesc;

	public bool CanEquipToHAB(HotAirBalloon hab)
	{
		if (!hab.CanModifyEquipment())
		{
			return false;
		}
		if (hab.GetEquipmentCount(this) >= MaxEquipCount)
		{
			return false;
		}
		if (GroundEquipOnly && !hab.Grounded)
		{
			return false;
		}
		if (hab.NextUpgradeTime > Time.time)
		{
			return false;
		}
		return true;
	}

	public void ApplyToHAB(HotAirBalloon hab)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (hab.isServer && CanEquipToHAB(hab) && Prefab.isValid)
		{
			HotAirBalloonEquipment hotAirBalloonEquipment = GameManager.server.CreateEntity(Prefab.resourcePath, ((Component)hab).transform.position, ((Component)hab).transform.rotation) as HotAirBalloonEquipment;
			if (Object.op_Implicit((Object)(object)hotAirBalloonEquipment))
			{
				hotAirBalloonEquipment.SetParent(hab, worldPositionStays: true);
				hotAirBalloonEquipment.Spawn();
				hotAirBalloonEquipment.DelayNextUpgradeOnRemoveDuration = DelayNextUpgradeOnRemoveDuration;
			}
		}
	}
}


public enum SlotType
{
	Basic,
	Armor
}


public class ItemModHead : ItemModAssociatedEntity<HeadEntity>
{
	protected override bool AllowNullParenting => true;
}


public class ItemModHideInfoPanel : ItemMod
{
}


public class ItemModKeycard : ItemMod
{
	public int accessLevel;
}


using UnityEngine;

public class ItemModMenuOption : ItemMod
{
	public string commandName;

	public ItemMod actionTarget;

	public BaseEntity.Menu.Option option;

	[Tooltip("If true, this is the command that will run when an item is 'selected' on the toolbar")]
	public bool isPrimaryOption = true;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (!(command != commandName) && actionTarget.CanDoAction(item, player))
		{
			actionTarget.DoAction(item, player);
		}
	}

	private void OnValidate()
	{
		if ((Object)(object)actionTarget == (Object)null)
		{
			Debug.LogWarning((object)"ItemModMenuOption: actionTarget is null!", (Object)(object)((Component)this).gameObject);
		}
		if (string.IsNullOrEmpty(commandName))
		{
			Debug.LogWarning((object)"ItemModMenuOption: commandName can't be empty!", (Object)(object)((Component)this).gameObject);
		}
		if ((Object)(object)option.icon == (Object)null)
		{
			Debug.LogWarning((object)("No icon set for ItemModMenuOption " + ((Object)((Component)this).gameObject).name), (Object)(object)((Component)this).gameObject);
		}
	}
}


using UnityEngine;

[RequireComponent(typeof(ItemModWearable))]
public class ItemModPaintable : ItemModAssociatedEntity<PaintedItemStorageEntity>
{
	public static readonly Phrase ItemPaintTitle = new Phrase("item.paint", "Paint");

	public static readonly Phrase ItemPaintDesc = new Phrase("item.paint.desc", "Paint on this item.");

	public GameObjectRef ChangeSignTextDialog;

	public MeshPaintableSource[] PaintableSources;

	protected override bool AllowNullParenting => true;

	protected override bool OwnedByParentPlayer => true;
}


using UnityEngine;

public class ItemModPetStats : ItemMod
{
	[Tooltip("Speed modifier. Value, not percentage.")]
	public float SpeedModifier;

	[Tooltip("HP amount to modify max health by. Value, not percentage.")]
	public float MaxHealthModifier;

	[Tooltip("Damage amount to modify base attack damage by. Value, not percentage.")]
	public float AttackDamageModifier;

	[Tooltip("Attack rate (seconds) to modify base attack rate by. Value, not percentage.")]
	public float AttackRateModifier;

	public void Apply(BasePet pet)
	{
		if (!((Object)(object)pet == (Object)null))
		{
			pet.SetMaxHealth(pet.MaxHealth() + MaxHealthModifier);
			if ((Object)(object)pet.Brain != (Object)null && (Object)(object)pet.Brain.Navigator != (Object)null)
			{
				pet.Brain.Navigator.Speed += SpeedModifier;
			}
			pet.BaseAttackRate += AttackRateModifier;
			pet.BaseAttackDamge += AttackDamageModifier;
		}
	}
}


using Rust;
using UnityEngine;

public class ItemModProjectile : MonoBehaviour
{
	public GameObjectRef projectileObject = new GameObjectRef();

	public ItemModProjectileMod[] mods;

	public AmmoTypes ammoType;

	public int numProjectiles = 1;

	public float projectileSpread;

	public float projectileVelocity = 100f;

	public float projectileVelocitySpread;

	public bool useCurve;

	public AnimationCurve spreadScalar;

	public GameObjectRef attackEffectOverride;

	public float barrelConditionLoss;

	public string category = "bullet";

	public float GetRandomVelocity()
	{
		return projectileVelocity + Random.Range(0f - projectileVelocitySpread, projectileVelocitySpread);
	}

	public float GetSpreadScalar()
	{
		if (useCurve)
		{
			return spreadScalar.Evaluate(Random.Range(0f, 1f));
		}
		return 1f;
	}

	public float GetIndexedSpreadScalar(int shotIndex, int maxShots)
	{
		float num = 0f;
		if (shotIndex != -1)
		{
			float num2 = 1f / (float)maxShots;
			num = (float)shotIndex * num2;
		}
		else
		{
			num = Random.Range(0f, 1f);
		}
		return spreadScalar.Evaluate(num);
	}

	public float GetAverageVelocity()
	{
		return projectileVelocity;
	}

	public float GetMinVelocity()
	{
		return projectileVelocity - projectileVelocitySpread;
	}

	public float GetMaxVelocity()
	{
		return projectileVelocity + projectileVelocitySpread;
	}

	public bool IsAmmo(AmmoTypes ammo)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Invalid comparison between Unknown and I4
		return (ammoType & ammo) > 0;
	}

	public virtual void ServerProjectileHit(HitInfo info)
	{
		if (mods == null)
		{
			return;
		}
		ItemModProjectileMod[] array = mods;
		foreach (ItemModProjectileMod itemModProjectileMod in array)
		{
			if (!((Object)(object)itemModProjectileMod == (Object)null))
			{
				itemModProjectileMod.ServerProjectileHit(info);
			}
		}
	}

	public virtual void ServerProjectileHitEntity(HitInfo hitInfo)
	{
		if (mods == null)
		{
			return;
		}
		ItemModProjectileMod[] array = mods;
		foreach (ItemModProjectileMod itemModProjectileMod in array)
		{
			if (!((Object)(object)itemModProjectileMod == (Object)null))
			{
				itemModProjectileMod.ServerProjectileHitEntity(hitInfo);
			}
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class ItemModProjectileDart : ItemModProjectileMod
{
	public List<ModifierDefintion> modifiers;

	public List<ItemModConsumable.ConsumableEffect> effects;

	public float TurretEffectScale = 0.5f;

	public float TurretDurationScale = 0.5f;

	public override void ServerProjectileHitEntity(HitInfo info)
	{
		base.ServerProjectileHitEntity(info);
		BasePlayer basePlayer = info.HitEntity as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		float effectScale = 1f;
		float durationScale = 1f;
		if ((Object)(object)info.Initiator != (Object)null && info.Initiator is AutoTurret)
		{
			effectScale = TurretEffectScale;
			durationScale = TurretDurationScale;
		}
		PlayerModifiers.AddToPlayer(basePlayer, modifiers, effectScale, durationScale);
		if (effects == null)
		{
			return;
		}
		foreach (ItemModConsumable.ConsumableEffect effect in effects)
		{
			if (!(Mathf.Clamp01(basePlayer.healthFraction + basePlayer.metabolism.pending_health.Fraction()) > effect.onlyIfHealthLessThan))
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					basePlayer.health += effect.amount;
				}
				else
				{
					basePlayer.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
		}
	}
}


using UnityEngine;

public class ItemModProjectileMod : MonoBehaviour
{
	public virtual void ServerProjectileHit(HitInfo info)
	{
	}

	public virtual void ServerProjectileHitEntity(HitInfo info)
	{
	}
}


using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

public class ItemModProjectileRadialDamage : ItemModProjectileMod
{
	public float radius = 0.5f;

	public DamageTypeEntry damage;

	public GameObjectRef effect;

	public bool ignoreHitObject = true;

	public bool onlyDoors;

	public int vibrationLevel = 2;

	public override void ServerProjectileHit(HitInfo info)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		if (effect.isValid)
		{
			Effect.server.Run(effect.resourcePath, info.HitPositionWorld, info.HitNormalWorld);
		}
		List<BaseCombatEntity> list = Pool.Get<List<BaseCombatEntity>>();
		List<BaseCombatEntity> list2 = Pool.Get<List<BaseCombatEntity>>();
		Vis.Entities(info.HitPositionWorld, radius, list2, 1237003025, (QueryTriggerInteraction)2);
		if (damage.type == DamageType.Explosion)
		{
			SeismicSensor.Notify(info.HitPositionWorld, vibrationLevel);
		}
		foreach (BaseCombatEntity item in list2)
		{
			if (!item.isServer || list.Contains(item) || (onlyDoors && !(item is Door)) || ((Object)(object)item == (Object)(object)info.HitEntity && ignoreHitObject))
			{
				continue;
			}
			item.CenterPoint();
			Vector3 val = item.ClosestPoint(info.HitPositionWorld);
			float num = Vector3.Distance(val, info.HitPositionWorld) / radius;
			if (num > 1f)
			{
				continue;
			}
			float num2 = 1f - num;
			if (!item.IsVisibleAndCanSeeLegacy(info.HitPositionWorld - ((Vector3)(ref info.ProjectileVelocity)).normalized * 0.1f))
			{
				continue;
			}
			Vector3 hitPositionWorld = info.HitPositionWorld;
			Vector3 val2 = val - info.HitPositionWorld;
			if (item.IsVisibleAndCanSeeLegacy(hitPositionWorld - ((Vector3)(ref val2)).normalized * 0.1f))
			{
				list.Add(item);
				BasePlayer component = ((Component)item).GetComponent<BasePlayer>();
				if ((Object)(object)component != (Object)null && component.GetActiveShield(out var foundShield) && (Object)(object)info.Initiator != (Object)null && foundShield.SphereCastAgainstColliders(info.HitPositionWorld, radius))
				{
					foundShield.OnAttacked(new HitInfo(info.Initiator, item, damage.type, damage.amount * num2));
				}
				else
				{
					item.OnAttacked(new HitInfo(info.Initiator, item, damage.type, damage.amount * num2));
				}
			}
		}
		Pool.FreeUnmanaged<BaseCombatEntity>(ref list);
		Pool.FreeUnmanaged<BaseCombatEntity>(ref list2);
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class ItemModProjectileRagdoll : ItemModProjectileMod
{
	public float radius = 0.5f;

	public float velocityInheritFactor = 0.25f;

	public override void ServerProjectileHit(HitInfo info)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Vis.Entities(info.HitPositionWorld, radius, list, 131072, (QueryTriggerInteraction)2);
		foreach (BasePlayer item in list)
		{
			if (item.isServer && !item.IsDead() && !item.InSafeZone())
			{
				Vector3 val;
				if ((Object)(object)info.HitEntity == (Object)(object)item)
				{
					val = info.ProjectileVelocity * velocityInheritFactor;
				}
				else
				{
					Vector3 val2 = ((Component)item).transform.position - info.HitPositionWorld + Vector3.up;
					val = ((Vector3)(ref val2)).normalized * 7.5f;
				}
				item.Ragdoll(item.GetWorldVelocity() + val);
			}
		}
	}
}


using ConVar;
using UnityEngine;

public class ItemModProjectileSpawn : ItemModProjectile
{
	public float createOnImpactChance;

	public GameObjectRef createOnImpact = new GameObjectRef();

	public float spreadAngle = 30f;

	public float spreadVelocityMin = 1f;

	public float spreadVelocityMax = 3f;

	public int numToCreateChances = 1;

	public override void ServerProjectileHit(HitInfo info)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < numToCreateChances; i++)
		{
			if (!createOnImpact.isValid || !(Random.Range(0f, 1f) < createOnImpactChance))
			{
				continue;
			}
			Vector3 hitPositionWorld = info.HitPositionWorld;
			Vector3 pointStart = info.PointStart;
			Vector3 normalized = ((Vector3)(ref info.ProjectileVelocity)).normalized;
			Vector3 normalized2 = ((Vector3)(ref info.HitNormalWorld)).normalized;
			Vector3 val = hitPositionWorld - normalized * 0.1f;
			Quaternion rotation = Quaternion.LookRotation(-normalized);
			int num = 1075904512;
			if (ConVar.AntiHack.projectile_terraincheck)
			{
				num |= 0x800000;
			}
			if (ConVar.AntiHack.projectile_vehiclecheck)
			{
				num |= 0x8000000;
			}
			if (!GamePhysics.LineOfSight(pointStart, val, num))
			{
				continue;
			}
			BaseEntity baseEntity = GameManager.server.CreateEntity(createOnImpact.resourcePath);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				((Component)baseEntity).transform.position = val;
				((Component)baseEntity).transform.rotation = rotation;
				baseEntity.Spawn();
				if (spreadAngle > 0f)
				{
					Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(spreadAngle, normalized2);
					baseEntity.SetVelocity(modifiedAimConeDirection * Random.Range(spreadVelocityMin, spreadVelocityMax));
				}
			}
		}
		base.ServerProjectileHit(info);
	}
}


public class ItemModRackMountable : ItemMod
{
}


using UnityEngine;

public class ItemModRecycleInto : ItemMod
{
	public static readonly Phrase RecycleIntoTitle = new Phrase("recycle_into", "MISSING RECYCLE INTO PHRASE");

	public static readonly Phrase RecycleIntoDesc = new Phrase("recycle_into_desc", "MISSING RECYCLE INTO DESC PHRASE");

	public ItemDefinition recycleIntoItem;

	public int numRecycledItemMin = 1;

	public int numRecycledItemMax = 1;

	public GameObjectRef successEffect;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		if (!(command == "recycle_item"))
		{
			return;
		}
		int num = Random.Range(numRecycledItemMin, numRecycledItemMax + 1);
		item.UseItem();
		if (num > 0)
		{
			Item item2 = ItemManager.Create(recycleIntoItem, num, 0uL);
			item2.SetItemOwnership(player, ItemOwnershipPhrases.Recycler);
			if (!item2.MoveToContainer(player.inventory.containerMain))
			{
				item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}
}


using UnityEngine;

public class ItemModReload : ItemMod
{
	public float conditionLost;

	public GameObjectRef successEffect;

	public int workbenchLvlRequired;

	public Phrase reloadPhrase = new Phrase("reload_item", "Reload Item");

	public bool HasCraftLevel(BasePlayer player = null)
	{
		if ((Object)(object)player != (Object)null && player.isServer)
		{
			return player.currentCraftLevel >= (float)workbenchLvlRequired;
		}
		return false;
	}

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		if (!(command == "reload") || player.IsSwimming() || !HasCraftLevel(player))
		{
			return;
		}
		BaseEntity heldEntity = item.GetHeldEntity();
		if ((Object)(object)heldEntity == (Object)null)
		{
			return;
		}
		BaseProjectile component = ((Component)heldEntity).GetComponent<BaseProjectile>();
		if (!((Object)(object)component == (Object)null))
		{
			int num = component.primaryMagazine.capacity - component.primaryMagazine.contents;
			if (num != 0 && component.TryReloadMagazine(player.inventory, num) && successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}
}


using Facepunch.Rust;
using Oxide.Core;
using UnityEngine;

public class ItemModRepair : ItemMod
{
	public static readonly Phrase RefillItemTitle = new Phrase("refill_item", "Refill");

	public static readonly Phrase RefillItemDesc = new Phrase("refill_item_desc", "Refill the item.");

	public float conditionLost = 0.05f;

	public GameObjectRef successEffect;

	public int workbenchLvlRequired;

	public bool canUseRepairBench;

	public bool HasCraftLevel(BasePlayer player = null)
	{
		if ((Object)(object)player != (Object)null && player.isServer)
		{
			return player.currentCraftLevel >= (float)workbenchLvlRequired;
		}
		return false;
	}

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		if (command == "refill" && !player.IsSwimming() && HasCraftLevel(player) && !(item.conditionNormalized >= 1f) && Interface.CallHook("OnItemRefill", (object)item, (object)player) == null)
		{
			float conditionNormalized = item.conditionNormalized;
			float maxConditionNormalized = item.maxConditionNormalized;
			item.DoRepair(conditionLost);
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
			Analytics.Azure.OnItemRepaired(player, player.GetCachedCraftLevelWorkbench(), item, conditionNormalized, maxConditionNormalized);
		}
	}
}


public class ItemModRestraint : ItemMod
{
}


using UnityEngine;

public class ItemModReveal : ItemMod
{
	public static readonly Phrase RevealItemTitle = new Phrase("reveal_item", "Reveal BP");

	public static readonly Phrase RevealItemDesc = new Phrase("reveal_item_desc", "Reveal blueprint");

	public int numForReveal = 10;

	public ItemDefinition revealedItemOverride;

	public int revealedItemAmount = 1;

	public LootSpawn revealList;

	public GameObjectRef successEffect;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		if (command == "reveal" && item.amount >= numForReveal)
		{
			int position = item.position;
			item.UseItem(numForReveal);
			Item item2 = null;
			if (Object.op_Implicit((Object)(object)revealedItemOverride))
			{
				item2 = ItemManager.Create(revealedItemOverride, revealedItemAmount, 0uL);
			}
			if (item2 != null && !item2.MoveToContainer(player.inventory.containerMain, (item.amount == 0) ? position : (-1)))
			{
				item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}
}


using Rust;
using UnityEngine;

public class ItemModSound : ItemMod
{
	public enum Type
	{
		OnAttachToWeapon
	}

	public GameObjectRef effect = new GameObjectRef();

	public Type actionType;

	public override void OnParentChanged(Item item)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoadingSave || actionType != 0 || item.parentItem == null || item.parentItem.info.category != 0)
		{
			return;
		}
		ItemContainer rootContainer = item.parentItem.GetRootContainer();
		if (rootContainer != null)
		{
			BasePlayer ownerPlayer = rootContainer.GetOwnerPlayer();
			if (!((Object)(object)ownerPlayer == (Object)null) && !ownerPlayer.IsNpc)
			{
				Effect.server.Run(effect.resourcePath, ownerPlayer, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}
}


public enum Type
{
	OnAttachToWeapon
}


using Facepunch.Rust;
using Oxide.Core;
using UnityEngine;

public class ItemModStudyBlueprint : ItemMod
{
	public GameObjectRef studyEffect;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		if (command != "study" || !item.IsBlueprint())
		{
			return;
		}
		if ((Object)(object)item.GetOwnerPlayer() != (Object)(object)player && player.inventory.GetBackpackWithInventory()?.contents != item.parent)
		{
			bool flag = false;
			foreach (ItemContainer container in player.inventory.loot.containers)
			{
				if (item.GetRootContainer() == container)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return;
			}
		}
		if (IsBlueprintUnlocked(item, player, out var blueprintTargetDef, out var blueprint) || Interface.CallHook("OnPlayerStudyBlueprint", (object)player, (object)item) != null)
		{
			return;
		}
		Item item2 = item;
		if (item.amount > 1)
		{
			item2 = item.SplitItem(1);
		}
		item2.UseItem();
		player.blueprints.Unlock(blueprintTargetDef);
		Analytics.Azure.OnBlueprintLearned(player, blueprintTargetDef, "blueprint", ResearchTable.ScrapForResearch(blueprintTargetDef), player);
		if ((Object)(object)blueprint != (Object)null && blueprint.additionalUnlocks != null && blueprint.additionalUnlocks.Count > 0)
		{
			foreach (ItemDefinition additionalUnlock in blueprint.additionalUnlocks)
			{
				player.blueprints.Unlock(additionalUnlock);
				Analytics.Azure.OnBlueprintLearned(player, additionalUnlock, "blueprint", 0, player);
			}
		}
		if (studyEffect.isValid)
		{
			Effect.server.Run(studyEffect.resourcePath, player, StringPool.Get("head"), Vector3.zero, Vector3.zero);
		}
	}

	private static bool IsBlueprintUnlocked(Item item, BasePlayer player, out ItemDefinition blueprintTargetDef, out ItemBlueprint blueprint)
	{
		blueprintTargetDef = item.blueprintTargetDef;
		blueprint = blueprintTargetDef.Blueprint;
		bool flag = IsBlueprintUnlocked(blueprintTargetDef, player);
		if (flag && (Object)(object)blueprint != (Object)null && blueprint.additionalUnlocks != null && blueprint.additionalUnlocks.Count > 0)
		{
			foreach (ItemDefinition additionalUnlock in blueprint.additionalUnlocks)
			{
				if (!IsBlueprintUnlocked(additionalUnlock, player))
				{
					flag = false;
				}
			}
		}
		if ((Object)(object)blueprint != (Object)null && blueprint.defaultBlueprint)
		{
			flag = true;
		}
		if (flag)
		{
			return true;
		}
		return false;
	}

	public static bool IsBlueprintUnlocked(ItemDefinition def, BasePlayer player)
	{
		return player.blueprints.IsUnlocked(def);
	}
}


using ConVar;
using UnityEngine;

public class ItemModSummerSunglassesEquip : ItemMod
{
	public float SunsetTime;

	public float SunriseTime;

	public string AchivementName;

	public override void DoAction(Item item, BasePlayer player)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		base.DoAction(item, player);
		if ((Object)(object)player != (Object)null && !string.IsNullOrEmpty(AchivementName) && player.inventory.containerWear.FindItemByUID(item.uid) != null)
		{
			float time = Env.time;
			if (time < SunriseTime || time > SunsetTime)
			{
				player.GiveAchievement(AchivementName);
			}
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust;
using UnityEngine;

public class ItemModSwap : ItemMod
{
	public GameObjectRef actionEffect;

	public ItemAmount[] becomeItem;

	public bool sendPlayerPickupNotification;

	public bool sendPlayerDropNotification;

	public float xpScale = 1f;

	public List<ItemAmount> RandomOptions;

	public List<float> RandomWeights;

	public Phrase OwnershipPhrase;

	public bool ApplyHarvestingTea;

	public override void DoAction(Item item, BasePlayer player)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		if (item.amount < 1 && RandomWeights.Count == 0 && RandomOptions.Count == 0)
		{
			return;
		}
		ItemAmount[] array = becomeItem;
		foreach (ItemAmount itemAmount in array)
		{
			if (itemAmount.itemDef.IsAllowed((EraRestriction)0))
			{
				SpawnItem(itemAmount, player, item.parent, allowTeaBonus: true);
			}
		}
		if (RandomOptions.Count > 0)
		{
			List<ItemAmount> list = null;
			List<float> list2 = null;
			List<ItemAmount> options = RandomOptions;
			List<float> weights = RandomWeights;
			if ((int)ConVar.Server.Era != 0)
			{
				list = Pool.Get<List<ItemAmount>>();
				list2 = Pool.Get<List<float>>();
				options = list;
				if (RandomWeights.Count != 0 && RandomWeights.Count == RandomOptions.Count)
				{
					weights = list2;
				}
				for (int j = 0; j < RandomOptions.Count; j++)
				{
					ItemAmount itemAmount2 = RandomOptions[j];
					if (itemAmount2.itemDef.IsAllowed((EraRestriction)0))
					{
						if (j < RandomWeights.Count)
						{
							list2.Add(RandomWeights.Count);
						}
						list.Add(itemAmount2);
					}
				}
			}
			ItemAmount itemAmount3 = ((RandomWeights.Count == 0 || RandomWeights.Count != RandomOptions.Count) ? PickRandomChoice(options) : PickWeightedRandomChoice(options, weights));
			if (itemAmount3 != null)
			{
				SpawnItem(itemAmount3, player, item.parent, allowTeaBonus: false);
			}
			if (list != null)
			{
				Pool.FreeUnmanaged<ItemAmount>(ref list);
			}
			if (list2 != null)
			{
				Pool.FreeUnmanaged<float>(ref list2);
			}
		}
		if (sendPlayerDropNotification)
		{
			player.Command("note.inv", item.info.itemid, -1);
		}
		if (actionEffect.isValid)
		{
			Effect.server.Run(actionEffect.resourcePath, ((Component)player).transform.position, Vector3.up);
		}
		item.UseItem();
	}

	private void SpawnItem(ItemAmount itemAmount, BasePlayer player, ItemContainer container, bool allowTeaBonus)
	{
		float num = 1f;
		if (ApplyHarvestingTea && itemAmount.amount > 1f && allowTeaBonus)
		{
			num += player.modifiers.GetValue(Modifier.ModifierType.Harvesting);
		}
		Item item = ItemManager.Create(itemAmount.itemDef, (int)(itemAmount.amount * num), 0uL);
		if (item != null)
		{
			if (OwnershipPhrase != null && !string.IsNullOrEmpty(OwnershipPhrase.token))
			{
				item.SetItemOwnership(player, OwnershipPhrase);
			}
			else
			{
				item.SetItemOwnership(player, ItemOwnershipPhrases.GenericPhrase);
			}
			AugmentItem(item);
			int num2 = 0;
			while (item.amount > item.MaxStackable() && num2 < 5)
			{
				Item item2 = item.SplitItem(item.MaxStackable());
				GiveOutItem(item2, player, container);
				num2++;
			}
			GiveOutItem(item, player, container);
		}
	}

	private void GiveOutItem(Item item, BasePlayer player, ItemContainer container)
	{
		if (!item.MoveToContainer(container))
		{
			player.GiveItem(item);
		}
		if (sendPlayerPickupNotification)
		{
			player.Command("note.inv", item.info.itemid, item.amount);
		}
	}

	protected virtual void AugmentItem(Item item)
	{
	}

	private ItemAmount PickRandomChoice(List<ItemAmount> options)
	{
		int index = Random.Range(0, options.Count);
		return options[index];
	}

	private ItemAmount PickWeightedRandomChoice(List<ItemAmount> options, List<float> weights)
	{
		float num = 0f;
		foreach (float weight in weights)
		{
			num += weight;
		}
		float num2 = Random.Range(0f, num);
		float num3 = 0f;
		for (int i = 0; i < options.Count; i++)
		{
			num3 += weights[i];
			if (num2 <= num3)
			{
				return options[i];
			}
		}
		return options[options.Count - 1];
	}
}


public class ItemModSwitchFlag : ItemMod
{
	public Item.Flag flag;

	public bool state;

	public override void DoAction(Item item, BasePlayer player)
	{
		if (item.amount >= 1 && item.HasFlag(flag) != state)
		{
			item.SetFlag(flag, state);
			item.MarkDirty();
		}
	}
}


using Oxide.Core;
using UnityEngine;

public class ItemModUpgrade : ItemMod
{
	public static readonly Phrase UpgradeItemTitle = new Phrase("upgrade_item", "Upgrade");

	public static readonly Phrase UpgradeItemDesc = new Phrase("upgrade_item_desc", "Upgrade item");

	public int numForUpgrade = 10;

	public float upgradeSuccessChance = 1f;

	public int numToLoseOnFail = 2;

	public ItemDefinition upgradedItem;

	public int numUpgradedItem = 1;

	public GameObjectRef successEffect;

	public GameObjectRef failEffect;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		if (!(command == "upgrade_item") || item.amount < numForUpgrade)
		{
			return;
		}
		if (Random.Range(0f, 1f) <= upgradeSuccessChance)
		{
			item.UseItem(numForUpgrade);
			Item item2 = ItemManager.Create(upgradedItem, numUpgradedItem, 0uL);
			Interface.CallHook("OnItemUpgrade", (object)item, (object)item2, (object)player);
			item2.SetItemOwnership(player, ItemOwnershipPhrases.UpgradeItem);
			if (!item2.MoveToContainer(player.inventory.containerMain))
			{
				item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
		else
		{
			item.UseItem(numToLoseOnFail);
			if (failEffect.isValid)
			{
				Effect.server.Run(failEffect.resourcePath, player.eyes.position);
			}
		}
	}
}


public class ItemModUseContent : ItemMod
{
	public int amountToConsume = 1;

	public override void DoAction(Item item, BasePlayer player)
	{
		if (item.contents != null && item.contents.itemList.Count != 0)
		{
			item.contents.itemList[0].UseItem(amountToConsume);
		}
	}
}


using Rust;
using UnityEngine;

public class ItemModWearable : ItemMod
{
	public GameObjectRef entityPrefab = new GameObjectRef();

	public GameObjectRef entityPrefabFemale = new GameObjectRef();

	public ProtectionProperties protectionProperties;

	public ArmorProperties armorProperties;

	public ClothingMovementProperties movementProperties;

	public UIBlackoutOverlay.blackoutType occlusionType = UIBlackoutOverlay.blackoutType.NONE;

	public bool blocksAiming;

	public bool emissive;

	public float accuracyBonus;

	public bool blocksEquipping;

	public float eggVision;

	public float weight;

	public bool equipOnRightClick = true;

	public bool equipOnPickup;

	public bool npcOnly;

	public GameObjectRef breakEffect = new GameObjectRef();

	public bool preventsMounting;

	public bool preventsMap;

	public bool blockFromMannequin;

	public GameObjectRef viewmodelAddition;

	public Wearable targetWearable
	{
		get
		{
			if (entityPrefab.isValid)
			{
				return entityPrefab.Get().GetComponent<Wearable>();
			}
			return null;
		}
	}

	private void DoPrepare()
	{
		if (!entityPrefab.isValid)
		{
			Debug.LogWarning((object)("ItemModWearable: entityPrefab is null! " + (object)((Component)this).gameObject), (Object)(object)((Component)this).gameObject);
		}
		if (entityPrefab.isValid && (Object)(object)targetWearable == (Object)null)
		{
			Debug.LogWarning((object)("ItemModWearable: entityPrefab doesn't have a Wearable component! " + (object)((Component)this).gameObject), (Object)(object)entityPrefab.Get());
		}
	}

	public override void ModInit()
	{
		if (string.IsNullOrEmpty(entityPrefab.resourcePath))
		{
			Debug.LogWarning((object)(((object)this)?.ToString() + " - entityPrefab is null or something.. - " + entityPrefab.guid));
		}
	}

	public bool ProtectsArea(HitArea area)
	{
		if ((Object)(object)armorProperties == (Object)null)
		{
			return false;
		}
		return armorProperties.Contains(area);
	}

	public bool ProtectsWholeBody()
	{
		bool num = ProtectsArea(HitArea.Head);
		bool flag = ProtectsArea(HitArea.Chest);
		bool flag2 = ProtectsArea(HitArea.Leg);
		return num && flag && flag2;
	}

	public bool HasProtections()
	{
		return (Object)(object)protectionProperties != (Object)null;
	}

	public float GetProtection(Item item, DamageType damageType)
	{
		if ((Object)(object)protectionProperties == (Object)null)
		{
			return 0f;
		}
		float num = protectionProperties.Get(damageType);
		float num2 = 0f;
		ItemModContainerArmorSlot itemModContainerArmorSlot = default(ItemModContainerArmorSlot);
		if (((Component)this).TryGetComponent<ItemModContainerArmorSlot>(ref itemModContainerArmorSlot))
		{
			num2 = itemModContainerArmorSlot.GetProtection(item, damageType);
		}
		return (num + num2) * ConditionProtectionScale(item);
	}

	public float ConditionProtectionScale(Item item)
	{
		if (!item.isBroken)
		{
			return 1f;
		}
		return 0.25f;
	}

	public void CollectProtection(Item item, ProtectionProperties protection)
	{
		if ((Object)(object)protectionProperties != (Object)null)
		{
			protection.Add(protectionProperties, ConditionProtectionScale(item));
		}
		ItemModContainerArmorSlot itemModContainerArmorSlot = default(ItemModContainerArmorSlot);
		if (((Component)this).TryGetComponent<ItemModContainerArmorSlot>(ref itemModContainerArmorSlot))
		{
			itemModContainerArmorSlot.CollectProtection(item, protection);
		}
	}

	private bool IsHeadgear()
	{
		Wearable component = entityPrefab.Get().GetComponent<Wearable>();
		if ((Object)(object)component != (Object)null && (component.occupationOver & (Wearable.OccupationSlots.HeadTop | Wearable.OccupationSlots.Face | Wearable.OccupationSlots.HeadBack)) != 0)
		{
			return true;
		}
		return false;
	}

	public bool IsFootwear()
	{
		Wearable component = entityPrefab.Get().GetComponent<Wearable>();
		if ((Object)(object)component != (Object)null && (component.occupationOver & (Wearable.OccupationSlots.LeftFoot | Wearable.OccupationSlots.RightFoot)) != 0)
		{
			return true;
		}
		return false;
	}

	public override void OnAttacked(Item item, HitInfo info)
	{
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		if (!item.hasCondition)
		{
			return;
		}
		float num = 0f;
		for (int i = 0; i < 26; i++)
		{
			DamageType damageType = (DamageType)i;
			if (info.damageTypes.Has(damageType))
			{
				num += Mathf.Clamp(info.damageTypes.types[i] * GetProtection(item, damageType), 0f, item.condition);
				if (num >= item.condition)
				{
					break;
				}
			}
		}
		item.LoseCondition(num);
		if (item != null && item.isBroken && Object.op_Implicit((Object)(object)item.GetOwnerPlayer()) && IsHeadgear() && info.damageTypes.Total() >= item.GetOwnerPlayer().health)
		{
			Vector3 vPos = ((Component)item.GetOwnerPlayer()).transform.position + new Vector3(0f, 1.8f, 0f);
			Vector3 vVelocity = item.GetOwnerPlayer().GetInheritedDropVelocity() + Vector3.up * 3f;
			Quaternion rotation = default(Quaternion);
			BaseEntity baseEntity = item.Drop(vPos, vVelocity, rotation);
			rotation = Random.rotation;
			baseEntity.SetAngularVelocity(((Quaternion)(ref rotation)).eulerAngles * 5f);
		}
	}

	public bool CanExistWith(ItemModWearable wearable)
	{
		if ((Object)(object)wearable == (Object)null)
		{
			return true;
		}
		Wearable wearable2 = targetWearable;
		Wearable wearable3 = wearable.targetWearable;
		if ((wearable2.occupationOver & wearable3.occupationOver) != 0)
		{
			return false;
		}
		if ((wearable2.occupationUnder & wearable3.occupationUnder) != 0)
		{
			return false;
		}
		return true;
	}
}


public class ItemModXPWhenUsed : ItemMod
{
	public float xpPerUnit;

	public int unitSize = 1;

	public void GiveConsumeXP(Item item)
	{
	}
}


using UnityEngine;

public class ItemFootstepSounds : MonoBehaviour
{
	public bool setEffectFolder = true;

	public string effectFolder = "barefoot";

	public SoundDefinition accentSound;
}


public static class ItemOwnershipPhrases
{
	public static Phrase BornPhrase = new Phrase("ownership.born", "Born with {0}");

	public static Phrase SpawnedPhrase = new Phrase("ownership.spawned", "Spawned by {0}");

	public static Phrase CraftedPhrase = new Phrase("ownership.crafted", "Crafted by {0}");

	public static Phrase LootedPhrase = new Phrase("ownership.looted", "Looted by {0}");

	public static Phrase MissionRewardPhrase = new Phrase("ownership.mission_reward", "Mission Reward for {0}");

	public static Phrase AdventCalendar = new Phrase("ownership.advent_calendar", "Found In Advent Calendar by {0}");

	public static Phrase PickedUp = new Phrase("ownership.pick_up", "Picked Up by {0}");

	public static Phrase VendorSale = new Phrase("ownership.vendor_purchase", "Purchased by {0}");

	public static Phrase MetalDetector = new Phrase("ownership.metal_detector", "Detected Underground by {0}");

	public static Phrase GatheredPhrase = new Phrase("ownership.gathered_generic", "Gathered by {0}");

	public static Phrase MixingTable = new Phrase("ownership.mixing_table", "Mixed by {0}");

	public static Phrase IndustrialCrafter = new Phrase("ownership.industrial_crafter", "Industrial Crafted by {0}");

	public static Phrase Fishing = new Phrase("ownership.fished", "Fished by {0}");

	public static Phrase SurvivalTrap = new Phrase("ownership.trap_caught", "Trapped by {0}");

	public static Phrase Recycler = new Phrase("ownership.recycled", "Recycled by {0}");

	public static Phrase ResearchTable = new Phrase("ownership.research", "Researched by {0}");

	public static Phrase UpgradeItem = new Phrase("ownership.upgrade_item", "Upgraded by {0}");

	public static Phrase Wrap = new Phrase("ownership.wrapped", "Wrapped by {0}");

	public static Phrase Recorded = new Phrase("ownership.recorded", "Recorded by {0}");

	public static Phrase Photographed = new Phrase("ownership.photographed", "Photographed by {0}");

	public static Phrase Cloned = new Phrase("ownership.cloned", "Cloned by {0}");

	public static Phrase Harvested = new Phrase("ownership.harvested", "Harvested by {0}");

	public static Phrase Shredded = new Phrase("ownership.shredded", "Shredded by {0}");

	public static Phrase Beheaded = new Phrase("ownership.beheaded", "Beheaded by {0}");

	public static Phrase Pooped = new Phrase("ownership.pooped", "Pooped by {0}");

	public static Phrase GenericRewardPhrase = new Phrase("ownership.generic_reward", "Rewarded to {0}");

	public static Phrase GenericPhrase = new Phrase("ownership.generic", "Created by {0}");
}


public struct ItemOwnershipShare
{
	public string username;

	public string reason;

	public int amount;

	public bool IsValid()
	{
		return !string.IsNullOrEmpty(reason);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

[Serializable]
public class ItemAmount : ISerializationCallbackReceiver
{
	[ItemSelector]
	public ItemDefinition itemDef;

	public float amount;

	[NonSerialized]
	public float startAmount;

	public bool ignoreInTutorial;

	public bool isBP;

	public int itemid
	{
		get
		{
			if ((Object)(object)itemDef == (Object)null)
			{
				return 0;
			}
			return itemDef.itemid;
		}
	}

	public ItemAmount(ItemDefinition item = null, float amt = 0f)
	{
		itemDef = item;
		amount = amt;
		startAmount = amount;
	}

	public virtual float GetAmount()
	{
		return amount;
	}

	public virtual void OnAfterDeserialize()
	{
		startAmount = amount;
	}

	public virtual void OnBeforeSerialize()
	{
	}

	public static ItemAmountList SerialiseList(List<ItemAmount> list)
	{
		ItemAmountList val = Pool.Get<ItemAmountList>();
		val.amount = Pool.Get<List<float>>();
		val.itemID = Pool.Get<List<int>>();
		foreach (ItemAmount item in list)
		{
			val.amount.Add(item.amount);
			val.itemID.Add(item.itemid);
		}
		return val;
	}

	public static void DeserialiseList(List<ItemAmount> target, ItemAmountList source)
	{
		target.Clear();
		if (source.amount.Count == source.itemID.Count)
		{
			for (int i = 0; i < source.amount.Count; i++)
			{
				target.Add(new ItemAmount(ItemManager.FindItemDefinition(source.itemID[i]), source.amount[i]));
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class ItemAmountRandom
{
	[ItemSelector]
	public ItemDefinition itemDef;

	public AnimationCurve amount = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
	{
		new Keyframe(0f, 0f),
		new Keyframe(1f, 1f)
	});

	public int RandomAmount()
	{
		return Mathf.RoundToInt(amount.Evaluate(Random.Range(0f, 1f)));
	}
}


using System;
using UnityEngine;

[Serializable]
public class ItemAmountRanged : ItemAmount
{
	public float maxAmount = -1f;

	public override void OnAfterDeserialize()
	{
		base.OnAfterDeserialize();
	}

	public ItemAmountRanged(ItemDefinition item = null, float amt = 0f, float max = -1f)
		: base(item, amt)
	{
		maxAmount = max;
	}

	public override float GetAmount()
	{
		if (maxAmount > 0f && maxAmount > amount)
		{
			return Random.Range(amount, maxAmount);
		}
		return amount;
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ItemManager
{
	private struct ItemRemove
	{
		public Item item;

		public float time;
	}

	[ServerVar]
	public static bool EnablePooling = true;

	public static List<ItemDefinition> itemList;

	public static Dictionary<int, ItemDefinition> itemDictionary;

	public static Dictionary<string, ItemDefinition> itemDictionaryByName;

	public static List<ItemBlueprint> bpList;

	public static int[] defaultBlueprints;

	public static ItemDefinition blueprintBaseDef;

	public static Dictionary<ItemDefinition, List<ItemDefinition>> redirectPerItem = new Dictionary<ItemDefinition, List<ItemDefinition>>();

	private static List<ItemRemove> ItemRemoves = new List<ItemRemove>();

	public static void InvalidateWorkshopSkinCache()
	{
		if (itemList == null)
		{
			return;
		}
		foreach (ItemDefinition item in itemList)
		{
			item.InvalidateWorkshopSkinCache();
		}
	}

	public static void Initialize()
	{
		if (itemList != null)
		{
			return;
		}
		Stopwatch stopwatch = new Stopwatch();
		stopwatch.Start();
		GameObject[] array = FileSystem.LoadAllFromBundle<GameObject>("items.preload.bundle", "l:ItemDefinition");
		if (array.Length == 0)
		{
			throw new Exception("items.preload.bundle has no items!");
		}
		if (stopwatch.Elapsed.TotalSeconds > 1.0)
		{
			Debug.Log((object)("Loading Items Took: " + stopwatch.Elapsed.TotalMilliseconds / 1000.0 + " seconds"));
		}
		List<ItemDefinition> list = (from x in array
			select x.GetComponent<ItemDefinition>() into x
			where (Object)(object)x != (Object)null
			select x).ToList();
		List<ItemBlueprint> list2 = (from x in array
			select x.GetComponent<ItemBlueprint>() into x
			where (Object)(object)x != (Object)null && x.userCraftable
			select x).ToList();
		Dictionary<int, ItemDefinition> dictionary = new Dictionary<int, ItemDefinition>();
		Dictionary<string, ItemDefinition> dictionary2 = new Dictionary<string, ItemDefinition>(StringComparer.OrdinalIgnoreCase);
		foreach (ItemDefinition item in list)
		{
			item.Initialize(list);
			if (dictionary.ContainsKey(item.itemid))
			{
				ItemDefinition itemDefinition = dictionary[item.itemid];
				Debug.LogWarning((object)("Item ID duplicate " + item.itemid + " (" + ((Object)item).name + ") - have you given your items unique shortnames?"), (Object)(object)((Component)item).gameObject);
				Debug.LogWarning((object)("Other item is " + ((Object)itemDefinition).name), (Object)(object)itemDefinition);
			}
			else if (string.IsNullOrEmpty(item.shortname))
			{
				Debug.LogWarning((object)$"{item} has a null short name! id: {item.itemid} {item.displayName.english}");
			}
			else
			{
				dictionary.Add(item.itemid, item);
				dictionary2.Add(item.shortname, item);
			}
		}
		stopwatch.Stop();
		if (stopwatch.Elapsed.TotalSeconds > 1.0)
		{
			Debug.Log((object)("Building Items Took: " + stopwatch.Elapsed.TotalMilliseconds / 1000.0 + " seconds / Items: " + list.Count + " / Blueprints: " + list2.Count));
		}
		defaultBlueprints = (from x in list2
			where !x.NeedsSteamItem && !x.NeedsSteamDLC && x.defaultBlueprint
			select x.targetItem.itemid).ToArray();
		itemList = list;
		bpList = list2;
		itemDictionary = dictionary;
		itemDictionaryByName = dictionary2;
		blueprintBaseDef = FindItemDefinition("blueprintbase");
		foreach (ItemDefinition item2 in itemList)
		{
			if ((Object)(object)item2 != (Object)null && (Object)(object)item2.isRedirectOf != (Object)null)
			{
				if (!redirectPerItem.TryGetValue(item2.isRedirectOf, out var value))
				{
					value = new List<ItemDefinition>();
					redirectPerItem[item2.isRedirectOf] = value;
				}
				value.Add(item2);
			}
		}
	}

	public static Item CreateByName(string strName, int iAmount = 1, ulong skin = 0uL)
	{
		ItemDefinition itemDefinition = itemList.Find((ItemDefinition x) => x.shortname == strName);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return null;
		}
		return CreateByItemID(itemDefinition.itemid, iAmount, skin);
	}

	public static Item CreateByPartialName(string strName, int iAmount = 1, ulong skin = 0uL)
	{
		ItemDefinition itemDefinition = FindDefinitionByPartialName(strName);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return null;
		}
		return CreateByItemID(itemDefinition.itemid, iAmount, skin);
	}

	public static ItemDefinition FindDefinitionByPartialName(string strName)
	{
		ItemDefinition itemDefinition = itemList.Find((ItemDefinition x) => x.shortname == strName);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			itemDefinition = itemList.Find((ItemDefinition x) => StringEx.Contains(x.shortname, strName, CompareOptions.IgnoreCase));
		}
		return itemDefinition;
	}

	public static Item CreateByItemID(int itemID, int iAmount = 1, ulong skin = 0uL)
	{
		ItemDefinition itemDefinition = FindItemDefinition(itemID);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return null;
		}
		return Create(itemDefinition, iAmount, skin);
	}

	public static Item Create(ItemDefinition template, int iAmount = 1, ulong skin = 0uL, bool isServerSide = true)
	{
		Debug.Assert(isServerSide, "Tried to create client item on server!");
		TrySkinChangeItem(ref template, ref skin);
		if ((Object)(object)template == (Object)null)
		{
			Debug.LogWarning((object)"Creating invalid/missing item!");
			return null;
		}
		if (iAmount <= 0)
		{
			Debug.LogError((object)("Creating item with less than 1 amount! (" + template.displayName.english + ")"));
			return null;
		}
		Item item = ((EnablePooling && isServerSide) ? Pool.Get<Item>() : new Item());
		item.isServer = isServerSide;
		item.info = template;
		item.amount = iAmount;
		item.skin = skin;
		item.Initialize(template);
		RustLog.Log(RustLog.EntryType.Item, 1, null, "Created <color={0}>{1}</color>", item.isServer ? "yellow" : "cyan", item);
		return item;
	}

	private static void TrySkinChangeItem(ref ItemDefinition template, ref ulong skinId)
	{
		if (skinId == 0L)
		{
			return;
		}
		ItemSkinDirectory.Skin skin = ItemSkinDirectory.FindByInventoryDefinitionId((int)skinId);
		if (skin.id != 0)
		{
			ItemSkin itemSkin = skin.invItem as ItemSkin;
			if (!((Object)(object)itemSkin == (Object)null) && !((Object)(object)itemSkin.Redirect == (Object)null))
			{
				template = itemSkin.Redirect;
				skinId = 0uL;
			}
		}
	}

	public static Item Load(Item load, Item created, bool isServer)
	{
		if (created == null)
		{
			created = ((EnablePooling && isServer) ? Pool.Get<Item>() : new Item());
		}
		created.isServer = isServer;
		created.Load(load);
		if ((Object)(object)created.info == (Object)null)
		{
			Debug.LogWarning((object)"Item loading failed - item is invalid");
			return null;
		}
		if ((Object)(object)created.info == (Object)(object)blueprintBaseDef && (Object)(object)created.blueprintTargetDef == (Object)null)
		{
			Debug.LogWarning((object)"Blueprint item loading failed - invalid item target");
			return null;
		}
		RustLog.Log(RustLog.EntryType.Item, 1, null, "Loaded <color={0}>{1}</color>", created.isServer ? "yellow" : "cyan", created);
		return created;
	}

	public static ItemDefinition FindItemDefinition(int itemID)
	{
		Initialize();
		if (itemDictionary.TryGetValue(itemID, out var value))
		{
			return value;
		}
		return null;
	}

	public static ItemDefinition FindItemDefinition(string shortName)
	{
		Initialize();
		if (itemDictionaryByName.TryGetValue(shortName, out var value))
		{
			return value;
		}
		return null;
	}

	public static ItemBlueprint FindBlueprint(ItemDefinition item)
	{
		return ((Component)item).GetComponent<ItemBlueprint>();
	}

	public static List<ItemDefinition> GetItemDefinitions()
	{
		Initialize();
		return itemList;
	}

	public static List<ItemBlueprint> GetBlueprints()
	{
		Initialize();
		return bpList;
	}

	public static void DoRemoves()
	{
		TimeWarning val = TimeWarning.New("DoRemoves", 0);
		try
		{
			for (int i = 0; i < ItemRemoves.Count; i++)
			{
				if (!(ItemRemoves[i].time > Time.time))
				{
					Item item = ItemRemoves[i].item;
					ItemRemoves.RemoveAt(i--);
					RustLog.Log(RustLog.EntryType.Item, 1, null, "Removing <color={0}>{1}</color>", item.isServer ? "yellow" : "cyan", item);
					item.DoRemove();
					if (EnablePooling)
					{
						Pool.Free<Item>(ref item);
					}
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void Heartbeat()
	{
		DoRemoves();
	}

	public static void RemoveItem(Item item, float fTime = 0f)
	{
		RustLog.Log(RustLog.EntryType.Item, 2, null, "Scheduled removal of <color={0}>{1}</color>", item.isServer ? "yellow" : "cyan", item);
		ItemRemove item2 = default(ItemRemove);
		item2.item = item;
		item2.time = Time.time + fTime;
		ItemRemoves.Add(item2);
	}

	public static IEnumerable<Item> GetAllItems()
	{
		Queue<Item> buffer = new Queue<Item>();
		HashSet<Item> bufferHash = new HashSet<Item>();
		foreach (Item item in GetAllItemsInternal())
		{
			if (item == null)
			{
				continue;
			}
			yield return item;
			if (item.contents == null)
			{
				continue;
			}
			bufferHash.Clear();
			buffer.Enqueue(item);
			Item result;
			while (buffer.TryDequeue(out result))
			{
				if (result.contents?.itemList == null)
				{
					continue;
				}
				foreach (Item child in result.contents.itemList)
				{
					yield return child;
					if (bufferHash.Add(child))
					{
						buffer.Enqueue(child);
					}
				}
			}
		}
	}

	private static IEnumerable<Item> GetAllItemsInternal()
	{
		List<ItemContainer> buffer = new List<ItemContainer>();
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				if (current is IInventoryProvider inventoryProvider)
				{
					buffer.Clear();
					inventoryProvider.GetAllInventories(buffer);
					foreach (ItemContainer item in buffer)
					{
						foreach (Item item2 in item.itemList)
						{
							yield return item2;
						}
					}
				}
				else if (current is DroppedItem droppedItem)
				{
					yield return droppedItem.item;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}
}


private struct ItemRemove
{
	public Item item;

	public float time;
}


using UnityEngine;

public class LeavesBlowing : MonoBehaviour
{
	public ParticleSystem m_psLeaves;

	public float m_flSwirl;

	public float m_flSpeed;

	public float m_flEmissionRate;

	private void Start()
	{
	}

	private void Update()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.RotateAround(((Component)this).transform.position, Vector3.up, Time.deltaTime * m_flSwirl);
		if ((Object)(object)m_psLeaves != (Object)null)
		{
			m_psLeaves.startSpeed = m_flSpeed;
			ParticleSystem psLeaves = m_psLeaves;
			psLeaves.startSpeed += Mathf.Sin(Time.time * 0.4f) * (m_flSpeed * 0.75f);
			m_psLeaves.emissionRate = m_flEmissionRate + Mathf.Sin(Time.time * 1f) * (m_flEmissionRate * 0.3f);
		}
	}
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/MaterialEffect")]
public class MaterialEffect : ScriptableObject
{
	[Serializable]
	public class Entry
	{
		public PhysicMaterial Material;

		public GameObjectRef Effect;

		public SoundDefinition SoundDefinition;
	}

	public GameObjectRef DefaultEffect;

	public SoundDefinition DefaultSoundDefinition;

	public Entry[] Entries;

	public int waterFootstepIndex = -1;

	public Entry deepWaterEntry;

	public float deepWaterDepth = -1f;

	public Entry submergedWaterEntry;

	public float submergedWaterDepth = -1f;

	public bool ScaleVolumeWithSpeed;

	public AnimationCurve SpeedGainCurve;

	public Entry GetEntryFromMaterial(PhysicMaterial mat)
	{
		Entry[] entries = Entries;
		foreach (Entry entry in entries)
		{
			if ((Object)(object)entry.Material == (Object)(object)mat)
			{
				return entry;
			}
		}
		return null;
	}

	public Entry GetWaterEntry()
	{
		if (waterFootstepIndex == -1)
		{
			for (int i = 0; i < Entries.Length; i++)
			{
				if (((Object)Entries[i].Material).name == "Water")
				{
					waterFootstepIndex = i;
					break;
				}
			}
		}
		if (waterFootstepIndex != -1)
		{
			return Entries[waterFootstepIndex];
		}
		Debug.LogWarning((object)("Unable to find water effect for :" + ((Object)this).name));
		return null;
	}

	public void SpawnOnRay(Ray ray, int mask, float length = 0.5f, Vector3 forward = default(Vector3), float speed = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		if (!GamePhysics.Trace(ray, 0f, out var hitInfo, length, mask, (QueryTriggerInteraction)0))
		{
			Effect.client.Run(DefaultEffect.resourcePath, ((Ray)(ref ray)).origin, ((Ray)(ref ray)).direction * -1f, forward);
			if ((Object)(object)DefaultSoundDefinition != (Object)null)
			{
				PlaySound(DefaultSoundDefinition, ((RaycastHit)(ref hitInfo)).point, speed);
			}
			return;
		}
		WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(((Ray)(ref ray)).origin, waves: true, volumes: false);
		if (waterInfo.isValid)
		{
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(((Ray)(ref ray)).origin.x, waterInfo.surfaceLevel, ((Ray)(ref ray)).origin.z);
			Entry waterEntry = GetWaterEntry();
			if (submergedWaterDepth > 0f && waterInfo.currentDepth >= submergedWaterDepth)
			{
				waterEntry = submergedWaterEntry;
			}
			else if (deepWaterDepth > 0f && waterInfo.currentDepth >= deepWaterDepth)
			{
				waterEntry = deepWaterEntry;
			}
			if (waterEntry != null)
			{
				Effect.client.Run(waterEntry.Effect.resourcePath, val, Vector3.up);
				if ((Object)(object)waterEntry.SoundDefinition != (Object)null)
				{
					PlaySound(waterEntry.SoundDefinition, val, speed);
				}
			}
			return;
		}
		PhysicMaterial materialAt = ((RaycastHit)(ref hitInfo)).collider.GetMaterialAt(((RaycastHit)(ref hitInfo)).point);
		Entry entryFromMaterial = GetEntryFromMaterial(materialAt);
		if (entryFromMaterial == null)
		{
			Effect.client.Run(DefaultEffect.resourcePath, ((RaycastHit)(ref hitInfo)).point, ((RaycastHit)(ref hitInfo)).normal, forward);
			if ((Object)(object)DefaultSoundDefinition != (Object)null)
			{
				PlaySound(DefaultSoundDefinition, ((RaycastHit)(ref hitInfo)).point, speed);
			}
		}
		else
		{
			Effect.client.Run(entryFromMaterial.Effect.resourcePath, ((RaycastHit)(ref hitInfo)).point, ((RaycastHit)(ref hitInfo)).normal, forward);
			if ((Object)(object)entryFromMaterial.SoundDefinition != (Object)null)
			{
				PlaySound(entryFromMaterial.SoundDefinition, ((RaycastHit)(ref hitInfo)).point, speed);
			}
		}
	}

	public void PlaySound(SoundDefinition definition, Vector3 position, float velocity = 0f)
	{
	}
}


using System;
using UnityEngine;

[Serializable]
public class Entry
{
	public PhysicMaterial Material;

	public GameObjectRef Effect;

	public SoundDefinition SoundDefinition;
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/MaterialSound")]
public class MaterialSound : ScriptableObject
{
	[Serializable]
	public class Entry
	{
		public PhysicMaterial Material;

		public SoundDefinition Sound;
	}

	public SoundDefinition DefaultSound;

	public Entry[] Entries;
}


using System;
using UnityEngine;

[Serializable]
public class Entry
{
	public PhysicMaterial Material;

	public SoundDefinition Sound;
}


using UnityEngine;

public class MaxSpawnDistance : MonoBehaviour, IClientComponent
{
	public float maxDistance = 30f;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Rust;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(menuName = "Rust/Missions/BaseMission")]
public class BaseMission : BaseScriptableObject
{
	[Serializable]
	public class MissionDependancy
	{
		public BaseMission targetMission;

		public MissionStatus targetMissionDesiredStatus;

		public bool everAttempted;

		public uint targetMissionID
		{
			get
			{
				if (!(targetMission != null))
				{
					return 0u;
				}
				return StringEx.ManifestHash(targetMission.shortname);
			}
		}
	}

	public enum MissionStatus
	{
		Default,
		Active,
		Accomplished,
		Failed,
		Completed
	}

	public enum MissionEventType
	{
		CUSTOM,
		HARVEST,
		CONVERSATION,
		KILL_ENTITY,
		ACQUIRE_ITEM,
		FREE_CRATE,
		MOUNT_ENTITY,
		HURT_ENTITY,
		PLAYER_TICK,
		CRAFT_ITEM,
		DEPLOY,
		HEAL,
		CLOTHINGCHANGED,
		STARTOVEN,
		CONSUME,
		ACQUITE_ITEM_STACK,
		OPEN_STORAGE,
		COOK,
		ENTER_TRIGGER,
		UPGRADE_BUILDING_GRADE,
		RESPAWN,
		METAL_DETECTOR_FIND,
		LONG_USE_OBJECT
	}

	[Serializable]
	public class MissionObjectiveEntry
	{
		public Phrase description;

		public bool startAfterPriorObjectives;

		public int[] startAfterCompletedObjectives;

		public int[] autoCompleteOtherObjectives;

		public bool onlyProgressIfStarted = true;

		public bool isRequired = true;

		public MissionObjective objective;

		public string[] requiredEntities;

		public ItemAmount[] bonusRewards;

		public MissionObjective Get()
		{
			return objective;
		}
	}

	public struct MissionEventPayload
	{
		public NetworkableId NetworkIdentifier;

		public uint UintIdentifier;

		public int IntIdentifier;

		public Vector3 WorldPosition;
	}

	public class MissionInstance : IPooled
	{
		[Serializable]
		public class ObjectiveStatus
		{
			public bool started;

			public bool completed;

			public bool failed;

			public float progressTarget;

			public float progressCurrent;

			public RealTimeSince sinceLastThink;
		}

		public enum ObjectiveType
		{
			MOVE,
			KILL
		}

		private BaseEntity _cachedProviderEntity;

		private BaseMission _cachedMission;

		public NetworkableId providerID;

		public uint missionID;

		public MissionStatus status;

		public long startTimeUtcSeconds;

		public long endTimeUtcSeconds;

		public Vector3 missionLocation;

		public float timePassed;

		public Dictionary<string, Vector3> missionPoints = new Dictionary<string, Vector3>();

		public Dictionary<string, MissionEntity> missionEntities = new Dictionary<string, MissionEntity>();

		private int playerInputCounter;

		public ObjectiveStatus[] objectiveStatuses = Array.Empty<ObjectiveStatus>();

		public BaseEntity ProviderEntity()
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)_cachedProviderEntity == (Object)null)
			{
				_cachedProviderEntity = BaseNetworkable.serverEntities.Find(providerID) as BaseEntity;
			}
			return _cachedProviderEntity;
		}

		public BaseMission GetMission()
		{
			if (_cachedMission == null)
			{
				_cachedMission = MissionManifest.GetFromID(missionID);
			}
			return _cachedMission;
		}

		public bool ShouldShowOnMap()
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			if (status == MissionStatus.Active || status == MissionStatus.Accomplished)
			{
				return missionLocation != Vector3.zero;
			}
			return false;
		}

		public bool ShouldShowOnCompass()
		{
			return ShouldShowOnMap();
		}

		public bool NeedsPlayerInput()
		{
			return playerInputCounter > 0;
		}

		public void EnablePlayerInput()
		{
			playerInputCounter++;
		}

		public void DisablePlayerInput()
		{
			playerInputCounter--;
			if (playerInputCounter < 0)
			{
				playerInputCounter = 0;
			}
		}

		public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionEventType type, MissionEventPayload payload, float amount)
		{
			if (status == MissionStatus.Active)
			{
				BaseMission mission = GetMission();
				for (int i = 0; i < mission.objectives.Length; i++)
				{
					mission.objectives[i].objective.ProcessMissionEvent(playerFor, this, i, type, payload, amount);
				}
			}
		}

		public void Think(BasePlayer assignee, float delta)
		{
			if (status != MissionStatus.Failed && status != MissionStatus.Completed)
			{
				BaseMission mission = GetMission();
				timePassed += delta;
				mission.Think(this, assignee, delta);
				if (mission.timeLimitSeconds > 0f && timePassed >= mission.timeLimitSeconds)
				{
					mission.MissionFailed(this, assignee, MissionFailReason.TimeOut);
				}
			}
		}

		public Vector3 GetMissionPoint(string identifier, BasePlayer playerFor, int depth = 0)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
			if (identifier == null)
			{
				identifier = "";
			}
			if (missionPoints.TryGetValue(identifier, out var value))
			{
				return value;
			}
			BaseMission mission = GetMission();
			if ((Object)(object)playerFor == (Object)null)
			{
				Debug.LogError((object)("Massive mission failure to get point, correct mission definition of: " + mission.shortname + " (player is null)"));
				return Vector3.zero;
			}
			PositionGenerator positionGenerator = List.FindWith<PositionGenerator, string>((IReadOnlyCollection<PositionGenerator>)(object)mission.positionGenerators, (Func<PositionGenerator, string>)((PositionGenerator p) => p.identifier), identifier, (IEqualityComparer<string>)null);
			if (positionGenerator == null)
			{
				Debug.LogError((object)("Massive mission failure to get point, correct mission definition of: " + mission.shortname + " (cannot find position '" + identifier + "')"));
				return Vector3.zero;
			}
			Vector3 position = positionGenerator.GetPosition(this, playerFor, depth);
			missionPoints.Add(identifier, position);
			if (positionGenerator.positionsAreExclusive)
			{
				AddBlocker(position);
			}
			return position;
		}

		public MissionEntity GetMissionEntity(string identifier, BasePlayer playerFor)
		{
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			if (identifier == null)
			{
				identifier = "";
			}
			if (missionEntities.TryGetValue(identifier, out var value))
			{
				return value;
			}
			MissionEntityEntry missionEntityEntry = List.FindWith<MissionEntityEntry, string>((IReadOnlyCollection<MissionEntityEntry>)(object)GetMission().missionEntities, (Func<MissionEntityEntry, string>)((MissionEntityEntry e) => e.identifier), identifier, (IEqualityComparer<string>)null);
			if (missionEntityEntry == null)
			{
				Debug.LogError((object)$"Cannot spawn mission entity, identifier '{identifier}' not found in mission ID {missionID}");
				value = null;
			}
			else if (!missionEntityEntry.entityRef.isValid)
			{
				Debug.LogError((object)$"Cannot spawn mission entity, identifier '{identifier}' has no entity set in mission ID {missionID}");
				value = null;
			}
			else
			{
				Vector3 missionPoint = GetMissionPoint(missionEntityEntry.spawnPositionToUse, playerFor);
				BaseEntity baseEntity = GameManager.server.CreateEntity(missionEntityEntry.entityRef.resourcePath, missionPoint, Quaternion.identity);
				MissionEntity missionEntity = default(MissionEntity);
				MissionEntity missionEntity2 = (((Component)baseEntity).gameObject.TryGetComponent<MissionEntity>(ref missionEntity) ? missionEntity : ((Component)baseEntity).gameObject.AddComponent<MissionEntity>());
				missionEntity2.Setup(playerFor, this, identifier, missionEntityEntry.cleanupOnMissionSuccess, missionEntityEntry.cleanupOnMissionFailed);
				baseEntity.Spawn();
				if (baseEntity is LootContainer lootContainer && missionEntityEntry.overrideLootOnItem != null && missionEntityEntry.overrideLootOnItem.Length != 0)
				{
					lootContainer.inventory.Clear();
					ItemAmount[] overrideLootOnItem = missionEntityEntry.overrideLootOnItem;
					foreach (ItemAmount itemAmount in overrideLootOnItem)
					{
						lootContainer.inventory.AddItem(itemAmount.itemDef, (int)itemAmount.amount, 0uL);
					}
				}
				value = missionEntity2;
			}
			missionEntities.Add(identifier, value);
			if ((Object)(object)value != (Object)null)
			{
				value.MissionStarted(playerFor, this);
			}
			return value;
		}

		public void PostServerLoad(BasePlayer player)
		{
			BaseMission mission = GetMission();
			for (int i = 0; i < mission.objectives.Length; i++)
			{
				if (i >= 0 && i < objectiveStatuses.Length)
				{
					mission.objectives[i].objective.PostServerLoad(player, objectiveStatuses[i]);
				}
			}
		}

		public int GetTotalRequiredRewardItemSlots()
		{
			BaseMission mission = GetMission();
			int num = 0;
			for (int i = 0; i < mission.objectives.Length; i++)
			{
				if (!mission.objectives[i].isRequired && objectiveStatuses[i].completed)
				{
					num += mission.objectives[i].bonusRewards.Length;
				}
			}
			return mission.GetMissionRewards().Length + num;
		}

		public void Reset()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			providerID = default(NetworkableId);
			missionID = 0u;
			status = MissionStatus.Default;
			startTimeUtcSeconds = long.MinValue;
			endTimeUtcSeconds = long.MinValue;
			missionLocation = Vector3.zero;
			_cachedMission = null;
			_cachedProviderEntity = null;
			timePassed = 0f;
			missionPoints.Clear();
			missionEntities.Clear();
		}

		public void EnterPool()
		{
			Reset();
		}

		public void LeavePool()
		{
		}
	}

	[Serializable]
	public class PositionGenerator
	{
		public enum RelativeType
		{
			Player,
			Provider,
			Position
		}

		public enum PositionType
		{
			MissionPoint,
			WorldPositionGenerator,
			DungeonPoint,
			Radius
		}

		public class PositionPointAttribute : PropertyAttribute
		{
		}

		public string identifier;

		public float minDistForMovePoint;

		public float maxDistForMovePoint = 25f;

		public bool allowDoubleDistanceIfNoOptionsAreFound;

		public bool positionsAreExclusive = true;

		public RelativeType relativeTo;

		public PositionType positionType;

		public string centerOnPositionIdentifier = "";

		[InspectorFlags]
		public MissionPoint.MissionPointEnum Flags = (MissionPoint.MissionPointEnum)(-1);

		[InspectorFlags]
		public MissionPoint.MissionPointEnum ExclusionFlags;

		public WorldPositionGenerator worldPositionGenerator;

		public bool IsDependant()
		{
			return !string.IsNullOrEmpty(centerOnPositionIdentifier);
		}

		public bool Validate(BasePlayer assignee, BaseMission missionDef)
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			Vector3 position;
			if (positionType == PositionType.MissionPoint)
			{
				List<MissionPoint> points = Pool.Get<List<MissionPoint>>();
				bool missionPoints = MissionPoint.GetMissionPoints(ref points, ((Component)assignee).transform.position, minDistForMovePoint, maxDistForMovePoint, (int)Flags, (int)ExclusionFlags);
				if (!missionPoints && allowDoubleDistanceIfNoOptionsAreFound)
				{
					points.Clear();
					missionPoints = MissionPoint.GetMissionPoints(ref points, ((Component)assignee).transform.position, minDistForMovePoint, maxDistForMovePoint * 2f, (int)Flags, (int)ExclusionFlags);
				}
				Pool.FreeUnmanaged<MissionPoint>(ref points);
				if (!missionPoints)
				{
					return false;
				}
			}
			else if (positionType == PositionType.WorldPositionGenerator && (Object)(object)worldPositionGenerator != (Object)null && !worldPositionGenerator.TrySample(((Component)assignee).transform.position, minDistForMovePoint, maxDistForMovePoint, out position, blockedPoints))
			{
				return false;
			}
			return true;
		}

		public Vector3 GetPosition(MissionInstance instance, BasePlayer assignee, int depth = 0)
		{
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0150: Unknown result type (might be due to invalid IL or missing references)
			//IL_0155: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_015b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0160: Unknown result type (might be due to invalid IL or missing references)
			//IL_0175: Unknown result type (might be due to invalid IL or missing references)
			//IL_0176: Unknown result type (might be due to invalid IL or missing references)
			//IL_0189: Unknown result type (might be due to invalid IL or missing references)
			//IL_018e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0193: Unknown result type (might be due to invalid IL or missing references)
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0115: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0138: Unknown result type (might be due to invalid IL or missing references)
			//IL_0139: Unknown result type (might be due to invalid IL or missing references)
			//IL_0120: Unknown result type (might be due to invalid IL or missing references)
			//IL_0122: Unknown result type (might be due to invalid IL or missing references)
			if (depth > 10)
			{
				Debug.LogError((object)$"Exceeded max depth while calculating position! missionID={instance.missionID} identifier={identifier}");
				return ((Component)assignee).transform.position;
			}
			Vector3 relativeToPosition = GetRelativeToPosition(instance, assignee, depth);
			Vector3 result;
			if (positionType == PositionType.MissionPoint)
			{
				List<MissionPoint> points = Pool.Get<List<MissionPoint>>();
				bool missionPoints = MissionPoint.GetMissionPoints(ref points, relativeToPosition, minDistForMovePoint, maxDistForMovePoint, (int)Flags, (int)ExclusionFlags);
				if (!missionPoints && allowDoubleDistanceIfNoOptionsAreFound)
				{
					points.Clear();
					missionPoints = MissionPoint.GetMissionPoints(ref points, relativeToPosition, minDistForMovePoint, maxDistForMovePoint * 2f, (int)Flags, (int)ExclusionFlags);
				}
				if (missionPoints)
				{
					result = points[Random.Range(0, points.Count)].GetPosition();
				}
				else
				{
					Debug.LogError((object)"UNABLE TO FIND MISSIONPOINT FOR MISSION!");
					result = relativeToPosition;
				}
				Pool.FreeUnmanaged<MissionPoint>(ref points);
			}
			else if (positionType == PositionType.WorldPositionGenerator && (Object)(object)worldPositionGenerator != (Object)null)
			{
				int num = 0;
				while (true)
				{
					if (worldPositionGenerator.TrySample(relativeToPosition, minDistForMovePoint, maxDistForMovePoint, out var position, blockedPoints) && TryAlignToGround(position, out var correctedPosition))
					{
						result = correctedPosition;
						break;
					}
					if (num >= 10)
					{
						Debug.LogError((object)"UNABLE TO FIND WORLD POINT FOR MISSION!");
						result = relativeToPosition;
						break;
					}
					num++;
				}
			}
			else if (positionType == PositionType.DungeonPoint)
			{
				result = DynamicDungeon.GetNextDungeonPoint();
			}
			else
			{
				int num2 = 0;
				while (true)
				{
					Vector3 onUnitSphere = Random.onUnitSphere;
					onUnitSphere.y = 0f;
					((Vector3)(ref onUnitSphere)).Normalize();
					Vector3 val = relativeToPosition + onUnitSphere * Random.Range(minDistForMovePoint, maxDistForMovePoint);
					val.y = WaterLevel.GetWaterOrTerrainSurface(val, waves: false, volumes: false);
					if (TryAlignToGround(val, out var correctedPosition2))
					{
						result = correctedPosition2;
						break;
					}
					if (num2 >= 10)
					{
						Debug.LogError((object)"UNABLE TO FIND WORLD POINT FOR MISSION!");
						result = relativeToPosition;
						break;
					}
					num2++;
				}
			}
			return result;
		}

		private Vector3 GetRelativeToPosition(MissionInstance instance, BasePlayer assignee, int depth)
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			switch (relativeTo)
			{
			case RelativeType.Position:
				return instance.GetMissionPoint(centerOnPositionIdentifier, assignee, depth + 1);
			case RelativeType.Provider:
			{
				BaseEntity baseEntity = instance.ProviderEntity();
				if ((Object)(object)baseEntity != (Object)null)
				{
					return ((Component)baseEntity).transform.position;
				}
				break;
			}
			}
			if ((Object)(object)assignee != (Object)null)
			{
				return ((Component)assignee).transform.position;
			}
			Debug.LogError((object)$"Cannot get mission point origin - assigne playere is null! missionID={instance.missionID} relativeTo={relativeTo}");
			return Vector3.zero;
		}

		private static bool TryAlignToGround(Vector3 wishPosition, out Vector3 correctedPosition)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = Vector3Ex.WithY(wishPosition, wishPosition.y + 50f);
			RaycastHit hit = default(RaycastHit);
			if (!Physics.Raycast(new Ray(val, Vector3.down), ref hit, 50f, 1218652417, (QueryTriggerInteraction)1))
			{
				correctedPosition = wishPosition;
				return true;
			}
			if ((Object)(object)hit.GetEntity() != (Object)null)
			{
				correctedPosition = wishPosition;
				return false;
			}
			correctedPosition = ((RaycastHit)(ref hit)).point;
			return true;
		}
	}

	[Serializable]
	public class MissionEntityEntry
	{
		[FormerlySerializedAs("entityIdentifier")]
		public string identifier;

		public GameObjectRef entityRef;

		public string spawnPositionToUse;

		public bool spawnOnMissionStart = true;

		public bool cleanupOnMissionFailed;

		public bool cleanupOnMissionSuccess;

		public ItemAmount[] overrideLootOnItem;
	}

	[Serializable]
	public struct NonItemReward
	{
		public Phrase DisplayPhrase;

		public Sprite DisplaySprite;

		public NonItemRewardType RewardType;
	}

	public enum NonItemRewardType
	{
		None,
		SafeZoneRespawnUnlock
	}

	[Serializable]
	public class MissionRewards
	{
		public ItemAmount[] items;

		public Era[] Eras;
	}

	public enum MissionFailReason
	{
		TimeOut,
		Disconnect,
		ResetPlayerState,
		Abandon,
		ObjectiveFailed
	}

	[ServerVar]
	public static bool missionsenabled = true;

	public string shortname;

	public Phrase missionName;

	public Phrase missionDesc;

	public bool canBeAbandoned = true;

	public bool completeSilently;

	public bool blockMissionStat;

	public TutorialMissionHelpSet showHelpInfo;

	public string[] requiredGameModeTags = new string[0];

	public MissionObjectiveEntry[] objectives;

	public GameObjectRef genericMissionProvider;

	public static List<Vector3> blockedPoints = new List<Vector3>();

	public const string MISSION_COMPLETE_STAT = "missions_completed";

	public GameObjectRef acceptEffect;

	public GameObjectRef failedEffect;

	public GameObjectRef victoryEffect;

	public BasePlayer.TutorialItemAllowance AllowedTutorialItems;

	public bool IsTutorialMission;

	public BaseMission followupMission;

	public int repeatDelaySecondsSuccess = -1;

	public int repeatDelaySecondsFailed = -1;

	public float timeLimitSeconds;

	public Sprite icon;

	public Sprite providerIcon;

	public bool hideStagesNotStarted;

	public MissionDependancy[] acceptDependancies;

	public MissionEntityEntry[] missionEntities;

	public PositionGenerator[] positionGenerators;

	public ItemAmount[] baseRewards;

	public MissionRewards[] alternativeRewards;

	public NonItemReward[] nonItemRewards;

	public uint id => StringEx.ManifestHash(shortname);

	public bool isRepeatable
	{
		get
		{
			if (repeatDelaySecondsSuccess < 0)
			{
				return repeatDelaySecondsFailed >= 0;
			}
			return true;
		}
	}

	public static void PlayerDisconnected(BasePlayer player)
	{
		if (player.IsNpc)
		{
			return;
		}
		int activeMission = player.GetActiveMission();
		if (activeMission != -1 && activeMission < player.missions.Count)
		{
			MissionInstance missionInstance = player.missions[activeMission];
			BaseMission mission = missionInstance.GetMission();
			if (mission.missionEntities.Length != 0)
			{
				mission.MissionFailed(missionInstance, player, MissionFailReason.Disconnect);
			}
		}
	}

	public static void PlayerKilled(BasePlayer player)
	{
	}

	public ItemAmount[] GetMissionRewards()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Invalid comparison between I4 and Unknown
		if ((int)ConVar.Server.Era == 0)
		{
			return baseRewards;
		}
		if (alternativeRewards != null)
		{
			MissionRewards[] array = alternativeRewards;
			foreach (MissionRewards missionRewards in array)
			{
				if (missionRewards.Eras == null)
				{
					continue;
				}
				Era[] eras = missionRewards.Eras;
				for (int j = 0; j < eras.Length; j++)
				{
					if ((int)eras[j] == (int)ConVar.Server.Era && missionRewards.items != null)
					{
						return missionRewards.items;
					}
				}
			}
		}
		return baseRewards;
	}

	public virtual Sprite GetIcon(MissionInstance instance)
	{
		return icon;
	}

	public static void AddBlocker(Vector3 point)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (point != Vector3.zero && !blockedPoints.Contains(point))
		{
			blockedPoints.Add(point);
		}
	}

	public void RemoveBlockers(MissionInstance instance)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		foreach (KeyValuePair<string, Vector3> missionPoint in instance.missionPoints)
		{
			if (positionGenerators[num++].positionsAreExclusive)
			{
				blockedPoints.Remove(missionPoint.Value);
			}
		}
	}

	public static void DoMissionEffect(string effectString, BasePlayer assignee)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Effect effect = new Effect();
		effect.Init(Effect.Type.Generic, assignee, StringPool.Get("head"), Vector3.zero, Vector3.forward);
		effect.pooledString = effectString;
		EffectNetwork.Send(effect, assignee.net.connection);
	}

	public virtual void MissionStart(MissionInstance instance, BasePlayer assignee)
	{
		if (Interface.CallHook("OnMissionStart", (object)this, (object)instance, (object)assignee) != null)
		{
			return;
		}
		for (int i = 0; i < objectives.Length; i++)
		{
			objectives[i].Get().MissionStarted(i, instance, assignee);
		}
		if (acceptEffect.isValid)
		{
			DoMissionEffect(acceptEffect.resourcePath, assignee);
		}
		MissionEntityEntry[] array = missionEntities;
		foreach (MissionEntityEntry missionEntityEntry in array)
		{
			if (missionEntityEntry.spawnOnMissionStart)
			{
				instance.GetMissionEntity(missionEntityEntry.identifier, assignee);
			}
		}
		if (AllowedTutorialItems != 0)
		{
			assignee.SetTutorialAllowance(AllowedTutorialItems);
		}
		Interface.CallHook("OnMissionStarted", (object)this, (object)instance, (object)assignee);
	}

	public void CheckObjectives(MissionInstance instance, BasePlayer assignee)
	{
		bool flag = true;
		bool flag2 = false;
		for (int i = 0; i < objectives.Length; i++)
		{
			if (objectives[i].isRequired && (!instance.objectiveStatuses[i].completed || instance.objectiveStatuses[i].failed))
			{
				flag = false;
			}
			if (instance.objectiveStatuses[i].failed && objectives[i].isRequired)
			{
				flag2 = true;
			}
		}
		if (instance.status == MissionStatus.Active)
		{
			if (flag2)
			{
				MissionFailed(instance, assignee, MissionFailReason.ObjectiveFailed);
			}
			else if (flag)
			{
				MissionSuccess(instance, assignee);
			}
		}
	}

	public virtual void Think(MissionInstance instance, BasePlayer assignee, float delta)
	{
		for (int i = 0; i < objectives.Length; i++)
		{
			objectives[i].Get().Think(i, instance, assignee, delta);
		}
		CheckObjectives(instance, assignee);
	}

	public virtual void MissionComplete(MissionInstance instance, BasePlayer assignee)
	{
		DoMissionEffect(victoryEffect.resourcePath, assignee);
		if (!instance.GetMission().completeSilently)
		{
			assignee.ChatMessage("You have completed the mission : " + missionName.english);
		}
		BaseMission mission = instance.GetMission();
		if (mission != null)
		{
			ItemAmount[] missionRewards = mission.GetMissionRewards();
			if (missionRewards != null)
			{
				ItemAmount[] array = missionRewards;
				foreach (ItemAmount reward2 in array)
				{
					GiveReward(assignee, reward2);
				}
			}
			if (mission.nonItemRewards != null)
			{
				NonItemReward[] array2 = mission.nonItemRewards;
				for (int i = 0; i < array2.Length; i++)
				{
					if (array2[i].RewardType != NonItemRewardType.SafeZoneRespawnUnlock)
					{
						continue;
					}
					using HashSet<StaticRespawnArea>.Enumerator enumerator = StaticRespawnArea.staticRespawnAreas.GetEnumerator();
					if (enumerator.MoveNext())
					{
						enumerator.Current.Authorize(assignee.userID);
						assignee.SendRespawnOptions();
					}
				}
			}
			for (int j = 0; j < mission.objectives.Length; j++)
			{
				MissionObjectiveEntry missionObjectiveEntry = mission.objectives[j];
				if (!missionObjectiveEntry.isRequired && missionObjectiveEntry.bonusRewards != null && instance.objectiveStatuses[j].completed && !instance.objectiveStatuses[j].failed)
				{
					ItemAmount[] array = missionObjectiveEntry.bonusRewards;
					foreach (ItemAmount reward3 in array)
					{
						GiveReward(assignee, reward3);
					}
				}
			}
		}
		Analytics.Azure.OnMissionComplete(assignee, this, null);
		instance.status = MissionStatus.Completed;
		assignee.SetActiveMission(-1);
		assignee.MissionDirty();
		if (followupMission != null)
		{
			assignee.RegisterFollowupMission(followupMission, instance.ProviderEntity() as IMissionProvider);
		}
		if (GameInfo.HasAchievements && mission != null && !mission.blockMissionStat)
		{
			assignee.stats.Add("missions_completed", 1, Stats.All);
			assignee.stats.Save(forceSteamSave: true);
		}
		if (assignee.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = assignee.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null && currentTutorialIsland.FinalMission == this)
			{
				currentTutorialIsland.StartEndingCinematic(assignee);
			}
		}
		if (!completeSilently)
		{
			assignee.ClientRPC(RpcTarget.Player("Client_MissionComplete", assignee), id);
		}
		static void GiveReward(BasePlayer player, ItemAmount reward)
		{
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)reward.itemDef == (Object)null || reward.amount == 0f)
			{
				Debug.LogError((object)"BIG REWARD SCREWUP, NULL ITEM DEF");
			}
			else if (!reward.itemDef.IsAllowed((EraRestriction)8))
			{
				Debug.LogError((object)$"Blocking mission reward '{reward.itemDef.shortname}' not allowed in era '{ConVar.Server.Era}'");
			}
			else
			{
				Item item = (reward.isBP ? ItemManager.Create(ItemManager.blueprintBaseDef, Mathf.CeilToInt(reward.amount), 0uL) : ItemManager.Create(reward.itemDef, Mathf.CeilToInt(reward.amount), 0uL));
				if (reward.isBP)
				{
					item.blueprintTarget = reward.itemDef.itemid;
				}
				item.SetItemOwnership(player, ItemOwnershipPhrases.MissionRewardPhrase);
				if (item != null)
				{
					player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
				}
			}
		}
	}

	public virtual void MissionSuccess(MissionInstance instance, BasePlayer assignee)
	{
		instance.status = MissionStatus.Accomplished;
		MissionEnded(instance, assignee);
		MissionComplete(instance, assignee);
		Interface.CallHook("OnMissionSucceeded", (object)this, (object)instance, (object)assignee);
	}

	public virtual void MissionFailed(MissionInstance instance, BasePlayer assignee, MissionFailReason failReason)
	{
		if (!instance.GetMission().completeSilently)
		{
			assignee.ChatMessage("You have failed the mission : " + missionName.english);
		}
		DoMissionEffect(failedEffect.resourcePath, assignee);
		Analytics.Azure.OnMissionComplete(assignee, this, failReason);
		instance.status = MissionStatus.Failed;
		MissionEnded(instance, assignee);
		Interface.CallHook("OnMissionFailed", (object)this, (object)instance, (object)assignee, (object)failReason);
		if (failReason == MissionFailReason.ResetPlayerState)
		{
			instance.endTimeUtcSeconds = long.MinValue;
			instance.status = MissionStatus.Default;
		}
		assignee.MissionDirty();
	}

	public virtual void MissionEnded(MissionInstance instance, BasePlayer assignee)
	{
		instance.endTimeUtcSeconds = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
		if (instance.missionEntities != null)
		{
			List<MissionEntity> list = Pool.Get<List<MissionEntity>>();
			foreach (MissionEntity value in instance.missionEntities.Values)
			{
				list.Add(value);
			}
			foreach (MissionEntity item in list)
			{
				if (!((Object)(object)item == (Object)null))
				{
					item.MissionEnded(assignee, instance);
				}
			}
			Pool.FreeUnmanaged<MissionEntity>(ref list);
		}
		RemoveBlockers(instance);
		assignee.SetActiveMission(-1);
		assignee.MissionDirty();
	}

	public void OnObjectiveCompleted(int objectiveIndex, MissionInstance instance, BasePlayer playerFor)
	{
		MissionObjectiveEntry missionObjectiveEntry = objectives[objectiveIndex];
		if (missionObjectiveEntry.autoCompleteOtherObjectives.Length != 0)
		{
			int[] autoCompleteOtherObjectives = missionObjectiveEntry.autoCompleteOtherObjectives;
			foreach (int num in autoCompleteOtherObjectives)
			{
				MissionObjectiveEntry missionObjectiveEntry2 = objectives[num];
				if (!instance.objectiveStatuses[num].completed)
				{
					missionObjectiveEntry2.objective.CompleteObjective(num, instance, playerFor);
				}
			}
		}
		CheckObjectives(instance, playerFor);
	}

	public void OnObjectiveFailed(int objectiveIndex, MissionInstance instance, BasePlayer playerFor)
	{
		CheckObjectives(instance, playerFor);
	}

	public static bool AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)
	{
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		if (!missionsenabled)
		{
			return false;
		}
		if (!mission.IsEligableForMission(assignee, provider))
		{
			return false;
		}
		object obj = Interface.CallHook("CanAssignMission", (object)assignee, (object)mission, (object)provider);
		if (obj is bool)
		{
			return (bool)obj;
		}
		int num = List.FindIndexWith<MissionInstance, uint>((IReadOnlyList<MissionInstance>)assignee.missions, (Func<MissionInstance, uint>)((MissionInstance i) => i.missionID), mission.id, (IEqualityComparer<uint>)null);
		MissionInstance missionInstance;
		int activeMission;
		if (num >= 0)
		{
			missionInstance = assignee.missions[num];
			activeMission = num;
			missionInstance.Reset();
		}
		else
		{
			missionInstance = Pool.Get<MissionInstance>();
			activeMission = assignee.missions.Count;
			assignee.missions.Add(missionInstance);
		}
		missionInstance.missionID = mission.id;
		missionInstance.startTimeUtcSeconds = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
		missionInstance.providerID = provider.ProviderID();
		missionInstance.status = MissionStatus.Active;
		missionInstance.objectiveStatuses = new MissionInstance.ObjectiveStatus[mission.objectives.Length];
		for (int j = 0; j < mission.objectives.Length; j++)
		{
			missionInstance.objectiveStatuses[j] = new MissionInstance.ObjectiveStatus();
		}
		mission.MissionStart(missionInstance, assignee);
		assignee.SetActiveMission(activeMission);
		assignee.MissionDirty();
		Interface.CallHook("OnMissionAssigned", (object)mission, (object)provider, (object)assignee);
		return true;
	}

	public bool IsEligableForMission(BasePlayer player, IMissionProvider provider)
	{
		if (!missionsenabled)
		{
			return false;
		}
		foreach (MissionInstance mission in player.missions)
		{
			if (mission.status == MissionStatus.Accomplished || mission.status == MissionStatus.Active)
			{
				return false;
			}
		}
		return true;
	}
}


using System;
using UnityEngine;

[Serializable]
public class MissionDependancy
{
	public BaseMission targetMission;

	public MissionStatus targetMissionDesiredStatus;

	public bool everAttempted;

	public uint targetMissionID
	{
		get
		{
			if (!(targetMission != null))
			{
				return 0u;
			}
			return StringEx.ManifestHash(targetMission.shortname);
		}
	}
}


public enum MissionStatus
{
	Default,
	Active,
	Accomplished,
	Failed,
	Completed
}


public enum MissionEventType
{
	CUSTOM,
	HARVEST,
	CONVERSATION,
	KILL_ENTITY,
	ACQUIRE_ITEM,
	FREE_CRATE,
	MOUNT_ENTITY,
	HURT_ENTITY,
	PLAYER_TICK,
	CRAFT_ITEM,
	DEPLOY,
	HEAL,
	CLOTHINGCHANGED,
	STARTOVEN,
	CONSUME,
	ACQUITE_ITEM_STACK,
	OPEN_STORAGE,
	COOK,
	ENTER_TRIGGER,
	UPGRADE_BUILDING_GRADE,
	RESPAWN,
	METAL_DETECTOR_FIND,
	LONG_USE_OBJECT
}


using System;

[Serializable]
public class MissionObjectiveEntry
{
	public Phrase description;

	public bool startAfterPriorObjectives;

	public int[] startAfterCompletedObjectives;

	public int[] autoCompleteOtherObjectives;

	public bool onlyProgressIfStarted = true;

	public bool isRequired = true;

	public MissionObjective objective;

	public string[] requiredEntities;

	public ItemAmount[] bonusRewards;

	public MissionObjective Get()
	{
		return objective;
	}
}


using UnityEngine;

public struct MissionEventPayload
{
	public NetworkableId NetworkIdentifier;

	public uint UintIdentifier;

	public int IntIdentifier;

	public Vector3 WorldPosition;
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.Extend;
using UnityEngine;

public class MissionInstance : IPooled
{
	[Serializable]
	public class ObjectiveStatus
	{
		public bool started;

		public bool completed;

		public bool failed;

		public float progressTarget;

		public float progressCurrent;

		public RealTimeSince sinceLastThink;
	}

	public enum ObjectiveType
	{
		MOVE,
		KILL
	}

	private BaseEntity _cachedProviderEntity;

	private BaseMission _cachedMission;

	public NetworkableId providerID;

	public uint missionID;

	public MissionStatus status;

	public long startTimeUtcSeconds;

	public long endTimeUtcSeconds;

	public Vector3 missionLocation;

	public float timePassed;

	public Dictionary<string, Vector3> missionPoints = new Dictionary<string, Vector3>();

	public Dictionary<string, MissionEntity> missionEntities = new Dictionary<string, MissionEntity>();

	private int playerInputCounter;

	public ObjectiveStatus[] objectiveStatuses = Array.Empty<ObjectiveStatus>();

	public BaseEntity ProviderEntity()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)_cachedProviderEntity == (Object)null)
		{
			_cachedProviderEntity = BaseNetworkable.serverEntities.Find(providerID) as BaseEntity;
		}
		return _cachedProviderEntity;
	}

	public BaseMission GetMission()
	{
		if (_cachedMission == null)
		{
			_cachedMission = MissionManifest.GetFromID(missionID);
		}
		return _cachedMission;
	}

	public bool ShouldShowOnMap()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if (status == MissionStatus.Active || status == MissionStatus.Accomplished)
		{
			return missionLocation != Vector3.zero;
		}
		return false;
	}

	public bool ShouldShowOnCompass()
	{
		return ShouldShowOnMap();
	}

	public bool NeedsPlayerInput()
	{
		return playerInputCounter > 0;
	}

	public void EnablePlayerInput()
	{
		playerInputCounter++;
	}

	public void DisablePlayerInput()
	{
		playerInputCounter--;
		if (playerInputCounter < 0)
		{
			playerInputCounter = 0;
		}
	}

	public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionEventType type, MissionEventPayload payload, float amount)
	{
		if (status == MissionStatus.Active)
		{
			BaseMission mission = GetMission();
			for (int i = 0; i < mission.objectives.Length; i++)
			{
				mission.objectives[i].objective.ProcessMissionEvent(playerFor, this, i, type, payload, amount);
			}
		}
	}

	public void Think(BasePlayer assignee, float delta)
	{
		if (status != MissionStatus.Failed && status != MissionStatus.Completed)
		{
			BaseMission mission = GetMission();
			timePassed += delta;
			mission.Think(this, assignee, delta);
			if (mission.timeLimitSeconds > 0f && timePassed >= mission.timeLimitSeconds)
			{
				mission.MissionFailed(this, assignee, MissionFailReason.TimeOut);
			}
		}
	}

	public Vector3 GetMissionPoint(string identifier, BasePlayer playerFor, int depth = 0)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		if (identifier == null)
		{
			identifier = "";
		}
		if (missionPoints.TryGetValue(identifier, out var value))
		{
			return value;
		}
		BaseMission mission = GetMission();
		if ((Object)(object)playerFor == (Object)null)
		{
			Debug.LogError((object)("Massive mission failure to get point, correct mission definition of: " + mission.shortname + " (player is null)"));
			return Vector3.zero;
		}
		PositionGenerator positionGenerator = List.FindWith<PositionGenerator, string>((IReadOnlyCollection<PositionGenerator>)(object)mission.positionGenerators, (Func<PositionGenerator, string>)((PositionGenerator p) => p.identifier), identifier, (IEqualityComparer<string>)null);
		if (positionGenerator == null)
		{
			Debug.LogError((object)("Massive mission failure to get point, correct mission definition of: " + mission.shortname + " (cannot find position '" + identifier + "')"));
			return Vector3.zero;
		}
		Vector3 position = positionGenerator.GetPosition(this, playerFor, depth);
		missionPoints.Add(identifier, position);
		if (positionGenerator.positionsAreExclusive)
		{
			AddBlocker(position);
		}
		return position;
	}

	public MissionEntity GetMissionEntity(string identifier, BasePlayer playerFor)
	{
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		if (identifier == null)
		{
			identifier = "";
		}
		if (missionEntities.TryGetValue(identifier, out var value))
		{
			return value;
		}
		MissionEntityEntry missionEntityEntry = List.FindWith<MissionEntityEntry, string>((IReadOnlyCollection<MissionEntityEntry>)(object)GetMission().missionEntities, (Func<MissionEntityEntry, string>)((MissionEntityEntry e) => e.identifier), identifier, (IEqualityComparer<string>)null);
		if (missionEntityEntry == null)
		{
			Debug.LogError((object)$"Cannot spawn mission entity, identifier '{identifier}' not found in mission ID {missionID}");
			value = null;
		}
		else if (!missionEntityEntry.entityRef.isValid)
		{
			Debug.LogError((object)$"Cannot spawn mission entity, identifier '{identifier}' has no entity set in mission ID {missionID}");
			value = null;
		}
		else
		{
			Vector3 missionPoint = GetMissionPoint(missionEntityEntry.spawnPositionToUse, playerFor);
			BaseEntity baseEntity = GameManager.server.CreateEntity(missionEntityEntry.entityRef.resourcePath, missionPoint, Quaternion.identity);
			MissionEntity missionEntity = default(MissionEntity);
			MissionEntity missionEntity2 = (((Component)baseEntity).gameObject.TryGetComponent<MissionEntity>(ref missionEntity) ? missionEntity : ((Component)baseEntity).gameObject.AddComponent<MissionEntity>());
			missionEntity2.Setup(playerFor, this, identifier, missionEntityEntry.cleanupOnMissionSuccess, missionEntityEntry.cleanupOnMissionFailed);
			baseEntity.Spawn();
			if (baseEntity is LootContainer lootContainer && missionEntityEntry.overrideLootOnItem != null && missionEntityEntry.overrideLootOnItem.Length != 0)
			{
				lootContainer.inventory.Clear();
				ItemAmount[] overrideLootOnItem = missionEntityEntry.overrideLootOnItem;
				foreach (ItemAmount itemAmount in overrideLootOnItem)
				{
					lootContainer.inventory.AddItem(itemAmount.itemDef, (int)itemAmount.amount, 0uL);
				}
			}
			value = missionEntity2;
		}
		missionEntities.Add(identifier, value);
		if ((Object)(object)value != (Object)null)
		{
			value.MissionStarted(playerFor, this);
		}
		return value;
	}

	public void PostServerLoad(BasePlayer player)
	{
		BaseMission mission = GetMission();
		for (int i = 0; i < mission.objectives.Length; i++)
		{
			if (i >= 0 && i < objectiveStatuses.Length)
			{
				mission.objectives[i].objective.PostServerLoad(player, objectiveStatuses[i]);
			}
		}
	}

	public int GetTotalRequiredRewardItemSlots()
	{
		BaseMission mission = GetMission();
		int num = 0;
		for (int i = 0; i < mission.objectives.Length; i++)
		{
			if (!mission.objectives[i].isRequired && objectiveStatuses[i].completed)
			{
				num += mission.objectives[i].bonusRewards.Length;
			}
		}
		return mission.GetMissionRewards().Length + num;
	}

	public void Reset()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		providerID = default(NetworkableId);
		missionID = 0u;
		status = MissionStatus.Default;
		startTimeUtcSeconds = long.MinValue;
		endTimeUtcSeconds = long.MinValue;
		missionLocation = Vector3.zero;
		_cachedMission = null;
		_cachedProviderEntity = null;
		timePassed = 0f;
		missionPoints.Clear();
		missionEntities.Clear();
	}

	public void EnterPool()
	{
		Reset();
	}

	public void LeavePool()
	{
	}
}


using System;

[Serializable]
public class ObjectiveStatus
{
	public bool started;

	public bool completed;

	public bool failed;

	public float progressTarget;

	public float progressCurrent;

	public RealTimeSince sinceLastThink;
}


public enum ObjectiveType
{
	MOVE,
	KILL
}


