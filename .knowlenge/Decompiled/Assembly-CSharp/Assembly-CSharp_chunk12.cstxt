using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using ConVar;
using UnityEngine;

public abstract class SpawnPopulationBase : BaseScriptableObject
{
	public string ResourceFolder = string.Empty;

	public GameObjectRef[] ResourceList;

	public bool EnforcePopulationLimits = true;

	public float SpawnRate = 1f;

	public bool ScaleWithServerPopulation;

	public Prefab<Spawnable>[] Prefabs;

	public int[] numToSpawn;

	private HashSet<Spawnable> spawnables = new HashSet<Spawnable>();

	public ICollection<Spawnable> GetSpawnables()
	{
		return spawnables;
	}

	public virtual bool Initialize()
	{
		if (Prefabs == null || Prefabs.Length == 0)
		{
			if (!string.IsNullOrEmpty(ResourceFolder))
			{
				Prefabs = Prefab.Load<Spawnable>("assets/bundled/prefabs/autospawn/" + ResourceFolder, GameManager.server, PrefabAttribute.server, useProbabilities: false, useWorldConfig: true);
			}
			if (ResourceList != null && ResourceList.Length != 0)
			{
				List<string> list = new List<string>();
				GameObjectRef[] resourceList = ResourceList;
				foreach (GameObjectRef gameObjectRef in resourceList)
				{
					string resourcePath = gameObjectRef.resourcePath;
					if (string.IsNullOrEmpty(resourcePath))
					{
						Debug.LogWarning((object)(((Object)this).name + " resource list contains invalid resource path for GUID " + gameObjectRef.guid), (Object)(object)this);
					}
					else
					{
						list.Add(resourcePath);
					}
				}
				Prefabs = Prefab.Load<Spawnable>(list.ToArray(), GameManager.server, PrefabAttribute.server);
			}
			if (Prefabs == null || Prefabs.Length == 0)
			{
				return false;
			}
			numToSpawn = new int[Prefabs.Length];
		}
		return true;
	}

	public float GetCurrentSpawnRate()
	{
		if (ScaleWithServerPopulation)
		{
			return SpawnRate * SpawnHandler.PlayerLerp(Spawn.min_rate, Spawn.max_rate);
		}
		return SpawnRate * Spawn.max_rate;
	}

	public void Fill(SpawnHandler spawnHandler, SpawnDistribution distribution, int numToFill, bool initialSpawn)
	{
		if (GetTargetCount(distribution) == 0)
		{
			return;
		}
		if (!Initialize())
		{
			Debug.LogError((object)("[Spawn] No prefabs to spawn: " + ((Object)this).name), (Object)(object)this);
			return;
		}
		if (Global.developer > 1)
		{
			Debug.Log((object)("[Spawn] Population " + ((Object)this).name + " needs to spawn " + numToFill));
		}
		SubFill(spawnHandler, distribution, numToFill, initialSpawn);
	}

	public abstract void SubFill(SpawnHandler spawnHandler, SpawnDistribution distribution, int numToFill, bool initialSpawn);

	public void DeleteEntities()
	{
		Spawnable[] array = GetSpawnables().ToArray();
		foreach (Spawnable spawnable in array)
		{
			if ((Object)(object)((Component)spawnable).gameObject == (Object)null)
			{
				Debug.LogWarning((object)("Trying to delete spawnable that has already been destroyed: " + ((Object)this).name));
				continue;
			}
			BaseEntity baseEntity = ((Component)spawnable).gameObject.ToBaseEntity();
			if (!baseEntity.IsValid())
			{
				Debug.LogWarning((object)("Trying to delete spawnable that is invalid: " + ((Object)this).name));
			}
			else
			{
				baseEntity.Kill();
			}
		}
	}

	public abstract byte[] GetBaseMapValues(int populationRes);

	public abstract int GetTargetCount(SpawnDistribution distribution);

	public abstract SpawnFilter GetSpawnFilter();

	public void GetReportString(StringBuilder sb, bool detailed)
	{
		if (!string.IsNullOrEmpty(ResourceFolder))
		{
			sb.AppendLine(((Object)this).name + " (autospawn/" + ResourceFolder + ")");
		}
		else
		{
			sb.AppendLine(((Object)this).name);
		}
		if (!detailed)
		{
			return;
		}
		sb.AppendLine("\tPrefabs:");
		if (Prefabs != null)
		{
			Prefab<Spawnable>[] prefabs = Prefabs;
			foreach (Prefab<Spawnable> prefab in prefabs)
			{
				int num = spawnables.Count((Spawnable x) => (((Component)x).GetComponent<BaseNetworkable>()?.prefabID ?? 0) == prefab.ID);
				sb.AppendLine($"\t\t{Path.GetFileNameWithoutExtension(prefab.Name)} : {num}");
			}
		}
		else
		{
			sb.AppendLine("\t\tN/A");
		}
	}

	public void AddInstance(Spawnable spawnable)
	{
		spawnables.Add(spawnable);
	}

	public void RemoveInstance(Spawnable spawnable)
	{
		spawnables.Remove(spawnable);
	}
}


using System;
using UnityEngine;

public static class FloodedSpawnHandler
{
	private static readonly int[] SpreadSteps = new int[7] { 0, 1, -1, 2, -2, 3, -3 };

	public static bool GetSpawnPoint(BasePlayer.SpawnPoint spawnPoint, float searchHeight)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		SpawnHandler instance = SingletonComponent<SpawnHandler>.Instance;
		if ((Object)(object)TerrainMeta.HeightMap == (Object)null || (Object)(object)instance == (Object)null)
		{
			return false;
		}
		LayerMask placementMask = instance.PlacementMask;
		LayerMask placementCheckMask = instance.PlacementCheckMask;
		float placementCheckHeight = instance.PlacementCheckHeight;
		LayerMask radiusCheckMask = instance.RadiusCheckMask;
		float radiusCheckDistance = instance.RadiusCheckDistance;
		RaycastHit val2 = default(RaycastHit);
		for (int i = 0; i < 10; i++)
		{
			Vector3 val = FindSpawnPoint(searchHeight);
			if (LayerMask.op_Implicit(placementCheckMask) != 0 && Physics.Raycast(val + Vector3.up * placementCheckHeight, Vector3.down, ref val2, placementCheckHeight, LayerMask.op_Implicit(placementCheckMask)))
			{
				if (((1 << ((Component)((RaycastHit)(ref val2)).transform).gameObject.layer) & LayerMask.op_Implicit(placementMask)) == 0)
				{
					continue;
				}
				val.y = ((RaycastHit)(ref val2)).point.y;
			}
			if (LayerMask.op_Implicit(radiusCheckMask) == 0 || !Physics.CheckSphere(val, radiusCheckDistance, LayerMask.op_Implicit(radiusCheckMask)))
			{
				spawnPoint.pos = val;
				spawnPoint.rot = Quaternion.Euler(0f, Random.Range(0f, 360f), 0f);
				return true;
			}
		}
		return false;
	}

	private static Vector3 FindSpawnPoint(float searchHeight)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3Ex.WithY(TerrainMeta.Size / 2f, 0f);
		float magnitude = ((Vector3)(ref val)).magnitude;
		float distance = magnitude / 50f;
		float num = RandomAngle();
		float num2 = num + MathF.PI;
		Vector3 val2 = TerrainMeta.Position + val + Step(num, magnitude);
		for (int i = 0; i < 50; i++)
		{
			float num3 = float.MinValue;
			Vector3 val3 = Vector3.zero;
			float num4 = 0f;
			int[] spreadSteps = SpreadSteps;
			foreach (int num5 in spreadSteps)
			{
				float num6 = num2 + (float)num5 * 0.17453292f;
				Vector3 val4 = val2 + Step(num6, distance);
				float height = TerrainMeta.HeightMap.GetHeight(val4);
				if (height > num3)
				{
					num3 = height;
					val3 = val4;
					num4 = num6;
				}
			}
			val2 = Vector3Ex.WithY(val3, num3);
			num2 = (num2 + num4) / 2f;
			if (num3 >= searchHeight)
			{
				break;
			}
		}
		return val2;
	}

	private static Vector3 Step(float angle, float distance)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(distance * Mathf.Cos(angle), 0f, distance * (0f - Mathf.Sin(angle)));
	}

	private static float RandomAngle()
	{
		return Random.value * (MathF.PI * 2f);
	}
}


using System.Collections.Generic;
using UnityEngine;

public abstract class BaseSpawnPoint : MonoBehaviour, IServerComponent
{
	public enum SpawnPointType
	{
		Normal,
		Tugboat,
		Motorbike,
		Bicycle
	}

	public SpawnPointType spawnPointType;

	[Tooltip("Min distance between the spawn area and any human players")]
	[Range(1f, 25f)]
	[SerializeField]
	protected float playerCheckMargin = 2f;

	public static Dictionary<SpawnPointType, List<BaseSpawnPoint>> spawnPoints = new Dictionary<SpawnPointType, List<BaseSpawnPoint>>();

	private bool spawningActive;

	public abstract void GetLocation(out Vector3 pos, out Quaternion rot);

	public abstract void ObjectSpawned(SpawnPointInstance instance);

	public abstract void ObjectRetired(SpawnPointInstance instance);

	protected void OnEnable()
	{
		spawningActive = true;
		if (spawnPointType != 0)
		{
			if (spawnPoints.TryGetValue(spawnPointType, out var value))
			{
				value.Add(this);
				return;
			}
			spawnPoints[spawnPointType] = new List<BaseSpawnPoint> { this };
		}
	}

	protected void OnDisable()
	{
		spawningActive = false;
		if (spawnPointType != 0 && spawnPoints.TryGetValue(spawnPointType, out var value))
		{
			value.Remove(this);
		}
	}

	protected void SetSpawningActive(bool newState)
	{
		spawningActive = newState;
		((Component)this).gameObject.SetActive(newState);
	}

	public virtual bool IsAvailableTo(GameObject prefab)
	{
		return spawningActive;
	}

	public virtual bool HasPlayersIntersecting()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return BaseNetworkable.HasCloseConnections(((Component)this).transform.position, playerCheckMargin);
	}

	protected void DropToGround(ref Vector3 pos, ref Quaternion rot)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap) && Object.op_Implicit((Object)(object)TerrainMeta.Collision) && !TerrainMeta.Collision.GetIgnore(pos))
		{
			float height = TerrainMeta.HeightMap.GetHeight(pos);
			pos.y = Mathf.Max(pos.y, height);
		}
		if (TransformUtil.GetGroundInfo(pos, out var hitOut, 20f, LayerMask.op_Implicit(1235288065)))
		{
			pos = ((RaycastHit)(ref hitOut)).point;
			rot = Quaternion.LookRotation(rot * Vector3.forward, ((RaycastHit)(ref hitOut)).normal);
		}
	}
}


public enum SpawnPointType
{
	Normal,
	Tugboat,
	Motorbike,
	Bicycle
}


using UnityEngine;

public class GameModeSpawnGroup : SpawnGroup
{
	public string[] gameModeTags;

	protected override bool AllowOverlappingSpawns => true;

	protected override bool BlockSpawnedEntitySaving => false;

	public void ResetSpawnGroup()
	{
		Clear();
		SpawnInitial();
	}

	public bool ShouldSpawn()
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode == (Object)null && HasTag("vanilla"))
		{
			return true;
		}
		if ((Object)(object)activeGameMode == (Object)null)
		{
			return false;
		}
		if (gameModeTags.Length == 0)
		{
			return true;
		}
		if (activeGameMode.HasAnyGameModeTag(gameModeTags))
		{
			return true;
		}
		return false;
	}

	private bool HasTag(string tag)
	{
		string[] array = gameModeTags;
		for (int i = 0; i < array.Length; i++)
		{
			if (string.Equals(array[i], tag))
			{
				return true;
			}
		}
		return false;
	}

	protected override void Spawn(int numToSpawn)
	{
		if (ShouldSpawn())
		{
			base.Spawn(numToSpawn);
		}
	}
}


using UnityEngine;
using UnityEngine.Events;

public class GenericSpawnPoint : BaseSpawnPoint
{
	public bool dropToGround = true;

	public bool randomRot;

	[Range(1f, 180f)]
	public float randomRotSnapDegrees = 1f;

	public GameObjectRef spawnEffect;

	public UnityEvent OnObjectSpawnedEvent = new UnityEvent();

	public UnityEvent OnObjectRetiredEvent = new UnityEvent();

	public Quaternion GetRandomRotation()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		if (!randomRot)
		{
			return Quaternion.identity;
		}
		int num = Mathf.FloorToInt(360f / randomRotSnapDegrees);
		int num2 = Random.Range(0, num);
		return Quaternion.Euler(0f, (float)num2 * randomRotSnapDegrees, 0f);
	}

	public override void GetLocation(out Vector3 pos, out Quaternion rot)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		pos = ((Component)this).transform.position;
		if (randomRot)
		{
			rot = ((Component)this).transform.rotation * GetRandomRotation();
		}
		else
		{
			rot = ((Component)this).transform.rotation;
		}
		if (dropToGround)
		{
			DropToGround(ref pos, ref rot);
		}
	}

	public override void ObjectSpawned(SpawnPointInstance instance)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (spawnEffect.isValid)
		{
			Effect.server.Run(spawnEffect.resourcePath, ((Component)instance).GetComponent<BaseEntity>(), 0u, Vector3.zero, Vector3.up);
		}
		OnObjectSpawnedEvent.Invoke();
		SetSpawningActive(newState: false);
	}

	public override void ObjectRetired(SpawnPointInstance instance)
	{
		OnObjectRetiredEvent.Invoke();
		SetSpawningActive(newState: true);
	}
}


using UnityEngine;

public class IndividualSpawner : BaseMonoBehaviour, IServerComponent, ISpawnPointUser, ISpawnGroup
{
	public GameObjectRef entityPrefab;

	public float respawnDelayMin = 10f;

	public float respawnDelayMax = 20f;

	public bool useCustomBoundsCheckMask;

	public LayerMask customBoundsCheckMask;

	[Tooltip("Simply spawns the entity once. No respawning. Entity can be saved if desired.")]
	[SerializeField]
	public bool oneTimeSpawner;

	internal bool isSpawnerActive = true;

	public SpawnPointInstance spawnInstance;

	public float nextSpawnTime = -1f;

	public int currentPopulation
	{
		get
		{
			if (!((Object)(object)spawnInstance == (Object)null))
			{
				return 1;
			}
			return 0;
		}
	}

	public bool IsSpawned => (Object)(object)spawnInstance != (Object)null;

	protected void Awake()
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.SpawnGroups.Add((ISpawnGroup)this);
		}
		else
		{
			Debug.LogWarning((object)(((object)this).GetType().Name + ": SpawnHandler instance not found."));
		}
	}

	protected void OnDestroy()
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.SpawnGroups.Remove((ISpawnGroup)this);
		}
		else
		{
			Debug.LogWarning((object)(((object)this).GetType().Name + ": SpawnHandler instance not found."));
		}
	}

	protected void OnDrawGizmosSelected()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if (TryGetEntityBounds(out var result))
		{
			Gizmos.color = Color.yellow;
			Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
			Gizmos.DrawCube(((Bounds)(ref result)).center, ((Bounds)(ref result)).size);
		}
	}

	public void ObjectSpawned(SpawnPointInstance instance)
	{
		spawnInstance = instance;
	}

	public void ObjectRetired(SpawnPointInstance instance)
	{
		spawnInstance = null;
		nextSpawnTime = Time.time + Random.Range(respawnDelayMin, respawnDelayMax);
	}

	public void Fill()
	{
		if (!oneTimeSpawner)
		{
			TrySpawnEntity();
		}
	}

	public void SpawnInitial()
	{
		TrySpawnEntity();
	}

	public void Clear()
	{
		if (IsSpawned)
		{
			BaseEntity baseEntity = ((Component)spawnInstance).gameObject.ToBaseEntity();
			if ((Object)(object)baseEntity != (Object)null)
			{
				baseEntity.Kill();
			}
		}
	}

	public void SpawnRepeating()
	{
		if (!IsSpawned && !oneTimeSpawner && Time.time >= nextSpawnTime)
		{
			TrySpawnEntity();
		}
	}

	public bool HasSpaceToSpawn()
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (useCustomBoundsCheckMask)
		{
			return SpawnHandler.CheckBounds(entityPrefab.Get(), ((Component)this).transform.position, ((Component)this).transform.rotation, Vector3.one, customBoundsCheckMask);
		}
		return SingletonComponent<SpawnHandler>.Instance.CheckBounds(entityPrefab.Get(), ((Component)this).transform.position, ((Component)this).transform.rotation, Vector3.one);
	}

	public virtual void TrySpawnEntity()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		if (!isSpawnerActive || IsSpawned)
		{
			return;
		}
		if (!HasSpaceToSpawn())
		{
			nextSpawnTime = Time.time + Random.Range(respawnDelayMin, respawnDelayMax);
			return;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(entityPrefab.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation, startActive: false);
		if ((Object)(object)baseEntity != (Object)null)
		{
			if (!oneTimeSpawner)
			{
				baseEntity.enableSaving = false;
			}
			((Component)baseEntity).gameObject.AwakeFromInstantiate();
			baseEntity.Spawn();
			SpawnPointInstance spawnPointInstance = ((Component)baseEntity).gameObject.AddComponent<SpawnPointInstance>();
			spawnPointInstance.parentSpawnPointUser = this;
			spawnPointInstance.Notify();
		}
		else
		{
			Debug.LogError((object)"IndividualSpawner failed to spawn entity.", (Object)(object)((Component)this).gameObject);
		}
	}

	public bool TryGetEntityBounds(out Bounds result)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (entityPrefab != null)
		{
			GameObject val = entityPrefab.Get();
			if ((Object)(object)val != (Object)null)
			{
				BaseEntity component = val.GetComponent<BaseEntity>();
				if ((Object)(object)component != (Object)null)
				{
					result = component.bounds;
					return true;
				}
			}
		}
		result = default(Bounds);
		return false;
	}
}


public class IndividualSpawnerNexusOnly : IndividualSpawner
{
	protected override void TrySpawnEntity()
	{
		isSpawnerActive = NexusServer.Started;
		base.TrySpawnEntity();
	}
}


public interface ISpawnGroup
{
	int currentPopulation { get; }

	void Clear();

	void Fill();

	void SpawnInitial();

	void SpawnRepeating();
}


public interface ISpawnPointUser
{
	void ObjectSpawned(SpawnPointInstance instance);

	void ObjectRetired(SpawnPointInstance instance);
}


using ConVar;
using UnityEngine;

public class JunkpileNPCSpawner : NPCSpawner
{
	[Header("Junkpile NPC Spawner")]
	public bool UseSpawnChance;

	protected override void Spawn(int numToSpawn)
	{
		if (!UseSpawnChance || !(Random.value > AI.npc_junkpilespawn_chance))
		{
			base.Spawn(numToSpawn);
		}
	}
}


using System;
using ConVar;
using UnityEngine;

public class NPCSpawner : SpawnGroup
{
	public int AdditionalLOSBlockingLayer;

	public MonumentNavMesh monumentNavMesh;

	public bool shouldFillOnSpawn;

	[Header("InfoZone Config")]
	public AIInformationZone VirtualInfoZone;

	[Header("Navigator Config")]
	public AIMovePointPath Path;

	public BasePath AStarGraph;

	[Header("Human Stat Replacements")]
	public bool UseStatModifiers;

	public float SenseRange = 30f;

	public bool CheckLOS = true;

	public float TargetLostRange = 50f;

	public float AttackRangeMultiplier = 1f;

	public float ListenRange = 10f;

	public float CanUseHealingItemsChance;

	[Header("Loadout Replacements")]
	public PlayerInventoryProperties[] Loadouts;

	public override void SpawnInitial()
	{
		if (!AI.npc_spawn_on_cargo_ship && ((Component)this).transform.root.ToBaseEntity() is CargoShip)
		{
			((Behaviour)this).enabled = false;
			return;
		}
		if (!AI.npc_spawn_on_junkpile && ((Component)this).transform.root.ToBaseEntity() is JunkPile)
		{
			((Behaviour)this).enabled = false;
			return;
		}
		fillOnSpawn = shouldFillOnSpawn;
		if (WaitingForNavMesh())
		{
			((FacepunchBehaviour)this).Invoke((Action)LateSpawn, 10f);
		}
		else
		{
			base.SpawnInitial();
		}
	}

	public bool WaitingForNavMesh()
	{
		if ((Object)(object)monumentNavMesh != (Object)null)
		{
			return monumentNavMesh.IsBuilding;
		}
		if (!DungeonNavmesh.NavReady())
		{
			return true;
		}
		return !AI.move;
	}

	public void LateSpawn()
	{
		if (!WaitingForNavMesh())
		{
			SpawnInitial();
			Debug.Log((object)"Navmesh complete, spawning");
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)LateSpawn, 5f);
		}
	}

	protected override void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
	{
		base.PostSpawnProcess(entity, spawnPoint);
		BaseNavigator component = ((Component)entity).GetComponent<BaseNavigator>();
		if (AdditionalLOSBlockingLayer != 0 && (Object)(object)entity != (Object)null && entity is HumanNPC humanNPC)
		{
			humanNPC.AdditionalLosBlockingLayer = AdditionalLOSBlockingLayer;
		}
		HumanNPC humanNPC2 = entity as HumanNPC;
		if ((Object)(object)humanNPC2 != (Object)null)
		{
			if (Loadouts != null && Loadouts.Length != 0)
			{
				humanNPC2.EquipLoadout(Loadouts);
			}
			ModifyHumanBrainStats(humanNPC2.Brain);
		}
		if ((Object)(object)VirtualInfoZone != (Object)null)
		{
			if (VirtualInfoZone.Virtual)
			{
				NPCPlayer nPCPlayer = entity as NPCPlayer;
				if ((Object)(object)nPCPlayer != (Object)null)
				{
					nPCPlayer.VirtualInfoZone = VirtualInfoZone;
					if ((Object)(object)humanNPC2 != (Object)null)
					{
						humanNPC2.VirtualInfoZone.RegisterSleepableEntity(humanNPC2.Brain);
					}
				}
			}
			else
			{
				Debug.LogError((object)"NPCSpawner trying to set a virtual info zone without the Virtual property!");
			}
		}
		if ((Object)(object)component != (Object)null)
		{
			component.Path = Path;
			component.AStarGraph = AStarGraph;
		}
	}

	private void ModifyHumanBrainStats(BaseAIBrain brain)
	{
		if (UseStatModifiers && !((Object)(object)brain == (Object)null))
		{
			brain.SenseRange = SenseRange;
			brain.TargetLostRange *= TargetLostRange;
			brain.AttackRangeMultiplier = AttackRangeMultiplier;
			brain.ListenRange = ListenRange;
			brain.CheckLOS = CheckLOS;
			if (CanUseHealingItemsChance > 0f)
			{
				brain.CanUseHealingItems = Random.Range(0f, 1f) <= CanUseHealingItemsChance;
			}
		}
	}
}


using UnityEngine;

public class RadialSpawnPoint : BaseSpawnPoint
{
	[Tooltip("Circle to spawn within")]
	[SerializeField]
	public float radius = 10f;

	public override void GetLocation(out Vector3 pos, out Quaternion rot)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = Random.insideUnitCircle * radius;
		pos = ((Component)this).transform.position + new Vector3(val.x, 0f, val.y);
		rot = Quaternion.Euler(0f, Random.Range(0f, 360f), 0f);
		DropToGround(ref pos, ref rot);
	}

	public override bool HasPlayersIntersecting()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return BaseNetworkable.HasCloseConnections(((Component)this).transform.position, radius + playerCheckMargin);
	}

	public override void ObjectSpawned(SpawnPointInstance instance)
	{
	}

	public override void ObjectRetired(SpawnPointInstance instance)
	{
	}
}


using System;

public class SingleSpawn : SpawnGroup
{
	public override bool WantsInitialSpawn()
	{
		return false;
	}

	public void FillDelay(float delay)
	{
		((FacepunchBehaviour)this).Invoke((Action)Fill, delay);
	}
}


using UnityEngine;

public class SpaceCheckingSpawnPoint : GenericSpawnPoint
{
	public bool useCustomBoundsCheckMask;

	public LayerMask customBoundsCheckMask;

	public float customBoundsCheckScale = 1f;

	public override bool IsAvailableTo(GameObject prefab)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		if (!base.IsAvailableTo(prefab))
		{
			return false;
		}
		if (useCustomBoundsCheckMask)
		{
			return SpawnHandler.CheckBounds(prefab, ((Component)this).transform.position, ((Component)this).transform.rotation, Vector3.one * customBoundsCheckScale, customBoundsCheckMask);
		}
		return SingletonComponent<SpawnHandler>.Instance.CheckBounds(prefab, ((Component)this).transform.position, ((Component)this).transform.rotation, Vector3.one * customBoundsCheckScale);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

public class SpawnGroup : BaseMonoBehaviour, IServerComponent, ISpawnPointUser, ISpawnGroup
{
	[Serializable]
	public class SpawnEntry
	{
		public GameObjectRef prefab;

		public int weight = 1;

		public bool mobile;
	}

	[InspectorFlags]
	public MonumentTier Tier = (MonumentTier)(-1);

	public List<SpawnEntry> prefabs;

	public int maxPopulation = 5;

	public int numToSpawnPerTickMin = 1;

	public int numToSpawnPerTickMax = 2;

	public float respawnDelayMin = 10f;

	public float respawnDelayMax = 20f;

	public bool wantsInitialSpawn = true;

	public bool temporary;

	public bool forceInitialSpawn;

	public bool preventDuplicates;

	public bool isSpawnerActive = true;

	public BoxCollider setFreeIfMovedBeyond;

	public string category;

	[NonSerialized]
	public MonumentInfo Monument;

	public bool fillOnSpawn;

	public BaseSpawnPoint[] spawnPoints;

	public List<SpawnPointInstance> spawnInstances = new List<SpawnPointInstance>();

	public LocalClock spawnClock = new LocalClock();

	public int currentPopulation => spawnInstances.Count;

	public IEnumerable<SpawnPointInstance> SpawnInstances => spawnInstances;

	public int ObjectsAdded { get; private set; }

	public int ObjectsRemoved { get; private set; }

	protected virtual bool BlockSpawnedEntitySaving => true;

	protected virtual bool AllowOverlappingSpawns => false;

	public bool DoesGroupContainNPCs()
	{
		foreach (SpawnEntry prefab in prefabs)
		{
			GameObject val = prefab.prefab?.Get();
			if (!((Object)(object)val == (Object)null))
			{
				BaseCombatEntity component = val.GetComponent<BaseCombatEntity>();
				if (!((Object)(object)component == (Object)null) && component.IsNpc)
				{
					return true;
				}
			}
		}
		return false;
	}

	public virtual bool WantsInitialSpawn()
	{
		return wantsInitialSpawn;
	}

	public virtual bool WantsTimedSpawn()
	{
		return respawnDelayMax != float.PositiveInfinity;
	}

	public float GetSpawnDelta()
	{
		return (respawnDelayMax + respawnDelayMin) * 0.5f / SpawnHandler.PlayerScale(ConVar.Spawn.player_scale);
	}

	public float GetSpawnVariance()
	{
		return (respawnDelayMax - respawnDelayMin) * 0.5f / SpawnHandler.PlayerScale(ConVar.Spawn.player_scale);
	}

	protected void Awake()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.TopologyMap == (Object)null)
		{
			return;
		}
		int topology = TerrainMeta.TopologyMap.GetTopology(((Component)this).transform.position);
		int num = 469762048;
		int num2 = MonumentInfo.TierToMask(Tier);
		if (num2 == num || (num2 & topology) != 0)
		{
			spawnPoints = ((Component)this).GetComponentsInChildren<BaseSpawnPoint>();
			if (WantsTimedSpawn())
			{
				spawnClock.Add(GetSpawnDelta(), GetSpawnVariance(), Spawn);
			}
			if (!temporary && Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
			{
				SingletonComponent<SpawnHandler>.Instance.SpawnGroups.Add((ISpawnGroup)this);
			}
			if (forceInitialSpawn)
			{
				((FacepunchBehaviour)this).Invoke((Action)SpawnInitial, 1f);
			}
			Monument = FindMonument();
		}
	}

	protected void OnDestroy()
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.SpawnGroups.Remove((ISpawnGroup)this);
		}
		else
		{
			Debug.LogWarning((object)(((object)this).GetType().Name + ": SpawnHandler instance not found."));
		}
	}

	public void Fill()
	{
		if (isSpawnerActive)
		{
			Spawn(maxPopulation);
		}
	}

	public void Clear()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		for (int num = spawnInstances.Count - 1; num >= 0; num--)
		{
			SpawnPointInstance spawnPointInstance = spawnInstances[num];
			BaseEntity baseEntity = ((Component)spawnPointInstance).gameObject.ToBaseEntity();
			if ((Object)(object)setFreeIfMovedBeyond != (Object)null)
			{
				Bounds bounds = ((Collider)setFreeIfMovedBeyond).bounds;
				if (!((Bounds)(ref bounds)).Contains(((Component)baseEntity).transform.position))
				{
					spawnPointInstance.Retire();
					continue;
				}
			}
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.Kill();
			}
		}
		spawnInstances.Clear();
	}

	public bool HasSpawned(uint prefabID)
	{
		foreach (SpawnPointInstance spawnInstance in spawnInstances)
		{
			BaseEntity baseEntity = ((Component)spawnInstance).gameObject.ToBaseEntity();
			if (Object.op_Implicit((Object)(object)baseEntity) && baseEntity.prefabID == prefabID)
			{
				return true;
			}
		}
		return false;
	}

	public virtual void SpawnInitial()
	{
		if (wantsInitialSpawn && isSpawnerActive)
		{
			if (fillOnSpawn)
			{
				Spawn(maxPopulation);
			}
			else
			{
				Spawn();
			}
		}
	}

	public void SpawnRepeating()
	{
		for (int i = 0; i < spawnClock.events.Count; i++)
		{
			LocalClock.TimedEvent value = spawnClock.events[i];
			if (Time.time > value.time)
			{
				value.delta = GetSpawnDelta();
				value.variance = GetSpawnVariance();
				spawnClock.events[i] = value;
			}
		}
		spawnClock.Tick();
	}

	public void ObjectSpawned(SpawnPointInstance instance)
	{
		spawnInstances.Add(instance);
		ObjectsAdded++;
	}

	public void ObjectRetired(SpawnPointInstance instance)
	{
		spawnInstances.Remove(instance);
		ObjectsRemoved++;
	}

	public void DelayedSpawn()
	{
		((FacepunchBehaviour)this).Invoke((Action)Spawn, 1f);
	}

	public void Spawn()
	{
		if (isSpawnerActive)
		{
			Spawn(Random.Range(numToSpawnPerTickMin, numToSpawnPerTickMax + 1));
		}
	}

	protected virtual void Spawn(int numToSpawn)
	{
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.scientist_spawners_enabled && prefabs != null)
		{
			foreach (SpawnEntry prefab2 in prefabs)
			{
				BaseEntity baseEntity = prefab2?.prefab?.GetEntity();
				if (baseEntity is ScientistNPC || baseEntity is TunnelDweller || baseEntity is UnderwaterDweller)
				{
					((Behaviour)this).enabled = false;
					return;
				}
			}
		}
		numToSpawn = Mathf.Min(numToSpawn, maxPopulation - currentPopulation);
		for (int i = 0; i < numToSpawn; i++)
		{
			GameObjectRef prefab = GetPrefab();
			if (prefab == null || string.IsNullOrEmpty(prefab.guid))
			{
				continue;
			}
			Vector3 pos;
			Quaternion rot;
			BaseSpawnPoint spawnPoint = GetSpawnPoint(prefab, out pos, out rot);
			if (!Object.op_Implicit((Object)(object)spawnPoint))
			{
				continue;
			}
			BaseEntity baseEntity2 = GameManager.server.CreateEntity(prefab.resourcePath, pos, rot, startActive: false);
			if (Object.op_Implicit((Object)(object)baseEntity2))
			{
				if (baseEntity2.enableSaving && BlockSpawnedEntitySaving && !(spawnPoint is SpaceCheckingSpawnPoint))
				{
					baseEntity2.enableSaving = false;
				}
				((Component)baseEntity2).gameObject.AwakeFromInstantiate();
				baseEntity2.Spawn();
				PostSpawnProcess(baseEntity2, spawnPoint);
				SpawnPointInstance spawnPointInstance = ((Component)baseEntity2).gameObject.AddComponent<SpawnPointInstance>();
				spawnPointInstance.parentSpawnPointUser = this;
				spawnPointInstance.parentSpawnPoint = spawnPoint;
				spawnPointInstance.Entity = baseEntity2;
				spawnPointInstance.Notify();
			}
		}
	}

	protected virtual void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (entity is HumanNPC humanNPC)
		{
			Vector3 position = ((Component)spawnPoint).transform.position;
			bool num = TerrainMeta.BiomeMap.GetBiomeMaxType(position) == 16;
			bool flag = EnvironmentManager.Check(position, EnvironmentType.TrainTunnels | EnvironmentType.UnderwaterLab | EnvironmentType.Submarine);
			bool topology = TerrainMeta.TopologyMap.GetTopology(position, 128);
			if (num && !flag && !topology && SingletonComponent<SpawnHandler>.Instance.JungleLoadouts != null && SingletonComponent<SpawnHandler>.Instance.JungleLoadouts.Length != 0)
			{
				humanNPC.EquipLoadout(SingletonComponent<SpawnHandler>.Instance.JungleLoadouts);
			}
		}
	}

	protected GameObjectRef GetPrefab()
	{
		float num = prefabs.Sum((SpawnEntry x) => (!preventDuplicates || !HasSpawned(x.prefab.resourceID)) ? x.weight : 0);
		if (num == 0f)
		{
			return null;
		}
		float num2 = Random.Range(0f, num);
		foreach (SpawnEntry prefab in prefabs)
		{
			int num3 = ((!preventDuplicates || !HasSpawned(prefab.prefab.resourceID)) ? prefab.weight : 0);
			if ((num2 -= (float)num3) <= 0f)
			{
				return prefab.prefab;
			}
		}
		return prefabs[prefabs.Count - 1].prefab;
	}

	protected virtual BaseSpawnPoint GetSpawnPoint(GameObjectRef prefabRef, out Vector3 pos, out Quaternion rot)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		pos = Vector3.zero;
		rot = Quaternion.identity;
		int num = Random.Range(0, spawnPoints.Length);
		NavMeshHit val = default(NavMeshHit);
		for (int i = 0; i < spawnPoints.Length; i++)
		{
			BaseSpawnPoint baseSpawnPoint = spawnPoints[(num + i) % spawnPoints.Length];
			if (!((Object)(object)baseSpawnPoint == (Object)null) && (baseSpawnPoint.IsAvailableTo(prefabRef.Get()) || AllowOverlappingSpawns) && !baseSpawnPoint.HasPlayersIntersecting())
			{
				baseSpawnPoint.GetLocation(out pos, out rot);
				if (!DoesRequireNavmeshToSpawn(prefabRef.Get()))
				{
					return baseSpawnPoint;
				}
				if (NavMesh.SamplePosition(pos, ref val, 2f, -1))
				{
					pos = ((NavMeshHit)(ref val)).position;
					rot = Quaternion.LookRotation(rot * Vector3.forward, ((NavMeshHit)(ref val)).normal);
					return baseSpawnPoint;
				}
				if (AI.logIssues)
				{
					Debug.LogWarning((object)$"Failed to spawn {prefabRef.Get()} at {pos} - no navmesh found");
				}
			}
		}
		return null;
	}

	private static bool DoesRequireNavmeshToSpawn(GameObject prefab)
	{
		if (!AI.npc_check_spawner_is_on_navmesh)
		{
			return false;
		}
		if (((Object)(object)prefab.GetComponent<BaseNavigator>()).Is<BaseNavigator>(out BaseNavigator entAsT) && entAsT.CanUseNavMesh)
		{
			return true;
		}
		if ((Object)(object)prefab.GetComponent<LimitedTurnNavAgent>() != (Object)null)
		{
			return true;
		}
		return false;
	}

	private MonumentInfo FindMonument()
	{
		return ((Component)this).GetComponentInParent<MonumentInfo>();
	}

	protected virtual void OnDrawGizmos()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = new Color(1f, 1f, 0f, 1f);
		Gizmos.DrawSphere(((Component)this).transform.position, 0.25f);
	}
}


using System;

[Serializable]
public class SpawnEntry
{
	public GameObjectRef prefab;

	public int weight = 1;

	public bool mobile;
}


using Rust;
using UnityEngine;

public class SpawnPointInstance : MonoBehaviour
{
	internal BaseEntity Entity;

	public ISpawnPointUser parentSpawnPointUser;

	public BaseSpawnPoint parentSpawnPoint;

	public void Notify()
	{
		if (!parentSpawnPointUser.IsUnityNull())
		{
			parentSpawnPointUser.ObjectSpawned(this);
		}
		if (Object.op_Implicit((Object)(object)parentSpawnPoint))
		{
			parentSpawnPoint.ObjectSpawned(this);
		}
	}

	public void Retire()
	{
		if (!parentSpawnPointUser.IsUnityNull())
		{
			parentSpawnPointUser.ObjectRetired(this);
		}
		if (Object.op_Implicit((Object)(object)parentSpawnPoint))
		{
			parentSpawnPoint.ObjectRetired(this);
		}
	}

	protected void OnDestroy()
	{
		if (!Application.isQuitting)
		{
			Retire();
		}
	}
}


using UnityEngine;

public class VehicleSpawnPoint : SpaceCheckingSpawnPoint
{
	public override void ObjectSpawned(SpawnPointInstance instance)
	{
		base.ObjectSpawned(instance);
		AddStartingFuel(((Component)instance).gameObject.ToBaseEntity() as VehicleSpawner.IVehicleSpawnUser);
	}

	public static void AddStartingFuel(VehicleSpawner.IVehicleSpawnUser vehicle)
	{
		vehicle?.GetFuelSystem()?.AddFuel(vehicle.StartingFuelUnits());
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using ConVar;
using UnityEngine;

public class SpawnHandler : SingletonComponent<SpawnHandler>
{
	public float TickInterval = 60f;

	public int MinSpawnsPerTick = 100;

	public int MaxSpawnsPerTick = 100;

	public LayerMask PlacementMask;

	public LayerMask PlacementCheckMask;

	public float PlacementCheckHeight = 25f;

	public LayerMask RadiusCheckMask;

	public float RadiusCheckDistance = 5f;

	public LayerMask BoundsCheckMask;

	public SpawnFilter CharacterSpawn;

	public float CharacterSpawnCutoff;

	public SpawnPopulationBase[] SpawnPopulations;

	public SpawnDistribution[] SpawnDistributions;

	public SpawnDistribution CharDistribution;

	public ListHashSet<ISpawnGroup> SpawnGroups = new ListHashSet<ISpawnGroup>();

	internal List<SpawnIndividual> SpawnIndividuals = new List<SpawnIndividual>();

	[Header("Scientist Outfits")]
	public PlayerInventoryProperties[] JungleLoadouts;

	[ReadOnly]
	public SpawnPopulationBase[] ConvarSpawnPopulations;

	public Dictionary<SpawnPopulationBase, SpawnDistribution> population2distribution;

	private bool spawnTick;

	public SpawnPopulationBase[] AllSpawnPopulations;

	private static int PlayerCount
	{
		get
		{
			if (ConVar.Spawn.loot_population_test <= 0)
			{
				return BasePlayer.activePlayerList.Count;
			}
			return ConVar.Spawn.loot_population_test;
		}
	}

	protected void OnEnable()
	{
		AllSpawnPopulations = SpawnPopulations.Concat(ConvarSpawnPopulations).ToArray();
		((MonoBehaviour)this).StartCoroutine(SpawnTick());
		((MonoBehaviour)this).StartCoroutine(SpawnGroupTick());
		((MonoBehaviour)this).StartCoroutine(SpawnIndividualTick());
	}

	public static BasePlayer.SpawnPoint GetSpawnPoint()
	{
		if ((Object)(object)SingletonComponent<SpawnHandler>.Instance == (Object)null || SingletonComponent<SpawnHandler>.Instance.CharDistribution == null)
		{
			return null;
		}
		BasePlayer.SpawnPoint spawnPoint = new BasePlayer.SpawnPoint();
		if (!((WaterSystem.OceanLevel < 0.5f) ? GetSpawnPointStandard(spawnPoint) : FloodedSpawnHandler.GetSpawnPoint(spawnPoint, WaterSystem.OceanLevel + 1f)))
		{
			return null;
		}
		return spawnPoint;
	}

	public static BasePlayer.SpawnPoint GetSpawnPointForTeam(ulong teamId)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (teamId == 0L)
		{
			return null;
		}
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(teamId);
		if (playerTeam == null)
		{
			return null;
		}
		if (!playerTeam.usePartySpawn)
		{
			return null;
		}
		if (playerTeam.firstSpawnLocation == default(Vector3))
		{
			return null;
		}
		float num = 100000f;
		BasePlayer.SpawnPoint spawnPoint = null;
		for (int i = 0; i < party.maxpartyspawnattempts; i++)
		{
			BasePlayer.SpawnPoint spawnPoint2 = GetSpawnPoint();
			float num2 = Vector3Ex.Distance2D(spawnPoint2.pos, playerTeam.firstSpawnLocation);
			if (num2 < num || spawnPoint == null)
			{
				spawnPoint = spawnPoint2;
				num = num2;
			}
			if (num2 < (float)party.maxpartyspawndistance)
			{
				return spawnPoint2;
			}
		}
		return spawnPoint;
	}

	private static bool GetSpawnPointStandard(BasePlayer.SpawnPoint spawnPoint)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < 60; i++)
		{
			if (!SingletonComponent<SpawnHandler>.Instance.CharDistribution.Sample(out spawnPoint.pos, out spawnPoint.rot, alignToNormal: false, 0f, 0.5f, SingletonComponent<SpawnHandler>.Instance.CharacterSpawn, SingletonComponent<SpawnHandler>.Instance.CharacterSpawnCutoff))
			{
				continue;
			}
			bool flag = true;
			if ((Object)(object)TerrainMeta.Path != (Object)null)
			{
				foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
				{
					if (monument.Distance(spawnPoint.pos) < 50f)
					{
						flag = false;
						break;
					}
				}
			}
			if (flag)
			{
				return true;
			}
		}
		return false;
	}

	public void UpdateDistributions()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		if (World.Size == 0)
		{
			return;
		}
		SpawnDistributions = new SpawnDistribution[AllSpawnPopulations.Length];
		population2distribution = new Dictionary<SpawnPopulationBase, SpawnDistribution>();
		Vector3 size = TerrainMeta.Size;
		Vector3 position = TerrainMeta.Position;
		int populationRes = Mathf.NextPowerOfTwo((int)((float)World.Size * 0.25f));
		for (int i = 0; i < AllSpawnPopulations.Length; i++)
		{
			SpawnPopulationBase spawnPopulationBase = AllSpawnPopulations[i];
			if (spawnPopulationBase == null)
			{
				Debug.LogError((object)"Spawn handler contains null spawn population.");
				continue;
			}
			byte[] baseMapValues = spawnPopulationBase.GetBaseMapValues(populationRes);
			SpawnDistribution value = (SpawnDistributions[i] = new SpawnDistribution(this, baseMapValues, position, size));
			population2distribution.Add(spawnPopulationBase, value);
		}
		int char_res = Mathf.NextPowerOfTwo((int)((float)World.Size * 0.5f));
		byte[] map = new byte[char_res * char_res];
		SpawnFilter filter = CharacterSpawn;
		float cutoff = CharacterSpawnCutoff;
		Parallel.For(0, char_res, (Action<int>)delegate(int z)
		{
			for (int j = 0; j < char_res; j++)
			{
				float normX = ((float)j + 0.5f) / (float)char_res;
				float normZ = ((float)z + 0.5f) / (float)char_res;
				float factor = filter.GetFactor(normX, normZ);
				map[z * char_res + j] = (byte)((factor > cutoff) ? (255f * factor) : 0f);
			}
		});
		CharDistribution = new SpawnDistribution(this, map, position, size);
	}

	public void FillPopulations()
	{
		if (SpawnDistributions == null)
		{
			return;
		}
		for (int i = 0; i < AllSpawnPopulations.Length; i++)
		{
			if (!(AllSpawnPopulations[i] == null))
			{
				SpawnInitial(AllSpawnPopulations[i], SpawnDistributions[i]);
			}
		}
	}

	public void DeletePopulation(string name)
	{
		SpawnPopulationBase[] allSpawnPopulations = AllSpawnPopulations;
		foreach (SpawnPopulationBase spawnPopulationBase in allSpawnPopulations)
		{
			if (((Object)spawnPopulationBase).name == name)
			{
				spawnPopulationBase.DeleteEntities();
				break;
			}
		}
	}

	public void DeleteAllPopulations()
	{
		SpawnPopulationBase[] allSpawnPopulations = AllSpawnPopulations;
		for (int i = 0; i < allSpawnPopulations.Length; i++)
		{
			allSpawnPopulations[i].DeleteEntities();
		}
	}

	public void FillGroups()
	{
		for (int i = 0; i < SpawnGroups.Count; i++)
		{
			SpawnGroups[i].Fill();
		}
	}

	public void FillIndividuals()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < SpawnIndividuals.Count; i++)
		{
			SpawnIndividual spawnIndividual = SpawnIndividuals[i];
			Spawn(Prefab.Load<Spawnable>(spawnIndividual.PrefabID, (GameManager)null, (PrefabAttribute.Library)null), spawnIndividual.Position, spawnIndividual.Rotation);
		}
	}

	public void InitialSpawn()
	{
		if (ConVar.Spawn.respawn_populations && SpawnDistributions != null)
		{
			for (int i = 0; i < AllSpawnPopulations.Length; i++)
			{
				if (!(AllSpawnPopulations[i] == null))
				{
					SpawnInitial(AllSpawnPopulations[i], SpawnDistributions[i]);
				}
			}
		}
		if (ConVar.Spawn.respawn_groups)
		{
			for (int j = 0; j < SpawnGroups.Count; j++)
			{
				SpawnGroups[j].SpawnInitial();
			}
		}
	}

	public void StartSpawnTick()
	{
		spawnTick = true;
	}

	private IEnumerator SpawnTick()
	{
		while (true)
		{
			yield return CoroutineEx.waitForEndOfFrame;
			if (!spawnTick || !ConVar.Spawn.respawn_populations)
			{
				continue;
			}
			yield return CoroutineEx.waitForSeconds(ConVar.Spawn.tick_populations);
			for (int i = 0; i < AllSpawnPopulations.Length; i++)
			{
				SpawnPopulationBase spawnPopulationBase = AllSpawnPopulations[i];
				if (spawnPopulationBase == null)
				{
					continue;
				}
				SpawnDistribution spawnDistribution = SpawnDistributions[i];
				if (spawnDistribution == null)
				{
					continue;
				}
				try
				{
					if (SpawnDistributions != null)
					{
						SpawnRepeating(spawnPopulationBase, spawnDistribution);
					}
				}
				catch (Exception ex)
				{
					Debug.LogError((object)ex);
				}
				yield return CoroutineEx.waitForEndOfFrame;
			}
		}
	}

	private IEnumerator SpawnGroupTick()
	{
		while (true)
		{
			yield return CoroutineEx.waitForEndOfFrame;
			if (!spawnTick || !ConVar.Spawn.respawn_groups)
			{
				continue;
			}
			yield return CoroutineEx.waitForSeconds(1f);
			for (int i = 0; i < SpawnGroups.Count; i++)
			{
				ISpawnGroup spawnGroup = SpawnGroups[i];
				if (spawnGroup != null)
				{
					try
					{
						spawnGroup.SpawnRepeating();
					}
					catch (Exception ex)
					{
						Debug.LogError((object)ex);
					}
					yield return CoroutineEx.waitForEndOfFrame;
				}
			}
		}
	}

	private IEnumerator SpawnIndividualTick()
	{
		while (true)
		{
			yield return CoroutineEx.waitForEndOfFrame;
			if (!spawnTick || !ConVar.Spawn.respawn_individuals)
			{
				continue;
			}
			yield return CoroutineEx.waitForSeconds(ConVar.Spawn.tick_individuals);
			for (int i = 0; i < SpawnIndividuals.Count; i++)
			{
				SpawnIndividual spawnIndividual = SpawnIndividuals[i];
				try
				{
					Spawn(Prefab.Load<Spawnable>(spawnIndividual.PrefabID, (GameManager)null, (PrefabAttribute.Library)null), spawnIndividual.Position, spawnIndividual.Rotation);
				}
				catch (Exception ex)
				{
					Debug.LogError((object)ex);
				}
				yield return CoroutineEx.waitForEndOfFrame;
			}
		}
	}

	public void SpawnInitial(SpawnPopulationBase population, SpawnDistribution distribution)
	{
		int targetCount = population.GetTargetCount(distribution);
		int count = distribution.Count;
		int numToFill = targetCount - count;
		population.Fill(this, distribution, numToFill, initialSpawn: true);
	}

	public void SpawnRepeating(SpawnPopulationBase population, SpawnDistribution distribution)
	{
		int targetCount = population.GetTargetCount(distribution);
		int count = distribution.Count;
		int num = targetCount - count;
		num = Mathf.RoundToInt((float)num * population.GetCurrentSpawnRate());
		num = Random.Range(Mathf.Min(num, MinSpawnsPerTick), Mathf.Min(num, MaxSpawnsPerTick));
		population.Fill(this, distribution, num, initialSpawn: false);
	}

	public GameObject Spawn(SpawnPopulationBase population, Prefab<Spawnable> prefab, Vector3 pos, Quaternion rot)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		if (prefab == null)
		{
			return null;
		}
		if ((Object)(object)prefab.Component == (Object)null)
		{
			Debug.LogError((object)("[Spawn] Missing component 'Spawnable' on " + prefab.Name));
			return null;
		}
		Vector3 scale = Vector3.one;
		DecorComponent[] components = PrefabAttribute.server.FindAll<DecorComponent>(prefab.ID);
		prefab.Object.transform.ApplyDecorComponents(components, ref pos, ref rot, ref scale);
		if (!prefab.ApplyTerrainFilters(pos, rot, scale))
		{
			return null;
		}
		if (!prefab.ApplyTerrainAnchors(ref pos, rot, scale, TerrainAnchorMode.MinimizeMovement, population.GetSpawnFilter()))
		{
			return null;
		}
		if (!prefab.ApplyTerrainChecks(pos, rot, scale, population.GetSpawnFilter()))
		{
			return null;
		}
		if (!prefab.ApplyWaterChecks(pos, rot, scale))
		{
			return null;
		}
		if (!prefab.ApplyEnvironmentVolumeChecks(pos, rot, scale))
		{
			return null;
		}
		if (!prefab.ApplyBoundsChecks(pos, rot, scale, BoundsCheckMask))
		{
			return null;
		}
		if (Global.developer > 1)
		{
			Debug.Log((object)("[Spawn] Spawning " + prefab.Name));
		}
		BaseEntity baseEntity = prefab.SpawnEntity(pos, rot, active: false);
		if ((Object)(object)baseEntity == (Object)null)
		{
			Debug.LogWarning((object)("[Spawn] Couldn't create prefab as entity - " + prefab.Name));
			return null;
		}
		Spawnable component = ((Component)baseEntity).GetComponent<Spawnable>();
		if (component.Population != population)
		{
			component.Population = population;
		}
		((Component)baseEntity).gameObject.AwakeFromInstantiate();
		baseEntity.Spawn();
		return ((Component)baseEntity).gameObject;
	}

	private GameObject Spawn(Prefab<Spawnable> prefab, Vector3 pos, Quaternion rot)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (!CheckBounds(prefab.Object, pos, rot, Vector3.one))
		{
			return null;
		}
		BaseEntity baseEntity = prefab.SpawnEntity(pos, rot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			Debug.LogWarning((object)("[Spawn] Couldn't create prefab as entity - " + prefab.Name));
			return null;
		}
		baseEntity.Spawn();
		return ((Component)baseEntity).gameObject;
	}

	public bool CheckBounds(GameObject gameObject, Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return CheckBounds(gameObject, pos, rot, scale, BoundsCheckMask);
	}

	public static bool CheckBounds(GameObject gameObject, Vector3 pos, Quaternion rot, Vector3 scale, LayerMask mask)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)gameObject == (Object)null)
		{
			return true;
		}
		if (LayerMask.op_Implicit(mask) != 0)
		{
			BaseEntity component = gameObject.GetComponent<BaseEntity>();
			if ((Object)(object)component != (Object)null && Physics.CheckBox(pos + rot * Vector3.Scale(((Bounds)(ref component.bounds)).center, scale), Vector3.Scale(((Bounds)(ref component.bounds)).extents, scale), rot, LayerMask.op_Implicit(mask)))
			{
				return false;
			}
		}
		return true;
	}

	public void EnforceLimits(bool forceAll = false)
	{
		if (SpawnDistributions == null)
		{
			return;
		}
		for (int i = 0; i < AllSpawnPopulations.Length; i++)
		{
			if (!(AllSpawnPopulations[i] == null))
			{
				SpawnPopulationBase spawnPopulationBase = AllSpawnPopulations[i];
				SpawnDistribution distribution = SpawnDistributions[i];
				if (forceAll || spawnPopulationBase.EnforcePopulationLimits)
				{
					EnforceLimits(spawnPopulationBase, distribution);
				}
			}
		}
	}

	public void EnforceLimits(SpawnPopulationBase population, SpawnDistribution distribution)
	{
		int targetCount = population.GetTargetCount(distribution);
		Spawnable[] array = FindAll(population);
		if (array.Length <= targetCount)
		{
			return;
		}
		Debug.Log((object)(((object)population)?.ToString() + " has " + array.Length + " objects, but max allowed is " + targetCount));
		int count = array.Length - targetCount;
		Debug.Log((object)(" - deleting " + count + " objects"));
		foreach (Spawnable item in array.Take(count))
		{
			BaseEntity baseEntity = ((Component)item).gameObject.ToBaseEntity();
			if (baseEntity.IsValid())
			{
				baseEntity.Kill();
			}
			else
			{
				GameManager.Destroy(((Component)item).gameObject);
			}
		}
	}

	public Spawnable[] FindAll(SpawnPopulationBase population)
	{
		return (from x in Object.FindObjectsOfType<Spawnable>()
			where ((Component)x).gameObject.activeInHierarchy && x.Population == population
			select x).ToArray();
	}

	public void AddRespawn(SpawnIndividual individual)
	{
		SpawnIndividuals.Add(individual);
	}

	public void AddInstance(Spawnable spawnable)
	{
		if (spawnable.Population != null)
		{
			spawnable.Population.AddInstance(spawnable);
			if (!population2distribution.TryGetValue(spawnable.Population, out var value))
			{
				Debug.LogWarning((object)("[SpawnHandler] trying to add instance to invalid population: " + (object)spawnable.Population));
			}
			else
			{
				value.AddInstance(spawnable);
			}
		}
	}

	public void RemoveInstance(Spawnable spawnable)
	{
		if (spawnable.Population != null)
		{
			spawnable.Population.RemoveInstance(spawnable);
			if (!population2distribution.TryGetValue(spawnable.Population, out var value))
			{
				Debug.LogWarning((object)("[SpawnHandler] trying to remove instance from invalid population: " + (object)spawnable.Population));
			}
			else
			{
				value.RemoveInstance(spawnable);
			}
		}
	}

	public static float PlayerFraction()
	{
		float num = Mathf.Max(Server.maxplayers, 1);
		if (ConVar.Spawn.population_cap_rate > 0 && Server.maxplayers > ConVar.Spawn.population_cap_rate)
		{
			num = ConVar.Spawn.population_cap_rate;
		}
		return Mathf.Clamp01((float)PlayerCount / num);
	}

	public static float PlayerLerp(float min, float max)
	{
		return Mathf.Lerp(min, max, PlayerFraction());
	}

	public static float PlayerExcess()
	{
		float num = Mathf.Max(ConVar.Spawn.player_base, 1f);
		float num2 = PlayerCount;
		if (num2 > (float)ConVar.Spawn.population_cap_rate && ConVar.Spawn.population_cap_rate > 0)
		{
			num2 = ConVar.Spawn.population_cap_rate;
		}
		if (num2 <= num)
		{
			return 0f;
		}
		return (num2 - num) / num;
	}

	public static float PlayerScale(float scalar)
	{
		return Mathf.Max(1f, PlayerExcess() * scalar);
	}

	public void DumpReport(string filename)
	{
		File.AppendAllText(filename, "\r\n\r\nSpawnHandler Report:\r\n\r\n" + GetReport());
	}

	public string GetReport(bool detailed = true, string filter = null)
	{
		StringBuilder stringBuilder = new StringBuilder();
		if (AllSpawnPopulations == null)
		{
			stringBuilder.AppendLine("Spawn population array is null.");
		}
		if (SpawnDistributions == null)
		{
			stringBuilder.AppendLine("Spawn distribution array is null.");
		}
		if (AllSpawnPopulations != null && SpawnDistributions != null)
		{
			for (int i = 0; i < AllSpawnPopulations.Length; i++)
			{
				if (AllSpawnPopulations[i] == null)
				{
					continue;
				}
				SpawnPopulationBase spawnPopulationBase = AllSpawnPopulations[i];
				SpawnDistribution spawnDistribution = SpawnDistributions[i];
				if (filter != null && !((Object)spawnPopulationBase).name.Contains(filter))
				{
					continue;
				}
				if (spawnPopulationBase != null)
				{
					spawnPopulationBase.GetReportString(stringBuilder, detailed);
					if (spawnDistribution != null)
					{
						int count = spawnDistribution.Count;
						int targetCount = spawnPopulationBase.GetTargetCount(spawnDistribution);
						stringBuilder.AppendLine("\tPopulation: " + count + "/" + targetCount);
					}
					else
					{
						stringBuilder.AppendLine("\tDistribution #" + i + " is not set.");
					}
				}
				else
				{
					stringBuilder.AppendLine("Population #" + i + " is not set.");
				}
				stringBuilder.AppendLine();
			}
		}
		return stringBuilder.ToString();
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class StripRig : MonoBehaviour, IPrefabPreProcess
{
	public Transform root;

	public bool fromClient;

	public bool fromServer;

	bool IPrefabPreProcess.CanRunDuringBundling => true;

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (Object.op_Implicit((Object)(object)root) && ((serverside && fromServer) || (clientside && fromClient)))
		{
			SkinnedMeshRenderer component = ((Component)this).GetComponent<SkinnedMeshRenderer>();
			Strip(preProcess, component);
		}
		preProcess.RemoveComponent((Component)(object)this);
	}

	public void Strip(IPrefabProcessor preProcess, SkinnedMeshRenderer skinnedMeshRenderer)
	{
		List<Transform> list = Pool.Get<List<Transform>>();
		((Component)root).GetComponentsInChildren<Transform>(list);
		for (int num = list.Count - 1; num >= 0; num--)
		{
			if (preProcess != null)
			{
				preProcess.NominateForDeletion(((Component)list[num]).gameObject);
			}
			else
			{
				Object.DestroyImmediate((Object)(object)((Component)list[num]).gameObject);
			}
		}
		Pool.FreeUnmanaged<Transform>(ref list);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Oxide.Core;
using Rust;
using UnityEngine;

[CreateAssetMenu(fileName = "NewTechTree", menuName = "Rust/Tech Tree", order = 2)]
public class TechTreeData : ScriptableObject
{
	[Serializable]
	public class NodeInstance
	{
		public int id;

		public ItemDefinition itemDef;

		public Vector2 graphPosition;

		public List<int> outputs = new List<int>();

		public List<int> inputs = new List<int>();

		public string groupName;

		public int costOverride = -1;

		public bool IsGroup()
		{
			if ((Object)(object)itemDef == (Object)null && groupName != "Entry")
			{
				return !string.IsNullOrEmpty(groupName);
			}
			return false;
		}
	}

	public string shortname;

	public int nextID;

	public int techTreeLevel;

	public SoundDefinition openSound;

	public SoundDefinition closeSound;

	public List<Era> AllowedEras;

	public bool RequireGameMode;

	private Dictionary<int, NodeInstance> _idToNode;

	private NodeInstance _entryNode;

	public List<NodeInstance> nodes = new List<NodeInstance>();

	public NodeInstance GetByID(int id)
	{
		if (Application.isPlaying)
		{
			if (_idToNode == null)
			{
				_idToNode = nodes.ToDictionary((NodeInstance n) => n.id, (NodeInstance n) => n);
			}
			_idToNode.TryGetValue(id, out var value);
			return value;
		}
		_idToNode = null;
		foreach (NodeInstance node in nodes)
		{
			if (node.id == id)
			{
				return node;
			}
		}
		return null;
	}

	public NodeInstance GetEntryNode()
	{
		if (Application.isPlaying && _entryNode != null && _entryNode.groupName == "Entry")
		{
			return _entryNode;
		}
		_entryNode = null;
		foreach (NodeInstance node in nodes)
		{
			if (node.groupName == "Entry")
			{
				_entryNode = node;
				return node;
			}
		}
		Debug.LogError((object)"NO ENTRY NODE FOR TECH TREE, This will Fail hard");
		return null;
	}

	public void ClearInputs(NodeInstance node)
	{
		foreach (int output in node.outputs)
		{
			NodeInstance byID = GetByID(output);
			byID.inputs.Clear();
			ClearInputs(byID);
		}
	}

	public void SetupInputs(NodeInstance node)
	{
		foreach (int output in node.outputs)
		{
			NodeInstance byID = GetByID(output);
			if (!byID.inputs.Contains(node.id))
			{
				byID.inputs.Add(node.id);
			}
			SetupInputs(byID);
		}
	}

	public bool PlayerHasPathForUnlock(BasePlayer player, NodeInstance node)
	{
		object obj = Interface.CallHook("CanUnlockTechTreeNodePath", (object)player, (object)node, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		NodeInstance entryNode = GetEntryNode();
		if (entryNode == null)
		{
			return false;
		}
		return CheckChainRecursive(player, entryNode, node);
	}

	public bool CheckChainRecursive(BasePlayer player, NodeInstance start, NodeInstance target)
	{
		if (start.groupName != "Entry")
		{
			if (start.IsGroup())
			{
				foreach (int input in start.inputs)
				{
					if (!PlayerHasPathForUnlock(player, GetByID(input)))
					{
						return false;
					}
				}
			}
			else if (start.itemDef.IsAllowed((EraRestriction)4) && !HasPlayerUnlocked(player, start))
			{
				return false;
			}
		}
		bool result = false;
		foreach (int output in start.outputs)
		{
			if (output == target.id)
			{
				return true;
			}
			if (CheckChainRecursive(player, GetByID(output), target))
			{
				result = true;
			}
		}
		return result;
	}

	public bool PlayerCanUnlock(BasePlayer player, NodeInstance node)
	{
		object obj = Interface.CallHook("CanUnlockTechTreeNode", (object)player, (object)node, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PlayerHasPathForUnlock(player, node))
		{
			return !HasPlayerUnlocked(player, node);
		}
		return false;
	}

	public bool HasPlayerUnlocked(BasePlayer player, NodeInstance node)
	{
		if (node.IsGroup())
		{
			bool result = true;
			{
				foreach (int output in node.outputs)
				{
					NodeInstance byID = GetByID(output);
					if (!HasPlayerUnlocked(player, byID))
					{
						result = false;
					}
				}
				return result;
			}
		}
		return player.blueprints.HasUnlocked(node.itemDef);
	}

	public void GetNodesRequiredToUnlock(BasePlayer player, NodeInstance node, List<NodeInstance> foundNodes)
	{
		foundNodes.Add(node);
		if (node == GetEntryNode())
		{
			return;
		}
		if (node.inputs.Count == 1)
		{
			GetNodesRequiredToUnlock(player, GetByID(node.inputs[0]), foundNodes);
			return;
		}
		List<NodeInstance> list = Pool.Get<List<NodeInstance>>();
		int num = int.MaxValue;
		foreach (int input in node.inputs)
		{
			List<NodeInstance> list2 = Pool.Get<List<NodeInstance>>();
			GetNodesRequiredToUnlock(player, GetByID(input), list2);
			int num2 = 0;
			foreach (NodeInstance item in list2)
			{
				if (!((Object)(object)item.itemDef == (Object)null) && !HasPlayerUnlocked(player, item))
				{
					num2 += Workbench.ScrapForResearch(item.itemDef, 0, out var _);
				}
			}
			if (num2 < num)
			{
				list.Clear();
				list.AddRange(list2);
				num = num2;
			}
			Pool.FreeUnmanaged<NodeInstance>(ref list2);
		}
		foundNodes.AddRange(list);
		Pool.FreeUnmanaged<NodeInstance>(ref list);
	}

	public bool IsAllowedInEra(Era era)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if (AllowedEras == null || AllowedEras.Count == 0)
		{
			return true;
		}
		return AllowedEras.Contains(era);
	}

	public bool IsAllowedInGameMode(bool isServer)
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(isServer);
		if ((Object)(object)activeGameMode == (Object)null)
		{
			return !RequireGameMode;
		}
		return activeGameMode.IsAllowed(this);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class NodeInstance
{
	public int id;

	public ItemDefinition itemDef;

	public Vector2 graphPosition;

	public List<int> outputs = new List<int>();

	public List<int> inputs = new List<int>();

	public string groupName;

	public int costOverride = -1;

	public bool IsGroup()
	{
		if ((Object)(object)itemDef == (Object)null && groupName != "Entry")
		{
			return !string.IsNullOrEmpty(groupName);
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class TriggerAchievement : TriggerBase
{
	public string statToIncrease = "";

	public string achievementOnEnter = "";

	public string requiredVehicleName = "";

	[Tooltip("Always set to true, clientside does not work, currently")]
	public bool serverSide = true;

	public bool allowDuringTutorial;

	[NonSerialized]
	private List<ulong> triggeredPlayers = new List<ulong>();

	public void OnPuzzleReset()
	{
		Reset();
	}

	public void Reset()
	{
		triggeredPlayers.Clear();
	}

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient && serverSide)
		{
			return null;
		}
		if (baseEntity.isServer && !serverSide)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if ((Object)(object)ent == (Object)null)
		{
			return;
		}
		BasePlayer component = ((Component)ent).GetComponent<BasePlayer>();
		if ((Object)(object)component == (Object)null || !component.IsAlive() || component.IsSleeping() || component.IsNpc || triggeredPlayers.Contains(component.userID))
		{
			return;
		}
		if (!string.IsNullOrEmpty(requiredVehicleName))
		{
			BaseVehicle mountedVehicle = component.GetMountedVehicle();
			if ((Object)(object)mountedVehicle == (Object)null || !mountedVehicle.ShortPrefabName.Contains(requiredVehicleName))
			{
				return;
			}
		}
		if (serverSide)
		{
			if (!string.IsNullOrEmpty(achievementOnEnter))
			{
				component.GiveAchievement(achievementOnEnter, allowDuringTutorial);
			}
			if (!string.IsNullOrEmpty(statToIncrease))
			{
				component.stats.Add(statToIncrease, 1);
				component.stats.Save(forceSteamSave: true);
			}
			triggeredPlayers.Add(component.userID);
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class TriggerAnalytic : TriggerBase, IServerComponent
{
	private struct RecentPlayerEntrance
	{
		public BasePlayer Player;

		public TimeSince Time;
	}

	public string AnalyticMessage;

	public float Timeout = 120f;

	private List<RecentPlayerEntrance> recentEntrances = new List<RecentPlayerEntrance>();

	internal override GameObject InterestedInObject(GameObject obj)
	{
		if (obj.ToBaseEntity() is BasePlayer { IsNpc: false, isServer: not false } basePlayer)
		{
			return ((Component)basePlayer).gameObject;
		}
		return null;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		base.OnEntityEnter(ent);
		BasePlayer basePlayer = ent.ToPlayer();
		if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsNpc)
		{
			CheckTimeouts();
			if (IsPlayerValid(basePlayer))
			{
				recentEntrances.Add(new RecentPlayerEntrance
				{
					Player = basePlayer,
					Time = TimeSince.op_Implicit(0f)
				});
			}
		}
	}

	private void CheckTimeouts()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		for (int num = recentEntrances.Count - 1; num >= 0; num--)
		{
			if (TimeSince.op_Implicit(recentEntrances[num].Time) > Timeout)
			{
				recentEntrances.RemoveAt(num);
			}
		}
	}

	private bool IsPlayerValid(BasePlayer p)
	{
		for (int i = 0; i < recentEntrances.Count; i++)
		{
			if ((Object)(object)recentEntrances[i].Player == (Object)(object)p)
			{
				return false;
			}
		}
		return true;
	}
}


private struct RecentPlayerEntrance
{
	public BasePlayer Player;

	public TimeSince Time;
}


using UnityEngine;

public class TriggerBanditZone : TriggerBase
{
	public float GetBanditZoneLevel(Vector3 pos)
	{
		return 1f;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Oxide.Core;
using Rust;
using UnityEngine;

public class TriggerBase : BaseMonoBehaviour
{
	[SerializeField]
	private LayerMask interestLayers;

	[NonSerialized]
	public HashSet<GameObject> contents;

	[NonSerialized]
	public HashSet<BaseEntity> entityContents;

	public Action<BaseNetworkable> OnEntityEnterTrigger;

	public Action<BaseNetworkable> OnEntityLeaveTrigger;

	private static bool _useExcludeLayers;

	private static readonly List<TriggerBase> _allTriggerBase = new List<TriggerBase>();

	public LayerMask InterestLayers
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return interestLayers;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			interestLayers = value;
			UpdateExcludeLayers();
		}
	}

	public bool HasAnyContents => !contents.IsNullOrEmpty();

	public bool HasAnyEntityContents => !entityContents.IsNullOrEmpty();

	[ServerVar]
	[ClientVar]
	public static bool UseExcludeLayers
	{
		get
		{
			return _useExcludeLayers;
		}
		set
		{
			if (_useExcludeLayers != value)
			{
				if (_useExcludeLayers)
				{
					ClearExcludeLayers();
				}
				if (!_useExcludeLayers)
				{
					SetExcludeLayers();
				}
			}
			_useExcludeLayers = value;
		}
	}

	protected virtual void Awake()
	{
		_allTriggerBase.Add(this);
		UpdateExcludeLayers();
	}

	private void UpdateExcludeLayers()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		if (!UseExcludeLayers)
		{
			return;
		}
		List<Collider> list = Pool.Get<List<Collider>>();
		((Component)this).gameObject.GetComponentsInChildren<Collider>(list);
		int num = ~LayerMask.op_Implicit(interestLayers);
		foreach (Collider item in list)
		{
			if (item.isTrigger)
			{
				item.excludeLayers = LayerMask.op_Implicit(LayerMask.op_Implicit(item.excludeLayers) | num);
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
	}

	[ServerVar]
	public static void ClearExcludeLayers()
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		Debug.Log((object)$"Clearing ExcludeLayers for {_allTriggerBase.Count} triggers");
		List<Collider> list = Pool.Get<List<Collider>>();
		foreach (TriggerBase item in _allTriggerBase)
		{
			if ((Object)(object)item == (Object)null)
			{
				continue;
			}
			((Component)item).gameObject.GetComponentsInChildren<Collider>(list);
			foreach (Collider item2 in list)
			{
				if (item2.isTrigger)
				{
					item2.excludeLayers = LayerMask.op_Implicit(0);
				}
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
	}

	[ServerVar]
	public static void SetExcludeLayers()
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		Debug.Log((object)$"Setting ExcludeLayers for {_allTriggerBase.Count} triggers");
		List<Collider> list = Pool.Get<List<Collider>>();
		foreach (TriggerBase item in _allTriggerBase)
		{
			if ((Object)(object)item == (Object)null)
			{
				continue;
			}
			((Component)item).gameObject.GetComponentsInChildren<Collider>(list);
			int num = ~LayerMask.op_Implicit(item.interestLayers);
			foreach (Collider item2 in list)
			{
				if (item2.isTrigger)
				{
					item2.excludeLayers = LayerMask.op_Implicit(num);
				}
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
	}

	public virtual GameObject InterestedInObject(GameObject obj)
	{
		int num = 1 << obj.layer;
		if ((((LayerMask)(ref interestLayers)).value & num) != num)
		{
			return null;
		}
		return obj;
	}

	internal virtual GameObject InterestedInObjectExitOnly(GameObject obj)
	{
		return InterestedInObject(obj);
	}

	internal virtual GameObject InterestedInObjectEnterOnly(GameObject obj)
	{
		return InterestedInObject(obj);
	}

	protected virtual void OnDisable()
	{
		if (!Application.isQuitting && contents != null)
		{
			GameObject[] array = contents.ToArray();
			foreach (GameObject targetObj in array)
			{
				OnTriggerExitImpl(targetObj);
			}
			contents = null;
		}
	}

	public virtual void OnEntityEnter(BaseEntity ent)
	{
		if (!((Object)(object)ent == (Object)null))
		{
			if (entityContents == null)
			{
				entityContents = new HashSet<BaseEntity>();
			}
			if (Interface.CallHook("OnEntityEnter", (object)this, (object)ent) == null)
			{
				entityContents.Add(ent);
				OnEntityEnterTrigger?.Invoke(ent);
			}
		}
	}

	public virtual void OnEntityLeave(BaseEntity ent)
	{
		if (entityContents != null && Interface.CallHook("OnEntityLeave", (object)this, (object)ent) == null)
		{
			entityContents.Remove(ent);
			OnEntityLeaveTrigger?.Invoke(ent);
		}
	}

	public virtual void OnObjectAdded(GameObject obj, Collider col)
	{
		if (!((Object)(object)obj == (Object)null))
		{
			BaseEntity baseEntity = obj.ToBaseEntity();
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.EnterTrigger(this);
				OnEntityEnter(baseEntity);
			}
		}
	}

	public virtual void OnObjectRemoved(GameObject obj)
	{
		if ((Object)(object)obj == (Object)null)
		{
			return;
		}
		BaseEntity baseEntity = obj.ToBaseEntity(allowDestroyed: true);
		if (!Object.op_Implicit((Object)(object)baseEntity))
		{
			return;
		}
		bool flag = false;
		foreach (GameObject content in contents)
		{
			if ((Object)(object)content == (Object)null)
			{
				Debug.LogWarning((object)("Trigger " + ((object)this).ToString() + " contains null object."));
			}
			else if ((Object)(object)content.ToBaseEntity(allowDestroyed: true) == (Object)(object)baseEntity)
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			baseEntity.LeaveTrigger(this);
			OnEntityLeave(baseEntity);
		}
	}

	public void RemoveInvalidEntities()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		if (entityContents.IsNullOrEmpty())
		{
			return;
		}
		Collider component = ((Component)this).GetComponent<Collider>();
		if ((Object)(object)component == (Object)null)
		{
			return;
		}
		Bounds bounds = component.bounds;
		((Bounds)(ref bounds)).Expand(1f);
		List<BaseEntity> list = null;
		foreach (BaseEntity entityContent in entityContents)
		{
			if ((Object)(object)entityContent == (Object)null)
			{
				if (Debugging.checktriggers)
				{
					Debug.LogWarning((object)("Trigger " + ((object)this).ToString() + " contains destroyed entity."));
				}
				if (list == null)
				{
					list = Pool.Get<List<BaseEntity>>();
				}
				list.Add(entityContent);
			}
			else if (!((Bounds)(ref bounds)).Contains(entityContent.ClosestPoint(((Component)this).transform.position)))
			{
				if (Debugging.checktriggers)
				{
					Debug.LogWarning((object)("Trigger " + ((object)this).ToString() + " contains entity that is too far away: " + ((object)entityContent).ToString()));
				}
				if (list == null)
				{
					list = Pool.Get<List<BaseEntity>>();
				}
				list.Add(entityContent);
			}
		}
		if (list == null)
		{
			return;
		}
		foreach (BaseEntity item in list)
		{
			RemoveEntity(item);
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	public bool CheckEntity(BaseEntity ent)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ent == (Object)null)
		{
			return true;
		}
		Collider component = ((Component)this).GetComponent<Collider>();
		if ((Object)(object)component == (Object)null)
		{
			return true;
		}
		Bounds bounds = component.bounds;
		((Bounds)(ref bounds)).Expand(1f);
		return ((Bounds)(ref bounds)).Contains(ent.ClosestPoint(((Component)this).transform.position));
	}

	public virtual void OnObjects()
	{
	}

	public virtual void OnEmpty()
	{
		contents = null;
		entityContents = null;
	}

	public void RemoveObject(GameObject obj)
	{
		if (!((Object)(object)obj == (Object)null))
		{
			Collider component = obj.GetComponent<Collider>();
			if (!((Object)(object)component == (Object)null))
			{
				OnTriggerExit(component);
			}
		}
	}

	public void RemoveEntity(BaseEntity ent)
	{
		if ((Object)(object)this == (Object)null || contents == null || (Object)(object)ent == (Object)null)
		{
			return;
		}
		List<GameObject> list = Pool.Get<List<GameObject>>();
		foreach (GameObject content in contents)
		{
			if ((Object)(object)content != (Object)null && (Object)(object)content.ToBaseEntity(allowDestroyed: true) == (Object)(object)ent)
			{
				list.Add(content);
			}
		}
		foreach (GameObject item in list)
		{
			OnTriggerExitImpl(item);
		}
		Pool.FreeUnmanaged<GameObject>(ref list);
	}

	public void OnTriggerEnter(Collider collider)
	{
		if ((Object)(object)this == (Object)null || !((Behaviour)this).enabled)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("TriggerBase.OnTriggerEnter", 0);
		try
		{
			GameObject val2 = InterestedInObjectEnterOnly(((Component)collider).gameObject);
			if ((Object)(object)val2 == (Object)null)
			{
				return;
			}
			if (contents == null)
			{
				contents = new HashSet<GameObject>();
			}
			if (contents.Contains(val2))
			{
				return;
			}
			int count = contents.Count;
			contents.Add(val2);
			OnObjectAdded(val2, collider);
			if (count == 0 && contents.Count == 1)
			{
				OnObjects();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		if (Debugging.checktriggers)
		{
			RemoveInvalidEntities();
		}
	}

	internal virtual bool SkipOnTriggerExit(Collider collider)
	{
		return false;
	}

	public void OnTriggerExit(Collider collider)
	{
		if ((Object)(object)this == (Object)null || (Object)(object)collider == (Object)null || SkipOnTriggerExit(collider))
		{
			return;
		}
		GameObject val = InterestedInObjectExitOnly(((Component)collider).gameObject);
		if (!((Object)(object)val == (Object)null))
		{
			OnTriggerExitImpl(val);
			if (Debugging.checktriggers)
			{
				RemoveInvalidEntities();
			}
		}
	}

	public void OnTriggerExitImpl(GameObject targetObj)
	{
		if (contents != null && contents.Contains(targetObj))
		{
			contents.Remove(targetObj);
			OnObjectRemoved(targetObj);
			if (contents == null || contents.Count == 0)
			{
				OnEmpty();
			}
		}
	}
}


using UnityEngine;

public class TriggerClanModify : TriggerBase
{
	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

public class TriggerComfort : TriggerBase
{
	public float triggerSize;

	public float baseComfort = 0.5f;

	public float minComfortRange = 2.5f;

	public bool applyToHorses;

	private const float perPlayerComfortBonus = 0.25f;

	private const float horseComfortBonus = 0.5f;

	private const float bonusComfort = 0f;

	private List<BaseEntity> _entities = new List<BaseEntity>();

	private void OnValidate()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		triggerSize = ((Component)this).GetComponent<SphereCollider>().radius * ((Component)this).transform.localScale.y;
	}

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public float CalculateComfort(Vector3 position, BasePlayer forPlayer = null)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3.Distance(((Component)this).gameObject.transform.position, position);
		float num2 = 1f - Mathf.Clamp(num - minComfortRange, 0f, num / (triggerSize - minComfortRange));
		bool flag = false;
		float num3 = 0f;
		foreach (BaseEntity entity in _entities)
		{
			if ((Object)(object)entity == (Object)(object)forPlayer)
			{
				continue;
			}
			if (entity is BasePlayer { IsNpc: false } basePlayer)
			{
				float num4 = 1f;
				if (basePlayer.IsSleeping())
				{
					num4 = 0.5f;
				}
				else if (!basePlayer.IsAlive())
				{
					num4 = 0f;
				}
				num3 += 0.25f * num4;
			}
			if (applyToHorses && (entity is RidableHorse || entity is RidableHorse) && !flag)
			{
				num3 += 0.5f;
				flag = true;
			}
		}
		float num5 = 0f + num3;
		return (baseComfort + num5) * num2;
	}

	public override void OnEntityEnter(BaseEntity ent)
	{
		if ((ent is BasePlayer || ent is RidableHorse || ent is RidableHorse) && Interface.CallHook("OnEntityEnter", (object)this, (object)ent) == null)
		{
			_entities.Add(ent);
		}
	}

	public override void OnEntityLeave(BaseEntity ent)
	{
		if ((ent is BasePlayer || ent is RidableHorse || ent is RidableHorse) && Interface.CallHook("OnEntityLeave", (object)this, (object)ent) == null)
		{
			_entities.Remove(ent);
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class TriggerDanceAchievement : TriggerBase
{
	public int RequiredPlayerCount = 3;

	public string AchievementName;

	[NonSerialized]
	private List<NetworkableId> triggeredPlayers = new List<NetworkableId>();

	public void OnPuzzleReset()
	{
		Reset();
	}

	public void Reset()
	{
		triggeredPlayers.Clear();
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (!(baseEntity is BasePlayer))
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public void NotifyDanceStarted()
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		if (entityContents == null)
		{
			return;
		}
		int num = 0;
		foreach (BaseEntity entityContent in entityContents)
		{
			if ((Object)(object)entityContent.ToPlayer() != (Object)null && entityContent.ToPlayer().CurrentGestureIsDance)
			{
				num++;
				if (num >= RequiredPlayerCount)
				{
					break;
				}
			}
		}
		if (num < RequiredPlayerCount)
		{
			return;
		}
		foreach (BaseEntity entityContent2 in entityContents)
		{
			if (!triggeredPlayers.Contains(entityContent2.net.ID) && (Object)(object)entityContent2.ToPlayer() != (Object)null)
			{
				entityContent2.ToPlayer().GiveAchievement(AchievementName);
				triggeredPlayers.Add(entityContent2.net.ID);
			}
		}
	}
}


using UnityEngine;

public class TriggerEnsnare : TriggerBase
{
	public bool blockHands = true;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


public class TriggerEnterTimer : TriggerBase
{
	public TimeSince EnterTime { get; private set; }

	internal override void OnEntityEnter(BaseEntity ent)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		bool hasAnyEntityContents = base.HasAnyEntityContents;
		base.OnEntityEnter(ent);
		if (!hasAnyEntityContents && base.HasAnyEntityContents)
		{
			EnterTime = TimeSince.op_Implicit(0f);
		}
	}
}


using UnityEngine;

public class TriggerForce : TriggerBase, IServerComponent
{
	public const float GravityMultiplier = 0.1f;

	public const float VelocityLerp = 10f;

	public const float AngularDrag = 10f;

	public Vector3 velocity = Vector3.forward;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public override void OnEntityEnter(BaseEntity ent)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		base.OnEntityEnter(ent);
		Vector3 val = ((Component)this).transform.TransformDirection(velocity);
		ent.ApplyInheritedVelocity(val);
	}

	public override void OnEntityLeave(BaseEntity ent)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		base.OnEntityLeave(ent);
		ent.ApplyInheritedVelocity(Vector3.zero);
	}

	protected void FixedUpdate()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (entityContents == null)
		{
			return;
		}
		Vector3 val = ((Component)this).transform.TransformDirection(velocity);
		foreach (BaseEntity entityContent in entityContents)
		{
			if ((Object)(object)entityContent != (Object)null)
			{
				entityContent.ApplyInheritedVelocity(val);
			}
		}
	}
}


public interface IHostileWarningEntity
{
	bool WarningEnabled(BaseEntity forEntity);

	float WarningRange();
}


using UnityEngine;

public class TriggerHostileWarningZone : TriggerBase
{
	public GameObject TargetGameObject;

	public Collider triggerCollider { get; private set; }

	protected override void Awake()
	{
		base.Awake();
		triggerCollider = ((Component)this).GetComponent<Collider>();
	}

	protected void OnEnable()
	{
		ResizeTrigger();
	}

	public void ResizeTrigger()
	{
		if ((Object)(object)TargetGameObject == (Object)null)
		{
			return;
		}
		BaseEntity baseEntity = TargetGameObject.ToBaseEntity();
		if (!((Object)(object)baseEntity == (Object)null) && baseEntity is IHostileWarningEntity hostileWarningEntity)
		{
			Collider obj = triggerCollider;
			SphereCollider val = (SphereCollider)(object)((obj is SphereCollider) ? obj : null);
			if ((Object)(object)val != (Object)null)
			{
				val.radius = hostileWarningEntity.WarningRange();
			}
		}
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public bool WarningEnabled(BaseEntity forEntity)
	{
		if ((Object)(object)TargetGameObject == (Object)null)
		{
			return true;
		}
		BaseEntity baseEntity = TargetGameObject.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return true;
		}
		if (baseEntity is IHostileWarningEntity hostileWarningEntity)
		{
			return hostileWarningEntity.WarningEnabled(forEntity);
		}
		return true;
	}
}


public interface IHurtTrigger
{
}


using System;
using System.Linq;
using Rust;
using UnityEngine;

public class TriggerHurt : TriggerBase, IServerComponent, IHurtTrigger
{
	public float DamagePerSecond = 1f;

	public float DamageTickRate = 4f;

	public DamageType damageType;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public override void OnObjects()
	{
		((FacepunchBehaviour)this).InvokeRepeating((Action)OnTick, 0f, 1f / DamageTickRate);
	}

	public override void OnEmpty()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)OnTick);
	}

	private void OnTick()
	{
		BaseEntity attacker = ((Component)this).gameObject.ToBaseEntity();
		if (entityContents == null)
		{
			return;
		}
		BaseEntity[] array = entityContents.ToArray();
		foreach (BaseEntity baseEntity in array)
		{
			if (baseEntity.IsValid())
			{
				BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
				if (!((Object)(object)baseCombatEntity == (Object)null) && CanHurt(baseCombatEntity))
				{
					baseCombatEntity.Hurt(DamagePerSecond * (1f / DamageTickRate), damageType, attacker);
				}
			}
		}
	}

	protected virtual bool CanHurt(BaseCombatEntity ent)
	{
		return true;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust;
using UnityEngine;

public class TriggerHurtNotChild : TriggerBase, IServerComponent, IHurtTrigger
{
	public interface IHurtTriggerUser
	{
		BasePlayer GetPlayerDamageInitiator();

		float GetDamageMultiplier(BaseEntity ent);

		void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal);
	}

	public float DamagePerSecond = 1f;

	public float DamageTickRate = 4f;

	public float DamageDelay;

	public DamageType damageType;

	public bool ignoreNPC = true;

	public float npcMultiplier = 1f;

	public float resourceMultiplier = 1f;

	public float lootContainerMultiplier = 1f;

	public bool triggerHitImpacts = true;

	public bool RequireUpAxis;

	public BaseEntity SourceEntity;

	public bool UseSourceEntityDamageMultiplier = true;

	public bool ignoreAllVehicleMounted;

	public float activationDelay;

	private Dictionary<BaseEntity, float> entryTimes;

	private TimeSince timeSinceAcivation;

	private IHurtTriggerUser hurtTiggerUser;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (ignoreNPC && baseEntity.IsNpc)
		{
			return null;
		}
		if (!Physics.treecollision && obj.layer == 30)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public override void OnObjects()
	{
		((FacepunchBehaviour)this).InvokeRepeating((Action)OnTick, 0f, 1f / DamageTickRate);
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if ((Object)(object)ent != (Object)null && DamageDelay > 0f)
		{
			if (entryTimes == null)
			{
				entryTimes = new Dictionary<BaseEntity, float>();
			}
			entryTimes.Add(ent, Time.time);
		}
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		if ((Object)(object)ent != (Object)null && entryTimes != null)
		{
			entryTimes.Remove(ent);
		}
		base.OnEntityLeave(ent);
	}

	public override void OnEmpty()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)OnTick);
	}

	protected void OnEnable()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		timeSinceAcivation = TimeSince.op_Implicit(0f);
		hurtTiggerUser = SourceEntity as IHurtTriggerUser;
	}

	public new void OnDisable()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)OnTick);
		base.OnDisable();
	}

	private bool IsInterested(BaseEntity ent)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		if (TimeSince.op_Implicit(timeSinceAcivation) < activationDelay)
		{
			return false;
		}
		BasePlayer basePlayer = ent.ToPlayer();
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (basePlayer.isMounted)
			{
				BaseVehicle mountedVehicle = basePlayer.GetMountedVehicle();
				if ((Object)(object)SourceEntity != (Object)null && (Object)(object)mountedVehicle == (Object)(object)SourceEntity)
				{
					return false;
				}
				if (ignoreAllVehicleMounted && (Object)(object)mountedVehicle != (Object)null)
				{
					return false;
				}
			}
			if ((Object)(object)SourceEntity != (Object)null && basePlayer.HasEntityInParents(SourceEntity))
			{
				return false;
			}
		}
		return true;
	}

	private void OnTick()
	{
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		if (entityContents.IsNullOrEmpty())
		{
			return;
		}
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		list.AddRange(entityContents);
		foreach (BaseEntity item in list)
		{
			if (item.IsValid() && IsInterested(item) && (!(DamageDelay > 0f) || entryTimes == null || !entryTimes.TryGetValue(item, out var value) || !(value + DamageDelay > Time.time)) && (!RequireUpAxis || !(Vector3.Dot(((Component)item).transform.up, ((Component)this).transform.up) < 0f)))
			{
				float num = DamagePerSecond * 1f / DamageTickRate;
				if (UseSourceEntityDamageMultiplier && hurtTiggerUser != null)
				{
					num *= hurtTiggerUser.GetDamageMultiplier(item);
				}
				if (item.IsNpc)
				{
					num *= npcMultiplier;
				}
				if (item is ResourceEntity)
				{
					num *= resourceMultiplier;
				}
				if (item is LootContainer)
				{
					num *= lootContainerMultiplier;
				}
				Vector3 val = ((Component)item).transform.position + Vector3.up * 1f;
				bool flag = item is BasePlayer || item is BaseNpc;
				BaseEntity baseEntity = null;
				BaseEntity weaponPrefab = null;
				if (hurtTiggerUser != null)
				{
					baseEntity = hurtTiggerUser.GetPlayerDamageInitiator();
					weaponPrefab = SourceEntity.LookupPrefab();
				}
				if ((Object)(object)baseEntity == (Object)null)
				{
					baseEntity = ((!((Object)(object)SourceEntity != (Object)null)) ? ((Component)this).gameObject.ToBaseEntity() : SourceEntity);
				}
				HitInfo hitInfo = new HitInfo
				{
					DoHitEffects = true,
					HitEntity = item,
					HitPositionWorld = val,
					HitPositionLocal = ((Component)item).transform.InverseTransformPoint(val),
					HitNormalWorld = Vector3.up,
					HitMaterial = (flag ? StringPool.Get("Flesh") : 0u),
					WeaponPrefab = weaponPrefab,
					Initiator = baseEntity
				};
				hitInfo.damageTypes = new DamageTypeList();
				hitInfo.damageTypes.Set(damageType, num);
				item.OnAttacked(hitInfo);
				if (hurtTiggerUser != null)
				{
					hurtTiggerUser.OnHurtTriggerOccupant(item, damageType, num);
				}
				if (triggerHitImpacts)
				{
					Effect.server.ImpactEffect(hitInfo);
				}
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		RemoveInvalidEntities();
	}
}


using Rust;

public interface IHurtTriggerUser
{
	BasePlayer GetPlayerDamageInitiator();

	float GetDamageMultiplier(BaseEntity ent);

	void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal);
}


using UnityEngine;

public class TriggerLadder : TriggerBase
{
	public enum LadderType
	{
		Rungs,
		Rope
	}

	public LadderType Type;

	public bool ForceLookAt;

	public bool RequireJumpToMount;

	public SoundDefinition ClimbFootstepSound;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if ((Object)(object)(baseEntity as BasePlayer) == (Object)null)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	internal override GameObject InterestedInObjectEnterOnly(GameObject obj)
	{
		obj = base.InterestedInObjectEnterOnly(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((baseEntity as BasePlayer).IsWounded())
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


public enum LadderType
{
	Rungs,
	Rope
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class TriggerMount : TriggerBase, IServerComponent
{
	private class EntryInfo
	{
		public float entryTime;

		public Vector3 entryPos;

		public EntryInfo(float entryTime, Vector3 entryPos)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			this.entryTime = entryTime;
			this.entryPos = entryPos;
		}

		public void Set(float entryTime, Vector3 entryPos)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			this.entryTime = entryTime;
			this.entryPos = entryPos;
		}
	}

	private const float MOUNT_DELAY = 3.5f;

	private const float MAX_MOVE = 0.5f;

	private Dictionary<BaseEntity, EntryInfo> entryInfo;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		BasePlayer basePlayer = baseEntity.ToPlayer();
		if ((Object)(object)basePlayer == (Object)null || basePlayer.IsNpc)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		base.OnEntityEnter(ent);
		if (entryInfo == null)
		{
			entryInfo = new Dictionary<BaseEntity, EntryInfo>();
		}
		entryInfo.Add(ent, new EntryInfo(Time.time, ((Component)ent).transform.position));
		((FacepunchBehaviour)this).Invoke((Action)CheckForMount, 3.6f);
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		if ((Object)(object)ent != (Object)null && entryInfo != null)
		{
			entryInfo.Remove(ent);
		}
		base.OnEntityLeave(ent);
	}

	private void CheckForMount()
	{
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		if (entityContents == null || entryInfo == null)
		{
			return;
		}
		foreach (KeyValuePair<BaseEntity, EntryInfo> item in entryInfo)
		{
			BaseEntity key = item.Key;
			if (!key.IsValid())
			{
				continue;
			}
			EntryInfo value = item.Value;
			BasePlayer basePlayer = key.ToPlayer();
			bool flag = (basePlayer.IsAdmin || basePlayer.IsDeveloper) && basePlayer.IsFlying;
			if (!((Object)(object)basePlayer != (Object)null) || !basePlayer.IsAlive() || flag)
			{
				continue;
			}
			bool flag2 = false;
			if (!basePlayer.isMounted && !basePlayer.IsSleeping() && value.entryTime + 3.5f < Time.time && Vector3.Distance(((Component)key).transform.position, value.entryPos) < 0.5f)
			{
				BaseVehicle componentInParent = ((Component)this).GetComponentInParent<BaseVehicle>();
				if ((Object)(object)componentInParent != (Object)null && !componentInParent.IsDead())
				{
					componentInParent.AttemptMount(basePlayer);
					flag2 = true;
				}
			}
			if (!flag2)
			{
				value.Set(Time.time, ((Component)key).transform.position);
				((FacepunchBehaviour)this).Invoke((Action)CheckForMount, 3.6f);
			}
		}
	}
}


using UnityEngine;

private class EntryInfo
{
	public float entryTime;

	public Vector3 entryPos;

	public EntryInfo(float entryTime, Vector3 entryPos)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		this.entryTime = entryTime;
		this.entryPos = entryPos;
	}

	public void Set(float entryTime, Vector3 entryPos)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		this.entryTime = entryTime;
		this.entryPos = entryPos;
	}
}


using System.Collections.Generic;
using UnityEngine;

[RequireComponent(typeof(SphereCollider))]
public class TriggerNoRespawnZone : TriggerBase
{
	public static List<TriggerNoRespawnZone> allNRZones = new List<TriggerNoRespawnZone>();

	public float maxDepth = 20f;

	public float maxAltitude = -1f;

	private SphereCollider sphereCollider;

	private float radiusSqr;

	protected override void Awake()
	{
		base.Awake();
		sphereCollider = ((Component)this).GetComponent<SphereCollider>();
		radiusSqr = sphereCollider.radius * sphereCollider.radius;
	}

	protected void OnEnable()
	{
		allNRZones.Add(this);
	}

	protected override void OnDisable()
	{
		base.OnDisable();
		allNRZones.Remove(this);
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BasePlayer basePlayer = obj.ToBaseEntity() as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null)
		{
			return null;
		}
		if (basePlayer.isClient)
		{
			return null;
		}
		return ((Component)basePlayer).gameObject;
	}

	public static bool InAnyNoRespawnZone(Vector3 theirPos)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < allNRZones.Count; i++)
		{
			if (allNRZones[i].InNoRespawnZone(theirPos, checkRadius: true))
			{
				return true;
			}
		}
		return false;
	}

	public bool InNoRespawnZone(Vector3 theirPos, bool checkRadius)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position + sphereCollider.center;
		if (checkRadius && Vector3.SqrMagnitude(val - theirPos) > radiusSqr)
		{
			return false;
		}
		float num = Mathf.Abs(val.y - theirPos.y);
		if (maxDepth != -1f && theirPos.y < val.y && num > maxDepth)
		{
			return false;
		}
		if (maxAltitude != -1f && theirPos.y > val.y && num > maxAltitude)
		{
			return false;
		}
		return true;
	}
}


using UnityEngine;

public class TriggerNoSpray : TriggerBase
{
	public BoxCollider TriggerCollider;

	private OBB cachedBounds;

	private Transform cachedTransform;

	private void OnEnable()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		cachedTransform = ((Component)this).transform;
		cachedBounds = new OBB(cachedTransform, new Bounds(TriggerCollider.center, TriggerCollider.size));
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if ((Object)(object)baseEntity.ToPlayer() == (Object)null)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public bool IsPositionValid(Vector3 worldPosition)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return !((OBB)(ref cachedBounds)).Contains(worldPosition);
	}
}


using UnityEngine;

public class TriggerNotify : TriggerBase, IPrefabPreProcess
{
	public GameObject notifyTarget;

	private INotifyTrigger toNotify;

	public bool runClientside = true;

	public bool runServerside = true;

	public bool HasContents
	{
		get
		{
			if (contents != null)
			{
				return contents.Count > 0;
			}
			return false;
		}
	}

	bool IPrefabPreProcess.CanRunDuringBundling => true;

	internal override void OnObjects()
	{
		base.OnObjects();
		if (toNotify != null || ((Object)(object)notifyTarget != (Object)null && notifyTarget.TryGetComponent<INotifyTrigger>(ref toNotify)))
		{
			toNotify.OnObjects(this);
		}
	}

	internal override void OnEmpty()
	{
		base.OnEmpty();
		if (toNotify != null || ((Object)(object)notifyTarget != (Object)null && notifyTarget.TryGetComponent<INotifyTrigger>(ref toNotify)))
		{
			toNotify.OnEmpty();
		}
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if ((!clientside || !runClientside) && (!serverside || !runServerside))
		{
			preProcess.RemoveComponent((Component)(object)this);
		}
	}
}


public interface INotifyTrigger
{
	void OnObjects(TriggerNotify trigger);

	void OnEmpty();
}


using UnityEngine;

public class TriggerNotifyEntity : TriggerBase, IPrefabPreProcess
{
	public GameObject notifyTarget;

	private INotifyEntityTrigger toNotify;

	public bool runClientside = true;

	public bool runServerside = true;

	public bool HasContents
	{
		get
		{
			if (contents != null)
			{
				return contents.Count > 0;
			}
			return false;
		}
	}

	bool IPrefabPreProcess.CanRunDuringBundling => true;

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if (toNotify != null || ((Object)(object)notifyTarget != (Object)null && notifyTarget.TryGetComponent<INotifyEntityTrigger>(ref toNotify)))
		{
			toNotify.OnEntityEnter(ent);
		}
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
		if (toNotify != null || ((Object)(object)notifyTarget != (Object)null && notifyTarget.TryGetComponent<INotifyEntityTrigger>(ref toNotify)))
		{
			toNotify.OnEntityLeave(ent);
		}
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if ((!clientside || !runClientside) && (!serverside || !runServerside))
		{
			preProcess.RemoveComponent((Component)(object)this);
		}
	}
}


public interface INotifyEntityTrigger
{
	void OnEntityEnter(BaseEntity ent);

	void OnEntityLeave(BaseEntity ent);
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust;
using UnityEngine;

[RequireComponent(typeof(Collider))]
public class TriggerParent : TriggerBase, IServerComponent
{
	[Header("General")]
	[SerializeField]
	[Tooltip("Deparent if the parented entity clips into an obstacle")]
	public bool doClippingCheck;

	[Tooltip("If deparenting via clipping, this will be used (if assigned) to also move the entity to a valid dismount position")]
	public BaseMountable associatedMountable;

	[Tooltip("Needed if the player might dismount inside the trigger and the trigger might be moving. Being mounting inside the trigger lets them dismount in local trigger-space, which means client and server will sync up.Otherwise the client/server delay can have them dismounting into invalid space.")]
	public bool parentMountedPlayers;

	[Tooltip("Sleepers don't have all the checks (e.g. clipping) that awake players get. If that might be a problem,sleeper parenting can be disabled. You'll need an associatedMountable though so that the sleeper can be dismounted.")]
	public bool parentSleepers = true;

	[Tooltip("This was added to allow parenting in some cases with sinking tugboats, it's generally not needed")]
	public bool parentSwimmers;

	[Header("NPC")]
	public bool ParentNPCPlayers;

	[Tooltip("When parenting an NPC don't check if they are shop keepers or mission providers.")]
	public bool SkipNPCChecks;

	[Tooltip("If the player is already parented to something else, they'll switch over to another parent only if this is true")]
	[Header("Other")]
	public bool overrideOtherTriggers;

	[Tooltip("Requires associatedMountable to be set. Prevents players entering the trigger if there's something between their feet and the bottom of the parent trigger")]
	public bool checkForObjUnderFeet;

	public const int CLIP_CHECK_MASK = 1218511105;

	protected float triggerHeight;

	private BasePlayer killPlayerTemp;

	protected override void Awake()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		base.Awake();
		Collider component = ((Component)this).GetComponent<Collider>();
		Bounds bounds = component.bounds;
		triggerHeight = ((Bounds)(ref bounds)).size.y;
	}

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public override void OnEntityEnter(BaseEntity ent)
	{
		if (!(ent is NPCPlayer npcPly) || (ParentNPCPlayers && CanParentNPC(npcPly)))
		{
			if (ShouldParent(ent))
			{
				Parent(ent);
			}
			base.OnEntityEnter(ent);
			if (entityContents != null && entityContents.Count == 1)
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)OnTick, 0f, 0f);
			}
		}
	}

	public override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
		if (entityContents == null || entityContents.Count == 0)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)OnTick);
		}
		BasePlayer basePlayer = ent.ToPlayer();
		if (!parentSleepers || !((Object)(object)basePlayer != (Object)null) || !basePlayer.IsSleeping())
		{
			Unparent(ent);
		}
	}

	internal virtual bool CanParentNPC(NPCPlayer npcPly)
	{
		if (SkipNPCChecks)
		{
			return true;
		}
		if (npcPly is NPCShopKeeper)
		{
			return false;
		}
		return true;
	}

	public virtual bool ShouldParent(BaseEntity ent, bool bypassOtherTriggerCheck = false)
	{
		if (!ent.canTriggerParent)
		{
			return false;
		}
		if (!bypassOtherTriggerCheck && !overrideOtherTriggers)
		{
			BaseEntity parentEntity = ent.GetParentEntity();
			if (parentEntity.IsValid() && (Object)(object)parentEntity != (Object)(object)((Component)this).gameObject.ToBaseEntity())
			{
				return false;
			}
		}
		if ((Object)(object)ent.FindTrigger<TriggerParentExclusion>() != (Object)null && (!ent.FindTrigger<TriggerParentExclusion>().IgnoreIfOnLadder || !(ent is BasePlayer basePlayer) || !basePlayer.OnLadder()))
		{
			return false;
		}
		if (doClippingCheck && IsClipping(ent) && !(ent is BaseCorpse))
		{
			return false;
		}
		if (checkForObjUnderFeet && HasObjUnderFeet(ent))
		{
			return false;
		}
		BasePlayer basePlayer2 = ent.ToPlayer();
		if ((Object)(object)basePlayer2 != (Object)null)
		{
			if (!parentSwimmers && basePlayer2.IsSwimming())
			{
				return false;
			}
			if (!parentMountedPlayers && basePlayer2.isMounted)
			{
				return false;
			}
			if (!parentSleepers && basePlayer2.IsSleeping())
			{
				return false;
			}
			if (basePlayer2.isMounted && (Object)(object)associatedMountable != (Object)null && !IsParentedToUs(basePlayer2) && !associatedMountable.HasValidDismountPosition(basePlayer2))
			{
				return false;
			}
		}
		return true;
	}

	public void ForceParentEarly(BaseEntity ent)
	{
		OnEntityEnter(ent);
		((FacepunchBehaviour)this).Invoke((Action)CheckAllParenting, 0.1f);
	}

	private void CheckAllParenting()
	{
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		if (contents != null)
		{
			foreach (GameObject content in contents)
			{
				if (!((Object)(object)content == (Object)null))
				{
					BaseEntity baseEntity = content.ToBaseEntity();
					if ((Object)(object)baseEntity != (Object)null && !list.Contains(baseEntity))
					{
						list.Add(baseEntity);
					}
				}
			}
		}
		List<BaseEntity> list2 = Pool.Get<List<BaseEntity>>();
		foreach (BaseEntity entityContent in entityContents)
		{
			if (!list.Contains(entityContent))
			{
				list2.Add(entityContent);
			}
		}
		foreach (BaseEntity item in list2)
		{
			OnEntityLeave(item);
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list2);
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	protected void Parent(BaseEntity ent)
	{
		BaseEntity baseEntity = ((Component)this).gameObject.ToBaseEntity();
		if (!((Object)(object)ent.GetParentEntity() == (Object)(object)baseEntity) && !((Object)(object)baseEntity.GetParentEntity() == (Object)(object)ent))
		{
			ent.SetParent(((Component)this).gameObject.ToBaseEntity(), worldPositionStays: true, sendImmediate: true);
		}
	}

	protected void Unparent(BaseEntity ent)
	{
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ent.GetParentEntity() != (Object)(object)((Component)this).gameObject.ToBaseEntity())
		{
			return;
		}
		if (ent.IsValid() && !ent.IsDestroyed)
		{
			TriggerParent triggerParent = ent.FindSuitableParent();
			if ((Object)(object)triggerParent != (Object)null && ((Component)triggerParent).gameObject.ToBaseEntity().IsValid())
			{
				triggerParent.Parent(ent);
				return;
			}
		}
		ent.SetParent(null, worldPositionStays: true, sendImmediate: true);
		BasePlayer basePlayer = ent.ToPlayer();
		if (!((Object)(object)basePlayer != (Object)null))
		{
			return;
		}
		basePlayer.unparentTime = Time.time;
		basePlayer.PauseFlyHackDetection(5f);
		basePlayer.PauseSpeedHackDetection(5f);
		basePlayer.PauseTickDistanceDetection(5f);
		if (AntiHack.TestNoClipping(basePlayer, ((Component)basePlayer).transform.position, ((Component)basePlayer).transform.position, BasePlayer.NoClipRadius(ConVar.AntiHack.noclip_margin), ConVar.AntiHack.noclip_backtracking, out var _, vehicleLayer: true))
		{
			basePlayer.PauseVehicleNoClipDetection(5f);
		}
		if ((Object)(object)associatedMountable != (Object)null && ((doClippingCheck && IsClipping(ent)) || basePlayer.IsSleeping()))
		{
			if (associatedMountable.GetDismountPosition(basePlayer, out var res))
			{
				basePlayer.MovePosition(res);
				((Component)basePlayer).transform.rotation = Quaternion.identity;
				basePlayer.SendNetworkUpdateImmediate();
				basePlayer.ClientRPC(RpcTarget.Player("ForcePositionTo", basePlayer), res);
			}
			else
			{
				killPlayerTemp = basePlayer;
				((FacepunchBehaviour)this).Invoke((Action)KillPlayerDelayed, 0f);
			}
		}
	}

	private bool IsParentedToUs(BaseEntity ent)
	{
		BaseEntity baseEntity = ((Component)this).gameObject.ToBaseEntity();
		return (Object)(object)ent.GetParentEntity() == (Object)(object)baseEntity;
	}

	private void KillPlayerDelayed()
	{
		if (killPlayerTemp.IsValid() && !killPlayerTemp.IsDead())
		{
			killPlayerTemp.Hurt(1000f, DamageType.Suicide, killPlayerTemp, useProtection: false);
		}
		killPlayerTemp = null;
	}

	private void OnTick()
	{
		if (entityContents == null)
		{
			return;
		}
		BaseEntity baseEntity = ((Component)this).gameObject.ToBaseEntity();
		if (!baseEntity.IsValid() || baseEntity.IsDestroyed)
		{
			return;
		}
		foreach (BaseEntity entityContent in entityContents)
		{
			if (entityContent.IsValid() && !entityContent.IsDestroyed)
			{
				if (ShouldParent(entityContent))
				{
					Parent(entityContent);
				}
				else
				{
					Unparent(entityContent);
				}
			}
		}
	}

	protected virtual bool IsClipping(BaseEntity ent)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GamePhysics.CheckOBB(ent.WorldSpaceBounds(), 1218511105, (QueryTriggerInteraction)1);
	}

	private bool HasObjUnderFeet(BaseEntity ent)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ent.PivotPoint() + ((Component)ent).transform.up * 0.1f;
		float maxDistance = triggerHeight + 0.1f;
		if (GamePhysics.Trace(new Ray(val, -((Component)this).transform.up), 0f, out var hitInfo, maxDistance, 1503731969, (QueryTriggerInteraction)1, ent) && (Object)(object)((RaycastHit)(ref hitInfo)).collider != (Object)null)
		{
			BaseEntity toFind = ((Component)this).gameObject.ToBaseEntity();
			BaseEntity baseEntity = ((RaycastHit)(ref hitInfo)).collider.ToBaseEntity();
			if ((Object)(object)baseEntity == (Object)null || !baseEntity.HasEntityInParents(toFind))
			{
				return true;
			}
		}
		return false;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class TriggerParentElevator : TriggerParentEnclosed
{
	public bool AllowHorsesToBypassClippingChecks = true;

	public bool AllowBikesToBypassClippingChecks = true;

	public bool IgnoreParentEntityColliders;

	protected override bool IsClipping(BaseEntity ent)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		if (AllowHorsesToBypassClippingChecks && ent is RidableHorse)
		{
			return false;
		}
		if ((AllowBikesToBypassClippingChecks && ent is Bike) || ent is Snowmobile)
		{
			return false;
		}
		if (IgnoreParentEntityColliders)
		{
			List<Collider> list = Pool.Get<List<Collider>>();
			GamePhysics.OverlapOBB(ent.WorldSpaceBounds(), list, 1218511105, (QueryTriggerInteraction)1);
			BaseEntity baseEntity = ((Component)this).gameObject.ToBaseEntity();
			foreach (Collider item in list)
			{
				BaseEntity baseEntity2 = item.ToBaseEntity();
				if ((Object)(object)baseEntity2 != (Object)null)
				{
					if (!((Object)(object)baseEntity2 == (Object)(object)baseEntity) && !(baseEntity2 is Elevator))
					{
					}
					continue;
				}
				return true;
			}
			Pool.FreeUnmanaged<Collider>(ref list);
			return false;
		}
		return base.IsClipping(ent);
	}
}


using ConVar;
using UnityEngine;

public class TriggerParentEnclosed : TriggerParent
{
	public enum TriggerMode
	{
		TriggerPoint,
		PivotPoint
	}

	public float Padding;

	[Tooltip("AnyIntersect: Look for any intersection with the trigger. OriginIntersect: Only consider objects in the trigger if their origin is inside")]
	public TriggerMode intersectionMode;

	public bool CheckBoundsOnUnparent;

	public BoxCollider boxCollider;

	protected void OnEnable()
	{
		boxCollider = ((Component)this).GetComponent<BoxCollider>();
	}

	public override bool ShouldParent(BaseEntity ent, bool bypassOtherTriggerCheck = false)
	{
		if (!base.ShouldParent(ent, bypassOtherTriggerCheck))
		{
			return false;
		}
		return IsInside(ent, Padding);
	}

	internal override bool SkipOnTriggerExit(Collider collider)
	{
		if (!CheckBoundsOnUnparent)
		{
			return false;
		}
		if (!Debugging.checkparentingtriggers)
		{
			return false;
		}
		BaseEntity baseEntity = collider.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return false;
		}
		return IsInside(baseEntity, 0f);
	}

	public bool IsInside(BaseEntity ent, float padding)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		Bounds val = default(Bounds);
		((Bounds)(ref val))..ctor(boxCollider.center, boxCollider.size);
		if (padding > 0f)
		{
			((Bounds)(ref val)).Expand(padding);
		}
		OBB val2 = default(OBB);
		((OBB)(ref val2))..ctor(((Component)boxCollider).transform, val);
		Vector3 val3 = ((intersectionMode == TriggerMode.TriggerPoint) ? ent.TriggerPoint() : ent.PivotPoint());
		return ((OBB)(ref val2)).Contains(val3);
	}
}


public enum TriggerMode
{
	TriggerPoint,
	PivotPoint
}


using UnityEngine;

public class TriggerParentExclusion : TriggerBase, IServerComponent
{
	public bool IgnoreIfOnLadder;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (IgnoreIfOnLadder && baseEntity is BasePlayer basePlayer && basePlayer.OnLadder())
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


public interface IPathListener
{
	void OnSplinePathTrigger(int pathId, WorldSpline spline, int direction);

	void OnBasePathTrigger(int pathId, BasePath path);
}


using UnityEngine;

public class TriggerPath : TriggerBase, IServerComponent
{
	public int pathTriggerId;

	[Header("Path")]
	public BasePath path;

	[Header("Spline")]
	public WorldSpline spline;

	public int splineDirection = 1;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isServer)
		{
			return ((Component)baseEntity).gameObject;
		}
		return null;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		IPathListener pathListener = default(IPathListener);
		if (((Component)ent).TryGetComponent<IPathListener>(ref pathListener))
		{
			if (Object.op_Implicit((Object)(object)spline))
			{
				pathListener.OnSplinePathTrigger(pathTriggerId, spline, splineDirection);
			}
			if (Object.op_Implicit((Object)(object)path))
			{
				pathListener.OnBasePathTrigger(pathTriggerId, path);
			}
		}
	}
}


using System;
using UnityEngine;

public class TriggerPlayerForce : TriggerBase, IServerComponent
{
	public BoxCollider triggerCollider;

	public float pushVelocity = 5f;

	public bool requireUpAxis;

	private const float HACK_DISABLE_TIME = 4f;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			return ((Component)baseEntity).gameObject;
		}
		return null;
	}

	internal override void OnObjects()
	{
		((FacepunchBehaviour)this).InvokeRepeating((Action)HackDisableTick, 0f, 3.75f);
	}

	internal override void OnEmpty()
	{
		base.OnEmpty();
		((FacepunchBehaviour)this).CancelInvoke((Action)HackDisableTick);
	}

	protected override void OnDisable()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)HackDisableTick);
		base.OnDisable();
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		base.OnEntityLeave(ent);
		ent.ApplyInheritedVelocity(Vector3.zero);
	}

	private void HackDisableTick()
	{
		if (entityContents == null || !((Behaviour)this).enabled)
		{
			return;
		}
		foreach (BaseEntity entityContent in entityContents)
		{
			if (IsInterested(entityContent))
			{
				BasePlayer basePlayer = entityContent.ToPlayer();
				if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsNpc)
				{
					basePlayer.PauseVehicleNoClipDetection(4f);
					basePlayer.PauseSpeedHackDetection(4f);
				}
			}
		}
	}

	protected void FixedUpdate()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		if (entityContents == null)
		{
			return;
		}
		foreach (BaseEntity entityContent in entityContents)
		{
			if ((!requireUpAxis || !(Vector3.Dot(((Component)entityContent).transform.up, ((Component)this).transform.up) < 0f)) && IsInterested(entityContent))
			{
				Vector3 velocity = GetPushVelocity(((Component)entityContent).gameObject);
				entityContent.ApplyInheritedVelocity(velocity);
			}
		}
	}

	private Vector3 GetPushVelocity(GameObject obj)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		Bounds bounds = ((Collider)triggerCollider).bounds;
		Vector3 val = -(((Bounds)(ref bounds)).center - obj.transform.position);
		((Vector3)(ref val)).Normalize();
		val.y = 0.2f;
		((Vector3)(ref val)).Normalize();
		return val * pushVelocity;
	}

	private bool IsInterested(BaseEntity entity)
	{
		if ((Object)(object)entity == (Object)null || entity.isClient)
		{
			return false;
		}
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer != (Object)null)
		{
			if ((basePlayer.IsAdmin || basePlayer.IsDeveloper) && basePlayer.IsFlying)
			{
				return false;
			}
			if ((Object)(object)basePlayer != (Object)null && basePlayer.IsAlive())
			{
				return !basePlayer.isMounted;
			}
			return false;
		}
		return true;
	}
}


using System;
using Rust;
using UnityEngine;

public class TriggerPlayerTimer : TriggerBase, IServerComponent
{
	public BaseEntity TargetEntity;

	public float DamageAmount = 20f;

	public float TimeToDamage = 3f;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj != (Object)null)
		{
			BaseEntity baseEntity = obj.ToBaseEntity();
			if (baseEntity is BasePlayer basePlayer && baseEntity.isServer && !basePlayer.isMounted)
			{
				return ((Component)baseEntity).gameObject;
			}
		}
		return obj;
	}

	internal override void OnObjects()
	{
		base.OnObjects();
		((FacepunchBehaviour)this).Invoke((Action)DamageTarget, TimeToDamage);
	}

	internal override void OnEmpty()
	{
		base.OnEmpty();
		((FacepunchBehaviour)this).CancelInvoke((Action)DamageTarget);
	}

	private void DamageTarget()
	{
		bool flag = false;
		foreach (BaseEntity entityContent in entityContents)
		{
			if (entityContent is BasePlayer { isMounted: false })
			{
				flag = true;
			}
		}
		if (flag && (Object)(object)TargetEntity != (Object)null)
		{
			TargetEntity.OnAttacked(new HitInfo(null, TargetEntity, DamageType.Generic, DamageAmount));
		}
		((FacepunchBehaviour)this).Invoke((Action)DamageTarget, TimeToDamage);
	}
}


using ConVar;
using Rust.Ai;
using UnityEngine;

public class TriggerQTE : TriggerBase, IServerComponent
{
	public WildlifeHazard Entity;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if ((Object)(object)(baseEntity as BasePlayer) == (Object)null)
		{
			return null;
		}
		if (baseEntity.IsNpc)
		{
			return null;
		}
		if (AI.ignoreplayers)
		{
			return null;
		}
		if (SimpleAIMemory.PlayerIgnoreList.Contains(baseEntity as BasePlayer))
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if ((Object)(object)Entity == (Object)null)
		{
			Debug.LogWarning((object)"TriggerQTE with no Entity linked", (Object)(object)((Component)this).gameObject);
		}
		else
		{
			Entity.TriggeredByPlayer(ent as BasePlayer);
		}
	}
}


using UnityEngine;
using UnityEngine.Serialization;

public class TriggerRadiation : TriggerBase
{
	public Radiation.Tier radiationTier = Radiation.Tier.LOW;

	public bool BypassArmor;

	public float RadiationAmountOverride;

	public float falloff = 0.1f;

	[FormerlySerializedAs("UseColliderRadius")]
	public bool DontScaleRadiationSize;

	public bool UseLOSCheck;

	public bool ApplyLocalHeightCheck;

	public float MinLocalHeight;

	private SphereCollider sphereCollider;

	private BoxCollider boxCollider;

	private float GetRadiationSize()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)sphereCollider))
		{
			sphereCollider = ((Component)this).GetComponent<SphereCollider>();
		}
		if ((Object)(object)sphereCollider != (Object)null)
		{
			if (!DontScaleRadiationSize)
			{
				return sphereCollider.radius * Vector3Ex.Max(((Component)this).transform.localScale);
			}
			return sphereCollider.radius;
		}
		if (!Object.op_Implicit((Object)(object)boxCollider))
		{
			boxCollider = ((Component)this).GetComponent<BoxCollider>();
		}
		if ((Object)(object)boxCollider != (Object)null)
		{
			Vector3 size = boxCollider.size;
			if (!DontScaleRadiationSize)
			{
				return Mathf.Max(new float[3] { size.x, size.y, size.z }) * 0.5f * Vector3Ex.Max(((Component)this).transform.localScale);
			}
			return Mathf.Max(new float[3] { size.x, size.y, size.z }) * 0.5f;
		}
		return 0f;
	}

	private float GetTriggerRadiation()
	{
		if (RadiationAmountOverride > 0f)
		{
			return RadiationAmountOverride;
		}
		return Radiation.GetRadiation(radiationTier);
	}

	public float GetRadiation(Vector3 position, float radProtection)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if (ApplyLocalHeightCheck && ((Component)this).transform.InverseTransformPoint(position).y < MinLocalHeight)
		{
			return 0f;
		}
		if (UseLOSCheck && !GamePhysics.LineOfSight(((Component)this).gameObject.transform.position, position, 2097152))
		{
			return 0f;
		}
		float radiationSize = GetRadiationSize();
		float triggerRadiation = GetTriggerRadiation();
		float num = Vector3.Distance(((Component)this).gameObject.transform.position, position);
		float num2 = Mathf.InverseLerp(radiationSize, radiationSize * (1f - falloff), num);
		float num3 = triggerRadiation;
		if (!BypassArmor)
		{
			num3 = Radiation.GetRadiationAfterProtection(triggerRadiation, radProtection);
		}
		return num3 * num2;
	}

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (!(baseEntity is BaseCombatEntity))
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public void OnDrawGizmosSelected()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		float radiationSize = GetRadiationSize();
		Gizmos.color = Color.green;
		if (Object.op_Implicit((Object)(object)sphereCollider))
		{
			Gizmos.DrawWireSphere(((Component)this).transform.position, radiationSize);
		}
		else if (Object.op_Implicit((Object)(object)boxCollider))
		{
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(radiationSize, radiationSize, radiationSize);
			val *= 2f;
			Gizmos.DrawWireCube(((Component)this).transform.position, val);
		}
		Gizmos.color = Color.red;
		if (Object.op_Implicit((Object)(object)sphereCollider))
		{
			Gizmos.DrawWireSphere(((Component)this).transform.position, radiationSize * (1f - falloff));
		}
		else if (Object.op_Implicit((Object)(object)boxCollider))
		{
			Vector3 val2 = default(Vector3);
			((Vector3)(ref val2))..ctor(radiationSize, radiationSize, radiationSize);
			val2 *= 2f;
			Gizmos.DrawWireCube(((Component)this).transform.position, val2 * (1f - falloff));
		}
	}
}


using UnityEngine;

public class TriggerRagdollRelocate : TriggerBase
{
	public Transform targetLocation;

	internal override void OnObjectAdded(GameObject obj, Collider col)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		base.OnObjectAdded(obj, col);
		BaseEntity baseEntity = obj.transform.ToBaseEntity();
		if ((Object)(object)baseEntity != (Object)null && baseEntity.isServer)
		{
			RepositionTransform(((Component)baseEntity).transform);
		}
		Ragdoll componentInParent = obj.GetComponentInParent<Ragdoll>();
		if (!((Object)(object)componentInParent != (Object)null))
		{
			return;
		}
		RepositionTransform(((Component)componentInParent).transform);
		foreach (Rigidbody rigidbody in componentInParent.rigidbodies)
		{
			if (((Component)rigidbody).transform.position.y < ((Component)this).transform.position.y)
			{
				RepositionTransform(((Component)rigidbody).transform);
			}
		}
	}

	private void RepositionTransform(Transform t)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = targetLocation.InverseTransformPoint(t.position);
		val.y = 0f;
		val = targetLocation.TransformPoint(val);
		t.position = val;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class TriggerSafeZone : TriggerBase
{
	public static List<TriggerSafeZone> allSafeZones = new List<TriggerSafeZone>();

	public float maxDepth = 20f;

	public float maxAltitude = -1f;

	public Collider triggerCollider { get; private set; }

	protected override void Awake()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		base.Awake();
		triggerCollider = ((Component)this).GetComponent<Collider>();
		base.InterestLayers = LayerMask.op_Implicit(LayerMask.op_Implicit(base.InterestLayers) | 0x200);
	}

	protected void OnEnable()
	{
		allSafeZones.Add(this);
	}

	protected override void OnDisable()
	{
		base.OnDisable();
		allSafeZones.Remove(this);
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public bool PassesHeightChecks(Vector3 entPos)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		float num = Mathf.Abs(position.y - entPos.y);
		if (maxDepth != -1f && entPos.y < position.y && num > maxDepth)
		{
			return false;
		}
		if (maxAltitude != -1f && entPos.y > position.y && num > maxAltitude)
		{
			return false;
		}
		return true;
	}

	public float GetSafeLevel(Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		if (!PassesHeightChecks(pos))
		{
			return 0f;
		}
		return 1f;
	}
}


using UnityEngine;

public class TriggerSnowmobileAchievement : TriggerBase
{
	internal override GameObject InterestedInObject(GameObject obj)
	{
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity != (Object)null && baseEntity.isServer && (Object)(object)baseEntity.ToPlayer() != (Object)null)
		{
			return ((Component)baseEntity).gameObject;
		}
		return null;
	}
}


using UnityEngine;

public class TriggerStashPlayer : TriggerBase
{
	public StashContainer Stash;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BasePlayer basePlayer = obj.ToBaseEntity() as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null)
		{
			return null;
		}
		if (basePlayer.isClient)
		{
			return null;
		}
		return ((Component)basePlayer).gameObject;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		if (entityContents == null || !entityContents.Contains(ent))
		{
			base.OnEntityEnter(ent);
			if (ent is BasePlayer basePlayer)
			{
				basePlayer.AddNeabyStash(Stash);
			}
		}
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
		if (ent is BasePlayer basePlayer)
		{
			basePlayer.RemoveNearbyStash(Stash);
		}
	}
}


using UnityEngine;

public class TriggerSubmarineMoonpool : TriggerBase, IServerComponent
{
	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isServer && baseEntity is BaseSubmarine baseSubmarine)
		{
			return ((Component)baseSubmarine).gameObject;
		}
		return null;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if (ent is BaseSubmarine baseSubmarine)
		{
			baseSubmarine.OnSurfacedInMoonpool();
		}
	}
}


using ConVar;
using UnityEngine;

public class TriggerTemperature : TriggerBase
{
	public float Temperature = 50f;

	public float triggerSize;

	public float minSize;

	public bool sunlightBlocker;

	public float sunlightBlockAmount;

	[Range(0f, 24f)]
	public float blockMinHour = 8.5f;

	[Range(0f, 24f)]
	public float blockMaxHour = 18.5f;

	private void OnValidate()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)((Component)this).GetComponent<SphereCollider>() != (Object)null)
		{
			triggerSize = ((Component)this).GetComponent<SphereCollider>().radius * ((Component)this).transform.localScale.y;
			return;
		}
		Vector3 val = Vector3.Scale(((Component)this).GetComponent<BoxCollider>().size, ((Component)this).transform.localScale);
		triggerSize = Vector3Ex.Max(val) * 0.5f;
	}

	public float WorkoutTemperature(Vector3 position, float oldTemperature)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (sunlightBlocker)
		{
			float time = Env.time;
			if (time >= blockMinHour && time <= blockMaxHour)
			{
				Vector3 position2 = TOD_Sky.Instance.Components.SunTransform.position;
				if (!GamePhysics.LineOfSight(position, position2, 256))
				{
					return oldTemperature - sunlightBlockAmount;
				}
			}
			return oldTemperature;
		}
		float num = Vector3.Distance(((Component)this).gameObject.transform.position, position);
		float num2 = Mathf.InverseLerp(triggerSize, minSize, num);
		return Mathf.Lerp(oldTemperature, Temperature, num2);
	}

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class TriggerWakeAIZ : TriggerBase, IServerComponent
{
	public float SleepDelaySeconds = 30f;

	public List<AIInformationZone> zones = new List<AIInformationZone>();

	private AIInformationZone aiz;

	public void Init(AIInformationZone zone = null)
	{
		if ((Object)(object)zone != (Object)null)
		{
			aiz = zone;
		}
		else if (zones == null || zones.Count == 0)
		{
			Transform val = ((Component)this).transform.parent;
			if ((Object)(object)val == (Object)null)
			{
				val = ((Component)this).transform;
			}
			aiz = ((Component)val).GetComponentInChildren<AIInformationZone>();
		}
		SetZonesSleeping(flag: true);
	}

	protected override void Awake()
	{
		base.Awake();
		Init();
	}

	private void SetZonesSleeping(bool flag)
	{
		if ((Object)(object)aiz != (Object)null)
		{
			if (flag)
			{
				aiz.SleepAI();
			}
			else
			{
				aiz.WakeAI();
			}
		}
		if (zones == null || zones.Count <= 0)
		{
			return;
		}
		foreach (AIInformationZone zone in zones)
		{
			if ((Object)(object)zone != (Object)null)
			{
				if (flag)
				{
					zone.SleepAI();
				}
				else
				{
					zone.WakeAI();
				}
			}
		}
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		BasePlayer basePlayer = baseEntity as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null && basePlayer.IsNpc)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if (!((Object)(object)aiz == (Object)null) || (zones != null && zones.Count != 0))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SleepAI);
			SetZonesSleeping(flag: false);
		}
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
		if ((!((Object)(object)aiz == (Object)null) || (zones != null && zones.Count != 0)) && (entityContents == null || entityContents.Count == 0))
		{
			DelayedSleepAI();
		}
	}

	private void DelayedSleepAI()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)SleepAI);
		((FacepunchBehaviour)this).Invoke((Action)SleepAI, SleepDelaySeconds);
	}

	private void SleepAI()
	{
		SetZonesSleeping(flag: true);
	}
}


using UnityEngine;

public class TriggerWetness : TriggerBase
{
	public float Wetness = 0.25f;

	public SphereCollider TargetCollider;

	public Transform OriginTransform;

	public bool ApplyLocalHeightCheck;

	public float MinLocalHeight;

	public float WorkoutWetness(Vector3 position)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (ApplyLocalHeightCheck && ((Component)this).transform.InverseTransformPoint(position).y < MinLocalHeight)
		{
			return 0f;
		}
		float num = Vector3Ex.Distance2D(OriginTransform.position, position) / TargetCollider.radius;
		num = Mathf.Clamp01(num);
		num = 1f - num;
		return Mathf.Lerp(0f, Wetness, num);
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using UnityEngine;

public class TriggerWorkbench : TriggerBase
{
	public Workbench parentBench;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public float WorkbenchLevel()
	{
		return parentBench.Workbenchlevel;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if (ent is BasePlayer basePlayer)
		{
			basePlayer.metabolism.ForceUpdateWorkbenchFlags();
		}
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
		if (ent is BasePlayer basePlayer)
		{
			basePlayer.metabolism.ForceUpdateWorkbenchFlags();
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class TubeRenderer : FacepunchBehaviour
{
	[Header("Settings")]
	[Range(3f, 64f)]
	public int Segments = 12;

	public float Radius = 0.1f;

	public bool useLocalPositions;

	[Header("Caps")]
	public bool EnableCaps = true;

	[Range(1f, 8f)]
	public int HemisphereRings = 4;

	[NonSerialized]
	public List<Vector3> points = new List<Vector3>();

	private Mesh mesh;

	public void ClearPositions()
	{
		points.Clear();
	}

	public void SetPosition(int index, Vector3 position)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (index >= 0 && index < points.Count)
		{
			points[index] = position;
		}
	}

	public void SetPositions(List<Vector3> positions)
	{
		points.Clear();
		points.AddRange(positions);
	}

	public void UpdateRenderer()
	{
		GenerateTube(points, Radius, Segments, HemisphereRings);
	}

	private void SetupMesh()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Expected O, but got Unknown
		mesh = new Mesh
		{
			name = "Tube Mesh"
		};
		mesh.MarkDynamic();
		MeshFilter val = ((Component)this).GetComponent<MeshFilter>();
		if ((Object)(object)val == (Object)null)
		{
			val = ((Component)this).gameObject.AddComponent<MeshFilter>();
		}
		val.mesh = mesh;
		if ((Object)(object)((Component)this).GetComponent<MeshRenderer>() == (Object)null)
		{
			((Component)this).gameObject.AddComponent<MeshRenderer>();
		}
	}

	private void GenerateTube(List<Vector3> points, float radius, int segments, int rings)
	{
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		if (points == null || points.Count < 2)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("TubeRenderer.GenerateTube", 0);
		try
		{
			if ((Object)(object)mesh == (Object)null)
			{
				SetupMesh();
			}
			List<Vector3> list = Pool.Get<List<Vector3>>();
			List<int> list2 = Pool.Get<List<int>>();
			List<Vector2> list3 = Pool.Get<List<Vector2>>();
			List<Quaternion> list4 = Pool.Get<List<Quaternion>>();
			List<float> list5 = Pool.Get<List<float>>();
			int vertOffset = 0;
			ComputeParallelTransportFrames(points, list4);
			list5.Add(0f);
			float num = 0f;
			for (int i = 1; i < points.Count; i++)
			{
				float num2 = Vector3.Distance(points[i - 1], points[i]);
				num += num2;
				list5.Add(num);
			}
			for (int j = 0; j < points.Count; j++)
			{
				Vector3 center = (useLocalPositions ? points[j] : ((Component)this).transform.InverseTransformPoint(points[j]));
				float v = ((num > 0f) ? (list5[j] / num) : 0f);
				AppendRing(list, list3, list4[j], center, radius, segments, v);
				if (j > 0)
				{
					BridgeLastTwoRings(list2, vertOffset, segments);
				}
				vertOffset += segments + 1;
			}
			if (EnableCaps)
			{
				AppendHemisphereCap(list, list2, list3, ref vertOffset, points[0], list4[0], radius, segments, rings, -1);
				List<Vector3> verts = list;
				List<int> tris = list2;
				List<Vector2> uvs = list3;
				Vector3 position = points[points.Count - 1];
				List<Quaternion> list6 = list4;
				AppendHemisphereCap(verts, tris, uvs, ref vertOffset, position, list6[list6.Count - 1], radius, segments, rings, 1);
			}
			else
			{
				AppendFlatCap(list, list2, list3, ref vertOffset, points[0], list4[0], radius, segments, -1);
				List<Vector3> verts2 = list;
				List<int> tris2 = list2;
				List<Vector2> uvs2 = list3;
				Vector3 position2 = points[points.Count - 1];
				List<Quaternion> list7 = list4;
				AppendFlatCap(verts2, tris2, uvs2, ref vertOffset, position2, list7[list7.Count - 1], radius, segments, 1);
			}
			mesh.Clear();
			mesh.SetVertices(list);
			mesh.SetUVs(0, list3);
			mesh.SetTriangles(list2, 0);
			mesh.RecalculateNormals();
			mesh.RecalculateBounds();
			Pool.FreeUnmanaged<Vector3>(ref list);
			Pool.FreeUnmanaged<int>(ref list2);
			Pool.FreeUnmanaged<Quaternion>(ref list4);
			Pool.FreeUnmanaged<Vector2>(ref list3);
			Pool.FreeUnmanaged<float>(ref list5);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void ComputeParallelTransportFrames(List<Vector3> points, List<Quaternion> rotations)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		rotations.Clear();
		if (points.Count >= 2)
		{
			Vector3 val = points[1] - points[0];
			Vector3 val2 = ((Vector3)(ref val)).normalized;
			Vector3 val3 = ((Mathf.Abs(Vector3.Dot(val2, Vector3.up)) < 0.99f) ? Vector3.up : Vector3.right);
			val = Vector3.Cross(val2, val3);
			Vector3 val4 = ((Vector3)(ref val)).normalized;
			val = Vector3.Cross(val2, val4);
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			rotations.Add(Quaternion.LookRotation(val2, normalized));
			for (int i = 1; i < points.Count; i++)
			{
				val = points[i] - points[i - 1];
				Vector3 normalized2 = ((Vector3)(ref val)).normalized;
				Vector3 val5 = Quaternion.FromToRotation(val2, normalized2) * val4;
				val = Vector3.Cross(normalized2, val5);
				Vector3 normalized3 = ((Vector3)(ref val)).normalized;
				rotations.Add(Quaternion.LookRotation(normalized2, normalized3));
				val2 = normalized2;
				val4 = val5;
			}
		}
	}

	private void AppendRing(List<Vector3> verts, List<Vector2> uvs, Quaternion rotation, Vector3 center, float radius, int segments, float v)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = rotation * Vector3.right;
		Vector3 val2 = rotation * Vector3.up;
		for (int i = 0; i <= segments; i++)
		{
			float num = (float)i / (float)segments * MathF.PI * 2f;
			Vector3 val3 = Mathf.Cos(num) * val + Mathf.Sin(num) * val2;
			verts.Add(center + val3 * radius);
			uvs.Add(new Vector2((float)i / (float)segments, v));
		}
	}

	private void BridgeLastTwoRings(List<int> tris, int vertOffset, int segments)
	{
		int num = vertOffset - (segments + 1);
		for (int i = 0; i < segments; i++)
		{
			int item = num + i;
			int item2 = num + i + 1;
			int item3 = vertOffset + i;
			int item4 = vertOffset + i + 1;
			tris.Add(item);
			tris.Add(item2);
			tris.Add(item3);
			tris.Add(item2);
			tris.Add(item4);
			tris.Add(item3);
		}
	}

	private void AppendFlatCap(List<Vector3> verts, List<int> tris, List<Vector2> uvs, ref int vertOffset, Vector3 position, Quaternion rotation, float radius, int segments, int direction)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		position = (useLocalPositions ? position : ((Component)this).transform.InverseTransformPoint(position));
		Vector3 val = rotation * Vector3.right;
		Vector3 val2 = rotation * Vector3.up;
		int count = verts.Count;
		verts.Add(position);
		uvs.Add(new Vector2(0.5f, 0.5f));
		for (int i = 0; i <= segments; i++)
		{
			float num = (float)i / (float)segments * MathF.PI * 2f;
			Vector3 val3 = Mathf.Cos(num) * val + Mathf.Sin(num) * val2;
			verts.Add(position + val3 * radius);
			float num2 = Mathf.Cos(num) * 0.5f + 0.5f;
			float num3 = Mathf.Sin(num) * 0.5f + 0.5f;
			uvs.Add(new Vector2(num2, num3));
		}
		for (int j = 0; j < segments; j++)
		{
			int item = count + j + 1;
			int item2 = count + j + 2;
			if (direction == 1)
			{
				tris.Add(count);
				tris.Add(item);
				tris.Add(item2);
			}
			else
			{
				tris.Add(count);
				tris.Add(item2);
				tris.Add(item);
			}
		}
		vertOffset += segments + 2;
	}

	private void AppendHemisphereCap(List<Vector3> verts, List<int> tris, List<Vector2> uvs, ref int vertOffset, Vector3 position, Quaternion rotation, float radius, int segments, int rings, int direction)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		position = (useLocalPositions ? position : ((Component)this).transform.InverseTransformPoint(position));
		List<Vector3> list = Pool.Get<List<Vector3>>();
		List<Vector2> list2 = Pool.Get<List<Vector2>>();
		Vector3 val = default(Vector3);
		for (int i = 0; i <= rings; i++)
		{
			float num = (float)i / (float)rings * MathF.PI / 2f;
			for (int j = 0; j <= segments; j++)
			{
				float num2 = (float)j / (float)segments * MathF.PI * 2f;
				float num3 = Mathf.Sin(num);
				((Vector3)(ref val))..ctor(Mathf.Cos(num2) * num3, Mathf.Sin(num2) * num3, Mathf.Cos(num) * (float)direction);
				Vector3 item = rotation * (val * radius) + position;
				list.Add(item);
				float num4 = Mathf.Cos(num2) * num3 * 0.5f + 0.5f;
				float num5 = Mathf.Sin(num2) * num3 * 0.5f + 0.5f;
				list2.Add(new Vector2(num4, num5));
			}
		}
		int count = verts.Count;
		verts.AddRange(list);
		uvs.AddRange(list2);
		for (int k = 0; k < rings; k++)
		{
			for (int l = 0; l < segments; l++)
			{
				int num6 = count + k * (segments + 1) + l;
				int item2 = num6 + 1;
				int num7 = num6 + (segments + 1);
				int item3 = num7 + 1;
				if (direction == 0)
				{
					tris.Add(num6);
					tris.Add(item2);
					tris.Add(num7);
					tris.Add(item2);
					tris.Add(item3);
					tris.Add(num7);
				}
				else
				{
					tris.Add(num6);
					tris.Add(num7);
					tris.Add(item2);
					tris.Add(item2);
					tris.Add(num7);
					tris.Add(item3);
				}
			}
		}
		vertOffset += list.Count;
		Pool.FreeUnmanaged<Vector3>(ref list);
		Pool.FreeUnmanaged<Vector2>(ref list2);
	}
}


using UnityEngine;

public class ValidBounds : SingletonComponent<ValidBounds>
{
	public Bounds worldBounds;

	public static bool Test(BaseEntity entity, Vector3 vPos)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)SingletonComponent<ValidBounds>.Instance))
		{
			return true;
		}
		if ((Object)(object)entity != (Object)null && entity.net != null && entity.net.group != null && TutorialIsland.IsTutorialNetworkGroup(entity.net.group.ID))
		{
			return SingletonComponent<ValidBounds>.Instance.IsInsideOuterBounds(vPos);
		}
		return SingletonComponent<ValidBounds>.Instance.IsInsideInnerBounds(vPos);
	}

	public static float TestDist(BaseEntity entity, Vector3 vPos)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)SingletonComponent<ValidBounds>.Instance))
		{
			return float.MaxValue;
		}
		if ((Object)(object)entity != (Object)null && entity.net != null && entity.net.group != null && TutorialIsland.IsTutorialNetworkGroup(entity.net.group.ID))
		{
			return float.MaxValue;
		}
		return SingletonComponent<ValidBounds>.Instance.DistToWorldEdge2D(vPos);
	}

	public static bool TestInnerBounds(Vector3 vPos)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)SingletonComponent<ValidBounds>.Instance))
		{
			return true;
		}
		return SingletonComponent<ValidBounds>.Instance.IsInsideInnerBounds(vPos);
	}

	public static bool TestOuterBounds(Vector3 vPos)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)SingletonComponent<ValidBounds>.Instance))
		{
			return true;
		}
		return SingletonComponent<ValidBounds>.Instance.IsInsideOuterBounds(vPos);
	}

	internal bool IsInsideInnerBounds(Vector3 vPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3Ex.IsNaNOrInfinity(vPos))
		{
			return false;
		}
		if (!((Bounds)(ref worldBounds)).Contains(vPos))
		{
			return false;
		}
		if ((Object)(object)TerrainMeta.Terrain != (Object)null)
		{
			if (World.Procedural && vPos.y < TerrainMeta.Position.y)
			{
				return false;
			}
			if (TerrainMeta.OutOfMargin(vPos))
			{
				return false;
			}
		}
		return true;
	}

	internal bool IsInsideOuterBounds(Vector3 vPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3Ex.IsNaNOrInfinity(vPos))
		{
			return false;
		}
		Bounds val = default(Bounds);
		((Bounds)(ref val))..ctor(((Bounds)(ref worldBounds)).center, new Vector3(((Bounds)(ref worldBounds)).size.x + TutorialIsland.TutorialBoundsSize * 2f, ((Bounds)(ref worldBounds)).size.y, ((Bounds)(ref worldBounds)).size.z + TutorialIsland.TutorialBoundsSize * 2f));
		if (!((Bounds)(ref val)).Contains(vPos))
		{
			return false;
		}
		if ((Object)(object)TerrainMeta.Terrain != (Object)null)
		{
			if (World.Procedural && vPos.y < TerrainMeta.Position.y)
			{
				return false;
			}
			if (TerrainMeta.OutOfMarginPlusTutorialBounds(vPos))
			{
				return false;
			}
		}
		return true;
	}

	public static float GetMaximumPointTutorial()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)SingletonComponent<ValidBounds>.Instance == (Object)null)
		{
			return 0f;
		}
		return Mathf.Min(TerrainMeta.Position.x + TerrainMeta.Size.x * 2f + TutorialIsland.TutorialBoundsSize, ((Bounds)(ref SingletonComponent<ValidBounds>.Instance.worldBounds)).extents.x + TutorialIsland.TutorialBoundsSize);
	}

	public static float GetMaximumPoint()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)SingletonComponent<ValidBounds>.Instance == (Object)null)
		{
			return 0f;
		}
		float num = ((Bounds)(ref SingletonComponent<ValidBounds>.Instance.worldBounds)).max.x;
		if ((Object)(object)TerrainMeta.Terrain != (Object)null)
		{
			num = Mathf.Min(TerrainMeta.Position.x + TerrainMeta.Size.x, num);
		}
		return num;
	}

	internal float DistToWorldEdge2D(Vector3 vPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (!IsInsideInnerBounds(vPos))
		{
			return -1f;
		}
		float num = worldBounds.InnerDistToEdge2D(vPos);
		if ((Object)(object)TerrainMeta.Terrain != (Object)null)
		{
			float num2 = TerrainMeta.InnerDistToEdge2D(vPos);
			return Mathf.Min(num, num2);
		}
		return num;
	}
}


using System.Collections.Generic;
using UnityEngine;

public static class Vis
{
	private static int colCount = 0;

	public static Collider[] colBuffer = (Collider[])(object)new Collider[32768];

	private static HashSet<object> hashSet = new HashSet<object>();

	private static void Buffer(Vector3 position, float radius, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		layerMask = GamePhysics.HandleIgnoreCollision(position, layerMask);
		int num = colCount;
		colCount = Physics.OverlapSphereNonAlloc(position, radius, colBuffer, layerMask, triggerInteraction);
		for (int i = colCount; i < num; i++)
		{
			colBuffer[i] = null;
		}
		if (colCount >= colBuffer.Length)
		{
			Debug.LogWarning((object)"Vis query is exceeding collider buffer length.");
			colCount = colBuffer.Length;
		}
	}

	public static bool AnyColliders(Vector3 position, float radius, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		Buffer(position, radius, layerMask, triggerInteraction);
		return colCount > 0;
	}

	public static void Colliders<T>(Vector3 position, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : Collider
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		Buffer(position, radius, layerMask, triggerInteraction);
		for (int i = 0; i < colCount; i++)
		{
			Collider obj = colBuffer[i];
			T val = (T)(object)((obj is T) ? obj : null);
			if (!((Object)(object)val == (Object)null) && ((Collider)val).enabled)
			{
				list.Add(val);
			}
		}
	}

	public static void Components<T>(Vector3 position, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : Component
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		Buffer(position, radius, layerMask, triggerInteraction);
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if (!((Object)(object)val == (Object)null) && val.enabled)
			{
				T component = ((Component)val).GetComponent<T>();
				if (!((Object)(object)component == (Object)null))
				{
					list.Add(component);
				}
			}
		}
	}

	public static void Entities<T>(Vector3 position, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : class
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		Buffer(position, radius, layerMask, triggerInteraction);
		hashSet.Clear();
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if (!((Object)(object)val == (Object)null) && val.enabled && val.ToBaseEntity() is T item && !hashSet.Contains(item))
			{
				hashSet.Add(item);
				list.Add(item);
			}
		}
	}

	public static void EntityComponents<T>(Vector3 position, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : EntityComponentBase
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		Buffer(position, radius, layerMask, triggerInteraction);
		hashSet.Clear();
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if ((Object)(object)val == (Object)null || !val.enabled)
			{
				continue;
			}
			BaseEntity baseEntity = val.ToBaseEntity();
			if (!((Object)(object)baseEntity == (Object)null) && !hashSet.Contains(baseEntity))
			{
				hashSet.Add(baseEntity);
				T component = ((Component)baseEntity).GetComponent<T>();
				if (!((Object)(object)component == (Object)null))
				{
					list.Add(component);
				}
			}
		}
	}

	private static void Buffer(OBB bounds, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		layerMask = GamePhysics.HandleIgnoreCollision(bounds.position, layerMask);
		int num = colCount;
		colCount = Physics.OverlapBoxNonAlloc(bounds.position, bounds.extents, colBuffer, bounds.rotation, layerMask, triggerInteraction);
		for (int i = colCount; i < num; i++)
		{
			colBuffer[i] = null;
		}
		if (colCount >= colBuffer.Length)
		{
			Debug.LogWarning((object)"Vis query is exceeding collider buffer length.");
			colCount = colBuffer.Length;
		}
	}

	public static void Colliders<T>(OBB bounds, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : Collider
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Buffer(bounds, layerMask, triggerInteraction);
		for (int i = 0; i < colCount; i++)
		{
			Collider obj = colBuffer[i];
			T val = (T)(object)((obj is T) ? obj : null);
			if (!((Object)(object)val == (Object)null) && ((Collider)val).enabled)
			{
				list.Add(val);
			}
		}
	}

	public static void Components<T>(OBB bounds, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : Component
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Buffer(bounds, layerMask, triggerInteraction);
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if (!((Object)(object)val == (Object)null) && val.enabled)
			{
				T component = ((Component)val).GetComponent<T>();
				if (!((Object)(object)component == (Object)null))
				{
					list.Add(component);
				}
			}
		}
	}

	public static void Entities<T>(OBB bounds, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : class
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Buffer(bounds, layerMask, triggerInteraction);
		hashSet.Clear();
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if (!((Object)(object)val == (Object)null) && val.enabled && val.ToBaseEntity() is T item && !hashSet.Contains(item))
			{
				hashSet.Add(item);
				list.Add(item);
			}
		}
	}

	public static void EntityComponents<T>(OBB bounds, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : EntityComponentBase
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Buffer(bounds, layerMask, triggerInteraction);
		hashSet.Clear();
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if ((Object)(object)val == (Object)null || !val.enabled)
			{
				continue;
			}
			BaseEntity baseEntity = val.ToBaseEntity();
			if (!((Object)(object)baseEntity == (Object)null) && !hashSet.Contains(baseEntity))
			{
				hashSet.Add(baseEntity);
				T component = ((Component)baseEntity).GetComponent<T>();
				if (!((Object)(object)component == (Object)null))
				{
					list.Add(component);
				}
			}
		}
	}

	private static void Buffer(Vector3 startPosition, Vector3 endPosition, float radius, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		layerMask = GamePhysics.HandleIgnoreCollision(startPosition, layerMask);
		int num = colCount;
		colCount = Physics.OverlapCapsuleNonAlloc(startPosition, endPosition, radius, colBuffer, layerMask, triggerInteraction);
		for (int i = colCount; i < num; i++)
		{
			colBuffer[i] = null;
		}
		if (colCount >= colBuffer.Length)
		{
			Debug.LogWarning((object)"Vis query is exceeding collider buffer length.");
			colCount = colBuffer.Length;
		}
	}

	public static void Colliders<T>(Vector3 startPosition, Vector3 endPosition, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : Collider
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		Buffer(startPosition, endPosition, radius, layerMask, triggerInteraction);
		for (int i = 0; i < colCount; i++)
		{
			Collider obj = colBuffer[i];
			T val = (T)(object)((obj is T) ? obj : null);
			if (!((Object)(object)val == (Object)null) && ((Collider)val).enabled)
			{
				list.Add(val);
			}
		}
	}

	public static void Components<T>(Vector3 startPosition, Vector3 endPosition, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : Component
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		Buffer(startPosition, endPosition, radius, layerMask, triggerInteraction);
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if (!((Object)(object)val == (Object)null) && val.enabled)
			{
				T component = ((Component)val).GetComponent<T>();
				if (!((Object)(object)component == (Object)null))
				{
					list.Add(component);
				}
			}
		}
	}

	public static void Entities<T>(Vector3 startPosition, Vector3 endPosition, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : class
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		Buffer(startPosition, endPosition, radius, layerMask, triggerInteraction);
		hashSet.Clear();
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if (!((Object)(object)val == (Object)null) && val.enabled && val.ToBaseEntity() is T item && !hashSet.Contains(item))
			{
				hashSet.Add(item);
				list.Add(item);
			}
		}
	}

	public static void EntityComponents<T>(Vector3 startPosition, Vector3 endPosition, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : EntityComponentBase
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		Buffer(startPosition, endPosition, radius, layerMask, triggerInteraction);
		hashSet.Clear();
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if ((Object)(object)val == (Object)null || !val.enabled)
			{
				continue;
			}
			BaseEntity baseEntity = val.ToBaseEntity();
			if (!((Object)(object)baseEntity == (Object)null) && !hashSet.Contains(baseEntity))
			{
				hashSet.Add(baseEntity);
				T component = ((Component)baseEntity).GetComponent<T>();
				if (!((Object)(object)component == (Object)null))
				{
					list.Add(component);
				}
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;
using UtilityJobs;
using WaterLevelJobs;

public static class WaterLevel
{
	public struct WaterInfo
	{
		public bool isValid;

		public float currentDepth;

		public float overallDepth;

		public float surfaceLevel;

		public float terrainHeight;

		public bool artificalWater;

		public int topology;
	}

	public const float InvalidWaterHeight = -1000f;

	private static NativeReference<int> CounterRef;

	private static NativeArray<Vector3> Centers;

	private static NativeArray<float> WaterHeights;

	private static NativeArray<float> TerrainHeights;

	private static NativeArray<int> Indices;

	private static NativeArray<bool> GetIgnoreResults;

	private static NativeArray<Vector3> GetIgnoreHeadStarts;

	private static NativeArray<float> GetIgnoreHeadRadii;

	private static NativeArray<Vector2> UVs;

	private static NativeArray<int> Topologies;

	private static NativeArray<float> ShoreDists;

	private static NativeArray<float> WaveHeights;

	public static float Factor(Vector3 start, Vector3 end, float radius, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.Factor", 0);
		try
		{
			return Factor(GetWaterInfo(start, end, radius, waves, volumes, forEntity), start, end, radius);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float Factor(in WaterInfo info, Vector3 start, Vector3 end, float radius)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!info.isValid)
		{
			return 0f;
		}
		return Mathf.InverseLerp(Mathf.Min(start.y, end.y) - radius, Mathf.Max(start.y, end.y) + radius, info.surfaceLevel);
	}

	public static float Factor(Bounds bounds, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.Factor", 0);
		try
		{
			if (((Bounds)(ref bounds)).size == Vector3.zero)
			{
				((Bounds)(ref bounds)).size = new Vector3(0.1f, 0.1f, 0.1f);
			}
			WaterInfo waterInfo = GetWaterInfo(bounds, waves, volumes, forEntity);
			return waterInfo.isValid ? Mathf.InverseLerp(((Bounds)(ref bounds)).min.y, ((Bounds)(ref bounds)).max.y, waterInfo.surfaceLevel) : 0f;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float Factor(in WaterInfo info, Bounds bounds)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if (((Bounds)(ref bounds)).size == Vector3.zero)
		{
			((Bounds)(ref bounds)).size = new Vector3(0.1f, 0.1f, 0.1f);
		}
		if (!info.isValid)
		{
			return 0f;
		}
		return Mathf.InverseLerp(((Bounds)(ref bounds)).min.y, ((Bounds)(ref bounds)).max.y, info.surfaceLevel);
	}

	public static bool Test(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.Test", 0);
		try
		{
			return GetWaterInfo(pos, waves, volumes, forEntity).isValid;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool Test(in WaterInfo info, bool volumes, Vector3 pos, BaseEntity forEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		bool flag = pos.y >= info.terrainHeight - 1f && pos.y <= info.surfaceLevel;
		if (!flag && volumes)
		{
			flag = GetWaterInfoFromVolumes(pos, forEntity).isValid;
		}
		return flag;
	}

	public static (float, float) GetWaterAndTerrainSurface(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterDepth", 0);
		try
		{
			WaterInfo waterInfo = GetWaterInfo(pos, waves, volumes, forEntity);
			return (waterInfo.surfaceLevel, waterInfo.terrainHeight);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float GetWaterOrTerrainSurface(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterDepth", 0);
		try
		{
			WaterInfo waterInfo = GetWaterInfo(pos, waves, volumes, forEntity);
			return Mathf.Max(waterInfo.surfaceLevel, waterInfo.terrainHeight);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float GetWaterSurface(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterDepth", 0);
		try
		{
			return GetWaterInfo(pos, waves, volumes, forEntity).surfaceLevel;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float GetWaterDepth(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterDepth", 0);
		try
		{
			return GetWaterInfo(pos, waves, volumes, forEntity).currentDepth;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float GetOverallWaterDepth(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetOverallWaterDepth", 0);
		try
		{
			return GetWaterInfo(pos, waves, volumes, forEntity).overallDepth;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static Vector3 GetWaterFlowDirection(Vector3 worldPosition)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.WaterFlowMap == (Object)null)
		{
			return Vector3.zero;
		}
		return TerrainMeta.WaterFlowMap.GetFlowDirection(worldPosition);
	}

	public static Vector3 GetWaterNormal(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.up;
	}

	public static WaterInfo GetBuoyancyWaterInfo(Vector3 pos, Vector2 posUV, float terrainHeight, float waterHeight, bool doDeepwaterChecks, BaseEntity forEntity)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterInfo", 0);
		try
		{
			WaterInfo result = default(WaterInfo);
			if (pos.y > waterHeight)
			{
				return GetWaterInfoFromVolumes(pos, forEntity);
			}
			bool flag = pos.y < terrainHeight - 1f;
			if (flag)
			{
				return GetWaterInfoFromVolumes(pos, forEntity);
			}
			bool flag2 = doDeepwaterChecks && (pos.y < waterHeight - 10f || TerrainMeta.OutOfBounds(pos));
			int num = (Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap) ? TerrainMeta.TopologyMap.GetTopologyFast(posUV) : 0);
			if ((flag || flag2 || (num & 0x3C180) == 0) && Object.op_Implicit((Object)(object)WaterSystem.Collision) && WaterSystem.Collision.GetIgnore(pos))
			{
				return result;
			}
			RaycastHit val2 = default(RaycastHit);
			if (flag2 && Physics.Raycast(pos, Vector3.up, ref val2, 5f, 16, (QueryTriggerInteraction)2))
			{
				float num2 = waterHeight;
				Bounds bounds = ((RaycastHit)(ref val2)).collider.bounds;
				waterHeight = Mathf.Min(num2, ((Bounds)(ref bounds)).max.y);
			}
			result.isValid = true;
			result.currentDepth = Mathf.Max(0f, waterHeight - pos.y);
			result.overallDepth = Mathf.Max(0f, waterHeight - terrainHeight);
			result.surfaceLevel = waterHeight;
			result.terrainHeight = terrainHeight;
			result.topology = num;
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static WaterInfo GetWaterInfo(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterInfo", 0);
		try
		{
			WaterInfo result = default(WaterInfo);
			float num = GetWaterLevel(pos, waves);
			float num2 = ((Object.op_Implicit((Object)(object)TerrainMeta.HeightMap) && TerrainMeta.HeightMap.isInitialized) ? TerrainMeta.HeightMap.GetHeight(pos) : 0f);
			result.isValid = true;
			if (pos.y > num)
			{
				result.isValid = false;
			}
			else if (pos.y < num2 - 1f)
			{
				result.isValid = false;
			}
			bool flag = false;
			if (!result.isValid && volumes)
			{
				result = GetWaterInfoFromVolumes(pos, forEntity);
				if (result.isValid)
				{
					flag = true;
					num = result.surfaceLevel;
				}
			}
			if (result.isValid && Object.op_Implicit((Object)(object)WaterSystem.Collision) && WaterSystem.Collision.GetIgnore(pos))
			{
				result.isValid = false;
				num = -1000f;
			}
			result.currentDepth = Mathf.Max(0f, num - pos.y);
			if (!flag)
			{
				result.overallDepth = Mathf.Max(0f, num - num2);
			}
			result.surfaceLevel = num;
			result.terrainHeight = num2;
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static WaterInfo GetWaterInfo(Bounds bounds, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterInfo", 0);
		try
		{
			WaterInfo result = default(WaterInfo);
			float num = GetWaterLevel(((Bounds)(ref bounds)).center, waves);
			float num2 = (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap) ? TerrainMeta.HeightMap.GetHeight(((Bounds)(ref bounds)).center) : 0f);
			result.isValid = true;
			if (((Bounds)(ref bounds)).min.y > num)
			{
				result.isValid = false;
			}
			else if (((Bounds)(ref bounds)).max.y < num2 - 1f)
			{
				result.isValid = false;
			}
			if (!result.isValid && volumes)
			{
				result = GetWaterInfoFromVolumes(bounds, forEntity);
				if (result.isValid)
				{
					num = result.surfaceLevel;
				}
			}
			if (result.isValid && Object.op_Implicit((Object)(object)WaterSystem.Collision) && WaterSystem.Collision.GetIgnore(bounds))
			{
				result.isValid = false;
				num = -1000f;
			}
			result.currentDepth = Mathf.Max(0f, num - ((Bounds)(ref bounds)).min.y);
			result.overallDepth = Mathf.Max(0f, num - num2);
			result.surfaceLevel = num;
			result.terrainHeight = num2;
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void InitInternalState(int initCap)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		DisposeInternalState();
		CounterRef = new NativeReference<int>(AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)0);
		Centers = new NativeArray<Vector3>(initCap, (Allocator)4, (NativeArrayOptions)0);
		WaterHeights = new NativeArray<float>(initCap, (Allocator)4, (NativeArrayOptions)0);
		TerrainHeights = new NativeArray<float>(initCap, (Allocator)4, (NativeArrayOptions)0);
		Indices = new NativeArray<int>(initCap, (Allocator)4, (NativeArrayOptions)0);
		GetIgnoreResults = new NativeArray<bool>(initCap, (Allocator)4, (NativeArrayOptions)0);
		GetIgnoreHeadStarts = new NativeArray<Vector3>(initCap, (Allocator)4, (NativeArrayOptions)0);
		GetIgnoreHeadRadii = new NativeArray<float>(initCap, (Allocator)4, (NativeArrayOptions)0);
		UVs = new NativeArray<Vector2>(initCap, (Allocator)4, (NativeArrayOptions)0);
		Topologies = new NativeArray<int>(initCap, (Allocator)4, (NativeArrayOptions)0);
		ShoreDists = new NativeArray<float>(initCap, (Allocator)4, (NativeArrayOptions)0);
		WaveHeights = new NativeArray<float>(initCap, (Allocator)4, (NativeArrayOptions)0);
	}

	public static void DisposeInternalState()
	{
		NativeReferenceEx.SafeDispose(ref CounterRef);
		Centers.SafeDispose<Vector3>();
		NativeArrayEx.SafeDispose(ref WaterHeights);
		NativeArrayEx.SafeDispose(ref TerrainHeights);
		NativeArrayEx.SafeDispose(ref Indices);
		NativeArrayEx.SafeDispose(ref GetIgnoreResults);
		GetIgnoreHeadStarts.SafeDispose<Vector3>();
		NativeArrayEx.SafeDispose(ref GetIgnoreHeadRadii);
		UVs.SafeDispose<Vector2>();
		NativeArrayEx.SafeDispose(ref Topologies);
		NativeArrayEx.SafeDispose(ref ShoreDists);
		NativeArrayEx.SafeDispose(ref WaveHeights);
	}

	public static void GetWaterInfos(ReadOnly<Vector3> starts, ReadOnly<Vector3> ends, ReadOnly<float> radii, ReadOnlySpan<BaseEntity> entities, ReadOnly<int> indices, bool waves, bool volumes, NativeArray<WaterInfo> results)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_043a: Unknown result type (might be due to invalid IL or missing references)
		//IL_043c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0443: Unknown result type (might be due to invalid IL or missing references)
		//IL_0444: Unknown result type (might be due to invalid IL or missing references)
		//IL_044b: Unknown result type (might be due to invalid IL or missing references)
		//IL_044c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0453: Unknown result type (might be due to invalid IL or missing references)
		//IL_0454: Unknown result type (might be due to invalid IL or missing references)
		//IL_0460: Unknown result type (might be due to invalid IL or missing references)
		//IL_0465: Unknown result type (might be due to invalid IL or missing references)
		//IL_0471: Unknown result type (might be due to invalid IL or missing references)
		//IL_0476: Unknown result type (might be due to invalid IL or missing references)
		//IL_047d: Unknown result type (might be due to invalid IL or missing references)
		//IL_047f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		//IL_02af: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_030a: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0316: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0333: Unknown result type (might be due to invalid IL or missing references)
		//IL_0334: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0343: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_037d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0382: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0398: Unknown result type (might be due to invalid IL or missing references)
		//IL_039f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f6: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetWaterInfos", 0);
		try
		{
			Centers.Expand<Vector3>(starts.Length, (NativeArrayOptions)0, copyContents: false, usePowerOfTwo: false);
			CalcCenterJobIndirect calcCenterJobIndirect = default(CalcCenterJobIndirect);
			calcCenterJobIndirect.Results = Centers;
			calcCenterJobIndirect.Starts = starts;
			calcCenterJobIndirect.Ends = ends;
			calcCenterJobIndirect.Indices = indices;
			CalcCenterJobIndirect calcCenterJobIndirect2 = calcCenterJobIndirect;
			IJobExtensions.RunByRef<CalcCenterJobIndirect>(ref calcCenterJobIndirect2);
			NativeArrayEx.Expand(ref WaterHeights, starts.Length, (NativeArrayOptions)0, copyContents: false);
			GetWaterLevels(Centers.AsReadOnly(), indices, waves, WaterHeights);
			NativeArrayEx.Expand(ref TerrainHeights, starts.Length, (NativeArrayOptions)0, copyContents: false);
			TerrainMeta.HeightMap?.GetHeightsIndirect(Centers.AsReadOnly(), indices, TerrainHeights);
			NativeArrayEx.Expand(ref Indices, starts.Length, (NativeArrayOptions)0, copyContents: false);
			InitialValidateInfoJobIndirect initialValidateInfoJobIndirect = default(InitialValidateInfoJobIndirect);
			initialValidateInfoJobIndirect.Results = results;
			initialValidateInfoJobIndirect.Starts = starts;
			initialValidateInfoJobIndirect.Ends = ends;
			initialValidateInfoJobIndirect.Radii = radii;
			initialValidateInfoJobIndirect.WaterHeights = WaterHeights.AsReadOnly();
			initialValidateInfoJobIndirect.TerrainHeights = TerrainHeights.AsReadOnly();
			initialValidateInfoJobIndirect.Indices = indices;
			InitialValidateInfoJobIndirect initialValidateInfoJobIndirect2 = initialValidateInfoJobIndirect;
			IJobExtensions.RunByRef<InitialValidateInfoJobIndirect>(ref initialValidateInfoJobIndirect2);
			if (volumes)
			{
				TimeWarning val2 = TimeWarning.New("WaterTestFromVolumes", 0);
				try
				{
					GatherInvalidInfosJobIndirect gatherInvalidInfosJobIndirect = default(GatherInvalidInfosJobIndirect);
					gatherInvalidInfosJobIndirect.InvalidIndices = Indices;
					gatherInvalidInfosJobIndirect.InvalidIndexCount = CounterRef;
					gatherInvalidInfosJobIndirect.Infos = results.AsReadOnly();
					gatherInvalidInfosJobIndirect.Indices = indices;
					GatherInvalidInfosJobIndirect gatherInvalidInfosJobIndirect2 = gatherInvalidInfosJobIndirect;
					IJobExtensions.RunByRef<GatherInvalidInfosJobIndirect>(ref gatherInvalidInfosJobIndirect2);
					int value = CounterRef.Value;
					if (value > 0)
					{
						NativeArray<int> subArray = Indices.GetSubArray(0, value);
						BaseEntity.WaterTestFromVolumesIndirect(entities, ReadOnly<Vector3>.op_Implicit(ref starts), ReadOnly<Vector3>.op_Implicit(ref ends), ReadOnly<float>.op_Implicit(ref radii), NativeArray<int>.op_Implicit(ref subArray), NativeArray<WaterInfo>.op_Implicit(ref results));
						UpdateWaterHeightsJobIndirect updateWaterHeightsJobIndirect = default(UpdateWaterHeightsJobIndirect);
						updateWaterHeightsJobIndirect.WaterHeights = WaterHeights;
						updateWaterHeightsJobIndirect.Infos = results;
						updateWaterHeightsJobIndirect.Indices = subArray;
						UpdateWaterHeightsJobIndirect updateWaterHeightsJobIndirect2 = updateWaterHeightsJobIndirect;
						IJobExtensions.RunByRef<UpdateWaterHeightsJobIndirect>(ref updateWaterHeightsJobIndirect2);
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			if (Object.op_Implicit((Object)(object)WaterSystem.Collision))
			{
				TimeWarning val3 = TimeWarning.New("WaterSystem.Collision", 0);
				try
				{
					GatherValidInfosJobIndirect gatherValidInfosJobIndirect = default(GatherValidInfosJobIndirect);
					gatherValidInfosJobIndirect.ValidIndices = Indices;
					gatherValidInfosJobIndirect.ValidIndexCount = CounterRef;
					gatherValidInfosJobIndirect.Infos = results.AsReadOnly();
					gatherValidInfosJobIndirect.Indices = indices;
					GatherValidInfosJobIndirect gatherValidInfosJobIndirect2 = gatherValidInfosJobIndirect;
					IJobExtensions.RunByRef<GatherValidInfosJobIndirect>(ref gatherValidInfosJobIndirect2);
					int value2 = CounterRef.Value;
					if (value2 > 0)
					{
						TimeWarning val4 = TimeWarning.New("WaterSystem.Collision.Entity", 0);
						try
						{
							NativeArray<int> subArray2 = Indices.GetSubArray(0, value2);
							NativeArrayEx.Expand(ref GetIgnoreResults, starts.Length, (NativeArrayOptions)0, copyContents: false);
							WaterSystem.Collision.GetIgnoreIndirect(starts, ends, radii, subArray2.AsReadOnly(), GetIgnoreResults);
							GetIgnoreHeadStarts.Expand<Vector3>(starts.Length, (NativeArrayOptions)0, copyContents: false, usePowerOfTwo: false);
							NativeArrayEx.Expand(ref GetIgnoreHeadRadii, starts.Length, (NativeArrayOptions)0, copyContents: false);
							SetupHeadQueryJobIndirect setupHeadQueryJobIndirect = default(SetupHeadQueryJobIndirect);
							setupHeadQueryJobIndirect.Indices = subArray2;
							setupHeadQueryJobIndirect.QueryIndexCount = CounterRef;
							setupHeadQueryJobIndirect.QueryStarts = GetIgnoreHeadStarts;
							setupHeadQueryJobIndirect.QueryRadii = GetIgnoreHeadRadii;
							setupHeadQueryJobIndirect.ValidInfos = GetIgnoreResults.AsReadOnly();
							setupHeadQueryJobIndirect.Starts = starts;
							setupHeadQueryJobIndirect.Ends = ends;
							setupHeadQueryJobIndirect.Radii = radii;
							SetupHeadQueryJobIndirect setupHeadQueryJobIndirect2 = setupHeadQueryJobIndirect;
							IJobExtensions.RunByRef<SetupHeadQueryJobIndirect>(ref setupHeadQueryJobIndirect2);
							int value3 = CounterRef.Value;
							if (value3 > 0)
							{
								TimeWarning val5 = TimeWarning.New("WaterSystem.Collision.Head", 0);
								try
								{
									NativeArray<int> subArray3 = Indices.GetSubArray(0, value3);
									WaterSystem.Collision.GetIgnoreIndirect(GetIgnoreHeadStarts.AsReadOnly(), GetIgnoreHeadRadii.AsReadOnly(), subArray3.AsReadOnly(), GetIgnoreResults);
									ApplyHeadQueryResultsJobIndirect applyHeadQueryResultsJobIndirect = default(ApplyHeadQueryResultsJobIndirect);
									applyHeadQueryResultsJobIndirect.WaterHeights = WaterHeights;
									applyHeadQueryResultsJobIndirect.Infos = results;
									applyHeadQueryResultsJobIndirect.Indices = subArray3.AsReadOnly();
									applyHeadQueryResultsJobIndirect.ValidInfos = GetIgnoreResults.AsReadOnly();
									applyHeadQueryResultsJobIndirect.Starts = GetIgnoreHeadStarts.AsReadOnly();
									ApplyHeadQueryResultsJobIndirect applyHeadQueryResultsJobIndirect2 = applyHeadQueryResultsJobIndirect;
									IJobExtensions.RunByRef<ApplyHeadQueryResultsJobIndirect>(ref applyHeadQueryResultsJobIndirect2);
								}
								finally
								{
									((IDisposable)val5)?.Dispose();
								}
							}
						}
						finally
						{
							((IDisposable)val4)?.Dispose();
						}
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
			ResolveWaterInfosJobIndirect resolveWaterInfosJobIndirect = default(ResolveWaterInfosJobIndirect);
			resolveWaterInfosJobIndirect.Infos = results;
			resolveWaterInfosJobIndirect.Starts = starts;
			resolveWaterInfosJobIndirect.Ends = ends;
			resolveWaterInfosJobIndirect.Radii = radii;
			resolveWaterInfosJobIndirect.WaterHeights = WaterHeights.AsReadOnly();
			resolveWaterInfosJobIndirect.TerrainHeights = TerrainHeights.AsReadOnly();
			resolveWaterInfosJobIndirect.Indices = indices;
			ResolveWaterInfosJobIndirect resolveWaterInfosJobIndirect2 = resolveWaterInfosJobIndirect;
			IJobExtensions.RunByRef<ResolveWaterInfosJobIndirect>(ref resolveWaterInfosJobIndirect2);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static WaterInfo GetWaterInfo(Vector3 start, Vector3 end, float radius, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterInfo", 0);
		try
		{
			WaterInfo result = default(WaterInfo);
			Vector3 val2 = (start + end) * 0.5f;
			float num = Mathf.Min(start.y, end.y) - radius;
			float num2 = Mathf.Max(start.y, end.y) + radius;
			float num3 = GetWaterLevel(val2, waves);
			float num4 = (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap) ? TerrainMeta.HeightMap.GetHeight(val2) : 0f);
			result.isValid = true;
			if (num > num3)
			{
				result.isValid = false;
			}
			else if (num2 < num4 - 1f)
			{
				result.isValid = false;
			}
			if (!result.isValid && volumes)
			{
				result = GetWaterInfoFromVolumes(start, end, radius, forEntity);
				if (result.isValid)
				{
					num3 = result.surfaceLevel;
				}
			}
			if (result.isValid && Object.op_Implicit((Object)(object)WaterSystem.Collision) && WaterSystem.Collision.GetIgnore(start, end, radius))
			{
				Vector3 val3 = Vector3Ex.WithY(val2, Mathf.Lerp(num, num2, 0.75f));
				if (!WaterSystem.Collision.GetIgnore(val3))
				{
					num3 = Mathf.Min(num3, val3.y);
				}
				else
				{
					result.isValid = false;
					num3 = -1000f;
				}
			}
			result.currentDepth = Mathf.Max(0f, num3 - num);
			result.overallDepth = Mathf.Max(0f, num3 - num4);
			result.surfaceLevel = num3;
			result.terrainHeight = num4;
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static WaterInfo GetWaterInfo(Camera cam, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterInfo", 0);
		try
		{
			waves = waves && (Object)(object)WaterSystem.Instance != (Object)null;
			float num = WaterSystem.OceanLevel;
			if (waves)
			{
				num += WaterSystem.Instance.oceanSimulation.MinLevel();
			}
			if (((Component)cam).transform.position.y < num - 1f)
			{
				return GetWaterInfo(((Component)cam).transform.position, waves, volumes, forEntity);
			}
			return GetWaterInfo(((Component)cam).transform.position - Vector3.up, waves, volumes, forEntity);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float GetWaterLevel(Vector3 pos, bool waves)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		waves = waves && (Object)(object)WaterSystem.Instance != (Object)null;
		float normX = TerrainMeta.NormalizeX(pos.x);
		float normZ = TerrainMeta.NormalizeZ(pos.z);
		float num = (Object.op_Implicit((Object)(object)TerrainMeta.WaterMap) ? TerrainMeta.WaterMap.GetHeight(normX, normZ) : TerrainMeta.Position.y);
		float num2 = WaterSystem.OceanLevel;
		if (waves)
		{
			num2 += WaterSystem.Instance.oceanSimulation.MaxLevel();
		}
		if (num < num2 && (!Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap) || TerrainMeta.TopologyMap.GetTopology(normX, normZ, 384)))
		{
			float num3 = WaterSystem.OceanLevel;
			if (waves)
			{
				num3 += WaterSystem.Instance.oceanSimulation.GetHeight(pos);
			}
			return Mathf.Max(num, num3);
		}
		return num;
	}

	public static float RaycastWaterColliders(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (!Physics.Raycast(Vector3Ex.WithY(pos, TerrainMeta.Max.y), Vector3.down, ref val, TerrainMeta.Size.y, 16, (QueryTriggerInteraction)2))
		{
			return WaterSystem.OceanLevel;
		}
		return ((RaycastHit)(ref val)).point.y;
	}

	public static void GetWaterLevels(ReadOnly<Vector3> positions, ReadOnly<int> indices, bool waves, NativeArray<float> heights)
	{
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_0346: Unknown result type (might be due to invalid IL or missing references)
		//IL_034c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0356: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_037e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0383: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_038c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevels", 0);
		try
		{
			waves = waves && (Object)(object)WaterSystem.Instance != (Object)null;
			float num = WaterSystem.OceanLevel;
			if (waves)
			{
				num += WaterSystem.Instance.oceanSimulation.MaxLevel();
			}
			UVs.Expand<Vector2>(positions.Length, (NativeArrayOptions)0, copyContents: false, usePowerOfTwo: false);
			NativeArray<Vector2> subArray = UVs.GetSubArray(0, positions.Length);
			ToUVJobIndirect toUVJobIndirect = default(ToUVJobIndirect);
			toUVJobIndirect.UV = subArray;
			toUVJobIndirect.Pos = positions;
			toUVJobIndirect.Indices = indices;
			toUVJobIndirect.TerrainPos = Vector3Ex.XZ2D(TerrainMeta.Position);
			toUVJobIndirect.TerrainOneOverSize = Vector3Ex.XZ2D(TerrainMeta.OneOverSize);
			ToUVJobIndirect toUVJobIndirect2 = toUVJobIndirect;
			IJobExtensions.RunByRef<ToUVJobIndirect>(ref toUVJobIndirect2);
			if (Object.op_Implicit((Object)(object)TerrainMeta.WaterMap))
			{
				TerrainMeta.WaterMap.GetHeightsIndirect(subArray.AsReadOnly(), indices, heights);
			}
			else
			{
				FillJob<float> fillJob = default(FillJob<float>);
				fillJob.Values = heights;
				fillJob.Value = TerrainMeta.Position.y;
				FillJob<float> fillJob2 = fillJob;
				IJobExtensions.RunByRef<FillJob<float>>(ref fillJob2);
			}
			NativeArrayEx.Expand(ref Topologies, positions.Length, (NativeArrayOptions)0, copyContents: false);
			NativeArray<int> subArray2 = Topologies.GetSubArray(0, positions.Length);
			if (Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap))
			{
				TerrainMeta.TopologyMap.GetTopologiesIndirect(subArray.AsReadOnly(), indices, subArray2);
			}
			else
			{
				FillJob<int> fillJob3 = default(FillJob<int>);
				fillJob3.Values = subArray2;
				fillJob3.Value = 384;
				FillJob<int> fillJob4 = fillJob3;
				IJobExtensions.RunByRef<FillJob<int>>(ref fillJob4);
			}
			if (!waves)
			{
				ApplyMaxHeightsJobIndirect applyMaxHeightsJobIndirect = default(ApplyMaxHeightsJobIndirect);
				applyMaxHeightsJobIndirect.Heights = heights;
				applyMaxHeightsJobIndirect.Topologies = subArray2.AsReadOnly();
				applyMaxHeightsJobIndirect.Indices = indices;
				applyMaxHeightsJobIndirect.WaterLevel = num;
				applyMaxHeightsJobIndirect.OceanLevel = WaterSystem.OceanLevel;
				ApplyMaxHeightsJobIndirect applyMaxHeightsJobIndirect2 = applyMaxHeightsJobIndirect;
				IJobExtensions.RunByRef<ApplyMaxHeightsJobIndirect>(ref applyMaxHeightsJobIndirect2);
				return;
			}
			NativeArrayEx.Expand(ref Indices, positions.Length, (NativeArrayOptions)0, copyContents: false);
			GatherWavesIndicesJobIndirect gatherWavesIndicesJobIndirect = default(GatherWavesIndicesJobIndirect);
			gatherWavesIndicesJobIndirect.WaveIndices = Indices;
			gatherWavesIndicesJobIndirect.WaveIndexCount = CounterRef;
			gatherWavesIndicesJobIndirect.Topologies = subArray2.AsReadOnly();
			gatherWavesIndicesJobIndirect.Heights = heights.AsReadOnly();
			gatherWavesIndicesJobIndirect.Indices = indices;
			gatherWavesIndicesJobIndirect.WaterLevel = num;
			GatherWavesIndicesJobIndirect gatherWavesIndicesJobIndirect2 = gatherWavesIndicesJobIndirect;
			IJobExtensions.RunByRef<GatherWavesIndicesJobIndirect>(ref gatherWavesIndicesJobIndirect2);
			int value = CounterRef.Value;
			if (value == 0)
			{
				return;
			}
			TimeWarning val2 = TimeWarning.New("Waves", 0);
			try
			{
				NativeArrayEx.Expand(ref TerrainHeights, positions.Length, (NativeArrayOptions)0, copyContents: false);
				NativeArrayEx.Expand(ref ShoreDists, positions.Length, (NativeArrayOptions)0, copyContents: false);
				NativeArrayEx.Expand(ref WaveHeights, positions.Length, (NativeArrayOptions)0, copyContents: false);
				ReadOnly<int> indices2 = Indices.GetSubArray(0, value).AsReadOnly();
				if (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap))
				{
					TerrainMeta.HeightMap.GetHeightsFastIndirect(subArray.AsReadOnly(), indices2, TerrainHeights);
				}
				else
				{
					FillJob<float> fillJob = default(FillJob<float>);
					fillJob.Values = TerrainHeights;
					fillJob.Value = 0f;
					FillJob<float> fillJob5 = fillJob;
					IJobExtensions.RunByRef<FillJob<float>>(ref fillJob5);
				}
				if (Object.op_Implicit((Object)(object)TerrainTexturing.Instance))
				{
					TerrainTexturing.Instance.GetCoarseDistancesToShoreIndirect(subArray.AsReadOnly(), indices2, ShoreDists);
				}
				else
				{
					FillJob<float> fillJob = default(FillJob<float>);
					fillJob.Values = ShoreDists;
					fillJob.Value = 0f;
					FillJob<float> fillJob6 = fillJob;
					IJobExtensions.RunByRef<FillJob<float>>(ref fillJob6);
				}
				WaterSystem.Instance.oceanSimulation.GetHeightsIndirect(positions, ShoreDists.AsReadOnly(), TerrainHeights.AsReadOnly(), indices2, WaveHeights);
				SelectMaxWaterLevelJobIndirect selectMaxWaterLevelJobIndirect = default(SelectMaxWaterLevelJobIndirect);
				selectMaxWaterLevelJobIndirect.Heights = heights;
				selectMaxWaterLevelJobIndirect.DynamicHeights = WaveHeights.AsReadOnly();
				selectMaxWaterLevelJobIndirect.Indices = indices2;
				selectMaxWaterLevelJobIndirect.OceanLevel = WaterSystem.OceanLevel;
				SelectMaxWaterLevelJobIndirect selectMaxWaterLevelJobIndirect2 = selectMaxWaterLevelJobIndirect;
				IJobExtensions.RunByRef<SelectMaxWaterLevelJobIndirect>(ref selectMaxWaterLevelJobIndirect2);
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static WaterInfo GetWaterInfoFromVolumes(Bounds bounds, BaseEntity forEntity)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		WaterInfo info = default(WaterInfo);
		if ((Object)(object)forEntity == (Object)null)
		{
			List<WaterVolume> list = Pool.Get<List<WaterVolume>>();
			Vis.Components<WaterVolume>(new OBB(bounds), list, 262144, (QueryTriggerInteraction)2);
			using (List<WaterVolume>.Enumerator enumerator = list.GetEnumerator())
			{
				while (enumerator.MoveNext() && !enumerator.Current.Test(bounds, out info))
				{
				}
			}
			Pool.FreeUnmanaged<WaterVolume>(ref list);
			return info;
		}
		forEntity.WaterTestFromVolumes(bounds, out info);
		return info;
	}

	private static WaterInfo GetWaterInfoFromVolumes(Vector3 pos, BaseEntity forEntity)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		WaterInfo info = default(WaterInfo);
		if ((Object)(object)forEntity == (Object)null)
		{
			List<WaterVolume> list = Pool.Get<List<WaterVolume>>();
			Vis.Components<WaterVolume>(pos, 0.1f, list, 262144, (QueryTriggerInteraction)2);
			foreach (WaterVolume item in list)
			{
				if (item.Test(pos, out info))
				{
					info.artificalWater = !item.naturalSource;
					break;
				}
			}
			Pool.FreeUnmanaged<WaterVolume>(ref list);
			return info;
		}
		forEntity.WaterTestFromVolumes(pos, out info);
		return info;
	}

	private static WaterInfo GetWaterInfoFromVolumes(Vector3 start, Vector3 end, float radius, BaseEntity forEntity)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		WaterInfo info = default(WaterInfo);
		if ((Object)(object)forEntity == (Object)null)
		{
			List<WaterVolume> list = Pool.Get<List<WaterVolume>>();
			Vis.Components<WaterVolume>(start, end, radius, list, 262144, (QueryTriggerInteraction)2);
			using (List<WaterVolume>.Enumerator enumerator = list.GetEnumerator())
			{
				while (enumerator.MoveNext() && !enumerator.Current.Test(start, end, radius, out info))
				{
				}
			}
			Pool.FreeUnmanaged<WaterVolume>(ref list);
			return info;
		}
		forEntity.WaterTestFromVolumes(start, end, radius, out info);
		return info;
	}

	public static WaterInfo InitialValidate(Vector3 start, Vector3 end, float radius, float waterHeight, float terrainHeight)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		WaterInfo result = default(WaterInfo);
		result.isValid = true;
		float num = Mathf.Min(start.y, end.y) - radius;
		float num2 = Mathf.Max(start.y, end.y) + radius;
		if (num > waterHeight)
		{
			result.isValid = false;
		}
		else if (num2 < terrainHeight - 1f)
		{
			result.isValid = false;
		}
		return result;
	}
}


public struct WaterInfo
{
	public bool isValid;

	public float currentDepth;

	public float overallDepth;

	public float surfaceLevel;

	public float terrainHeight;

	public bool artificalWater;

	public int topology;
}


using UnityEngine;

public class WaterResource
{
	public static ItemDefinition SV_GetAtPoint(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (IsRadioactive(pos))
		{
			return WaterTypes.RadioactiveWaterItemDef;
		}
		if (!IsFreshWater(pos))
		{
			return WaterTypes.SaltWaterItemDef;
		}
		return WaterTypes.WaterItemDef;
	}

	public static WaterBody FindWaterBodyAtPos(Vector3 pos)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		float num = 1.5f;
		RaycastHit hitInfo;
		bool num2 = GamePhysics.Trace(new Ray(pos + Vector3.up * num, Vector3.down), 0f, out hitInfo, 3f, 16, (QueryTriggerInteraction)0);
		WaterBody result = null;
		if (num2)
		{
			result = hitInfo.GetWaterBody();
		}
		return result;
	}

	public static bool IsRadioactive(WaterBody body)
	{
		return body.Type == WaterBodyType.Radioactive;
	}

	public static bool IsRadioactive(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		WaterBody waterBody = FindWaterBodyAtPos(pos);
		if (Object.op_Implicit((Object)(object)waterBody))
		{
			return waterBody.Type == WaterBodyType.Radioactive;
		}
		return false;
	}

	public static bool IsFreshWater(Vector3 pos)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.TopologyMap == (Object)null)
		{
			return false;
		}
		return TerrainMeta.TopologyMap.GetTopology(pos, 245760);
	}

	public static ItemDefinition Merge(ItemDefinition first, ItemDefinition second)
	{
		if ((Object)(object)first == (Object)(object)second)
		{
			return first;
		}
		if ((Object)(object)first == (Object)(object)WaterTypes.RadioactiveWaterItemDef || (Object)(object)second == (Object)(object)WaterTypes.RadioactiveWaterItemDef)
		{
			return WaterTypes.RadioactiveWaterItemDef;
		}
		if ((Object)(object)first == (Object)(object)WaterTypes.SaltWaterItemDef || (Object)(object)second == (Object)(object)WaterTypes.SaltWaterItemDef)
		{
			return WaterTypes.SaltWaterItemDef;
		}
		return WaterTypes.WaterItemDef;
	}
}


using UnityEngine;

public static class WaterTypes
{
	private static ItemDefinition _waterItemDef;

	private static ItemDefinition _saltWaterItemDef;

	private static ItemDefinition _radioactiveWaterItemDef;

	public static ItemDefinition WaterItemDef
	{
		get
		{
			if ((Object)(object)_waterItemDef == (Object)null)
			{
				_waterItemDef = ItemManager.FindItemDefinition("water");
			}
			return _waterItemDef;
		}
	}

	public static ItemDefinition SaltWaterItemDef
	{
		get
		{
			if ((Object)(object)_saltWaterItemDef == (Object)null)
			{
				_saltWaterItemDef = ItemManager.FindItemDefinition("water.salt");
			}
			return _saltWaterItemDef;
		}
	}

	public static ItemDefinition RadioactiveWaterItemDef
	{
		get
		{
			if ((Object)(object)_radioactiveWaterItemDef == (Object)null)
			{
				_radioactiveWaterItemDef = ItemManager.FindItemDefinition("water.radioactive");
			}
			return _radioactiveWaterItemDef;
		}
	}
}


using UnityEngine;

public class WaterVolume : TriggerBase
{
	public Bounds WaterBounds = new Bounds(Vector3.zero, Vector3.one);

	private OBB cachedBounds;

	private Transform cachedTransform;

	public Transform[] cutOffPlanes = (Transform[])(object)new Transform[0];

	[Tooltip("Allows filling bota bags, jugs, etc. Don't turn this on if the player is responsible for filling this water volume as that will allow water duplication")]
	public bool naturalSource;

	public bool waterEnabled = true;

	private void OnEnable()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		cachedTransform = ((Component)this).transform;
		cachedBounds = new OBB(cachedTransform, WaterBounds);
	}

	private Plane GetWaterPlane()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		return new Plane(cachedBounds.up, cachedBounds.position);
	}

	public bool Test(Vector3 pos, out WaterLevel.WaterInfo info)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		if (!waterEnabled)
		{
			info = default(WaterLevel.WaterInfo);
			return false;
		}
		UpdateCachedTransform();
		if (((OBB)(ref cachedBounds)).Contains(pos))
		{
			if (!CheckCutOffPlanes(pos, out var bottomCutY))
			{
				info = default(WaterLevel.WaterInfo);
				return false;
			}
			Plane waterPlane = GetWaterPlane();
			Vector3 val = ((Plane)(ref waterPlane)).ClosestPointOnPlane(pos);
			float y = (val + cachedBounds.up * cachedBounds.extents.y).y;
			float y2 = (val + -cachedBounds.up * cachedBounds.extents.y).y;
			y2 = Mathf.Max(y2, bottomCutY);
			info = default(WaterLevel.WaterInfo);
			info.isValid = true;
			info.currentDepth = Mathf.Max(0f, y - pos.y);
			info.overallDepth = Mathf.Max(0f, y - y2);
			info.surfaceLevel = y;
			return true;
		}
		info = default(WaterLevel.WaterInfo);
		return false;
	}

	public bool Test(Bounds bounds, out WaterLevel.WaterInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		if (!waterEnabled)
		{
			info = default(WaterLevel.WaterInfo);
			return false;
		}
		UpdateCachedTransform();
		if (((OBB)(ref cachedBounds)).Contains(((Bounds)(ref bounds)).ClosestPoint(cachedBounds.position)))
		{
			if (!CheckCutOffPlanes(((Bounds)(ref bounds)).center, out var bottomCutY))
			{
				info = default(WaterLevel.WaterInfo);
				return false;
			}
			Plane waterPlane = GetWaterPlane();
			Vector3 val = ((Plane)(ref waterPlane)).ClosestPointOnPlane(((Bounds)(ref bounds)).center);
			float y = (val + cachedBounds.up * cachedBounds.extents.y).y;
			float y2 = (val + -cachedBounds.up * cachedBounds.extents.y).y;
			y2 = Mathf.Max(y2, bottomCutY);
			info = default(WaterLevel.WaterInfo);
			info.isValid = true;
			info.currentDepth = Mathf.Max(0f, y - ((Bounds)(ref bounds)).min.y);
			info.overallDepth = Mathf.Max(0f, y - y2);
			info.surfaceLevel = y;
			return true;
		}
		info = default(WaterLevel.WaterInfo);
		return false;
	}

	public bool Test(Vector3 start, Vector3 end, float radius, out WaterLevel.WaterInfo info)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		if (!waterEnabled)
		{
			info = default(WaterLevel.WaterInfo);
			return false;
		}
		UpdateCachedTransform();
		Vector3 val = (start + end) * 0.5f;
		float num = Mathf.Min(start.y, end.y) - radius;
		if (((OBB)(ref cachedBounds)).Distance(start) < radius || ((OBB)(ref cachedBounds)).Distance(end) < radius)
		{
			if (!CheckCutOffPlanes(val, out var bottomCutY))
			{
				info = default(WaterLevel.WaterInfo);
				return false;
			}
			Plane waterPlane = GetWaterPlane();
			Vector3 val2 = ((Plane)(ref waterPlane)).ClosestPointOnPlane(val);
			float y = (val2 + cachedBounds.up * cachedBounds.extents.y).y;
			float y2 = (val2 + -cachedBounds.up * cachedBounds.extents.y).y;
			y2 = Mathf.Max(y2, bottomCutY);
			info = default(WaterLevel.WaterInfo);
			info.isValid = true;
			info.currentDepth = Mathf.Max(0f, y - num);
			info.overallDepth = Mathf.Max(0f, y - y2);
			info.surfaceLevel = y;
			return true;
		}
		info = default(WaterLevel.WaterInfo);
		return false;
	}

	private bool CheckCutOffPlanes(Vector3 pos, out float bottomCutY)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		int num = cutOffPlanes.Length;
		bottomCutY = float.MaxValue;
		bool flag = true;
		for (int i = 0; i < num; i++)
		{
			if ((Object)(object)cutOffPlanes[i] != (Object)null)
			{
				Vector3 val = cutOffPlanes[i].InverseTransformPoint(pos);
				Vector3 position = cutOffPlanes[i].position;
				if (Vector3.Dot(cutOffPlanes[i].up, cachedBounds.up) < -0.1f)
				{
					bottomCutY = Mathf.Min(bottomCutY, position.y);
				}
				if (val.y > 0f)
				{
					flag = false;
					break;
				}
			}
		}
		if (!flag)
		{
			return false;
		}
		return true;
	}

	private void UpdateCachedTransform()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)cachedTransform != (Object)null && cachedTransform.hasChanged)
		{
			cachedBounds = new OBB(cachedTransform, WaterBounds);
			cachedTransform.hasChanged = false;
		}
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using UnityEngine;

public class Wearable : MonoBehaviour, IItemSetup, IPrefabPreProcess
{
	[Flags]
	public enum RemoveSkin
	{
		Torso = 1,
		Feet = 2,
		Hands = 4,
		Legs = 8,
		Head = 0x10
	}

	[Flags]
	public enum RemoveHair
	{
		Head = 1,
		Eyebrow = 2,
		Facial = 4,
		Armpit = 8,
		Pubic = 0x10
	}

	[Flags]
	public enum DeformHair
	{
		None = 0,
		BaseballCap = 1,
		BoonieHat = 2,
		CandleHat = 3,
		MinersHat = 4,
		WoodHelmet = 5
	}

	[Flags]
	public enum OccupationSlots
	{
		HeadTop = 1,
		Face = 2,
		HeadBack = 4,
		TorsoFront = 8,
		TorsoBack = 0x10,
		LeftShoulder = 0x20,
		RightShoulder = 0x40,
		LeftArm = 0x80,
		RightArm = 0x100,
		LeftHand = 0x200,
		RightHand = 0x400,
		Groin = 0x800,
		Bum = 0x1000,
		LeftKnee = 0x2000,
		RightKnee = 0x4000,
		LeftLeg = 0x8000,
		RightLeg = 0x10000,
		LeftFoot = 0x20000,
		RightFoot = 0x40000,
		Mouth = 0x80000,
		Eyes = 0x100000,
		Back = 0x200000
	}

	[Serializable]
	public struct PartRandomizer
	{
		public PartCollection[] groups;
	}

	[Serializable]
	public struct PartCollection
	{
		public GameObject[] parts;
	}

	[InspectorFlags]
	public RemoveSkin removeSkin;

	[InspectorFlags]
	public RemoveSkin removeSkinFirstPerson;

	[InspectorFlags]
	public RemoveHair removeHair;

	[InspectorFlags]
	public DeformHair deformHair;

	[InspectorFlags]
	public OccupationSlots occupationUnder;

	[InspectorFlags]
	public OccupationSlots occupationOver;

	[InspectorFlags]
	public OccupationSlots stripOccupation;

	public bool IsBackpack;

	public bool HideInPlayerPreview;

	public bool OnlyShowOnPlayerPreview;

	public bool showCensorshipCube;

	public bool showCensorshipCubeBreasts;

	public bool forceHideCensorshipBreasts;

	public string followBone;

	public bool disableRigStripping;

	public bool overrideDownLimit;

	public float downLimit = 70f;

	[NonSerialized]
	public bool hasClothingUnderNotifier;

	[Range(0f, 1f)]
	public float handcuffsSize;

	[HideInInspector]
	public PlayerModelHair playerModelHair;

	[HideInInspector]
	public PlayerModelHairCap playerModelHairCap;

	[HideInInspector]
	public WearableReplacementByRace wearableReplacementByRace;

	[HideInInspector]
	public WearableShadowLod wearableShadowLod;

	[HideInInspector]
	public List<Renderer> renderers = new List<Renderer>();

	[HideInInspector]
	public List<PlayerModelSkin> playerModelSkins = new List<PlayerModelSkin>();

	[HideInInspector]
	public List<BoneRetarget> boneRetargets = new List<BoneRetarget>();

	[HideInInspector]
	public List<SkinnedMeshRenderer> skinnedRenderers = new List<SkinnedMeshRenderer>();

	[HideInInspector]
	public List<SkeletonSkin> skeletonSkins = new List<SkeletonSkin>();

	[HideInInspector]
	public List<ComponentInfo> componentInfos = new List<ComponentInfo>();

	[HideInInspector]
	public List<WearableNotify> notifies = new List<WearableNotify>();

	public bool HideInEyesView;

	[Header("First Person Legs")]
	[Tooltip("If this is true, we'll hide this item in the first person view. Usually done for items that you definitely won't see in first person view, like facemasks and hats.")]
	public bool HideInFirstPerson;

	[Range(0f, 5f)]
	[Tooltip("Use this if the clothing item clips into the player view. It'll push the chest legs model backwards.")]
	public float ExtraLeanBack;

	[Tooltip("Enable this to check for BoneRetargets which need to be preserved in first person view")]
	public bool PreserveBones;

	public bool LegFade;

	public Renderer[] RenderersLod0;

	public Renderer[] RenderersLod1;

	public Renderer[] RenderersLod2;

	public Renderer[] RenderersLod3;

	public Renderer[] RenderersLod4;

	public Renderer[] SkipInFirstPersonLegs;

	private static LOD[] emptyLOD = (LOD[])(object)new LOD[1];

	public PartRandomizer[] randomParts;

	public bool stripOccupationCollisions => stripOccupation != (OccupationSlots)0;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public void OnItemSetup(Item item)
	{
	}

	public virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		LODGroup[] componentsInChildren = ((Component)this).GetComponentsInChildren<LODGroup>(true);
		foreach (LODGroup val in componentsInChildren)
		{
			val.SetLODs(emptyLOD);
			preProcess.RemoveComponent((Component)(object)val);
		}
	}

	public void CacheComponents()
	{
		playerModelHairCap = ((Component)this).GetComponent<PlayerModelHairCap>();
		playerModelHair = ((Component)this).GetComponent<PlayerModelHair>();
		wearableReplacementByRace = ((Component)this).GetComponent<WearableReplacementByRace>();
		wearableShadowLod = ((Component)this).GetComponent<WearableShadowLod>();
		((Component)this).GetComponentsInChildren<Renderer>(true, renderers);
		((Component)this).GetComponentsInChildren<PlayerModelSkin>(true, playerModelSkins);
		((Component)this).GetComponentsInChildren<BoneRetarget>(true, boneRetargets);
		((Component)this).GetComponentsInChildren<SkinnedMeshRenderer>(true, skinnedRenderers);
		((Component)this).GetComponentsInChildren<SkeletonSkin>(true, skeletonSkins);
		((Component)this).GetComponentsInChildren<ComponentInfo>(true, componentInfos);
		((Component)this).GetComponentsInChildren<WearableNotify>(true, notifies);
		RenderersLod0 = renderers.Where((Renderer x) => ((Object)((Component)x).gameObject).name.EndsWith("0")).ToArray();
		RenderersLod1 = renderers.Where((Renderer x) => ((Object)((Component)x).gameObject).name.EndsWith("1")).ToArray();
		RenderersLod2 = renderers.Where((Renderer x) => ((Object)((Component)x).gameObject).name.EndsWith("2")).ToArray();
		RenderersLod3 = renderers.Where((Renderer x) => ((Object)((Component)x).gameObject).name.EndsWith("3")).ToArray();
		RenderersLod4 = renderers.Where((Renderer x) => ((Object)((Component)x).gameObject).name.EndsWith("4")).ToArray();
		foreach (Renderer renderer in renderers)
		{
			((Component)renderer).gameObject.AddComponent<ObjectMotionVectorFix>();
			renderer.motionVectorGenerationMode = (MotionVectorGenerationMode)2;
		}
	}

	public void StripRig(IPrefabProcessor preProcess, SkinnedMeshRenderer skinnedMeshRenderer)
	{
		if (disableRigStripping)
		{
			return;
		}
		Transform val = skinnedMeshRenderer.FindRig();
		if (!((Object)(object)val != (Object)null))
		{
			return;
		}
		List<Transform> list = Pool.Get<List<Transform>>();
		((Component)val).GetComponentsInChildren<Transform>(list);
		for (int num = list.Count - 1; num >= 0; num--)
		{
			if (preProcess != null)
			{
				preProcess.NominateForDeletion(((Component)list[num]).gameObject);
			}
			else
			{
				Object.DestroyImmediate((Object)(object)((Component)list[num]).gameObject);
			}
		}
		Pool.FreeUnmanaged<Transform>(ref list);
	}

	public void SetupRendererCache(IPrefabProcessor preProcess)
	{
	}
}


using System;

[Flags]
public enum RemoveSkin
{
	Torso = 1,
	Feet = 2,
	Hands = 4,
	Legs = 8,
	Head = 0x10
}


using System;

[Flags]
public enum RemoveHair
{
	Head = 1,
	Eyebrow = 2,
	Facial = 4,
	Armpit = 8,
	Pubic = 0x10
}


using System;

[Flags]
public enum DeformHair
{
	None = 0,
	BaseballCap = 1,
	BoonieHat = 2,
	CandleHat = 3,
	MinersHat = 4,
	WoodHelmet = 5
}


using System;

[Flags]
public enum OccupationSlots
{
	HeadTop = 1,
	Face = 2,
	HeadBack = 4,
	TorsoFront = 8,
	TorsoBack = 0x10,
	LeftShoulder = 0x20,
	RightShoulder = 0x40,
	LeftArm = 0x80,
	RightArm = 0x100,
	LeftHand = 0x200,
	RightHand = 0x400,
	Groin = 0x800,
	Bum = 0x1000,
	LeftKnee = 0x2000,
	RightKnee = 0x4000,
	LeftLeg = 0x8000,
	RightLeg = 0x10000,
	LeftFoot = 0x20000,
	RightFoot = 0x40000,
	Mouth = 0x80000,
	Eyes = 0x100000,
	Back = 0x200000
}


using System;

[Serializable]
public struct PartRandomizer
{
	public PartCollection[] groups;
}


using System;
using UnityEngine;

[Serializable]
public struct PartCollection
{
	public GameObject[] parts;
}


using UnityEngine;

public class WearableEyeViewAdjustment : MonoBehaviour
{
}


using UnityEngine;

public class WearableEyeViewAdjustment_Submesh : WearableEyeViewAdjustment
{
	public int TargetSubmesh;

	public Material HideMaterial;

	public Material DefaultMaterial;
}


using UnityEngine;

public class WearableFadeToggle : MonoBehaviour, IClientComponent
{
}


using System;
using UnityEngine;

public class WearableHolsterOffset : MonoBehaviour
{
	[Serializable]
	public class offsetInfo
	{
		public enum OverrideBone
		{
			None,
			Spine4
		}

		public HeldEntity.HolsterInfo.HolsterSlot type;

		public Vector3 offset;

		public Vector3 rotationOffset;

		public int priority;

		public Vector3 rightBackpackSlotOffset;

		public Vector3 rightBackpackSlotRotationOffset;

		public OverrideBone overrideBone;
	}

	public offsetInfo[] Offsets;
}


using System;
using UnityEngine;

[Serializable]
public class offsetInfo
{
	public enum OverrideBone
	{
		None,
		Spine4
	}

	public HeldEntity.HolsterInfo.HolsterSlot type;

	public Vector3 offset;

	public Vector3 rotationOffset;

	public int priority;

	public Vector3 rightBackpackSlotOffset;

	public Vector3 rightBackpackSlotRotationOffset;

	public OverrideBone overrideBone;
}


public enum OverrideBone
{
	None,
	Spine4
}


using UnityEngine;

public class WearableNotify : MonoBehaviour
{
}


using System.Collections.Generic;
using UnityEngine;

public class WearableNotifyConditionalClothing : WearableNotify
{
	public List<GameObject> MinClothing = new List<GameObject>();

	public List<GameObject> MaxClothing = new List<GameObject>();
}


using UnityEngine;

public class WearableNotifyHasBackpack : WearableNotify
{
	public GameObject[] ObjectsToHide = (GameObject[])(object)new GameObject[0];
}


using UnityEngine.Events;

public class WearableNotifyLifestate : WearableNotify
{
	public BaseCombatEntity.LifeState TargetState;

	public UnityEvent OnTargetState = new UnityEvent();

	public UnityEvent OnTargetStateFailed = new UnityEvent();
}


using Facepunch.BurstCloth;
using UnityEngine;
using UnityEngine.Events;

public class WearableNotifyTrophyMounted : WearableNotify
{
	public UnityEvent OnMounted = new UnityEvent();

	public Renderer[] EmissionToggles;

	public BurstCloth[] BurstCloths;
}


using System;
using UnityEngine;

public class WearableRandomMaterial : MonoBehaviour
{
	[Serializable]
	public struct MaterialOption
	{
		public int Chance;

		public Material ToApply;
	}

	[Serializable]
	public struct TargetRenderer
	{
		public Renderer Renderer;

		public int MaterialIndex;
	}

	public TargetRenderer[] TargetRenderers;

	public MaterialOption[] MaterialOptions;

	public bool RunRandomisation;
}


using System;
using UnityEngine;

[Serializable]
public struct MaterialOption
{
	public int Chance;

	public Material ToApply;
}


using System;
using UnityEngine;

[Serializable]
public struct TargetRenderer
{
	public Renderer Renderer;

	public int MaterialIndex;
}


using UnityEngine;

public class WearableReplacementByRace : MonoBehaviour
{
	public GameObjectRef[] replacements;

	public GameObjectRef GetReplacement(int meshIndex)
	{
		int num = Mathf.Clamp(meshIndex, 0, replacements.Length - 1);
		return replacements[num];
	}
}


using UnityEngine;

public class WearableShadowLod : MonoBehaviour, IClientComponent
{
	public Renderer[] DisableShadows;
}


using UnityEngine;

public abstract class WeatherEffect : BaseMonoBehaviour, IClientComponent
{
	public ParticleSystem[] emitOnStart;

	public ParticleSystem[] emitOnStop;

	public ParticleSystem[] emitOnLoop;
}


public class AuroraEffect : WeatherEffect
{
}


public class RainbowEffect : WeatherEffect
{
}


public class RainEffect : WeatherEffect
{
	public int FadeStartDistance = 10;

	public int FadeEndDistance = 50;

	public int FadeFalloff = 3;

	public bool Stormy;
}


public class SnowEffect : WeatherEffect
{
	public int FadeStartDistance = 10;

	public int FadeEndDistance = 50;

	public int FadeFalloff = 3;

	public bool Stormy;
}


public class UnderwaterEffect : WeatherEffect
{
}


public abstract class WeatherEffectSting : BaseMonoBehaviour, IClientComponent
{
	public float frequency = 600f;

	public float variance = 300f;

	public GameObjectRef[] effects;
}


public class RainEffectSting : WeatherEffectSting
{
}


public enum WeatherPresetType
{
	Clear,
	Overcast,
	Storm,
	Dust,
	Fog,
	Rain,
	Cinematic
}


using System;
using System.Collections.Generic;
using System.Text;
using Facepunch.Extend;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/WeatherPreset")]
public class WeatherPreset : ScriptableObject
{
	[Serializable]
	public struct BiomeFogMults
	{
		public float AmbientIntensityMult;

		public float LightBoostMult;

		public float FogRampStartDist;

		public float FogRampEndDist;

		public void Reset()
		{
			AmbientIntensityMult = -1f;
			LightBoostMult = -1f;
			FogRampStartDist = -1f;
			FogRampEndDist = -1f;
		}

		public static BiomeFogMults Default()
		{
			BiomeFogMults result = default(BiomeFogMults);
			result.AmbientIntensityMult = 1f;
			result.LightBoostMult = 1f;
			result.FogRampStartDist = 0f;
			result.FogRampEndDist = 0.0001f;
			return result;
		}
	}

	public WeatherPresetType Type;

	public float Wind;

	public float Rain;

	public float Thunder;

	public float Rainbow;

	public TOD_AtmosphereParameters Atmosphere;

	public TOD_CloudParameters Clouds;

	public float AmbientLightMultiplier = 1f;

	public float DirectionalLightMultiplier = 1f;

	public float ReflectionMultiplier = 1f;

	public float SunMeshBrightnessMultiplier = 1f;

	public float MoonMeshBrightnessMultiplier = 1f;

	public float FogMultiplier = 5f;

	public float BiomeFogDistanceCurve = 1f;

	public float BiomeFogAmbientSaturationMult = 1f;

	public float AtmosphereFogHeightFalloff;

	public float AtmosphereFogRampStartDistance;

	public float AtmosphereFogRampEndDistance = 0.0001f;

	[Range(0f, 10f)]
	public float OceanScale;

	public BiomeFogMults AridFogMults = BiomeFogMults.Default();

	public BiomeFogMults TemperateFogMults = BiomeFogMults.Default();

	public BiomeFogMults TundraFogMults = BiomeFogMults.Default();

	public BiomeFogMults ArcticFogMults = BiomeFogMults.Default();

	public BiomeFogMults JungleFogMults = BiomeFogMults.Default();

	public VolumeCloudsConfig[] VolumeCloudsConfigs;

	public VolumeCloudsCirrusConfig[] VolumeCloudsCirrusConfigs;

	public VolumeCloudsRadialWeatherLayerConfig[] VolumeCloudsStormLayers;

	public float VolumeCloudsSunColorScale = -1f;

	public float VolumeCloudsMoonColorScale = -1f;

	public float VolumeCloudsAtmosphericHaze = -1f;

	public float VolumeCloudsSkyOcclusion = -1f;

	public int OverrideCloudConfig = -1;

	public void Apply(TOD_Sky sky)
	{
		sky.Atmosphere.RayleighMultiplier = Atmosphere.RayleighMultiplier;
		sky.Atmosphere.MieMultiplier = Atmosphere.MieMultiplier;
		sky.Atmosphere.Brightness = Atmosphere.Brightness;
		sky.Atmosphere.Contrast = Atmosphere.Contrast;
		sky.Atmosphere.Directionality = Atmosphere.Directionality;
		sky.Atmosphere.Fogginess = Atmosphere.Fogginess;
		sky.Atmosphere.NightContrast = Atmosphere.NightContrast;
		sky.Atmosphere.NightBrightness = Atmosphere.NightBrightness;
		sky.Clouds.Size = Clouds.Size;
		sky.Clouds.Opacity = Clouds.Opacity;
		sky.Clouds.Coverage = Clouds.Coverage;
		sky.Clouds.Sharpness = Clouds.Sharpness;
		sky.Clouds.Coloring = Clouds.Coloring;
		sky.Clouds.Attenuation = Clouds.Attenuation;
		sky.Clouds.Saturation = Clouds.Saturation;
		sky.Clouds.Scattering = Clouds.Scattering;
		sky.Clouds.Brightness = Clouds.Brightness;
	}

	public void Copy(TOD_Sky sky)
	{
		Atmosphere.RayleighMultiplier = sky.Atmosphere.RayleighMultiplier;
		Atmosphere.MieMultiplier = sky.Atmosphere.MieMultiplier;
		Atmosphere.Brightness = sky.Atmosphere.Brightness;
		Atmosphere.Contrast = sky.Atmosphere.Contrast;
		Atmosphere.Directionality = sky.Atmosphere.Directionality;
		Atmosphere.Fogginess = sky.Atmosphere.Fogginess;
		Atmosphere.NightBrightness = sky.Atmosphere.NightBrightness;
		Atmosphere.NightContrast = sky.Atmosphere.NightContrast;
		Clouds.Size = sky.Clouds.Size;
		Clouds.Opacity = sky.Clouds.Opacity;
		Clouds.Coverage = sky.Clouds.Coverage;
		Clouds.Sharpness = sky.Clouds.Sharpness;
		Clouds.Coloring = sky.Clouds.Coloring;
		Clouds.Attenuation = sky.Clouds.Attenuation;
		Clouds.Saturation = sky.Clouds.Saturation;
		Clouds.Scattering = sky.Clouds.Scattering;
		Clouds.Brightness = sky.Clouds.Brightness;
	}

	public void Reset()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Expected O, but got Unknown
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Expected O, but got Unknown
		Wind = -1f;
		Rain = -1f;
		Thunder = -1f;
		Rainbow = -1f;
		Atmosphere = new TOD_AtmosphereParameters();
		Atmosphere.RayleighMultiplier = -1f;
		Atmosphere.MieMultiplier = -1f;
		Atmosphere.Brightness = -1f;
		Atmosphere.Contrast = -1f;
		Atmosphere.Directionality = -1f;
		Atmosphere.Fogginess = -1f;
		Atmosphere.NightContrast = -1f;
		Atmosphere.NightBrightness = -1f;
		Clouds = new TOD_CloudParameters();
		Clouds.Size = -1f;
		Clouds.Opacity = -1f;
		Clouds.Coverage = -1f;
		Clouds.Sharpness = -1f;
		Clouds.Coloring = -1f;
		Clouds.Attenuation = -1f;
		Clouds.Saturation = -1f;
		Clouds.Scattering = -1f;
		Clouds.Brightness = -1f;
		AmbientLightMultiplier = -1f;
		DirectionalLightMultiplier = -1f;
		ReflectionMultiplier = -1f;
		SunMeshBrightnessMultiplier = -1f;
		MoonMeshBrightnessMultiplier = -1f;
		FogMultiplier = -1f;
		OceanScale = -1f;
		VolumeCloudsSunColorScale = -1f;
		VolumeCloudsMoonColorScale = -1f;
		VolumeCloudsSkyOcclusion = -1f;
		VolumeCloudsAtmosphericHaze = -1f;
		BiomeFogDistanceCurve = -1f;
		BiomeFogAmbientSaturationMult = -1f;
		AtmosphereFogHeightFalloff = -1f;
		AtmosphereFogRampStartDistance = -1f;
		AtmosphereFogRampEndDistance = -1f;
		AridFogMults.Reset();
		TemperateFogMults.Reset();
		TundraFogMults.Reset();
		ArcticFogMults.Reset();
		JungleFogMults.Reset();
		OverrideCloudConfig = -1;
	}

	public void Set(WeatherPreset other)
	{
		Wind = other.Wind;
		Rain = other.Rain;
		Thunder = other.Thunder;
		Rainbow = other.Rainbow;
		Atmosphere.RayleighMultiplier = other.Atmosphere.RayleighMultiplier;
		Atmosphere.MieMultiplier = other.Atmosphere.MieMultiplier;
		Atmosphere.Brightness = other.Atmosphere.Brightness;
		Atmosphere.Contrast = other.Atmosphere.Contrast;
		Atmosphere.Directionality = other.Atmosphere.Directionality;
		Atmosphere.Fogginess = other.Atmosphere.Fogginess;
		Atmosphere.NightContrast = other.Atmosphere.NightContrast;
		Atmosphere.NightBrightness = other.Atmosphere.NightBrightness;
		Clouds.Size = other.Clouds.Size;
		Clouds.Opacity = other.Clouds.Opacity;
		Clouds.Coverage = other.Clouds.Coverage;
		Clouds.Sharpness = other.Clouds.Sharpness;
		Clouds.Coloring = other.Clouds.Coloring;
		Clouds.Attenuation = other.Clouds.Attenuation;
		Clouds.Saturation = other.Clouds.Saturation;
		Clouds.Scattering = other.Clouds.Scattering;
		Clouds.Brightness = other.Clouds.Brightness;
		AmbientLightMultiplier = other.AmbientLightMultiplier;
		DirectionalLightMultiplier = other.DirectionalLightMultiplier;
		ReflectionMultiplier = other.ReflectionMultiplier;
		SunMeshBrightnessMultiplier = other.SunMeshBrightnessMultiplier;
		MoonMeshBrightnessMultiplier = other.MoonMeshBrightnessMultiplier;
		FogMultiplier = other.FogMultiplier;
		BiomeFogDistanceCurve = other.BiomeFogDistanceCurve;
		BiomeFogAmbientSaturationMult = other.BiomeFogAmbientSaturationMult;
		AtmosphereFogHeightFalloff = other.AtmosphereFogHeightFalloff;
		AtmosphereFogRampStartDistance = other.AtmosphereFogRampStartDistance;
		AtmosphereFogRampEndDistance = other.AtmosphereFogRampEndDistance;
		OceanScale = other.OceanScale;
		VolumeCloudsAtmosphericHaze = other.VolumeCloudsAtmosphericHaze;
		VolumeCloudsSunColorScale = other.VolumeCloudsSunColorScale;
		VolumeCloudsSkyOcclusion = other.VolumeCloudsSkyOcclusion;
		VolumeCloudsMoonColorScale = other.VolumeCloudsMoonColorScale;
		AridFogMults = other.AridFogMults;
		TemperateFogMults = other.TemperateFogMults;
		TundraFogMults = other.TundraFogMults;
		ArcticFogMults = other.ArcticFogMults;
		OverrideCloudConfig = other.OverrideCloudConfig;
	}

	public void SetVolumeCloudsConfigs(WeatherPreset other)
	{
		if (other.VolumeCloudsConfigs == null)
		{
			VolumeCloudsConfigs = null;
			OverrideCloudConfig = -1;
			return;
		}
		VolumeCloudsConfigs = new VolumeCloudsConfig[other.VolumeCloudsConfigs.Length];
		for (int i = 0; i < other.VolumeCloudsConfigs.Length; i++)
		{
			VolumeCloudsConfigs[i] = other.VolumeCloudsConfigs[i];
		}
		if (VolumeCloudsConfigs.Length != 0)
		{
			OverrideCloudConfig = List.FindIndex<VolumeCloudsConfig>((IReadOnlyList<VolumeCloudsConfig>)SingletonComponent<Climate>.Instance.AllCloudConfigs, VolumeCloudsConfigs[0], (IEqualityComparer<VolumeCloudsConfig>)null);
		}
		else
		{
			OverrideCloudConfig = -1;
		}
	}

	public override string ToString()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"Wind {Wind}");
		stringBuilder.AppendLine($"Rain {Rain}");
		stringBuilder.AppendLine($"Thunder {Thunder}");
		stringBuilder.AppendLine($"Rainbow {Rainbow}");
		stringBuilder.AppendLine($"RayleighMultiplier {Atmosphere.RayleighMultiplier}");
		stringBuilder.AppendLine($"MieMultiplier {Atmosphere.MieMultiplier}");
		stringBuilder.AppendLine($"Brightness {Atmosphere.Brightness}");
		stringBuilder.AppendLine($"Contrast {Atmosphere.Contrast}");
		stringBuilder.AppendLine($"Directionality {Atmosphere.Directionality}");
		stringBuilder.AppendLine($"Fogginess {Atmosphere.Fogginess}");
		stringBuilder.AppendLine($"Night Brightness {Atmosphere.NightBrightness}");
		stringBuilder.AppendLine($"Night Contrast {Atmosphere.NightContrast}");
		stringBuilder.AppendLine($"Size {Clouds.Size}");
		stringBuilder.AppendLine($"Opacity {Clouds.Opacity}");
		stringBuilder.AppendLine($"Coverage {Clouds.Coverage}");
		stringBuilder.AppendLine($"Sharpness {Clouds.Sharpness}");
		stringBuilder.AppendLine($"Coloring {Clouds.Coloring}");
		stringBuilder.AppendLine($"Attenuation {Clouds.Attenuation}");
		stringBuilder.AppendLine($"Saturation {Clouds.Saturation}");
		stringBuilder.AppendLine($"Scattering {Clouds.Scattering}");
		stringBuilder.AppendLine($"Brightness {Clouds.Brightness}");
		stringBuilder.AppendLine($"AmbientLightMultiplier {AmbientLightMultiplier}");
		stringBuilder.AppendLine($"DirectionalLightMultiplier {DirectionalLightMultiplier}");
		stringBuilder.AppendLine($"ReflectionMultiplier {ReflectionMultiplier}");
		stringBuilder.AppendLine($"SunMeshBrightnessMultiplier {SunMeshBrightnessMultiplier}");
		stringBuilder.AppendLine($"MoonMeshBrightnessMultiplier {MoonMeshBrightnessMultiplier}");
		stringBuilder.AppendLine($"FogMultiplier {FogMultiplier}");
		stringBuilder.AppendLine($"BiomeFogDistanceCurve {BiomeFogDistanceCurve}");
		stringBuilder.AppendLine($"BiomeFogAmbientSaturationMult {BiomeFogAmbientSaturationMult}");
		stringBuilder.AppendLine($"AtmosphereFogHeightFalloff {AtmosphereFogHeightFalloff}");
		stringBuilder.AppendLine($"AtmosphereFogRampStartDistance {AtmosphereFogRampStartDistance}");
		stringBuilder.AppendLine($"AtmosphereFogRampEndDistance {AtmosphereFogRampEndDistance}");
		stringBuilder.AppendLine($"Ocean {OceanScale}");
		return stringBuilder.ToString();
	}

	public void Fade(WeatherPreset a, WeatherPreset b, float t)
	{
		Fade(ref Wind, a.Wind, b.Wind, t);
		Fade(ref Rain, a.Rain, b.Rain, t);
		Fade(ref Thunder, a.Thunder, b.Thunder, t);
		Fade(ref Rainbow, a.Rainbow, b.Rainbow, t);
		Fade(ref Atmosphere.RayleighMultiplier, a.Atmosphere.RayleighMultiplier, b.Atmosphere.RayleighMultiplier, t);
		Fade(ref Atmosphere.MieMultiplier, a.Atmosphere.MieMultiplier, b.Atmosphere.MieMultiplier, t);
		Fade(ref Atmosphere.Brightness, a.Atmosphere.Brightness, b.Atmosphere.Brightness, t);
		Fade(ref Atmosphere.Contrast, a.Atmosphere.Contrast, b.Atmosphere.Contrast, t);
		Fade(ref Atmosphere.Directionality, a.Atmosphere.Directionality, b.Atmosphere.Directionality, t);
		Fade(ref Atmosphere.Fogginess, a.Atmosphere.Fogginess, b.Atmosphere.Fogginess, t);
		Fade(ref Atmosphere.NightContrast, a.Atmosphere.NightContrast, b.Atmosphere.NightContrast, t);
		Fade(ref Atmosphere.NightBrightness, a.Atmosphere.NightBrightness, b.Atmosphere.NightBrightness, t);
		Fade(ref Clouds.Size, a.Clouds.Size, b.Clouds.Size, t);
		Fade(ref Clouds.Opacity, a.Clouds.Opacity, b.Clouds.Opacity, t);
		Fade(ref Clouds.Coverage, a.Clouds.Coverage, b.Clouds.Coverage, t);
		Fade(ref Clouds.Sharpness, a.Clouds.Sharpness, b.Clouds.Sharpness, t);
		Fade(ref Clouds.Coloring, a.Clouds.Coloring, b.Clouds.Coloring, t);
		Fade(ref Clouds.Attenuation, a.Clouds.Attenuation, b.Clouds.Attenuation, t);
		Fade(ref Clouds.Saturation, a.Clouds.Saturation, b.Clouds.Saturation, t);
		Fade(ref Clouds.Scattering, a.Clouds.Scattering, b.Clouds.Scattering, t);
		Fade(ref Clouds.Brightness, a.Clouds.Brightness, b.Clouds.Brightness, t);
		Fade(ref AmbientLightMultiplier, a.AmbientLightMultiplier, b.AmbientLightMultiplier, t);
		Fade(ref DirectionalLightMultiplier, a.DirectionalLightMultiplier, b.DirectionalLightMultiplier, t);
		Fade(ref ReflectionMultiplier, a.ReflectionMultiplier, b.ReflectionMultiplier, t);
		Fade(ref SunMeshBrightnessMultiplier, a.SunMeshBrightnessMultiplier, b.SunMeshBrightnessMultiplier, t);
		Fade(ref MoonMeshBrightnessMultiplier, a.MoonMeshBrightnessMultiplier, b.MoonMeshBrightnessMultiplier, t);
		Fade(ref FogMultiplier, a.FogMultiplier, b.FogMultiplier, t);
		Fade(ref BiomeFogDistanceCurve, a.BiomeFogDistanceCurve, b.BiomeFogDistanceCurve, t);
		Fade(ref BiomeFogAmbientSaturationMult, a.BiomeFogAmbientSaturationMult, b.BiomeFogAmbientSaturationMult, t);
		Fade(ref AtmosphereFogHeightFalloff, a.AtmosphereFogHeightFalloff, b.AtmosphereFogHeightFalloff, t);
		Fade(ref AtmosphereFogRampStartDistance, a.AtmosphereFogRampStartDistance, b.AtmosphereFogRampStartDistance, t);
		Fade(ref AtmosphereFogRampEndDistance, a.AtmosphereFogRampEndDistance, b.AtmosphereFogRampEndDistance, t);
		Fade(ref OceanScale, a.OceanScale, b.OceanScale, t);
		Fade(ref VolumeCloudsSunColorScale, a.VolumeCloudsSunColorScale, b.VolumeCloudsSunColorScale, t);
		Fade(ref VolumeCloudsMoonColorScale, a.VolumeCloudsMoonColorScale, b.VolumeCloudsMoonColorScale, t);
		Fade(ref VolumeCloudsSkyOcclusion, a.VolumeCloudsSkyOcclusion, b.VolumeCloudsSkyOcclusion, t);
		Fade(ref VolumeCloudsAtmosphericHaze, a.VolumeCloudsAtmosphericHaze, b.VolumeCloudsAtmosphericHaze, t);
		Fade(ref AridFogMults, a.AridFogMults, b.AridFogMults, t);
		Fade(ref TemperateFogMults, a.TemperateFogMults, b.TemperateFogMults, t);
		Fade(ref TundraFogMults, a.TundraFogMults, b.TundraFogMults, t);
		Fade(ref ArcticFogMults, a.ArcticFogMults, b.ArcticFogMults, t);
		Fade(ref JungleFogMults, a.JungleFogMults, b.JungleFogMults, t);
	}

	public void Override(WeatherPreset other)
	{
		Override(ref Wind, other.Wind);
		Override(ref Rain, other.Rain);
		Override(ref Thunder, other.Thunder);
		Override(ref Rainbow, other.Rainbow);
		Override(ref Atmosphere.RayleighMultiplier, other.Atmosphere.RayleighMultiplier);
		Override(ref Atmosphere.MieMultiplier, other.Atmosphere.MieMultiplier);
		Override(ref Atmosphere.Brightness, other.Atmosphere.Brightness);
		Override(ref Atmosphere.Contrast, other.Atmosphere.Contrast);
		Override(ref Atmosphere.Directionality, other.Atmosphere.Directionality);
		Override(ref Atmosphere.Fogginess, other.Atmosphere.Fogginess);
		Override(ref Atmosphere.NightBrightness, other.Atmosphere.NightBrightness);
		Override(ref Atmosphere.NightContrast, other.Atmosphere.NightContrast);
		Override(ref Clouds.Size, other.Clouds.Size);
		Override(ref Clouds.Opacity, other.Clouds.Opacity);
		Override(ref Clouds.Coverage, other.Clouds.Coverage);
		Override(ref Clouds.Sharpness, other.Clouds.Sharpness);
		Override(ref Clouds.Coloring, other.Clouds.Coloring);
		Override(ref Clouds.Attenuation, other.Clouds.Attenuation);
		Override(ref Clouds.Saturation, other.Clouds.Saturation);
		Override(ref Clouds.Scattering, other.Clouds.Scattering);
		Override(ref Clouds.Brightness, other.Clouds.Brightness);
		Override(ref AmbientLightMultiplier, other.AmbientLightMultiplier);
		Override(ref DirectionalLightMultiplier, other.DirectionalLightMultiplier);
		Override(ref ReflectionMultiplier, other.ReflectionMultiplier);
		Override(ref SunMeshBrightnessMultiplier, other.SunMeshBrightnessMultiplier);
		Override(ref MoonMeshBrightnessMultiplier, other.MoonMeshBrightnessMultiplier);
		Override(ref FogMultiplier, other.FogMultiplier);
		Override(ref BiomeFogDistanceCurve, other.BiomeFogDistanceCurve);
		Override(ref BiomeFogAmbientSaturationMult, other.BiomeFogAmbientSaturationMult);
		Override(ref AtmosphereFogHeightFalloff, other.AtmosphereFogHeightFalloff);
		Override(ref AtmosphereFogRampStartDistance, other.AtmosphereFogRampStartDistance);
		Override(ref AtmosphereFogRampEndDistance, other.AtmosphereFogRampEndDistance);
		Override(ref OceanScale, other.OceanScale);
		Override(ref VolumeCloudsSunColorScale, other.VolumeCloudsSunColorScale);
		Override(ref VolumeCloudsMoonColorScale, other.VolumeCloudsMoonColorScale);
		Override(ref VolumeCloudsSkyOcclusion, other.VolumeCloudsSkyOcclusion);
		Override(ref VolumeCloudsAtmosphericHaze, other.VolumeCloudsAtmosphericHaze);
		Override(ref AridFogMults, other.AridFogMults);
		Override(ref TemperateFogMults, other.TemperateFogMults);
		Override(ref TundraFogMults, other.TundraFogMults);
		Override(ref ArcticFogMults, other.ArcticFogMults);
		Override(ref JungleFogMults, other.JungleFogMults);
		OverrideCloudConfig = other.OverrideCloudConfig;
	}

	public void Max(WeatherPreset other)
	{
		Max(ref Wind, other.Wind);
		Max(ref Rain, other.Rain);
		Max(ref Thunder, other.Thunder);
		Max(ref Rainbow, other.Rainbow);
		Max(ref Atmosphere.RayleighMultiplier, other.Atmosphere.RayleighMultiplier);
		Max(ref Atmosphere.MieMultiplier, other.Atmosphere.MieMultiplier);
		Max(ref Atmosphere.Brightness, other.Atmosphere.Brightness);
		Max(ref Atmosphere.Contrast, other.Atmosphere.Contrast);
		Max(ref Atmosphere.Directionality, other.Atmosphere.Directionality);
		Max(ref Atmosphere.Fogginess, other.Atmosphere.Fogginess);
		Max(ref Atmosphere.NightContrast, other.Atmosphere.NightContrast);
		Max(ref Atmosphere.NightBrightness, other.Atmosphere.NightBrightness);
		Max(ref Clouds.Size, other.Clouds.Size);
		Max(ref Clouds.Opacity, other.Clouds.Opacity);
		Max(ref Clouds.Coverage, other.Clouds.Coverage);
		Max(ref Clouds.Sharpness, other.Clouds.Sharpness);
		Max(ref Clouds.Coloring, other.Clouds.Coloring);
		Max(ref Clouds.Attenuation, other.Clouds.Attenuation);
		Max(ref Clouds.Saturation, other.Clouds.Saturation);
		Max(ref Clouds.Scattering, other.Clouds.Scattering);
		Max(ref Clouds.Brightness, other.Clouds.Brightness);
		Max(ref AmbientLightMultiplier, other.AmbientLightMultiplier);
		Max(ref DirectionalLightMultiplier, other.DirectionalLightMultiplier);
		Max(ref ReflectionMultiplier, other.ReflectionMultiplier);
		Max(ref SunMeshBrightnessMultiplier, other.SunMeshBrightnessMultiplier);
		Max(ref MoonMeshBrightnessMultiplier, other.MoonMeshBrightnessMultiplier);
		Max(ref FogMultiplier, other.FogMultiplier);
		Max(ref BiomeFogDistanceCurve, other.BiomeFogDistanceCurve);
		Max(ref BiomeFogAmbientSaturationMult, other.BiomeFogAmbientSaturationMult);
		Max(ref AtmosphereFogHeightFalloff, other.AtmosphereFogHeightFalloff);
		Max(ref AtmosphereFogRampStartDistance, other.AtmosphereFogRampStartDistance);
		Max(ref AtmosphereFogRampEndDistance, other.AtmosphereFogRampEndDistance);
		Max(ref OceanScale, other.OceanScale);
		Max(ref VolumeCloudsSunColorScale, other.VolumeCloudsSunColorScale);
		Max(ref VolumeCloudsMoonColorScale, other.VolumeCloudsMoonColorScale);
		Max(ref VolumeCloudsSkyOcclusion, other.VolumeCloudsSkyOcclusion);
		Max(ref VolumeCloudsAtmosphericHaze, other.VolumeCloudsAtmosphericHaze);
		Max(ref AridFogMults, other.AridFogMults);
		Max(ref TemperateFogMults, other.TemperateFogMults);
		Max(ref TundraFogMults, other.TundraFogMults);
		Max(ref ArcticFogMults, other.ArcticFogMults);
		Max(ref JungleFogMults, other.JungleFogMults);
	}

	public void Min(WeatherPreset other)
	{
		Min(ref Wind, other.Wind);
		Min(ref Rain, other.Rain);
		Min(ref Thunder, other.Thunder);
		Min(ref Rainbow, other.Rainbow);
		Min(ref Atmosphere.RayleighMultiplier, other.Atmosphere.RayleighMultiplier);
		Min(ref Atmosphere.MieMultiplier, other.Atmosphere.MieMultiplier);
		Min(ref Atmosphere.Brightness, other.Atmosphere.Brightness);
		Min(ref Atmosphere.Contrast, other.Atmosphere.Contrast);
		Min(ref Atmosphere.Directionality, other.Atmosphere.Directionality);
		Min(ref Atmosphere.Fogginess, other.Atmosphere.Fogginess);
		Min(ref Atmosphere.NightContrast, other.Atmosphere.NightContrast);
		Min(ref Atmosphere.NightBrightness, other.Atmosphere.NightBrightness);
		Min(ref Clouds.Size, other.Clouds.Size);
		Min(ref Clouds.Opacity, other.Clouds.Opacity);
		Min(ref Clouds.Coverage, other.Clouds.Coverage);
		Min(ref Clouds.Sharpness, other.Clouds.Sharpness);
		Min(ref Clouds.Coloring, other.Clouds.Coloring);
		Min(ref Clouds.Attenuation, other.Clouds.Attenuation);
		Min(ref Clouds.Saturation, other.Clouds.Saturation);
		Min(ref Clouds.Scattering, other.Clouds.Scattering);
		Min(ref Clouds.Brightness, other.Clouds.Brightness);
		Min(ref AmbientLightMultiplier, other.AmbientLightMultiplier);
		Min(ref DirectionalLightMultiplier, other.DirectionalLightMultiplier);
		Min(ref ReflectionMultiplier, other.ReflectionMultiplier);
		Min(ref SunMeshBrightnessMultiplier, other.SunMeshBrightnessMultiplier);
		Min(ref MoonMeshBrightnessMultiplier, other.MoonMeshBrightnessMultiplier);
		Min(ref FogMultiplier, other.FogMultiplier);
		Min(ref BiomeFogDistanceCurve, other.BiomeFogDistanceCurve);
		Min(ref BiomeFogAmbientSaturationMult, other.BiomeFogAmbientSaturationMult);
		Min(ref AtmosphereFogHeightFalloff, other.AtmosphereFogHeightFalloff);
		Min(ref AtmosphereFogRampStartDistance, other.AtmosphereFogRampStartDistance);
		Min(ref AtmosphereFogRampEndDistance, other.AtmosphereFogRampEndDistance);
		Min(ref OceanScale, other.OceanScale);
		Min(ref VolumeCloudsSunColorScale, other.VolumeCloudsSunColorScale);
		Min(ref VolumeCloudsMoonColorScale, other.VolumeCloudsMoonColorScale);
		Min(ref VolumeCloudsSkyOcclusion, other.VolumeCloudsSkyOcclusion);
		Min(ref VolumeCloudsAtmosphericHaze, other.VolumeCloudsAtmosphericHaze);
		Min(ref AridFogMults, other.AridFogMults);
		Min(ref TemperateFogMults, other.TemperateFogMults);
		Min(ref TundraFogMults, other.TundraFogMults);
		Min(ref ArcticFogMults, other.ArcticFogMults);
		Min(ref JungleFogMults, other.JungleFogMults);
	}

	private void Fade(ref float x, float a, float b, float t)
	{
		x = Mathf.SmoothStep(a, b, t);
	}

	private void Override(ref float x, float other)
	{
		if (other >= 0f)
		{
			x = other;
		}
	}

	private void Max(ref float x, float other)
	{
		x = Mathf.Max(x, other);
	}

	private void Min(ref float x, float other)
	{
		if (other >= 0f)
		{
			x = Mathf.Min(x, other);
		}
	}

	private void Fade(ref BiomeFogMults x, BiomeFogMults a, BiomeFogMults b, float t)
	{
		Fade(ref x.AmbientIntensityMult, a.AmbientIntensityMult, b.AmbientIntensityMult, t);
		Fade(ref x.LightBoostMult, a.LightBoostMult, b.LightBoostMult, t);
		Fade(ref x.FogRampStartDist, a.FogRampStartDist, b.FogRampStartDist, t);
		Fade(ref x.FogRampEndDist, a.FogRampEndDist, b.FogRampEndDist, t);
	}

	private void Override(ref BiomeFogMults x, BiomeFogMults other)
	{
		Override(ref x.AmbientIntensityMult, other.AmbientIntensityMult);
		Override(ref x.LightBoostMult, other.LightBoostMult);
		Override(ref x.FogRampStartDist, other.FogRampStartDist);
		Override(ref x.FogRampEndDist, other.FogRampEndDist);
	}

	private void Max(ref BiomeFogMults x, BiomeFogMults other)
	{
		Max(ref x.AmbientIntensityMult, other.AmbientIntensityMult);
		Max(ref x.LightBoostMult, other.LightBoostMult);
		Max(ref x.FogRampStartDist, other.FogRampStartDist);
		Max(ref x.FogRampEndDist, other.FogRampEndDist);
	}

	private void Min(ref BiomeFogMults x, BiomeFogMults other)
	{
		Min(ref x.AmbientIntensityMult, other.AmbientIntensityMult);
		Min(ref x.LightBoostMult, other.LightBoostMult);
		Min(ref x.FogRampStartDist, other.FogRampStartDist);
		Min(ref x.FogRampEndDist, other.FogRampEndDist);
	}
}


using System;

[Serializable]
public struct BiomeFogMults
{
	public float AmbientIntensityMult;

	public float LightBoostMult;

	public float FogRampStartDist;

	public float FogRampEndDist;

	public void Reset()
	{
		AmbientIntensityMult = -1f;
		LightBoostMult = -1f;
		FogRampStartDist = -1f;
		FogRampEndDist = -1f;
	}

	public static BiomeFogMults Default()
	{
		BiomeFogMults result = default(BiomeFogMults);
		result.AmbientIntensityMult = 1f;
		result.LightBoostMult = 1f;
		result.FogRampStartDist = 0f;
		result.FogRampEndDist = 0.0001f;
		return result;
	}
}


using UnityEngine;

public class LegacyWeatherState
{
	private WeatherPreset preset;

	public float Wind
	{
		get
		{
			return preset.Wind;
		}
		set
		{
			preset.Wind = value;
		}
	}

	public float Rain
	{
		get
		{
			return preset.Rain;
		}
		set
		{
			preset.Rain = value;
		}
	}

	public float Clouds
	{
		get
		{
			return preset.Clouds.Coverage;
		}
		set
		{
			preset.Clouds.Opacity = Mathf.Sign(value);
			preset.Clouds.Coverage = value;
		}
	}

	public float Fog
	{
		get
		{
			return preset.Atmosphere.Fogginess;
		}
		set
		{
			preset.Atmosphere.Fogginess = value;
		}
	}

	public LegacyWeatherState(WeatherPreset preset)
	{
		this.preset = preset;
	}
}


public static class WordFilter
{
	public static string Filter(string str)
	{
		return str;
	}
}


public class WorldGrid : SingletonComponent<WorldGrid>, IClientComponent
{
	public static bool Paused;

	public float CellSize = 50f;

	public float MaxMilliseconds = 0.1f;

	public const float MaxRefreshDistance = 500f;

	public const float MinTimeBetweenRefreshes = 1f;
}


using UnityEngine;

public class WorldModel : MonoBehaviour
{
	public float mass = 1f;
}


using System;
using UnityEngine;

[Serializable]
public class PegConfig
{
	public enum PegType
	{
		Small,
		Large
	}

	public PegType Type;

	public Vector3 VerticalMountLocalRotation;

	public Vector3 VerticalMountLocalOffset;

	public void Init(PegType t, Vector3 localRot, Vector3 localOffset)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Type = t;
		VerticalMountLocalRotation = localRot;
		VerticalMountLocalOffset = localOffset;
	}
}


public enum PegType
{
	Small,
	Large
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class WorldModelRackMountConfig : MonoBehaviour
{
	[Serializable]
	public class CustomPosition
	{
		public WeaponRack.SpecialRackType RackType;

		public Vector3 CenterOffset;

		public Vector3 Rotation;
	}

	public List<WeaponRack.RackType> ExcludedRackTypes = new List<WeaponRack.RackType>();

	public Vector3 CenterOffsfet;

	public Vector3 LeftOffset;

	public Vector3 VerticalMountLocalRotation;

	public Vector3 VerticalMountLocalOffset;

	public int XSize = 3;

	public int YSize = 2;

	public int ZSize = 1;

	public List<PegConfig> Pegs = new List<PegConfig>();

	public List<PegConfig> VerticalPegs = new List<PegConfig>();

	public bool OverrideScale;

	public Vector3 Scale = Vector3.one;

	public bool UseManualRenderBounds;

	public Bounds ManualRenderBounds;

	public bool CanReloadOnWeaponRack = true;

	[Header("Special Rack Types")]
	public List<CustomPosition> CustomPositions = new List<CustomPosition>();

	public static WorldModelRackMountConfig GetForItemDef(ItemDefinition itemDef)
	{
		GameObjectRef worldModelPrefab = itemDef.worldModelPrefab;
		if (!worldModelPrefab.isValid)
		{
			return null;
		}
		return worldModelPrefab.Get().GetComponent<WorldModelRackMountConfig>();
	}

	public void ApplyTransformDefaults(Transform displayItem)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)displayItem == (Object)null))
		{
			if (OverrideScale)
			{
				displayItem.localScale = Scale;
			}
			displayItem.localPosition = VerticalMountLocalOffset;
			displayItem.localEulerAngles = VerticalMountLocalRotation;
		}
	}

	public CustomPosition FindCustomRackPosition(WeaponRack.SpecialRackType rackType)
	{
		if (CustomPositions == null)
		{
			return null;
		}
		foreach (CustomPosition customPosition in CustomPositions)
		{
			if (customPosition.RackType == rackType)
			{
				return customPosition;
			}
		}
		return null;
	}
}


using System;
using UnityEngine;

[Serializable]
public class CustomPosition
{
	public WeaponRack.SpecialRackType RackType;

	public Vector3 CenterOffset;

	public Vector3 Rotation;
}


using UnityEngine;

public class WorldModelRandomiser : MonoBehaviour
{
	public Wearable.PartRandomizer[] randomParts;
}


using UnityEngine;

public class WorldModelVisualConfig : MonoBehaviour, IClientComponent
{
	public FoodViewModel.FoodVisualConfig VisualConfig;

	public void Init(ItemDefinition itemDef)
	{
		if (VisualConfig != null && !((Object)(object)itemDef == (Object)null))
		{
			VisualConfig.InitForItemDef(itemDef);
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Gestures/Gesture Collection")]
public class GestureCollection : BaseScriptableObject
{
	public static uint HeavyLandingId = 3204230781u;

	private static GestureCollection _instance = null;

	public GestureConfig[] AllGestures;

	public float GestureVmInDuration = 0.25f;

	public AnimationCurve GestureInCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public float GestureVmOutDuration = 0.25f;

	public AnimationCurve GestureOutCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public float GestureViewmodelDeployDelay = 0.25f;

	public Sprite EmptyGestureSlotSprite;

	public Phrase EmptySlotTitle;

	public Phrase EmptySlotDescription;

	public static GestureCollection Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = FileSystem.Load<GestureCollection>("assets/prefabs/player/gestures/gesturecollection.asset", true);
			}
			return _instance;
		}
	}

	public GestureConfig IdToGesture(uint id)
	{
		GestureConfig[] allGestures = AllGestures;
		foreach (GestureConfig gestureConfig in allGestures)
		{
			if (gestureConfig.gestureId == id)
			{
				return gestureConfig;
			}
		}
		return null;
	}

	public GestureConfig StringToGesture(string gestureName)
	{
		if (string.IsNullOrEmpty(gestureName))
		{
			return null;
		}
		GestureConfig[] allGestures = AllGestures;
		foreach (GestureConfig gestureConfig in allGestures)
		{
			if (gestureConfig.convarName == gestureName)
			{
				return gestureConfig;
			}
		}
		return null;
	}
}


using ConVar;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Video;

[CreateAssetMenu(menuName = "Rust/Gestures/Gesture Config")]
public class GestureConfig : ScriptableObject
{
	public enum GestureType
	{
		Player,
		NPC,
		Cinematic
	}

	public enum PlayerModelLayer
	{
		UpperBody = 3,
		FullBody
	}

	public enum MovementCapabilities
	{
		FullMovement,
		NoMovement
	}

	public enum AnimationType
	{
		OneShot,
		Loop
	}

	public enum GestureActionType
	{
		None,
		ShowNameTag,
		DanceAchievement,
		Surrender,
		RockPaperScissors
	}

	[ReadOnly]
	public uint gestureId;

	public string gestureCommand;

	public string convarName;

	public Phrase gestureName;

	public Phrase gestureDescription;

	public Sprite icon;

	public AnimationType animationType;

	public float duration = 1.5f;

	public bool canCancel = true;

	public MovementCapabilities movementMode;

	public BasePlayer.CameraMode viewMode;

	public bool hideInWheel;

	public VideoClip previewClip;

	[Header("Player model setup")]
	public PlayerModelLayer playerModelLayer = PlayerModelLayer.UpperBody;

	public GestureType gestureType;

	public bool hideHeldEntity = true;

	public bool unequipHeldEntity;

	public bool canDuckDuringGesture;

	public bool hasViewmodelAnimation = true;

	public float viewmodelHolsterDelay;

	public bool useRootMotion;

	public bool forceForwardRotation;

	[Header("Interaction")]
	public bool hasMultiplayerInteraction;

	public Phrase joinPlayerPhrase = new Phrase("", "");

	public Phrase joinPlayerDescPhrase = new Phrase("", "");

	[Header("Ownership")]
	public GestureActionType actionType;

	public bool forceUnlock;

	public SteamDLCItem dlcItem;

	public SteamInventoryItem inventoryItem;

	public int GetItemId()
	{
		if ((Object)(object)dlcItem != (Object)null)
		{
			return dlcItem.dlcAppID;
		}
		if ((Object)(object)inventoryItem != (Object)null)
		{
			return inventoryItem.id;
		}
		return 0;
	}

	public Phrase GetSteamItemName()
	{
		if ((Object)(object)dlcItem != (Object)null)
		{
			return dlcItem.dlcName;
		}
		if ((Object)(object)inventoryItem != (Object)null)
		{
			return inventoryItem.displayName;
		}
		return null;
	}

	public bool IsOwnedBy(BasePlayer player, bool allowCinematic = false)
	{
		object obj = Interface.CallHook("CanUseGesture", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (forceUnlock)
		{
			return true;
		}
		if (gestureType == GestureType.NPC)
		{
			if ((Object)(object)player != (Object)null)
			{
				return player.IsNpc;
			}
			return false;
		}
		if (gestureType == GestureType.Cinematic)
		{
			if (!allowCinematic && (!((Object)(object)player != (Object)null) || !player.IsAdmin))
			{
				return Server.cinematic;
			}
			return true;
		}
		return IsUnlockedBy(player);
	}

	public bool IsUnlockedBy(BasePlayer player)
	{
		if (forceUnlock)
		{
			return true;
		}
		if ((Object)(object)dlcItem != (Object)null && (Object)(object)player != (Object)null)
		{
			return dlcItem.CanUse(player);
		}
		if ((Object)(object)inventoryItem != (Object)null && (Object)(object)player != (Object)null && player.blueprints.steamInventory.HasItem(inventoryItem.id))
		{
			return true;
		}
		return false;
	}

	public bool CanBeUsedBy(BasePlayer player)
	{
		if (player.isMounted)
		{
			if (playerModelLayer == PlayerModelLayer.FullBody)
			{
				return false;
			}
			if (player.GetMounted().allowedGestures == BaseMountable.MountGestureType.None)
			{
				return false;
			}
		}
		if (player.IsSwimming() && playerModelLayer == PlayerModelLayer.FullBody)
		{
			return false;
		}
		if (playerModelLayer == PlayerModelLayer.FullBody && player.modelState.ducked)
		{
			return false;
		}
		return true;
	}
}


public enum GestureType
{
	Player,
	NPC,
	Cinematic
}


public enum PlayerModelLayer
{
	UpperBody = 3,
	FullBody
}


public enum MovementCapabilities
{
	FullMovement,
	NoMovement
}


public enum AnimationType
{
	OneShot,
	Loop
}


public enum GestureActionType
{
	None,
	ShowNameTag,
	DanceAchievement,
	Surrender,
	RockPaperScissors
}


using Rust.UI;
using UnityEngine;

public class RockPaperScissorsDialog : SingletonComponent<RockPaperScissorsDialog>
{
	public RustText[] InputTexts;

	public RustSlider TimerBar;

	public GameObject ActiveRoot;

	public GameObject[] MadeSelection;
}


using System.Collections.Generic;
using UnityEngine;

public class OutlineManager : MonoBehaviour, IClientComponent
{
	public static Material blurMat;

	public List<OutlineObject> objectsToRender;

	public float blurAmount = 2f;

	public Material glowSolidMaterial;

	public Material blendGlowMaterial;
}


using UnityEngine;

public class OutlineObject : MonoBehaviour, IClientComponent
{
	public Mesh[] meshes;

	public Transform[] meshTransforms;
}


public class WorldModelOutline : OutlineObject
{
	public bool AlwaysRender;
}


using UnityEngine;

[ExecuteInEditMode]
public class LinearFog : MonoBehaviour
{
	public Material fogMaterial;

	public Color fogColor = Color.white;

	public float fogStart;

	public float fogRange = 1f;

	public float fogDensity = 1f;

	public bool fogSky;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)fogMaterial))
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		fogMaterial.SetColor("_FogColor", fogColor);
		fogMaterial.SetFloat("_Start", fogStart);
		fogMaterial.SetFloat("_Range", fogRange);
		fogMaterial.SetFloat("_Density", fogDensity);
		if (fogSky)
		{
			fogMaterial.SetFloat("_CutOff", 2f);
		}
		else
		{
			fogMaterial.SetFloat("_CutOff", 1f);
		}
		for (int i = 0; i < fogMaterial.passCount; i++)
		{
			Graphics.Blit((Texture)(object)source, destination, fogMaterial, i);
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class MaterialOverlay : MonoBehaviour
{
	public Material material;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (!Object.op_Implicit((Object)(object)material))
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		for (int i = 0; i < material.passCount; i++)
		{
			Graphics.Blit((Texture)(object)source, destination, material, i);
		}
	}
}


using UnityEngine;

[RequireComponent(typeof(Camera))]
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Natural Bloom and Dirty Lens")]
public class NaturalBloomAndDirtyLens : MonoBehaviour
{
	public Shader shader;

	public Texture2D lensDirtTexture;

	public float range = 10000f;

	public float cutoff = 1f;

	[Range(0f, 1f)]
	public float bloomIntensity = 0.05f;

	[Range(0f, 1f)]
	public float lensDirtIntensity = 0.05f;

	[Range(0f, 4f)]
	public float spread = 1f;

	[Range(0f, 4f)]
	public int iterations = 1;

	[Range(1f, 10f)]
	public int mips = 6;

	public float[] mipWeights = new float[6] { 0.5f, 0.6f, 0.6f, 0.45f, 0.35f, 0.23f };

	public bool highPrecision;

	public bool downscaleSource;

	public bool debug;

	public bool temporalFilter;

	[Range(0.01f, 1f)]
	public float temporalFilterWeight = 0.75f;
}


using UnityEngine;

public class ImageRenderController : SingletonComponent<ImageRenderController>
{
	public Camera Camera;
}


public enum BUTTON
{
	FORWARD = 2,
	BACKWARD = 4,
	LEFT = 8,
	RIGHT = 0x10,
	JUMP = 0x20,
	DUCK = 0x40,
	SPRINT = 0x80,
	USE = 0x100,
	FIRE_PRIMARY = 0x400,
	FIRE_SECONDARY = 0x800,
	RELOAD = 0x2000,
	FIRE_THIRD = 0x8000000
}


using UnityEngine;

public class InputState
{
	public InputMessage current = new InputMessage
	{
		ShouldPool = false
	};

	public InputMessage previous = new InputMessage
	{
		ShouldPool = false
	};

	private int SwallowedButtons;

	public bool IsDown(BUTTON btn)
	{
		if (current == null)
		{
			return false;
		}
		if (((uint)SwallowedButtons & (uint)btn) == (uint)btn)
		{
			return false;
		}
		return ((uint)current.buttons & (uint)btn) == (uint)btn;
	}

	public bool WasDown(BUTTON btn)
	{
		if (previous == null)
		{
			return false;
		}
		return ((uint)previous.buttons & (uint)btn) == (uint)btn;
	}

	public bool IsAnyDown()
	{
		if (current == null)
		{
			return false;
		}
		return (float)(current.buttons & ~SwallowedButtons) > 0f;
	}

	public bool WasJustPressed(BUTTON btn)
	{
		if (IsDown(btn))
		{
			return !WasDown(btn);
		}
		return false;
	}

	public bool WasJustReleased(BUTTON btn)
	{
		if (!IsDown(btn))
		{
			return WasDown(btn);
		}
		return false;
	}

	public void SwallowButton(BUTTON btn)
	{
		if (current != null)
		{
			SwallowedButtons |= (int)btn;
		}
	}

	public Quaternion AimAngle()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		if (current == null)
		{
			return Quaternion.identity;
		}
		return Quaternion.Euler(current.aimAngles);
	}

	public Vector3 MouseDelta()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		if (current == null)
		{
			return Vector3.zero;
		}
		return current.mouseDelta;
	}

	public void Flip(InputMessage newcurrent)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		SwallowedButtons = 0;
		previous.aimAngles = current.aimAngles;
		previous.buttons = current.buttons;
		previous.mouseDelta = current.mouseDelta;
		current.aimAngles = newcurrent.aimAngles;
		current.buttons = newcurrent.buttons;
		current.mouseDelta = newcurrent.mouseDelta;
	}

	public void Clear()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		current.buttons = 0;
		previous.buttons = 0;
		SetMouseDelta(Vector3.zero);
		SwallowedButtons = 0;
	}

	public void SetMouseDelta(Vector3 d)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		previous.mouseDelta = d;
		current.mouseDelta = d;
	}
}


using System.Collections.Generic;
using ProtoBuf;

public class ItemCraftTask
{
	public ItemBlueprint blueprint;

	public float endTime;

	public int taskUID;

	public bool cancelled;

	public InstanceData instanceData;

	public int amount = 1;

	public int skinID;

	public List<Item> takenItems;

	public int numCrafted;

	public float conditionScale = 1f;

	public BaseEntity workbenchEntity;
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class ItemCrafter : EntityComponent<BasePlayer>
{
	public List<ItemContainer> containers = new List<ItemContainer>();

	public LinkedList<ItemCraftTask> queue = new LinkedList<ItemCraftTask>();

	public int taskUID;

	[NonSerialized]
	public BasePlayer owner;

	public void AddContainer(ItemContainer container)
	{
		containers.Add(container);
	}

	public static float GetScaledDuration(ItemBlueprint bp, float workbenchLevel, bool isInTutorial)
	{
		float num = workbenchLevel - (float)bp.GetWorkbenchLevel();
		if (isInTutorial)
		{
			return bp.GetCraftTime() * 0.25f;
		}
		if (num == 1f)
		{
			return bp.GetCraftTime() * 0.5f;
		}
		if (num >= 2f)
		{
			return bp.GetCraftTime() * 0.25f;
		}
		return bp.GetCraftTime();
	}

	public void ServerUpdate(float delta)
	{
		if (queue.Count == 0)
		{
			return;
		}
		ItemCraftTask value = queue.First.Value;
		if (value.cancelled)
		{
			owner.Command("note.craft_done", value.taskUID, 0);
			queue.RemoveFirst();
			return;
		}
		float currentCraftLevel = owner.currentCraftLevel;
		if (value.endTime > Time.realtimeSinceStartup)
		{
			return;
		}
		if (value.endTime == 0f)
		{
			float scaledDuration = GetScaledDuration(value.blueprint, currentCraftLevel, owner.IsInTutorial);
			value.endTime = Time.realtimeSinceStartup + scaledDuration;
			value.workbenchEntity = owner.GetCachedCraftLevelWorkbench();
			if ((Object)(object)owner != (Object)null)
			{
				owner.Command("note.craft_start", value.taskUID, scaledDuration, value.amount);
				if (owner.IsAdmin && Craft.instant)
				{
					value.endTime = Time.realtimeSinceStartup + 1f;
				}
			}
		}
		else
		{
			FinishCrafting(value);
			if (value.amount <= 0)
			{
				queue.RemoveFirst();
			}
			else
			{
				value.endTime = 0f;
			}
		}
	}

	private void CollectIngredient(int item, int amount, List<Item> collect, bool takeBroken = true)
	{
		foreach (ItemContainer container in containers)
		{
			amount -= container.Take(collect, item, amount, takeBroken);
			if (amount <= 0)
			{
				break;
			}
		}
	}

	private void CollectIngredients(ItemBlueprint bp, ItemCraftTask task, int amount = 1, BasePlayer player = null, bool takeBroken = true)
	{
		if (Interface.CallHook("OnIngredientsCollect", (object)this, (object)bp, (object)task, (object)amount, (object)player, (object)takeBroken) != null)
		{
			return;
		}
		List<Item> list = new List<Item>();
		foreach (ItemAmount ingredient in bp.GetIngredients())
		{
			CollectIngredient(ingredient.itemid, (int)ingredient.amount * amount, list, takeBroken);
		}
		foreach (Item item in list)
		{
			item.CollectedForCrafting(player);
		}
		task.takenItems = list;
	}

	public bool CraftItem(ItemBlueprint bp, BasePlayer owner, InstanceData instanceData = null, int amount = 1, int skinID = 0, Item fromTempBlueprint = null, bool free = false)
	{
		if ((Object)(object)owner != (Object)null && (owner.IsTransferring() || owner.IsSleeping()))
		{
			return false;
		}
		if (!CanCraft(bp, amount, free))
		{
			return false;
		}
		taskUID++;
		ItemCraftTask itemCraftTask = Pool.Get<ItemCraftTask>();
		itemCraftTask.blueprint = bp;
		if (!free)
		{
			CollectIngredients(bp, itemCraftTask, amount, owner, takeBroken: false);
		}
		itemCraftTask.endTime = 0f;
		itemCraftTask.taskUID = taskUID;
		itemCraftTask.instanceData = instanceData;
		if (itemCraftTask.instanceData != null)
		{
			itemCraftTask.instanceData.ShouldPool = false;
		}
		itemCraftTask.amount = amount;
		itemCraftTask.skinID = skinID;
		if (fromTempBlueprint != null && itemCraftTask.takenItems != null)
		{
			fromTempBlueprint.RemoveFromContainer();
			itemCraftTask.takenItems.Add(fromTempBlueprint);
			itemCraftTask.conditionScale = 0.5f;
		}
		object obj = Interface.CallHook("OnItemCraft", (object)itemCraftTask, (object)owner, (object)fromTempBlueprint);
		if (obj is bool)
		{
			if (fromTempBlueprint != null && itemCraftTask.instanceData != null)
			{
				fromTempBlueprint.instanceData = itemCraftTask.instanceData;
			}
			return (bool)obj;
		}
		queue.AddLast(itemCraftTask);
		if ((Object)(object)owner != (Object)null)
		{
			owner.Command("note.craft_add", itemCraftTask.taskUID, itemCraftTask.blueprint.targetItem.itemid, amount, itemCraftTask.skinID);
		}
		return true;
	}

	public void FinishCrafting(ItemCraftTask task)
	{
		//IL_0370: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_037e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0384: Unknown result type (might be due to invalid IL or missing references)
		task.amount--;
		task.numCrafted++;
		ulong skin = ItemDefinition.FindSkin(task.blueprint.targetItem.itemid, task.skinID);
		Item item2 = ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, 1, skin);
		item2.amount = task.blueprint.amountToCreate;
		int amount = item2.amount;
		_ = owner.currentCraftLevel;
		bool inSafezone = owner.InSafeZone();
		if (item2.hasCondition && task.conditionScale != 1f)
		{
			item2.maxCondition *= task.conditionScale;
			item2.condition = item2.maxCondition;
		}
		item2.OnVirginSpawn(owner);
		item2.SetItemOwnership(owner, ItemOwnershipPhrases.CraftedPhrase);
		foreach (ItemAmount ingredient in task.blueprint.GetIngredients())
		{
			int num = (int)ingredient.amount;
			if (task.takenItems == null)
			{
				continue;
			}
			foreach (Item takenItem in task.takenItems)
			{
				if ((Object)(object)takenItem.info == (Object)(object)ingredient.itemDef)
				{
					int num2 = Mathf.Min(takenItem.amount, num);
					Analytics.Azure.OnCraftMaterialConsumed(takenItem.info.shortname, num, base.baseEntity, task.workbenchEntity, inSafezone, item2.info.shortname);
					takenItem.UseItem(num);
					num -= num2;
				}
				if (num <= 0)
				{
					break;
				}
			}
		}
		task.takenItems?.RemoveAll((Item item) => item.amount == 0);
		Analytics.Azure.OnCraftItem(item2.info.shortname, item2.amount, base.baseEntity, task.workbenchEntity, inSafezone);
		owner.Command("note.craft_done", task.taskUID, 1, task.amount);
		Interface.CallHook("OnItemCraftFinished", (object)task, (object)item2, (object)this);
		if (task.instanceData != null)
		{
			item2.instanceData = task.instanceData;
		}
		if (!string.IsNullOrEmpty(task.blueprint.UnlockAchievment))
		{
			owner.GiveAchievement(task.blueprint.UnlockAchievment);
		}
		owner.ProcessMissionEvent(BaseMission.MissionEventType.CRAFT_ITEM, item2.info.itemid, amount);
		if (owner.inventory.GiveItem(item2))
		{
			owner.Command("note.inv", item2.info.itemid, amount);
			return;
		}
		ItemContainer itemContainer = containers.First();
		owner.Command("note.inv", item2.info.itemid, amount);
		owner.Command("note.inv", item2.info.itemid, -item2.amount);
		item2.Drop(itemContainer.dropPosition, itemContainer.dropVelocity);
	}

	public bool CancelTask(int iID)
	{
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		if (queue.Count == 0)
		{
			return false;
		}
		if ((Object)(object)owner != (Object)null && owner.IsTransferring())
		{
			return false;
		}
		ItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) => x.taskUID == iID && !x.cancelled);
		if (itemCraftTask == null)
		{
			return false;
		}
		itemCraftTask.cancelled = true;
		if ((Object)(object)owner == (Object)null)
		{
			return true;
		}
		Interface.CallHook("OnItemCraftCancelled", (object)itemCraftTask, (object)this);
		owner.Command("note.craft_done", itemCraftTask.taskUID, 0);
		if (itemCraftTask.takenItems != null && itemCraftTask.takenItems.Count > 0)
		{
			foreach (Item takenItem in itemCraftTask.takenItems)
			{
				if (takenItem != null && takenItem.amount > 0)
				{
					if (takenItem.IsBlueprint() && (Object)(object)takenItem.blueprintTargetDef == (Object)(object)itemCraftTask.blueprint.targetItem)
					{
						takenItem.UseItem(itemCraftTask.numCrafted);
					}
					if (takenItem.amount > 0 && !takenItem.MoveToContainer(owner.inventory.containerMain))
					{
						takenItem.Drop(owner.inventory.containerMain.dropPosition + Random.value * Vector3.down + Random.insideUnitSphere, owner.inventory.containerMain.dropVelocity);
						owner.Command("note.inv", takenItem.info.itemid, -takenItem.amount);
					}
				}
			}
			itemCraftTask.takenItems.Clear();
		}
		return true;
	}

	public bool CancelBlueprint(int itemid)
	{
		if (queue.Count == 0)
		{
			return false;
		}
		if ((Object)(object)owner != (Object)null && owner.IsTransferring())
		{
			return false;
		}
		ItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) => x.blueprint.targetItem.itemid == itemid && !x.cancelled);
		if (itemCraftTask == null)
		{
			return false;
		}
		return CancelTask(itemCraftTask.taskUID);
	}

	public void CancelAll()
	{
		foreach (ItemCraftTask item in queue)
		{
			CancelTask(item.taskUID);
		}
	}

	private bool DoesHaveOKConditionItem(int item, int iAmount = 1)
	{
		int num = 0;
		foreach (ItemContainer container in containers)
		{
			num += container.GetOkConditionAmount(item, onlyUsableAmounts: true);
		}
		return num >= iAmount;
	}

	public bool DoesHaveUsableItem(int item, int iAmount)
	{
		int num = 0;
		foreach (ItemContainer container in containers)
		{
			num += container.GetAmount(item, onlyUsableAmounts: true);
		}
		return num >= iAmount;
	}

	public bool CanCraft(ItemBlueprint bp, int amount = 1, bool free = false)
	{
		if (!bp.targetItem.IsAllowed((EraRestriction)4))
		{
			return false;
		}
		if ((Object)(object)base.baseEntity != (Object)null && base.baseEntity.IsRestrained)
		{
			Handcuffs restraintItem = base.baseEntity.Belt.GetRestraintItem();
			if ((Object)(object)restraintItem != (Object)null && restraintItem.BlockCrafting)
			{
				return false;
			}
		}
		float num = (float)amount / (float)bp.targetItem.craftingStackable;
		foreach (ItemCraftTask item in queue)
		{
			if (!item.cancelled)
			{
				num += (float)item.amount / (float)item.blueprint.targetItem.craftingStackable;
			}
		}
		if (num > 8f)
		{
			return false;
		}
		object obj = Interface.CallHook("CanCraft", (object)this, (object)bp, (object)amount, (object)free);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (amount < 1 || amount > bp.targetItem.craftingStackable)
		{
			return false;
		}
		foreach (ItemAmount ingredient in bp.GetIngredients())
		{
			if (!DoesHaveUsableItem(ingredient.itemid, (int)ingredient.amount * amount))
			{
				return false;
			}
			if (ingredient.itemDef.condition.enabled && !DoesHaveOKConditionItem(ingredient.itemid, (int)ingredient.amount * amount))
			{
				return false;
			}
		}
		return true;
	}

	public bool CanCraft(ItemDefinition def, int amount = 1, bool free = false)
	{
		ItemBlueprint component = ((Component)def).GetComponent<ItemBlueprint>();
		if (CanCraft(component, amount, free))
		{
			return true;
		}
		return false;
	}

	public bool FastTrackTask(int taskID)
	{
		int taskID2 = taskID;
		if (queue.Count == 0)
		{
			return false;
		}
		if ((Object)(object)owner != (Object)null && owner.IsTransferring())
		{
			return false;
		}
		ItemCraftTask value = queue.First.Value;
		if (value == null)
		{
			return false;
		}
		ItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) => x.taskUID == taskID2 && !x.cancelled);
		if (itemCraftTask == null)
		{
			return false;
		}
		if (itemCraftTask == value)
		{
			return false;
		}
		object obj = Interface.CallHook("CanFastTrackCraftTask", (object)this, (object)itemCraftTask, (object)taskID);
		if (obj is bool)
		{
			return (bool)obj;
		}
		value.endTime = 0f;
		queue.Remove(itemCraftTask);
		queue.AddFirst(itemCraftTask);
		owner.Command("note.craft_fasttracked", taskID2);
		return true;
	}

	public ItemCrafter Save()
	{
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		ItemCrafter val = Pool.Get<ItemCrafter>();
		val.queue = Pool.Get<List<Task>>();
		foreach (ItemCraftTask item in queue)
		{
			Task val2 = Pool.Get<Task>();
			val2.itemID = item.blueprint.targetItem.itemid;
			val2.remainingTime = ((item.endTime > 0f) ? (item.endTime - Time.realtimeSinceStartup) : 0f);
			val2.taskUID = item.taskUID;
			val2.cancelled = item.cancelled;
			InstanceData instanceData = item.instanceData;
			val2.instanceData = ((instanceData != null) ? instanceData.Copy() : null);
			val2.amount = item.amount;
			val2.skinID = item.skinID;
			val2.takenItems = SaveItems(item.takenItems);
			val2.numCrafted = item.numCrafted;
			val2.conditionScale = item.conditionScale;
			val2.workbenchEntity = (NetworkableId)(item.workbenchEntity.IsValid() ? item.workbenchEntity.net.ID : default(NetworkableId));
			val.queue.Add(val2);
		}
		return val;
		static List<Item> SaveItems(List<Item> items)
		{
			List<Item> list = Pool.Get<List<Item>>();
			if (items != null)
			{
				foreach (Item item2 in items)
				{
					list.Add(item2.Save(bIncludeContainer: true));
				}
			}
			return list;
		}
	}

	public void Load(ItemCrafter proto)
	{
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		if (proto?.queue == null)
		{
			return;
		}
		queue.Clear();
		ItemBlueprint blueprint = default(ItemBlueprint);
		foreach (Task item in proto.queue)
		{
			ItemDefinition itemDefinition = ItemManager.FindItemDefinition(item.itemID);
			if ((Object)(object)itemDefinition == (Object)null || !((Component)itemDefinition).TryGetComponent<ItemBlueprint>(ref blueprint))
			{
				Debug.LogWarning((object)$"ItemCrafter has queue task for item ID {item.itemID}, but it was not found or has no blueprint. Skipping it");
				continue;
			}
			ItemCraftTask itemCraftTask = Pool.Get<ItemCraftTask>();
			itemCraftTask.blueprint = blueprint;
			itemCraftTask.endTime = ((item.remainingTime > 0f) ? (Time.realtimeSinceStartup + item.remainingTime) : 0f);
			itemCraftTask.taskUID = item.taskUID;
			itemCraftTask.cancelled = item.cancelled;
			InstanceData instanceData = item.instanceData;
			itemCraftTask.instanceData = ((instanceData != null) ? instanceData.Copy() : null);
			itemCraftTask.amount = item.amount;
			itemCraftTask.skinID = item.skinID;
			itemCraftTask.takenItems = LoadItems(item.takenItems);
			itemCraftTask.numCrafted = item.numCrafted;
			itemCraftTask.conditionScale = item.conditionScale;
			itemCraftTask.workbenchEntity = new EntityRef<BaseEntity>
			{
				uid = item.workbenchEntity
			}.Get(serverside: true);
			queue.AddLast(itemCraftTask);
			taskUID = Mathf.Max(taskUID, itemCraftTask.taskUID);
		}
		static List<Item> LoadItems(List<Item> itemProtos)
		{
			List<Item> list = new List<Item>();
			if (itemProtos != null)
			{
				foreach (Item itemProto in itemProtos)
				{
					list.Add(ItemManager.Load(itemProto, null, isServer: true));
				}
			}
			return list;
		}
	}

	public void SendToOwner()
	{
		if (!owner.IsValid() || !owner.IsConnected)
		{
			return;
		}
		foreach (ItemCraftTask item in queue)
		{
			owner.Command("note.craft_add", item.taskUID, item.blueprint.targetItem.itemid, item.amount, item.skinID);
		}
	}
}


using UnityEngine;
using UnityEngine.Events;

public class ItemEventFlag : MonoBehaviour, IItemUpdate
{
	public Item.Flag flag;

	public UnityEvent onEnabled = new UnityEvent();

	public UnityEvent onDisable = new UnityEvent();

	internal bool firstRun = true;

	internal bool lastState;

	public virtual void OnItemUpdate(Item item)
	{
		bool flag = item.HasFlag(this.flag);
		if (firstRun || flag != lastState)
		{
			if (flag)
			{
				onEnabled.Invoke();
			}
			else
			{
				onDisable.Invoke();
			}
			lastState = flag;
			firstRun = false;
		}
	}
}


using System.Collections.Generic;
using Rust;

public interface IAmmoContainer
{
	Item FindAmmo(AmmoTypes ammoType);

	void FindAmmo(List<Item> list, AmmoTypes ammoType);

	Item FindItemByItemID(int id);

	void FindItemsByItemID(List<Item> list, int id);

	Item FindItemByItemName(string name);

	bool HasAmmo(AmmoTypes ammoType);

	Item FindItemByUID(ItemId iUID);

	bool GiveItem(Item item, ItemContainer container = null);
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class Item : IPooled
{
	[Flags]
	public enum Flag
	{
		None = 0,
		Placeholder = 1,
		IsOn = 2,
		OnFire = 4,
		IsLocked = 8,
		Cooking = 0x10,
		Radioactive = 0x20,
		Refrigerated = 0x40
	}

	private const string DefaultArmourBreakEffectPath = "assets/bundled/prefabs/fx/armor_break.prefab";

	public float _condition;

	public float _maxCondition = 100f;

	public ItemDefinition info;

	public ItemId uid;

	public bool dirty;

	public int amount = 1;

	public int position;

	public float busyTime;

	public float removeTime;

	public float fuel;

	public bool isServer;

	public InstanceData instanceData;

	public ulong skin;

	public string name;

	public string streamerName;

	public string text;

	public float cookTimeLeft;

	public float radioactivity;

	public List<ItemOwnershipShare> ownershipShares;

	public Flag flags;

	public ItemContainer contents;

	public ItemContainer parent;

	private EntityRef worldEnt;

	private EntityRef heldEntity;

	public float condition
	{
		get
		{
			return _condition;
		}
		set
		{
			float num = _condition;
			_condition = Mathf.Clamp(value, 0f, maxCondition);
			if (isServer && Mathf.Ceil(value) != Mathf.Ceil(num))
			{
				MarkDirty();
			}
		}
	}

	public float maxCondition
	{
		get
		{
			return _maxCondition;
		}
		set
		{
			_maxCondition = Mathf.Clamp(value, 0f, info.condition.max);
			if (isServer)
			{
				MarkDirty();
			}
		}
	}

	public float maxConditionNormalized => _maxCondition / info.condition.max;

	public float conditionNormalized
	{
		get
		{
			if (!hasCondition)
			{
				return 1f;
			}
			return condition / maxCondition;
		}
		set
		{
			if (hasCondition)
			{
				condition = value * maxCondition;
			}
		}
	}

	public bool hasCondition
	{
		get
		{
			if ((Object)(object)info != (Object)null && info.condition.enabled)
			{
				return info.condition.max > 0f;
			}
			return false;
		}
	}

	public bool isBroken
	{
		get
		{
			if (hasCondition)
			{
				return condition <= 0f;
			}
			return false;
		}
	}

	public int despawnMultiplier
	{
		get
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Expected I4, but got Unknown
			Rarity val = info.despawnRarity;
			if ((int)val == 0)
			{
				val = info.rarity;
			}
			if (!((Object)(object)info != (Object)null))
			{
				return 1;
			}
			return Mathf.Clamp((val - 1) * 4, 1, 100);
		}
	}

	public ItemDefinition blueprintTargetDef
	{
		get
		{
			if (!IsBlueprint())
			{
				return null;
			}
			return ItemManager.FindItemDefinition(blueprintTarget);
		}
	}

	public int blueprintTarget
	{
		get
		{
			if (instanceData == null)
			{
				return 0;
			}
			return instanceData.blueprintTarget;
		}
		set
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Expected O, but got Unknown
			if (instanceData == null)
			{
				instanceData = new InstanceData();
			}
			instanceData.ShouldPool = false;
			instanceData.blueprintTarget = value;
		}
	}

	public int blueprintAmount
	{
		get
		{
			return amount;
		}
		set
		{
			amount = value;
		}
	}

	public Item parentItem
	{
		get
		{
			if (parent == null)
			{
				return null;
			}
			return parent.parent;
		}
	}

	public float temperature
	{
		get
		{
			if (parent != null)
			{
				return parent.GetTemperature(position);
			}
			return 15f;
		}
	}

	public BaseEntity.TraitFlag Traits => info.Traits;

	public event Action<Item> OnDirty;

	public event Action<Item, float> onCycle;

	public void LoseCondition(float amount)
	{
		if (hasCondition && !Debugging.disablecondition && Interface.CallHook("IOnLoseCondition", (object)this, (object)amount) == null)
		{
			float num = condition;
			condition -= amount;
			if (Global.developer > 0)
			{
				Debug.Log((object)(info.shortname + " was damaged by: " + amount + "cond is: " + condition + "/" + maxCondition));
			}
			if (condition <= 0f && condition < num)
			{
				OnBroken();
			}
		}
	}

	public void RepairCondition(float amount)
	{
		if (hasCondition)
		{
			condition += amount;
		}
	}

	public void DoRepair(float maxLossFraction)
	{
		if (hasCondition)
		{
			if (info.condition.maintainMaxCondition)
			{
				maxLossFraction = 0f;
			}
			float num = 1f - condition / maxCondition;
			maxLossFraction = Mathf.Clamp(maxLossFraction, 0f, info.condition.max);
			maxCondition *= 1f - maxLossFraction * num;
			condition = maxCondition;
			BaseEntity baseEntity = GetHeldEntity();
			if ((Object)(object)baseEntity != (Object)null)
			{
				baseEntity.SetFlag(BaseEntity.Flags.Broken, b: false);
			}
			if (Global.developer > 0)
			{
				Debug.Log((object)(info.shortname + " was repaired! new cond is: " + condition + "/" + maxCondition));
			}
		}
	}

	public ItemContainer GetRootContainer()
	{
		ItemContainer itemContainer = parent;
		int num = 0;
		while (itemContainer != null && num <= 8 && itemContainer.parent != null && itemContainer.parent.parent != null)
		{
			itemContainer = itemContainer.parent.parent;
			num++;
		}
		if (num == 8)
		{
			Debug.LogWarning((object)"GetRootContainer failed with 8 iterations");
		}
		return itemContainer;
	}

	public virtual void OnBroken()
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		if (!hasCondition)
		{
			return;
		}
		BaseEntity baseEntity = GetHeldEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			baseEntity.SetFlag(BaseEntity.Flags.Broken, b: true);
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (Object.op_Implicit((Object)(object)ownerPlayer))
		{
			if (ownerPlayer.GetActiveItem() == this)
			{
				Effect.server.Run("assets/bundled/prefabs/fx/item_break.prefab", ownerPlayer, 0u, Vector3.zero, Vector3.zero);
				ownerPlayer.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ActiveItemBroken, false);
			}
			ItemModWearable itemModWearable = default(ItemModWearable);
			if (((Component)info).TryGetComponent<ItemModWearable>(ref itemModWearable) && ownerPlayer.inventory.containerWear.itemList.Contains(this))
			{
				if (itemModWearable.breakEffect.isValid)
				{
					Effect.server.Run(itemModWearable.breakEffect.resourcePath, ownerPlayer, 0u, Vector3.zero, Vector3.zero);
				}
				else
				{
					Effect.server.Run("assets/bundled/prefabs/fx/armor_break.prefab", ownerPlayer, 0u, Vector3.zero, Vector3.zero);
				}
			}
		}
		if (info.condition.breakEffect != null && info.condition.breakEffect.isValid)
		{
			BasePlayer playerOwner = GetRootContainer().playerOwner;
			if ((Object)(object)playerOwner != (Object)null)
			{
				Effect.server.Run(info.condition.breakEffect.resourcePath, playerOwner, 0u, Vector3.zero, Vector3.zero);
			}
		}
		if ((!info.condition.repairable && !Object.op_Implicit((Object)(object)((Component)info).GetComponent<ItemModRepair>())) || maxCondition <= 5f)
		{
			UnloadAmmo();
			Remove();
		}
		else if (parent != null && parent.HasFlag(ItemContainer.Flag.NoBrokenItems))
		{
			ItemContainer rootContainer = GetRootContainer();
			if (rootContainer.HasFlag(ItemContainer.Flag.NoBrokenItems))
			{
				Remove();
			}
			else
			{
				BasePlayer playerOwner2 = rootContainer.playerOwner;
				if ((Object)(object)playerOwner2 != (Object)null && !MoveToContainer(playerOwner2.inventory.containerMain))
				{
					Drop(((Component)playerOwner2).transform.position, playerOwner2.eyes.BodyForward() * 1.5f);
				}
			}
		}
		ItemModEntity itemModEntity = default(ItemModEntity);
		if (((Component)info).TryGetComponent<ItemModEntity>(ref itemModEntity) && itemModEntity.destroyEntityWhenBroken)
		{
			baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);
		}
		MarkDirty();
	}

	void IPooled.EnterPool()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		info = null;
		uid = default(ItemId);
		dirty = false;
		amount = 1;
		position = 0;
		busyTime = 0f;
		removeTime = 0f;
		fuel = 0f;
		isServer = false;
		instanceData = null;
		skin = 0uL;
		name = null;
		streamerName = null;
		text = null;
		cookTimeLeft = 0f;
		radioactivity = 0f;
		flags = Flag.None;
		if (contents != null)
		{
			Pool.Free<ItemContainer>(ref contents);
		}
		parent = null;
		heldEntity = default(EntityRef);
		worldEnt = default(EntityRef);
		this.onCycle = null;
		this.OnDirty = null;
		_condition = 0f;
		_maxCondition = 100f;
		ownershipShares = null;
	}

	void IPooled.LeavePool()
	{
	}

	public string GetName(bool? streamerModeOverride = null)
	{
		if (streamerModeOverride.HasValue)
		{
			if (!streamerModeOverride.Value)
			{
				return name;
			}
			return streamerName ?? name;
		}
		return name;
	}

	public bool IsBlueprint()
	{
		return blueprintTarget != 0;
	}

	public bool HasFlag(Flag f)
	{
		return (flags & f) == f;
	}

	public void SetFlag(Flag f, bool b)
	{
		if (b)
		{
			flags |= f;
		}
		else
		{
			flags &= ~f;
		}
	}

	public bool IsOn()
	{
		return HasFlag(Flag.IsOn);
	}

	public bool IsOnFire()
	{
		return HasFlag(Flag.OnFire);
	}

	public bool IsCooking()
	{
		return HasFlag(Flag.Cooking);
	}

	public bool IsLocked()
	{
		if (!HasFlag(Flag.IsLocked))
		{
			if (parent != null)
			{
				return parent.IsLocked();
			}
			return false;
		}
		return true;
	}

	public bool IsRadioactive()
	{
		return HasFlag(Flag.Radioactive);
	}

	public bool IsRefrigerated()
	{
		return HasFlag(Flag.Refrigerated);
	}

	public void MarkDirty()
	{
		OnChanged();
		dirty = true;
		if (parent != null)
		{
			parent.MarkDirty();
		}
		if (this.OnDirty != null)
		{
			this.OnDirty(this);
		}
	}

	public void OnChanged()
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].OnChanged(this);
		}
		if (contents != null)
		{
			contents.OnChanged();
		}
	}

	public void CollectedForCrafting(BasePlayer crafter)
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].CollectedForCrafting(this, crafter);
		}
	}

	public void ReturnedFromCancelledCraft(BasePlayer crafter)
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].ReturnedFromCancelledCraft(this, crafter);
		}
	}

	public void Initialize(ItemDefinition template)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		uid = new ItemId(Net.sv.TakeUID());
		float num = (maxCondition = info.condition.max);
		condition = num;
		SetRadioactivity(template);
		InitializeItemOwnership();
		OnItemCreated();
	}

	public void OnItemCreated()
	{
		this.onCycle = null;
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].OnItemCreated(this);
		}
	}

	public void OnVirginSpawn(BasePlayer creatingPlayer = null)
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].OnVirginItem(this, creatingPlayer);
		}
	}

	public float GetDespawnDuration()
	{
		if (info.quickDespawn)
		{
			return ConVar.Server.itemdespawn_quick;
		}
		int num = 0;
		if (contents != null && contents.itemList != null)
		{
			foreach (Item item in contents.itemList)
			{
				num += item.despawnMultiplier;
			}
		}
		return (float)Mathf.Min(Mathf.Max(despawnMultiplier, num), ConVar.Server.itemdespawn_container_max_multiplier) * ConVar.Server.itemdespawn;
	}

	public void RemoveFromWorld()
	{
		BaseEntity worldEntity = GetWorldEntity();
		if ((Object)(object)worldEntity == (Object)null)
		{
			return;
		}
		SetWorldEntity(null);
		OnRemovedFromWorld();
		if (contents != null)
		{
			contents.OnRemovedFromWorld();
		}
		if (worldEntity.IsValid())
		{
			if (worldEntity is WorldItem worldItem)
			{
				worldItem.RemoveItem();
			}
			worldEntity.Kill();
		}
	}

	public void OnRemovedFromWorld()
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].OnRemovedFromWorld(this);
		}
	}

	public void RemoveFromContainer()
	{
		if (parent != null)
		{
			SetParent(null);
		}
	}

	public bool DoItemSlotsConflict(Item other)
	{
		return (info.occupySlots & other.info.occupySlots) != 0;
	}

	public void AddItemOwnership(string username, string reason, int shareAmount)
	{
		if (ownershipShares == null)
		{
			return;
		}
		if (ownershipShares.Count > 0)
		{
			for (int i = 0; i < ownershipShares.Count; i++)
			{
				ItemOwnershipShare value = ownershipShares[i];
				if (value.username == username && value.reason == reason)
				{
					value.amount += shareAmount;
					ownershipShares[i] = value;
					shareAmount = 0;
					break;
				}
			}
		}
		if (shareAmount > 0)
		{
			ItemOwnershipShare itemOwnershipShare = default(ItemOwnershipShare);
			itemOwnershipShare.username = username;
			itemOwnershipShare.reason = reason;
			itemOwnershipShare.amount = shareAmount;
			ItemOwnershipShare item = itemOwnershipShare;
			ownershipShares.Add(item);
		}
		MarkDirty();
	}

	public void MigrateItemOwnership(Item targetItem, int amount)
	{
		if (ownershipShares != null && targetItem.ownershipShares != null)
		{
			TransferOwnership(targetItem, amount);
		}
	}

	public ItemOwnershipShare TakeOwnershipShare()
	{
		if (!HasItemOwnership())
		{
			return default(ItemOwnershipShare);
		}
		ItemOwnershipShare itemOwnershipShare = ownershipShares[0];
		itemOwnershipShare.amount--;
		ownershipShares[0] = itemOwnershipShare;
		if (itemOwnershipShare.amount <= 0)
		{
			ownershipShares.RemoveAt(0);
		}
		return itemOwnershipShare;
	}

	public void ReduceItemOwnership(int amount)
	{
		if (ownershipShares != null)
		{
			TransferOwnership(null, amount);
		}
	}

	private void TransferOwnership(Item targetItem, int amount)
	{
		for (int num = ownershipShares.Count - 1; num >= 0; num--)
		{
			if (amount <= 0)
			{
				return;
			}
			ItemOwnershipShare value = ownershipShares[num];
			int num2 = Mathf.Min(value.amount, amount);
			targetItem?.AddItemOwnership(value.username, value.reason, num2);
			amount -= num2;
			value.amount -= num2;
			if (value.amount == 0)
			{
				ownershipShares.RemoveAt(num);
			}
			else
			{
				ownershipShares[num] = value;
			}
		}
		MarkDirty();
	}

	public bool HasItemOwnership()
	{
		if (ownershipShares != null)
		{
			return ownershipShares.Count > 0;
		}
		return false;
	}

	public void AddItemOwnership(BasePlayer player, Phrase reason)
	{
		AddItemOwnership(((Object)(object)player != (Object)null && !player.IsDestroyed) ? player.displayName : "", reason.token, amount);
	}

	public Item SetItemOwnership(BasePlayer player, Phrase reason)
	{
		return SetItemOwnership(((Object)(object)player != (Object)null && !player.IsDestroyed) ? player.displayName : "", reason.token);
	}

	public Item SetItemOwnership(ItemOwnershipShare ownership)
	{
		return SetItemOwnership(ownership.username, ownership.reason);
	}

	public Item SetItemOwnership(BasePlayer player, string reason)
	{
		return SetItemOwnership(((Object)(object)player != (Object)null && !player.IsDestroyed) ? player.displayName : "", reason);
	}

	public Item SetItemOwnership(string username, Phrase reason)
	{
		return SetItemOwnership(username, reason?.token ?? "");
	}

	public Item SetItemOwnership(string username, string reason)
	{
		if (ownershipShares == null)
		{
			return this;
		}
		ownershipShares?.Clear();
		AddItemOwnership(username, reason, amount);
		return this;
	}

	public void InitializeItemOwnership()
	{
		if (!((Object)(object)info == (Object)null) && info.SupportsItemOwnership() && ownershipShares == null)
		{
			ownershipShares = Pool.Get<List<ItemOwnershipShare>>();
		}
	}

	public void SetParent(ItemContainer target)
	{
		if (target == parent)
		{
			return;
		}
		if (parent != null)
		{
			parent.Remove(this);
			parent = null;
		}
		if (target == null)
		{
			position = 0;
		}
		else
		{
			parent = target;
			if (!parent.Insert(this))
			{
				Remove();
				Debug.LogError((object)"Item.SetParent caused remove - this shouldn't ever happen");
			}
		}
		MarkDirty();
		RecalulateParentEntity(children: false);
		if (parent != null)
		{
			ItemContainer itemContainer = parent;
			BasePlayer basePlayer = null;
			do
			{
				basePlayer = itemContainer.GetOwnerPlayer();
				itemContainer = itemContainer?.parent?.parent;
			}
			while (itemContainer != null && (Object)(object)basePlayer == (Object)null);
			if ((Object)(object)basePlayer != (Object)null)
			{
				if (!basePlayer.enableSaving)
				{
					ForbidHeldEntitySaving();
				}
				else
				{
					RestoreHeldEntitySaving();
				}
			}
		}
		else
		{
			RestoreHeldEntitySaving();
		}
	}

	public void RecalulateParentEntity(bool children)
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].OnParentChanged(this);
		}
		if (!children || contents == null)
		{
			return;
		}
		foreach (Item item in contents.itemList)
		{
			item.RecalulateParentEntity(children: false);
		}
	}

	private void ForbidHeldEntitySaving()
	{
		if (heldEntity.IsValid(serverside: true))
		{
			heldEntity.Get(serverside: true).EnableSaving(wants: false);
		}
		if (contents == null)
		{
			return;
		}
		foreach (Item item in contents.itemList)
		{
			item.ForbidHeldEntitySaving();
		}
	}

	private void RestoreHeldEntitySaving()
	{
		if (heldEntity.IsValid(serverside: true))
		{
			heldEntity.Get(serverside: true).RestoreCanSave();
		}
		if (contents == null)
		{
			return;
		}
		foreach (Item item in contents.itemList)
		{
			item.RestoreHeldEntitySaving();
		}
	}

	public void OnAttacked(HitInfo hitInfo)
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].OnAttacked(this, hitInfo);
		}
	}

	public BaseEntity GetEntityOwner()
	{
		return parent?.GetEntityOwner();
	}

	public bool IsChildContainer(ItemContainer c)
	{
		if (contents == null)
		{
			return false;
		}
		if (contents == c)
		{
			return true;
		}
		foreach (Item item in contents.itemList)
		{
			if (item.IsChildContainer(c))
			{
				return true;
			}
		}
		return false;
	}

	public bool CanMoveTo(ItemContainer newcontainer, int iTargetPos = -1)
	{
		if (IsChildContainer(newcontainer))
		{
			return false;
		}
		if (newcontainer.CanAcceptItem(this, iTargetPos) != 0)
		{
			return false;
		}
		if (iTargetPos >= newcontainer.capacity)
		{
			return false;
		}
		if (parent != null && newcontainer == parent && iTargetPos == position)
		{
			return false;
		}
		return true;
	}

	public bool MoveToContainer(ItemContainer newcontainer, int iTargetPos = -1, bool allowStack = true, bool ignoreStackLimit = false, BasePlayer sourcePlayer = null, bool allowSwap = true)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0584: Unknown result type (might be due to invalid IL or missing references)
		//IL_058a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0591: Unknown result type (might be due to invalid IL or missing references)
		//IL_0597: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("MoveToContainer", 0);
		try
		{
			BasePlayer playerOwner = newcontainer.playerOwner;
			if ((Object)(object)playerOwner != (Object)null && playerOwner.IsDead() && parent != null)
			{
				return false;
			}
			bool flag = iTargetPos == -1;
			ItemContainer itemContainer = parent;
			if (iTargetPos == -1)
			{
				if (allowStack && info.stackable > 1)
				{
					BufferList<Item> val2 = Pool.Get<BufferList<Item>>();
					newcontainer.FindItemsByItemID(info.itemid, val2);
					Enumerator<Item> enumerator = val2.GetEnumerator();
					try
					{
						while (enumerator.MoveNext())
						{
							Item current = enumerator.Current;
							if (current.position > iTargetPos && current.CanStack(this) && (ignoreStackLimit || current.amount < current.MaxStackable()))
							{
								iTargetPos = current.position;
							}
						}
					}
					finally
					{
						((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
					}
					Pool.Free<Item>(ref val2, false);
				}
				if (iTargetPos == -1 && newcontainer.GetEntityOwner(returnHeldEntity: true) is IIdealSlotEntity idealSlotEntity)
				{
					iTargetPos = idealSlotEntity.GetIdealSlot(sourcePlayer, newcontainer, this);
					if (iTargetPos == int.MinValue)
					{
						return false;
					}
				}
				if (iTargetPos == -1)
				{
					if (newcontainer == parent)
					{
						return false;
					}
					bool flag2 = newcontainer.HasFlag(ItemContainer.Flag.Clothing) && info.isWearable;
					ItemModWearable itemModWearable = info.ItemModWearable;
					for (int i = 0; i < newcontainer.capacity; i++)
					{
						Item slot = newcontainer.GetSlot(i);
						if (slot == null)
						{
							if (CanMoveTo(newcontainer, i))
							{
								iTargetPos = i;
								break;
							}
							continue;
						}
						if (flag2 && slot != null && !slot.info.ItemModWearable.CanExistWith(itemModWearable))
						{
							iTargetPos = i;
							break;
						}
						if (newcontainer.HasAvailableSlotsDefined && DoItemSlotsConflict(slot))
						{
							iTargetPos = i;
							break;
						}
					}
					if (flag2 && iTargetPos == -1)
					{
						iTargetPos = newcontainer.capacity - 1;
					}
				}
			}
			if (iTargetPos == -1)
			{
				return false;
			}
			if (!CanMoveTo(newcontainer, iTargetPos))
			{
				return false;
			}
			if (iTargetPos >= 0 && newcontainer.SlotTaken(this, iTargetPos))
			{
				Item slot2 = newcontainer.GetSlot(iTargetPos);
				if (slot2 == this)
				{
					return false;
				}
				if (allowStack && slot2 != null)
				{
					int num = slot2.MaxStackable();
					if (slot2.CanStack(this))
					{
						if (ignoreStackLimit)
						{
							num = int.MaxValue;
						}
						if (slot2.amount >= num)
						{
							return false;
						}
						int num2 = Mathf.Min(num - slot2.amount, amount);
						slot2.amount += num2;
						if (slot2.instanceData != null && instanceData != null && Object.op_Implicit((Object)(object)((Component)info).GetComponent<ItemModFoodSpoiling>()))
						{
							slot2.instanceData.dataFloat = Mathf.Min(slot2.instanceData.dataFloat, instanceData.dataFloat);
						}
						newcontainer.onItemAddedToStack?.Invoke(slot2, num2);
						amount -= num2;
						slot2.MarkDirty();
						Interface.CallHook("OnItemStacked", (object)slot2, (object)this, (object)newcontainer, (object)num2);
						MarkDirty();
						MigrateItemOwnership(slot2, num2);
						if (amount <= 0)
						{
							RemoveFromWorld();
							RemoveFromContainer();
							Remove();
							return true;
						}
						if (flag)
						{
							return MoveToContainer(newcontainer, -1, allowStack, ignoreStackLimit, sourcePlayer);
						}
						return false;
					}
				}
				if (parent != null && allowSwap && slot2 != null)
				{
					ItemContainer itemContainer2 = parent;
					int iTargetPos2 = position;
					ItemContainer newcontainer2 = slot2.parent;
					int num3 = slot2.position;
					if (!slot2.CanMoveTo(itemContainer2, iTargetPos2))
					{
						return false;
					}
					if (itemContainer2.maxStackSize > 0 && slot2.amount > itemContainer2.maxStackSize)
					{
						Item item = slot2.SplitItem(slot2.amount - itemContainer2.maxStackSize);
						if (item == null || !item.MoveToContainer(newcontainer2, -1, allowStack: false, ignoreStackLimit: false, sourcePlayer, allowSwap: false))
						{
							slot2.amount += item.amount;
							item.MigrateItemOwnership(slot2, item.amount);
							item.Remove();
							return false;
						}
					}
					BaseEntity entityOwner = GetEntityOwner();
					BaseEntity entityOwner2 = slot2.GetEntityOwner();
					RemoveFromContainer();
					slot2.RemoveFromContainer();
					RemoveConflictingSlots(newcontainer, entityOwner, sourcePlayer);
					slot2.RemoveConflictingSlots(itemContainer2, entityOwner2, sourcePlayer);
					if (!slot2.MoveToContainer(itemContainer2, iTargetPos2, allowStack: true, ignoreStackLimit: false, sourcePlayer) || !MoveToContainer(newcontainer, iTargetPos, allowStack: true, ignoreStackLimit: false, sourcePlayer))
					{
						RemoveFromContainer();
						slot2.RemoveFromContainer();
						SetParent(itemContainer2);
						position = iTargetPos2;
						slot2.SetParent(newcontainer2);
						slot2.position = num3;
						return true;
					}
					return true;
				}
				return false;
			}
			if (parent == newcontainer)
			{
				if (iTargetPos >= 0 && iTargetPos != position && !parent.SlotTaken(this, iTargetPos))
				{
					newcontainer.onItemPositionChanged?.Invoke(this, position, iTargetPos);
					position = iTargetPos;
					MarkDirty();
					return true;
				}
				return false;
			}
			if (newcontainer.maxStackSize > 0 && newcontainer.maxStackSize < amount)
			{
				Item item2 = SplitItem(newcontainer.maxStackSize);
				if (item2 != null && !item2.MoveToContainer(newcontainer, iTargetPos, allowStack: false, ignoreStackLimit: false, sourcePlayer) && (itemContainer == null || !item2.MoveToContainer(itemContainer, -1, allowStack: true, ignoreStackLimit: false, sourcePlayer)))
				{
					DroppedItem droppedItem = item2.Drop(newcontainer.dropPosition, newcontainer.dropVelocity) as DroppedItem;
					if ((Object)(object)droppedItem != (Object)null)
					{
						droppedItem.DroppedBy = sourcePlayer?.userID ?? ((EncryptedValue<ulong>)0uL);
					}
				}
				Interface.CallHook("OnItemStacked", (object)item2, (object)this, (object)newcontainer);
				return true;
			}
			if (!newcontainer.CanAccept(this))
			{
				return false;
			}
			BaseEntity entityOwner3 = GetEntityOwner();
			RemoveFromContainer();
			RemoveFromWorld();
			RemoveConflictingSlots(newcontainer, entityOwner3, sourcePlayer);
			position = iTargetPos;
			SetParent(newcontainer);
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void RemoveConflictingSlots(ItemContainer container, BaseEntity entityOwner, BasePlayer sourcePlayer)
	{
		if (!isServer || !container.HasAvailableSlotsDefined)
		{
			return;
		}
		List<Item> list = Pool.Get<List<Item>>();
		list.AddRange(container.itemList);
		foreach (Item item in list)
		{
			if (item.DoItemSlotsConflict(this))
			{
				item.RemoveFromContainer();
				if (entityOwner is BasePlayer basePlayer)
				{
					basePlayer.GiveItem(item);
				}
				else if (entityOwner is IItemContainerEntity itemContainerEntity)
				{
					item.MoveToContainer(itemContainerEntity.inventory, -1, allowStack: true, ignoreStackLimit: false, sourcePlayer);
				}
			}
		}
		Pool.Free<Item>(ref list, false);
	}

	public BaseEntity CreateWorldObject(Vector3 pos, Quaternion rotation = default(Quaternion), BaseEntity parentEnt = null, uint parentBone = 0u)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity worldEntity = GetWorldEntity();
		if ((Object)(object)worldEntity != (Object)null)
		{
			return worldEntity;
		}
		worldEntity = GameManager.server.CreateEntity("assets/prefabs/misc/burlap sack/generic_world.prefab", pos, rotation);
		if ((Object)(object)worldEntity == (Object)null)
		{
			Debug.LogWarning((object)"Couldn't create world object for prefab: items/generic_world");
			return null;
		}
		WorldItem worldItem = worldEntity as WorldItem;
		if ((Object)(object)worldItem != (Object)null)
		{
			worldItem.InitializeItem(this);
		}
		if ((Object)(object)parentEnt != (Object)null)
		{
			worldEntity.SetParent(parentEnt, parentBone);
		}
		worldEntity.Spawn();
		SetWorldEntity(worldEntity);
		return GetWorldEntity();
	}

	public BaseEntity Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation = default(Quaternion))
	{
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		ulong droppedBy = GetRootContainer()?.playerOwner?.userID ?? ((EncryptedValue<ulong>)0uL);
		RemoveFromWorld();
		if (info.AlignWorldModelOnDrop)
		{
			Quaternion val = Quaternion.LookRotation(((Vector3)(ref vVelocity)).normalized, Vector3.up);
			rotation = Quaternion.Euler(0f, ((Quaternion)(ref val)).eulerAngles.y, 0f);
			rotation = Quaternion.Euler(info.WorldModelDropOffset) * rotation;
		}
		BaseEntity baseEntity = null;
		if (vPos != Vector3.zero && !info.HasFlag(ItemDefinition.Flag.NoDropping))
		{
			baseEntity = CreateWorldObject(vPos, rotation);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.SetVelocity(vVelocity);
			}
			if (baseEntity is DroppedItem droppedItem)
			{
				droppedItem.DroppedBy = droppedBy;
				if (info.AdjustCenterOfMassOnDrop)
				{
					droppedItem.Rigidbody.centerOfMass = info.DropCenterOfMass;
				}
			}
		}
		else
		{
			Remove();
		}
		Interface.CallHook("OnItemDropped", (object)this, (object)baseEntity);
		RemoveFromContainer();
		return baseEntity;
	}

	public BaseEntity DropAndTossUpwards(Vector3 vPos, float force = 2f)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		float num = Random.value * MathF.PI * 2f;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(Mathf.Sin(num), 1f, Mathf.Cos(num));
		return Drop(vPos + Vector3.up * 0.1f, val * force);
	}

	public bool IsBusy()
	{
		if (busyTime > Time.time)
		{
			return true;
		}
		return false;
	}

	public void BusyFor(float fTime)
	{
		busyTime = Time.time + fTime;
	}

	public bool IsRemoved()
	{
		return removeTime > 0f;
	}

	public void Remove(float fTime = 0f)
	{
		if (removeTime > 0f || Interface.CallHook("OnItemRemove", (object)this) != null)
		{
			return;
		}
		if (isServer)
		{
			ItemMod[] itemMods = info.itemMods;
			for (int i = 0; i < itemMods.Length; i++)
			{
				itemMods[i].OnRemove(this);
			}
		}
		this.onCycle = null;
		removeTime = Time.time + fTime;
		this.OnDirty = null;
		position = -1;
		ItemManager.RemoveItem(this, fTime);
	}

	public void DoRemove()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		this.OnDirty = null;
		this.onCycle = null;
		if (isServer && ((ItemId)(ref uid)).IsValid && Net.sv != null)
		{
			Net.sv.ReturnUID(uid.Value);
			uid = default(ItemId);
		}
		if (contents != null)
		{
			Pool.Free<ItemContainer>(ref contents);
		}
		if (isServer)
		{
			RemoveFromWorld();
			RemoveFromContainer();
		}
		BaseEntity baseEntity = GetHeldEntity();
		if (baseEntity.IsValid())
		{
			Debug.LogWarning((object)("Item's Held Entity not removed!" + info.displayName.english + " -> " + (object)baseEntity), (Object)(object)baseEntity);
		}
	}

	public void SwitchOnOff(bool bNewState)
	{
		if (HasFlag(Flag.IsOn) != bNewState)
		{
			SetFlag(Flag.IsOn, bNewState);
			MarkDirty();
		}
	}

	public void LockUnlock(bool bNewState)
	{
		if (HasFlag(Flag.IsLocked) != bNewState && (!bNewState || Interface.CallHook("OnItemLock", (object)this) == null) && (bNewState || Interface.CallHook("OnItemUnlock", (object)this) == null))
		{
			SetFlag(Flag.IsLocked, bNewState);
			MarkDirty();
		}
	}

	public BasePlayer GetOwnerPlayer()
	{
		if (parent == null)
		{
			return null;
		}
		return parent.GetOwnerPlayer();
	}

	public bool IsBackpack()
	{
		if ((Object)(object)info != (Object)null)
		{
			return (info.flags & ItemDefinition.Flag.Backpack) != 0;
		}
		return false;
	}

	public int GetChildItemCount()
	{
		return (contents?.itemList?.Count).GetValueOrDefault();
	}

	public int GetItemVolume()
	{
		if (IsBackpack() && (contents?.itemList?.Count).GetValueOrDefault() > 0)
		{
			ItemModBackpack component = ((Component)info).GetComponent<ItemModBackpack>();
			if ((Object)(object)component != (Object)null)
			{
				return component.containerVolumeWhenFilled;
			}
		}
		return info.volume;
	}

	public Item SplitItem(int split_Amount)
	{
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Expected O, but got Unknown
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Expected O, but got Unknown
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Expected O, but got Unknown
		Assert.IsTrue(split_Amount > 0, "split_Amount <= 0");
		if (split_Amount <= 0)
		{
			return null;
		}
		if (split_Amount >= amount)
		{
			return null;
		}
		object obj = Interface.CallHook("OnItemSplit", (object)this, (object)split_Amount);
		if (obj is Item)
		{
			return (Item)obj;
		}
		amount -= split_Amount;
		Item item = ItemManager.CreateByItemID(info.itemid, 1, 0uL);
		item.amount = split_Amount;
		item.skin = skin;
		MigrateItemOwnership(item, split_Amount);
		if (IsBlueprint())
		{
			item.blueprintTarget = blueprintTarget;
		}
		if (info.amountType == ItemDefinition.AmountType.Genetics && instanceData != null && instanceData.dataInt != 0)
		{
			item.instanceData = new InstanceData();
			item.instanceData.dataInt = instanceData.dataInt;
			item.instanceData.ShouldPool = false;
		}
		if (instanceData != null && instanceData.dataInt > 0 && (Object)(object)info != (Object)null && (Object)(object)info.Blueprint != (Object)null && info.Blueprint.GetWorkbenchLevel() == 3)
		{
			item.instanceData = new InstanceData();
			item.instanceData.dataInt = instanceData.dataInt;
			item.instanceData.ShouldPool = false;
			item.SetFlag(Flag.IsOn, IsOn());
		}
		if (instanceData != null && Object.op_Implicit((Object)(object)((Component)info).GetComponent<ItemModFoodSpoiling>()))
		{
			item.instanceData = new InstanceData();
			item.instanceData.dataFloat = instanceData.dataFloat;
			item.instanceData.ShouldPool = false;
		}
		MarkDirty();
		return item;
	}

	public void UnloadAmmo()
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		BaseProjectile baseProjectile = GetHeldEntity() as BaseProjectile;
		if ((Object)(object)baseProjectile == (Object)null)
		{
			return;
		}
		while (baseProjectile.primaryMagazine.contents > 0)
		{
			int num = Mathf.Min(baseProjectile.primaryMagazine.contents, baseProjectile.primaryMagazine.ammoType.stackable);
			baseProjectile.primaryMagazine.contents -= num;
			Item item = ItemManager.Create(baseProjectile.primaryMagazine.ammoType, num, 0uL);
			BasePlayer basePlayer = GetRootContainer()?.playerOwner;
			if ((Object)(object)basePlayer != (Object)null)
			{
				basePlayer.GiveItem(item);
			}
			else if (!item.MoveToContainer(parent) && (Object)(object)item.Drop(parent.dropPosition, parent.dropVelocity) == (Object)null)
			{
				item.Remove();
			}
		}
	}

	public bool CanBeHeld()
	{
		if (isBroken)
		{
			return false;
		}
		if ((Object)(object)((Component)info).GetComponent<ItemModShield>() != (Object)null)
		{
			return false;
		}
		return true;
	}

	public bool CanStack(Item item)
	{
		object obj = Interface.CallHook("CanStackItem", (object)this, (object)item);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (item == this)
		{
			return false;
		}
		if (MaxStackable() <= 1)
		{
			return false;
		}
		if (item.info.stackable <= 1)
		{
			return false;
		}
		if (item.info.itemid != info.itemid)
		{
			return false;
		}
		if (hasCondition && condition != item.info.condition.max)
		{
			return false;
		}
		if (item.hasCondition && item.condition != item.info.condition.max)
		{
			return false;
		}
		if (!IsValid())
		{
			return false;
		}
		if (IsBlueprint() && blueprintTarget != item.blueprintTarget)
		{
			return false;
		}
		if (item.skin != skin)
		{
			return false;
		}
		if (item.info.amountType == ItemDefinition.AmountType.Genetics || info.amountType == ItemDefinition.AmountType.Genetics)
		{
			int num = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));
			int num2 = ((instanceData != null) ? instanceData.dataInt : (-1));
			if (num != num2)
			{
				return false;
			}
		}
		if (item.instanceData != null && instanceData != null && (item.IsOn() != IsOn() || (item.instanceData.dataInt != instanceData.dataInt && (Object)(object)item.info.Blueprint != (Object)null && item.info.Blueprint.GetWorkbenchLevel() == 3)))
		{
			return false;
		}
		if (instanceData != null && ((NetworkableId)(ref instanceData.subEntity)).IsValid && Object.op_Implicit((Object)(object)((Component)info).GetComponent<ItemModSign>()))
		{
			return false;
		}
		if (item.instanceData != null && ((NetworkableId)(ref item.instanceData.subEntity)).IsValid && Object.op_Implicit((Object)(object)((Component)item.info).GetComponent<ItemModSign>()))
		{
			return false;
		}
		if (BlockStackFoodItem(item, this))
		{
			return false;
		}
		return true;
	}

	public static bool BlockStackFoodItem(Item a, Item b)
	{
		ItemModFoodSpoiling itemModFoodSpoiling = default(ItemModFoodSpoiling);
		if (a.instanceData != null && b.instanceData != null && ((Component)a.info).TryGetComponent<ItemModFoodSpoiling>(ref itemModFoodSpoiling))
		{
			bool flag = false;
			float dataFloat = a.instanceData.dataFloat;
			float dataFloat2 = b.instanceData.dataFloat;
			if (Mathf.Abs(dataFloat - dataFloat2) < ConVar.Server.maxFoodSpoilTimeDiffForItemStack)
			{
				flag = true;
			}
			float num = itemModFoodSpoiling.TotalSpoilTimeHours * 60f * 60f;
			float num2 = a.instanceData.dataFloat / num;
			float num3 = b.instanceData.dataFloat / num;
			if (num2 > ConVar.Server.normalisedFoodSpoilTimeStackThreshold && num3 > ConVar.Server.normalisedFoodSpoilTimeStackThreshold)
			{
				flag = true;
			}
			if (!flag)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsValid()
	{
		if (removeTime > 0f)
		{
			return false;
		}
		return true;
	}

	public bool IsDroppedInWorld(bool serverside)
	{
		return worldEnt.IsValid(serverside);
	}

	public void SetWorldEntity(BaseEntity ent)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (!ent.IsValid())
		{
			worldEnt.Set(null);
			MarkDirty();
		}
		else if (!(worldEnt.uid == ent.net.ID))
		{
			worldEnt.Set(ent);
			MarkDirty();
			OnMovedToWorld();
			if (contents != null)
			{
				contents.OnMovedToWorld();
			}
		}
	}

	public void OnMovedToWorld()
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].OnMovedToWorld(this);
		}
	}

	public BaseEntity GetWorldEntity()
	{
		return worldEnt.Get(isServer);
	}

	public void SetHeldEntity(BaseEntity ent)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (!ent.IsValid())
		{
			this.heldEntity.Set(null);
			MarkDirty();
		}
		else
		{
			if (this.heldEntity.uid == ent.net.ID)
			{
				return;
			}
			this.heldEntity.Set(ent);
			MarkDirty();
			if (ent.IsValid())
			{
				HeldEntity heldEntity = ent as HeldEntity;
				if ((Object)(object)heldEntity != (Object)null)
				{
					heldEntity.SetupHeldEntity(this);
				}
			}
		}
	}

	public BaseEntity GetHeldEntity()
	{
		return heldEntity.Get(isServer);
	}

	public void OnCycle(float delta)
	{
		if (this.onCycle != null)
		{
			this.onCycle(this, delta);
		}
	}

	public void ServerCommand(string command, BasePlayer player)
	{
		HeldEntity heldEntity = GetHeldEntity() as HeldEntity;
		if ((Object)(object)heldEntity != (Object)null)
		{
			heldEntity.ServerCommand(this, command, player);
		}
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].ServerCommand(this, command, player);
		}
	}

	public void UseItem(int amountToConsume = 1)
	{
		if (amountToConsume > 0)
		{
			object obj = Interface.CallHook("OnItemUse", (object)this, (object)amountToConsume);
			if (obj is int)
			{
				amountToConsume = (int)obj;
			}
			amount -= amountToConsume;
			ReduceItemOwnership(amountToConsume);
			if (amount <= 0)
			{
				amount = 0;
				Remove();
			}
			else
			{
				MarkDirty();
			}
		}
	}

	public bool HasAmmo(AmmoTypes ammoType)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		ItemModProjectile itemModProjectile = default(ItemModProjectile);
		if (((Component)info).TryGetComponent<ItemModProjectile>(ref itemModProjectile) && itemModProjectile.IsAmmo(ammoType))
		{
			return true;
		}
		if (contents != null)
		{
			ItemModContainer itemModContainer = default(ItemModContainer);
			if ((Object)(object)info != (Object)null && ((Component)info).TryGetComponent<ItemModContainer>(ref itemModContainer) && itemModContainer.blockAmmoSource)
			{
				return false;
			}
			return contents.HasAmmo(ammoType);
		}
		return false;
	}

	public Item FindAmmo(AmmoTypes ammoType)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		ItemModProjectile itemModProjectile = default(ItemModProjectile);
		if (((Component)info).TryGetComponent<ItemModProjectile>(ref itemModProjectile) && itemModProjectile.IsAmmo(ammoType))
		{
			return this;
		}
		if (contents != null)
		{
			return contents.FindAmmo(ammoType);
		}
		return null;
	}

	public void FindAmmo(List<Item> list, AmmoTypes ammoType)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		ItemModProjectile itemModProjectile = default(ItemModProjectile);
		if (((Component)info).TryGetComponent<ItemModProjectile>(ref itemModProjectile) && itemModProjectile.IsAmmo(ammoType))
		{
			list.Add(this);
		}
		else if (contents != null)
		{
			contents.FindAmmo(list, ammoType);
		}
	}

	public int GetAmmoAmount(AmmoTypes ammoType)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		ItemModProjectile itemModProjectile = default(ItemModProjectile);
		if (((Component)info).TryGetComponent<ItemModProjectile>(ref itemModProjectile) && itemModProjectile.IsAmmo(ammoType))
		{
			num += amount;
		}
		if (contents != null)
		{
			num += contents.GetAmmoAmount(ammoType);
		}
		return num;
	}

	public int GetAmmoAmount(List<AmmoTypes> ammoTypes)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		ItemModProjectile itemModProjectile = default(ItemModProjectile);
		if (((Component)info).TryGetComponent<ItemModProjectile>(ref itemModProjectile))
		{
			foreach (AmmoTypes ammoType in ammoTypes)
			{
				if (itemModProjectile.IsAmmo(ammoType))
				{
					num += amount;
				}
			}
		}
		if (contents != null)
		{
			foreach (AmmoTypes ammoType2 in ammoTypes)
			{
				num += contents.GetAmmoAmount(ammoType2);
			}
		}
		return num;
	}

	public override string ToString()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		string[] obj = new string[6]
		{
			"Item.",
			info.shortname,
			"x",
			amount.ToString(),
			".",
			null
		};
		ItemId val = uid;
		obj[5] = ((object)(ItemId)(ref val)/*cast due to .constrained prefix*/).ToString();
		return string.Concat(obj);
	}

	public Item FindItem(ItemId iUID)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (uid == iUID)
		{
			return this;
		}
		if (contents == null)
		{
			return null;
		}
		return contents.FindItemByUID(iUID);
	}

	public int MaxStackable()
	{
		int num = info.stackable;
		if (parent != null && parent.maxStackSize > 0)
		{
			num = Mathf.Min(parent.maxStackSize, num);
		}
		object obj = Interface.CallHook("OnMaxStackable", (object)this);
		if (obj is int)
		{
			return (int)obj;
		}
		return num;
	}

	private void SetRadioactivity(ItemDefinition template)
	{
		if (!((Object)(object)template == (Object)null))
		{
			radioactivity = template.baseRadioactivity;
			if (radioactivity > 0f)
			{
				SetFlag(Flag.Radioactive, b: true);
			}
		}
	}

	public GameObjectRef GetWorldModel()
	{
		return info.GetWorldModel(amount);
	}

	public virtual Item Save(bool bIncludeContainer = false, bool bIncludeOwners = true)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		dirty = false;
		Item val = Pool.Get<Item>();
		val.UID = uid;
		val.itemid = info.itemid;
		val.slot = position;
		val.amount = amount;
		val.flags = (int)flags;
		val.removetime = removeTime;
		val.locktime = busyTime;
		val.instanceData = instanceData;
		val.worldEntity = worldEnt.uid;
		val.heldEntity = heldEntity.uid;
		val.skinid = skin;
		val.name = name;
		val.streamerName = streamerName;
		val.text = text;
		val.cooktime = cookTimeLeft;
		if (ownershipShares != null)
		{
			val.ownership = Pool.Get<List<ItemOwnershipAmount>>();
			foreach (ItemOwnershipShare ownershipShare in ownershipShares)
			{
				ItemOwnershipAmount val2 = Pool.Get<ItemOwnershipAmount>();
				val2.username = ownershipShare.username;
				val2.reason = ownershipShare.reason;
				val2.amount = ownershipShare.amount;
				val.ownership.Add(val2);
			}
		}
		val.ammoCount = 0;
		NetworkableId val3 = heldEntity.uid;
		if (((NetworkableId)(ref val3)).IsValid)
		{
			BaseEntity baseEntity = GetHeldEntity();
			if (baseEntity is BaseProjectile baseProjectile)
			{
				val.ammoCount = baseProjectile.primaryMagazine.contents + 1;
			}
			else if (baseEntity is Chainsaw chainsaw)
			{
				val.ammoCount = chainsaw.ammo + 1;
			}
			else if (baseEntity is FlameThrower flameThrower)
			{
				val.ammoCount = flameThrower.ammo + 1;
			}
		}
		if (hasCondition)
		{
			val.conditionData = Pool.Get<ConditionData>();
			val.conditionData.maxCondition = _maxCondition;
			val.conditionData.condition = _condition;
		}
		if (contents != null && bIncludeContainer)
		{
			val.contents = contents.Save(bIncludeContainer);
		}
		return val;
	}

	public virtual void Load(Item load)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)info == (Object)null || info.itemid != load.itemid)
		{
			info = ItemManager.FindItemDefinition(load.itemid);
		}
		if ((Object)(object)info == (Object)null)
		{
			Debug.LogError((object)$"Load invalid item id {load.itemid} from item {load.UID} (no ItemDefinition found)");
			return;
		}
		uid = load.UID;
		name = load.name;
		streamerName = load.streamerName;
		text = load.text;
		cookTimeLeft = load.cooktime;
		amount = load.amount;
		position = load.slot;
		busyTime = load.locktime;
		removeTime = load.removetime;
		flags = (Flag)load.flags;
		worldEnt.uid = load.worldEntity;
		heldEntity.uid = load.heldEntity;
		if (load.ownership != null && load.ownership.Count > 0)
		{
			if (ownershipShares == null)
			{
				ownershipShares = Pool.Get<List<ItemOwnershipShare>>();
			}
			else
			{
				ownershipShares.Clear();
			}
			foreach (ItemOwnershipAmount item2 in load.ownership)
			{
				ItemOwnershipShare itemOwnershipShare = default(ItemOwnershipShare);
				itemOwnershipShare.username = item2.username;
				itemOwnershipShare.reason = item2.reason;
				itemOwnershipShare.amount = item2.amount;
				ItemOwnershipShare item = itemOwnershipShare;
				ownershipShares.Add(item);
			}
		}
		else if (ownershipShares != null)
		{
			Pool.FreeUnmanaged<ItemOwnershipShare>(ref ownershipShares);
		}
		SetRadioactivity(info);
		InitializeItemOwnership();
		if (isServer)
		{
			Net.sv.RegisterUID(uid.Value);
		}
		if (instanceData != null)
		{
			instanceData.ShouldPool = true;
			instanceData.ResetToPool();
			instanceData = null;
		}
		instanceData = load.instanceData;
		if (instanceData != null)
		{
			instanceData.ShouldPool = false;
		}
		skin = load.skinid;
		_condition = 0f;
		_maxCondition = 0f;
		if (load.conditionData != null)
		{
			_condition = load.conditionData.condition;
			_maxCondition = load.conditionData.maxCondition;
		}
		else if (info.condition.enabled)
		{
			_condition = info.condition.max;
			_maxCondition = info.condition.max;
		}
		if (load.contents != null)
		{
			if (contents == null)
			{
				contents = Pool.Get<ItemContainer>();
				if (isServer)
				{
					contents.ServerInitialize(this, load.contents.slots);
				}
			}
			contents.Load(load.contents);
		}
		if (isServer)
		{
			removeTime = 0f;
			OnItemCreated();
		}
	}
}


using System;

[Flags]
public enum Flag
{
	None = 0,
	Placeholder = 1,
	IsOn = 2,
	OnFire = 4,
	IsLocked = 8,
	Cooking = 0x10,
	Radioactive = 0x20,
	Refrigerated = 0x40
}


public interface IItemUpdate
{
	void OnItemUpdate(Item item);
}


public interface IItemSetup
{
	void OnItemSetup(Item item);
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public sealed class ItemContainer : IAmmoContainer, IPooled
{
	[Flags]
	public enum Flag
	{
		IsPlayer = 1,
		Clothing = 2,
		Belt = 4,
		SingleType = 8,
		IsLocked = 0x10,
		ShowSlotsOnIcon = 0x20,
		NoBrokenItems = 0x40,
		NoItemInput = 0x80,
		ContentsHidden = 0x100,
		IsArmor = 0x200
	}

	[Flags]
	public enum ContentsType
	{
		Generic = 1,
		Liquid = 2
	}

	public enum LimitStack
	{
		None,
		Existing,
		All
	}

	public enum CanAcceptResult
	{
		CanAccept,
		CannotAccept,
		CannotAcceptRightNow
	}

	public const int BackpackSlotIndex = 7;

	public Flag flags;

	public ContentsType allowedContents;

	public ItemDefinition[] onlyAllowedItems;

	public HashSet<ItemDefinition> blockedItems;

	public List<ItemSlot> availableSlots = new List<ItemSlot>();

	public int capacity = 2;

	public ItemContainerId uid;

	public bool dirty;

	public List<Item> itemList = new List<Item>();

	public float temperature = 15f;

	public Item parent;

	public BasePlayer playerOwner;

	public BaseEntity entityOwner;

	public bool isServer;

	public int maxStackSize;

	public int containerVolume;

	public Func<Item, int, bool> canAcceptItem;

	public Func<Item, int, bool> slotIsReserved;

	public Action<Item, bool> onItemAddedRemoved;

	public Action<Item, int, int> onItemPositionChanged;

	public Action<Item, bool> onItemContentsChanged;

	public Action<Item, int> onItemAddedToStack;

	public Action<Item, int> onItemRemovedFromStack;

	public Action<Item> onPreItemRemove;

	public Action<Item, float> onItemRadiationChanged;

	public Action<Item, Item> onItemParentChanged;

	public bool HasAvailableSlotsDefined => !availableSlots.IsEmpty();

	public bool HasLimitedAllowedItems
	{
		get
		{
			if (onlyAllowedItems != null)
			{
				return onlyAllowedItems.Length != 0;
			}
			return false;
		}
	}

	public Vector3 dropPosition
	{
		get
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)playerOwner))
			{
				return playerOwner.GetDropPosition();
			}
			if (Object.op_Implicit((Object)(object)entityOwner))
			{
				return entityOwner.GetDropPosition();
			}
			if (parent != null)
			{
				BaseEntity worldEntity = parent.GetWorldEntity();
				if ((Object)(object)worldEntity != (Object)null)
				{
					return worldEntity.GetDropPosition();
				}
			}
			Debug.LogWarning((object)"ItemContainer.dropPosition dropped through");
			return Vector3.zero;
		}
	}

	public Vector3 dropVelocity
	{
		get
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)playerOwner))
			{
				return playerOwner.GetDropVelocity();
			}
			if (Object.op_Implicit((Object)(object)entityOwner))
			{
				return entityOwner.GetDropVelocity();
			}
			if (parent != null)
			{
				BaseEntity worldEntity = parent.GetWorldEntity();
				if ((Object)(object)worldEntity != (Object)null)
				{
					return worldEntity.GetDropVelocity();
				}
			}
			Debug.LogWarning((object)"ItemContainer.dropVelocity dropped through");
			return Vector3.zero;
		}
	}

	public event Action onDirty;

	public void UpdateAvailableSlots(List<ItemSlot> newSlots)
	{
		availableSlots.Clear();
		if (newSlots != null)
		{
			availableSlots.AddRange(newSlots);
		}
	}

	public bool HasFlag(Flag f)
	{
		return (flags & f) == f;
	}

	public void SetFlag(Flag f, bool b)
	{
		if (b)
		{
			flags |= f;
		}
		else
		{
			flags &= ~f;
		}
	}

	public bool IsLocked()
	{
		return HasFlag(Flag.IsLocked);
	}

	public bool PlayerItemInputBlocked()
	{
		return HasFlag(Flag.NoItemInput);
	}

	void IPooled.EnterPool()
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		flags = (Flag)0;
		allowedContents = (ContentsType)0;
		onlyAllowedItems = null;
		blockedItems = null;
		availableSlots.Clear();
		capacity = 2;
		if (((ItemContainerId)(ref uid)).IsValid && Net.sv != null)
		{
			Net.sv.ReturnUID(uid.Value);
		}
		uid = default(ItemContainerId);
		temperature = 15f;
		parent = null;
		playerOwner = null;
		entityOwner = null;
		isServer = false;
		maxStackSize = 0;
		containerVolume = 0;
		this.onDirty = null;
		canAcceptItem = null;
		slotIsReserved = null;
		onItemAddedRemoved = null;
		onItemContentsChanged = null;
		onItemAddedToStack = null;
		onItemRemovedFromStack = null;
		onPreItemRemove = null;
		onItemRadiationChanged = null;
		onItemParentChanged = null;
		Clear();
		dirty = false;
	}

	void IPooled.LeavePool()
	{
	}

	public float GetTemperature(int slot)
	{
		if (entityOwner is BaseOven baseOven)
		{
			return baseOven.GetTemperature(slot);
		}
		return temperature;
	}

	public void ServerInitialize(Item parentItem, int iMaxCapacity)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		parent = parentItem;
		capacity = iMaxCapacity;
		uid = default(ItemContainerId);
		isServer = true;
		if (allowedContents == (ContentsType)0)
		{
			allowedContents = ContentsType.Generic;
		}
		onItemRadiationChanged = (Action<Item, float>)Delegate.Combine(onItemRadiationChanged, new Action<Item, float>(BubbleUpRadiationChanged));
		MarkDirty();
	}

	public void GiveUID()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsTrue(!((ItemContainerId)(ref uid)).IsValid, "Calling GiveUID - but already has a uid!");
		uid = new ItemContainerId(Net.sv.TakeUID());
	}

	public void MarkDirty()
	{
		dirty = true;
		parent?.MarkDirty();
		this.onDirty?.Invoke();
	}

	public DroppedItemContainer Drop(string prefab, Vector3 pos, Quaternion rot, float destroyPercent)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (itemList == null || itemList.Count == 0)
		{
			return null;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefab, pos, rot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		DroppedItemContainer droppedItemContainer = baseEntity as DroppedItemContainer;
		if ((Object)(object)droppedItemContainer != (Object)null)
		{
			droppedItemContainer.TakeFrom(new ItemContainer[1] { this }, destroyPercent);
		}
		droppedItemContainer.Spawn();
		return droppedItemContainer;
	}

	public static DroppedItemContainer Drop(string prefab, Vector3 pos, Quaternion rot, params ItemContainer[] containers)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		foreach (ItemContainer itemContainer in containers)
		{
			num += ((itemContainer.itemList != null) ? itemContainer.itemList.Count : 0);
		}
		if (num == 0)
		{
			return null;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefab, pos, rot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		DroppedItemContainer droppedItemContainer = baseEntity as DroppedItemContainer;
		if ((Object)(object)droppedItemContainer != (Object)null)
		{
			droppedItemContainer.TakeFrom(containers, 0f);
		}
		droppedItemContainer.Spawn();
		return droppedItemContainer;
	}

	public BaseEntity GetEntityOwner(bool returnHeldEntity = false)
	{
		ItemContainer itemContainer = this;
		for (int i = 0; i < 10; i++)
		{
			if ((Object)(object)itemContainer.entityOwner != (Object)null)
			{
				return itemContainer.entityOwner;
			}
			if ((Object)(object)itemContainer.playerOwner != (Object)null)
			{
				return itemContainer.playerOwner;
			}
			if (returnHeldEntity)
			{
				BaseEntity baseEntity = itemContainer.parent?.GetHeldEntity();
				if ((Object)(object)baseEntity != (Object)null)
				{
					return baseEntity;
				}
			}
			ItemContainer itemContainer2 = itemContainer.parent?.parent;
			if (itemContainer2 == null || itemContainer2 == itemContainer)
			{
				return null;
			}
			itemContainer = itemContainer2;
		}
		return null;
	}

	public void OnChanged()
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			itemList[i].OnChanged();
		}
	}

	public Item FindItemByUID(ItemId iUID)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < itemList.Count; i++)
		{
			Item item = itemList[i];
			if (item.IsValid())
			{
				Item item2 = item.FindItem(iUID);
				if (item2 != null)
				{
					return item2;
				}
			}
		}
		return null;
	}

	public bool IsFull(bool checkForPartialStacks = false)
	{
		if (!checkForPartialStacks)
		{
			return itemList.Count >= capacity;
		}
		if (itemList.Count < capacity)
		{
			return false;
		}
		foreach (Item item in itemList)
		{
			if (item.IsValid() && item.amount < item.MaxStackable())
			{
				return false;
			}
		}
		return true;
	}

	public bool HasSpaceFor(Item item)
	{
		if (!IsFull())
		{
			return true;
		}
		return HasPartialStack(item);
	}

	public bool IsEmpty()
	{
		return itemList.Count == 0;
	}

	public bool HasPartialStack(Item toStack, out int slot)
	{
		slot = -1;
		foreach (Item item in itemList)
		{
			if (item.info.itemid == toStack.info.itemid && item.amount < item.MaxStackable() && toStack.CanStack(item))
			{
				slot = item.position;
				return true;
			}
		}
		return false;
	}

	public float GetRadioactiveMaterialInContainer()
	{
		float num = 0f;
		foreach (Item item in itemList)
		{
			num += item.radioactivity;
		}
		return num;
	}

	public bool HasPartialStack(Item toStack)
	{
		int slot;
		return HasPartialStack(toStack, out slot);
	}

	public bool CanAccept(Item item)
	{
		if (IsFull())
		{
			return false;
		}
		return true;
	}

	public int GetMaxTransferAmount(ItemDefinition def)
	{
		int num = ContainerMaxStackSize();
		foreach (Item item in itemList)
		{
			if ((Object)(object)item.info == (Object)(object)def)
			{
				num -= item.amount;
				if (num <= 0)
				{
					return 0;
				}
			}
		}
		return num;
	}

	public void SetOnlyAllowedItem(ItemDefinition def)
	{
		SetOnlyAllowedItems(def);
	}

	public void SetOnlyAllowedItems(ItemDefinition[] baseItems, params ItemDefinition[] additionalItems)
	{
		onlyAllowedItems = (from item in baseItems.Concat(additionalItems)
			where (Object)(object)item != (Object)null
			select item).ToArray();
	}

	public void SetOnlyAllowedItems(params ItemDefinition[] defs)
	{
		int num = 0;
		ItemDefinition[] array = defs;
		for (int i = 0; i < array.Length; i++)
		{
			if ((Object)(object)array[i] != (Object)null)
			{
				num++;
			}
		}
		onlyAllowedItems = new ItemDefinition[num];
		int num2 = 0;
		array = defs;
		foreach (ItemDefinition itemDefinition in array)
		{
			if ((Object)(object)itemDefinition != (Object)null)
			{
				onlyAllowedItems[num2] = itemDefinition;
				num2++;
			}
		}
	}

	public void SetBlacklist(ItemDefinition[] defs)
	{
		if (defs != null && defs.Length != 0)
		{
			blockedItems = new HashSet<ItemDefinition>(defs);
		}
	}

	public bool Insert(Item item)
	{
		if (itemList.Contains(item))
		{
			return false;
		}
		if (IsFull())
		{
			return false;
		}
		itemList.Add(item);
		item.parent = this;
		if (!FindPosition(item))
		{
			return false;
		}
		MarkDirty();
		if (onItemAddedRemoved != null)
		{
			onItemAddedRemoved(item, arg2: true);
		}
		ItemContainer itemContainer = parent?.parent;
		if (itemContainer != null && itemContainer.onItemContentsChanged != null)
		{
			itemContainer.onItemContentsChanged(item, arg2: true);
		}
		Interface.CallHook("OnItemAddedToContainer", (object)this, (object)item);
		return true;
	}

	public bool SlotTaken(Item item, int i)
	{
		if (slotIsReserved != null && slotIsReserved(item, i))
		{
			return true;
		}
		return GetSlot(i) != null;
	}

	public Item GetSlot(int slot)
	{
		if (slot == -1)
		{
			return null;
		}
		_ = itemList.Count;
		foreach (Item item in itemList)
		{
			if (item.position == slot)
			{
				return item;
			}
		}
		return null;
	}

	public bool QuickIndustrialPreCheck(Item toTransfer, Vector2i range, int fakeSlots, out int foundSlot)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		int num = range.y - range.x + 1;
		int count = itemList.Count;
		int num2 = 0;
		foundSlot = -1;
		for (int i = 0; i < count; i++)
		{
			Item item = itemList[i];
			int position = item.position;
			if (position < range.x || position > range.y)
			{
				continue;
			}
			num2++;
			if (item.amount >= item.info.stackable || item.IsRemoved())
			{
				continue;
			}
			if (toTransfer.IsBlueprint())
			{
				if (item.blueprintTarget != toTransfer.blueprintTarget)
				{
					continue;
				}
			}
			else if ((Object)(object)item.info != (Object)(object)toTransfer.info)
			{
				continue;
			}
			if (item.instanceData == null || item.CanStack(toTransfer))
			{
				foundSlot = position;
				return true;
			}
		}
		return num2 + fakeSlots < num;
	}

	public bool FindPosition(Item item)
	{
		int position = item.position;
		item.position = -1;
		if (position >= 0 && !SlotTaken(item, position))
		{
			item.position = position;
			return true;
		}
		for (int i = 0; i < capacity; i++)
		{
			if (!SlotTaken(item, i))
			{
				item.position = i;
				return true;
			}
		}
		return false;
	}

	public bool HasItem(ItemDefinition searchFor)
	{
		if ((Object)(object)searchFor == (Object)null)
		{
			return false;
		}
		foreach (Item item in itemList)
		{
			if (item != null && (Object)(object)item.info == (Object)(object)searchFor)
			{
				return true;
			}
		}
		return false;
	}

	public void SetLocked(bool isLocked, bool lockSubItems = false)
	{
		SetFlag(Flag.IsLocked, isLocked);
		if (lockSubItems)
		{
			SetSubItemsLocked(isLocked);
		}
		MarkDirty();
	}

	private void SetSubItemsLocked(bool isLocked)
	{
		if (itemList == null)
		{
			return;
		}
		foreach (Item item in itemList)
		{
			if (item != null && item.contents != null)
			{
				item.contents.SetLocked(isLocked);
			}
		}
	}

	public bool Remove(Item item)
	{
		if (!itemList.Contains(item))
		{
			return false;
		}
		onPreItemRemove?.Invoke(item);
		itemList.Remove(item);
		item.parent = null;
		onItemParentChanged?.Invoke(parent, item);
		onItemAddedRemoved?.Invoke(item, arg2: false);
		ItemContainer itemContainer = parent?.parent;
		if (itemContainer != null && itemContainer.onItemContentsChanged != null)
		{
			itemContainer.onItemContentsChanged(item, arg2: false);
		}
		MarkDirty();
		Interface.CallHook("OnItemRemovedFromContainer", (object)this, (object)item);
		return true;
	}

	public void Clear()
	{
		if (itemList.Count == 0)
		{
			return;
		}
		foreach (Item item in itemList)
		{
			onPreItemRemove?.Invoke(item);
			item.parent = null;
			item.Remove();
			onItemAddedRemoved?.Invoke(item, arg2: false);
			ItemContainer itemContainer = parent?.parent;
			if (itemContainer != null && itemContainer.onItemContentsChanged != null)
			{
				itemContainer.onItemContentsChanged(item, arg2: false);
			}
		}
		itemList.Clear();
		MarkDirty();
	}

	public void Kill()
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		parent = null;
		this.onDirty = null;
		canAcceptItem = null;
		slotIsReserved = null;
		onItemAddedRemoved = null;
		onItemContentsChanged = null;
		onPreItemRemove = null;
		if (((ItemContainerId)(ref uid)).IsValid && Net.sv != null)
		{
			Net.sv.ReturnUID(uid.Value);
			uid = default(ItemContainerId);
		}
		Clear();
	}

	public int GetAmount(int itemid, bool onlyUsableAmounts)
	{
		int num = 0;
		foreach (Item item in itemList)
		{
			if (item.info.itemid == itemid && (!onlyUsableAmounts || !item.IsBusy()))
			{
				num += item.amount;
			}
		}
		return num;
	}

	public int GetAmount(int blueprintBaseId, int itemId, bool onlyUsableAmounts)
	{
		int num = 0;
		foreach (Item item in itemList)
		{
			if (item.info.itemid == blueprintBaseId && item.blueprintTarget == itemId && (!onlyUsableAmounts || !item.IsBusy()))
			{
				num += item.amount;
			}
		}
		return num;
	}

	public int GetOkConditionAmount(int itemid, bool onlyUsableAmounts)
	{
		int num = 0;
		foreach (Item item in itemList)
		{
			if (item.info.itemid == itemid && (!onlyUsableAmounts || !item.IsBusy()) && !(item.condition <= 0f))
			{
				num += item.amount;
			}
		}
		return num;
	}

	public Item FindItemByItemID(int itemid)
	{
		foreach (Item item in itemList)
		{
			if (item.info.itemid == itemid)
			{
				return item;
			}
		}
		return null;
	}

	public Item FindItemByItemName(string name)
	{
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(name);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return null;
		}
		for (int i = 0; i < itemList.Count; i++)
		{
			if ((Object)(object)itemList[i].info == (Object)(object)itemDefinition)
			{
				return itemList[i];
			}
		}
		return null;
	}

	public Item FindBySubEntityID(NetworkableId subEntityID)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (!((NetworkableId)(ref subEntityID)).IsValid)
		{
			return null;
		}
		foreach (Item item in itemList)
		{
			if (item.instanceData != null && item.instanceData.subEntity == subEntityID)
			{
				return item;
			}
		}
		return null;
	}

	public void FindItemsByItemID(List<Item> list, int itemid)
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			Item item = itemList[i];
			if (item.info.itemid == itemid)
			{
				list.Add(item);
			}
		}
	}

	public void FindItemsByItemID(int itemId, BufferList<Item> found)
	{
		found.Clear();
		foreach (Item item in itemList)
		{
			if (item.info.itemid == itemId)
			{
				found.Add(item);
			}
		}
	}

	public ItemContainer Save(bool bIncludeContainer = true)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		ItemContainer val = Pool.Get<ItemContainer>();
		val.contents = Pool.Get<List<Item>>();
		val.UID = uid;
		val.slots = capacity;
		val.temperature = temperature;
		val.allowedContents = (int)allowedContents;
		if (HasLimitedAllowedItems)
		{
			val.allowedItems = Pool.Get<List<int>>();
			for (int i = 0; i < onlyAllowedItems.Length; i++)
			{
				if ((Object)(object)onlyAllowedItems[i] != (Object)null)
				{
					val.allowedItems.Add(onlyAllowedItems[i].itemid);
				}
			}
		}
		val.flags = (int)flags;
		val.maxStackSize = maxStackSize;
		val.volume = containerVolume;
		if (availableSlots != null && availableSlots.Count > 0)
		{
			val.availableSlots = Pool.Get<List<int>>();
			for (int j = 0; j < availableSlots.Count; j++)
			{
				val.availableSlots.Add((int)availableSlots[j]);
			}
		}
		for (int k = 0; k < itemList.Count; k++)
		{
			Item item = itemList[k];
			if (item.IsValid())
			{
				val.contents.Add(item.Save(bIncludeContainer));
			}
		}
		return val;
	}

	public void Load(ItemContainer container)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("ItemContainer.Load", 0);
		try
		{
			uid = container.UID;
			capacity = container.slots;
			List<Item> list = itemList;
			itemList = Pool.Get<List<Item>>();
			temperature = container.temperature;
			flags = (Flag)container.flags;
			allowedContents = ((container.allowedContents == 0) ? ContentsType.Generic : ((ContentsType)container.allowedContents));
			if (container.allowedItems != null && container.allowedItems.Count > 0)
			{
				onlyAllowedItems = new ItemDefinition[container.allowedItems.Count];
				for (int i = 0; i < container.allowedItems.Count; i++)
				{
					onlyAllowedItems[i] = ItemManager.FindItemDefinition(container.allowedItems[i]);
				}
			}
			else
			{
				onlyAllowedItems = null;
			}
			maxStackSize = container.maxStackSize;
			containerVolume = container.volume;
			availableSlots.Clear();
			if (container.availableSlots != null)
			{
				for (int j = 0; j < container.availableSlots.Count; j++)
				{
					availableSlots.Add((ItemSlot)container.availableSlots[j]);
				}
			}
			TimeWarning val2 = TimeWarning.New("container.contents", 0);
			try
			{
				foreach (Item content in container.contents)
				{
					Item created = null;
					foreach (Item item in list)
					{
						if (item.uid == content.UID)
						{
							created = item;
							break;
						}
					}
					created = ItemManager.Load(content, created, isServer);
					if (created != null)
					{
						created.parent = this;
						created.position = content.slot;
						Insert(created);
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			val2 = TimeWarning.New("Delete old items", 0);
			try
			{
				foreach (Item item2 in list)
				{
					if (!itemList.Contains(item2))
					{
						item2.Remove();
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			dirty = true;
			Pool.Free<Item>(ref list, false);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public BasePlayer GetOwnerPlayer()
	{
		return playerOwner;
	}

	public int ContainerMaxStackSize()
	{
		if (maxStackSize <= 0)
		{
			return int.MaxValue;
		}
		return maxStackSize;
	}

	public int Take(List<Item> collect, int itemid, int iAmount, bool takeBroken = true)
	{
		int num = 0;
		if (iAmount == 0)
		{
			return num;
		}
		List<Item> list = Pool.Get<List<Item>>();
		foreach (Item item2 in itemList)
		{
			if (item2.info.itemid != itemid || (!takeBroken && item2.info.condition.enabled && item2.condition <= 0f))
			{
				continue;
			}
			int num2 = iAmount - num;
			if (num2 <= 0)
			{
				continue;
			}
			if (item2.amount > num2)
			{
				num += num2;
				Item item = item2.SplitItem(num2);
				if (item != null)
				{
					item.CollectedForCrafting(playerOwner);
					collect?.Add(item);
				}
				break;
			}
			if (item2.amount <= num2)
			{
				num += item2.amount;
				list.Add(item2);
				collect?.Add(item2);
			}
			if (num == iAmount)
			{
				break;
			}
		}
		foreach (Item item3 in list)
		{
			item3.RemoveFromContainer();
		}
		Pool.Free<Item>(ref list, false);
		return num;
	}

	public bool TryTakeOne(int itemid, out Item item)
	{
		item = null;
		foreach (Item item3 in itemList)
		{
			if (item3.info.itemid == itemid)
			{
				if (item3.amount > 1)
				{
					item3.MarkDirty();
					item3.amount--;
					Item item2 = ItemManager.CreateByItemID(itemid, 1, 0uL);
					item2.amount = 1;
					item2.CollectedForCrafting(playerOwner);
					item = item2;
				}
				else
				{
					item = item3;
				}
				break;
			}
		}
		if (item != null)
		{
			item.RemoveFromContainer();
			return true;
		}
		return false;
	}

	public bool GiveItem(Item item, ItemContainer container = null)
	{
		if (item == null)
		{
			return false;
		}
		if (container != null && item.MoveToContainer(container))
		{
			return true;
		}
		return item.MoveToContainer(this);
	}

	public void OnCycle(float delta)
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			if (itemList[i].IsValid())
			{
				itemList[i].OnCycle(delta);
			}
		}
	}

	public Item FindAmmo(AmmoTypes ammoType)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < itemList.Count; i++)
		{
			Item item = itemList[i].FindAmmo(ammoType);
			if (item != null)
			{
				return item;
			}
		}
		return null;
	}

	public void FindAmmo(List<Item> list, AmmoTypes ammoType)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < itemList.Count; i++)
		{
			itemList[i].FindAmmo(list, ammoType);
		}
	}

	public bool HasAmmo(AmmoTypes ammoType)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < itemList.Count; i++)
		{
			if (itemList[i].HasAmmo(ammoType))
			{
				return true;
			}
		}
		return false;
	}

	public int GetAmmoAmount(ItemDefinition specificAmmo)
	{
		int num = 0;
		for (int i = 0; i < itemList.Count; i++)
		{
			num += (((Object)(object)itemList[i].info == (Object)(object)specificAmmo) ? itemList[i].amount : 0);
		}
		return num;
	}

	public int GetAmmoAmount(AmmoTypes ammoType)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		for (int i = 0; i < itemList.Count; i++)
		{
			num += itemList[i].GetAmmoAmount(ammoType);
		}
		return num;
	}

	public int TotalItemAmount()
	{
		int num = 0;
		for (int i = 0; i < itemList.Count; i++)
		{
			num += itemList[i].amount;
		}
		return num;
	}

	public bool HasAny(ItemDefinition itemDef)
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			Item item = itemList[i];
			if ((Object)(object)item.info == (Object)(object)itemDef && item.amount > 0)
			{
				return true;
			}
		}
		return false;
	}

	public bool HasAnyWithSpace(ItemDefinition itemDef)
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			Item item = itemList[i];
			if ((Object)(object)item.info == (Object)(object)itemDef && item.amount > 0 && item.amount < item.info.stackable)
			{
				return true;
			}
		}
		return false;
	}

	public int GetTotalItemAmount(Item item, int slotStartInclusive, int slotEndInclusive)
	{
		int num = 0;
		for (int i = slotStartInclusive; i <= slotEndInclusive; i++)
		{
			Item slot = GetSlot(i);
			if (slot == null)
			{
				continue;
			}
			if (item.IsBlueprint())
			{
				if (slot.IsBlueprint() && slot.blueprintTarget == item.blueprintTarget)
				{
					num += slot.amount;
				}
			}
			else if ((Object)(object)slot.info == (Object)(object)item.info || (Object)(object)slot.info.isRedirectOf == (Object)(object)item.info || (Object)(object)item.info.isRedirectOf == (Object)(object)slot.info)
			{
				num += slot.amount;
			}
			else if ((Object)(object)slot.info.isRedirectOf != (Object)null && (Object)(object)slot.info.isRedirectOf == (Object)(object)item.info.isRedirectOf)
			{
				num += slot.amount;
			}
		}
		return num;
	}

	public int TotalItemAmount(ItemDefinition itemDef)
	{
		int num = 0;
		for (int i = 0; i < itemList.Count; i++)
		{
			Item item = itemList[i];
			if ((Object)(object)item.info == (Object)(object)itemDef)
			{
				num += item.amount;
			}
		}
		return num;
	}

	public int GetTotalCategoryAmount(ItemCategory category, int slotStartInclusive, int slotEndInclusive)
	{
		int num = 0;
		for (int i = slotStartInclusive; i <= slotEndInclusive; i++)
		{
			Item slot = GetSlot(i);
			if (slot != null && slot.info.category == category)
			{
				num += slot.amount;
			}
		}
		return num;
	}

	public void AddItem(ItemDefinition itemToCreate, int amount, ulong skin = 0uL, LimitStack limitStack = LimitStack.Existing)
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			if (amount == 0)
			{
				return;
			}
			if ((Object)(object)itemList[i].info != (Object)(object)itemToCreate)
			{
				continue;
			}
			int num = itemList[i].MaxStackable();
			if (num <= itemList[i].amount && limitStack != 0)
			{
				continue;
			}
			MarkDirty();
			itemList[i].amount += amount;
			amount -= amount;
			if (itemList[i].amount > num && limitStack != 0)
			{
				amount = itemList[i].amount - num;
				if (amount > 0)
				{
					itemList[i].amount -= amount;
				}
			}
		}
		if (amount == 0)
		{
			return;
		}
		int num2 = ((limitStack == LimitStack.All) ? Mathf.Min(itemToCreate.stackable, ContainerMaxStackSize()) : int.MaxValue);
		if (num2 <= 0)
		{
			return;
		}
		while (amount > 0)
		{
			int num3 = Mathf.Min(amount, num2);
			Item item = ItemManager.Create(itemToCreate, num3, skin);
			amount -= num3;
			if (!item.MoveToContainer(this))
			{
				item.Remove();
			}
		}
	}

	public void MoveAllItems(ItemContainer target)
	{
		for (int num = itemList.Count - 1; num >= 0; num--)
		{
			itemList[num].MoveToContainer(target);
		}
	}

	public void RemoveFractionOfContainer(List<Item> removedItems, float removeFraction)
	{
		removeFraction = Mathf.Clamp01(removeFraction);
		if (itemList.Count == 0 || removeFraction == 0f)
		{
			return;
		}
		List<Item> list = Pool.Get<List<Item>>();
		Dictionary<ItemDefinition, float> dictionary = Pool.Get<Dictionary<ItemDefinition, float>>();
		for (int num = itemList.Count - 1; num >= 0; num--)
		{
			Item item = itemList[num];
			if (item.amount == 1)
			{
				list.Add(item);
			}
			else
			{
				float num2 = (float)item.amount * removeFraction;
				int num3 = Mathf.FloorToInt(num2);
				float num4 = num2 - (float)num3;
				if (num4 > 0f)
				{
					if (!dictionary.TryGetValue(item.info, out var value))
					{
						float num5 = num4;
						if (Random.Range(0f, 1f) < num5)
						{
							num4 = -1f + num5;
							num3++;
						}
						else
						{
							num4 += removeFraction;
						}
						dictionary.Add(item.info, num4);
					}
					else
					{
						num4 += value;
						if (num4 > 1f)
						{
							num3++;
							num4 -= 1f;
						}
						dictionary[item.info] = num4;
					}
				}
				if (num3 > 0)
				{
					if (num3 == item.amount)
					{
						removedItems.Add(item);
						item.RemoveFromContainer();
					}
					else
					{
						removedItems.Add(item.SplitItem(num3));
					}
				}
			}
		}
		int num6 = Mathf.RoundToInt((float)list.Count * removeFraction);
		ListEx.Shuffle<Item>(list, (uint)Random.Range(0, 1000000000));
		for (int i = 0; i < num6; i++)
		{
			Item item2 = list[i];
			removedItems.Add(item2);
			item2.RemoveFromContainer();
		}
		Pool.FreeUnmanaged<Item>(ref list);
		Pool.FreeUnmanaged<ItemDefinition, float>(ref dictionary);
	}

	public void RemoveItemsFromContainer(List<Item> removedItems, string[] targetItems)
	{
		for (int num = itemList.Count - 1; num >= 0; num--)
		{
			Item item = itemList[num];
			foreach (string text in targetItems)
			{
				if (item.info.shortname == text)
				{
					item.RemoveFromContainer();
					removedItems.Add(item);
					break;
				}
			}
		}
	}

	public void MergeAllStacks()
	{
		List<Item> list = Pool.Get<List<Item>>();
		list.AddRange(itemList);
		foreach (Item item in list)
		{
			item.RemoveFromContainer();
		}
		foreach (Item item2 in list)
		{
			item2.MoveToContainer(this);
		}
		Pool.Free<Item>(ref list, false);
	}

	public void OnMovedToWorld()
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			itemList[i].OnMovedToWorld();
		}
	}

	public void OnRemovedFromWorld()
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			itemList[i].OnRemovedFromWorld();
		}
	}

	public uint ContentsDeepHash(bool ignoreBackContents = false)
	{
		uint num = 0u;
		for (int i = 0; i < capacity; i++)
		{
			Item slot = GetSlot(i);
			if (slot == null)
			{
				continue;
			}
			num = CRC.Compute32(num, slot.info.itemid);
			num = CRC.Compute32(num, slot.skin);
			num = CRC.Compute32(num, slot.uid.Value);
			if ((slot.IsBackpack() && ignoreBackContents) || slot.contents == null)
			{
				continue;
			}
			for (int j = 0; j < slot.contents.capacity; j++)
			{
				if (slot.contents.GetSlot(j) != null)
				{
					num = CRC.Compute32(num, slot.info.itemid);
				}
			}
		}
		return num;
	}

	public ItemContainer FindContainer(ItemContainerId id)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (id == uid)
		{
			return this;
		}
		for (int i = 0; i < itemList.Count; i++)
		{
			Item item = itemList[i];
			if (item.contents != null)
			{
				ItemContainer itemContainer = item.contents.FindContainer(id);
				if (itemContainer != null)
				{
					return itemContainer;
				}
			}
		}
		return null;
	}

	public CanAcceptResult CanAcceptItem(Item item, int targetPos)
	{
		if (canAcceptItem != null && !canAcceptItem(item, targetPos))
		{
			return CanAcceptResult.CannotAccept;
		}
		if (isServer && availableSlots != null && availableSlots.Count > 0)
		{
			if (item.info.occupySlots == (ItemSlot)0 || item.info.occupySlots == ItemSlot.None)
			{
				return CanAcceptResult.CannotAccept;
			}
			if (item.isBroken)
			{
				return CanAcceptResult.CannotAccept;
			}
			int num = 0;
			foreach (ItemSlot availableSlot in availableSlots)
			{
				num |= (int)availableSlot;
			}
			if (((uint)num & (uint)item.info.occupySlots) != (uint)item.info.occupySlots)
			{
				return CanAcceptResult.CannotAcceptRightNow;
			}
		}
		if ((allowedContents & item.info.itemType) != item.info.itemType)
		{
			return CanAcceptResult.CannotAccept;
		}
		if (HasLimitedAllowedItems)
		{
			bool flag = false;
			for (int i = 0; i < onlyAllowedItems.Length; i++)
			{
				if ((Object)(object)onlyAllowedItems[i] == (Object)(object)item.info)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return CanAcceptResult.CannotAccept;
			}
		}
		object obj = Interface.CallHook("CanAcceptItem", (object)this, (object)item, (object)targetPos);
		if (obj is CanAcceptResult)
		{
			return (CanAcceptResult)obj;
		}
		if (blockedItems != null && blockedItems.Contains(item.info))
		{
			return CanAcceptResult.CannotAccept;
		}
		if (item.GetItemVolume() > containerVolume)
		{
			return CanAcceptResult.CannotAccept;
		}
		return CanAcceptResult.CanAccept;
	}

	public bool HasBackpackItem()
	{
		foreach (Item item in itemList)
		{
			if (!item.isBroken && item.IsBackpack())
			{
				return true;
			}
		}
		return false;
	}

	public void BubbleUpRadiationChanged(Item item, float amount)
	{
		if (parent != null && parent.parent != null)
		{
			parent?.parent?.onItemRadiationChanged?.Invoke(parent, 0f);
		}
	}
}


using System;

[Flags]
public enum Flag
{
	IsPlayer = 1,
	Clothing = 2,
	Belt = 4,
	SingleType = 8,
	IsLocked = 0x10,
	ShowSlotsOnIcon = 0x20,
	NoBrokenItems = 0x40,
	NoItemInput = 0x80,
	ContentsHidden = 0x100,
	IsArmor = 0x200
}


using System;

[Flags]
public enum ContentsType
{
	Generic = 1,
	Liquid = 2
}


public enum LimitStack
{
	None,
	Existing,
	All
}


public enum CanAcceptResult
{
	CanAccept,
	CannotAccept,
	CannotAcceptRightNow
}


using UnityEngine;

public class ItemCorpseOverride : MonoBehaviour
{
	public GameObjectRef MaleCorpse;

	public GameObjectRef FemaleCorpse;

	public bool BlockWearableCopy;
}


using System;
using System.Collections.Generic;
using ConVar;
using Rust;
using UnityEngine;

public class ItemBlueprint : MonoBehaviour
{
	[Serializable]
	public struct BlueprintOverride
	{
		public Era TargetEra;

		public List<ItemAmount> Ingredients;

		public float craftTime;

		public int workbenchLevel;

		public BlueprintOverride(ItemBlueprint bp)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			TargetEra = (Era)0;
			Ingredients = bp.ingredients;
			craftTime = bp.time;
			workbenchLevel = bp.workbenchLevelRequired;
		}
	}

	private ItemDefinition _targetItem;

	public List<ItemAmount> ingredients = new List<ItemAmount>();

	public List<ItemDefinition> additionalUnlocks = new List<ItemDefinition>();

	public bool defaultBlueprint;

	public bool userCraftable = true;

	public bool isResearchable = true;

	public bool forceShowInConveyorFilter;

	public Rarity rarity;

	[Header("Workbench")]
	public int workbenchLevelRequired;

	[Header("Scrap")]
	public int scrapRequired;

	public int scrapFromRecycle;

	[Tooltip("This item won't show anywhere unless you have the corresponding SteamItem in your inventory - which is defined on the ItemDefinition")]
	[Header("Unlocking")]
	public bool NeedsSteamItem;

	public ItemDefinition RequireUnlockedItem;

	public int blueprintStackSize = -1;

	public float time = 1f;

	public int amountToCreate = 1;

	public bool ForceThisCraftTime;

	public string UnlockAchievment;

	public string RecycleStat;

	public List<BlueprintOverride> Overrides = new List<BlueprintOverride>();

	public ItemDefinition targetItem
	{
		get
		{
			if (_targetItem == null)
			{
				_targetItem = ((Component)this).GetComponent<ItemDefinition>();
			}
			return _targetItem;
		}
	}

	public bool NeedsSteamDLC => (Object)(object)targetItem.steamDlc != (Object)null;

	public List<ItemAmount> GetIngredients()
	{
		BlueprintOverride recipeOverride = GetRecipeOverride();
		float multiplier = 1f;
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode != (Object)null)
		{
			multiplier = activeGameMode.GetCraftingCostModifier(targetItem);
		}
		if (recipeOverride.Ingredients != null && recipeOverride.Ingredients.Count > 0)
		{
			ApplyMultiplierToIngredients(recipeOverride.Ingredients, multiplier);
			return recipeOverride.Ingredients;
		}
		ApplyMultiplierToIngredients(ingredients, multiplier);
		return ingredients;
	}

	private void ApplyMultiplierToIngredients(List<ItemAmount> ingredients, float multiplier)
	{
		foreach (ItemAmount ingredient in ingredients)
		{
			ingredient.amount = Mathf.RoundToInt(ingredient.startAmount * multiplier);
		}
	}

	public float GetCraftTime()
	{
		float craftTime = time;
		float num = 5f;
		ItemDefinition itemDefinition = targetItem;
		if ((Object)(object)itemDefinition != (Object)null && (itemDefinition.stackable == 1 || itemDefinition.isHoldable || itemDefinition.isWearable || itemDefinition.isUsable || itemDefinition.category == ItemCategory.Construction || itemDefinition.category == ItemCategory.Traps))
		{
			num += (float)Mathf.Max(workbenchLevelRequired, 1) * 10f;
		}
		BlueprintOverride recipeOverride = GetRecipeOverride();
		if (recipeOverride.craftTime > 0f)
		{
			craftTime = recipeOverride.craftTime;
		}
		if (ForceThisCraftTime)
		{
			return craftTime;
		}
		return Mathf.Min(num, craftTime);
	}

	public BlueprintOverride GetRecipeOverride()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (Overrides.Count == 0)
		{
			return new BlueprintOverride(this);
		}
		foreach (BlueprintOverride @override in Overrides)
		{
			if (@override.TargetEra == ConVar.Server.Era)
			{
				return @override;
			}
		}
		return new BlueprintOverride(this);
	}

	public int GetWorkbenchLevel()
	{
		BlueprintOverride recipeOverride = GetRecipeOverride();
		if (recipeOverride.workbenchLevel != 0)
		{
			return Mathf.Max(0, recipeOverride.workbenchLevel);
		}
		return workbenchLevelRequired;
	}
}


using System;
using System.Collections.Generic;
using Rust;

[Serializable]
public struct BlueprintOverride
{
	public Era TargetEra;

	public List<ItemAmount> Ingredients;

	public float craftTime;

	public int workbenchLevel;

	public BlueprintOverride(ItemBlueprint bp)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		TargetEra = (Era)0;
		Ingredients = bp.ingredients;
		craftTime = bp.time;
		workbenchLevel = bp.workbenchLevelRequired;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Rust;
using UnityEngine;

public class ItemDefinition : MonoBehaviour
{
	[Flags]
	public enum LootDistributionModifierType
	{
		None = 0,
		Firearm = 1,
		FirearmAmmunition = 2,
		Unused = int.MinValue
	}

	[Serializable]
	public struct Condition
	{
		[Serializable]
		public class WorldSpawnCondition
		{
			public float fractionMin = 1f;

			public float fractionMax = 1f;
		}

		public bool enabled;

		[Tooltip("The maximum condition this item type can have, new items will start with this value")]
		public float max;

		[Tooltip("If false then item will destroy when condition reaches 0")]
		public bool repairable;

		[Tooltip("If true, never lose max condition when repaired")]
		public bool maintainMaxCondition;

		public bool ovenCondition;

		public WorldSpawnCondition foundCondition;

		public bool hideConditionBar;

		public GameObjectRef breakEffect;
	}

	[Serializable]
	public struct OverrideWorldModel
	{
		public GameObjectRef worldModel;

		public int minStackSize;
	}

	public enum RedirectVendingBehaviour
	{
		NoListing,
		ListAsUniqueItem
	}

	[Flags]
	public enum Flag
	{
		NoDropping = 1,
		NotStraightToBelt = 2,
		NotAllowedInBelt = 4,
		Backpack = 8
	}

	public enum AmountType
	{
		Count,
		Millilitre,
		Feet,
		Genetics,
		OxygenSeconds,
		Frequency,
		Generic,
		BagLimit,
		ShelterLimit,
		ContentCount,
		TurretLimit,
		NucleusGrades
	}

	[ReadOnly]
	[Header("Item")]
	public int itemid;

	[Tooltip("The shortname should be unique. A hash will be generated from it to identify the item type. If this name changes at any point it will make all saves incompatible")]
	public string shortname;

	public Era era;

	public EraRestriction eraRestrictions;

	public LootDistributionModifierType lootDistributionType;

	[Header("Appearance")]
	public Phrase displayName;

	public Phrase displayDescription;

	public Sprite iconSprite;

	public ItemCategory category;

	public ItemSelectionPanel selectionPanel;

	[Header("Containment")]
	public int maxDraggable;

	public ItemContainer.ContentsType itemType = ItemContainer.ContentsType.Generic;

	public AmountType amountType;

	[InspectorFlags]
	public ItemSlot occupySlots = ItemSlot.None;

	public int stackable;

	public int volume;

	public float baseRadioactivity;

	public bool quickDespawn;

	public bool blockStealingInSafeZone;

	[Tooltip("Should this item be blocked from being burried and found by other players? Off by default to allow most items.")]
	public bool allowBurying;

	public BasePlayer.TutorialItemAllowance tutorialAllowance;

	[Tooltip("If true, this item will support item ownership even if it's stacksize is >1")]
	public bool supportsStackableOwnership;

	[Header("Spawn Tables")]
	[Tooltip("How rare this item is and how much it costs to research")]
	public Rarity rarity;

	public Rarity despawnRarity;

	public bool spawnAsBlueprint;

	[Header("Sounds")]
	public SoundDefinition inventoryGrabSound;

	public SoundDefinition inventoryDropSound;

	public SoundDefinition physImpactSoundDef;

	public Condition condition;

	[Header("Misc")]
	public bool hidden;

	[InspectorFlags]
	public Flag flags;

	public bool hideSelectedPanel;

	[Tooltip("User can craft this item on any server if they have this steam item")]
	public SteamInventoryItem steamItem;

	[Tooltip("User can craft this item if they have this DLC purchased")]
	public SteamDLCItem steamDlc;

	[Tooltip("Can only craft this item if the parent is craftable (tech tree)")]
	public ItemDefinition Parent;

	[Header("World Model")]
	public GameObjectRef worldModelPrefab;

	public OverrideWorldModel[] worldModelOverrides;

	public bool treatAsComponentForRepairs;

	public bool AlignWorldModelOnDrop;

	public Vector3 WorldModelDropOffset;

	public bool AdjustCenterOfMassOnDrop;

	public Vector3 DropCenterOfMass;

	public ItemDefinition isRedirectOf;

	public RedirectVendingBehaviour redirectVendingBehaviour;

	[NonSerialized]
	public ItemMod[] itemMods;

	public BaseEntity.TraitFlag Traits;

	[NonSerialized]
	public ItemSkinDirectory.Skin[] skins;

	[NonSerialized]
	public IPlayerItemDefinition[] _skins2;

	private float _worldModelMass;

	[Tooltip("Panel to show in the inventory menu when selected")]
	public GameObject panel;

	[NonSerialized]
	public ItemDefinition[] Children = new ItemDefinition[0];

	public IPlayerItemDefinition[] skins2
	{
		get
		{
			if (_skins2 != null)
			{
				return _skins2;
			}
			if (PlatformService.Instance.IsValid && PlatformService.Instance.ItemDefinitions != null)
			{
				string prefabname = ((Object)this).name;
				_skins2 = PlatformService.Instance.ItemDefinitions.Where((IPlayerItemDefinition x) => (x.ItemShortName == shortname || x.ItemShortName == prefabname) && x.WorkshopId != 0).ToArray();
			}
			return _skins2;
		}
	}

	public ItemBlueprint Blueprint { get; private set; }

	public int craftingStackable => Mathf.Max(10, stackable);

	public bool isWearable => (Object)(object)ItemModWearable != (Object)null;

	public ItemModWearable ItemModWearable { get; set; }

	public ItemModBurnable ItemModBurnable { get; set; }

	public ItemModCookable ItemModCookable { get; set; }

	public bool isHoldable { get; private set; }

	public bool isUsable { get; private set; }

	public bool HasSkins
	{
		get
		{
			if (skins2 != null && skins2.Length != 0)
			{
				return true;
			}
			if (skins != null && skins.Length != 0)
			{
				return true;
			}
			return false;
		}
	}

	public bool CraftableWithSkin { get; private set; }

	public bool Hidden()
	{
		return hidden;
	}

	public void InvalidateWorkshopSkinCache()
	{
		_skins2 = null;
	}

	public bool IsAllowed(EraRestriction targetRestriction)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode != (Object)null && !activeGameMode.IsAllowed(this, targetRestriction))
		{
			return false;
		}
		return IsAllowedInEra(targetRestriction);
	}

	public bool IsAllowed(EraRestriction targetRestriction, Era serverEra)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode != (Object)null && !activeGameMode.IsAllowed(this, targetRestriction))
		{
			return false;
		}
		return IsAllowedInEra(targetRestriction, serverEra);
	}

	public bool IsAllowedInEra(EraRestriction targetRestriction)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		if ((int)ConVar.Server.Era == 0)
		{
			return true;
		}
		return IsAllowedInEra(targetRestriction, ConVar.Server.Era);
	}

	private bool IsAllowedInEra(EraRestriction targetRestriction, Era serverEra)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Invalid comparison between Unknown and I4
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if ((int)serverEra == 0)
		{
			return true;
		}
		if ((Object)(object)isRedirectOf != (Object)null)
		{
			return isRedirectOf.IsAllowedInEra(targetRestriction);
		}
		Era val = era;
		if ((int)val != 0)
		{
			if ((int)val == 1)
			{
				return true;
			}
			if (era <= serverEra)
			{
				if ((int)targetRestriction != 0 && (int)eraRestrictions != 0 && (EraRestriction)(eraRestrictions & targetRestriction) != eraRestrictions)
				{
					return false;
				}
				return true;
			}
			return false;
		}
		return true;
	}

	public static ulong FindSkin(int itemID, int skinID)
	{
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemID);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return 0uL;
		}
		IPlayerItemDefinition itemDefinition2 = PlatformService.Instance.GetItemDefinition(skinID);
		if (itemDefinition2 != null)
		{
			ulong workshopDownload = itemDefinition2.WorkshopDownload;
			if (workshopDownload != 0L)
			{
				string itemShortName = itemDefinition2.ItemShortName;
				if (itemShortName == itemDefinition.shortname || itemShortName == ((Object)itemDefinition).name)
				{
					return workshopDownload;
				}
			}
		}
		for (int i = 0; i < itemDefinition.skins.Length; i++)
		{
			if (itemDefinition.skins[i].id == skinID)
			{
				return (ulong)skinID;
			}
		}
		return 0uL;
	}

	public float GetWorldModelMass()
	{
		if (_worldModelMass != 0f)
		{
			return _worldModelMass;
		}
		GameObject val = worldModelPrefab?.Get();
		if ((Object)(object)val != (Object)null)
		{
			WorldModel component = val.GetComponent<WorldModel>();
			if ((Object)(object)component != (Object)null && component.mass != 0f)
			{
				_worldModelMass = component.mass;
				return _worldModelMass;
			}
		}
		_worldModelMass = 1f;
		return _worldModelMass;
	}

	public bool HasFlag(Flag f)
	{
		return (flags & f) == f;
	}

	public void Initialize(List<ItemDefinition> itemList)
	{
		if (itemMods != null)
		{
			Debug.LogError((object)("Item Definition Initializing twice: " + ((Object)this).name));
		}
		skins = ItemSkinDirectory.ForItem(this);
		itemMods = ((Component)this).GetComponentsInChildren<ItemMod>(true);
		ItemMod[] array = itemMods;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].ModInit();
		}
		Children = itemList.Where((ItemDefinition x) => (Object)(object)x.Parent == (Object)(object)this).ToArray();
		ItemModWearable = ((Component)this).GetComponent<ItemModWearable>();
		ItemModBurnable = ((Component)this).GetComponent<ItemModBurnable>();
		ItemModCookable = ((Component)this).GetComponent<ItemModCookable>();
		isHoldable = (Object)(object)((Component)this).GetComponent<ItemModEntity>() != (Object)null;
		isUsable = (Object)(object)((Component)this).GetComponent<ItemModEntity>() != (Object)null || (Object)(object)((Component)this).GetComponent<ItemModConsume>() != (Object)null;
		Blueprint = ((Component)this).GetComponent<ItemBlueprint>();
	}

	public GameObjectRef GetWorldModel(int amount)
	{
		if (worldModelOverrides == null || worldModelOverrides.Length == 0)
		{
			return worldModelPrefab;
		}
		for (int num = worldModelOverrides.Length - 1; num >= 0; num--)
		{
			if (amount >= worldModelOverrides[num].minStackSize)
			{
				return worldModelOverrides[num].worldModel;
			}
		}
		return worldModelPrefab;
	}

	public int GetWorldModelIndex(int amount)
	{
		if (worldModelOverrides == null || worldModelOverrides.Length == 0)
		{
			return -1;
		}
		for (int num = worldModelOverrides.Length - 1; num >= 0; num--)
		{
			if (amount >= worldModelOverrides[num].minStackSize)
			{
				return num;
			}
		}
		return -1;
	}

	public bool SupportsItemOwnership()
	{
		if (stackable != 1)
		{
			if (supportsStackableOwnership)
			{
				return Inventory.stackable_item_ownership;
			}
			return false;
		}
		return true;
	}
}


using System;

[Flags]
public enum LootDistributionModifierType
{
	None = 0,
	Firearm = 1,
	FirearmAmmunition = 2,
	Unused = int.MinValue
}


using System;
using UnityEngine;

[Serializable]
public struct Condition
{
	[Serializable]
	public class WorldSpawnCondition
	{
		public float fractionMin = 1f;

		public float fractionMax = 1f;
	}

	public bool enabled;

	[Tooltip("The maximum condition this item type can have, new items will start with this value")]
	public float max;

	[Tooltip("If false then item will destroy when condition reaches 0")]
	public bool repairable;

	[Tooltip("If true, never lose max condition when repaired")]
	public bool maintainMaxCondition;

	public bool ovenCondition;

	public WorldSpawnCondition foundCondition;

	public bool hideConditionBar;

	public GameObjectRef breakEffect;
}


using System;

[Serializable]
public class WorldSpawnCondition
{
	public float fractionMin = 1f;

	public float fractionMax = 1f;
}


using System;

[Serializable]
public struct OverrideWorldModel
{
	public GameObjectRef worldModel;

	public int minStackSize;
}


public enum RedirectVendingBehaviour
{
	NoListing,
	ListAsUniqueItem
}


using System;

[Flags]
public enum Flag
{
	NoDropping = 1,
	NotStraightToBelt = 2,
	NotAllowedInBelt = 4,
	Backpack = 8
}


public enum AmountType
{
	Count,
	Millilitre,
	Feet,
	Genetics,
	OxygenSeconds,
	Frequency,
	Generic,
	BagLimit,
	ShelterLimit,
	ContentCount,
	TurretLimit,
	NucleusGrades
}


public enum ItemCategory
{
	Weapon,
	Construction,
	Items,
	Resources,
	Attire,
	Tool,
	Medical,
	Food,
	Ammunition,
	Traps,
	Misc,
	All,
	Common,
	Component,
	Search,
	Favourite,
	Electrical,
	Fun
}


using System;

[Flags]
public enum ItemSlot
{
	None = 1,
	Barrel = 2,
	Silencer = 4,
	Scope = 8,
	UnderBarrel = 0x10,
	Magazine = 0x20,
	Internal = 0x40,
	InternalTargeting = 0x80
}


public enum ItemSelectionPanel
{
	None,
	Vessel,
	Modifications,
	GunInformation
}


using UnityEngine;

public class ItemSelector : PropertyAttribute
{
}


using UnityEngine;

public class ItemMod : MonoBehaviour
{
	protected ItemMod[] siblingMods;

	public virtual void ModInit()
	{
		siblingMods = ((Component)this).GetComponents<ItemMod>();
	}

	public virtual void OnItemCreated(Item item)
	{
	}

	public virtual void OnVirginItem(Item item, BasePlayer creatingPlayer)
	{
	}

	public virtual void ServerCommand(Item item, string command, BasePlayer player)
	{
	}

	public virtual void DoAction(Item item, BasePlayer player)
	{
	}

	public virtual void OnRemove(Item item)
	{
	}

	public virtual void OnParentChanged(Item item)
	{
	}

	public virtual void CollectedForCrafting(Item item, BasePlayer crafter)
	{
	}

	public virtual void ReturnedFromCancelledCraft(Item item, BasePlayer crafter)
	{
	}

	public virtual void OnAttacked(Item item, HitInfo info)
	{
	}

	public virtual void OnChanged(Item item)
	{
	}

	public virtual bool CanDoAction(Item item, BasePlayer player)
	{
		ItemMod[] array = siblingMods;
		for (int i = 0; i < array.Length; i++)
		{
			if (!array[i].Passes(item))
			{
				return false;
			}
		}
		return true;
	}

	public virtual bool Passes(Item item)
	{
		return true;
	}

	public virtual void OnRemovedFromWorld(Item item)
	{
	}

	public virtual void OnMovedToWorld(Item item)
	{
	}
}


using UnityEngine;

public class ItemModActionChange : ItemMod
{
	public ItemMod[] actions;

	public override void OnChanged(Item item)
	{
		if (!item.isServer)
		{
			return;
		}
		BasePlayer ownerPlayer = item.GetOwnerPlayer();
		ItemMod[] array = actions;
		foreach (ItemMod itemMod in array)
		{
			if (itemMod.CanDoAction(item, ownerPlayer))
			{
				itemMod.DoAction(item, ownerPlayer);
			}
		}
	}

	private void OnValidate()
	{
		if (actions == null)
		{
			Debug.LogWarning((object)"ItemModMenuOption: actions is null!", (Object)(object)((Component)this).gameObject);
		}
	}
}


using UnityEngine;

public class ItemModActionContainerChange : ItemMod
{
	public ItemMod[] actions;

	public override void OnParentChanged(Item item)
	{
		if (!item.isServer)
		{
			return;
		}
		BasePlayer ownerPlayer = item.GetOwnerPlayer();
		ItemMod[] array = actions;
		foreach (ItemMod itemMod in array)
		{
			if (itemMod.CanDoAction(item, ownerPlayer))
			{
				itemMod.DoAction(item, ownerPlayer);
			}
		}
	}

	private void OnValidate()
	{
		if (actions == null)
		{
			Debug.LogWarning((object)"ItemModMenuOption: actions is null!", (Object)(object)((Component)this).gameObject);
		}
	}
}


public class ItemModAlterCondition : ItemMod
{
	public float conditionChange;

	public override void DoAction(Item item, BasePlayer player)
	{
		if (item.amount >= 1)
		{
			if (conditionChange < 0f)
			{
				item.LoseCondition(conditionChange * -1f);
			}
			else
			{
				item.RepairCondition(conditionChange);
			}
		}
	}
}


public class ItemModAnimalEquipment : ItemMod
{
	public enum SlotType
	{
		Basic,
		Armor,
		Saddle,
		Bit,
		Feet,
		SaddleDouble
	}

	public BaseEntity.Flags WearableFlag;

	public bool hideHair;

	public ProtectionProperties animalProtection;

	public ProtectionProperties riderProtection;

	public int additionalInventorySlots;

	public float speedModifier;

	public float staminaUseModifier;

	public SlotType slot;
}


public enum SlotType
{
	Basic,
	Armor,
	Saddle,
	Bit,
	Feet,
	SaddleDouble
}


public class ItemModArmorInsert : ItemMod
{
	public ProtectionProperties protectionProperties;

	public float SpeedReduction;
}


using ProtoBuf;
using UnityEngine;

public abstract class ItemModAssociatedEntity<T> : ItemMod where T : BaseEntity
{
	public GameObjectRef entityPrefab;

	protected virtual bool AllowNullParenting => false;

	protected virtual bool AllowHeldEntityParenting => false;

	protected virtual bool ShouldAutoCreateEntity => true;

	protected virtual bool OwnedByParentPlayer => false;

	public override void OnItemCreated(Item item)
	{
		base.OnItemCreated(item);
		if (ShouldAutoCreateEntity)
		{
			CreateAssociatedEntity(item);
		}
	}

	public T CreateAssociatedEntity(Item item)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Expected O, but got Unknown
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		if (item.instanceData != null)
		{
			return null;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(entityPrefab.resourcePath, Vector3.zero);
		T component = ((Component)baseEntity).GetComponent<T>();
		OnAssociatedItemCreated(component);
		baseEntity.Spawn();
		item.instanceData = new InstanceData();
		item.instanceData.ShouldPool = false;
		item.instanceData.subEntity = baseEntity.net.ID;
		item.MarkDirty();
		return component;
	}

	protected virtual void OnAssociatedItemCreated(T ent)
	{
	}

	public override void OnRemove(Item item)
	{
		base.OnRemove(item);
		T associatedEntity = GetAssociatedEntity(item);
		if (Object.op_Implicit((Object)(object)associatedEntity))
		{
			associatedEntity.Kill();
		}
	}

	public override void OnMovedToWorld(Item item)
	{
		UpdateParent(item);
		base.OnMovedToWorld(item);
	}

	public override void OnRemovedFromWorld(Item item)
	{
		UpdateParent(item);
		base.OnRemovedFromWorld(item);
	}

	public void UpdateParent(Item item)
	{
		T associatedEntity = GetAssociatedEntity(item);
		if ((Object)(object)associatedEntity == (Object)null)
		{
			return;
		}
		BaseEntity entityForParenting = GetEntityForParenting(item);
		if ((Object)(object)entityForParenting == (Object)null)
		{
			if (AllowNullParenting)
			{
				associatedEntity.SetParent(null, worldPositionStays: false, sendImmediate: true);
			}
			if (OwnedByParentPlayer)
			{
				associatedEntity.OwnerID = 0uL;
			}
		}
		else if (entityForParenting.isServer && entityForParenting.IsFullySpawned())
		{
			associatedEntity.SetParent(entityForParenting, worldPositionStays: false, sendImmediate: true);
			if (OwnedByParentPlayer && entityForParenting is BasePlayer basePlayer)
			{
				associatedEntity.OwnerID = basePlayer.userID;
			}
		}
	}

	public override void OnParentChanged(Item item)
	{
		base.OnParentChanged(item);
		UpdateParent(item);
	}

	public BaseEntity GetEntityForParenting(Item item = null)
	{
		if (item != null)
		{
			Item item2 = item;
			Item parentItem = item.parentItem;
			if (parentItem != null && parentItem.IsBackpack())
			{
				item2 = item.parentItem;
			}
			BasePlayer ownerPlayer = item2.GetOwnerPlayer();
			if (Object.op_Implicit((Object)(object)ownerPlayer))
			{
				return ownerPlayer;
			}
			BaseEntity baseEntity = ((item2.parent == null) ? null : item2.parent.entityOwner);
			if ((Object)(object)baseEntity != (Object)null)
			{
				return baseEntity;
			}
			BaseEntity worldEntity = item2.GetWorldEntity();
			if (Object.op_Implicit((Object)(object)worldEntity))
			{
				return worldEntity;
			}
			if (AllowHeldEntityParenting && item.parentItem != null && (Object)(object)item.parentItem.GetHeldEntity() != (Object)null)
			{
				return item.parentItem.GetHeldEntity();
			}
			return null;
		}
		return null;
	}

	public static bool GetAssociatedEntity(Item item, out T result, bool isServer = true)
	{
		result = GetAssociatedEntity(item, isServer);
		return (Object)(object)result != (Object)null;
	}

	public static T GetAssociatedEntity(Item item, bool isServer = true)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if (item?.instanceData == null)
		{
			return null;
		}
		BaseNetworkable baseNetworkable = null;
		if (isServer)
		{
			baseNetworkable = BaseNetworkable.serverEntities.Find(item.instanceData.subEntity);
		}
		if (Object.op_Implicit((Object)(object)baseNetworkable))
		{
			return ((Component)baseNetworkable).GetComponent<T>();
		}
		return null;
	}
}


using System;
using UnityEngine;

public class ItemModBackpack : ItemMod
{
	public SoundDefinition ZipSound;

	[Header("Should the 'selected' panel be hidden when the backpack is selected when equipped")]
	public bool hideSelectedPanel;

	[Header("Backpack's item volume when items are in it")]
	public int containerVolumeWhenFilled = 1;

	public bool DropWhenDowned;

	public override void OnItemCreated(Item item)
	{
		base.OnItemCreated(item);
		if (item.contents != null)
		{
			ItemContainer contents = item.contents;
			contents.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(contents.canAcceptItem, (Func<Item, int, bool>)((Item subItem, int slot) => CanAcceptItem(item, subItem, slot)));
		}
	}

	public bool CanAcceptItem(Item backpack, Item item, int slot)
	{
		if (backpack.parent == null)
		{
			return true;
		}
		if (backpack.parent.HasFlag(ItemContainer.Flag.Clothing))
		{
			return true;
		}
		return false;
	}
}


using UnityEngine;

public class ItemModBaitContainer : ItemModContainer
{
	protected override bool ForceAcceptItemCheck => true;

	protected override bool CanAcceptItem(Item item, int count)
	{
		ItemModCompostable component = ((Component)item.info).GetComponent<ItemModCompostable>();
		if ((Object)(object)component != (Object)null)
		{
			return component.BaitValue > 0f;
		}
		return false;
	}

	protected override void SetAllowedItems(ItemContainer container)
	{
		FishLookup.LoadFish();
		container.SetOnlyAllowedItems(FishLookup.BaitItems);
	}
}


using UnityEngine;

public class ItemModBlueprintCraft : ItemMod
{
	public static readonly Phrase CraftItemTitle = new Phrase("craft_item", "Craft");

	public static readonly Phrase CraftItemDesc = new Phrase("craft_item_desc", "Create the item the blueprint is referring to");

	public static readonly Phrase CraftAllTitle = new Phrase("craft_all", "Craft All");

	public static readonly Phrase CraftAllDesc = new Phrase("craft_all_desc", "Craft all available blueprints into items");

	public GameObjectRef successEffect;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)item.GetOwnerPlayer() != (Object)(object)player)
		{
			return;
		}
		if (command == "craft")
		{
			if (!item.IsBlueprint() || !player.inventory.crafting.CanCraft(item.blueprintTargetDef.Blueprint))
			{
				return;
			}
			Item fromTempBlueprint = item;
			if (item.amount > 1)
			{
				fromTempBlueprint = item.SplitItem(1);
			}
			player.inventory.crafting.CraftItem(item.blueprintTargetDef.Blueprint, player, null, 1, 0, fromTempBlueprint);
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
		if (command == "craft_all" && item.IsBlueprint() && player.inventory.crafting.CanCraft(item.blueprintTargetDef.Blueprint, item.amount))
		{
			player.inventory.crafting.CraftItem(item.blueprintTargetDef.Blueprint, player, null, item.amount, 0, item);
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}
}


public class ItemModBurnable : ItemMod
{
	public float fuelAmount = 10f;

	[ItemSelector]
	public ItemDefinition byproductItem;

	public int byproductAmount = 1;

	public float byproductChance = 0.5f;

	public override void OnItemCreated(Item item)
	{
		item.fuel = fuelAmount;
	}
}


public class ItemModCassetteContainer : ItemModContainer
{
	public ItemDefinition[] CassetteItems;

	protected override bool ForceAcceptItemCheck => true;

	protected override void SetAllowedItems(ItemContainer container)
	{
		container.SetOnlyAllowedItems(CassetteItems);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class ItemModCatapultBoulder : MonoBehaviour
{
	[Serializable]
	public struct ProjectileSettings
	{
		public GameObjectRef prefab;

		public int count;

		public float gravityModifier;
	}

	[SerializeField]
	public List<ProjectileSettings> projectileSettings = new List<ProjectileSettings>();

	public float spreadAngle = 6f;
}


using System;

[Serializable]
public struct ProjectileSettings
{
	public GameObjectRef prefab;

	public int count;

	public float gravityModifier;
}


public class ItemModChildIO : ItemMod
{
	public GameObjectRef TargetChildIO;
}


using UnityEngine;

public class ItemModCompostable : MonoBehaviour
{
	public float TotalFertilizerProduced = 0.2f;

	public float BaitValue = 1f;

	public int MaxBaitStack;
}


public class ItemModConditionContainerFlag : ItemMod
{
	public ItemContainer.Flag flag;

	public bool requiredState;

	public override bool Passes(Item item)
	{
		if (item.parent == null)
		{
			return !requiredState;
		}
		if (!item.parent.HasFlag(flag))
		{
			return !requiredState;
		}
		return requiredState;
	}
}


using UnityEngine;

public class ItemModConditionHasCondition : ItemMod
{
	public float conditionTarget = 1f;

	[Tooltip("If set to above 0 will check for fraction instead of raw value")]
	public float conditionFractionTarget = -1f;

	public bool lessThan;

	public override bool Passes(Item item)
	{
		if (!item.hasCondition)
		{
			return false;
		}
		if (conditionFractionTarget > 0f)
		{
			if (lessThan || !(item.conditionNormalized > conditionFractionTarget))
			{
				if (lessThan)
				{
					return item.conditionNormalized < conditionFractionTarget;
				}
				return false;
			}
			return true;
		}
		if (lessThan || !(item.condition >= conditionTarget))
		{
			if (lessThan)
			{
				return item.condition < conditionTarget;
			}
			return false;
		}
		return true;
	}
}


using System.Linq;
using UnityEngine;

public class ItemModConditionHasContents : ItemMod
{
	[Tooltip("Can be null to mean any item")]
	public ItemDefinition itemDef;

	public bool requiredState;

	public override bool Passes(Item item)
	{
		if (item.contents == null)
		{
			return !requiredState;
		}
		if (item.contents.itemList.Count == 0)
		{
			return !requiredState;
		}
		if (Object.op_Implicit((Object)(object)itemDef) && !item.contents.itemList.Any((Item x) => (Object)(object)x.info == (Object)(object)itemDef))
		{
			return !requiredState;
		}
		return requiredState;
	}
}


public class ItemModConditionHasFlag : ItemMod
{
	public Item.Flag flag;

	public bool requiredState;

	public override bool Passes(Item item)
	{
		return item.HasFlag(flag) == requiredState;
	}
}


using UnityEngine;

public class ItemModConditionInWater : ItemMod
{
	public bool requiredState;

	public override bool Passes(Item item)
	{
		BasePlayer ownerPlayer = item.GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null)
		{
			return false;
		}
		return ownerPlayer.IsHeadUnderwater() == requiredState;
	}
}


using UnityEngine;

public class ItemModConditionIsSleeping : ItemMod
{
	public bool requiredState;

	public override bool Passes(Item item)
	{
		BasePlayer ownerPlayer = item.GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null)
		{
			return false;
		}
		return ownerPlayer.IsSleeping() == requiredState;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class ItemModConsumable : MonoBehaviour
{
	[Serializable]
	public class ConsumableEffect
	{
		public MetabolismAttribute.Type type;

		public float amount;

		public float time;

		public float onlyIfHealthLessThan = 1f;
	}

	public int amountToConsume = 1;

	public float conditionFractionToLose;

	public string achievementWhenEaten;

	public bool chickenCoopFood;

	public List<ConsumableEffect> effects = new List<ConsumableEffect>();

	public List<ModifierDefintion> modifiers = new List<ModifierDefintion>();

	public float GetIfType(MetabolismAttribute.Type typeToPick)
	{
		for (int i = 0; i < effects.Count; i++)
		{
			if (effects[i].type == typeToPick)
			{
				return effects[i].amount;
			}
		}
		return 0f;
	}
}


using System;

[Serializable]
public class ConsumableEffect
{
	public MetabolismAttribute.Type type;

	public float amount;

	public float time;

	public float onlyIfHealthLessThan = 1f;
}


using Facepunch.Rust;
using Oxide.Core;
using Rust;
using UnityEngine;

[RequireComponent(typeof(ItemModConsumable))]
public class ItemModConsume : ItemMod
{
	public GameObjectRef consumeEffect;

	public string eatGesture = "eat_2hand";

	[Tooltip("Items that are given on consumption of this item")]
	public ItemAmountRandom[] product;

	public ItemModConsumable primaryConsumable;

	public virtual ItemModConsumable GetConsumable()
	{
		if (Object.op_Implicit((Object)(object)primaryConsumable))
		{
			return primaryConsumable;
		}
		return ((Component)this).GetComponent<ItemModConsumable>();
	}

	public virtual GameObjectRef GetConsumeEffect()
	{
		return consumeEffect;
	}

	public override void DoAction(Item item, BasePlayer player)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		if (item.amount < 1)
		{
			return;
		}
		GameObjectRef gameObjectRef = GetConsumeEffect();
		if (gameObjectRef.isValid)
		{
			Vector3 posLocal = (player.IsDucked() ? new Vector3(0f, 1f, 0f) : new Vector3(0f, 2f, 0f));
			Effect.server.Run(gameObjectRef.resourcePath, player, 0u, posLocal, Vector3.zero);
		}
		player.metabolism.MarkConsumption();
		ItemModConsumable consumable = GetConsumable();
		if (!string.IsNullOrEmpty(consumable.achievementWhenEaten))
		{
			player.GiveAchievement(consumable.achievementWhenEaten);
		}
		Analytics.Azure.OnConsumableUsed(player, item);
		float num = Mathf.Max(consumable.amountToConsume, 1);
		float num2 = Mathf.Min((float)item.amount, num);
		float num3 = num2 / num;
		float num4 = item.conditionNormalized;
		if (consumable.conditionFractionToLose > 0f)
		{
			num4 = consumable.conditionFractionToLose;
		}
		foreach (ItemModConsumable.ConsumableEffect effect in consumable.effects)
		{
			if (Mathf.Clamp01(player.healthFraction + player.metabolism.pending_health.Fraction()) > effect.onlyIfHealthLessThan)
			{
				continue;
			}
			if (effect.type == MetabolismAttribute.Type.Health)
			{
				if (effect.amount < 0f)
				{
					player.OnAttacked(new HitInfo(player, player, DamageType.Generic, (0f - effect.amount) * num3 * num4, ((Component)player).transform.position + ((Component)player).transform.forward * 1f));
				}
				else
				{
					player.health += effect.amount * num3 * num4;
				}
			}
			else
			{
				player.metabolism.ApplyChange(effect.type, effect.amount * num3 * num4, effect.time * num3 * num4);
			}
		}
		player.ProcessMissionEvent(BaseMission.MissionEventType.CONSUME, item.info.itemid, 1f);
		if ((Object)(object)player.modifiers != (Object)null && Interface.CallHook("OnPlayerAddModifiers", (object)player, (object)item, (object)consumable) == null)
		{
			player.modifiers.Add(consumable.modifiers);
		}
		if (product != null)
		{
			ItemAmountRandom[] array = product;
			foreach (ItemAmountRandom itemAmountRandom in array)
			{
				int num5 = Mathf.RoundToInt((float)itemAmountRandom.RandomAmount() * num4);
				if (num5 > 0)
				{
					Item item2 = ItemManager.Create(itemAmountRandom.itemDef, num5, 0uL);
					player.GiveItem(item2);
				}
			}
		}
		if (string.IsNullOrEmpty(eatGesture))
		{
			player.SignalBroadcast(BaseEntity.Signal.Gesture, eatGesture);
		}
		if (consumable.conditionFractionToLose > 0f)
		{
			item.LoseCondition(consumable.conditionFractionToLose * item.maxCondition);
		}
		else
		{
			item.UseItem((int)num2);
		}
	}

	public override bool CanDoAction(Item item, BasePlayer player)
	{
		return player.metabolism.CanConsume();
	}
}


using UnityEngine;

public class ItemModConsumeChance : ItemModConsume
{
	public float chanceForSecondaryConsume = 0.5f;

	public GameObjectRef secondaryConsumeEffect;

	public ItemModConsumable secondaryConsumable;

	private bool GetChance()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		State state = Random.state;
		Random.InitState(Time.frameCount);
		bool result = Random.Range(0f, 1f) <= chanceForSecondaryConsume;
		Random.state = state;
		return result;
	}

	public override ItemModConsumable GetConsumable()
	{
		if (GetChance())
		{
			return secondaryConsumable;
		}
		return base.GetConsumable();
	}

	public override GameObjectRef GetConsumeEffect()
	{
		if (GetChance())
		{
			return secondaryConsumeEffect;
		}
		return base.GetConsumeEffect();
	}
}


using UnityEngine;

public class ItemModConsumeContents : ItemMod
{
	public GameObjectRef consumeEffect;

	public override void DoAction(Item item, BasePlayer player)
	{
		foreach (Item item2 in item.contents.itemList)
		{
			ItemModConsume component = ((Component)item2.info).GetComponent<ItemModConsume>();
			if (!((Object)(object)component == (Object)null) && component.CanDoAction(item2, player))
			{
				component.DoAction(item2, player);
				item.contents?.onItemRemovedFromStack?.Invoke(item2, 0);
				break;
			}
		}
	}

	public override bool CanDoAction(Item item, BasePlayer player)
	{
		if (!player.metabolism.CanConsume())
		{
			return false;
		}
		if (item.contents == null)
		{
			return false;
		}
		foreach (Item item2 in item.contents.itemList)
		{
			ItemModConsume component = ((Component)item2.info).GetComponent<ItemModConsume>();
			if (!((Object)(object)component == (Object)null) && component.CanDoAction(item2, player))
			{
				return true;
			}
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

public class ItemModContainer : ItemMod
{
	public int capacity = 6;

	public int maxStackSize;

	public int containerVolume;

	public bool canLootInWorld;

	public float pickupInWorldDelay;

	public float maxWeight = -1f;

	public float worldWeightScale = 1f;

	[InspectorFlags]
	public ItemContainer.Flag containerFlags;

	public ItemContainer.ContentsType onlyAllowedContents = ItemContainer.ContentsType.Generic;

	public ItemDefinition onlyAllowedItemType;

	public List<ItemSlot> availableSlots = new List<ItemSlot>();

	public ItemDefinition[] validItemWhitelist = new ItemDefinition[0];

	public bool openInDeployed = true;

	public bool openInInventory = true;

	public List<ItemAmount> defaultContents = new List<ItemAmount>();

	[Tooltip("If true items in this container won't be usable as ammo for reloads")]
	public bool blockAmmoSource;

	[Header("Sounds")]
	public SoundDefinition openSound;

	public SoundDefinition closeSound;

	protected virtual bool ForceAcceptItemCheck => false;

	public override void OnItemCreated(Item item)
	{
		CreateContents(item);
	}

	protected void CreateContents(Item item)
	{
		if (!item.isServer || capacity <= 0)
		{
			return;
		}
		if (item.contents != null)
		{
			if (validItemWhitelist != null && validItemWhitelist.Length != 0)
			{
				item.contents.canAcceptItem = CanAcceptItem;
			}
			return;
		}
		Debug.Assert(item.contents == null, "Double init of contents!");
		item.contents = Pool.Get<ItemContainer>();
		item.contents.flags = containerFlags;
		item.contents.allowedContents = ((onlyAllowedContents == (ItemContainer.ContentsType)0) ? ItemContainer.ContentsType.Generic : onlyAllowedContents);
		SetAllowedItems(item.contents);
		item.contents.UpdateAvailableSlots(availableSlots);
		ItemContainer contents = item.contents;
		contents.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(contents.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedOrRemoved));
		if ((validItemWhitelist != null && validItemWhitelist.Length != 0) || ForceAcceptItemCheck)
		{
			item.contents.canAcceptItem = CanAcceptItem;
		}
		item.contents.ServerInitialize(item, capacity);
		item.contents.containerVolume = containerVolume;
		item.contents.maxStackSize = maxStackSize;
		item.contents.GiveUID();
	}

	protected virtual void SetAllowedItems(ItemContainer container)
	{
		container.SetOnlyAllowedItem(onlyAllowedItemType);
	}

	protected virtual bool CanAcceptItem(Item item, int count)
	{
		ItemDefinition[] array = validItemWhitelist;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].itemid == item.info.itemid)
			{
				return true;
			}
		}
		return false;
	}

	private void OnItemAddedOrRemoved(Item item, bool added)
	{
		if (!Application.isLoadingSave)
		{
			DroppedItem droppedItem = item.parentItem?.GetWorldEntity() as DroppedItem;
			if (!((Object)(object)droppedItem == (Object)null))
			{
				droppedItem.UpdateItemMass();
			}
		}
	}

	public override void OnVirginItem(Item item, BasePlayer creatingPlayer)
	{
		base.OnVirginItem(item, creatingPlayer);
		foreach (ItemAmount defaultContent in defaultContents)
		{
			ItemManager.Create(defaultContent.itemDef, (int)defaultContent.amount, 0uL)?.MoveToContainer(item.contents);
		}
	}

	public override void CollectedForCrafting(Item item, BasePlayer crafter)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (item.contents == null)
		{
			return;
		}
		for (int num = item.contents.itemList.Count - 1; num >= 0; num--)
		{
			Item item2 = item.contents.itemList[num];
			if (!item2.MoveToContainer(crafter.inventory.containerMain))
			{
				item2.Drop(crafter.GetDropPosition(), crafter.GetDropVelocity());
			}
		}
	}
}


using Rust;
using UnityEngine;

public class ItemModContainerArmorSlot : ItemModContainer
{
	public int MinSlots;

	public int MaxSlots = 3;

	public bool CraftedItemsOnly = true;

	private static float[] RollChances = new float[3] { 0.25f, 0.1f, 0.05f };

	public override void OnVirginItem(Item item, BasePlayer creatingPlayer)
	{
		if (item.isServer)
		{
			base.OnVirginItem(item, creatingPlayer);
			CreateForPlayer(item, creatingPlayer);
		}
	}

	private static int GetRandomSlotCount(float improveChance, int min, int max)
	{
		float num = Random.Range(0f, 1f - improveChance);
		int num2 = 0;
		if (num <= 0.5f || improveChance > 0f)
		{
			num2 = min;
			for (int i = 0; i < max - min && num <= RollChances[Mathf.Clamp(i, 0, RollChances.Length)]; i++)
			{
				num2++;
			}
		}
		return num2;
	}

	public void CreateForPlayer(Item item, BasePlayer player)
	{
		if (!((Object)(object)player == (Object)null) || !CraftedItemsOnly)
		{
			int cap = 0;
			if ((Object)(object)player != (Object)null)
			{
				cap = GetRandomSlotCount(Mathf.Clamp01(player.modifiers.GetValue(Modifier.ModifierType.Crafting_Quality)), MinSlots, MaxSlots);
			}
			CreateAtCapacity(cap, item);
		}
	}

	public void SetSlotAmount(Item item, int amount)
	{
		if (item.contents != null)
		{
			item.contents.capacity = amount;
			item.MarkDirty();
		}
		else
		{
			CreateAtCapacity(amount, item);
		}
	}

	public void CreateAtCapacity(int cap, Item item)
	{
		capacity = cap;
		if (capacity != 0)
		{
			CreateContents(item);
			if (item != null && item.contents != null)
			{
				item.contents.canAcceptItem = CanAcceptArmorItem;
			}
		}
	}

	public override void OnItemCreated(Item item)
	{
		if (capacity > 0 && item != null && item.contents != null)
		{
			item.contents.canAcceptItem = CanAcceptArmorItem;
		}
	}

	protected bool CanAcceptArmorItem(Item item, int count)
	{
		if (item == null || (Object)(object)item.info == (Object)null)
		{
			return false;
		}
		if ((Object)(object)((Component)item.info).GetComponent<ItemModArmorInsert>() == (Object)null)
		{
			return false;
		}
		return true;
	}

	public float TotalSpeedReduction(Item item)
	{
		if (item == null)
		{
			return 0f;
		}
		if (item.contents == null)
		{
			return 0f;
		}
		if (item.contents.itemList == null)
		{
			return 0f;
		}
		float num = 0f;
		ItemModArmorInsert itemModArmorInsert = default(ItemModArmorInsert);
		foreach (Item item2 in item.contents.itemList)
		{
			if (((Component)item2.info).TryGetComponent<ItemModArmorInsert>(ref itemModArmorInsert))
			{
				num += itemModArmorInsert.SpeedReduction;
			}
		}
		return num;
	}

	public float GetProtection(Item item, DamageType damageType)
	{
		if (item == null)
		{
			return 0f;
		}
		if (item.contents == null)
		{
			return 0f;
		}
		if (item.contents.itemList == null)
		{
			return 0f;
		}
		float num = 0f;
		ItemModArmorInsert itemModArmorInsert = default(ItemModArmorInsert);
		foreach (Item item2 in item.contents.itemList)
		{
			if (((Component)item2.info).TryGetComponent<ItemModArmorInsert>(ref itemModArmorInsert))
			{
				num += itemModArmorInsert.protectionProperties.amounts[(int)damageType];
			}
		}
		return num;
	}

	public void CollectProtection(Item item, ProtectionProperties protection)
	{
		if (item == null || item.contents == null || (Object)(object)protection == (Object)null)
		{
			return;
		}
		ItemModArmorInsert itemModArmorInsert = default(ItemModArmorInsert);
		foreach (Item item2 in item.contents.itemList)
		{
			if (((Component)item2.info).TryGetComponent<ItemModArmorInsert>(ref itemModArmorInsert) && !((Object)(object)itemModArmorInsert.protectionProperties == (Object)null))
			{
				protection.Add(itemModArmorInsert.protectionProperties, 1f);
			}
		}
	}
}


using System;

public class ItemModContainerRads : ItemModContainer
{
	public override void OnItemCreated(Item item)
	{
		base.OnItemCreated(item);
		if (item != null && item.contents != null)
		{
			CountRads(item.contents);
			ItemContainer contents = item.contents;
			contents.onItemParentChanged = (Action<Item, Item>)Delegate.Combine(contents.onItemParentChanged, new Action<Item, Item>(OnItemParentChanged));
			ItemContainer contents2 = item.contents;
			contents2.onItemRadiationChanged = (Action<Item, float>)Delegate.Combine(contents2.onItemRadiationChanged, new Action<Item, float>(OnItemRadiationChanged));
			ItemContainer contents3 = item.contents;
			contents3.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(contents3.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
			ItemContainer contents4 = item.contents;
			contents4.onItemAddedToStack = (Action<Item, int>)Delegate.Combine(contents4.onItemAddedToStack, new Action<Item, int>(OnItemAddedToStack));
			ItemContainer contents5 = item.contents;
			contents5.onItemRemovedFromStack = (Action<Item, int>)Delegate.Combine(contents5.onItemRemovedFromStack, new Action<Item, int>(OnItemRemovedFromStack));
		}
	}

	public override void OnRemove(Item item)
	{
		base.OnRemove(item);
		if (item != null && item.contents != null)
		{
			ItemContainer contents = item.contents;
			contents.onItemParentChanged = (Action<Item, Item>)Delegate.Remove(contents.onItemParentChanged, new Action<Item, Item>(OnItemParentChanged));
			ItemContainer contents2 = item.contents;
			contents2.onItemRadiationChanged = (Action<Item, float>)Delegate.Remove(contents2.onItemRadiationChanged, new Action<Item, float>(OnItemRadiationChanged));
			ItemContainer contents3 = item.contents;
			contents3.onItemAddedRemoved = (Action<Item, bool>)Delegate.Remove(contents3.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
			ItemContainer contents4 = item.contents;
			contents4.onItemAddedToStack = (Action<Item, int>)Delegate.Remove(contents4.onItemAddedToStack, new Action<Item, int>(OnItemAddedToStack));
			ItemContainer contents5 = item.contents;
			contents5.onItemRemovedFromStack = (Action<Item, int>)Delegate.Remove(contents5.onItemRemovedFromStack, new Action<Item, int>(OnItemRemovedFromStack));
		}
	}

	public override void OnParentChanged(Item item)
	{
		ProcessRadCountFromParent(item);
	}

	private void OnItemParentChanged(Item parent, Item child)
	{
		ProcessRadCountFromParent(parent);
	}

	private void OnItemRadiationChanged(Item item, float rads)
	{
		ProcessRadCountFromChild(item);
	}

	private void OnItemAddedRemoved(Item childItem, bool added)
	{
		if (childItem != null)
		{
			ProcessRadCountFromChild(childItem);
		}
	}

	private void OnItemRemovedFromStack(Item childItem, int amount)
	{
		ProcessRadCountFromChild(childItem);
	}

	private void OnItemAddedToStack(Item childItem, int amount)
	{
		ProcessRadCountFromChild(childItem);
	}

	private void ProcessRadCountFromChild(Item childItem)
	{
		ItemContainer parent = childItem.parent;
		if (parent != null)
		{
			CountRads(parent);
		}
	}

	private void ProcessRadCountFromParent(Item item, bool skipEvent = false)
	{
		ItemContainer contents = item.contents;
		if (contents != null)
		{
			CountRads(contents, skipEvent);
		}
	}

	private void CountRads(ItemContainer container, bool skipEvent = false)
	{
		Item parent = container.parent;
		if (container?.itemList == null)
		{
			return;
		}
		if (container.itemList.Count == 0)
		{
			parent.radioactivity = 0f;
			if (!skipEvent)
			{
				parent.parent?.onItemRadiationChanged?.Invoke(parent, 0f);
			}
		}
		else
		{
			if (container.itemList[0] == null)
			{
				return;
			}
			float num = 0f;
			foreach (Item item in container.itemList)
			{
				num += (float)item.amount * item.radioactivity;
			}
			if (parent == null)
			{
				return;
			}
			if (num > 0f)
			{
				if (!parent.HasFlag(Item.Flag.Radioactive))
				{
					parent.SetFlag(Item.Flag.Radioactive, b: true);
				}
			}
			else if (parent.HasFlag(Item.Flag.Radioactive))
			{
				parent.SetFlag(Item.Flag.Radioactive, b: false);
			}
			parent.radioactivity = num;
			if (parent.parent != null && !skipEvent)
			{
				parent.parent.onItemRadiationChanged?.Invoke(parent, num);
			}
		}
	}
}


using System;
using UnityEngine;

public class ItemModContainerRestriction : ItemMod
{
	[Flags]
	public enum SlotFlags
	{
		Map = 1
	}

	[InspectorFlags]
	public SlotFlags slotFlags;

	public bool CanExistWith(ItemModContainerRestriction other)
	{
		if ((Object)(object)other == (Object)null)
		{
			return true;
		}
		if ((slotFlags & other.slotFlags) != 0)
		{
			return false;
		}
		return true;
	}
}


using System;

[Flags]
public enum SlotFlags
{
	Map = 1
}


using UnityEngine;

public class ItemModConversation : ItemMod
{
	public static readonly Phrase SquakTitle = new Phrase("squak", "MISSING SQUAK PHRASE");

	public static readonly Phrase SquakDesc = new Phrase("squak_desc", "MISSING SQUAK DESC PHRASE");

	public ConversationData conversationData;

	public GameObjectRef conversationEntity;

	public GameObjectRef squakEffect;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		if (command == "squak")
		{
			if (squakEffect.isValid)
			{
				Effect.server.Run(squakEffect.resourcePath, player.eyes.position);
			}
			Debug.Log((object)"Starting conversation");
			BaseEntity baseEntity = GameManager.server.CreateEntity(conversationEntity.resourcePath, ((Component)player).transform.position + Vector3.up * -2f);
			((Component)baseEntity).GetComponent<NPCMissionProvider>().conversations[0] = conversationData;
			baseEntity.Spawn();
			((MonoBehaviour)baseEntity).Invoke("Kill", 600f);
		}
	}
}


public class ItemModConveyorOptions : ItemMod
{
	public bool ForceShowInConveyorFilter;
}


using Facepunch.Rust;
using UnityEngine;

public class ItemModCookable : ItemMod
{
	[ItemSelector]
	public ItemDefinition becomeOnCooked;

	public float cookTime = 30f;

	public int amountOfBecome = 1;

	public int lowTemp;

	public int highTemp;

	public bool setCookingFlag;

	public void OnValidate()
	{
		if (amountOfBecome < 1)
		{
			amountOfBecome = 1;
		}
		if ((Object)(object)becomeOnCooked == (Object)null)
		{
			Debug.LogWarning((object)("[ItemModCookable] becomeOnCooked is unset! [" + ((Object)this).name + "]"), (Object)(object)((Component)this).gameObject);
		}
	}

	public bool CanBeCookedByAtTemperature(float temperature)
	{
		if (temperature > (float)lowTemp)
		{
			return temperature < (float)highTemp;
		}
		return false;
	}

	private void CycleCooking(Item item, float delta)
	{
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		if (!CanBeCookedByAtTemperature(item.temperature) || item.cookTimeLeft < 0f)
		{
			if (setCookingFlag && item.HasFlag(Item.Flag.Cooking))
			{
				item.SetFlag(Item.Flag.Cooking, b: false);
				item.MarkDirty();
			}
			return;
		}
		if (setCookingFlag && !item.HasFlag(Item.Flag.Cooking))
		{
			item.SetFlag(Item.Flag.Cooking, b: true);
			item.MarkDirty();
		}
		item.cookTimeLeft -= delta;
		if (item.cookTimeLeft > 0f)
		{
			item.MarkDirty();
			return;
		}
		float num = item.cookTimeLeft * -1f;
		int num2 = 1 + Mathf.FloorToInt(num / cookTime);
		item.cookTimeLeft = cookTime - num % cookTime;
		BaseOven baseOven = item.GetEntityOwner() as BaseOven;
		num2 = Mathf.Min(num2, item.amount);
		if (item.amount > num2)
		{
			item.amount -= num2;
			item.MarkDirty();
		}
		else
		{
			item.Remove();
		}
		Analytics.Azure.AddPendingItems(baseOven, item.info.shortname, num2, "smelt");
		if (!((Object)(object)becomeOnCooked != (Object)null))
		{
			return;
		}
		Item item2 = ItemManager.Create(becomeOnCooked, amountOfBecome * num2, 0uL);
		Analytics.Azure.AddPendingItems(baseOven, item2.info.shortname, item2.amount, "smelt", consumed: false);
		if ((Object)(object)item.parent.entityOwner != (Object)null && item.parent.entityOwner.net.group.restricted)
		{
			TutorialIsland closestTutorialIsland = TutorialIsland.GetClosestTutorialIsland(((Component)item.parent.entityOwner).transform.position, 50f);
			if ((Object)(object)closestTutorialIsland != (Object)null)
			{
				BasePlayer basePlayer = closestTutorialIsland.ForPlayer.Get(serverside: true);
				if ((Object)(object)basePlayer != (Object)null)
				{
					basePlayer.ProcessMissionEvent(BaseMission.MissionEventType.COOK, new BaseMission.MissionEventPayload
					{
						IntIdentifier = item2.info.itemid,
						WorldPosition = ((Component)item.parent.entityOwner).transform.position,
						NetworkIdentifier = item.parent.entityOwner.net.ID
					}, item2.amount);
				}
			}
		}
		if (item2 != null && !item2.MoveToContainer(item.parent) && !item2.MoveToContainer(item.parent))
		{
			item2.Drop(item.parent.dropPosition, item.parent.dropVelocity);
			if (Object.op_Implicit((Object)(object)item.parent.entityOwner) && (Object)(object)baseOven != (Object)null)
			{
				baseOven.OvenFull();
			}
		}
	}

	public override void OnItemCreated(Item itemcreated)
	{
		itemcreated.cookTimeLeft = cookTime;
		itemcreated.onCycle += CycleCooking;
	}
}


using UnityEngine;

public class ItemModCycle : ItemMod
{
	public ItemMod[] actions;

	public float timeBetweenCycles = 1f;

	public float timerStart;

	public bool onlyAdvanceTimerWhenPass;

	public override void OnItemCreated(Item itemcreated)
	{
		float timeTaken = timerStart;
		itemcreated.onCycle += delegate(Item item, float delta)
		{
			if (!onlyAdvanceTimerWhenPass || CanCycle(item))
			{
				timeTaken += delta;
				if (!(timeTaken < timeBetweenCycles))
				{
					timeTaken = 0f;
					if (onlyAdvanceTimerWhenPass || CanCycle(item))
					{
						CustomCycle(item, delta);
					}
				}
			}
		};
	}

	private bool CanCycle(Item item)
	{
		ItemMod[] array = actions;
		for (int i = 0; i < array.Length; i++)
		{
			if (!array[i].CanDoAction(item, item.GetOwnerPlayer()))
			{
				return false;
			}
		}
		return true;
	}

	public void CustomCycle(Item item, float delta)
	{
		BasePlayer ownerPlayer = item.GetOwnerPlayer();
		ItemMod[] array = actions;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].DoAction(item, ownerPlayer);
		}
	}

	private void OnValidate()
	{
		if (actions == null)
		{
			Debug.LogWarning((object)"ItemModMenuOption: actions is null", (Object)(object)((Component)this).gameObject);
		}
	}
}


using Oxide.Core;
using UnityEngine;

public class ItemModDeployable : MonoBehaviour
{
	public GameObjectRef entityPrefab = new GameObjectRef();

	[Header("Tooltips")]
	public bool showCrosshair;

	public string UnlockAchievement;

	public Deployable GetDeployable(BaseEntity entity)
	{
		if ((Object)(object)entity.gameManager.FindPrefab(entityPrefab.resourcePath) == (Object)null)
		{
			return null;
		}
		return entity.prefabAttribute.Find<Deployable>(entityPrefab.resourceID);
	}

	internal void OnDeployed(BaseEntity ent, BasePlayer player)
	{
		if (player.IsValid() && !string.IsNullOrEmpty(UnlockAchievement))
		{
			player.GiveAchievement(UnlockAchievement);
		}
		if (ent is BuildingPrivlidge buildingPrivlidge && Interface.CallHook("OnCupboardAuthorize", (object)buildingPrivlidge, (object)player) == null)
		{
			buildingPrivlidge.AddPlayer(player, player.userID);
		}
	}
}


using UnityEngine;

public class ItemModEntity : ItemMod
{
	public GameObjectRef entityPrefab = new GameObjectRef();

	public string defaultBone;

	public bool playerOnlyEntity;

	public bool destroyEntityWhenBroken;

	public override void OnChanged(Item item)
	{
		HeldEntity heldEntity = item.GetHeldEntity() as HeldEntity;
		if ((Object)(object)heldEntity != (Object)null)
		{
			heldEntity.OnItemChanged(item);
		}
		base.OnChanged(item);
	}

	public override void OnItemCreated(Item item)
	{
		if ((Object)(object)item.GetHeldEntity() == (Object)null && !playerOnlyEntity)
		{
			CreateEntity(item);
		}
	}

	private void CreateEntity(Item item)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (!destroyEntityWhenBroken || !item.isBroken)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(entityPrefab.resourcePath);
			if ((Object)(object)baseEntity == (Object)null)
			{
				Debug.LogWarning((object)("Couldn't create item entity " + item.info.displayName.english + " (" + entityPrefab.resourcePath + ")"));
			}
			else
			{
				baseEntity.skinID = item.skin;
				baseEntity.limitNetworking = true;
				baseEntity.Spawn();
				item.SetHeldEntity(baseEntity);
			}
		}
	}

	public override void OnRemove(Item item)
	{
		BaseEntity heldEntity = item.GetHeldEntity();
		if (!((Object)(object)heldEntity == (Object)null))
		{
			heldEntity.Kill();
			item.SetHeldEntity(null);
		}
	}

	private bool ParentToParent(Item item, BaseEntity ourEntity)
	{
		Item parentItem = item.parentItem;
		if (parentItem == null)
		{
			return false;
		}
		if (parentItem.IsBackpack())
		{
			return false;
		}
		BaseEntity baseEntity = parentItem.GetWorldEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			baseEntity = item.parentItem.GetHeldEntity();
		}
		ourEntity.SetFlag(BaseEntity.Flags.Disabled, b: false);
		ourEntity.limitNetworking = false;
		ourEntity.SetParent(baseEntity, defaultBone);
		return true;
	}

	private bool ParentToPlayer(Item item, BaseEntity ourEntity)
	{
		HeldEntity heldEntity = ourEntity as HeldEntity;
		if ((Object)(object)heldEntity == (Object)null)
		{
			return false;
		}
		BasePlayer basePlayer = item.GetRootContainer()?.GetOwnerPlayer();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			heldEntity.SetOwnerPlayer(basePlayer);
			return true;
		}
		heldEntity.ClearOwnerPlayer();
		return true;
	}

	public override void OnParentChanged(Item item)
	{
		BaseEntity baseEntity = item.GetHeldEntity();
		if (playerOnlyEntity)
		{
			BasePlayer ownerPlayer = item.GetOwnerPlayer();
			if ((Object)(object)ownerPlayer == (Object)null && (Object)(object)baseEntity != (Object)null)
			{
				baseEntity.Kill();
				baseEntity = null;
				item.SetHeldEntity(null);
			}
			else if ((Object)(object)ownerPlayer != (Object)null && (Object)(object)baseEntity == (Object)null)
			{
				CreateEntity(item);
				baseEntity = item.GetHeldEntity();
			}
		}
		if (!((Object)(object)baseEntity == (Object)null) && !ParentToParent(item, baseEntity) && !ParentToPlayer(item, baseEntity))
		{
			baseEntity.SetParent(null);
			baseEntity.limitNetworking = true;
			baseEntity.SetFlag(BaseEntity.Flags.Disabled, b: true);
		}
	}

	public override void CollectedForCrafting(Item item, BasePlayer crafter)
	{
		BaseEntity heldEntity = item.GetHeldEntity();
		if (!((Object)(object)heldEntity == (Object)null))
		{
			HeldEntity heldEntity2 = heldEntity as HeldEntity;
			if (!((Object)(object)heldEntity2 == (Object)null))
			{
				heldEntity2.CollectedForCrafting(item, crafter);
			}
		}
	}

	public override void ReturnedFromCancelledCraft(Item item, BasePlayer crafter)
	{
		BaseEntity heldEntity = item.GetHeldEntity();
		if (!((Object)(object)heldEntity == (Object)null))
		{
			HeldEntity heldEntity2 = heldEntity as HeldEntity;
			if (!((Object)(object)heldEntity2 == (Object)null))
			{
				heldEntity2.ReturnedFromCancelledCraft(item, crafter);
			}
		}
	}
}


using UnityEngine;

public class ItemModEntityReference : MonoBehaviour
{
	public GameObjectRef entityPrefab;
}


public class ItemModEntityThrow : ItemMod
{
	public GameObjectRef entityPrefab;

	public float throwVelocity = 5f;

	public bool consumeOnThrow = true;
}


using UnityEngine;

public class ItemModFishable : ItemMod
{
	public bool CanBeFished = true;

	[Header("Catching Behaviour")]
	public float StrainModifier = 1f;

	public float MoveMultiplier = 1f;

	public float ReelInSpeedMultiplier = 1f;

	public float CatchWaitTimeMultiplier = 1f;

	[Header("Catch Criteria")]
	public float MinimumBaitLevel;

	public float MaximumBaitLevel;

	public float MinimumWaterDepth;

	public float MaximumWaterDepth;

	[InspectorFlags]
	public WaterBody.FishingTag RequiredTag;

	[Range(0f, 1f)]
	public float Chance;

	public string SteamStatName;

	[Header("Mounting")]
	public bool CanBeMounted;

	public int FishMountIndex;
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ItemModFoodSpoiling : ItemMod
{
	public class FoodSpoilingWorkQueue : PersistentObjectWorkQueue<Item>
	{
		private Dictionary<ItemId, TimeSince> lastUpdated = new Dictionary<ItemId, TimeSince>();

		protected override void RunJob(Item foodItem)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			float timeToApply = 0f;
			if (lastUpdated.TryGetValue(foodItem.uid, out var value))
			{
				timeToApply = TimeSince.op_Implicit(value);
				lastUpdated[foodItem.uid] = TimeSince.op_Implicit(0f);
			}
			else
			{
				lastUpdated.Add(foodItem.uid, TimeSince.op_Implicit(0f));
			}
			DeductTimeFromFoodItem(foodItem, timeToApply, setDirty: false);
		}

		public static void DeductTimeFromFoodItem(Item foodItem, float timeToApply, bool setDirty)
		{
			//IL_019b: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_0128: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_013e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0148: Unknown result type (might be due to invalid IL or missing references)
			//IL_014d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0152: Unknown result type (might be due to invalid IL or missing references)
			//IL_0159: Unknown result type (might be due to invalid IL or missing references)
			//IL_015f: Unknown result type (might be due to invalid IL or missing references)
			if (foodItem.instanceData != null)
			{
				float dataFloat = foodItem.instanceData.dataFloat;
				float num = 1f;
				IFoodSpoilModifier foodSpoilModifier = default(IFoodSpoilModifier);
				if (foodItem.parent != null && (Object)(object)foodItem.parent.entityOwner != (Object)null && ((Component)foodItem.parent.entityOwner).TryGetComponent<IFoodSpoilModifier>(ref foodSpoilModifier))
				{
					num = foodSpoilModifier.GetSpoilMultiplier(foodItem);
				}
				bool flag = num != 1f;
				if (foodItem.HasFlag(Item.Flag.Refrigerated) != flag)
				{
					foodItem.SetFlag(Item.Flag.Refrigerated, flag);
					foodItem.MarkDirty();
					if ((Object)(object)foodItem.GetEntityOwner() != (Object)null)
					{
						foodItem.GetEntityOwner().SendNetworkUpdate();
					}
				}
				InstanceData instanceData = foodItem.instanceData;
				instanceData.dataFloat -= timeToApply * num;
				if (!(foodItem.instanceData.dataFloat <= 0f) || !(dataFloat > 0f))
				{
					return;
				}
				int amount = foodItem.amount;
				ItemContainer parent = foodItem.parent;
				foodItem.RemoveFromContainer();
				Item item = ItemManager.Create(((Component)foodItem.info).GetComponent<ItemModFoodSpoiling>().SpoilItem, amount, 0uL);
				if (parent != null && !parent.GiveItem(item))
				{
					if ((Object)(object)parent.entityOwner != (Object)null)
					{
						item.Drop(((Component)parent.entityOwner).transform.position + Vector3.up * ((Bounds)(ref parent.entityOwner.bounds)).size.y, Vector3.zero);
					}
					else
					{
						item.Remove();
					}
				}
				else if (item.parent == null)
				{
					BaseEntity worldEntity = foodItem.GetWorldEntity();
					if ((Object)(object)worldEntity != (Object)null)
					{
						item.Drop(((Component)worldEntity).transform.position, Vector3.zero, ((Component)worldEntity).transform.rotation);
					}
					else
					{
						item.Remove();
					}
				}
				foodItem.Remove();
				ItemManager.DoRemoves();
			}
			else if (setDirty)
			{
				foodItem.MarkDirty();
				if ((Object)(object)foodItem.GetEntityOwner() != (Object)null)
				{
					foodItem.GetEntityOwner().SendNetworkUpdate();
				}
			}
		}
	}

	public float TotalSpoilTimeHours = 12f;

	public ItemDefinition SpoilItem;

	public static FoodSpoilingWorkQueue foodSpoilItems = new FoodSpoilingWorkQueue();

	public override void OnItemCreated(Item item)
	{
		base.OnItemCreated(item);
		if (item.instanceData == null)
		{
			item.instanceData = Pool.Get<InstanceData>();
			item.instanceData.dataFloat = 3600f * TotalSpoilTimeHours;
			item.instanceData.ShouldPool = false;
		}
		((PersistentObjectWorkQueue<Item>)foodSpoilItems).Add(item);
	}

	public override void OnRemove(Item item)
	{
		base.OnRemove(item);
		((PersistentObjectWorkQueue<Item>)foodSpoilItems).Remove(item);
	}

	public static void DeductTimeFromAll(TimeSpan span)
	{
		((PersistentObjectWorkQueue<Item>)foodSpoilItems).RunOnAll((Action<Item>)delegate(Item foodItem)
		{
			FoodSpoilingWorkQueue.DeductTimeFromFoodItem(foodItem, (float)span.TotalSeconds, setDirty: true);
		});
	}
}


using System.Collections.Generic;
using ProtoBuf;
using UnityEngine;

public class FoodSpoilingWorkQueue : PersistentObjectWorkQueue<Item>
{
	private Dictionary<ItemId, TimeSince> lastUpdated = new Dictionary<ItemId, TimeSince>();

	protected override void RunJob(Item foodItem)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		float timeToApply = 0f;
		if (lastUpdated.TryGetValue(foodItem.uid, out var value))
		{
			timeToApply = TimeSince.op_Implicit(value);
			lastUpdated[foodItem.uid] = TimeSince.op_Implicit(0f);
		}
		else
		{
			lastUpdated.Add(foodItem.uid, TimeSince.op_Implicit(0f));
		}
		DeductTimeFromFoodItem(foodItem, timeToApply, setDirty: false);
	}

	public static void DeductTimeFromFoodItem(Item foodItem, float timeToApply, bool setDirty)
	{
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		if (foodItem.instanceData != null)
		{
			float dataFloat = foodItem.instanceData.dataFloat;
			float num = 1f;
			IFoodSpoilModifier foodSpoilModifier = default(IFoodSpoilModifier);
			if (foodItem.parent != null && (Object)(object)foodItem.parent.entityOwner != (Object)null && ((Component)foodItem.parent.entityOwner).TryGetComponent<IFoodSpoilModifier>(ref foodSpoilModifier))
			{
				num = foodSpoilModifier.GetSpoilMultiplier(foodItem);
			}
			bool flag = num != 1f;
			if (foodItem.HasFlag(Item.Flag.Refrigerated) != flag)
			{
				foodItem.SetFlag(Item.Flag.Refrigerated, flag);
				foodItem.MarkDirty();
				if ((Object)(object)foodItem.GetEntityOwner() != (Object)null)
				{
					foodItem.GetEntityOwner().SendNetworkUpdate();
				}
			}
			InstanceData instanceData = foodItem.instanceData;
			instanceData.dataFloat -= timeToApply * num;
			if (!(foodItem.instanceData.dataFloat <= 0f) || !(dataFloat > 0f))
			{
				return;
			}
			int amount = foodItem.amount;
			ItemContainer parent = foodItem.parent;
			foodItem.RemoveFromContainer();
			Item item = ItemManager.Create(((Component)foodItem.info).GetComponent<ItemModFoodSpoiling>().SpoilItem, amount, 0uL);
			if (parent != null && !parent.GiveItem(item))
			{
				if ((Object)(object)parent.entityOwner != (Object)null)
				{
					item.Drop(((Component)parent.entityOwner).transform.position + Vector3.up * ((Bounds)(ref parent.entityOwner.bounds)).size.y, Vector3.zero);
				}
				else
				{
					item.Remove();
				}
			}
			else if (item.parent == null)
			{
				BaseEntity worldEntity = foodItem.GetWorldEntity();
				if ((Object)(object)worldEntity != (Object)null)
				{
					item.Drop(((Component)worldEntity).transform.position, Vector3.zero, ((Component)worldEntity).transform.rotation);
				}
				else
				{
					item.Remove();
				}
			}
			foodItem.Remove();
			ItemManager.DoRemoves();
		}
		else if (setDirty)
		{
			foodItem.MarkDirty();
			if ((Object)(object)foodItem.GetEntityOwner() != (Object)null)
			{
				foodItem.GetEntityOwner().SendNetworkUpdate();
			}
		}
	}
}


public interface IFoodSpoilModifier
{
	float GetSpoilMultiplier(Item item);
}


public class ItemModForceSelectFromBelt : ItemMod
{
	public bool IfIsOn = true;

	public bool IfPlayerRestrained = true;
}


public class ItemModForceWearFromBelt : ItemMod
{
	public bool IfPlayerRestrained = true;
}


public interface IAirSupply
{
	ItemModGiveOxygen.AirSupplyType AirType { get; }

	float GetAirTimeRemaining(Item forItem);
}


using UnityEngine;

public class ItemModGiveOxygen : ItemMod, IAirSupply
{
	public enum AirSupplyType
	{
		Lungs,
		ScubaTank,
		Submarine
	}

	public AirSupplyType airType = AirSupplyType.ScubaTank;

	public int amountToConsume = 1;

	public GameObjectRef inhaleEffect;

	public GameObjectRef exhaleEffect;

	public GameObjectRef bubblesEffect;

	private float cycleTime;

	private bool inhaled;

	public AirSupplyType AirType => airType;

	public float GetAirTimeRemaining(Item forItem)
	{
		return ConditionToTime(forItem);
	}

	public override void ModInit()
	{
		base.ModInit();
		cycleTime = 1f;
		ItemMod[] array = siblingMods;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] is ItemModCycle itemModCycle)
			{
				cycleTime = itemModCycle.timeBetweenCycles;
			}
		}
	}

	public override void DoAction(Item item, BasePlayer player)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		if (!item.hasCondition || item.conditionNormalized == 0f || (Object)(object)player == (Object)null)
		{
			return;
		}
		float num = Mathf.Clamp01(0.525f);
		if (!(player.AirFactor() > num) && item.parent != null && item.parent == player.inventory.containerWear)
		{
			Effect.server.Run((!inhaled) ? inhaleEffect.resourcePath : exhaleEffect.resourcePath, player, StringPool.Get("jaw"), Vector3.zero, Vector3.forward);
			inhaled = !inhaled;
			if (!inhaled && WaterLevel.GetWaterDepth(player.eyes.position, waves: true, volumes: true, player) > 3f)
			{
				Effect.server.Run(bubblesEffect.resourcePath, player, StringPool.Get("jaw"), Vector3.zero, Vector3.forward);
			}
			item.LoseCondition(amountToConsume);
			player.metabolism.oxygen.Add(1f);
		}
	}

	private float ConditionToTime(Item item)
	{
		if (item == null || !item.hasCondition)
		{
			return 0f;
		}
		return item.condition * ((float)amountToConsume / cycleTime);
	}
}


public enum AirSupplyType
{
	Lungs,
	ScubaTank,
	Submarine
}


using UnityEngine;

public class ItemModHABEquipment : ItemMod
{
	public enum SlotType
	{
		Basic,
		Armor
	}

	public SlotType slot;

	public GameObjectRef Prefab;

	public int MaxEquipCount = 1;

	public bool GroundEquipOnly = true;

	public float DelayNextUpgradeOnRemoveDuration = 60f;

	public Phrase MenuOptionTitle;

	public Phrase MenuOptionDesc;

	public bool CanEquipToHAB(HotAirBalloon hab)
	{
		if (!hab.CanModifyEquipment())
		{
			return false;
		}
		if (hab.GetEquipmentCount(this) >= MaxEquipCount)
		{
			return false;
		}
		if (GroundEquipOnly && !hab.Grounded)
		{
			return false;
		}
		if (hab.NextUpgradeTime > Time.time)
		{
			return false;
		}
		return true;
	}

	public void ApplyToHAB(HotAirBalloon hab)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (hab.isServer && CanEquipToHAB(hab) && Prefab.isValid)
		{
			HotAirBalloonEquipment hotAirBalloonEquipment = GameManager.server.CreateEntity(Prefab.resourcePath, ((Component)hab).transform.position, ((Component)hab).transform.rotation) as HotAirBalloonEquipment;
			if (Object.op_Implicit((Object)(object)hotAirBalloonEquipment))
			{
				hotAirBalloonEquipment.SetParent(hab, worldPositionStays: true);
				hotAirBalloonEquipment.Spawn();
				hotAirBalloonEquipment.DelayNextUpgradeOnRemoveDuration = DelayNextUpgradeOnRemoveDuration;
			}
		}
	}
}


public enum SlotType
{
	Basic,
	Armor
}


public class ItemModHead : ItemModAssociatedEntity<HeadEntity>
{
	protected override bool AllowNullParenting => true;
}


public class ItemModHideInfoPanel : ItemMod
{
}


public class ItemModKeycard : ItemMod
{
	public int accessLevel;
}


using UnityEngine;

public class ItemModMenuOption : ItemMod
{
	public string commandName;

	public ItemMod actionTarget;

	public BaseEntity.Menu.Option option;

	[Tooltip("If true, this is the command that will run when an item is 'selected' on the toolbar")]
	public bool isPrimaryOption = true;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (!(command != commandName) && actionTarget.CanDoAction(item, player))
		{
			actionTarget.DoAction(item, player);
		}
	}

	private void OnValidate()
	{
		if ((Object)(object)actionTarget == (Object)null)
		{
			Debug.LogWarning((object)"ItemModMenuOption: actionTarget is null!", (Object)(object)((Component)this).gameObject);
		}
		if (string.IsNullOrEmpty(commandName))
		{
			Debug.LogWarning((object)"ItemModMenuOption: commandName can't be empty!", (Object)(object)((Component)this).gameObject);
		}
		if ((Object)(object)option.icon == (Object)null)
		{
			Debug.LogWarning((object)("No icon set for ItemModMenuOption " + ((Object)((Component)this).gameObject).name), (Object)(object)((Component)this).gameObject);
		}
	}
}


using UnityEngine;

[RequireComponent(typeof(ItemModWearable))]
public class ItemModPaintable : ItemModAssociatedEntity<PaintedItemStorageEntity>
{
	public static readonly Phrase ItemPaintTitle = new Phrase("item.paint", "Paint");

	public static readonly Phrase ItemPaintDesc = new Phrase("item.paint.desc", "Paint on this item.");

	public GameObjectRef ChangeSignTextDialog;

	public MeshPaintableSource[] PaintableSources;

	protected override bool AllowNullParenting => true;

	protected override bool OwnedByParentPlayer => true;
}


using UnityEngine;

public class ItemModPetStats : ItemMod
{
	[Tooltip("Speed modifier. Value, not percentage.")]
	public float SpeedModifier;

	[Tooltip("HP amount to modify max health by. Value, not percentage.")]
	public float MaxHealthModifier;

	[Tooltip("Damage amount to modify base attack damage by. Value, not percentage.")]
	public float AttackDamageModifier;

	[Tooltip("Attack rate (seconds) to modify base attack rate by. Value, not percentage.")]
	public float AttackRateModifier;

	public void Apply(BasePet pet)
	{
		if (!((Object)(object)pet == (Object)null))
		{
			pet.SetMaxHealth(pet.MaxHealth() + MaxHealthModifier);
			if ((Object)(object)pet.Brain != (Object)null && (Object)(object)pet.Brain.Navigator != (Object)null)
			{
				pet.Brain.Navigator.Speed += SpeedModifier;
			}
			pet.BaseAttackRate += AttackRateModifier;
			pet.BaseAttackDamge += AttackDamageModifier;
		}
	}
}


using Rust;
using UnityEngine;

public class ItemModProjectile : MonoBehaviour
{
	public GameObjectRef projectileObject = new GameObjectRef();

	public ItemModProjectileMod[] mods;

	public AmmoTypes ammoType;

	public int numProjectiles = 1;

	public float projectileSpread;

	public float projectileVelocity = 100f;

	public float projectileVelocitySpread;

	public bool useCurve;

	public AnimationCurve spreadScalar;

	public GameObjectRef attackEffectOverride;

	public float barrelConditionLoss;

	public string category = "bullet";

	public float GetRandomVelocity()
	{
		return projectileVelocity + Random.Range(0f - projectileVelocitySpread, projectileVelocitySpread);
	}

	public float GetSpreadScalar()
	{
		if (useCurve)
		{
			return spreadScalar.Evaluate(Random.Range(0f, 1f));
		}
		return 1f;
	}

	public float GetIndexedSpreadScalar(int shotIndex, int maxShots)
	{
		float num = 0f;
		if (shotIndex != -1)
		{
			float num2 = 1f / (float)maxShots;
			num = (float)shotIndex * num2;
		}
		else
		{
			num = Random.Range(0f, 1f);
		}
		return spreadScalar.Evaluate(num);
	}

	public float GetAverageVelocity()
	{
		return projectileVelocity;
	}

	public float GetMinVelocity()
	{
		return projectileVelocity - projectileVelocitySpread;
	}

	public float GetMaxVelocity()
	{
		return projectileVelocity + projectileVelocitySpread;
	}

	public bool IsAmmo(AmmoTypes ammo)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Invalid comparison between Unknown and I4
		return (ammoType & ammo) > 0;
	}

	public virtual void ServerProjectileHit(HitInfo info)
	{
		if (mods == null)
		{
			return;
		}
		ItemModProjectileMod[] array = mods;
		foreach (ItemModProjectileMod itemModProjectileMod in array)
		{
			if (!((Object)(object)itemModProjectileMod == (Object)null))
			{
				itemModProjectileMod.ServerProjectileHit(info);
			}
		}
	}

	public virtual void ServerProjectileHitEntity(HitInfo hitInfo)
	{
		if (mods == null)
		{
			return;
		}
		ItemModProjectileMod[] array = mods;
		foreach (ItemModProjectileMod itemModProjectileMod in array)
		{
			if (!((Object)(object)itemModProjectileMod == (Object)null))
			{
				itemModProjectileMod.ServerProjectileHitEntity(hitInfo);
			}
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class ItemModProjectileDart : ItemModProjectileMod
{
	public List<ModifierDefintion> modifiers;

	public List<ItemModConsumable.ConsumableEffect> effects;

	public float TurretEffectScale = 0.5f;

	public float TurretDurationScale = 0.5f;

	public override void ServerProjectileHitEntity(HitInfo info)
	{
		base.ServerProjectileHitEntity(info);
		BasePlayer basePlayer = info.HitEntity as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		float effectScale = 1f;
		float durationScale = 1f;
		if ((Object)(object)info.Initiator != (Object)null && info.Initiator is AutoTurret)
		{
			effectScale = TurretEffectScale;
			durationScale = TurretDurationScale;
		}
		PlayerModifiers.AddToPlayer(basePlayer, modifiers, effectScale, durationScale);
		if (effects == null)
		{
			return;
		}
		foreach (ItemModConsumable.ConsumableEffect effect in effects)
		{
			if (!(Mathf.Clamp01(basePlayer.healthFraction + basePlayer.metabolism.pending_health.Fraction()) > effect.onlyIfHealthLessThan))
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					basePlayer.health += effect.amount;
				}
				else
				{
					basePlayer.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
		}
	}
}


using UnityEngine;

public class ItemModProjectileMod : MonoBehaviour
{
	public virtual void ServerProjectileHit(HitInfo info)
	{
	}

	public virtual void ServerProjectileHitEntity(HitInfo info)
	{
	}
}


using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

public class ItemModProjectileRadialDamage : ItemModProjectileMod
{
	public float radius = 0.5f;

	public DamageTypeEntry damage;

	public GameObjectRef effect;

	public bool ignoreHitObject = true;

	public bool onlyDoors;

	public int vibrationLevel = 2;

	public override void ServerProjectileHit(HitInfo info)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		if (effect.isValid)
		{
			Effect.server.Run(effect.resourcePath, info.HitPositionWorld, info.HitNormalWorld);
		}
		List<BaseCombatEntity> list = Pool.Get<List<BaseCombatEntity>>();
		List<BaseCombatEntity> list2 = Pool.Get<List<BaseCombatEntity>>();
		Vis.Entities(info.HitPositionWorld, radius, list2, 1237003025, (QueryTriggerInteraction)2);
		if (damage.type == DamageType.Explosion)
		{
			SeismicSensor.Notify(info.HitPositionWorld, vibrationLevel);
		}
		foreach (BaseCombatEntity item in list2)
		{
			if (!item.isServer || list.Contains(item) || (onlyDoors && !(item is Door)) || ((Object)(object)item == (Object)(object)info.HitEntity && ignoreHitObject))
			{
				continue;
			}
			item.CenterPoint();
			Vector3 val = item.ClosestPoint(info.HitPositionWorld);
			float num = Vector3.Distance(val, info.HitPositionWorld) / radius;
			if (num > 1f)
			{
				continue;
			}
			float num2 = 1f - num;
			if (!item.IsVisibleAndCanSeeLegacy(info.HitPositionWorld - ((Vector3)(ref info.ProjectileVelocity)).normalized * 0.1f))
			{
				continue;
			}
			Vector3 hitPositionWorld = info.HitPositionWorld;
			Vector3 val2 = val - info.HitPositionWorld;
			if (item.IsVisibleAndCanSeeLegacy(hitPositionWorld - ((Vector3)(ref val2)).normalized * 0.1f))
			{
				list.Add(item);
				BasePlayer component = ((Component)item).GetComponent<BasePlayer>();
				if ((Object)(object)component != (Object)null && component.GetActiveShield(out var foundShield) && (Object)(object)info.Initiator != (Object)null && foundShield.SphereCastAgainstColliders(info.HitPositionWorld, radius))
				{
					foundShield.OnAttacked(new HitInfo(info.Initiator, item, damage.type, damage.amount * num2));
				}
				else
				{
					item.OnAttacked(new HitInfo(info.Initiator, item, damage.type, damage.amount * num2));
				}
			}
		}
		Pool.FreeUnmanaged<BaseCombatEntity>(ref list);
		Pool.FreeUnmanaged<BaseCombatEntity>(ref list2);
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class ItemModProjectileRagdoll : ItemModProjectileMod
{
	public float radius = 0.5f;

	public float velocityInheritFactor = 0.25f;

	public override void ServerProjectileHit(HitInfo info)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Vis.Entities(info.HitPositionWorld, radius, list, 131072, (QueryTriggerInteraction)2);
		foreach (BasePlayer item in list)
		{
			if (item.isServer && !item.IsDead() && !item.InSafeZone())
			{
				Vector3 val;
				if ((Object)(object)info.HitEntity == (Object)(object)item)
				{
					val = info.ProjectileVelocity * velocityInheritFactor;
				}
				else
				{
					Vector3 val2 = ((Component)item).transform.position - info.HitPositionWorld + Vector3.up;
					val = ((Vector3)(ref val2)).normalized * 7.5f;
				}
				item.Ragdoll(item.GetWorldVelocity() + val);
			}
		}
	}
}


using ConVar;
using UnityEngine;

public class ItemModProjectileSpawn : ItemModProjectile
{
	public float createOnImpactChance;

	public GameObjectRef createOnImpact = new GameObjectRef();

	public float spreadAngle = 30f;

	public float spreadVelocityMin = 1f;

	public float spreadVelocityMax = 3f;

	public int numToCreateChances = 1;

	public override void ServerProjectileHit(HitInfo info)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < numToCreateChances; i++)
		{
			if (!createOnImpact.isValid || !(Random.Range(0f, 1f) < createOnImpactChance))
			{
				continue;
			}
			Vector3 hitPositionWorld = info.HitPositionWorld;
			Vector3 pointStart = info.PointStart;
			Vector3 normalized = ((Vector3)(ref info.ProjectileVelocity)).normalized;
			Vector3 normalized2 = ((Vector3)(ref info.HitNormalWorld)).normalized;
			Vector3 val = hitPositionWorld - normalized * 0.1f;
			Quaternion rotation = Quaternion.LookRotation(-normalized);
			int num = 1075904512;
			if (ConVar.AntiHack.projectile_terraincheck)
			{
				num |= 0x800000;
			}
			if (ConVar.AntiHack.projectile_vehiclecheck)
			{
				num |= 0x8000000;
			}
			if (!GamePhysics.LineOfSight(pointStart, val, num))
			{
				continue;
			}
			BaseEntity baseEntity = GameManager.server.CreateEntity(createOnImpact.resourcePath);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				((Component)baseEntity).transform.position = val;
				((Component)baseEntity).transform.rotation = rotation;
				baseEntity.Spawn();
				if (spreadAngle > 0f)
				{
					Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(spreadAngle, normalized2);
					baseEntity.SetVelocity(modifiedAimConeDirection * Random.Range(spreadVelocityMin, spreadVelocityMax));
				}
			}
		}
		base.ServerProjectileHit(info);
	}
}


public class ItemModRackMountable : ItemMod
{
}


using UnityEngine;

public class ItemModRecycleInto : ItemMod
{
	public static readonly Phrase RecycleIntoTitle = new Phrase("recycle_into", "MISSING RECYCLE INTO PHRASE");

	public static readonly Phrase RecycleIntoDesc = new Phrase("recycle_into_desc", "MISSING RECYCLE INTO DESC PHRASE");

	public ItemDefinition recycleIntoItem;

	public int numRecycledItemMin = 1;

	public int numRecycledItemMax = 1;

	public GameObjectRef successEffect;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		if (!(command == "recycle_item"))
		{
			return;
		}
		int num = Random.Range(numRecycledItemMin, numRecycledItemMax + 1);
		item.UseItem();
		if (num > 0)
		{
			Item item2 = ItemManager.Create(recycleIntoItem, num, 0uL);
			item2.SetItemOwnership(player, ItemOwnershipPhrases.Recycler);
			if (!item2.MoveToContainer(player.inventory.containerMain))
			{
				item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}
}


using UnityEngine;

public class ItemModReload : ItemMod
{
	public float conditionLost;

	public GameObjectRef successEffect;

	public int workbenchLvlRequired;

	public Phrase reloadPhrase = new Phrase("reload_item", "Reload Item");

	public bool HasCraftLevel(BasePlayer player = null)
	{
		if ((Object)(object)player != (Object)null && player.isServer)
		{
			return player.currentCraftLevel >= (float)workbenchLvlRequired;
		}
		return false;
	}

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		if (!(command == "reload") || player.IsSwimming() || !HasCraftLevel(player))
		{
			return;
		}
		BaseEntity heldEntity = item.GetHeldEntity();
		if ((Object)(object)heldEntity == (Object)null)
		{
			return;
		}
		BaseProjectile component = ((Component)heldEntity).GetComponent<BaseProjectile>();
		if (!((Object)(object)component == (Object)null))
		{
			int num = component.primaryMagazine.capacity - component.primaryMagazine.contents;
			if (num != 0 && component.TryReloadMagazine(player.inventory, num) && successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}
}


using Facepunch.Rust;
using Oxide.Core;
using UnityEngine;

public class ItemModRepair : ItemMod
{
	public static readonly Phrase RefillItemTitle = new Phrase("refill_item", "Refill");

	public static readonly Phrase RefillItemDesc = new Phrase("refill_item_desc", "Refill the item.");

	public float conditionLost = 0.05f;

	public GameObjectRef successEffect;

	public int workbenchLvlRequired;

	public bool canUseRepairBench;

	public bool HasCraftLevel(BasePlayer player = null)
	{
		if ((Object)(object)player != (Object)null && player.isServer)
		{
			return player.currentCraftLevel >= (float)workbenchLvlRequired;
		}
		return false;
	}

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		if (command == "refill" && !player.IsSwimming() && HasCraftLevel(player) && !(item.conditionNormalized >= 1f) && Interface.CallHook("OnItemRefill", (object)item, (object)player) == null)
		{
			float conditionNormalized = item.conditionNormalized;
			float maxConditionNormalized = item.maxConditionNormalized;
			item.DoRepair(conditionLost);
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
			Analytics.Azure.OnItemRepaired(player, player.GetCachedCraftLevelWorkbench(), item, conditionNormalized, maxConditionNormalized);
		}
	}
}


public class ItemModRestraint : ItemMod
{
}


using UnityEngine;

public class ItemModReveal : ItemMod
{
	public static readonly Phrase RevealItemTitle = new Phrase("reveal_item", "Reveal BP");

	public static readonly Phrase RevealItemDesc = new Phrase("reveal_item_desc", "Reveal blueprint");

	public int numForReveal = 10;

	public ItemDefinition revealedItemOverride;

	public int revealedItemAmount = 1;

	public LootSpawn revealList;

	public GameObjectRef successEffect;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		if (command == "reveal" && item.amount >= numForReveal)
		{
			int position = item.position;
			item.UseItem(numForReveal);
			Item item2 = null;
			if (Object.op_Implicit((Object)(object)revealedItemOverride))
			{
				item2 = ItemManager.Create(revealedItemOverride, revealedItemAmount, 0uL);
			}
			if (item2 != null && !item2.MoveToContainer(player.inventory.containerMain, (item.amount == 0) ? position : (-1)))
			{
				item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}
}


using Rust;
using UnityEngine;

public class ItemModSound : ItemMod
{
	public enum Type
	{
		OnAttachToWeapon
	}

	public GameObjectRef effect = new GameObjectRef();

	public Type actionType;

	public override void OnParentChanged(Item item)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoadingSave || actionType != 0 || item.parentItem == null || item.parentItem.info.category != 0)
		{
			return;
		}
		ItemContainer rootContainer = item.parentItem.GetRootContainer();
		if (rootContainer != null)
		{
			BasePlayer ownerPlayer = rootContainer.GetOwnerPlayer();
			if (!((Object)(object)ownerPlayer == (Object)null) && !ownerPlayer.IsNpc)
			{
				Effect.server.Run(effect.resourcePath, ownerPlayer, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}
}


public enum Type
{
	OnAttachToWeapon
}


using Facepunch.Rust;
using Oxide.Core;
using UnityEngine;

public class ItemModStudyBlueprint : ItemMod
{
	public GameObjectRef studyEffect;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		if (command != "study" || !item.IsBlueprint())
		{
			return;
		}
		if ((Object)(object)item.GetOwnerPlayer() != (Object)(object)player && player.inventory.GetBackpackWithInventory()?.contents != item.parent)
		{
			bool flag = false;
			foreach (ItemContainer container in player.inventory.loot.containers)
			{
				if (item.GetRootContainer() == container)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return;
			}
		}
		if (IsBlueprintUnlocked(item, player, out var blueprintTargetDef, out var blueprint) || Interface.CallHook("OnPlayerStudyBlueprint", (object)player, (object)item) != null)
		{
			return;
		}
		Item item2 = item;
		if (item.amount > 1)
		{
			item2 = item.SplitItem(1);
		}
		item2.UseItem();
		player.blueprints.Unlock(blueprintTargetDef);
		Analytics.Azure.OnBlueprintLearned(player, blueprintTargetDef, "blueprint", ResearchTable.ScrapForResearch(blueprintTargetDef), player);
		if ((Object)(object)blueprint != (Object)null && blueprint.additionalUnlocks != null && blueprint.additionalUnlocks.Count > 0)
		{
			foreach (ItemDefinition additionalUnlock in blueprint.additionalUnlocks)
			{
				player.blueprints.Unlock(additionalUnlock);
				Analytics.Azure.OnBlueprintLearned(player, additionalUnlock, "blueprint", 0, player);
			}
		}
		if (studyEffect.isValid)
		{
			Effect.server.Run(studyEffect.resourcePath, player, StringPool.Get("head"), Vector3.zero, Vector3.zero);
		}
	}

	private static bool IsBlueprintUnlocked(Item item, BasePlayer player, out ItemDefinition blueprintTargetDef, out ItemBlueprint blueprint)
	{
		blueprintTargetDef = item.blueprintTargetDef;
		blueprint = blueprintTargetDef.Blueprint;
		bool flag = IsBlueprintUnlocked(blueprintTargetDef, player);
		if (flag && (Object)(object)blueprint != (Object)null && blueprint.additionalUnlocks != null && blueprint.additionalUnlocks.Count > 0)
		{
			foreach (ItemDefinition additionalUnlock in blueprint.additionalUnlocks)
			{
				if (!IsBlueprintUnlocked(additionalUnlock, player))
				{
					flag = false;
				}
			}
		}
		if ((Object)(object)blueprint != (Object)null && blueprint.defaultBlueprint)
		{
			flag = true;
		}
		if (flag)
		{
			return true;
		}
		return false;
	}

	public static bool IsBlueprintUnlocked(ItemDefinition def, BasePlayer player)
	{
		return player.blueprints.IsUnlocked(def);
	}
}


using ConVar;
using UnityEngine;

public class ItemModSummerSunglassesEquip : ItemMod
{
	public float SunsetTime;

	public float SunriseTime;

	public string AchivementName;

	public override void DoAction(Item item, BasePlayer player)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		base.DoAction(item, player);
		if ((Object)(object)player != (Object)null && !string.IsNullOrEmpty(AchivementName) && player.inventory.containerWear.FindItemByUID(item.uid) != null)
		{
			float time = Env.time;
			if (time < SunriseTime || time > SunsetTime)
			{
				player.GiveAchievement(AchivementName);
			}
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust;
using UnityEngine;

public class ItemModSwap : ItemMod
{
	public GameObjectRef actionEffect;

	public ItemAmount[] becomeItem;

	public bool sendPlayerPickupNotification;

	public bool sendPlayerDropNotification;

	public float xpScale = 1f;

	public List<ItemAmount> RandomOptions;

	public List<float> RandomWeights;

	public Phrase OwnershipPhrase;

	public bool ApplyHarvestingTea;

	public override void DoAction(Item item, BasePlayer player)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		if (item.amount < 1 && RandomWeights.Count == 0 && RandomOptions.Count == 0)
		{
			return;
		}
		ItemAmount[] array = becomeItem;
		foreach (ItemAmount itemAmount in array)
		{
			if (itemAmount.itemDef.IsAllowed((EraRestriction)0))
			{
				SpawnItem(itemAmount, player, item.parent, allowTeaBonus: true);
			}
		}
		if (RandomOptions.Count > 0)
		{
			List<ItemAmount> list = null;
			List<float> list2 = null;
			List<ItemAmount> options = RandomOptions;
			List<float> weights = RandomWeights;
			if ((int)ConVar.Server.Era != 0)
			{
				list = Pool.Get<List<ItemAmount>>();
				list2 = Pool.Get<List<float>>();
				options = list;
				if (RandomWeights.Count != 0 && RandomWeights.Count == RandomOptions.Count)
				{
					weights = list2;
				}
				for (int j = 0; j < RandomOptions.Count; j++)
				{
					ItemAmount itemAmount2 = RandomOptions[j];
					if (itemAmount2.itemDef.IsAllowed((EraRestriction)0))
					{
						if (j < RandomWeights.Count)
						{
							list2.Add(RandomWeights.Count);
						}
						list.Add(itemAmount2);
					}
				}
			}
			ItemAmount itemAmount3 = ((RandomWeights.Count == 0 || RandomWeights.Count != RandomOptions.Count) ? PickRandomChoice(options) : PickWeightedRandomChoice(options, weights));
			if (itemAmount3 != null)
			{
				SpawnItem(itemAmount3, player, item.parent, allowTeaBonus: false);
			}
			if (list != null)
			{
				Pool.FreeUnmanaged<ItemAmount>(ref list);
			}
			if (list2 != null)
			{
				Pool.FreeUnmanaged<float>(ref list2);
			}
		}
		if (sendPlayerDropNotification)
		{
			player.Command("note.inv", item.info.itemid, -1);
		}
		if (actionEffect.isValid)
		{
			Effect.server.Run(actionEffect.resourcePath, ((Component)player).transform.position, Vector3.up);
		}
		item.UseItem();
	}

	private void SpawnItem(ItemAmount itemAmount, BasePlayer player, ItemContainer container, bool allowTeaBonus)
	{
		float num = 1f;
		if (ApplyHarvestingTea && itemAmount.amount > 1f && allowTeaBonus)
		{
			num += player.modifiers.GetValue(Modifier.ModifierType.Harvesting);
		}
		Item item = ItemManager.Create(itemAmount.itemDef, (int)(itemAmount.amount * num), 0uL);
		if (item != null)
		{
			if (OwnershipPhrase != null && !string.IsNullOrEmpty(OwnershipPhrase.token))
			{
				item.SetItemOwnership(player, OwnershipPhrase);
			}
			else
			{
				item.SetItemOwnership(player, ItemOwnershipPhrases.GenericPhrase);
			}
			AugmentItem(item);
			if (!item.MoveToContainer(container))
			{
				player.GiveItem(item);
			}
			if (sendPlayerPickupNotification)
			{
				player.Command("note.inv", item.info.itemid, item.amount);
			}
		}
	}

	protected virtual void AugmentItem(Item item)
	{
	}

	private ItemAmount PickRandomChoice(List<ItemAmount> options)
	{
		int index = Random.Range(0, options.Count);
		return options[index];
	}

	private ItemAmount PickWeightedRandomChoice(List<ItemAmount> options, List<float> weights)
	{
		float num = 0f;
		foreach (float weight in weights)
		{
			num += weight;
		}
		float num2 = Random.Range(0f, num);
		float num3 = 0f;
		for (int i = 0; i < options.Count; i++)
		{
			num3 += weights[i];
			if (num2 <= num3)
			{
				return options[i];
			}
		}
		return options[options.Count - 1];
	}
}


public class ItemModSwitchFlag : ItemMod
{
	public Item.Flag flag;

	public bool state;

	public override void DoAction(Item item, BasePlayer player)
	{
		if (item.amount >= 1 && item.HasFlag(flag) != state)
		{
			item.SetFlag(flag, state);
			item.MarkDirty();
		}
	}
}


using Oxide.Core;
using UnityEngine;

public class ItemModUpgrade : ItemMod
{
	public static readonly Phrase UpgradeItemTitle = new Phrase("upgrade_item", "Upgrade");

	public static readonly Phrase UpgradeItemDesc = new Phrase("upgrade_item_desc", "Upgrade item");

	public int numForUpgrade = 10;

	public float upgradeSuccessChance = 1f;

	public int numToLoseOnFail = 2;

	public ItemDefinition upgradedItem;

	public int numUpgradedItem = 1;

	public GameObjectRef successEffect;

	public GameObjectRef failEffect;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		if (!(command == "upgrade_item") || item.amount < numForUpgrade)
		{
			return;
		}
		if (Random.Range(0f, 1f) <= upgradeSuccessChance)
		{
			item.UseItem(numForUpgrade);
			Item item2 = ItemManager.Create(upgradedItem, numUpgradedItem, 0uL);
			Interface.CallHook("OnItemUpgrade", (object)item, (object)item2, (object)player);
			item2.SetItemOwnership(player, ItemOwnershipPhrases.UpgradeItem);
			if (!item2.MoveToContainer(player.inventory.containerMain))
			{
				item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
		else
		{
			item.UseItem(numToLoseOnFail);
			if (failEffect.isValid)
			{
				Effect.server.Run(failEffect.resourcePath, player.eyes.position);
			}
		}
	}
}


public class ItemModUseContent : ItemMod
{
	public int amountToConsume = 1;

	public override void DoAction(Item item, BasePlayer player)
	{
		if (item.contents != null && item.contents.itemList.Count != 0)
		{
			item.contents.itemList[0].UseItem(amountToConsume);
		}
	}
}


using Rust;
using UnityEngine;

public class ItemModWearable : ItemMod
{
	public GameObjectRef entityPrefab = new GameObjectRef();

	public GameObjectRef entityPrefabFemale = new GameObjectRef();

	public ProtectionProperties protectionProperties;

	public ArmorProperties armorProperties;

	public ClothingMovementProperties movementProperties;

	public UIBlackoutOverlay.blackoutType occlusionType = UIBlackoutOverlay.blackoutType.NONE;

	public bool blocksAiming;

	public bool emissive;

	public float accuracyBonus;

	public bool blocksEquipping;

	public float eggVision;

	public float weight;

	public bool equipOnRightClick = true;

	public bool equipOnPickup;

	public bool npcOnly;

	public GameObjectRef breakEffect = new GameObjectRef();

	public bool preventsMounting;

	public bool preventsMap;

	public GameObjectRef viewmodelAddition;

	public Wearable targetWearable
	{
		get
		{
			if (entityPrefab.isValid)
			{
				return entityPrefab.Get().GetComponent<Wearable>();
			}
			return null;
		}
	}

	private void DoPrepare()
	{
		if (!entityPrefab.isValid)
		{
			Debug.LogWarning((object)("ItemModWearable: entityPrefab is null! " + (object)((Component)this).gameObject), (Object)(object)((Component)this).gameObject);
		}
		if (entityPrefab.isValid && (Object)(object)targetWearable == (Object)null)
		{
			Debug.LogWarning((object)("ItemModWearable: entityPrefab doesn't have a Wearable component! " + (object)((Component)this).gameObject), (Object)(object)entityPrefab.Get());
		}
	}

	public override void ModInit()
	{
		if (string.IsNullOrEmpty(entityPrefab.resourcePath))
		{
			Debug.LogWarning((object)(((object)this)?.ToString() + " - entityPrefab is null or something.. - " + entityPrefab.guid));
		}
	}

	public bool ProtectsArea(HitArea area)
	{
		if ((Object)(object)armorProperties == (Object)null)
		{
			return false;
		}
		return armorProperties.Contains(area);
	}

	public bool ProtectsWholeBody()
	{
		bool num = ProtectsArea(HitArea.Head);
		bool flag = ProtectsArea(HitArea.Chest);
		bool flag2 = ProtectsArea(HitArea.Leg);
		return num && flag && flag2;
	}

	public bool HasProtections()
	{
		return (Object)(object)protectionProperties != (Object)null;
	}

	public float GetProtection(Item item, DamageType damageType)
	{
		if ((Object)(object)protectionProperties == (Object)null)
		{
			return 0f;
		}
		float num = protectionProperties.Get(damageType);
		float num2 = 0f;
		ItemModContainerArmorSlot itemModContainerArmorSlot = default(ItemModContainerArmorSlot);
		if (((Component)this).TryGetComponent<ItemModContainerArmorSlot>(ref itemModContainerArmorSlot))
		{
			num2 = itemModContainerArmorSlot.GetProtection(item, damageType);
		}
		return (num + num2) * ConditionProtectionScale(item);
	}

	public float ConditionProtectionScale(Item item)
	{
		if (!item.isBroken)
		{
			return 1f;
		}
		return 0.25f;
	}

	public void CollectProtection(Item item, ProtectionProperties protection)
	{
		if ((Object)(object)protectionProperties != (Object)null)
		{
			protection.Add(protectionProperties, ConditionProtectionScale(item));
		}
		ItemModContainerArmorSlot itemModContainerArmorSlot = default(ItemModContainerArmorSlot);
		if (((Component)this).TryGetComponent<ItemModContainerArmorSlot>(ref itemModContainerArmorSlot))
		{
			itemModContainerArmorSlot.CollectProtection(item, protection);
		}
	}

	private bool IsHeadgear()
	{
		Wearable component = entityPrefab.Get().GetComponent<Wearable>();
		if ((Object)(object)component != (Object)null && (component.occupationOver & (Wearable.OccupationSlots.HeadTop | Wearable.OccupationSlots.Face | Wearable.OccupationSlots.HeadBack)) != 0)
		{
			return true;
		}
		return false;
	}

	public bool IsFootwear()
	{
		Wearable component = entityPrefab.Get().GetComponent<Wearable>();
		if ((Object)(object)component != (Object)null && (component.occupationOver & (Wearable.OccupationSlots.LeftFoot | Wearable.OccupationSlots.RightFoot)) != 0)
		{
			return true;
		}
		return false;
	}

	public override void OnAttacked(Item item, HitInfo info)
	{
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		if (!item.hasCondition)
		{
			return;
		}
		float num = 0f;
		for (int i = 0; i < 26; i++)
		{
			DamageType damageType = (DamageType)i;
			if (info.damageTypes.Has(damageType))
			{
				num += Mathf.Clamp(info.damageTypes.types[i] * GetProtection(item, damageType), 0f, item.condition);
				if (num >= item.condition)
				{
					break;
				}
			}
		}
		item.LoseCondition(num);
		if (item != null && item.isBroken && Object.op_Implicit((Object)(object)item.GetOwnerPlayer()) && IsHeadgear() && info.damageTypes.Total() >= item.GetOwnerPlayer().health)
		{
			Vector3 vPos = ((Component)item.GetOwnerPlayer()).transform.position + new Vector3(0f, 1.8f, 0f);
			Vector3 vVelocity = item.GetOwnerPlayer().GetInheritedDropVelocity() + Vector3.up * 3f;
			Quaternion rotation = default(Quaternion);
			BaseEntity baseEntity = item.Drop(vPos, vVelocity, rotation);
			rotation = Random.rotation;
			baseEntity.SetAngularVelocity(((Quaternion)(ref rotation)).eulerAngles * 5f);
		}
	}

	public bool CanExistWith(ItemModWearable wearable)
	{
		if ((Object)(object)wearable == (Object)null)
		{
			return true;
		}
		Wearable wearable2 = targetWearable;
		Wearable wearable3 = wearable.targetWearable;
		if ((wearable2.occupationOver & wearable3.occupationOver) != 0)
		{
			return false;
		}
		if ((wearable2.occupationUnder & wearable3.occupationUnder) != 0)
		{
			return false;
		}
		return true;
	}
}


public class ItemModXPWhenUsed : ItemMod
{
	public float xpPerUnit;

	public int unitSize = 1;

	public void GiveConsumeXP(Item item)
	{
	}
}


using UnityEngine;

public class ItemFootstepSounds : MonoBehaviour
{
	public bool setEffectFolder = true;

	public string effectFolder = "barefoot";

	public SoundDefinition accentSound;
}


public static class ItemOwnershipPhrases
{
	public static Phrase BornPhrase = new Phrase("ownership.born", "Born with {0}");

	public static Phrase SpawnedPhrase = new Phrase("ownership.spawned", "Spawned by {0}");

	public static Phrase CraftedPhrase = new Phrase("ownership.crafted", "Crafted by {0}");

	public static Phrase LootedPhrase = new Phrase("ownership.looted", "Looted by {0}");

	public static Phrase MissionRewardPhrase = new Phrase("ownership.mission_reward", "Mission Reward for {0}");

	public static Phrase AdventCalendar = new Phrase("ownership.advent_calendar", "Found In Advent Calendar by {0}");

	public static Phrase PickedUp = new Phrase("ownership.pick_up", "Picked Up by {0}");

	public static Phrase VendorSale = new Phrase("ownership.vendor_purchase", "Purchased by {0}");

	public static Phrase MetalDetector = new Phrase("ownership.metal_detector", "Detected Underground by {0}");

	public static Phrase GatheredPhrase = new Phrase("ownership.gathered_generic", "Gathered by {0}");

	public static Phrase MixingTable = new Phrase("ownership.mixing_table", "Mixed by {0}");

	public static Phrase IndustrialCrafter = new Phrase("ownership.industrial_crafter", "Industrial Crafted by {0}");

	public static Phrase Fishing = new Phrase("ownership.fished", "Fished by {0}");

	public static Phrase SurvivalTrap = new Phrase("ownership.trap_caught", "Trapped by {0}");

	public static Phrase Recycler = new Phrase("ownership.recycled", "Recycled by {0}");

	public static Phrase ResearchTable = new Phrase("ownership.research", "Researched by {0}");

	public static Phrase UpgradeItem = new Phrase("ownership.upgrade_item", "Upgraded by {0}");

	public static Phrase Wrap = new Phrase("ownership.wrapped", "Wrapped by {0}");

	public static Phrase Recorded = new Phrase("ownership.recorded", "Recorded by {0}");

	public static Phrase Photographed = new Phrase("ownership.photographed", "Photographed by {0}");

	public static Phrase Cloned = new Phrase("ownership.cloned", "Cloned by {0}");

	public static Phrase Harvested = new Phrase("ownership.harvested", "Harvested by {0}");

	public static Phrase Shredded = new Phrase("ownership.shredded", "Shredded by {0}");

	public static Phrase Beheaded = new Phrase("ownership.beheaded", "Beheaded by {0}");

	public static Phrase Pooped = new Phrase("ownership.pooped", "Pooped by {0}");

	public static Phrase GenericRewardPhrase = new Phrase("ownership.generic_reward", "Rewarded to {0}");

	public static Phrase GenericPhrase = new Phrase("ownership.generic", "Created by {0}");
}


public struct ItemOwnershipShare
{
	public string username;

	public string reason;

	public int amount;

	public bool IsValid()
	{
		return !string.IsNullOrEmpty(reason);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

[Serializable]
public class ItemAmount : ISerializationCallbackReceiver
{
	[ItemSelector]
	public ItemDefinition itemDef;

	public float amount;

	[NonSerialized]
	public float startAmount;

	public bool ignoreInTutorial;

	public bool isBP;

	public int itemid
	{
		get
		{
			if ((Object)(object)itemDef == (Object)null)
			{
				return 0;
			}
			return itemDef.itemid;
		}
	}

	public ItemAmount(ItemDefinition item = null, float amt = 0f)
	{
		itemDef = item;
		amount = amt;
		startAmount = amount;
	}

	public virtual float GetAmount()
	{
		return amount;
	}

	public virtual void OnAfterDeserialize()
	{
		startAmount = amount;
	}

	public virtual void OnBeforeSerialize()
	{
	}

	public static ItemAmountList SerialiseList(List<ItemAmount> list)
	{
		ItemAmountList val = Pool.Get<ItemAmountList>();
		val.amount = Pool.Get<List<float>>();
		val.itemID = Pool.Get<List<int>>();
		foreach (ItemAmount item in list)
		{
			val.amount.Add(item.amount);
			val.itemID.Add(item.itemid);
		}
		return val;
	}

	public static void DeserialiseList(List<ItemAmount> target, ItemAmountList source)
	{
		target.Clear();
		if (source.amount.Count == source.itemID.Count)
		{
			for (int i = 0; i < source.amount.Count; i++)
			{
				target.Add(new ItemAmount(ItemManager.FindItemDefinition(source.itemID[i]), source.amount[i]));
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class ItemAmountRandom
{
	[ItemSelector]
	public ItemDefinition itemDef;

	public AnimationCurve amount = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
	{
		new Keyframe(0f, 0f),
		new Keyframe(1f, 1f)
	});

	public int RandomAmount()
	{
		return Mathf.RoundToInt(amount.Evaluate(Random.Range(0f, 1f)));
	}
}


using System;
using UnityEngine;

[Serializable]
public class ItemAmountRanged : ItemAmount
{
	public float maxAmount = -1f;

	public override void OnAfterDeserialize()
	{
		base.OnAfterDeserialize();
	}

	public ItemAmountRanged(ItemDefinition item = null, float amt = 0f, float max = -1f)
		: base(item, amt)
	{
		maxAmount = max;
	}

	public override float GetAmount()
	{
		if (maxAmount > 0f && maxAmount > amount)
		{
			return Random.Range(amount, maxAmount);
		}
		return amount;
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ItemManager
{
	private struct ItemRemove
	{
		public Item item;

		public float time;
	}

	[ServerVar]
	public static bool EnablePooling = true;

	public static List<ItemDefinition> itemList;

	public static Dictionary<int, ItemDefinition> itemDictionary;

	public static Dictionary<string, ItemDefinition> itemDictionaryByName;

	public static List<ItemBlueprint> bpList;

	public static int[] defaultBlueprints;

	public static ItemDefinition blueprintBaseDef;

	private static List<ItemRemove> ItemRemoves = new List<ItemRemove>();

	public static void InvalidateWorkshopSkinCache()
	{
		if (itemList == null)
		{
			return;
		}
		foreach (ItemDefinition item in itemList)
		{
			item.InvalidateWorkshopSkinCache();
		}
	}

	public static void Initialize()
	{
		if (itemList != null)
		{
			return;
		}
		Stopwatch stopwatch = new Stopwatch();
		stopwatch.Start();
		GameObject[] array = FileSystem.LoadAllFromBundle<GameObject>("items.preload.bundle", "l:ItemDefinition");
		if (array.Length == 0)
		{
			throw new Exception("items.preload.bundle has no items!");
		}
		if (stopwatch.Elapsed.TotalSeconds > 1.0)
		{
			Debug.Log((object)("Loading Items Took: " + stopwatch.Elapsed.TotalMilliseconds / 1000.0 + " seconds"));
		}
		List<ItemDefinition> list = (from x in array
			select x.GetComponent<ItemDefinition>() into x
			where (Object)(object)x != (Object)null
			select x).ToList();
		List<ItemBlueprint> list2 = (from x in array
			select x.GetComponent<ItemBlueprint>() into x
			where (Object)(object)x != (Object)null && x.userCraftable
			select x).ToList();
		Dictionary<int, ItemDefinition> dictionary = new Dictionary<int, ItemDefinition>();
		Dictionary<string, ItemDefinition> dictionary2 = new Dictionary<string, ItemDefinition>(StringComparer.OrdinalIgnoreCase);
		foreach (ItemDefinition item in list)
		{
			item.Initialize(list);
			if (dictionary.ContainsKey(item.itemid))
			{
				ItemDefinition itemDefinition = dictionary[item.itemid];
				Debug.LogWarning((object)("Item ID duplicate " + item.itemid + " (" + ((Object)item).name + ") - have you given your items unique shortnames?"), (Object)(object)((Component)item).gameObject);
				Debug.LogWarning((object)("Other item is " + ((Object)itemDefinition).name), (Object)(object)itemDefinition);
			}
			else if (string.IsNullOrEmpty(item.shortname))
			{
				Debug.LogWarning((object)$"{item} has a null short name! id: {item.itemid} {item.displayName.english}");
			}
			else
			{
				dictionary.Add(item.itemid, item);
				dictionary2.Add(item.shortname, item);
			}
		}
		stopwatch.Stop();
		if (stopwatch.Elapsed.TotalSeconds > 1.0)
		{
			Debug.Log((object)("Building Items Took: " + stopwatch.Elapsed.TotalMilliseconds / 1000.0 + " seconds / Items: " + list.Count + " / Blueprints: " + list2.Count));
		}
		defaultBlueprints = (from x in list2
			where !x.NeedsSteamItem && !x.NeedsSteamDLC && x.defaultBlueprint
			select x.targetItem.itemid).ToArray();
		itemList = list;
		bpList = list2;
		itemDictionary = dictionary;
		itemDictionaryByName = dictionary2;
		blueprintBaseDef = FindItemDefinition("blueprintbase");
	}

	public static Item CreateByName(string strName, int iAmount = 1, ulong skin = 0uL)
	{
		ItemDefinition itemDefinition = itemList.Find((ItemDefinition x) => x.shortname == strName);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return null;
		}
		return CreateByItemID(itemDefinition.itemid, iAmount, skin);
	}

	public static Item CreateByPartialName(string strName, int iAmount = 1, ulong skin = 0uL)
	{
		ItemDefinition itemDefinition = FindDefinitionByPartialName(strName);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return null;
		}
		return CreateByItemID(itemDefinition.itemid, iAmount, skin);
	}

	public static ItemDefinition FindDefinitionByPartialName(string strName)
	{
		ItemDefinition itemDefinition = itemList.Find((ItemDefinition x) => x.shortname == strName);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			itemDefinition = itemList.Find((ItemDefinition x) => StringEx.Contains(x.shortname, strName, CompareOptions.IgnoreCase));
		}
		return itemDefinition;
	}

	public static Item CreateByItemID(int itemID, int iAmount = 1, ulong skin = 0uL)
	{
		ItemDefinition itemDefinition = FindItemDefinition(itemID);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return null;
		}
		return Create(itemDefinition, iAmount, skin);
	}

	public static Item Create(ItemDefinition template, int iAmount = 1, ulong skin = 0uL, bool isServerSide = true)
	{
		Debug.Assert(isServerSide, "Tried to create client item on server!");
		TrySkinChangeItem(ref template, ref skin);
		if ((Object)(object)template == (Object)null)
		{
			Debug.LogWarning((object)"Creating invalid/missing item!");
			return null;
		}
		if (iAmount <= 0)
		{
			Debug.LogError((object)("Creating item with less than 1 amount! (" + template.displayName.english + ")"));
			return null;
		}
		Item item = ((EnablePooling && isServerSide) ? Pool.Get<Item>() : new Item());
		item.isServer = isServerSide;
		item.info = template;
		item.amount = iAmount;
		item.skin = skin;
		item.Initialize(template);
		RustLog.Log(RustLog.EntryType.Item, 1, null, "Created <color={0}>{1}</color>", item.isServer ? "yellow" : "cyan", item);
		return item;
	}

	private static void TrySkinChangeItem(ref ItemDefinition template, ref ulong skinId)
	{
		if (skinId == 0L)
		{
			return;
		}
		ItemSkinDirectory.Skin skin = ItemSkinDirectory.FindByInventoryDefinitionId((int)skinId);
		if (skin.id != 0)
		{
			ItemSkin itemSkin = skin.invItem as ItemSkin;
			if (!((Object)(object)itemSkin == (Object)null) && !((Object)(object)itemSkin.Redirect == (Object)null))
			{
				template = itemSkin.Redirect;
				skinId = 0uL;
			}
		}
	}

	public static Item Load(Item load, Item created, bool isServer)
	{
		if (created == null)
		{
			created = ((EnablePooling && isServer) ? Pool.Get<Item>() : new Item());
		}
		created.isServer = isServer;
		created.Load(load);
		if ((Object)(object)created.info == (Object)null)
		{
			Debug.LogWarning((object)"Item loading failed - item is invalid");
			return null;
		}
		if ((Object)(object)created.info == (Object)(object)blueprintBaseDef && (Object)(object)created.blueprintTargetDef == (Object)null)
		{
			Debug.LogWarning((object)"Blueprint item loading failed - invalid item target");
			return null;
		}
		RustLog.Log(RustLog.EntryType.Item, 1, null, "Loaded <color={0}>{1}</color>", created.isServer ? "yellow" : "cyan", created);
		return created;
	}

	public static ItemDefinition FindItemDefinition(int itemID)
	{
		Initialize();
		if (itemDictionary.TryGetValue(itemID, out var value))
		{
			return value;
		}
		return null;
	}

	public static ItemDefinition FindItemDefinition(string shortName)
	{
		Initialize();
		if (itemDictionaryByName.TryGetValue(shortName, out var value))
		{
			return value;
		}
		return null;
	}

	public static ItemBlueprint FindBlueprint(ItemDefinition item)
	{
		return ((Component)item).GetComponent<ItemBlueprint>();
	}

	public static List<ItemDefinition> GetItemDefinitions()
	{
		Initialize();
		return itemList;
	}

	public static List<ItemBlueprint> GetBlueprints()
	{
		Initialize();
		return bpList;
	}

	public static void DoRemoves()
	{
		TimeWarning val = TimeWarning.New("DoRemoves", 0);
		try
		{
			for (int i = 0; i < ItemRemoves.Count; i++)
			{
				if (!(ItemRemoves[i].time > Time.time))
				{
					Item item = ItemRemoves[i].item;
					ItemRemoves.RemoveAt(i--);
					RustLog.Log(RustLog.EntryType.Item, 1, null, "Removing <color={0}>{1}</color>", item.isServer ? "yellow" : "cyan", item);
					item.DoRemove();
					if (EnablePooling)
					{
						Pool.Free<Item>(ref item);
					}
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void Heartbeat()
	{
		DoRemoves();
	}

	public static void RemoveItem(Item item, float fTime = 0f)
	{
		RustLog.Log(RustLog.EntryType.Item, 2, null, "Scheduled removal of <color={0}>{1}</color>", item.isServer ? "yellow" : "cyan", item);
		ItemRemove item2 = default(ItemRemove);
		item2.item = item;
		item2.time = Time.time + fTime;
		ItemRemoves.Add(item2);
	}

	public static IEnumerable<Item> GetAllItems()
	{
		Queue<Item> buffer = new Queue<Item>();
		HashSet<Item> bufferHash = new HashSet<Item>();
		foreach (Item item in GetAllItemsInternal())
		{
			if (item == null)
			{
				continue;
			}
			yield return item;
			if (item.contents == null)
			{
				continue;
			}
			bufferHash.Clear();
			buffer.Enqueue(item);
			Item result;
			while (buffer.TryDequeue(out result))
			{
				if (result.contents?.itemList == null)
				{
					continue;
				}
				foreach (Item child in result.contents.itemList)
				{
					yield return child;
					if (bufferHash.Add(child))
					{
						buffer.Enqueue(child);
					}
				}
			}
		}
	}

	private static IEnumerable<Item> GetAllItemsInternal()
	{
		List<ItemContainer> buffer = new List<ItemContainer>();
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				if (current is IInventoryProvider inventoryProvider)
				{
					buffer.Clear();
					inventoryProvider.GetAllInventories(buffer);
					foreach (ItemContainer item in buffer)
					{
						foreach (Item item2 in item.itemList)
						{
							yield return item2;
						}
					}
				}
				else if (current is DroppedItem droppedItem)
				{
					yield return droppedItem.item;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}
}


private struct ItemRemove
{
	public Item item;

	public float time;
}


using UnityEngine;

public class LeavesBlowing : MonoBehaviour
{
	public ParticleSystem m_psLeaves;

	public float m_flSwirl;

	public float m_flSpeed;

	public float m_flEmissionRate;

	private void Start()
	{
	}

	private void Update()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.RotateAround(((Component)this).transform.position, Vector3.up, Time.deltaTime * m_flSwirl);
		if ((Object)(object)m_psLeaves != (Object)null)
		{
			m_psLeaves.startSpeed = m_flSpeed;
			ParticleSystem psLeaves = m_psLeaves;
			psLeaves.startSpeed += Mathf.Sin(Time.time * 0.4f) * (m_flSpeed * 0.75f);
			m_psLeaves.emissionRate = m_flEmissionRate + Mathf.Sin(Time.time * 1f) * (m_flEmissionRate * 0.3f);
		}
	}
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/MaterialEffect")]
public class MaterialEffect : ScriptableObject
{
	[Serializable]
	public class Entry
	{
		public PhysicMaterial Material;

		public GameObjectRef Effect;

		public SoundDefinition SoundDefinition;
	}

	public GameObjectRef DefaultEffect;

	public SoundDefinition DefaultSoundDefinition;

	public Entry[] Entries;

	public int waterFootstepIndex = -1;

	public Entry deepWaterEntry;

	public float deepWaterDepth = -1f;

	public Entry submergedWaterEntry;

	public float submergedWaterDepth = -1f;

	public bool ScaleVolumeWithSpeed;

	public AnimationCurve SpeedGainCurve;

	public Entry GetEntryFromMaterial(PhysicMaterial mat)
	{
		Entry[] entries = Entries;
		foreach (Entry entry in entries)
		{
			if ((Object)(object)entry.Material == (Object)(object)mat)
			{
				return entry;
			}
		}
		return null;
	}

	public Entry GetWaterEntry()
	{
		if (waterFootstepIndex == -1)
		{
			for (int i = 0; i < Entries.Length; i++)
			{
				if (((Object)Entries[i].Material).name == "Water")
				{
					waterFootstepIndex = i;
					break;
				}
			}
		}
		if (waterFootstepIndex != -1)
		{
			return Entries[waterFootstepIndex];
		}
		Debug.LogWarning((object)("Unable to find water effect for :" + ((Object)this).name));
		return null;
	}

	public void SpawnOnRay(Ray ray, int mask, float length = 0.5f, Vector3 forward = default(Vector3), float speed = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		if (!GamePhysics.Trace(ray, 0f, out var hitInfo, length, mask, (QueryTriggerInteraction)0))
		{
			Effect.client.Run(DefaultEffect.resourcePath, ((Ray)(ref ray)).origin, ((Ray)(ref ray)).direction * -1f, forward);
			if ((Object)(object)DefaultSoundDefinition != (Object)null)
			{
				PlaySound(DefaultSoundDefinition, ((RaycastHit)(ref hitInfo)).point, speed);
			}
			return;
		}
		WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(((Ray)(ref ray)).origin, waves: true, volumes: false);
		if (waterInfo.isValid)
		{
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(((Ray)(ref ray)).origin.x, waterInfo.surfaceLevel, ((Ray)(ref ray)).origin.z);
			Entry waterEntry = GetWaterEntry();
			if (submergedWaterDepth > 0f && waterInfo.currentDepth >= submergedWaterDepth)
			{
				waterEntry = submergedWaterEntry;
			}
			else if (deepWaterDepth > 0f && waterInfo.currentDepth >= deepWaterDepth)
			{
				waterEntry = deepWaterEntry;
			}
			if (waterEntry != null)
			{
				Effect.client.Run(waterEntry.Effect.resourcePath, val, Vector3.up);
				if ((Object)(object)waterEntry.SoundDefinition != (Object)null)
				{
					PlaySound(waterEntry.SoundDefinition, val, speed);
				}
			}
			return;
		}
		PhysicMaterial materialAt = ((RaycastHit)(ref hitInfo)).collider.GetMaterialAt(((RaycastHit)(ref hitInfo)).point);
		Entry entryFromMaterial = GetEntryFromMaterial(materialAt);
		if (entryFromMaterial == null)
		{
			Effect.client.Run(DefaultEffect.resourcePath, ((RaycastHit)(ref hitInfo)).point, ((RaycastHit)(ref hitInfo)).normal, forward);
			if ((Object)(object)DefaultSoundDefinition != (Object)null)
			{
				PlaySound(DefaultSoundDefinition, ((RaycastHit)(ref hitInfo)).point, speed);
			}
		}
		else
		{
			Effect.client.Run(entryFromMaterial.Effect.resourcePath, ((RaycastHit)(ref hitInfo)).point, ((RaycastHit)(ref hitInfo)).normal, forward);
			if ((Object)(object)entryFromMaterial.SoundDefinition != (Object)null)
			{
				PlaySound(entryFromMaterial.SoundDefinition, ((RaycastHit)(ref hitInfo)).point, speed);
			}
		}
	}

	public void PlaySound(SoundDefinition definition, Vector3 position, float velocity = 0f)
	{
	}
}


using System;
using UnityEngine;

[Serializable]
public class Entry
{
	public PhysicMaterial Material;

	public GameObjectRef Effect;

	public SoundDefinition SoundDefinition;
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/MaterialSound")]
public class MaterialSound : ScriptableObject
{
	[Serializable]
	public class Entry
	{
		public PhysicMaterial Material;

		public SoundDefinition Sound;
	}

	public SoundDefinition DefaultSound;

	public Entry[] Entries;
}


using System;
using UnityEngine;

[Serializable]
public class Entry
{
	public PhysicMaterial Material;

	public SoundDefinition Sound;
}


using UnityEngine;

public class MaxSpawnDistance : MonoBehaviour, IClientComponent
{
	public float maxDistance = 30f;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Rust;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(menuName = "Rust/Missions/BaseMission")]
public class BaseMission : BaseScriptableObject
{
	[Serializable]
	public class MissionDependancy
	{
		public BaseMission targetMission;

		public MissionStatus targetMissionDesiredStatus;

		public bool everAttempted;

		public uint targetMissionID
		{
			get
			{
				if (!(targetMission != null))
				{
					return 0u;
				}
				return StringEx.ManifestHash(targetMission.shortname);
			}
		}
	}

	public enum MissionStatus
	{
		Default,
		Active,
		Accomplished,
		Failed,
		Completed
	}

	public enum MissionEventType
	{
		CUSTOM,
		HARVEST,
		CONVERSATION,
		KILL_ENTITY,
		ACQUIRE_ITEM,
		FREE_CRATE,
		MOUNT_ENTITY,
		HURT_ENTITY,
		PLAYER_TICK,
		CRAFT_ITEM,
		DEPLOY,
		HEAL,
		CLOTHINGCHANGED,
		STARTOVEN,
		CONSUME,
		ACQUITE_ITEM_STACK,
		OPEN_STORAGE,
		COOK,
		ENTER_TRIGGER,
		UPGRADE_BUILDING_GRADE,
		RESPAWN,
		METAL_DETECTOR_FIND,
		LONG_USE_OBJECT
	}

	[Serializable]
	public class MissionObjectiveEntry
	{
		public Phrase description;

		public bool startAfterPriorObjectives;

		public int[] startAfterCompletedObjectives;

		public int[] autoCompleteOtherObjectives;

		public bool onlyProgressIfStarted = true;

		public bool isRequired = true;

		public MissionObjective objective;

		public string[] requiredEntities;

		public ItemAmount[] bonusRewards;

		public MissionObjective Get()
		{
			return objective;
		}
	}

	public struct MissionEventPayload
	{
		public NetworkableId NetworkIdentifier;

		public uint UintIdentifier;

		public int IntIdentifier;

		public Vector3 WorldPosition;
	}

	public class MissionInstance : IPooled
	{
		[Serializable]
		public class ObjectiveStatus
		{
			public bool started;

			public bool completed;

			public bool failed;

			public float progressTarget;

			public float progressCurrent;

			public RealTimeSince sinceLastThink;
		}

		public enum ObjectiveType
		{
			MOVE,
			KILL
		}

		private BaseEntity _cachedProviderEntity;

		private BaseMission _cachedMission;

		public NetworkableId providerID;

		public uint missionID;

		public MissionStatus status;

		public float startTime;

		public float endTime;

		public Vector3 missionLocation;

		public float timePassed;

		public Dictionary<string, Vector3> missionPoints = new Dictionary<string, Vector3>();

		public Dictionary<string, MissionEntity> missionEntities = new Dictionary<string, MissionEntity>();

		private int playerInputCounter;

		public ObjectiveStatus[] objectiveStatuses;

		public BaseEntity ProviderEntity()
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)_cachedProviderEntity == (Object)null)
			{
				_cachedProviderEntity = BaseNetworkable.serverEntities.Find(providerID) as BaseEntity;
			}
			return _cachedProviderEntity;
		}

		public BaseMission GetMission()
		{
			if (_cachedMission == null)
			{
				_cachedMission = MissionManifest.GetFromID(missionID);
			}
			return _cachedMission;
		}

		public bool ShouldShowOnMap()
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			if (status == MissionStatus.Active || status == MissionStatus.Accomplished)
			{
				return missionLocation != Vector3.zero;
			}
			return false;
		}

		public bool ShouldShowOnCompass()
		{
			return ShouldShowOnMap();
		}

		public bool NeedsPlayerInput()
		{
			return playerInputCounter > 0;
		}

		public void EnablePlayerInput()
		{
			playerInputCounter++;
		}

		public void DisablePlayerInput()
		{
			playerInputCounter--;
			if (playerInputCounter < 0)
			{
				playerInputCounter = 0;
			}
		}

		public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionEventType type, MissionEventPayload payload, float amount)
		{
			if (status == MissionStatus.Active)
			{
				BaseMission mission = GetMission();
				for (int i = 0; i < mission.objectives.Length; i++)
				{
					mission.objectives[i].objective.ProcessMissionEvent(playerFor, this, i, type, payload, amount);
				}
			}
		}

		public void Think(BasePlayer assignee, float delta)
		{
			if (status != MissionStatus.Failed && status != MissionStatus.Completed)
			{
				BaseMission mission = GetMission();
				timePassed += delta;
				mission.Think(this, assignee, delta);
				if (mission.timeLimitSeconds > 0f && timePassed >= mission.timeLimitSeconds)
				{
					mission.MissionFailed(this, assignee, MissionFailReason.TimeOut);
				}
			}
		}

		public Vector3 GetMissionPoint(string identifier, BasePlayer playerFor, int depth = 0)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
			if (identifier == null)
			{
				identifier = "";
			}
			if (missionPoints.TryGetValue(identifier, out var value))
			{
				return value;
			}
			BaseMission mission = GetMission();
			if ((Object)(object)playerFor == (Object)null)
			{
				Debug.LogError((object)("Massive mission failure to get point, correct mission definition of: " + mission.shortname + " (player is null)"));
				return Vector3.zero;
			}
			PositionGenerator positionGenerator = List.FindWith<PositionGenerator, string>((IReadOnlyCollection<PositionGenerator>)(object)mission.positionGenerators, (Func<PositionGenerator, string>)((PositionGenerator p) => p.identifier), identifier, (IEqualityComparer<string>)null);
			if (positionGenerator == null)
			{
				Debug.LogError((object)("Massive mission failure to get point, correct mission definition of: " + mission.shortname + " (cannot find position '" + identifier + "')"));
				return Vector3.zero;
			}
			Vector3 position = positionGenerator.GetPosition(this, playerFor, depth);
			missionPoints.Add(identifier, position);
			if (positionGenerator.positionsAreExclusive)
			{
				AddBlocker(position);
			}
			return position;
		}

		public MissionEntity GetMissionEntity(string identifier, BasePlayer playerFor)
		{
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			if (identifier == null)
			{
				identifier = "";
			}
			if (missionEntities.TryGetValue(identifier, out var value))
			{
				return value;
			}
			MissionEntityEntry missionEntityEntry = List.FindWith<MissionEntityEntry, string>((IReadOnlyCollection<MissionEntityEntry>)(object)GetMission().missionEntities, (Func<MissionEntityEntry, string>)((MissionEntityEntry e) => e.identifier), identifier, (IEqualityComparer<string>)null);
			if (missionEntityEntry == null)
			{
				Debug.LogError((object)$"Cannot spawn mission entity, identifier '{identifier}' not found in mission ID {missionID}");
				value = null;
			}
			else if (!missionEntityEntry.entityRef.isValid)
			{
				Debug.LogError((object)$"Cannot spawn mission entity, identifier '{identifier}' has no entity set in mission ID {missionID}");
				value = null;
			}
			else
			{
				Vector3 missionPoint = GetMissionPoint(missionEntityEntry.spawnPositionToUse, playerFor);
				BaseEntity baseEntity = GameManager.server.CreateEntity(missionEntityEntry.entityRef.resourcePath, missionPoint, Quaternion.identity);
				MissionEntity missionEntity = default(MissionEntity);
				MissionEntity missionEntity2 = (((Component)baseEntity).gameObject.TryGetComponent<MissionEntity>(ref missionEntity) ? missionEntity : ((Component)baseEntity).gameObject.AddComponent<MissionEntity>());
				missionEntity2.Setup(playerFor, this, identifier, missionEntityEntry.cleanupOnMissionSuccess, missionEntityEntry.cleanupOnMissionFailed);
				baseEntity.Spawn();
				if (baseEntity is LootContainer lootContainer && missionEntityEntry.overrideLootOnItem != null && missionEntityEntry.overrideLootOnItem.Length != 0)
				{
					lootContainer.inventory.Clear();
					ItemAmount[] overrideLootOnItem = missionEntityEntry.overrideLootOnItem;
					foreach (ItemAmount itemAmount in overrideLootOnItem)
					{
						lootContainer.inventory.AddItem(itemAmount.itemDef, (int)itemAmount.amount, 0uL);
					}
				}
				value = missionEntity2;
			}
			missionEntities.Add(identifier, value);
			if ((Object)(object)value != (Object)null)
			{
				value.MissionStarted(playerFor, this);
			}
			return value;
		}

		public void PostServerLoad(BasePlayer player)
		{
			BaseMission mission = GetMission();
			for (int i = 0; i < mission.objectives.Length; i++)
			{
				if (i >= 0 && i < objectiveStatuses.Length)
				{
					mission.objectives[i].objective.PostServerLoad(player, objectiveStatuses[i]);
				}
			}
		}

		public int GetTotalRequiredRewardItemSlots()
		{
			BaseMission mission = GetMission();
			int num = 0;
			for (int i = 0; i < mission.objectives.Length; i++)
			{
				if (!mission.objectives[i].isRequired && objectiveStatuses[i].completed)
				{
					num += mission.objectives[i].bonusRewards.Length;
				}
			}
			return mission.GetMissionRewards().Length + num;
		}

		public void Reset()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			providerID = default(NetworkableId);
			missionID = 0u;
			status = MissionStatus.Default;
			startTime = -1f;
			endTime = -1f;
			missionLocation = Vector3.zero;
			_cachedMission = null;
			timePassed = 0f;
			missionPoints.Clear();
			missionEntities.Clear();
		}

		public void EnterPool()
		{
			Reset();
		}

		public void LeavePool()
		{
		}
	}

	[Serializable]
	public class PositionGenerator
	{
		public enum RelativeType
		{
			Player,
			Provider,
			Position
		}

		public enum PositionType
		{
			MissionPoint,
			WorldPositionGenerator,
			DungeonPoint,
			Radius
		}

		public class PositionPointAttribute : PropertyAttribute
		{
		}

		public string identifier;

		public float minDistForMovePoint;

		public float maxDistForMovePoint = 25f;

		public bool allowDoubleDistanceIfNoOptionsAreFound;

		public bool positionsAreExclusive = true;

		public RelativeType relativeTo;

		public PositionType positionType;

		public string centerOnPositionIdentifier = "";

		[InspectorFlags]
		public MissionPoint.MissionPointEnum Flags = (MissionPoint.MissionPointEnum)(-1);

		[InspectorFlags]
		public MissionPoint.MissionPointEnum ExclusionFlags;

		public WorldPositionGenerator worldPositionGenerator;

		public bool IsDependant()
		{
			return !string.IsNullOrEmpty(centerOnPositionIdentifier);
		}

		public bool Validate(BasePlayer assignee, BaseMission missionDef)
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			Vector3 position;
			if (positionType == PositionType.MissionPoint)
			{
				List<MissionPoint> points = Pool.Get<List<MissionPoint>>();
				bool missionPoints = MissionPoint.GetMissionPoints(ref points, ((Component)assignee).transform.position, minDistForMovePoint, maxDistForMovePoint, (int)Flags, (int)ExclusionFlags);
				if (!missionPoints && allowDoubleDistanceIfNoOptionsAreFound)
				{
					points.Clear();
					missionPoints = MissionPoint.GetMissionPoints(ref points, ((Component)assignee).transform.position, minDistForMovePoint, maxDistForMovePoint * 2f, (int)Flags, (int)ExclusionFlags);
				}
				Pool.FreeUnmanaged<MissionPoint>(ref points);
				if (!missionPoints)
				{
					return false;
				}
			}
			else if (positionType == PositionType.WorldPositionGenerator && (Object)(object)worldPositionGenerator != (Object)null && !worldPositionGenerator.TrySample(((Component)assignee).transform.position, minDistForMovePoint, maxDistForMovePoint, out position, blockedPoints))
			{
				return false;
			}
			return true;
		}

		public Vector3 GetPosition(MissionInstance instance, BasePlayer assignee, int depth = 0)
		{
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0150: Unknown result type (might be due to invalid IL or missing references)
			//IL_0155: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_015b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0160: Unknown result type (might be due to invalid IL or missing references)
			//IL_0175: Unknown result type (might be due to invalid IL or missing references)
			//IL_0176: Unknown result type (might be due to invalid IL or missing references)
			//IL_0189: Unknown result type (might be due to invalid IL or missing references)
			//IL_018e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0193: Unknown result type (might be due to invalid IL or missing references)
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0115: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0138: Unknown result type (might be due to invalid IL or missing references)
			//IL_0139: Unknown result type (might be due to invalid IL or missing references)
			//IL_0120: Unknown result type (might be due to invalid IL or missing references)
			//IL_0122: Unknown result type (might be due to invalid IL or missing references)
			if (depth > 10)
			{
				Debug.LogError((object)$"Exceeded max depth while calculating position! missionID={instance.missionID} identifier={identifier}");
				return ((Component)assignee).transform.position;
			}
			Vector3 relativeToPosition = GetRelativeToPosition(instance, assignee, depth);
			Vector3 result;
			if (positionType == PositionType.MissionPoint)
			{
				List<MissionPoint> points = Pool.Get<List<MissionPoint>>();
				bool missionPoints = MissionPoint.GetMissionPoints(ref points, relativeToPosition, minDistForMovePoint, maxDistForMovePoint, (int)Flags, (int)ExclusionFlags);
				if (!missionPoints && allowDoubleDistanceIfNoOptionsAreFound)
				{
					points.Clear();
					missionPoints = MissionPoint.GetMissionPoints(ref points, relativeToPosition, minDistForMovePoint, maxDistForMovePoint * 2f, (int)Flags, (int)ExclusionFlags);
				}
				if (missionPoints)
				{
					result = points[Random.Range(0, points.Count)].GetPosition();
				}
				else
				{
					Debug.LogError((object)"UNABLE TO FIND MISSIONPOINT FOR MISSION!");
					result = relativeToPosition;
				}
				Pool.FreeUnmanaged<MissionPoint>(ref points);
			}
			else if (positionType == PositionType.WorldPositionGenerator && (Object)(object)worldPositionGenerator != (Object)null)
			{
				int num = 0;
				while (true)
				{
					if (worldPositionGenerator.TrySample(relativeToPosition, minDistForMovePoint, maxDistForMovePoint, out var position, blockedPoints) && TryAlignToGround(position, out var correctedPosition))
					{
						result = correctedPosition;
						break;
					}
					if (num >= 10)
					{
						Debug.LogError((object)"UNABLE TO FIND WORLD POINT FOR MISSION!");
						result = relativeToPosition;
						break;
					}
					num++;
				}
			}
			else if (positionType == PositionType.DungeonPoint)
			{
				result = DynamicDungeon.GetNextDungeonPoint();
			}
			else
			{
				int num2 = 0;
				while (true)
				{
					Vector3 onUnitSphere = Random.onUnitSphere;
					onUnitSphere.y = 0f;
					((Vector3)(ref onUnitSphere)).Normalize();
					Vector3 val = relativeToPosition + onUnitSphere * Random.Range(minDistForMovePoint, maxDistForMovePoint);
					val.y = WaterLevel.GetWaterOrTerrainSurface(val, waves: false, volumes: false);
					if (TryAlignToGround(val, out var correctedPosition2))
					{
						result = correctedPosition2;
						break;
					}
					if (num2 >= 10)
					{
						Debug.LogError((object)"UNABLE TO FIND WORLD POINT FOR MISSION!");
						result = relativeToPosition;
						break;
					}
					num2++;
				}
			}
			return result;
		}

		private Vector3 GetRelativeToPosition(MissionInstance instance, BasePlayer assignee, int depth)
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			switch (relativeTo)
			{
			case RelativeType.Position:
				return instance.GetMissionPoint(centerOnPositionIdentifier, assignee, depth + 1);
			case RelativeType.Provider:
			{
				BaseEntity baseEntity = instance.ProviderEntity();
				if ((Object)(object)baseEntity != (Object)null)
				{
					return ((Component)baseEntity).transform.position;
				}
				break;
			}
			}
			if ((Object)(object)assignee != (Object)null)
			{
				return ((Component)assignee).transform.position;
			}
			Debug.LogError((object)$"Cannot get mission point origin - assigne playere is null! missionID={instance.missionID} relativeTo={relativeTo}");
			return Vector3.zero;
		}

		private static bool TryAlignToGround(Vector3 wishPosition, out Vector3 correctedPosition)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = Vector3Ex.WithY(wishPosition, wishPosition.y + 50f);
			RaycastHit hit = default(RaycastHit);
			if (!Physics.Raycast(new Ray(val, Vector3.down), ref hit, 50f, 1218652417, (QueryTriggerInteraction)1))
			{
				correctedPosition = wishPosition;
				return true;
			}
			if ((Object)(object)hit.GetEntity() != (Object)null)
			{
				correctedPosition = wishPosition;
				return false;
			}
			correctedPosition = ((RaycastHit)(ref hit)).point;
			return true;
		}
	}

	[Serializable]
	public class MissionEntityEntry
	{
		[FormerlySerializedAs("entityIdentifier")]
		public string identifier;

		public GameObjectRef entityRef;

		public string spawnPositionToUse;

		public bool spawnOnMissionStart = true;

		public bool cleanupOnMissionFailed;

		public bool cleanupOnMissionSuccess;

		public ItemAmount[] overrideLootOnItem;
	}

	[Serializable]
	public struct NonItemReward
	{
		public Phrase DisplayPhrase;

		public Sprite DisplaySprite;

		public NonItemRewardType RewardType;
	}

	public enum NonItemRewardType
	{
		None,
		SafeZoneRespawnUnlock
	}

	[Serializable]
	public class MissionRewards
	{
		public ItemAmount[] items;

		public Era[] Eras;
	}

	public enum MissionFailReason
	{
		TimeOut,
		Disconnect,
		ResetPlayerState,
		Abandon,
		ObjectiveFailed
	}

	[ServerVar]
	public static bool missionsenabled = true;

	public string shortname;

	public Phrase missionName;

	public Phrase missionDesc;

	public bool canBeAbandoned = true;

	public bool completeSilently;

	public bool blockMissionStat;

	public TutorialMissionHelpSet showHelpInfo;

	public string[] requiredGameModeTags = new string[0];

	public MissionObjectiveEntry[] objectives;

	public GameObjectRef genericMissionProvider;

	public static List<Vector3> blockedPoints = new List<Vector3>();

	public const string MISSION_COMPLETE_STAT = "missions_completed";

	public GameObjectRef acceptEffect;

	public GameObjectRef failedEffect;

	public GameObjectRef victoryEffect;

	public BasePlayer.TutorialItemAllowance AllowedTutorialItems;

	public bool IsTutorialMission;

	public BaseMission followupMission;

	public int repeatDelaySecondsSuccess = -1;

	public int repeatDelaySecondsFailed = -1;

	public float timeLimitSeconds;

	public Sprite icon;

	public Sprite providerIcon;

	public bool hideStagesNotStarted;

	public MissionDependancy[] acceptDependancies;

	public MissionEntityEntry[] missionEntities;

	public PositionGenerator[] positionGenerators;

	public ItemAmount[] baseRewards;

	public MissionRewards[] alternativeRewards;

	public NonItemReward[] nonItemRewards;

	public uint id => StringEx.ManifestHash(shortname);

	public bool isRepeatable
	{
		get
		{
			if (repeatDelaySecondsSuccess < 0)
			{
				return repeatDelaySecondsFailed >= 0;
			}
			return true;
		}
	}

	public static void PlayerDisconnected(BasePlayer player)
	{
		if (player.IsNpc)
		{
			return;
		}
		int activeMission = player.GetActiveMission();
		if (activeMission != -1 && activeMission < player.missions.Count)
		{
			MissionInstance missionInstance = player.missions[activeMission];
			BaseMission mission = missionInstance.GetMission();
			if (mission.missionEntities.Length != 0)
			{
				mission.MissionFailed(missionInstance, player, MissionFailReason.Disconnect);
			}
		}
	}

	public static void PlayerKilled(BasePlayer player)
	{
	}

	public ItemAmount[] GetMissionRewards()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Invalid comparison between I4 and Unknown
		if ((int)ConVar.Server.Era == 0)
		{
			return baseRewards;
		}
		if (alternativeRewards != null)
		{
			MissionRewards[] array = alternativeRewards;
			foreach (MissionRewards missionRewards in array)
			{
				if (missionRewards.Eras == null)
				{
					continue;
				}
				Era[] eras = missionRewards.Eras;
				for (int j = 0; j < eras.Length; j++)
				{
					if ((int)eras[j] == (int)ConVar.Server.Era && missionRewards.items != null)
					{
						return missionRewards.items;
					}
				}
			}
		}
		return baseRewards;
	}

	public virtual Sprite GetIcon(MissionInstance instance)
	{
		return icon;
	}

	public static void AddBlocker(Vector3 point)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (point != Vector3.zero && !blockedPoints.Contains(point))
		{
			blockedPoints.Add(point);
		}
	}

	public void RemoveBlockers(MissionInstance instance)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		foreach (KeyValuePair<string, Vector3> missionPoint in instance.missionPoints)
		{
			if (positionGenerators[num++].positionsAreExclusive)
			{
				blockedPoints.Remove(missionPoint.Value);
			}
		}
	}

	public static void DoMissionEffect(string effectString, BasePlayer assignee)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Effect effect = new Effect();
		effect.Init(Effect.Type.Generic, assignee, StringPool.Get("head"), Vector3.zero, Vector3.forward);
		effect.pooledString = effectString;
		EffectNetwork.Send(effect, assignee.net.connection);
	}

	public virtual void MissionStart(MissionInstance instance, BasePlayer assignee)
	{
		if (Interface.CallHook("OnMissionStart", (object)this, (object)instance, (object)assignee) != null)
		{
			return;
		}
		for (int i = 0; i < objectives.Length; i++)
		{
			objectives[i].Get().MissionStarted(i, instance, assignee);
		}
		if (acceptEffect.isValid)
		{
			DoMissionEffect(acceptEffect.resourcePath, assignee);
		}
		MissionEntityEntry[] array = missionEntities;
		foreach (MissionEntityEntry missionEntityEntry in array)
		{
			if (missionEntityEntry.spawnOnMissionStart)
			{
				instance.GetMissionEntity(missionEntityEntry.identifier, assignee);
			}
		}
		if (AllowedTutorialItems != 0)
		{
			assignee.SetTutorialAllowance(AllowedTutorialItems);
		}
		Interface.CallHook("OnMissionStarted", (object)this, (object)instance, (object)assignee);
	}

	public void CheckObjectives(MissionInstance instance, BasePlayer assignee)
	{
		bool flag = true;
		bool flag2 = false;
		for (int i = 0; i < objectives.Length; i++)
		{
			if (objectives[i].isRequired && (!instance.objectiveStatuses[i].completed || instance.objectiveStatuses[i].failed))
			{
				flag = false;
			}
			if (instance.objectiveStatuses[i].failed && objectives[i].isRequired)
			{
				flag2 = true;
			}
		}
		if (instance.status == MissionStatus.Active)
		{
			if (flag2)
			{
				MissionFailed(instance, assignee, MissionFailReason.ObjectiveFailed);
			}
			else if (flag)
			{
				MissionSuccess(instance, assignee);
			}
		}
	}

	public virtual void Think(MissionInstance instance, BasePlayer assignee, float delta)
	{
		for (int i = 0; i < objectives.Length; i++)
		{
			objectives[i].Get().Think(i, instance, assignee, delta);
		}
		CheckObjectives(instance, assignee);
	}

	public virtual void MissionComplete(MissionInstance instance, BasePlayer assignee)
	{
		DoMissionEffect(victoryEffect.resourcePath, assignee);
		if (!instance.GetMission().completeSilently)
		{
			assignee.ChatMessage("You have completed the mission : " + missionName.english);
		}
		BaseMission mission = instance.GetMission();
		if (mission != null)
		{
			ItemAmount[] missionRewards = mission.GetMissionRewards();
			if (missionRewards != null)
			{
				ItemAmount[] array = missionRewards;
				foreach (ItemAmount reward2 in array)
				{
					GiveReward(assignee, reward2);
				}
			}
			if (mission.nonItemRewards != null)
			{
				NonItemReward[] array2 = mission.nonItemRewards;
				for (int i = 0; i < array2.Length; i++)
				{
					if (array2[i].RewardType != NonItemRewardType.SafeZoneRespawnUnlock)
					{
						continue;
					}
					using HashSet<StaticRespawnArea>.Enumerator enumerator = StaticRespawnArea.staticRespawnAreas.GetEnumerator();
					if (enumerator.MoveNext())
					{
						enumerator.Current.Authorize(assignee.userID);
						assignee.SendRespawnOptions();
					}
				}
			}
			for (int j = 0; j < mission.objectives.Length; j++)
			{
				MissionObjectiveEntry missionObjectiveEntry = mission.objectives[j];
				if (!missionObjectiveEntry.isRequired && missionObjectiveEntry.bonusRewards != null && instance.objectiveStatuses[j].completed && !instance.objectiveStatuses[j].failed)
				{
					ItemAmount[] array = missionObjectiveEntry.bonusRewards;
					foreach (ItemAmount reward3 in array)
					{
						GiveReward(assignee, reward3);
					}
				}
			}
		}
		Analytics.Azure.OnMissionComplete(assignee, this, null);
		instance.status = MissionStatus.Completed;
		assignee.SetActiveMission(-1);
		assignee.MissionDirty();
		if (followupMission != null)
		{
			assignee.RegisterFollowupMission(followupMission, instance.ProviderEntity() as IMissionProvider);
		}
		if (GameInfo.HasAchievements && mission != null && !mission.blockMissionStat)
		{
			assignee.stats.Add("missions_completed", 1, Stats.All);
			assignee.stats.Save(forceSteamSave: true);
		}
		if (assignee.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = assignee.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null && currentTutorialIsland.FinalMission == this)
			{
				currentTutorialIsland.StartEndingCinematic(assignee);
			}
		}
		if (!completeSilently)
		{
			assignee.ClientRPC(RpcTarget.Player("Client_MissionComplete", assignee), id);
		}
		static void GiveReward(BasePlayer player, ItemAmount reward)
		{
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)reward.itemDef == (Object)null || reward.amount == 0f)
			{
				Debug.LogError((object)"BIG REWARD SCREWUP, NULL ITEM DEF");
			}
			else if (!reward.itemDef.IsAllowed((EraRestriction)8))
			{
				Debug.LogError((object)$"Blocking mission reward '{reward.itemDef.shortname}' not allowed in era '{ConVar.Server.Era}'");
			}
			else
			{
				Item item = (reward.isBP ? ItemManager.Create(ItemManager.blueprintBaseDef, Mathf.CeilToInt(reward.amount), 0uL) : ItemManager.Create(reward.itemDef, Mathf.CeilToInt(reward.amount), 0uL));
				if (reward.isBP)
				{
					item.blueprintTarget = reward.itemDef.itemid;
				}
				item.SetItemOwnership(player, ItemOwnershipPhrases.MissionRewardPhrase);
				if (item != null)
				{
					player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
				}
			}
		}
	}

	public virtual void MissionSuccess(MissionInstance instance, BasePlayer assignee)
	{
		instance.status = MissionStatus.Accomplished;
		MissionEnded(instance, assignee);
		MissionComplete(instance, assignee);
		Interface.CallHook("OnMissionSucceeded", (object)this, (object)instance, (object)assignee);
	}

	public virtual void MissionFailed(MissionInstance instance, BasePlayer assignee, MissionFailReason failReason)
	{
		if (!instance.GetMission().completeSilently)
		{
			assignee.ChatMessage("You have failed the mission : " + missionName.english);
		}
		DoMissionEffect(failedEffect.resourcePath, assignee);
		Analytics.Azure.OnMissionComplete(assignee, this, failReason);
		instance.status = MissionStatus.Failed;
		MissionEnded(instance, assignee);
		Interface.CallHook("OnMissionFailed", (object)this, (object)instance, (object)assignee, (object)failReason);
		if (failReason == MissionFailReason.ResetPlayerState)
		{
			instance.endTime = 0f;
			instance.status = MissionStatus.Default;
			assignee.MissionDirty();
		}
	}

	public virtual void MissionEnded(MissionInstance instance, BasePlayer assignee)
	{
		if (instance.missionEntities != null)
		{
			List<MissionEntity> list = Pool.Get<List<MissionEntity>>();
			foreach (MissionEntity value in instance.missionEntities.Values)
			{
				list.Add(value);
			}
			foreach (MissionEntity item in list)
			{
				if (!((Object)(object)item == (Object)null))
				{
					item.MissionEnded(assignee, instance);
				}
			}
			Pool.FreeUnmanaged<MissionEntity>(ref list);
		}
		RemoveBlockers(instance);
		assignee.SetActiveMission(-1);
		assignee.MissionDirty();
	}

	public void OnObjectiveCompleted(int objectiveIndex, MissionInstance instance, BasePlayer playerFor)
	{
		MissionObjectiveEntry missionObjectiveEntry = objectives[objectiveIndex];
		if (missionObjectiveEntry.autoCompleteOtherObjectives.Length != 0)
		{
			int[] autoCompleteOtherObjectives = missionObjectiveEntry.autoCompleteOtherObjectives;
			foreach (int num in autoCompleteOtherObjectives)
			{
				MissionObjectiveEntry missionObjectiveEntry2 = objectives[num];
				if (!instance.objectiveStatuses[num].completed)
				{
					missionObjectiveEntry2.objective.CompleteObjective(num, instance, playerFor);
				}
			}
		}
		CheckObjectives(instance, playerFor);
	}

	public void OnObjectiveFailed(int objectiveIndex, MissionInstance instance, BasePlayer playerFor)
	{
		CheckObjectives(instance, playerFor);
	}

	public static bool AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)
	{
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		if (!missionsenabled)
		{
			return false;
		}
		if (!mission.IsEligableForMission(assignee, provider))
		{
			return false;
		}
		object obj = Interface.CallHook("CanAssignMission", (object)assignee, (object)mission, (object)provider);
		if (obj is bool)
		{
			return (bool)obj;
		}
		int num = List.FindIndexWith<MissionInstance, uint>((IReadOnlyList<MissionInstance>)assignee.missions, (Func<MissionInstance, uint>)((MissionInstance i) => i.missionID), mission.id, (IEqualityComparer<uint>)null);
		MissionInstance missionInstance;
		int activeMission;
		if (num >= 0)
		{
			missionInstance = assignee.missions[num];
			activeMission = num;
			missionInstance.Reset();
		}
		else
		{
			missionInstance = Pool.Get<MissionInstance>();
			activeMission = assignee.missions.Count;
			assignee.missions.Add(missionInstance);
		}
		missionInstance.missionID = mission.id;
		missionInstance.startTime = Time.time;
		missionInstance.providerID = provider.ProviderID();
		missionInstance.status = MissionStatus.Active;
		missionInstance.objectiveStatuses = new MissionInstance.ObjectiveStatus[mission.objectives.Length];
		for (int j = 0; j < mission.objectives.Length; j++)
		{
			missionInstance.objectiveStatuses[j] = new MissionInstance.ObjectiveStatus();
		}
		mission.MissionStart(missionInstance, assignee);
		assignee.SetActiveMission(activeMission);
		assignee.MissionDirty();
		Interface.CallHook("OnMissionAssigned", (object)mission, (object)provider, (object)assignee);
		return true;
	}

	public bool IsEligableForMission(BasePlayer player, IMissionProvider provider)
	{
		if (!missionsenabled)
		{
			return false;
		}
		foreach (MissionInstance mission in player.missions)
		{
			if (mission.status == MissionStatus.Accomplished || mission.status == MissionStatus.Active)
			{
				return false;
			}
		}
		return true;
	}
}


using System;
using UnityEngine;

[Serializable]
public class MissionDependancy
{
	public BaseMission targetMission;

	public MissionStatus targetMissionDesiredStatus;

	public bool everAttempted;

	public uint targetMissionID
	{
		get
		{
			if (!(targetMission != null))
			{
				return 0u;
			}
			return StringEx.ManifestHash(targetMission.shortname);
		}
	}
}


public enum MissionStatus
{
	Default,
	Active,
	Accomplished,
	Failed,
	Completed
}


public enum MissionEventType
{
	CUSTOM,
	HARVEST,
	CONVERSATION,
	KILL_ENTITY,
	ACQUIRE_ITEM,
	FREE_CRATE,
	MOUNT_ENTITY,
	HURT_ENTITY,
	PLAYER_TICK,
	CRAFT_ITEM,
	DEPLOY,
	HEAL,
	CLOTHINGCHANGED,
	STARTOVEN,
	CONSUME,
	ACQUITE_ITEM_STACK,
	OPEN_STORAGE,
	COOK,
	ENTER_TRIGGER,
	UPGRADE_BUILDING_GRADE,
	RESPAWN,
	METAL_DETECTOR_FIND,
	LONG_USE_OBJECT
}


using System;

[Serializable]
public class MissionObjectiveEntry
{
	public Phrase description;

	public bool startAfterPriorObjectives;

	public int[] startAfterCompletedObjectives;

	public int[] autoCompleteOtherObjectives;

	public bool onlyProgressIfStarted = true;

	public bool isRequired = true;

	public MissionObjective objective;

	public string[] requiredEntities;

	public ItemAmount[] bonusRewards;

	public MissionObjective Get()
	{
		return objective;
	}
}


using UnityEngine;

public struct MissionEventPayload
{
	public NetworkableId NetworkIdentifier;

	public uint UintIdentifier;

	public int IntIdentifier;

	public Vector3 WorldPosition;
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.Extend;
using UnityEngine;

public class MissionInstance : IPooled
{
	[Serializable]
	public class ObjectiveStatus
	{
		public bool started;

		public bool completed;

		public bool failed;

		public float progressTarget;

		public float progressCurrent;

		public RealTimeSince sinceLastThink;
	}

	public enum ObjectiveType
	{
		MOVE,
		KILL
	}

	private BaseEntity _cachedProviderEntity;

	private BaseMission _cachedMission;

	public NetworkableId providerID;

	public uint missionID;

	public MissionStatus status;

	public float startTime;

	public float endTime;

	public Vector3 missionLocation;

	public float timePassed;

	public Dictionary<string, Vector3> missionPoints = new Dictionary<string, Vector3>();

	public Dictionary<string, MissionEntity> missionEntities = new Dictionary<string, MissionEntity>();

	private int playerInputCounter;

	public ObjectiveStatus[] objectiveStatuses;

	public BaseEntity ProviderEntity()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)_cachedProviderEntity == (Object)null)
		{
			_cachedProviderEntity = BaseNetworkable.serverEntities.Find(providerID) as BaseEntity;
		}
		return _cachedProviderEntity;
	}

	public BaseMission GetMission()
	{
		if (_cachedMission == null)
		{
			_cachedMission = MissionManifest.GetFromID(missionID);
		}
		return _cachedMission;
	}

	public bool ShouldShowOnMap()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if (status == MissionStatus.Active || status == MissionStatus.Accomplished)
		{
			return missionLocation != Vector3.zero;
		}
		return false;
	}

	public bool ShouldShowOnCompass()
	{
		return ShouldShowOnMap();
	}

	public bool NeedsPlayerInput()
	{
		return playerInputCounter > 0;
	}

	public void EnablePlayerInput()
	{
		playerInputCounter++;
	}

	public void DisablePlayerInput()
	{
		playerInputCounter--;
		if (playerInputCounter < 0)
		{
			playerInputCounter = 0;
		}
	}

	public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionEventType type, MissionEventPayload payload, float amount)
	{
		if (status == MissionStatus.Active)
		{
			BaseMission mission = GetMission();
			for (int i = 0; i < mission.objectives.Length; i++)
			{
				mission.objectives[i].objective.ProcessMissionEvent(playerFor, this, i, type, payload, amount);
			}
		}
	}

	public void Think(BasePlayer assignee, float delta)
	{
		if (status != MissionStatus.Failed && status != MissionStatus.Completed)
		{
			BaseMission mission = GetMission();
			timePassed += delta;
			mission.Think(this, assignee, delta);
			if (mission.timeLimitSeconds > 0f && timePassed >= mission.timeLimitSeconds)
			{
				mission.MissionFailed(this, assignee, MissionFailReason.TimeOut);
			}
		}
	}

	public Vector3 GetMissionPoint(string identifier, BasePlayer playerFor, int depth = 0)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		if (identifier == null)
		{
			identifier = "";
		}
		if (missionPoints.TryGetValue(identifier, out var value))
		{
			return value;
		}
		BaseMission mission = GetMission();
		if ((Object)(object)playerFor == (Object)null)
		{
			Debug.LogError((object)("Massive mission failure to get point, correct mission definition of: " + mission.shortname + " (player is null)"));
			return Vector3.zero;
		}
		PositionGenerator positionGenerator = List.FindWith<PositionGenerator, string>((IReadOnlyCollection<PositionGenerator>)(object)mission.positionGenerators, (Func<PositionGenerator, string>)((PositionGenerator p) => p.identifier), identifier, (IEqualityComparer<string>)null);
		if (positionGenerator == null)
		{
			Debug.LogError((object)("Massive mission failure to get point, correct mission definition of: " + mission.shortname + " (cannot find position '" + identifier + "')"));
			return Vector3.zero;
		}
		Vector3 position = positionGenerator.GetPosition(this, playerFor, depth);
		missionPoints.Add(identifier, position);
		if (positionGenerator.positionsAreExclusive)
		{
			AddBlocker(position);
		}
		return position;
	}

	public MissionEntity GetMissionEntity(string identifier, BasePlayer playerFor)
	{
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		if (identifier == null)
		{
			identifier = "";
		}
		if (missionEntities.TryGetValue(identifier, out var value))
		{
			return value;
		}
		MissionEntityEntry missionEntityEntry = List.FindWith<MissionEntityEntry, string>((IReadOnlyCollection<MissionEntityEntry>)(object)GetMission().missionEntities, (Func<MissionEntityEntry, string>)((MissionEntityEntry e) => e.identifier), identifier, (IEqualityComparer<string>)null);
		if (missionEntityEntry == null)
		{
			Debug.LogError((object)$"Cannot spawn mission entity, identifier '{identifier}' not found in mission ID {missionID}");
			value = null;
		}
		else if (!missionEntityEntry.entityRef.isValid)
		{
			Debug.LogError((object)$"Cannot spawn mission entity, identifier '{identifier}' has no entity set in mission ID {missionID}");
			value = null;
		}
		else
		{
			Vector3 missionPoint = GetMissionPoint(missionEntityEntry.spawnPositionToUse, playerFor);
			BaseEntity baseEntity = GameManager.server.CreateEntity(missionEntityEntry.entityRef.resourcePath, missionPoint, Quaternion.identity);
			MissionEntity missionEntity = default(MissionEntity);
			MissionEntity missionEntity2 = (((Component)baseEntity).gameObject.TryGetComponent<MissionEntity>(ref missionEntity) ? missionEntity : ((Component)baseEntity).gameObject.AddComponent<MissionEntity>());
			missionEntity2.Setup(playerFor, this, identifier, missionEntityEntry.cleanupOnMissionSuccess, missionEntityEntry.cleanupOnMissionFailed);
			baseEntity.Spawn();
			if (baseEntity is LootContainer lootContainer && missionEntityEntry.overrideLootOnItem != null && missionEntityEntry.overrideLootOnItem.Length != 0)
			{
				lootContainer.inventory.Clear();
				ItemAmount[] overrideLootOnItem = missionEntityEntry.overrideLootOnItem;
				foreach (ItemAmount itemAmount in overrideLootOnItem)
				{
					lootContainer.inventory.AddItem(itemAmount.itemDef, (int)itemAmount.amount, 0uL);
				}
			}
			value = missionEntity2;
		}
		missionEntities.Add(identifier, value);
		if ((Object)(object)value != (Object)null)
		{
			value.MissionStarted(playerFor, this);
		}
		return value;
	}

	public void PostServerLoad(BasePlayer player)
	{
		BaseMission mission = GetMission();
		for (int i = 0; i < mission.objectives.Length; i++)
		{
			if (i >= 0 && i < objectiveStatuses.Length)
			{
				mission.objectives[i].objective.PostServerLoad(player, objectiveStatuses[i]);
			}
		}
	}

	public int GetTotalRequiredRewardItemSlots()
	{
		BaseMission mission = GetMission();
		int num = 0;
		for (int i = 0; i < mission.objectives.Length; i++)
		{
			if (!mission.objectives[i].isRequired && objectiveStatuses[i].completed)
			{
				num += mission.objectives[i].bonusRewards.Length;
			}
		}
		return mission.GetMissionRewards().Length + num;
	}

	public void Reset()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		providerID = default(NetworkableId);
		missionID = 0u;
		status = MissionStatus.Default;
		startTime = -1f;
		endTime = -1f;
		missionLocation = Vector3.zero;
		_cachedMission = null;
		timePassed = 0f;
		missionPoints.Clear();
		missionEntities.Clear();
	}

	public void EnterPool()
	{
		Reset();
	}

	public void LeavePool()
	{
	}
}


using System;

[Serializable]
public class ObjectiveStatus
{
	public bool started;

	public bool completed;

	public bool failed;

	public float progressTarget;

	public float progressCurrent;

	public RealTimeSince sinceLastThink;
}


public enum ObjectiveType
{
	MOVE,
	KILL
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[Serializable]
public class PositionGenerator
{
	public enum RelativeType
	{
		Player,
		Provider,
		Position
	}

	public enum PositionType
	{
		MissionPoint,
		WorldPositionGenerator,
		DungeonPoint,
		Radius
	}

	public class PositionPointAttribute : PropertyAttribute
	{
	}

	public string identifier;

	public float minDistForMovePoint;

	public float maxDistForMovePoint = 25f;

	public bool allowDoubleDistanceIfNoOptionsAreFound;

	public bool positionsAreExclusive = true;

	public RelativeType relativeTo;

	public PositionType positionType;

	public string centerOnPositionIdentifier = "";

	[InspectorFlags]
	public MissionPoint.MissionPointEnum Flags = (MissionPoint.MissionPointEnum)(-1);

	[InspectorFlags]
	public MissionPoint.MissionPointEnum ExclusionFlags;

	public WorldPositionGenerator worldPositionGenerator;

	public bool IsDependant()
	{
		return !string.IsNullOrEmpty(centerOnPositionIdentifier);
	}

	public bool Validate(BasePlayer assignee, BaseMission missionDef)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position;
		if (positionType == PositionType.MissionPoint)
		{
			List<MissionPoint> points = Pool.Get<List<MissionPoint>>();
			bool missionPoints = MissionPoint.GetMissionPoints(ref points, ((Component)assignee).transform.position, minDistForMovePoint, maxDistForMovePoint, (int)Flags, (int)ExclusionFlags);
			if (!missionPoints && allowDoubleDistanceIfNoOptionsAreFound)
			{
				points.Clear();
				missionPoints = MissionPoint.GetMissionPoints(ref points, ((Component)assignee).transform.position, minDistForMovePoint, maxDistForMovePoint * 2f, (int)Flags, (int)ExclusionFlags);
			}
			Pool.FreeUnmanaged<MissionPoint>(ref points);
			if (!missionPoints)
			{
				return false;
			}
		}
		else if (positionType == PositionType.WorldPositionGenerator && (Object)(object)worldPositionGenerator != (Object)null && !worldPositionGenerator.TrySample(((Component)assignee).transform.position, minDistForMovePoint, maxDistForMovePoint, out position, blockedPoints))
		{
			return false;
		}
		return true;
	}

	public Vector3 GetPosition(MissionInstance instance, BasePlayer assignee, int depth = 0)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		if (depth > 10)
		{
			Debug.LogError((object)$"Exceeded max depth while calculating position! missionID={instance.missionID} identifier={identifier}");
			return ((Component)assignee).transform.position;
		}
		Vector3 relativeToPosition = GetRelativeToPosition(instance, assignee, depth);
		Vector3 result;
		if (positionType == PositionType.MissionPoint)
		{
			List<MissionPoint> points = Pool.Get<List<MissionPoint>>();
			bool missionPoints = MissionPoint.GetMissionPoints(ref points, relativeToPosition, minDistForMovePoint, maxDistForMovePoint, (int)Flags, (int)ExclusionFlags);
			if (!missionPoints && allowDoubleDistanceIfNoOptionsAreFound)
			{
				points.Clear();
				missionPoints = MissionPoint.GetMissionPoints(ref points, relativeToPosition, minDistForMovePoint, maxDistForMovePoint * 2f, (int)Flags, (int)ExclusionFlags);
			}
			if (missionPoints)
			{
				result = points[Random.Range(0, points.Count)].GetPosition();
			}
			else
			{
				Debug.LogError((object)"UNABLE TO FIND MISSIONPOINT FOR MISSION!");
				result = relativeToPosition;
			}
			Pool.FreeUnmanaged<MissionPoint>(ref points);
		}
		else if (positionType == PositionType.WorldPositionGenerator && (Object)(object)worldPositionGenerator != (Object)null)
		{
			int num = 0;
			while (true)
			{
				if (worldPositionGenerator.TrySample(relativeToPosition, minDistForMovePoint, maxDistForMovePoint, out var position, blockedPoints) && TryAlignToGround(position, out var correctedPosition))
				{
					result = correctedPosition;
					break;
				}
				if (num >= 10)
				{
					Debug.LogError((object)"UNABLE TO FIND WORLD POINT FOR MISSION!");
					result = relativeToPosition;
					break;
				}
				num++;
			}
		}
		else if (positionType == PositionType.DungeonPoint)
		{
			result = DynamicDungeon.GetNextDungeonPoint();
		}
		else
		{
			int num2 = 0;
			while (true)
			{
				Vector3 onUnitSphere = Random.onUnitSphere;
				onUnitSphere.y = 0f;
				((Vector3)(ref onUnitSphere)).Normalize();
				Vector3 val = relativeToPosition + onUnitSphere * Random.Range(minDistForMovePoint, maxDistForMovePoint);
				val.y = WaterLevel.GetWaterOrTerrainSurface(val, waves: false, volumes: false);
				if (TryAlignToGround(val, out var correctedPosition2))
				{
					result = correctedPosition2;
					break;
				}
				if (num2 >= 10)
				{
					Debug.LogError((object)"UNABLE TO FIND WORLD POINT FOR MISSION!");
					result = relativeToPosition;
					break;
				}
				num2++;
			}
		}
		return result;
	}

	private Vector3 GetRelativeToPosition(MissionInstance instance, BasePlayer assignee, int depth)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		switch (relativeTo)
		{
		case RelativeType.Position:
			return instance.GetMissionPoint(centerOnPositionIdentifier, assignee, depth + 1);
		case RelativeType.Provider:
		{
			BaseEntity baseEntity = instance.ProviderEntity();
			if ((Object)(object)baseEntity != (Object)null)
			{
				return ((Component)baseEntity).transform.position;
			}
			break;
		}
		}
		if ((Object)(object)assignee != (Object)null)
		{
			return ((Component)assignee).transform.position;
		}
		Debug.LogError((object)$"Cannot get mission point origin - assigne playere is null! missionID={instance.missionID} relativeTo={relativeTo}");
		return Vector3.zero;
	}

	private static bool TryAlignToGround(Vector3 wishPosition, out Vector3 correctedPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3Ex.WithY(wishPosition, wishPosition.y + 50f);
		RaycastHit hit = default(RaycastHit);
		if (!Physics.Raycast(new Ray(val, Vector3.down), ref hit, 50f, 1218652417, (QueryTriggerInteraction)1))
		{
			correctedPosition = wishPosition;
			return true;
		}
		if ((Object)(object)hit.GetEntity() != (Object)null)
		{
			correctedPosition = wishPosition;
			return false;
		}
		correctedPosition = ((RaycastHit)(ref hit)).point;
		return true;
	}
}


public enum RelativeType
{
	Player,
	Provider,
	Position
}


public enum PositionType
{
	MissionPoint,
	WorldPositionGenerator,
	DungeonPoint,
	Radius
}


using UnityEngine;

public class PositionPointAttribute : PropertyAttribute
{
}


using System;
using UnityEngine.Serialization;

[Serializable]
public class MissionEntityEntry
{
	[FormerlySerializedAs("entityIdentifier")]
	public string identifier;

	public GameObjectRef entityRef;

	public string spawnPositionToUse;

	public bool spawnOnMissionStart = true;

	public bool cleanupOnMissionFailed;

	public bool cleanupOnMissionSuccess;

	public ItemAmount[] overrideLootOnItem;
}


using System;
using UnityEngine;

[Serializable]
public struct NonItemReward
{
	public Phrase DisplayPhrase;

	public Sprite DisplaySprite;

	public NonItemRewardType RewardType;
}


public enum NonItemRewardType
{
	None,
	SafeZoneRespawnUnlock
}


using System;
using Rust;

[Serializable]
public class MissionRewards
{
	public ItemAmount[] items;

	public Era[] Eras;
}


public enum MissionFailReason
{
	TimeOut,
	Disconnect,
	ResetPlayerState,
	Abandon,
	ObjectiveFailed
}


public class DebugWorldPosition : ListComponent<DebugWorldPosition>
{
	public WorldPositionGenerator GeneratorToFake;
}


using UnityEngine;

public class MissionEntity : BaseMonoBehaviour, IOnParentDestroying
{
	public string identifier;

	public bool cleanupOnMissionSuccess = true;

	public bool cleanupOnMissionFailed = true;

	public void OnParentDestroying()
	{
		Object.Destroy((Object)(object)this);
	}

	public virtual void Setup(BasePlayer assignee, BaseMission.MissionInstance instance, string identifier, bool wantsSuccessCleanup, bool wantsFailedCleanup)
	{
		this.identifier = identifier;
		cleanupOnMissionFailed = wantsFailedCleanup;
		cleanupOnMissionSuccess = wantsSuccessCleanup;
		BaseEntity entity = GetEntity();
		if (Object.op_Implicit((Object)(object)entity))
		{
			((Component)entity).SendMessage("MissionSetupPlayer", (object)assignee, (SendMessageOptions)1);
		}
	}

	public virtual void MissionStarted(BasePlayer assignee, BaseMission.MissionInstance instance)
	{
		IMissionEntityListener[] componentsInChildren = ((Component)this).GetComponentsInChildren<IMissionEntityListener>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].MissionStarted(assignee, instance);
		}
	}

	public virtual void MissionEnded(BasePlayer assignee, BaseMission.MissionInstance instance)
	{
		IMissionEntityListener[] componentsInChildren = ((Component)this).GetComponentsInChildren<IMissionEntityListener>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].MissionEnded(assignee, instance);
		}
		instance.missionEntities.Remove(identifier);
		if ((cleanupOnMissionSuccess && (instance.status == BaseMission.MissionStatus.Completed || instance.status == BaseMission.MissionStatus.Accomplished)) || (cleanupOnMissionFailed && instance.status == BaseMission.MissionStatus.Failed))
		{
			BaseEntity entity = GetEntity();
			if (Object.op_Implicit((Object)(object)entity))
			{
				entity.Kill();
			}
		}
	}

	public BaseEntity GetEntity()
	{
		return ((Component)this).GetComponent<BaseEntity>();
	}
}


public interface IMissionEntityListener
{
	void MissionStarted(BasePlayer assignee, BaseMission.MissionInstance instance);

	void MissionEnded(BasePlayer assignee, BaseMission.MissionInstance instance);
}


using UnityEngine;

public interface IMissionProvider
{
	NetworkableId ProviderID();

	Vector3 ProviderPosition();

	BaseEntity Entity();
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/MissionManifest")]
public class MissionManifest : ScriptableObject
{
	public ScriptableObjectRef[] missionList;

	public WorldPositionGenerator[] positionGenerators;

	public static MissionManifest instance;

	public static MissionManifest Get()
	{
		if ((Object)(object)instance == (Object)null)
		{
			instance = Resources.Load<MissionManifest>("MissionManifest");
			WorldPositionGenerator[] array = instance.positionGenerators;
			foreach (WorldPositionGenerator worldPositionGenerator in array)
			{
				if ((Object)(object)worldPositionGenerator != (Object)null)
				{
					worldPositionGenerator.PrecalculatePositions();
				}
			}
		}
		return instance;
	}

	public static BaseMission GetFromShortName(string shortname)
	{
		ScriptableObjectRef[] array = Get().missionList;
		for (int i = 0; i < array.Length; i++)
		{
			BaseMission baseMission = array[i].Get() as BaseMission;
			if (baseMission.shortname == shortname)
			{
				return baseMission;
			}
		}
		return null;
	}

	public static BaseMission GetFromID(uint id)
	{
		MissionManifest missionManifest = Get();
		if (missionManifest.missionList == null)
		{
			return null;
		}
		ScriptableObjectRef[] array = missionManifest.missionList;
		for (int i = 0; i < array.Length; i++)
		{
			BaseMission baseMission = array[i].Get() as BaseMission;
			if (baseMission.id == id)
			{
				return baseMission;
			}
		}
		return null;
	}

	public static bool TryGet(uint id, out BaseMission mission)
	{
		mission = GetFromID(id);
		return mission != null;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

public class MissionPoint : MonoBehaviour
{
	public enum MissionPointEnum
	{
		EasyMonument = 1,
		MediumMonument = 2,
		HardMonument = 4,
		Item_Hidespot = 8,
		Underwater = 0x80,
		Tutorial_Bear = 0x100,
		AtmosphereSensor = 0x200,
		SafeZoneMonument = 0x400
	}

	public bool dropToGround = true;

	public const int COUNT = 8;

	public const int EVERYTHING = -1;

	public const int NOTHING = 0;

	public const int EASY_MONUMENT = 1;

	public const int MED_MONUMENT = 2;

	public const int HARD_MONUMENT = 4;

	public const int ITEM_HIDESPOT = 8;

	public const int UNDERWATER = 128;

	public const int TUTORIAL_BEAR = 256;

	public const int ATMOSPHERE_SENSOR = 512;

	public const int SAFE_ZONE_MONUMENT = 1024;

	public const int EASY_MONUMENT_IDX = 0;

	public const int MED_MONUMENT_IDX = 1;

	public const int HARD_MONUMENT_IDX = 2;

	public const int ITEM_HIDESPOT_IDX = 3;

	public const int FOREST_IDX = 4;

	public const int ROADSIDE_IDX = 5;

	public const int BEACH = 6;

	public const int UNDERWATER_IDX = 7;

	public const int TUTORIAL_BEAR_IDX = 8;

	public const int ATMOSPHERE_SENSOR_IDX = 9;

	public const int SAFE_ZONE_MONUMENT_IDX = 10;

	private static Dictionary<int, int> type2index = new Dictionary<int, int>
	{
		{ 1, 0 },
		{ 2, 1 },
		{ 4, 2 },
		{ 8, 3 },
		{ 128, 7 },
		{ 256, 8 },
		{ 512, 9 }
	};

	[InspectorFlags]
	public MissionPointEnum Flags = (MissionPointEnum)(-1);

	public static List<MissionPoint> all = new List<MissionPoint>();

	public static int TypeToIndex(int id)
	{
		return type2index[id];
	}

	public static int IndexToType(int idx)
	{
		return 1 << idx;
	}

	public void Awake()
	{
		all.Add(this);
	}

	private void Start()
	{
		if (dropToGround)
		{
			((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)DropToGround, 0.5f);
		}
	}

	private void DropToGround()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)this))
		{
			if (Application.isLoading)
			{
				((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)DropToGround, 0.5f);
				return;
			}
			_ = ((Component)this).transform.position;
			((Component)this).transform.DropToGround();
		}
	}

	public void OnDisable()
	{
		if (all.Contains(this))
		{
			all.Remove(this);
		}
	}

	public virtual Vector3 GetPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public virtual Quaternion GetRotation()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.rotation;
	}

	public static bool GetMissionPoints(ref List<MissionPoint> points, Vector3 near, float minDistance, float maxDistance, int flags, int exclusionFlags)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		List<MissionPoint> list = Pool.Get<List<MissionPoint>>();
		foreach (MissionPoint item in all)
		{
			if (((uint)item.Flags & (uint)flags) != (uint)flags || (exclusionFlags != 0 && ((uint)item.Flags & (uint)exclusionFlags) != 0))
			{
				continue;
			}
			float num = Vector3.Distance(((Component)item).transform.position, near);
			if (!(num <= maxDistance) || !(num > minDistance))
			{
				continue;
			}
			if (BaseMission.blockedPoints.Count > 0)
			{
				bool flag = false;
				foreach (Vector3 blockedPoint in BaseMission.blockedPoints)
				{
					if (Vector3.Distance(blockedPoint, ((Component)item).transform.position) < 3f)
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					continue;
				}
			}
			list.Add(item);
		}
		if (list.Count == 0)
		{
			return false;
		}
		foreach (MissionPoint item2 in list)
		{
			points.Add(item2);
		}
		Pool.FreeUnmanaged<MissionPoint>(ref list);
		return true;
	}
}


public enum MissionPointEnum
{
	EasyMonument = 1,
	MediumMonument = 2,
	HardMonument = 4,
	Item_Hidespot = 8,
	Underwater = 0x80,
	Tutorial_Bear = 0x100,
	AtmosphereSensor = 0x200,
	SafeZoneMonument = 0x400
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/MoveMission")]
public class MoveMission : BaseMission
{
	public float minDistForMovePoint = 20f;

	public float maxDistForMovePoint = 25f;

	private float minDistFromLocation = 3f;

	public override void MissionStart(MissionInstance instance, BasePlayer assignee)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		Vector3 onUnitSphere = Random.onUnitSphere;
		onUnitSphere.y = 0f;
		((Vector3)(ref onUnitSphere)).Normalize();
		Vector3 val = ((Component)assignee).transform.position + onUnitSphere * Random.Range(minDistForMovePoint, maxDistForMovePoint);
		val.y = WaterLevel.GetWaterOrTerrainSurface(val, waves: false, volumes: false);
		instance.missionLocation = val;
		base.MissionStart(instance, assignee);
	}

	public override Sprite GetIcon(MissionInstance instance)
	{
		if (instance.status != MissionStatus.Accomplished)
		{
			return icon;
		}
		return providerIcon;
	}

	public override void Think(MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3.Distance(instance.missionLocation, ((Component)assignee).transform.position);
		if (instance.status == MissionStatus.Active && num <= minDistFromLocation)
		{
			MissionSuccess(instance, assignee);
			BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(instance.providerID);
			if (Object.op_Implicit((Object)(object)baseNetworkable))
			{
				instance.missionLocation = ((Component)baseNetworkable).transform.position;
			}
		}
		else
		{
			if (instance.status == MissionStatus.Accomplished)
			{
				_ = minDistFromLocation;
			}
			base.Think(instance, assignee, delta);
		}
	}
}


using Rust.UI;
using UnityEngine;

public class MissionUIPanel : MonoBehaviour
{
	public GameObject activeMissionParent;

	public RustText missionTitleText;

	public RustText missionDescText;

	public GameObject rewardsParent;

	public VirtualItemIcon[] rewardIcons;

	public GameObject bonusRewardsParent;

	public VirtualItemIcon[] bonusIcons;

	public Phrase noMissionText;

	public GameObject abandonButton;
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public abstract class MissionObjective : ScriptableObject
{
	public virtual void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
	}

	public virtual void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		instance.objectiveStatuses[index].started = true;
		BaseMission mission = instance.GetMission();
		if (mission != null && mission.objectives[index].requiredEntities != null)
		{
			string[] requiredEntities = mission.objectives[index].requiredEntities;
			foreach (string identifier in requiredEntities)
			{
				instance.GetMissionEntity(identifier, playerFor);
			}
		}
		playerFor.MissionDirty();
	}

	public virtual void ObjectiveCompleted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
	}

	public virtual void ObjectiveFailed(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
	}

	public bool IsStarted(int index, BaseMission.MissionInstance instance)
	{
		if (instance == null || instance.objectiveStatuses.Length <= index)
		{
			return false;
		}
		return instance.objectiveStatuses[index].started;
	}

	public bool CanProgress(int index, BaseMission.MissionInstance instance)
	{
		if (instance.GetMission().objectives[index].onlyProgressIfStarted)
		{
			return IsStarted(index, instance);
		}
		return true;
	}

	public bool ShouldObjectiveStart(int index, BaseMission.MissionInstance instance)
	{
		BaseMission.MissionObjectiveEntry missionObjectiveEntry = instance.GetMission().objectives[index];
		if (missionObjectiveEntry.startAfterPriorObjectives)
		{
			bool result = true;
			for (int i = 0; i < instance.objectiveStatuses.Length; i++)
			{
				if (i != index && !instance.objectiveStatuses[i].completed)
				{
					result = false;
					break;
				}
				if (i == index)
				{
					break;
				}
			}
			return result;
		}
		int[] startAfterCompletedObjectives = missionObjectiveEntry.startAfterCompletedObjectives;
		foreach (int num in startAfterCompletedObjectives)
		{
			if (!instance.objectiveStatuses[num].completed && !instance.objectiveStatuses[num].failed)
			{
				return false;
			}
		}
		return true;
	}

	public bool IsCompleted(int index, BaseMission.MissionInstance instance)
	{
		if (!instance.objectiveStatuses[index].completed)
		{
			return instance.objectiveStatuses[index].failed;
		}
		return true;
	}

	public virtual bool ShouldThink(int index, BaseMission.MissionInstance instance)
	{
		return !IsCompleted(index, instance);
	}

	public void ResetObjective(int index, BaseMission.MissionInstance instance, BasePlayer playerFor)
	{
		if (instance.objectiveStatuses[index].completed || instance.objectiveStatuses[index].failed)
		{
			instance.objectiveStatuses[index].completed = false;
			instance.objectiveStatuses[index].failed = false;
			playerFor.MissionDirty();
		}
	}

	public void CompleteObjective(int index, BaseMission.MissionInstance instance, BasePlayer playerFor)
	{
		if (!instance.objectiveStatuses[index].completed && !instance.objectiveStatuses[index].failed)
		{
			instance.objectiveStatuses[index].completed = true;
			instance.GetMission().OnObjectiveCompleted(index, instance, playerFor);
			playerFor.MissionDirty();
			ObjectiveCompleted(playerFor, index, instance);
		}
	}

	public void FailObjective(int index, BaseMission.MissionInstance instance, BasePlayer playerFor)
	{
		if (!instance.objectiveStatuses[index].completed && !instance.objectiveStatuses[index].failed)
		{
			instance.objectiveStatuses[index].failed = true;
			instance.GetMission().OnObjectiveFailed(index, instance, playerFor);
			playerFor.MissionDirty();
			ObjectiveFailed(playerFor, index, instance);
		}
	}

	public virtual void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
	}

	public virtual void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		if (ShouldObjectiveStart(index, instance) && !IsStarted(index, instance))
		{
			ObjectiveStarted(assignee, index, instance);
		}
	}

	protected bool TryFindNearby<T>(Vector3 origin, Func<T, bool> filter, out T entity, float radius = 20f) where T : BaseEntity
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		List<T> list = Pool.Get<List<T>>();
		Vis.Entities(origin, radius, list, -1, (QueryTriggerInteraction)2);
		int num = -1;
		float num2 = float.PositiveInfinity;
		for (int i = 0; i < list.Count; i++)
		{
			T val = list[i];
			if (filter == null || filter(val))
			{
				float num3 = Vector3.Distance(((Component)val).transform.position, origin);
				if (num3 < num2)
				{
					num = i;
					num2 = num3;
				}
			}
		}
		bool flag = num != -1;
		entity = (flag ? list[num] : null);
		Pool.FreeUnmanaged<T>(ref list);
		return flag;
	}

	public virtual void PostServerLoad(BasePlayer player, BaseMission.MissionInstance.ObjectiveStatus status)
	{
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/AcquireItem")]
public class MissionObjective_AcquireItem : MissionObjective
{
	[ItemSelector]
	public ItemDefinition targetItem;

	public int targetItemAmount;

	public bool allowStackEvents;

	public bool showResourcePings;

	public bool acceptExistingItems;

	[BaseMission.PositionGenerator.PositionPoint]
	public string requireProximityToPosition;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetItemAmount;
		if (showResourcePings)
		{
			forPlayer.EnableResourcePings(targetItem, BasePlayer.PingType.GoTo);
		}
		if (acceptExistingItems)
		{
			int amount = forPlayer.inventory.GetAmount(targetItem);
			if (amount > 0)
			{
				ProcessMissionEvent(forPlayer, instance, index, BaseMission.MissionEventType.ACQUIRE_ITEM, new BaseMission.MissionEventPayload
				{
					IntIdentifier = targetItem.itemid
				}, amount);
			}
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (((type == BaseMission.MissionEventType.ACQUITE_ITEM_STACK && allowStackEvents) || type == BaseMission.MissionEventType.ACQUIRE_ITEM) && !IsCompleted(index, instance) && CanProgress(index, instance) && targetItem.itemid == payload.IntIdentifier)
		{
			instance.objectiveStatuses[index].progressCurrent += (int)amount;
			if (instance.objectiveStatuses[index].progressCurrent >= (float)targetItemAmount)
			{
				CompleteObjective(index, instance, playerFor);
			}
			if (showResourcePings)
			{
				playerFor.DisableResourcePings(targetItem, BasePlayer.PingType.GoTo);
			}
			playerFor.MissionDirty();
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		base.Think(index, instance, assignee, delta);
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Activate Long Use Object")]
public class MissionObjective_ActivateLongUseObject : MissionObjective
{
	public BaseEntity RequiredEntity;

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.LONG_USE_OBJECT)
		{
			BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(payload.NetworkIdentifier);
			if ((Object)(object)baseNetworkable != (Object)null && (Object)(object)RequiredEntity != (Object)null && RequiredEntity.prefabID == baseNetworkable.prefabID)
			{
				CompleteObjective(index, instance, playerFor);
				playerFor.MissionDirty();
			}
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Consume")]
public class MissionObjective_Consume : MissionObjective
{
	public ItemDefinition TargetItem;

	public int RequiredAmount;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = RequiredAmount;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.CONSUME && !IsCompleted(index, instance) && CanProgress(index, instance) && payload.IntIdentifier == TargetItem.itemid)
		{
			instance.objectiveStatuses[index].progressCurrent += 1f;
			if (instance.objectiveStatuses[index].progressCurrent >= instance.objectiveStatuses[index].progressTarget)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionDirty();
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/CookItem")]
public class MissionObjective_CookItem : MissionObjective
{
	[Tooltip("The cooked result that this objective is looking for (eg cooked chicken, not raw)")]
	[ItemSelector]
	public ItemDefinition targetItem;

	public int targetItemAmount;

	public BaseEntityRef[] pingEntitiesOnTutorialIsland;

	public BasePlayer.PingType pingType = BasePlayer.PingType.GoTo;

	public bool checkExistingInventory;

	private bool HasPings
	{
		get
		{
			if (pingEntitiesOnTutorialIsland != null)
			{
				return pingEntitiesOnTutorialIsland.Length != 0;
			}
			return false;
		}
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetItemAmount;
	}

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		base.ObjectiveStarted(playerFor, index, instance);
		if (HasPings)
		{
			TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				List<TutorialBuildTarget> list = Pool.Get<List<TutorialBuildTarget>>();
				BaseEntityRef[] array = pingEntitiesOnTutorialIsland;
				foreach (BaseEntityRef baseEntityRef in array)
				{
					list.Clear();
					currentTutorialIsland.GetBuildTargets(list, baseEntityRef.Get().prefabID);
					if (list.Count > 0)
					{
						List<BaseOven> list2 = Pool.Get<List<BaseOven>>();
						Vis.Entities(((Component)list[0]).transform.position, 0.25f, list2, 153092352, (QueryTriggerInteraction)2);
						if (list2.Count > 0)
						{
							playerFor.RegisterPingedEntity(list2[0], pingType);
						}
						Pool.FreeUnmanaged<BaseOven>(ref list2);
						break;
					}
				}
				Pool.FreeUnmanaged<TutorialBuildTarget>(ref list);
			}
		}
		if (checkExistingInventory)
		{
			int amount = playerFor.inventory.GetAmount(targetItem);
			if (amount > 0)
			{
				ProcessMissionEvent(playerFor, instance, index, BaseMission.MissionEventType.COOK, new BaseMission.MissionEventPayload
				{
					IntIdentifier = targetItem.itemid
				}, amount);
			}
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.COOK || IsCompleted(index, instance) || !CanProgress(index, instance) || targetItem.itemid != payload.IntIdentifier)
		{
			return;
		}
		instance.objectiveStatuses[index].progressCurrent += (int)amount;
		if (instance.objectiveStatuses[index].progressCurrent >= (float)targetItemAmount)
		{
			CompleteObjective(index, instance, playerFor);
			if (HasPings)
			{
				playerFor.DeregisterPingedEntity(payload.NetworkIdentifier, pingType);
			}
		}
		playerFor.MissionDirty();
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Craft")]
public class MissionObjective_Craft : MissionObjective
{
	[ItemSelector]
	public ItemDefinition[] targetItems;

	public int targetItemAmount;

	public bool checkExistingInventory;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetItemAmount;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.CRAFT_ITEM || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		ItemDefinition[] array = targetItems;
		foreach (ItemDefinition itemDefinition in array)
		{
			ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(payload.IntIdentifier);
			bool flag = (Object)(object)itemDefinition2 != (Object)null && (Object)(object)itemDefinition2.isRedirectOf != (Object)null && itemDefinition2.isRedirectOf.itemid == itemDefinition.itemid;
			if (itemDefinition.itemid == payload.IntIdentifier || flag)
			{
				instance.objectiveStatuses[index].progressCurrent += (int)amount;
				if (instance.objectiveStatuses[index].progressCurrent >= (float)targetItemAmount)
				{
					CompleteObjective(index, instance, playerFor);
				}
				playerFor.MissionDirty();
				break;
			}
		}
	}

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		if (checkExistingInventory)
		{
			int num = 0;
			ItemDefinition[] array = targetItems;
			foreach (ItemDefinition definition in array)
			{
				num += playerFor.inventory.GetAmount(definition);
			}
			if (num > 0)
			{
				ProcessMissionEvent(playerFor, instance, index, BaseMission.MissionEventType.CRAFT_ITEM, new BaseMission.MissionEventPayload
				{
					IntIdentifier = targetItems[0].itemid
				}, num);
			}
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Deploy")]
public class MissionObjective_DeployItem : MissionObjective
{
	public BaseEntity[] PossibleOptions = new BaseEntity[0];

	public ItemDefinition[] PossibleItems = new ItemDefinition[0];

	public int RequiredAmount = 1;

	public bool PingTutorialTargets;

	private const BasePlayer.PingType PingType = BasePlayer.PingType.Build;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = RequiredAmount;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		if (IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.DEPLOY && Matches(payload))
		{
			instance.objectiveStatuses[index].progressCurrent += amount;
			if (PingTutorialTargets)
			{
				UpdatePings(playerFor);
			}
			if (instance.objectiveStatuses[index].progressCurrent >= instance.objectiveStatuses[index].progressTarget)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionDirty();
		}
	}

	private bool Matches(BaseMission.MissionEventPayload payload)
	{
		BaseEntity[] possibleOptions = PossibleOptions;
		for (int i = 0; i < possibleOptions.Length; i++)
		{
			if (possibleOptions[i].prefabID == payload.UintIdentifier)
			{
				return true;
			}
		}
		ItemDefinition itemDefinition = null;
		ItemDefinition[] possibleItems = PossibleItems;
		foreach (ItemDefinition itemDefinition2 in possibleItems)
		{
			if (itemDefinition2.itemid == payload.IntIdentifier)
			{
				return true;
			}
			if ((Object)(object)itemDefinition == (Object)null)
			{
				itemDefinition = ItemManager.FindItemDefinition(payload.IntIdentifier);
			}
			if ((Object)(object)itemDefinition != (Object)null && (Object)(object)itemDefinition.isRedirectOf == (Object)(object)itemDefinition2)
			{
				return true;
			}
		}
		return false;
	}

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		if (PingTutorialTargets)
		{
			UpdatePings(playerFor);
		}
	}

	private void UpdatePings(BasePlayer playerFor)
	{
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
		if (!((Object)(object)currentTutorialIsland != (Object)null))
		{
			return;
		}
		List<TutorialBuildTarget> list = Pool.Get<List<TutorialBuildTarget>>();
		BaseEntity[] possibleOptions = PossibleOptions;
		foreach (BaseEntity baseEntity in possibleOptions)
		{
			currentTutorialIsland.GetBuildTargets(list, baseEntity.prefabID);
		}
		foreach (TutorialBuildTarget item in list)
		{
			item.UpdateActive(playerFor);
			if (((Component)item).gameObject.activeSelf)
			{
				playerFor.AddPingAtLocation(BasePlayer.PingType.Build, ((Component)item).transform.position, 86400f, currentTutorialIsland.net.ID);
			}
			else
			{
				playerFor.RemovePingAtLocation(BasePlayer.PingType.Build, ((Component)item).transform.position, 0.5f, currentTutorialIsland.net.ID);
			}
		}
		Pool.FreeUnmanaged<TutorialBuildTarget>(ref list);
	}
}


using UnityEngine;

public class MissionObjective_EnterTrigger : MissionObjective
{
	public string positionName = "default";

	public float distForCompletion = 3f;

	public bool use2D;

	public BaseMountable requiredMountable;

	public bool shouldPing;

	public BasePlayer.PingType pingType = BasePlayer.PingType.GoTo;

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		base.ObjectiveStarted(playerFor, index, instance);
		instance.missionLocation = instance.GetMissionPoint(positionName, playerFor);
		playerFor.MissionDirty();
		if (shouldPing)
		{
			TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				playerFor.AddPingAtLocation(pingType, instance.missionLocation, 86400f, currentTutorialIsland.net.ID);
			}
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (!ShouldThink(index, instance) || type != BaseMission.MissionEventType.ENTER_TRIGGER || ((Object)(object)requiredMountable != (Object)null && (!playerFor.isMounted || playerFor.GetMounted().prefabID != requiredMountable.prefabID)))
		{
			return;
		}
		CompleteObjective(index, instance, playerFor);
		if (shouldPing)
		{
			TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				playerFor.RemovePingAtLocation(pingType, instance.missionLocation, float.MaxValue, currentTutorialIsland.net.ID);
			}
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Equip Clothing")]
public class MissionObjective_EquipClothing : MissionObjective
{
	public ItemDefinition[] RequiredItems = new ItemDefinition[0];

	public bool CheckExistingClothingOnStart = true;

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		if (CheckExistingClothingOnStart)
		{
			ProcessMissionEvent(playerFor, instance, index, BaseMission.MissionEventType.CLOTHINGCHANGED, default(BaseMission.MissionEventPayload), 0f);
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (IsCompleted(index, instance) || !CanProgress(index, instance) || type != BaseMission.MissionEventType.CLOTHINGCHANGED)
		{
			return;
		}
		ItemDefinition[] requiredItems = RequiredItems;
		foreach (ItemDefinition searchFor in requiredItems)
		{
			if (!playerFor.inventory.containerWear.HasItem(searchFor))
			{
				return;
			}
		}
		CompleteObjective(index, instance, playerFor);
		playerFor.MissionDirty();
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Fill Tutorial TC")]
public class MissionObjective_FillTutorialToolCupboard : MissionObjective
{
	public int RequiredUpkeepHours = 24;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = RequiredUpkeepHours;
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		base.Think(index, instance, assignee, delta);
		if (!IsStarted(index, instance))
		{
			return;
		}
		BuildingPrivlidge buildingPrivilege = assignee.GetBuildingPrivilege();
		if (!((Object)(object)buildingPrivilege != (Object)null))
		{
			return;
		}
		int num = Mathf.RoundToInt(buildingPrivilege.GetProtectedMinutes() / 60f);
		if (num != Mathf.RoundToInt(instance.objectiveStatuses[index].progressCurrent))
		{
			instance.objectiveStatuses[index].progressCurrent = num;
			if (num >= RequiredUpkeepHours)
			{
				CompleteObjective(index, instance, assignee);
			}
			assignee.MissionDirty();
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/FreeCrate")]
public class MissionObjective_FreeCrate : MissionObjective
{
	public int targetAmount;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetAmount;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.FREE_CRATE && !IsCompleted(index, instance) && CanProgress(index, instance))
		{
			instance.objectiveStatuses[index].progressCurrent += (int)amount;
			if (instance.objectiveStatuses[index].progressCurrent >= (float)targetAmount)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionDirty();
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		base.Think(index, instance, assignee, delta);
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Harvest")]
public class MissionObjective_Harvest : MissionObjective
{
	[ItemSelector]
	public ItemDefinition[] targetItems;

	public int targetItemAmount;

	public ItemDefinition[] pingResourceDispensers;

	public BasePlayer.PingType pingType = BasePlayer.PingType.GoTo;

	public bool countExisting;

	public override void PostServerLoad(BasePlayer player, BaseMission.MissionInstance.ObjectiveStatus status)
	{
		base.PostServerLoad(player, status);
		if (status.started && !status.completed)
		{
			InitialiseResourcePings(player);
		}
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetItemAmount;
	}

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		InitialiseResourcePings(playerFor);
		if (countExisting && targetItems.Length != 0)
		{
			int num = 0;
			ItemDefinition[] array = targetItems;
			foreach (ItemDefinition definition in array)
			{
				num += playerFor.inventory.GetAmount(definition);
			}
			ProcessMissionEvent(playerFor, instance, index, BaseMission.MissionEventType.HARVEST, new BaseMission.MissionEventPayload
			{
				IntIdentifier = targetItems[0].itemid
			}, num);
		}
	}

	private void InitialiseResourcePings(BasePlayer forPlayer)
	{
		if (pingResourceDispensers != null)
		{
			ItemDefinition[] array = pingResourceDispensers;
			foreach (ItemDefinition forItem in array)
			{
				forPlayer.EnableResourcePings(forItem, pingType);
			}
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.HARVEST || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		ItemDefinition[] array = targetItems;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].itemid == payload.IntIdentifier)
			{
				instance.objectiveStatuses[index].progressCurrent += (int)amount;
				if (instance.objectiveStatuses[index].progressCurrent >= (float)targetItemAmount)
				{
					CompleteObjective(index, instance, playerFor);
				}
				playerFor.MissionDirty();
				break;
			}
		}
	}

	public override void ObjectiveCompleted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveCompleted(playerFor, index, instance);
		if (pingResourceDispensers != null)
		{
			ItemDefinition[] array = pingResourceDispensers;
			foreach (ItemDefinition forItem in array)
			{
				playerFor.DisableResourcePings(forItem, pingType);
			}
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/HaveItem")]
public class MissionObjective_HaveItem : MissionObjective
{
	[ItemSelector]
	public ItemDefinition targetItem;

	public int targetItemAmount;

	public bool canBeReset = true;

	public BaseEntityRef[] pingEntitiesOnTutorialIsland;

	public BasePlayer.PingType pingType = BasePlayer.PingType.GoTo;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetItemAmount;
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		base.Think(index, instance, assignee, delta);
		if (!IsStarted(index, instance) || (Object)(object)targetItem == (Object)null)
		{
			return;
		}
		int amount = assignee.inventory.GetAmount(targetItem.itemid);
		bool completed = instance.objectiveStatuses[index].completed;
		bool flag = amount >= targetItemAmount;
		if (!canBeReset && completed)
		{
			return;
		}
		if (completed != flag)
		{
			if (flag)
			{
				CompleteObjective(index, instance, assignee);
			}
			else
			{
				ResetObjective(index, instance, assignee);
			}
		}
		if (amount != (int)instance.objectiveStatuses[index].progressCurrent)
		{
			instance.objectiveStatuses[index].progressCurrent = amount;
			assignee.MissionDirty();
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Heal")]
public class MissionObjective_Heal : MissionObjective
{
	[Range(0f, 1f)]
	public float RequiredHealthNormalised = 0.5f;

	public BaseEntityRef RequireHealSource;

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (!IsCompleted(index, instance) && CanProgress(index, instance) && type == BaseMission.MissionEventType.HEAL && (RequireHealSource == null || RequireHealSource.Get().prefabID == payload.UintIdentifier) && playerFor.healthFraction >= RequiredHealthNormalised)
		{
			CompleteObjective(index, instance, playerFor);
			playerFor.MissionDirty();
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Extend;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/HurtEntityType")]
public class MissionObjective_HurtEntityType : MissionObjective
{
	public BaseEntityRef[] targetEntities;

	public float targetDamage = 1f;

	public bool shouldUpdateMissionLocation = true;

	private bool isInitalized;

	private uint[] targetPrefabIDs;

	private Func<BaseCombatEntity, bool> searchFilter;

	private void EnsureInitialized()
	{
		if (!isInitalized)
		{
			isInitalized = true;
			targetPrefabIDs = (from e in targetEntities
				where e.isValid
				select e.Get().prefabID).ToArray();
		}
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetDamage;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.HURT_ENTITY || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		EnsureInitialized();
		EntityRef<BaseCombatEntity> entityRef = default(EntityRef<BaseCombatEntity>);
		entityRef.uid = payload.NetworkIdentifier;
		EntityRef<BaseCombatEntity> entityRef2 = entityRef;
		BaseCombatEntity baseCombatEntity = entityRef2.Get(serverside: true);
		if (!baseCombatEntity.IsValid())
		{
			return;
		}
		uint[] array = targetPrefabIDs;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] == baseCombatEntity.prefabID)
			{
				instance.objectiveStatuses[index].progressCurrent += amount;
				if (instance.objectiveStatuses[index].progressCurrent >= targetDamage)
				{
					CompleteObjective(index, instance, playerFor);
				}
				playerFor.MissionDirty();
				break;
			}
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		base.Think(index, instance, assignee, delta);
		if (!shouldUpdateMissionLocation || !IsStarted(index, instance))
		{
			return;
		}
		ref RealTimeSince sinceLastThink = ref instance.objectiveStatuses[index].sinceLastThink;
		if (RealTimeSince.op_Implicit(sinceLastThink) < 1f)
		{
			return;
		}
		sinceLastThink = RealTimeSince.op_Implicit(0f);
		if (searchFilter == null)
		{
			searchFilter = (BaseCombatEntity e) => List.TryFindWith<uint, uint>((IReadOnlyCollection<uint>)(object)targetPrefabIDs, (Func<uint, uint>)((uint id) => id), e.prefabID, (IEqualityComparer<uint>)null).HasValue && e.IsAlive();
		}
		if (TryFindNearby(((Component)assignee).transform.position, searchFilter, out var entity))
		{
			instance.missionLocation = ((Component)entity).transform.position;
			assignee.MissionDirty();
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/HurtMissionEntity")]
public class MissionObjective_HurtMissionEntity : MissionObjective
{
	public string targetIdentifier;

	public float targetDamage = 1f;

	public bool shouldUpdateMissionLocation = true;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetDamage;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.HURT_ENTITY || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		MissionEntity missionEntity = instance.GetMissionEntity(targetIdentifier, playerFor);
		if ((Object)(object)missionEntity == (Object)null)
		{
			FailObjective(index, instance, playerFor);
			return;
		}
		BaseEntity entity = missionEntity.GetEntity();
		if (!entity.IsValid())
		{
			FailObjective(index, instance, playerFor);
			return;
		}
		EntityRef<BaseCombatEntity> entityRef = default(EntityRef<BaseCombatEntity>);
		entityRef.uid = payload.NetworkIdentifier;
		EntityRef<BaseCombatEntity> entityRef2 = entityRef;
		BaseCombatEntity baseCombatEntity = entityRef2.Get(serverside: true);
		if (baseCombatEntity.IsValid() && baseCombatEntity.EqualNetID((BaseNetworkable)entity))
		{
			instance.objectiveStatuses[index].progressCurrent += amount;
			if (instance.objectiveStatuses[index].progressCurrent >= targetDamage)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionDirty();
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		base.Think(index, instance, assignee, delta);
		if (!IsStarted(index, instance) || IsCompleted(index, instance))
		{
			return;
		}
		ref RealTimeSince sinceLastThink = ref instance.objectiveStatuses[index].sinceLastThink;
		if (RealTimeSince.op_Implicit(sinceLastThink) < 1f)
		{
			return;
		}
		sinceLastThink = RealTimeSince.op_Implicit(0f);
		MissionEntity missionEntity = instance.GetMissionEntity(targetIdentifier, assignee);
		if ((Object)(object)missionEntity == (Object)null)
		{
			FailObjective(index, instance, assignee);
		}
		else if (shouldUpdateMissionLocation)
		{
			Vector3 position = ((Component)missionEntity).transform.position;
			if (position != instance.missionLocation)
			{
				instance.missionLocation = position;
				assignee.MissionDirty();
			}
		}
	}
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Ignite Oven")]
public class MissionObjective_IgniteOven : MissionObjective
{
	public BaseEntityRef TargetOven;

	public bool PingTarget;

	public BasePlayer.PingType PingType = BasePlayer.PingType.GoTo;

	private Func<BaseCombatEntity, bool> searchFilter;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		base.MissionStarted(index, instance, forPlayer);
		if (searchFilter == null)
		{
			searchFilter = (BaseCombatEntity e) => e.IsAlive() && e.prefabID == TargetOven.resourceID;
		}
		if (PingTarget && TryFindNearby(((Component)forPlayer).transform.position, searchFilter, out var entity, 200f))
		{
			instance.missionLocation = ((Component)entity).transform.position;
			forPlayer.RegisterPingedEntity(entity, PingType);
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.STARTOVEN || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		if (TargetOven.resourceID == payload.UintIdentifier)
		{
			CompleteObjective(index, instance, playerFor);
			if (PingTarget)
			{
				playerFor.DeregisterPingedEntity(payload.NetworkIdentifier, PingType);
			}
		}
		playerFor.MissionDirty();
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Extend;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Kill")]
public class MissionObjective_KillEntity : MissionObjective
{
	public BaseEntityRef[] targetEntities;

	public int numToKill;

	public bool shouldUpdateMissionLocation;

	public bool pingTargets;

	private bool isInitalized;

	private uint[] targetPrefabIDs;

	private Func<BaseCombatEntity, bool> searchFilter;

	private void EnsureInitialized()
	{
		if (!isInitalized)
		{
			isInitalized = true;
			targetPrefabIDs = (from e in targetEntities
				where e.isValid
				select e.Get().prefabID).ToArray();
		}
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = numToKill;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.KILL_ENTITY || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		EnsureInitialized();
		uint[] array = targetPrefabIDs;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] == payload.UintIdentifier)
			{
				instance.objectiveStatuses[index].progressCurrent += (int)amount;
				if (instance.objectiveStatuses[index].progressCurrent >= (float)numToKill)
				{
					CompleteObjective(index, instance, playerFor);
				}
				playerFor.DeregisterPingedEntitiesOfType(BasePlayer.PingType.Hostile);
				playerFor.MissionDirty();
				break;
			}
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		base.Think(index, instance, assignee, delta);
		if (!shouldUpdateMissionLocation || !IsStarted(index, instance))
		{
			return;
		}
		ref RealTimeSince sinceLastThink = ref instance.objectiveStatuses[index].sinceLastThink;
		if (RealTimeSince.op_Implicit(sinceLastThink) < 1f)
		{
			return;
		}
		EnsureInitialized();
		sinceLastThink = RealTimeSince.op_Implicit(0f);
		if (searchFilter == null)
		{
			searchFilter = (BaseCombatEntity e) => List.TryFindWith<uint, uint>((IReadOnlyCollection<uint>)(object)targetPrefabIDs, (Func<uint, uint>)((uint id) => id), e.prefabID, (IEqualityComparer<uint>)null).HasValue && e.IsAlive();
		}
		if (IsCompleted(index, instance))
		{
			return;
		}
		assignee.DeregisterPingedEntitiesOfType(BasePlayer.PingType.Hostile);
		if (TryFindNearby(((Component)assignee).transform.position, searchFilter, out var entity, pingTargets ? 200f : 20f))
		{
			instance.missionLocation = ((Component)entity).transform.position;
			assignee.MissionDirty();
			if (pingTargets)
			{
				assignee.RegisterPingedEntity(entity, BasePlayer.PingType.Hostile);
			}
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Metal Detector")]
public class MissionObjective_MetalDetectorFind : MissionObjective
{
	public int RequiredFinds = 3;

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = RequiredFinds;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.METAL_DETECTOR_FIND && !IsCompleted(index, instance) && CanProgress(index, instance))
		{
			instance.objectiveStatuses[index].progressCurrent += 1f;
			if (instance.objectiveStatuses[index].progressCurrent >= instance.objectiveStatuses[index].progressTarget)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionDirty();
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Extend;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/MountEntityType")]
public class MissionObjective_MountEntityType : MissionObjective
{
	public BaseEntityRef[] targetEntities;

	public int numToMount = 1;

	public bool shouldUpdateMissionLocation = true;

	private bool isInitalized;

	private uint[] targetPrefabIDs;

	private Func<BaseEntity, bool> searchFilter;

	private void EnsureInitialized()
	{
		if (!isInitalized)
		{
			isInitalized = true;
			targetPrefabIDs = (from e in targetEntities
				where e.isValid
				select e.Get().prefabID).ToArray();
		}
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		if (numToMount > 1)
		{
			instance.objectiveStatuses[index].progressTarget = numToMount;
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.MOUNT_ENTITY || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		EnsureInitialized();
		EntityRef<BaseMountable> entityRef = default(EntityRef<BaseMountable>);
		entityRef.uid = payload.NetworkIdentifier;
		EntityRef<BaseMountable> entityRef2 = entityRef;
		BaseMountable baseMountable = entityRef2.Get(serverside: true);
		if (!baseMountable.IsValid())
		{
			return;
		}
		uint[] array = targetPrefabIDs;
		foreach (uint num in array)
		{
			BaseVehicle baseVehicle = baseMountable.VehicleParent();
			if (num == baseMountable.prefabID || (!((Object)(object)baseVehicle == (Object)null) && num == baseVehicle.prefabID))
			{
				instance.objectiveStatuses[index].progressCurrent += (int)amount;
				if (instance.objectiveStatuses[index].progressCurrent >= (float)numToMount)
				{
					CompleteObjective(index, instance, playerFor);
				}
				playerFor.MissionDirty();
				break;
			}
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		base.Think(index, instance, assignee, delta);
		if (!shouldUpdateMissionLocation || !IsStarted(index, instance))
		{
			return;
		}
		ref RealTimeSince sinceLastThink = ref instance.objectiveStatuses[index].sinceLastThink;
		if (RealTimeSince.op_Implicit(sinceLastThink) < 1f)
		{
			return;
		}
		sinceLastThink = RealTimeSince.op_Implicit(0f);
		if (searchFilter == null)
		{
			searchFilter = (BaseEntity e) => List.TryFindWith<uint, uint>((IReadOnlyCollection<uint>)(object)targetPrefabIDs, (Func<uint, uint>)((uint id) => id), e.prefabID, (IEqualityComparer<uint>)null).HasValue;
		}
		if (TryFindNearby(((Component)assignee).transform.position, searchFilter, out var entity))
		{
			instance.missionLocation = ((Component)entity).transform.position;
			assignee.MissionDirty();
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/MountMissionEntity")]
public class MissionObjective_MountMissionEntity : MissionObjective
{
	public string targetIdentifier;

	public bool shouldUpdateMissionLocation = true;

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		instance.GetMissionEntity(targetIdentifier, playerFor);
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.MOUNT_ENTITY || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		MissionEntity missionEntity = instance.GetMissionEntity(targetIdentifier, playerFor);
		if ((Object)(object)missionEntity == (Object)null)
		{
			FailObjective(index, instance, playerFor);
			return;
		}
		BaseEntity entity = missionEntity.GetEntity();
		if (!entity.IsValid())
		{
			FailObjective(index, instance, playerFor);
			return;
		}
		EntityRef<BaseMountable> entityRef = default(EntityRef<BaseMountable>);
		entityRef.uid = payload.NetworkIdentifier;
		EntityRef<BaseMountable> entityRef2 = entityRef;
		BaseMountable baseMountable = entityRef2.Get(serverside: true);
		if (baseMountable.IsValid())
		{
			BaseVehicle baseVehicle = baseMountable.VehicleParent();
			if (baseMountable.EqualNetID((BaseNetworkable)entity) || ((Object)(object)baseVehicle != (Object)null && baseVehicle.EqualNetID((BaseNetworkable)entity)))
			{
				CompleteObjective(index, instance, playerFor);
			}
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		base.Think(index, instance, assignee, delta);
		if (!IsStarted(index, instance) || IsCompleted(index, instance))
		{
			return;
		}
		ref RealTimeSince sinceLastThink = ref instance.objectiveStatuses[index].sinceLastThink;
		if (RealTimeSince.op_Implicit(sinceLastThink) < 1f)
		{
			return;
		}
		sinceLastThink = RealTimeSince.op_Implicit(0f);
		MissionEntity missionEntity = instance.GetMissionEntity(targetIdentifier, assignee);
		if ((Object)(object)missionEntity == (Object)null)
		{
			FailObjective(index, instance, assignee);
		}
		else if (shouldUpdateMissionLocation)
		{
			Vector3 position = ((Component)missionEntity).transform.position;
			if (position != instance.missionLocation)
			{
				instance.missionLocation = position;
				assignee.MissionDirty();
			}
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Move")]
public class MissionObjective_Move : MissionObjective
{
	[BaseMission.PositionGenerator.PositionPoint]
	public string positionName = "default";

	public float distForCompletion = 3f;

	public bool use2D;

	public BaseMountable requiredMountable;

	public bool shouldPing;

	public BasePlayer.PingType pingType = BasePlayer.PingType.GoTo;

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		base.ObjectiveStarted(playerFor, index, instance);
		instance.missionLocation = instance.GetMissionPoint(positionName, playerFor);
		playerFor.MissionDirty();
		if (shouldPing)
		{
			TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				playerFor.AddPingAtLocation(pingType, instance.missionLocation, 86400f, currentTutorialIsland.net.ID);
			}
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		base.Think(index, instance, assignee, delta);
		if (!ShouldThink(index, instance) || ((Object)(object)requiredMountable != (Object)null && (!assignee.isMounted || assignee.GetMounted().prefabID != requiredMountable.prefabID)))
		{
			return;
		}
		Vector3 missionPoint = instance.GetMissionPoint(positionName, assignee);
		if (!((use2D ? Vector3Ex.Distance2D(missionPoint, ((Component)assignee).transform.position) : Vector3.Distance(missionPoint, ((Component)assignee).transform.position)) <= distForCompletion))
		{
			return;
		}
		CompleteObjective(index, instance, assignee);
		if (shouldPing)
		{
			TutorialIsland currentTutorialIsland = assignee.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				assignee.RemovePingAtLocation(pingType, instance.missionLocation, float.MaxValue, currentTutorialIsland.net.ID);
			}
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Open Tutorial Storage")]
public class MissionObjective_OpenTutorialStorageContainer : MissionObjective
{
	public ItemAmount[] Items;

	public BaseEntity TargetEntity;

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
		if ((Object)(object)currentTutorialIsland != (Object)null && (Object)(object)currentTutorialIsland.TutorialContainer != (Object)null)
		{
			currentTutorialIsland.TutorialContainer.LoadStorage(Items);
		}
		playerFor.RegisterPingedEntity(currentTutorialIsland.TutorialContainer, BasePlayer.PingType.Loot);
	}

	public override void ObjectiveCompleted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveCompleted(playerFor, index, instance);
		DeregisterPing(playerFor);
	}

	private void DeregisterPing(BasePlayer playerFor)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
		if ((Object)(object)currentTutorialIsland != (Object)null && (Object)(object)currentTutorialIsland.TutorialContainer != (Object)null)
		{
			playerFor.DeregisterPingedEntity(currentTutorialIsland.TutorialContainer.net.ID, BasePlayer.PingType.Loot);
		}
	}

	public override void ObjectiveFailed(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveFailed(playerFor, index, instance);
		DeregisterPing(playerFor);
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.OPEN_STORAGE && !IsCompleted(index, instance) && CanProgress(index, instance) && payload.UintIdentifier == TargetEntity.prefabID)
		{
			CompleteObjective(index, instance, playerFor);
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/PlayerInput")]
public class MissionObjective_PlayerInput : MissionObjective
{
	public BUTTON requiredButton;

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		instance.EnablePlayerInput();
	}

	public override void ObjectiveCompleted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveCompleted(playerFor, index, instance);
		instance.DisablePlayerInput();
	}

	public override void ObjectiveFailed(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveFailed(playerFor, index, instance);
		instance.DisablePlayerInput();
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.PLAYER_TICK && !IsCompleted(index, instance) && CanProgress(index, instance) && playerFor.serverInput.IsDown(requiredButton))
		{
			CompleteObjective(index, instance, playerFor);
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Respawn")]
public class MissionObjective_Respawn : MissionObjective
{
	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.RESPAWN && !IsCompleted(index, instance) && CanProgress(index, instance))
		{
			CompleteObjective(index, instance, playerFor);
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Retrieve Items from corpse")]
public class MissionObjective_RetrieveItemsFromCorpse : MissionObjective
{
	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		base.ObjectiveStarted(playerFor, index, instance);
		if (playerFor.ServerCurrentDeathNote == null)
		{
			return;
		}
		List<PlayerCorpse> list = Pool.Get<List<PlayerCorpse>>();
		Vis.Entities(playerFor.ServerCurrentDeathNote.worldPosition, 3f, list, 512, (QueryTriggerInteraction)2);
		foreach (PlayerCorpse item in list)
		{
			if ((Object)(object)item != (Object)null && item.isServer)
			{
				playerFor.RegisterPingedEntity(item, BasePlayer.PingType.Loot);
				break;
			}
		}
		Pool.FreeUnmanaged<PlayerCorpse>(ref list);
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.OPEN_STORAGE || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(payload.NetworkIdentifier);
		if ((Object)(object)baseNetworkable != (Object)null)
		{
			bool flag = baseNetworkable is PlayerCorpse playerCorpse && playerCorpse.playerSteamID == (ulong)playerFor.userID;
			if (!flag && baseNetworkable is DroppedItemContainer droppedItemContainer && droppedItemContainer.playerSteamID == (ulong)playerFor.userID)
			{
				flag = true;
			}
			if (flag)
			{
				playerFor.DeregisterPingedEntity(payload.NetworkIdentifier, BasePlayer.PingType.Loot);
				CompleteObjective(index, instance, playerFor);
			}
		}
	}
}


using ConVar;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/SpeakWith")]
public class MissionObjective_SpeakWith : MissionObjective
{
	public ItemAmount[] requiredReturnItems = new ItemAmount[0];

	public bool destroyReturnItems;

	public bool showPing;

	public bool checkSpaceForRewards;

	public static Phrase NoSpaceInInventoryPhrase = new Phrase("no_space_mission_reward", "No space for rewards in inventory, please clear some space");

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = instance.ProviderEntity();
		if (Object.op_Implicit((Object)(object)baseEntity) && !showPing)
		{
			instance.missionLocation = ((Component)baseEntity).transform.position;
			playerFor.MissionDirty();
		}
		base.ObjectiveStarted(playerFor, index, instance);
		if ((Object)(object)baseEntity != (Object)null && showPing)
		{
			playerFor.RegisterPingedEntity(baseEntity, BasePlayer.PingType.GoTo);
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.CONVERSATION)
		{
			return;
		}
		if (Debugging.printMissionSpeakInfo)
		{
			Debug.Log((object)$"Speak info: IsCompleted:{IsCompleted(index, instance)} CanProgress:{CanProgress(index, instance)}");
		}
		if (IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		BaseEntity baseEntity = instance.ProviderEntity();
		if (Debugging.printMissionSpeakInfo)
		{
			Debug.Log((object)$"Looking for Provider: {instance.providerID.Value}/{baseEntity} Supplied NPC:{payload.NetworkIdentifier}");
		}
		if (!Object.op_Implicit((Object)(object)baseEntity))
		{
			return;
		}
		IMissionProvider component = ((Component)baseEntity).GetComponent<IMissionProvider>();
		if (component == null || !(component.ProviderID() == payload.NetworkIdentifier) || amount != 1f)
		{
			return;
		}
		bool flag = true;
		if (component.ProviderID() == payload.NetworkIdentifier && amount == 1f)
		{
			ItemAmount[] array = requiredReturnItems;
			foreach (ItemAmount itemAmount in array)
			{
				if ((float)playerFor.inventory.GetAmount(itemAmount.itemDef.itemid) < itemAmount.amount)
				{
					flag = false;
					break;
				}
			}
			if (flag && destroyReturnItems)
			{
				if (!CheckRewardsSpace())
				{
					return;
				}
				array = requiredReturnItems;
				foreach (ItemAmount itemAmount2 in array)
				{
					playerFor.inventory.Take(null, itemAmount2.itemDef.itemid, (int)itemAmount2.amount);
				}
			}
		}
		if (CheckRewardsSpace() && (requiredReturnItems == null || requiredReturnItems.Length == 0 || flag))
		{
			CompleteObjective(index, instance, playerFor);
		}
		bool CheckRewardsSpace()
		{
			if (checkSpaceForRewards && !playerFor.inventory.HasEmptySlots(instance.GetTotalRequiredRewardItemSlots()))
			{
				playerFor.ShowToast(GameTip.Styles.Red_Normal, NoSpaceInInventoryPhrase, false);
				return false;
			}
			return true;
		}
	}

	public override void ObjectiveCompleted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveCompleted(playerFor, index, instance);
		if (showPing)
		{
			DeregisterPing(playerFor, instance);
		}
	}

	private static void DeregisterPing(BasePlayer playerFor, BaseMission.MissionInstance instance)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = instance.ProviderEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			playerFor.DeregisterPingedEntity(baseEntity.net.ID, BasePlayer.PingType.GoTo);
		}
	}

	public override void ObjectiveFailed(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveFailed(playerFor, index, instance);
		if (showPing)
		{
			DeregisterPing(playerFor, instance);
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Upgrade Building Block")]
public class MissionObjective_UpgradeBuildingBlock : MissionObjective
{
	public bool ShouldPingBlocksLessThanTargetGrade;

	public BasePlayer.PingType PingType;

	public BuildingGrade.Enum TargetGrade;

	public int RequiredCount = 6;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = RequiredCount;
		if (!ShouldPingBlocksLessThanTargetGrade)
		{
			return;
		}
		TutorialIsland currentTutorialIsland = forPlayer.GetCurrentTutorialIsland();
		if (!((Object)(object)currentTutorialIsland != (Object)null))
		{
			return;
		}
		Vector3 worldPosOfBuildTarget = currentTutorialIsland.GetWorldPosOfBuildTarget(0);
		List<BuildingBlock> list = Pool.Get<List<BuildingBlock>>();
		Vis.Entities(worldPosOfBuildTarget, 32f, list, 2097152, (QueryTriggerInteraction)2);
		if (list.Count != RequiredCount)
		{
			Debug.LogWarning((object)("Non matching building block count, check RequiredCount on " + ((Object)this).name));
		}
		foreach (BuildingBlock item in list)
		{
			forPlayer.RegisterPingedEntity(item, PingType);
		}
		Pool.FreeUnmanaged<BuildingBlock>(ref list);
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.UPGRADE_BUILDING_GRADE && !IsCompleted(index, instance) && CanProgress(index, instance) && payload.IntIdentifier >= (int)TargetGrade)
		{
			instance.objectiveStatuses[index].progressCurrent += 1f;
			if (instance.objectiveStatuses[index].progressCurrent >= (float)RequiredCount)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionDirty();
			if (ShouldPingBlocksLessThanTargetGrade)
			{
				playerFor.DeregisterPingedEntity(payload.NetworkIdentifier, PingType);
			}
		}
	}
}


using UnityEngine;

public class PVPMissionManager : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}


using System;
using UnityEngine;

public class TriggerMission : TriggerBase
{
	private BasePlayer cachedPlayer;

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if ((Object)(object)ent.ToPlayer() != (Object)null)
		{
			cachedPlayer = ent.ToPlayer();
			((FacepunchBehaviour)this).Invoke((Action)DelayedEntityCallback, 0f);
		}
	}

	private void DelayedEntityCallback()
	{
		if ((Object)(object)cachedPlayer != (Object)null)
		{
			cachedPlayer.ProcessMissionEvent(BaseMission.MissionEventType.ENTER_TRIGGER, 0, 0f);
		}
		cachedPlayer = null;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/WorldPositionGenerator")]
public class WorldPositionGenerator : ScriptableObject
{
	public SpawnFilter Filter = new SpawnFilter();

	public float FilterCutoff;

	public bool aboveWater;

	public float MaxSlopeRadius;

	public float MaxSlopeDegrees = 90f;

	public float CheckSphereRadius;

	public LayerMask CheckSphereMask;

	private Vector3 _origin;

	private Vector3 _area;

	private ByteQuadtree _quadtree;

	public bool TrySample(Vector3 origin, float minDist, float maxDist, out Vector3 position, List<Vector3> blocked = null)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		if (_quadtree == null)
		{
			PrecalculatePositions();
		}
		Rect inclusion = new Rect(origin.x - maxDist, origin.z - maxDist, maxDist * 2f, maxDist * 2f);
		Rect exclusion = new Rect(origin.x - minDist, origin.z - minDist, minDist * 2f, minDist * 2f);
		List<Rect> blockedRects = Pool.Get<List<Rect>>();
		if (blocked != null)
		{
			float num = 10f;
			Rect item = default(Rect);
			foreach (Vector3 item2 in blocked)
			{
				((Rect)(ref item))..ctor(item2.x - num, item2.z - num, num * 2f, num * 2f);
				blockedRects.Add(item);
			}
		}
		List<ByteQuadtree.Element> candidates = Pool.Get<List<ByteQuadtree.Element>>();
		candidates.Add(_quadtree.Root);
		for (int i = 0; i < candidates.Count; i++)
		{
			ByteQuadtree.Element element2 = candidates[i];
			if (!element2.IsLeaf)
			{
				ListEx.RemoveUnordered<ByteQuadtree.Element>(candidates, i--);
				EvaluateCandidate(element2.Child1);
				EvaluateCandidate(element2.Child2);
				EvaluateCandidate(element2.Child3);
				EvaluateCandidate(element2.Child4);
			}
		}
		if (candidates.Count == 0)
		{
			position = origin;
			Pool.FreeUnmanaged<ByteQuadtree.Element>(ref candidates);
			Pool.FreeUnmanaged<Rect>(ref blockedRects);
			return false;
		}
		Vector3 val2;
		if (CheckSphereRadius <= float.Epsilon)
		{
			ByteQuadtree.Element random = ListEx.GetRandom<ByteQuadtree.Element>(candidates);
			Rect val = GetElementRect(random);
			val2 = Vector3Ex.XZ3D(((Rect)(ref val)).min + ((Rect)(ref val)).size * new Vector2(Random.value, Random.value));
		}
		else
		{
			Vector3 val4;
			while (true)
			{
				if (candidates.Count == 0)
				{
					position = Vector3.zero;
					return false;
				}
				int index = Random.Range(0, candidates.Count);
				ByteQuadtree.Element element3 = candidates[index];
				Rect val3 = GetElementRect(element3);
				val4 = Vector3Ex.XZ3D(((Rect)(ref val3)).center);
				val4.y = TerrainMeta.HeightMap.GetHeight(val4);
				if (!Physics.CheckSphere(val4, CheckSphereRadius, ((LayerMask)(ref CheckSphereMask)).value))
				{
					break;
				}
				candidates.RemoveAt(index);
			}
			val2 = val4;
		}
		position = Vector3Ex.WithY(val2, aboveWater ? WaterLevel.GetWaterOrTerrainSurface(val2, waves: false, volumes: false) : TerrainMeta.HeightMap.GetHeight(val2));
		Pool.FreeUnmanaged<ByteQuadtree.Element>(ref candidates);
		Pool.FreeUnmanaged<Rect>(ref blockedRects);
		return true;
		void EvaluateCandidate(ByteQuadtree.Element child)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			if (child.Value != 0)
			{
				Rect val5 = GetElementRect(child);
				if (((Rect)(ref val5)).Overlaps(inclusion) && (!((Rect)(ref exclusion)).Contains(((Rect)(ref val5)).min) || !((Rect)(ref exclusion)).Contains(((Rect)(ref val5)).max)))
				{
					if (blockedRects.Count > 0)
					{
						foreach (Rect item3 in blockedRects)
						{
							Rect current2 = item3;
							if (((Rect)(ref current2)).Contains(((Rect)(ref val5)).min) && ((Rect)(ref current2)).Contains(((Rect)(ref val5)).max))
							{
								return;
							}
						}
					}
					candidates.Add(child);
				}
			}
		}
		Rect GetElementRect(ByteQuadtree.Element element)
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			int num2 = 1 << element.Depth;
			float num3 = 1f / (float)num2;
			Vector2 val6 = element.Coords * num3;
			return new Rect(_origin.x + val6.x * _area.x, _origin.z + val6.y * _area.z, _area.x * num3, _area.z * num3);
		}
	}

	public void PrecalculatePositions()
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		int res = Mathf.NextPowerOfTwo((int)((float)World.Size * 0.25f));
		byte[] map = new byte[res * res];
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			for (int i = 0; i < res; i++)
			{
				float normX = ((float)i + 0.5f) / (float)res;
				float normZ = ((float)z + 0.5f) / (float)res;
				float factor = Filter.GetFactor(normX, normZ);
				if (factor > 0f && MaxSlopeRadius > 0f)
				{
					TerrainMeta.HeightMap.ForEach(normX, normZ, MaxSlopeRadius / (float)res, delegate(int slopeX, int slopeZ)
					{
						if (TerrainMeta.HeightMap.GetSlope(slopeX, slopeZ) > MaxSlopeDegrees)
						{
							factor = 0f;
						}
					});
				}
				map[z * res + i] = (byte)((factor >= FilterCutoff) ? (255f * factor) : 0f);
			}
		});
		_origin = TerrainMeta.Position;
		_area = TerrainMeta.Size;
		_quadtree = new ByteQuadtree();
		_quadtree.UpdateValues(map);
	}
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public class CargoShipContainer : BaseEntity
{
	public GameObject[] DressingVariants;

	public const Flags Descending = Flags.Reserved1;

	public const Flags Targeted = Flags.Reserved2;

	private int dressingVariant;

	public override float MaxVelocity()
	{
		return 1f;
	}

	public override void PreInitShared()
	{
		base.PreInitShared();
		AssignVariant();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		UpdateDressingVariant();
	}

	public override void PostMapEntitySpawn()
	{
		base.PostMapEntitySpawn();
		UpdateDressingVariant();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.cargoShipContainer = Pool.Get<CargoShipContainer>();
		info.msg.cargoShipContainer.dressingVariant = dressingVariant;
	}

	private void AssignVariant()
	{
		dressingVariant = Random.Range(0, DressingVariants.Length);
	}

	public void ToggleHurtCollider(bool state)
	{
		SetFlag(Flags.Reserved1, state);
	}

	public void SetTargeted(bool state)
	{
		SetFlag(Flags.Reserved2, state);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.cargoShipContainer != null)
		{
			dressingVariant = info.msg.cargoShipContainer.dressingVariant;
		}
		UpdateDressingVariant();
	}

	private void UpdateDressingVariant()
	{
		for (int i = 0; i < DressingVariants.Length; i++)
		{
			DressingVariants[i].SetActive(dressingVariant == i);
		}
	}
}


public class CargoShipContainerSounds : FacepunchBehaviour, IClientComponent
{
	public SoundDefinition liftDef;

	public SoundDefinition dropDef;
}


using UnityEngine;

public class HarborBridgeSounds : MonoBehaviour, IClientComponent
{
	public HarborProximityEntity bridge;

	public SoundDefinition rootRotationLoopDef;

	public SoundDefinition rootRotationStartDef;

	public SoundDefinition rootRotationStopDef;
}


using UnityEngine;

public class HarborCrane : HarborProximityEntity
{
	public Transform CraneGrab;

	public Transform ArmRoot;

	public Transform ArmSupportLower;

	public Transform ArmSupportUpper;

	public TransformLineRenderer[] LineRenderers;

	protected void UpdateArmSupports(Vector3 fwd)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)ArmSupportUpper == (Object)null) && !((Object)(object)ArmSupportLower == (Object)null))
		{
			Vector3 val = ArmSupportUpper.position - ArmSupportLower.position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			ArmSupportLower.rotation = Quaternion.LookRotation(fwd, normalized);
			ArmSupportUpper.rotation = Quaternion.LookRotation(fwd, normalized);
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class HarborCraneContainerPickup : HarborCrane
{
	public struct ContainerStack
	{
		public Transform RootPoint;

		public int MaxStackSize;

		public int CurrentStackSize { get; set; }
	}

	private struct QueuedMove
	{
		public EntityRef<CargoShipContainer> TargetEntity;

		public Vector3 TargetWorldPosition;

		public Quaternion TargetWorldRotation;

		public bool HasTarget;
	}

	private enum PickupState
	{
		RotateToFace,
		Lift,
		RotateToTarget,
		Drop,
		Reset
	}

	public Transform ServerTowerGrab;

	public float LockTime = 5f;

	public float MaxMoveDistance = 32f;

	public float PickedUpObjectRotationSpeed = 30f;

	private List<ContainerStack> Stacks;

	public GameObjectRef ContainerPrefab;

	private const float ContainerSize = 3f;

	public int MaxContainerStackSize = 3;

	public bool DebugContainerSpawns;

	public bool DebugContainerDestinations;

	private Vector3 grabOffset = new Vector3(0f, 19f, 0f);

	public static ListHashSet<HarborCraneContainerPickup> AllCranes = new ListHashSet<HarborCraneContainerPickup>();

	private Vector3 startForward;

	private List<QueuedMove> movesToMake = new List<QueuedMove>();

	private QueuedMove? moveInProcess;

	private EntityRef<CargoShip> toParent;

	private float moveDelay;

	private PickupState currentPickupState;

	private float lockOnTime;

	private float maxTargetHeight;

	public override void ServerInit()
	{
		base.ServerInit();
		AllCranes.Add(this);
		List<HarborCraneContainerSpawnPoint> list = Pool.Get<List<HarborCraneContainerSpawnPoint>>();
		FindNearbyContainerSpawns(list);
		Stacks = new List<ContainerStack>();
		foreach (HarborCraneContainerSpawnPoint item in list)
		{
			Stacks.Add(new ContainerStack
			{
				RootPoint = ((Component)item).transform,
				MaxStackSize = item.MaxStackSize
			});
		}
		Pool.FreeUnmanaged<HarborCraneContainerSpawnPoint>(ref list);
		UpdateArm();
		SendNetworkUpdate();
	}

	public override void PostMapEntitySpawn()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.PostMapEntitySpawn();
		startForward = ((Component)this).transform.forward;
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		AllCranes.Remove(this);
	}

	private void FindNearbyContainerSpawns(List<HarborCraneContainerSpawnPoint> foundPoints)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		Vis.Components<HarborCraneContainerSpawnPoint>(((Component)this).transform.position, MaxMoveDistance, foundPoints, 1218652417, (QueryTriggerInteraction)2);
	}

	private void ReplenishContainers(int totalContainers)
	{
		for (int i = 0; i < Stacks.Count; i++)
		{
			ContainerStack value = Stacks[i];
			value.CurrentStackSize = 0;
			Stacks[i] = value;
		}
		maxTargetHeight = 0f;
		int count = Stacks.Count;
		if (count == 0)
		{
			return;
		}
		int num = Random.Range(0, count);
		int num2 = 0;
		while (totalContainers > 0 && num2 < 50)
		{
			num2++;
			num++;
			if (num >= count)
			{
				num = 0;
			}
			ContainerStack containerStack = Stacks[num];
			if (SpawnContainerOnStack(containerStack))
			{
				containerStack.CurrentStackSize++;
				totalContainers--;
				Stacks[num] = containerStack;
			}
		}
		movesToMake.Reverse();
		bool SpawnContainerOnStack(ContainerStack stack)
		{
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00af: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			if (stack.CurrentStackSize >= MaxContainerStackSize || stack.CurrentStackSize >= stack.MaxStackSize)
			{
				return false;
			}
			if (CargoShip.docking_debug)
			{
				Debug.Log((object)$"Spawning container on stack {stack.RootPoint.position}");
			}
			Vector3 position = stack.RootPoint.position;
			position.y += (float)stack.CurrentStackSize * 3f;
			List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
			Vis.Entities(new OBB(position, stack.RootPoint.rotation, new Bounds(new Vector3(0f, 1.5f, 0f), new Vector3(4.5f, 1.5f, 1.5f) * 0.8f)), list, 1218685185, (QueryTriggerInteraction)2);
			bool num3 = list.Count == 0;
			if (!num3 && CargoShip.docking_debug)
			{
				Debug.Log((object)("Container spawn blocked by " + ((Object)((Component)list[0]).gameObject).name), (Object)(object)list[0]);
			}
			Pool.FreeUnmanaged<BaseEntity>(ref list);
			if (!num3)
			{
				return false;
			}
			CargoShipContainer cargoShipContainer = GameManager.server.CreateEntity(ContainerPrefab.resourcePath, position, stack.RootPoint.rotation) as CargoShipContainer;
			cargoShipContainer.Spawn();
			QueuedMove item = default(QueuedMove);
			item.TargetEntity.Set(cargoShipContainer);
			item.HasTarget = false;
			movesToMake.Add(item);
			return true;
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.harborCrane = Pool.Get<HarborCrane>();
		info.msg.harborCrane.depth = ServerTowerGrab.localPosition.z;
		info.msg.harborCrane.height = ServerTowerGrab.localPosition.y;
		info.msg.harborCrane.time = GetNetworkTime();
		info.msg.harborCrane.maxMoveHeight = maxTargetHeight;
		info.msg.harborCrane.toParent = toParent.uid;
		info.msg.harborCrane.startForward = startForward;
		info.msg.harborCrane.moveDelay = moveDelay;
		if (moveInProcess.HasValue)
		{
			info.msg.harborCrane.currentMove = Pool.Get<QueuedMove>();
			CreateMove(moveInProcess.Value, info.msg.harborCrane.currentMove);
		}
		if (movesToMake.Count > 0)
		{
			info.msg.harborCrane.queuedMoves = Pool.Get<List<QueuedMove>>();
			foreach (QueuedMove item in movesToMake)
			{
				QueuedMove val = Pool.Get<QueuedMove>();
				CreateMove(item, val);
				info.msg.harborCrane.queuedMoves.Add(val);
			}
		}
		info.msg.harborCrane.currentPickupState = (int)currentPickupState;
	}

	private QueuedMove CreateMove(QueuedMove from)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		QueuedMove result = default(QueuedMove);
		result.TargetEntity = new EntityRef<CargoShipContainer>(from.targetEntity);
		result.TargetWorldPosition = from.targetWorldPosition;
		result.TargetWorldRotation = new Quaternion(from.targetWorldRotation.x, from.targetWorldRotation.y, from.targetWorldRotation.z, from.targetWorldRotation.w);
		result.HasTarget = from.hasTarget;
		return result;
	}

	private void CreateMove(QueuedMove move, QueuedMove target)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		target.hasTarget = move.HasTarget;
		target.targetEntity = move.TargetEntity.uid;
		target.targetWorldPosition = move.TargetWorldPosition;
		target.targetWorldRotation = new Vector4(move.TargetWorldRotation.x, move.TargetWorldRotation.y, move.TargetWorldRotation.z, move.TargetWorldRotation.w);
	}

	private void CountdownDelay()
	{
		moveDelay -= Time.deltaTime;
		if (moveDelay <= 0f)
		{
			moveDelay = 0f;
			((FacepunchBehaviour)this).CancelInvoke((Action)CountdownDelay);
			CheckMoveQueue();
		}
	}

	private void CheckMoveQueue()
	{
		if (moveDelay > 0f && movesToMake.Count > 0 && !((FacepunchBehaviour)this).IsInvoking((Action)CountdownDelay))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)CountdownDelay, 0f, 0f);
		}
		else if (movesToMake.Count > 0 && !IsBusy() && movesToMake[0].HasTarget)
		{
			moveInProcess = movesToMake[0];
			movesToMake.RemoveAt(0);
			currentPickupState = PickupState.RotateToFace;
			lockOnTime = 0f;
			SetFlag(Flags.Busy, b: true);
			((FacepunchBehaviour)this).InvokeRepeating((Action)ProcessCraneMovement, 0f, 0f);
		}
	}

	private void ProcessCraneMovement()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0348: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0358: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0362: Unknown result type (might be due to invalid IL or missing references)
		//IL_0364: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_036c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_037f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0401: Unknown result type (might be due to invalid IL or missing references)
		//IL_0406: Unknown result type (might be due to invalid IL or missing references)
		//IL_040b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0419: Unknown result type (might be due to invalid IL or missing references)
		//IL_041e: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_043e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0440: Unknown result type (might be due to invalid IL or missing references)
		//IL_0446: Unknown result type (might be due to invalid IL or missing references)
		//IL_044b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0467: Unknown result type (might be due to invalid IL or missing references)
		//IL_0469: Unknown result type (might be due to invalid IL or missing references)
		//IL_0476: Unknown result type (might be due to invalid IL or missing references)
		//IL_047b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0483: Unknown result type (might be due to invalid IL or missing references)
		//IL_0496: Unknown result type (might be due to invalid IL or missing references)
		//IL_049c: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_030a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0584: Unknown result type (might be due to invalid IL or missing references)
		//IL_058a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0594: Unknown result type (might be due to invalid IL or missing references)
		//IL_0599: Unknown result type (might be due to invalid IL or missing references)
		//IL_059e: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0612: Unknown result type (might be due to invalid IL or missing references)
		//IL_0618: Unknown result type (might be due to invalid IL or missing references)
		//IL_061d: Unknown result type (might be due to invalid IL or missing references)
		if (!moveInProcess.HasValue)
		{
			return;
		}
		QueuedMove value = moveInProcess.Value;
		CargoShipContainer cargoShipContainer = value.TargetEntity.Get(serverside: true);
		if ((Object)(object)cargoShipContainer == (Object)null)
		{
			return;
		}
		Vector3 position = ((Component)this).transform.position;
		float num = Mathf.Max(15.585f, Mathf.Max(value.TargetWorldPosition.y, maxTargetHeight));
		float num2 = num;
		Vector3 val = ((Component)cargoShipContainer).transform.position;
		Vector3 val2 = Vector3Ex.WithY(val, position.y) - position;
		float num3 = Vector3.Angle(((Component)this).transform.forward, ((Vector3)(ref val2)).normalized);
		Vector3 localPosition = ServerTowerGrab.localPosition;
		bool flag = false;
		float num4 = 0f;
		switch (currentPickupState)
		{
		case PickupState.RotateToFace:
			cargoShipContainer.SetTargeted(state: true);
			if (!(num3 < 2f))
			{
				break;
			}
			num2 = ((Component)this).transform.InverseTransformPoint(new Vector3(0f, ((Component)cargoShipContainer).transform.position.y + ((Bounds)(ref cargoShipContainer.bounds)).max.y, 0f)).y;
			if (Mathf.Abs(num2 - localPosition.y) < 0.1f)
			{
				lockOnTime += Time.deltaTime;
				if (lockOnTime > LockTime)
				{
					currentPickupState = PickupState.Lift;
					lockOnTime = 0f;
				}
			}
			break;
		case PickupState.Lift:
			flag = true;
			if (Mathf.Abs(num2 - localPosition.y) < 0.1f)
			{
				currentPickupState = PickupState.RotateToTarget;
			}
			break;
		case PickupState.RotateToTarget:
			flag = true;
			val = value.TargetWorldPosition;
			val2 = Vector3Ex.WithY(val, position.y) - position;
			num3 = Vector3.Angle(((Component)this).transform.forward, ((Vector3)(ref val2)).normalized);
			((Component)cargoShipContainer).transform.rotation = Quaternion.RotateTowards(((Component)cargoShipContainer).transform.rotation, value.TargetWorldRotation, PickedUpObjectRotationSpeed * Time.deltaTime);
			if (num3 < 0.1f)
			{
				currentPickupState = PickupState.Drop;
			}
			break;
		case PickupState.Drop:
			flag = true;
			val = value.TargetWorldPosition;
			val2 = Vector3Ex.WithY(val, position.y) - position;
			num2 = ((Component)this).transform.InverseTransformPoint(value.TargetWorldPosition).y + ((Bounds)(ref cargoShipContainer.bounds)).size.y;
			((Component)cargoShipContainer).transform.rotation = Quaternion.RotateTowards(((Component)cargoShipContainer).transform.rotation, value.TargetWorldRotation, PickedUpObjectRotationSpeed * Time.deltaTime);
			if (Mathf.Abs(num2 - localPosition.y) < 0.1f)
			{
				lockOnTime += Time.deltaTime;
				if (lockOnTime > LockTime)
				{
					currentPickupState = PickupState.Reset;
					((Component)cargoShipContainer).transform.SetPositionAndRotation(value.TargetWorldPosition, (PickedUpObjectRotationSpeed > 0f) ? value.TargetWorldRotation : ((Component)cargoShipContainer).transform.rotation);
					cargoShipContainer.SetParent(toParent.Get(serverside: true), worldPositionStays: true);
					cargoShipContainer.SetTargeted(state: false);
					lockOnTime = 0f;
				}
			}
			break;
		case PickupState.Reset:
			num2 = num;
			val = ((Component)this).transform.position + startForward * 26f;
			val2 = Vector3Ex.WithY(val, position.y) - position;
			num3 = Vector3.Angle(((Component)this).transform.forward, ((Vector3)(ref val2)).normalized);
			if (num3 < 0.1f)
			{
				lockOnTime += Time.deltaTime;
				if (lockOnTime > 5f)
				{
					lockOnTime = 0f;
					SetFlag(Flags.Busy, b: false);
					((FacepunchBehaviour)this).CancelInvoke((Action)ProcessCraneMovement);
					CheckMoveQueue();
				}
			}
			break;
		}
		cargoShipContainer.ToggleHurtCollider(currentPickupState == PickupState.Drop);
		Quaternion val3 = Quaternion.LookRotation(((Vector3)(ref val2)).normalized, Vector3.up);
		((Component)this).transform.rotation = Quaternion.RotateTowards(((Component)this).transform.rotation, val3, 5f * Time.deltaTime);
		float num5 = ((num4 > 0f) ? num4 : Vector3.Distance(Vector3Ex.WithY(val, position.y), position));
		Vector3 val4 = default(Vector3);
		((Vector3)(ref val4))..ctor(0f, num2, num5);
		localPosition = Vector3.MoveTowards(localPosition, val4, Time.deltaTime * 2f);
		ServerTowerGrab.localPosition = localPosition;
		CraneGrab.position = ServerTowerGrab.position + grabOffset;
		if (flag)
		{
			((Component)cargoShipContainer).transform.position = ServerTowerGrab.position - Vector3.up * ((Bounds)(ref cargoShipContainer.bounds)).size.y;
		}
		UpdateArm();
		SendNetworkUpdate();
		CargoShip cargoShip = toParent.Get(serverside: true);
		if (!((Object)(object)cargoShip != (Object)null) || cargoShip.HasFlag(Flags.Reserved1))
		{
			return;
		}
		foreach (QueuedMove item in movesToMake)
		{
			item.TargetEntity.Get(serverside: true).Kill();
		}
		if ((Object)(object)cargoShipContainer != (Object)null && currentPickupState != PickupState.Reset)
		{
			cargoShipContainer.Kill();
		}
		val = ((Component)this).transform.position + startForward * 26f;
		val2 = Vector3Ex.WithY(val, position.y) - position;
		num2 = num;
		num5 = Vector3.Distance(Vector3Ex.WithY(val, position.y), position);
		((Vector3)(ref val4))..ctor(0f, num2, num5);
		((Component)this).transform.rotation = Quaternion.LookRotation(((Vector3)(ref val2)).normalized, Vector3.up);
		ServerTowerGrab.localPosition = val4;
		CraneGrab.position = ServerTowerGrab.position + grabOffset;
		UpdateArm();
		SendNetworkUpdate();
		SetFlag(Flags.Busy, b: false);
		((FacepunchBehaviour)this).CancelInvoke((Action)ProcessCraneMovement);
	}

	public void ReplenishContainers()
	{
		ReplenishContainers(Random.Range(2, 4));
	}

	public void AssignDestination(List<Transform> destinations, CargoShip targetShip, float delay)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		if (startForward == Vector3.zero)
		{
			startForward = ((Component)targetShip).transform.forward;
		}
		toParent.Set(targetShip);
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < movesToMake.Count; i++)
		{
			QueuedMove value = movesToMake[i];
			Transform val = destinations[num];
			value.TargetWorldRotation = val.rotation;
			value.TargetWorldPosition = val.position + Vector3.up * ((float)num2 * 3f);
			maxTargetHeight = Mathf.Max(value.TargetWorldPosition.y, maxTargetHeight);
			value.HasTarget = true;
			movesToMake[i] = value;
			num++;
			if (num >= destinations.Count)
			{
				num = 0;
				num2++;
			}
		}
		moveDelay = delay;
		CheckMoveQueue();
	}

	public bool IsDestinationValidForCrane(CargoShipContainerDestination destination)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		Vector3 val = Vector3Ex.WithY(((Component)destination).transform.position, position.y);
		Vector3 val2 = position;
		return Vector3.Distance(val, val2) < MaxMoveDistance - 2f;
	}

	public override void Load(LoadInfo info)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (!base.isServer)
		{
			return;
		}
		startForward = info.msg.harborCrane.startForward;
		ServerTowerGrab.localPosition = new Vector3(0f, info.msg.harborCrane.height, info.msg.harborCrane.depth);
		toParent.uid = info.msg.harborCrane.toParent;
		moveDelay = info.msg.harborCrane.moveDelay;
		if (moveDelay > 0f && !((FacepunchBehaviour)this).IsInvoking((Action)CountdownDelay))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)CountdownDelay, 0f, 0f);
		}
		if (info.msg.harborCrane.currentMove != null)
		{
			moveInProcess = CreateMove(info.msg.harborCrane.currentMove);
		}
		movesToMake.Clear();
		if (info.msg.harborCrane.queuedMoves != null)
		{
			foreach (QueuedMove queuedMove in info.msg.harborCrane.queuedMoves)
			{
				movesToMake.Add(CreateMove(queuedMove));
			}
			Pool.Free<QueuedMove>(ref info.msg.harborCrane.queuedMoves, false);
		}
		currentPickupState = (PickupState)info.msg.harborCrane.currentPickupState;
		if (IsBusy() && !((FacepunchBehaviour)this).IsInvoking((Action)ProcessCraneMovement))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)ProcessCraneMovement, 0f, 0f);
		}
		maxTargetHeight = info.msg.harborCrane.maxMoveHeight;
	}

	private void UpdateArm()
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ArmRoot != (Object)null && (Object)(object)CraneGrab != (Object)null)
		{
			Vector3 position = ((Component)this).transform.position;
			Vector3 position2 = CraneGrab.position;
			float num = Vector3.Distance(position, Vector3Ex.WithY(position2, position.y));
			if (num < MaxMoveDistance + 2f)
			{
				float num2 = Mathf.Acos(num / (MaxMoveDistance + 3f));
				ArmRoot.localEulerAngles = new Vector3(0f - num2 * 57.29578f, 90f, 0f);
			}
		}
		UpdateArmSupports(((Component)this).transform.right);
	}
}


using UnityEngine;

public struct ContainerStack
{
	public Transform RootPoint;

	public int MaxStackSize;

	public int CurrentStackSize { get; set; }
}


using UnityEngine;

private struct QueuedMove
{
	public EntityRef<CargoShipContainer> TargetEntity;

	public Vector3 TargetWorldPosition;

	public Quaternion TargetWorldRotation;

	public bool HasTarget;
}


private enum PickupState
{
	RotateToFace,
	Lift,
	RotateToTarget,
	Drop,
	Reset
}


using UnityEngine;

public class HarborCraneContainerSpawnPoint : MonoBehaviour
{
	public int MaxStackSize = 1;
}


using UnityEngine;

public class HarborCraneSounds : MonoBehaviour, IClientComponent
{
	public HarborCrane crane;

	public SoundDefinition rootRotationLoopDef;

	public SoundDefinition rootRotationStartDef;

	public SoundDefinition rootRotationStopDef;

	public SoundDefinition armRotationLoopDef;

	public SoundDefinition armRotationStartDef;

	public SoundDefinition armRotationStopDef;

	public Transform grabSoundPosition;

	public SoundDefinition grabMoveLoopDef;

	public SoundDefinition grabMoveStartDef;

	public SoundDefinition grabMoveStopDef;
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public class HarborCraneStatic : HarborCrane
{
	public float StartingDepth;

	public float StartingHeight;

	public float StartingAngle;

	public Transform HangingLadder;

	public override void PostMapEntitySpawn()
	{
		base.PostMapEntitySpawn();
		SetArmPos(StartingAngle, StartingHeight, StartingDepth);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.harborCrane = Pool.Get<HarborCrane>();
		info.msg.harborCrane.depth = CraneGrab.localPosition.x;
		info.msg.harborCrane.height = CraneGrab.localPosition.y;
		info.msg.harborCrane.yaw = ArmRoot.localEulerAngles.z;
	}

	private void SetArmPos(float angle, float height, float depth)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		ArmRoot.localEulerAngles = new Vector3(0f, 0f, angle);
		CraneGrab.localPosition = new Vector3(depth, height, 0f);
		HangingLadder.rotation = Quaternion.LookRotation(((Component)this).transform.right, Vector3.up);
		UpdateArmSupports(((Component)this).transform.forward);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.harborCrane != null)
		{
			SetArmPos(info.msg.harborCrane.yaw, info.msg.harborCrane.height, info.msg.harborCrane.depth);
		}
	}
}


using System;
using UnityEngine;

public class HarborProximityEntity : BaseEntity
{
	public bool SupportChildDeployables;

	public const Flags IsMoving = Flags.Reserved1;

	private static ListHashSet<HarborProximityEntity> harborEntities = new ListHashSet<HarborProximityEntity>();

	public override void ServerInit()
	{
		base.ServerInit();
		harborEntities.Add(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		harborEntities.Remove(this);
	}

	public static HarborProximityEntity GetEntity(Vector3 worldPos)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<HarborProximityEntity> enumerator = harborEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				HarborProximityEntity current = enumerator.Current;
				if (Vector3.Distance(Vector3Ex.WithY(((Component)current).transform.position, worldPos.y), worldPos) < 3f)
				{
					return current;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return null;
	}

	public void NotifyStart()
	{
		SetFlag(Flags.Reserved1, b: true);
	}

	public void NotifyEnd()
	{
		SetFlag(Flags.Reserved1, b: false);
	}

	public override bool SupportsChildDeployables()
	{
		return SupportChildDeployables;
	}
}


using System;
using UnityEngine;

public class HarborProximityManager : MonoBehaviour, IServerComponent
{
	[Serializable]
	public class MoveToMake
	{
		public Transform EntityReferencePoint;

		public Transform MinimumPoint;

		public Transform MaximumPoint;

		public AnimationCurve Animation = AnimationCurve.Linear(0f, 0f, 1f, 1f);

		public bool UseToggleMode;

		public float ToggleSpeed = 1f;

		private float toggleState;

		private BaseEntity cachedEntity;

		private bool isMoving;

		public void Apply(float normalisedTime)
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)cachedEntity == (Object)null)
			{
				cachedEntity = HarborProximityEntity.GetEntity(EntityReferencePoint.position);
			}
			if ((Object)(object)cachedEntity == (Object)null)
			{
				return;
			}
			EvaluatePositionRotation(normalisedTime, out var rotToApply, out var posToApply);
			if (((Component)cachedEntity).transform.position != posToApply || ((Component)cachedEntity).transform.rotation != rotToApply)
			{
				if (!isMoving)
				{
					isMoving = true;
					if (cachedEntity is HarborProximityEntity harborProximityEntity)
					{
						harborProximityEntity.NotifyStart();
					}
				}
				((Component)cachedEntity).transform.SetPositionAndRotation(posToApply, rotToApply);
			}
			else if (isMoving)
			{
				isMoving = false;
				if (cachedEntity is HarborProximityEntity harborProximityEntity2)
				{
					harborProximityEntity2.NotifyEnd();
				}
			}
		}

		public void OnDockingEnded()
		{
			if (isMoving)
			{
				isMoving = false;
				if (cachedEntity is HarborProximityEntity harborProximityEntity)
				{
					harborProximityEntity.NotifyEnd();
				}
			}
		}

		public void EvaluatePositionRotation(float normalisedTime, out Quaternion rotToApply, out Vector3 posToApply)
		{
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			float num = Animation.Evaluate(normalisedTime);
			if (UseToggleMode)
			{
				if (Application.isPlaying)
				{
					toggleState = Mathf.MoveTowards(toggleState, num, Time.deltaTime * ToggleSpeed);
				}
				else
				{
					toggleState = num;
				}
				num = toggleState;
			}
			rotToApply = Quaternion.Lerp(MinimumPoint.rotation, MaximumPoint.rotation, num);
			posToApply = Vector3.Lerp(MinimumPoint.position, MaximumPoint.position, num);
		}
	}

	public MoveToMake[] Moves;

	public bool DebugCargo;

	[Range(0f, 1f)]
	public float DebugVisPoint;

	private float localNormalisedState;

	public void StartMovement()
	{
		localNormalisedState = 0f;
		Apply(0f);
	}

	public void UpdateNormalisedState(float f)
	{
		localNormalisedState = Mathf.Max(localNormalisedState, f);
		localNormalisedState = f;
		Apply(localNormalisedState);
	}

	public void EndMovement()
	{
		Apply(0f);
		MoveToMake[] moves = Moves;
		for (int i = 0; i < moves.Length; i++)
		{
			moves[i].OnDockingEnded();
		}
	}

	private void Apply(float f)
	{
		MoveToMake[] moves = Moves;
		for (int i = 0; i < moves.Length; i++)
		{
			moves[i].Apply(f);
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class MoveToMake
{
	public Transform EntityReferencePoint;

	public Transform MinimumPoint;

	public Transform MaximumPoint;

	public AnimationCurve Animation = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public bool UseToggleMode;

	public float ToggleSpeed = 1f;

	private float toggleState;

	private BaseEntity cachedEntity;

	private bool isMoving;

	public void Apply(float normalisedTime)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)cachedEntity == (Object)null)
		{
			cachedEntity = HarborProximityEntity.GetEntity(EntityReferencePoint.position);
		}
		if ((Object)(object)cachedEntity == (Object)null)
		{
			return;
		}
		EvaluatePositionRotation(normalisedTime, out var rotToApply, out var posToApply);
		if (((Component)cachedEntity).transform.position != posToApply || ((Component)cachedEntity).transform.rotation != rotToApply)
		{
			if (!isMoving)
			{
				isMoving = true;
				if (cachedEntity is HarborProximityEntity harborProximityEntity)
				{
					harborProximityEntity.NotifyStart();
				}
			}
			((Component)cachedEntity).transform.SetPositionAndRotation(posToApply, rotToApply);
		}
		else if (isMoving)
		{
			isMoving = false;
			if (cachedEntity is HarborProximityEntity harborProximityEntity2)
			{
				harborProximityEntity2.NotifyEnd();
			}
		}
	}

	public void OnDockingEnded()
	{
		if (isMoving)
		{
			isMoving = false;
			if (cachedEntity is HarborProximityEntity harborProximityEntity)
			{
				harborProximityEntity.NotifyEnd();
			}
		}
	}

	public void EvaluatePositionRotation(float normalisedTime, out Quaternion rotToApply, out Vector3 posToApply)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		float num = Animation.Evaluate(normalisedTime);
		if (UseToggleMode)
		{
			if (Application.isPlaying)
			{
				toggleState = Mathf.MoveTowards(toggleState, num, Time.deltaTime * ToggleSpeed);
			}
			else
			{
				toggleState = num;
			}
			num = toggleState;
		}
		rotToApply = Quaternion.Lerp(MinimumPoint.rotation, MaximumPoint.rotation, num);
		posToApply = Vector3.Lerp(MinimumPoint.position, MaximumPoint.position, num);
	}
}


using UnityEngine;

public class MovementSounds : MonoBehaviour
{
	public SoundDefinition waterMovementDef;

	public float waterMovementFadeInSpeed = 1f;

	public float waterMovementFadeOutSpeed = 1f;

	public SoundDefinition enterWaterSmall;

	public SoundDefinition enterWaterMedium;

	public SoundDefinition enterWaterLarge;

	private Sound waterMovement;

	private SoundModulation.Modulator waterGainMod;

	public bool inWater;

	public float waterLevel;

	public bool mute;
}


using UnityEngine;

public class MoveOverTime : MonoBehaviour
{
	[Range(-10f, 10f)]
	public float speed = 1f;

	public Vector3 position;

	public Vector3 rotation;

	public Vector3 scale;

	private void Update()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)this).transform;
		Quaternion val = ((Component)this).transform.rotation;
		transform.rotation = Quaternion.Euler(((Quaternion)(ref val)).eulerAngles + rotation * speed * Time.deltaTime);
		Transform transform2 = ((Component)this).transform;
		transform2.localScale += scale * speed * Time.deltaTime;
		Transform transform3 = ((Component)this).transform;
		transform3.localPosition += position * speed * Time.deltaTime;
	}
}


using System;
using Network;

public abstract class NetworkCryptography : INetworkCryptography
{
	private byte[] buffer = new byte[8388608];

	public unsafe ArraySegment<byte> EncryptCopy(Connection connection, ArraySegment<byte> data)
	{
		ArraySegment<byte> src = new ArraySegment<byte>(data.Array, data.Offset, data.Count);
		ArraySegment<byte> dst = new ArraySegment<byte>(buffer, data.Offset, buffer.Length - data.Offset);
		if (data.Offset > 0)
		{
			fixed (byte* array2 = dst.Array)
			{
				fixed (byte* array = data.Array)
				{
					Buffer.MemoryCopy(array, array2, dst.Array.Length, data.Offset);
				}
			}
		}
		EncryptionHandler(connection, src, ref dst);
		return dst;
	}

	public unsafe ArraySegment<byte> DecryptCopy(Connection connection, ArraySegment<byte> data)
	{
		ArraySegment<byte> src = new ArraySegment<byte>(data.Array, data.Offset, data.Count);
		ArraySegment<byte> dst = new ArraySegment<byte>(buffer, data.Offset, buffer.Length - data.Offset);
		if (data.Offset > 0)
		{
			fixed (byte* array2 = dst.Array)
			{
				fixed (byte* array = data.Array)
				{
					Buffer.MemoryCopy(array, array2, dst.Array.Length, data.Offset);
				}
			}
		}
		DecryptionHandler(connection, src, ref dst);
		return dst;
	}

	public void Encrypt(Connection connection, ref ArraySegment<byte> data)
	{
		ArraySegment<byte> src = new ArraySegment<byte>(data.Array, data.Offset, data.Count);
		ArraySegment<byte> dst = new ArraySegment<byte>(data.Array, data.Offset, data.Array.Length - data.Offset);
		EncryptionHandler(connection, src, ref dst);
		data = dst;
	}

	public void Decrypt(Connection connection, ref ArraySegment<byte> data)
	{
		ArraySegment<byte> src = new ArraySegment<byte>(data.Array, data.Offset, data.Count);
		ArraySegment<byte> dst = new ArraySegment<byte>(data.Array, data.Offset, data.Array.Length - data.Offset);
		DecryptionHandler(connection, src, ref dst);
		data = dst;
	}

	protected abstract void EncryptionHandler(Connection connection, ArraySegment<byte> src, ref ArraySegment<byte> dst);

	protected abstract void DecryptionHandler(Connection connection, ArraySegment<byte> src, ref ArraySegment<byte> dst);
}


using System;
using Network;

public class NetworkCryptographyServer : NetworkCryptography
{
	protected override void EncryptionHandler(Connection connection, ArraySegment<byte> src, ref ArraySegment<byte> dst)
	{
		if (connection.encryptionLevel > 1)
		{
			EACServer.Encrypt(connection, src, ref dst);
		}
		else
		{
			Craptography.XOR(2594u, src, ref dst);
		}
	}

	protected override void DecryptionHandler(Connection connection, ArraySegment<byte> src, ref ArraySegment<byte> dst)
	{
		if (connection.encryptionLevel > 1)
		{
			EACServer.Decrypt(connection, src, ref dst);
		}
		else
		{
			Craptography.XOR(2594u, src, ref dst);
		}
	}
}


using System;
using ConVar;
using Network;
using Network.Visibility;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Serialization;

public class NetworkVisibilityGrid : MonoBehaviour, Provider
{
	public const int overworldLayer = 0;

	public const int cavesLayer = 1;

	public const int tunnelsLayer = 2;

	public const int tutorialsLayer = 3;

	public const int dynamicDungeonsFirstLayer = 10;

	public int startID = 1024;

	public int gridSize = 100;

	public int cellCount = 32;

	[FormerlySerializedAs("visibilityRadius")]
	public int visibilityRadiusFar = 2;

	public int visibilityRadiusNear = 1;

	public float switchTolerance = 20f;

	public static float cavesThreshold = -5f;

	public static float tunnelsThreshold = -50f;

	public float dynamicDungeonsThreshold = 1000f;

	public float dynamicDungeonsInterval = 100f;

	private float halfGridSize;

	private float cellSize;

	private float halfCellSize;

	private int numIDsPerLayer;

	public static void ResetUndergroundThresholds()
	{
		cavesThreshold = -5f;
		tunnelsThreshold = -50f;
	}

	public static void RegisterEnvironmentVolume(EnvironmentVolume volume)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if ((volume.NetworkType & NetworkGroupType.Canyon) == NetworkGroupType.Canyon)
		{
			tunnelsThreshold = Mathf.Min(tunnelsThreshold, ((Component)volume).transform.position.y + volume.Center.y - volume.Size.y * 0.5f);
		}
	}

	private void Awake()
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Expected O, but got Unknown
		Debug.Assert(Net.sv != null, "Network.Net.sv is NULL when creating Visibility Grid");
		Debug.Assert(Net.sv.visibility == null, "Network.Net.sv.visibility is being set multiple times");
		Net.sv.visibility = new Manager((Provider)(object)this);
	}

	private void OnEnable()
	{
		halfGridSize = (float)gridSize / 2f;
		cellSize = (float)gridSize / (float)cellCount;
		halfCellSize = cellSize / 2f;
		numIDsPerLayer = cellCount * cellCount;
	}

	private void OnDisable()
	{
		if (!Application.isQuitting && Net.sv != null && Net.sv.visibility != null)
		{
			Net.sv.visibility.Dispose();
			Net.sv.visibility = null;
		}
	}

	private void OnDrawGizmosSelected()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.blue;
		Vector3 position = ((Component)this).transform.position;
		for (int i = 0; i <= cellCount; i++)
		{
			float num = 0f - halfGridSize + (float)i * cellSize - halfCellSize;
			Gizmos.DrawLine(new Vector3(halfGridSize, position.y, num), new Vector3(0f - halfGridSize, position.y, num));
			Gizmos.DrawLine(new Vector3(num, position.y, halfGridSize), new Vector3(num, position.y, 0f - halfGridSize));
		}
	}

	private int PositionToGrid(float value)
	{
		return Mathf.Clamp(Mathf.RoundToInt((value + halfGridSize) / cellSize), 0, cellCount - 1);
	}

	private float GridToPosition(int value)
	{
		return (float)value * cellSize - halfGridSize;
	}

	private int PositionToLayer(float x, float y, float z)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (y < tunnelsThreshold)
		{
			return 2;
		}
		if (y < cavesThreshold)
		{
			return 1;
		}
		if (y >= dynamicDungeonsThreshold)
		{
			return 10 + Mathf.FloorToInt((y - dynamicDungeonsThreshold) / dynamicDungeonsInterval);
		}
		if (TerrainMeta.IsPointWithinTutorialBounds(new Vector3(x, 0f, z)))
		{
			return 3;
		}
		return 0;
	}

	private uint CoordToID(int x, int y, int layer)
	{
		return (uint)(layer * numIDsPerLayer + (x * cellCount + y) + startID);
	}

	private uint GetID(Vector3 vPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		int num = PositionToGrid(vPos.x);
		int num2 = PositionToGrid(vPos.z);
		int num3 = PositionToLayer(vPos.x, vPos.y, vPos.z);
		if (num3 == 3)
		{
			Enumerator<TutorialIsland.IslandBounds> enumerator = TutorialIsland.BoundsListServer.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					TutorialIsland.IslandBounds current = enumerator.Current;
					if (current.Contains(vPos))
					{
						return current.Id;
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		uint num4 = CoordToID(num, num2, num3);
		if (num4 < startID)
		{
			Debug.LogError((object)$"NetworkVisibilityGrid.GetID - group is below range {num} {num2} {num3} {num4} {cellCount}");
		}
		return num4;
	}

	private (int x, int y, int layer) DeconstructGroupId(int groupId)
	{
		groupId -= startID;
		int result;
		int item = Math.DivRem(groupId, numIDsPerLayer, out result);
		int result2;
		return (x: Math.DivRem(result, cellCount, out result2), y: result2, layer: item);
	}

	private Bounds GetBounds(uint uid)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		var (value, value2, num) = DeconstructGroupId((int)uid);
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(GridToPosition(value) - halfCellSize, 0f, GridToPosition(value2) - halfCellSize);
		Vector3 max = default(Vector3);
		((Vector3)(ref max))..ctor(val.x + cellSize, 0f, val.z + cellSize);
		if (num == 0 || num == 3)
		{
			val.y = cavesThreshold;
			max.y = dynamicDungeonsThreshold;
		}
		else if (num == 1)
		{
			val.y = tunnelsThreshold;
			max.y = cavesThreshold - float.Epsilon;
		}
		else if (num == 2)
		{
			val.y = -10000f;
			max.y = tunnelsThreshold - float.Epsilon;
		}
		else if (num >= 10)
		{
			int num2 = num - 10;
			val.y = dynamicDungeonsThreshold + (float)num2 * dynamicDungeonsInterval + float.Epsilon;
			max.y = val.y + dynamicDungeonsInterval;
		}
		else
		{
			Debug.LogError((object)$"Cannot get bounds for unknown layer {num}!", (Object)(object)this);
		}
		Bounds result = default(Bounds);
		((Bounds)(ref result)).min = val;
		((Bounds)(ref result)).max = max;
		return result;
	}

	public void OnGroupAdded(Group group)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (!group.restricted)
		{
			group.bounds = GetBounds(group.ID);
		}
	}

	public bool IsInside(Group group, Vector3 vPos)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false || group.ID == 0 || ((Bounds)(ref group.bounds)).Contains(vPos);
		if (!group.restricted)
		{
			flag = flag || ((Bounds)(ref group.bounds)).SqrDistance(vPos) < switchTolerance;
		}
		return flag;
	}

	public Group GetGroup(Vector3 vPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		uint iD = GetID(vPos);
		if (iD == 0)
		{
			return null;
		}
		Group val = Net.sv.visibility.Get(iD);
		if (Net.network_group_debug && !IsInside(val, vPos))
		{
			float num = ((Bounds)(ref val.bounds)).SqrDistance(vPos);
			string[] obj = new string[6]
			{
				"Group is inside is all fucked ",
				iD.ToString(),
				"/",
				num.ToString(),
				"/",
				null
			};
			Vector3 val2 = vPos;
			obj[5] = ((object)(Vector3)(ref val2)/*cast due to .constrained prefix*/).ToString();
			Debug.Log((object)string.Concat(obj));
		}
		return val;
	}

	public void GetVisibleFromFar(Group group, ListHashSet<Group> groups)
	{
		int visibilityRadiusFarOverride = Net.visibilityRadiusFarOverride;
		int radius = ((visibilityRadiusFarOverride > 0) ? visibilityRadiusFarOverride : visibilityRadiusFar);
		GetVisibleFrom(group, groups, radius);
	}

	public void GetVisibleFromNear(Group group, ListHashSet<Group> groups)
	{
		int visibilityRadiusNearOverride = Net.visibilityRadiusNearOverride;
		int radius = ((visibilityRadiusNearOverride > 0) ? visibilityRadiusNearOverride : visibilityRadiusNear);
		GetVisibleFrom(group, groups, radius);
	}

	private void GetVisibleFrom(Group group, ListHashSet<Group> groups, int radius)
	{
		if (Interface.CallHook("OnNetworkSubscriptionsGather", (object)this, (object)group, (object)groups, (object)radius) != null)
		{
			return;
		}
		ListHashSet<Group> groups2 = groups;
		groups2.Add(Net.sv.visibility.Get(0u));
		if (group.restricted)
		{
			groups2.Add(group);
			return;
		}
		int iD = (int)group.ID;
		if (iD < startID)
		{
			return;
		}
		var (num, num2, groupLayer2) = DeconstructGroupId(iD);
		AddLayers(num, num2, groupLayer2);
		for (int i = 1; i <= radius; i++)
		{
			AddLayers(num - i, num2, groupLayer2);
			AddLayers(num + i, num2, groupLayer2);
			AddLayers(num, num2 - i, groupLayer2);
			AddLayers(num, num2 + i, groupLayer2);
			for (int j = 1; j < i; j++)
			{
				AddLayers(num - i, num2 - j, groupLayer2);
				AddLayers(num - i, num2 + j, groupLayer2);
				AddLayers(num + i, num2 - j, groupLayer2);
				AddLayers(num + i, num2 + j, groupLayer2);
				AddLayers(num - j, num2 - i, groupLayer2);
				AddLayers(num + j, num2 - i, groupLayer2);
				AddLayers(num - j, num2 + i, groupLayer2);
				AddLayers(num + j, num2 + i, groupLayer2);
			}
			AddLayers(num - i, num2 - i, groupLayer2);
			AddLayers(num - i, num2 + i, groupLayer2);
			AddLayers(num + i, num2 - i, groupLayer2);
			AddLayers(num + i, num2 + i, groupLayer2);
		}
		void Add(int groupX, int groupY, int groupLayer)
		{
			groups2.Add(Net.sv.visibility.Get(CoordToID(groupX, groupY, groupLayer)));
		}
		void AddLayers(int groupX, int groupY, int groupLayer)
		{
			Add(groupX, groupY, groupLayer);
			if (groupLayer == 0)
			{
				Add(groupX, groupY, 1);
			}
			if (groupLayer == 1)
			{
				Add(groupX, groupY, 2);
				Add(groupX, groupY, 0);
			}
			if (groupLayer == 2)
			{
				Add(groupX, groupY, 1);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Network;
using Network.Visibility;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public static class ServerOcclusion
{
	public readonly struct Grid : IEquatable<Grid>
	{
		public readonly int x;

		public readonly int y;

		public readonly int z;

		public const float Resolution = 16f;

		public const float HalfResolution = 8f;

		public Grid(int x, int y, int z)
		{
			this.x = x;
			this.y = y;
			this.z = z;
		}

		public int GetOffset(float axis)
		{
			return Mathf.RoundToInt(axis / 2f / 16f);
		}

		public Vector3 GetCenterPoint()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			return new Vector3((float)(x - GetOffset(TerrainMeta.Size.x)) * 16f, (float)(y - GetOffset(MaxY)) * 16f, (float)(z - GetOffset(TerrainMeta.Size.z)) * 16f);
		}

		public override string ToString()
		{
			return $"(x: {x}, y: {y}, z: {z})";
		}

		public bool Equals(Grid other)
		{
			if (x == other.x && y == other.y)
			{
				return z == other.z;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(x, y, z);
		}

		public bool IsBlocked()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			return GamePhysics.CheckBounds(new Bounds(GetCenterPoint(), new Vector3(16f, 16f, 16f)), 8388608, (QueryTriggerInteraction)0);
		}

		public int GetIndex()
		{
			return GetGridIndex(x, y, z);
		}
	}

	public readonly struct SubGrid : IEquatable<SubGrid>
	{
		public readonly int x;

		public readonly int y;

		public readonly int z;

		public const float Resolution = 2f;

		public const float HalfResolution = 1f;

		public SubGrid(int x, int y, int z)
		{
			this.x = x;
			this.y = y;
			this.z = z;
		}

		public SubGrid(int3 p)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			x = p.x;
			y = p.y;
			z = p.z;
		}

		public int GetOffset(float axis)
		{
			return Mathf.RoundToInt(axis / 2f / 2f);
		}

		public Vector3 GetCenterPoint()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			return new Vector3((float)(x - GetOffset(TerrainMeta.Size.x)) * 2f, (float)(y - GetOffset(MaxY)) * 2f, (float)(z - GetOffset(TerrainMeta.Size.z)) * 2f);
		}

		public override string ToString()
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			return $"(x: {x}, y: {y}, z: {z}) - {GetCenterPoint()}, {IsBlocked()}";
		}

		public bool Equals(SubGrid other)
		{
			if (x == other.x && y == other.y)
			{
				return z == other.z;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(x, y, z);
		}

		public bool IsBlocked()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			bool flag = false;
			for (int i = 0; i < GridOffsets.Length; i++)
			{
				Vector3 pos = GetCenterPoint() + GridOffsets[i];
				flag = false;
				if (OcclusionIncludeRocks)
				{
					flag = AntiHack.IsInsideMesh(pos);
				}
				if (!flag && !AntiHack.TestInsideTerrain(pos))
				{
					return false;
				}
			}
			if (flag)
			{
				return ((Component)((RaycastHit)(ref AntiHack.isInsideRayHit)).collider).gameObject.HasCustomTag(GameObjectTag.AllowBarricadePlacement);
			}
			return true;
		}

		public int GetIndex()
		{
			return GetSubGridIndex(x, y, z);
		}

		public int GetDistance(SubGrid other)
		{
			return Mathf.Abs(x - other.x) + Mathf.Abs(y - other.y) + Mathf.Abs(z - other.z);
		}
	}

	public static int MaxY = 200;

	public static int ChunkCountX;

	public static int ChunkCountY;

	public static int ChunkCountZ;

	public static int SubChunkCountX;

	public static int SubChunkCountY;

	public static int SubChunkCountZ;

	public static float AxisX;

	public static float AxisY;

	public static float AxisZ;

	public static LimitDictionary<(SubGrid, SubGrid), bool> OcclusionCache = new LimitDictionary<(SubGrid, SubGrid), bool>(32768);

	public static NativeArray<NativeBitArray> OcclusionSubGridBlocked;

	public static NativeReference<bool> ReturnHolder;

	public const int OcclusionChunkSize = 16;

	public const int OcclusionChunkResolution = 8;

	public static Dictionary<Group, ListHashSet<BaseNetworkable>> Occludees = new Dictionary<Group, ListHashSet<BaseNetworkable>>();

	public static readonly Vector3[] GridOffsets = (Vector3[])(object)new Vector3[2]
	{
		new Vector3(0f, 0f, 0f),
		new Vector3(0f, 1f, 0f)
	};

	public static readonly (int, int, int)[] neighbours = new(int, int, int)[6]
	{
		(1, 0, 0),
		(-1, 0, 0),
		(0, 1, 0),
		(0, -1, 0),
		(0, 0, 1),
		(0, 0, -1)
	};

	[ServerVar]
	public static bool UseJob = true;

	public static bool OcclusionEnabled { get; set; } = true;

	public static bool OcclusionIncludeRocks { get; set; } = true;

	public static float OcclusionPollRate => 2f;

	public static int MinOcclusionDistance => 25;

	public static string SubGridFilePath
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			return Server.rootFolder + "/" + World.MapFileName.Replace(".map", "") + "_occlusion.dat";
		}
	}

	public static int GetGridIndex(int x, int y, int z)
	{
		return z * ChunkCountX * ChunkCountY + y * ChunkCountZ + x;
	}

	public static int GetSubGridIndex(int x, int y, int z)
	{
		return z * SubChunkCountX * SubChunkCountY + y * SubChunkCountX + x;
	}

	public static int GetGrid(float position, float axis)
	{
		return Mathf.RoundToInt(position / 16f + axis / 16f);
	}

	public static Grid GetGrid(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		int grid = GetGrid(position.x, AxisX);
		int grid2 = GetGrid(position.y, AxisY);
		int grid3 = GetGrid(position.z, AxisZ);
		if (IsValidGrid(grid, grid2, grid3))
		{
			return new Grid(grid, grid2, grid3);
		}
		return default(Grid);
	}

	public static int GetSubGrid(float position, float axis)
	{
		return Mathf.RoundToInt(position / 2f + axis / 2f);
	}

	public static SubGrid GetSubGrid(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		int subGrid = GetSubGrid(position.x, AxisX);
		int subGrid2 = GetSubGrid(position.y, AxisY);
		int subGrid3 = GetSubGrid(position.z, AxisZ);
		if (IsValidSubGrid(subGrid, subGrid2, subGrid3))
		{
			return new SubGrid(subGrid, subGrid2, subGrid3);
		}
		return default(SubGrid);
	}

	public static bool IsBlocked(int x, int y, int z)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		int result;
		int x2 = Math.DivRem(x, 8, out result);
		int result2;
		int y2 = Math.DivRem(y, 8, out result2);
		int result3;
		int z2 = Math.DivRem(z, 8, out result3);
		int gridIndex = GetGridIndex(x2, y2, z2);
		NativeBitArray val = (NativeBitArray)(IsValidGrid(x2, y2, z2) ? OcclusionSubGridBlocked[gridIndex] : default(NativeBitArray));
		int num = result3 * 8 * 8 + result2 * 8 + result;
		if (((NativeBitArray)(ref val)).IsCreated)
		{
			return ((NativeBitArray)(ref val)).IsSet(num);
		}
		return false;
	}

	public static bool IsBlocked(SubGrid sub)
	{
		return IsBlocked(sub.x, sub.y, sub.z);
	}

	public static bool IsValidGrid(int x, int y, int z)
	{
		if (x < 0 || y < 0 || z < 0)
		{
			return false;
		}
		if (x >= ChunkCountX || y >= ChunkCountY || z >= ChunkCountZ)
		{
			return false;
		}
		return true;
	}

	public static bool IsValidSubGrid(int x, int y, int z)
	{
		if (x < 0 || y < 0 || z < 0)
		{
			return false;
		}
		if (x >= SubChunkCountX || y >= SubChunkCountY || z >= SubChunkCountZ)
		{
			return false;
		}
		return true;
	}

	public static void CalculatePathBetweenGridsJob(SubGrid grid1, SubGrid grid2, out bool pathBlocked)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		pathBlocked = false;
		NativeReference<bool> returnHolder = ReturnHolder;
		CalculatePathBetweenGridsJob calculatePathBetweenGridsJob = default(CalculatePathBetweenGridsJob);
		calculatePathBetweenGridsJob.Grid1 = grid1;
		calculatePathBetweenGridsJob.Grid2 = grid2;
		calculatePathBetweenGridsJob.PathBlocked = returnHolder;
		calculatePathBetweenGridsJob.OcclusionSubGridBlocked = OcclusionSubGridBlocked;
		calculatePathBetweenGridsJob.server_occlusion_blocked_grid_threshold = ConVar.AntiHack.server_occlusion_blocked_grid_threshold;
		calculatePathBetweenGridsJob.server_occlusion_neighbour_threshold = ConVar.AntiHack.server_occlusion_neighbour_threshold;
		calculatePathBetweenGridsJob.server_occlusion_use_neighbour_thresholds = ConVar.AntiHack.server_occlusion_use_neighbour_thresholds;
		calculatePathBetweenGridsJob.ChunkCount = new int3(ChunkCountX, ChunkCountY, ChunkCountZ);
		calculatePathBetweenGridsJob.SubChunkCount = new int3(SubChunkCountX, SubChunkCountY, SubChunkCountZ);
		CalculatePathBetweenGridsJob calculatePathBetweenGridsJob2 = calculatePathBetweenGridsJob;
		IJobExtensions.RunByRef<CalculatePathBetweenGridsJob>(ref calculatePathBetweenGridsJob2);
		pathBlocked = returnHolder.Value;
	}

	public static void CalculatePathBetweenGrids(SubGrid grid1, SubGrid grid2, out bool pathBlocked)
	{
		if (UseJob)
		{
			CalculatePathBetweenGridsJob(grid1, grid2, out pathBlocked);
			return;
		}
		int num = 0;
		int neighboursChecked = 0;
		pathBlocked = false;
		int num2 = grid1.x;
		int num3 = grid1.y;
		int num4 = grid1.z;
		int x = grid2.x;
		int y = grid2.y;
		int z = grid2.z;
		int num5 = x - grid1.x;
		int num6 = y - grid1.y;
		int num7 = z - grid1.z;
		int num8 = Mathf.Abs(num5);
		int num9 = Mathf.Abs(num6);
		int num10 = Mathf.Abs(num7);
		int num11 = num8 << 1;
		int num12 = num9 << 1;
		int num13 = num10 << 1;
		int xStep = ((num5 >= 0) ? 1 : (-1));
		int yStep = ((num6 >= 0) ? 1 : (-1));
		int zStep = ((num7 >= 0) ? 1 : (-1));
		int num14;
		int num15;
		if (num8 >= num9 && num8 >= num10)
		{
			num14 = num12 - num8;
			num15 = num13 - num8;
			for (int i = 0; i < num8; i++)
			{
				if (!AddToGridArea(new SubGrid(num2, num3, num4)) && ++num > ConVar.AntiHack.server_occlusion_blocked_grid_threshold)
				{
					pathBlocked = true;
					break;
				}
				if (num14 > 0)
				{
					num3 += yStep;
					num14 -= num11;
				}
				if (num15 > 0)
				{
					num4 += zStep;
					num15 -= num11;
				}
				num14 += num12;
				num15 += num13;
				num2 += xStep;
			}
			return;
		}
		if (num9 >= num8 && num9 >= num10)
		{
			num14 = num11 - num9;
			num15 = num13 - num9;
			for (int j = 0; j < num9; j++)
			{
				if (!AddToGridArea(new SubGrid(num2, num3, num4)) && ++num > ConVar.AntiHack.server_occlusion_blocked_grid_threshold)
				{
					pathBlocked = true;
					break;
				}
				if (num14 > 0)
				{
					num2 += xStep;
					num14 -= num12;
				}
				if (num15 > 0)
				{
					num4 += zStep;
					num15 -= num12;
				}
				num14 += num11;
				num15 += num13;
				num3 += yStep;
			}
			return;
		}
		num14 = num12 - num10;
		num15 = num11 - num10;
		for (int k = 0; k < num10; k++)
		{
			if (!AddToGridArea(new SubGrid(num2, num3, num4)) && ++num > ConVar.AntiHack.server_occlusion_blocked_grid_threshold)
			{
				pathBlocked = true;
				break;
			}
			if (num14 > 0)
			{
				num3 += yStep;
				num14 -= num13;
			}
			if (num15 > 0)
			{
				num2 += xStep;
				num15 -= num13;
			}
			num14 += num12;
			num15 += num11;
			num4 += zStep;
		}
		bool AddNeighbours(SubGrid grid)
		{
			for (int l = 0; l < neighbours.Length; l++)
			{
				if (neighbours[l].Item1 != -xStep && neighbours[l].Item2 != -yStep && neighbours[l].Item3 != -zStep)
				{
					int x2 = grid.x + neighbours[l].Item1;
					int y2 = grid.y + neighbours[l].Item2;
					int z2 = grid.z + neighbours[l].Item3;
					if (IsValidSubGrid(x2, y2, z2) && !IsBlocked(new SubGrid(x2, y2, z2)))
					{
						return true;
					}
				}
			}
			return false;
		}
		bool AddToGridArea(SubGrid grid)
		{
			if (!IsBlocked(grid))
			{
				return true;
			}
			if (!ConVar.AntiHack.server_occlusion_use_neighbour_thresholds || ++neighboursChecked <= ConVar.AntiHack.server_occlusion_neighbour_threshold)
			{
				return AddNeighbours(grid);
			}
			return false;
		}
	}

	public static void SetupGrid()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		Stopwatch stopwatch = new Stopwatch();
		stopwatch.Start();
		Vector3 size = TerrainMeta.Size;
		ChunkCountX = Mathf.Max(Mathf.CeilToInt(size.x / 16f), 1);
		ChunkCountY = Mathf.Max(Mathf.CeilToInt((float)MaxY / 16f), 1);
		ChunkCountZ = Mathf.Max(Mathf.CeilToInt(size.z / 16f), 1);
		SubChunkCountX = Mathf.Max(Mathf.CeilToInt(size.x / 2f), 1);
		SubChunkCountY = Mathf.Max(Mathf.CeilToInt((float)MaxY / 2f), 1);
		SubChunkCountZ = Mathf.Max(Mathf.CeilToInt(size.z / 2f), 1);
		AxisX = TerrainMeta.Size.x / 2f;
		AxisY = MaxY / 2;
		AxisZ = TerrainMeta.Size.z / 2f;
		bool server_occlusion_save_grid = ConVar.AntiHack.server_occlusion_save_grid;
		if (!server_occlusion_save_grid || !ReadGridFromFile(SubGridFilePath))
		{
			OcclusionSubGridBlocked = new NativeArray<NativeBitArray>(ChunkCountX * ChunkCountY * ChunkCountZ, (Allocator)4, (NativeArrayOptions)1);
			ReturnHolder = new NativeReference<bool>(AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)1);
			Debug.Log((object)$"Preparing Occlusion Grid ({SubChunkCountX}, {SubChunkCountY}, {SubChunkCountZ})");
			for (int i = 0; i < ChunkCountX; i++)
			{
				for (int j = 0; j < ChunkCountY; j++)
				{
					for (int k = 0; k < ChunkCountZ; k++)
					{
						Grid cell2 = new Grid(i, j, k);
						if (cell2.IsBlocked())
						{
							PopulateSubGrid(cell2);
						}
					}
				}
			}
			if (server_occlusion_save_grid)
			{
				WriteGridToFile(ChunkCountX * ChunkCountY * ChunkCountZ, OcclusionSubGridBlocked);
			}
			Debug.Log((object)$"Initialized {SubChunkCountX * SubChunkCountY * SubChunkCountZ} occlusion sub-chunks - took {stopwatch.Elapsed.TotalMilliseconds / 1000.0} seconds");
		}
		else
		{
			Debug.Log((object)$"Loaded {SubChunkCountX * SubChunkCountY * SubChunkCountZ} occlusion sub-chunks from file - took {stopwatch.Elapsed.TotalMilliseconds / 1000.0} seconds");
		}
		foreach (BasePlayer allPlayer in BasePlayer.allPlayerList)
		{
			if (OcclusionEnabled && allPlayer.SupportsServerOcclusion())
			{
				allPlayer.SubGrid = GetSubGrid(allPlayer.GetOcclusionOffset());
				ListHashSet<Group> val = Pool.Get<ListHashSet<Group>>();
				Net.sv.visibility.GetVisibleFromFar(allPlayer.net.group, val);
				allPlayer.GroupAddOccludee(allPlayer.net.group);
				for (int l = 0; l < val.Count; l++)
				{
					allPlayer.GroupAddOccludee(val[l]);
				}
				Pool.FreeUnmanaged<Group>(ref val);
			}
		}
		static void PopulateSubGrid(Grid cell)
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			int num = cell.x * 8;
			int num2 = cell.y * 8;
			int num3 = cell.z * 8;
			int index = cell.GetIndex();
			NativeBitArray val2 = OcclusionSubGridBlocked[index];
			NativeBitArray val3;
			if (!((NativeBitArray)(ref val2)).IsCreated)
			{
				((NativeBitArray)(ref val2))..ctor(512, AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)1);
				OcclusionSubGridBlocked[index] = val2;
				val3 = val2;
			}
			else
			{
				val3 = OcclusionSubGridBlocked[index];
			}
			NativeBitArray val4 = val3;
			for (int m = 0; m < 8; m++)
			{
				for (int n = 0; n < 8; n++)
				{
					for (int num4 = 0; num4 < 8; num4++)
					{
						int num5 = num4 * 8 * 8 + n * 8 + m;
						((NativeBitArray)(ref val4)).Set(num5, new SubGrid(num + m, num2 + n, num3 + num4).IsBlocked());
					}
				}
			}
		}
	}

	public static void Dispose()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (OcclusionSubGridBlocked.IsCreated)
		{
			for (int i = 0; i < OcclusionSubGridBlocked.Length; i++)
			{
				NativeBitArray val = OcclusionSubGridBlocked[i];
				if (((NativeBitArray)(ref val)).IsCreated)
				{
					((NativeBitArray)(ref val)).Dispose();
				}
			}
			OcclusionSubGridBlocked.Dispose();
		}
		if (ReturnHolder.IsCreated)
		{
			ReturnHolder.Dispose();
		}
	}

	private static void WriteGridToFile(int length, NativeArray<NativeBitArray> data)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			using BinaryWriter binaryWriter = new BinaryWriter(File.Open(SubGridFilePath, FileMode.Create));
			binaryWriter.Write(length);
			binaryWriter.Write(OcclusionIncludeRocks);
			Enumerator<NativeBitArray> enumerator = data.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					NativeBitArray current = enumerator.Current;
					if (!((NativeBitArray)(ref current)).IsCreated)
					{
						binaryWriter.Write(0);
						continue;
					}
					binaryWriter.Write(((NativeBitArray)(ref current)).Length);
					byte[] array = new byte[(((NativeBitArray)(ref current)).Length + 7) / 8];
					((NativeBitArray)(ref current)).AsNativeArray<byte>().CopyTo(array);
					binaryWriter.Write(array);
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)ex.Message);
		}
	}

	public static bool ReadGridFromFile(string path)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			if (!File.Exists(path))
			{
				return false;
			}
			using (BinaryReader binaryReader = new BinaryReader(File.Open(path, FileMode.Open)))
			{
				int num = binaryReader.ReadInt32();
				if (binaryReader.ReadBoolean() != OcclusionIncludeRocks)
				{
					Debug.LogWarning((object)"Grid file and occlusion parameters don't match, rebuilding grid");
					binaryReader.Close();
					File.Delete(path);
					return false;
				}
				OcclusionSubGridBlocked = new NativeArray<NativeBitArray>(num, (Allocator)4, (NativeArrayOptions)1);
				ReturnHolder = new NativeReference<bool>(AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)1);
				for (int i = 0; i < num; i++)
				{
					int num2 = binaryReader.ReadInt32();
					if (num2 != 0)
					{
						byte[] array = binaryReader.ReadBytes((num2 + 7) / 8);
						OcclusionSubGridBlocked[i] = new NativeBitArray(num2, AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)1);
						NativeBitArray val = OcclusionSubGridBlocked[i];
						((NativeBitArray)(ref val)).AsNativeArray<byte>().CopyFrom(array);
					}
				}
			}
			return true;
		}
		catch (Exception ex)
		{
			Debug.LogError((object)ex.Message);
			return false;
		}
	}

	[ServerVar(Help = "Tests occlusion visibility between two positions")]
	public static string serverocclusiondebug(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vector = arg.GetVector3(0, default(Vector3));
		Vector3 vector2 = arg.GetVector3(1, default(Vector3));
		SubGrid subGrid = GetSubGrid(vector);
		SubGrid subGrid2 = GetSubGrid(vector2);
		if (subGrid.Equals(default(SubGrid)) || subGrid2.Equals(default(SubGrid)))
		{
			return $"Invalid grid(s), positions provided: {vector} - {vector2}";
		}
		CalculatePathBetweenGrids(subGrid, subGrid2, out var pathBlocked);
		return $"Grid 1: {subGrid}, Grid 2: {subGrid2}\nPath blocked: {pathBlocked}";
	}
}


using System;
using UnityEngine;

public readonly struct Grid : IEquatable<Grid>
{
	public readonly int x;

	public readonly int y;

	public readonly int z;

	public const float Resolution = 16f;

	public const float HalfResolution = 8f;

	public Grid(int x, int y, int z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}

	public int GetOffset(float axis)
	{
		return Mathf.RoundToInt(axis / 2f / 16f);
	}

	public Vector3 GetCenterPoint()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3((float)(x - GetOffset(TerrainMeta.Size.x)) * 16f, (float)(y - GetOffset(MaxY)) * 16f, (float)(z - GetOffset(TerrainMeta.Size.z)) * 16f);
	}

	public override string ToString()
	{
		return $"(x: {x}, y: {y}, z: {z})";
	}

	public bool Equals(Grid other)
	{
		if (x == other.x && y == other.y)
		{
			return z == other.z;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(x, y, z);
	}

	public bool IsBlocked()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		return GamePhysics.CheckBounds(new Bounds(GetCenterPoint(), new Vector3(16f, 16f, 16f)), 8388608, (QueryTriggerInteraction)0);
	}

	public int GetIndex()
	{
		return GetGridIndex(x, y, z);
	}
}


using System;
using Unity.Mathematics;
using UnityEngine;

public readonly struct SubGrid : IEquatable<SubGrid>
{
	public readonly int x;

	public readonly int y;

	public readonly int z;

	public const float Resolution = 2f;

	public const float HalfResolution = 1f;

	public SubGrid(int x, int y, int z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}

	public SubGrid(int3 p)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		x = p.x;
		y = p.y;
		z = p.z;
	}

	public int GetOffset(float axis)
	{
		return Mathf.RoundToInt(axis / 2f / 2f);
	}

	public Vector3 GetCenterPoint()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3((float)(x - GetOffset(TerrainMeta.Size.x)) * 2f, (float)(y - GetOffset(MaxY)) * 2f, (float)(z - GetOffset(TerrainMeta.Size.z)) * 2f);
	}

	public override string ToString()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		return $"(x: {x}, y: {y}, z: {z}) - {GetCenterPoint()}, {IsBlocked()}";
	}

	public bool Equals(SubGrid other)
	{
		if (x == other.x && y == other.y)
		{
			return z == other.z;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(x, y, z);
	}

	public bool IsBlocked()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		for (int i = 0; i < GridOffsets.Length; i++)
		{
			Vector3 pos = GetCenterPoint() + GridOffsets[i];
			flag = false;
			if (OcclusionIncludeRocks)
			{
				flag = AntiHack.IsInsideMesh(pos);
			}
			if (!flag && !AntiHack.TestInsideTerrain(pos))
			{
				return false;
			}
		}
		if (flag)
		{
			return ((Component)((RaycastHit)(ref AntiHack.isInsideRayHit)).collider).gameObject.HasCustomTag(GameObjectTag.AllowBarricadePlacement);
		}
		return true;
	}

	public int GetIndex()
	{
		return GetSubGridIndex(x, y, z);
	}

	public int GetDistance(SubGrid other)
	{
		return Mathf.Abs(x - other.x) + Mathf.Abs(y - other.y) + Mathf.Abs(z - other.z);
	}
}


using System;
using System.Runtime.CompilerServices;
using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct CalculatePathBetweenGridsJob : IJob
{
	public ServerOcclusion.SubGrid Grid1;

	public ServerOcclusion.SubGrid Grid2;

	public NativeReference<bool> PathBlocked;

	[ReadOnly]
	[NativeDisableContainerSafetyRestriction]
	public NativeArray<NativeBitArray> OcclusionSubGridBlocked;

	public int server_occlusion_blocked_grid_threshold;

	public int server_occlusion_neighbour_threshold;

	public bool server_occlusion_use_neighbour_thresholds;

	public int3 ChunkCount;

	public int3 SubChunkCount;

	private static readonly int3[] neighbours = (int3[])(object)new int3[6]
	{
		math.int3(1, 0, 0),
		math.int3(-1, 0, 0),
		math.int3(0, 1, 0),
		math.int3(0, -1, 0),
		math.int3(0, 0, 1),
		math.int3(0, 0, -1)
	};

	public void Execute()
	{
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		int neighboursChecked = 0;
		PathBlocked.Value = false;
		int num2 = Grid1.x;
		int num3 = Grid1.y;
		int num4 = Grid1.z;
		int x = Grid2.x;
		int y = Grid2.y;
		int z = Grid2.z;
		int num5 = x - Grid1.x;
		int num6 = y - Grid1.y;
		int num7 = z - Grid1.z;
		int num8 = Mathf.Abs(num5);
		int num9 = Mathf.Abs(num6);
		int num10 = Mathf.Abs(num7);
		int num11 = num8 << 1;
		int num12 = num9 << 1;
		int num13 = num10 << 1;
		int num14 = ((num5 >= 0) ? 1 : (-1));
		int num15 = ((num6 >= 0) ? 1 : (-1));
		int num16 = ((num7 >= 0) ? 1 : (-1));
		int3 nStep = -math.int3(num14, num15, num16);
		int num17;
		int num18;
		if (num8 >= num9 && num8 >= num10)
		{
			num17 = num12 - num8;
			num18 = num13 - num8;
			for (int i = 0; i < num8; i++)
			{
				ServerOcclusion.SubGrid grid = new ServerOcclusion.SubGrid(num2, num3, num4);
				if (!AddToGridArea(grid, nStep, ref neighboursChecked) && ++num > server_occlusion_blocked_grid_threshold)
				{
					PathBlocked.Value = true;
					break;
				}
				if (num17 > 0)
				{
					num3 += num15;
					num17 -= num11;
				}
				if (num18 > 0)
				{
					num4 += num16;
					num18 -= num11;
				}
				num17 += num12;
				num18 += num13;
				num2 += num14;
			}
			return;
		}
		if (num9 >= num8 && num9 >= num10)
		{
			num17 = num11 - num9;
			num18 = num13 - num9;
			for (int j = 0; j < num9; j++)
			{
				ServerOcclusion.SubGrid grid2 = new ServerOcclusion.SubGrid(num2, num3, num4);
				if (!AddToGridArea(grid2, nStep, ref neighboursChecked) && ++num > server_occlusion_blocked_grid_threshold)
				{
					PathBlocked.Value = true;
					break;
				}
				if (num17 > 0)
				{
					num2 += num14;
					num17 -= num12;
				}
				if (num18 > 0)
				{
					num4 += num16;
					num18 -= num12;
				}
				num17 += num11;
				num18 += num13;
				num3 += num15;
			}
			return;
		}
		num17 = num12 - num10;
		num18 = num11 - num10;
		for (int k = 0; k < num10; k++)
		{
			ServerOcclusion.SubGrid grid3 = new ServerOcclusion.SubGrid(num2, num3, num4);
			if (!AddToGridArea(grid3, nStep, ref neighboursChecked) && ++num > server_occlusion_blocked_grid_threshold)
			{
				PathBlocked.Value = true;
				break;
			}
			if (num17 > 0)
			{
				num3 += num15;
				num17 -= num13;
			}
			if (num18 > 0)
			{
				num2 += num14;
				num18 -= num13;
			}
			num17 += num12;
			num18 += num11;
			num4 += num16;
		}
	}

	private bool IsValidGrid(int3 p)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (p.x < 0 || p.y < 0 || p.z < 0)
		{
			return false;
		}
		if (p.x >= ChunkCount.x || p.y >= ChunkCount.y || p.z >= ChunkCount.z)
		{
			return false;
		}
		return true;
	}

	private bool IsValidSubGrid(int3 p)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (p.x < 0 || p.y < 0 || p.z < 0)
		{
			return false;
		}
		if (p.x >= SubChunkCount.x || p.y >= SubChunkCount.y || p.z >= SubChunkCount.z)
		{
			return false;
		}
		return true;
	}

	private bool AddNeighbours(ServerOcclusion.SubGrid grid, int3 nStep)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		int3 val = math.int3(grid.x, grid.y, grid.z);
		for (int i = 0; i < neighbours.Length; i++)
		{
			int3 val2 = neighbours[i];
			if (!math.any(val2 == nStep))
			{
				int3 p = val + val2;
				if (IsValidSubGrid(p) && !IsBlocked(p))
				{
					return true;
				}
			}
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private int GetGridIndex(int x, int y, int z)
	{
		return z * ChunkCount.x * ChunkCount.y + y * ChunkCount.z + x;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private bool IsBlocked(ServerOcclusion.SubGrid grid)
	{
		return IsBlocked(grid.x, grid.y, grid.z);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private bool IsBlocked(int3 p)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return IsBlocked(p.x, p.y, p.z);
	}

	private bool IsBlocked(int x, int y, int z)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		int result;
		int num = Math.DivRem(x, 8, out result);
		int result2;
		int num2 = Math.DivRem(y, 8, out result2);
		int result3;
		int num3 = Math.DivRem(z, 8, out result3);
		int gridIndex = GetGridIndex(num, num2, num3);
		NativeBitArray val = (NativeBitArray)(IsValidGrid(math.int3(num, num2, num3)) ? OcclusionSubGridBlocked[gridIndex] : default(NativeBitArray));
		int num4 = result3 * 8 * 8 + result2 * 8 + result;
		if (((NativeBitArray)(ref val)).IsCreated)
		{
			return ((NativeBitArray)(ref val)).IsSet(num4);
		}
		return false;
	}

	private bool AddToGridArea(ServerOcclusion.SubGrid grid, int3 nStep, ref int neighboursChecked)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (!IsBlocked(grid))
		{
			return true;
		}
		if (!server_occlusion_use_neighbour_thresholds || ++neighboursChecked <= server_occlusion_neighbour_threshold)
		{
			return AddNeighbours(grid, nStep);
		}
		return false;
	}
}


using System;

[AttributeUsage(AttributeTargets.Property)]
public class SyncAttribute : Attribute
{
	public bool Pack { get; set; } = true;

	public bool Autosave { get; set; }

	public bool RequireChange { get; set; } = true;
}


using UnityEngine;

public class DisableIfDlssNotSupported : MonoBehaviour
{
	private void OnEnable()
	{
		((Component)this).gameObject.SetActive(false);
	}
}


using UnityEngine;

public class NVidiaReflex : MonoBehaviour
{
}


using System;
using UnityEngine;

[Serializable]
public class PIDController
{
	[SerializeField]
	public float p;

	[SerializeField]
	public float i;

	[SerializeField]
	public float d;

	private float oldError;

	private float integralSum;

	public float Update(float dt, float current, float target)
	{
		float num = target - current;
		float num2 = p * num;
		float num3 = (num - oldError) / dt;
		oldError = num;
		float num4 = d * num3;
		integralSum += num * dt;
		float num5 = i * integralSum;
		return num2 + num5 + num4;
	}
}


public enum BlurType
{
	StandardGauss,
	SgxGauss
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class BlurTypeParameter : ParameterOverride<BlurType>
{
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class FixedIntParameter : ParameterOverride<int>
{
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(BlurOptimizedRenderer), PostProcessEvent.AfterStack, "Custom/BlurOptimized", true)]
public class BlurOptimized : PostProcessEffectSettings
{
	[Range(0f, 2f)]
	public FixedIntParameter downsample = new FixedIntParameter
	{
		value = 0
	};

	[Range(1f, 4f)]
	public FixedIntParameter blurIterations = new FixedIntParameter
	{
		value = 1
	};

	[Range(0f, 10f)]
	public FloatParameter blurSize = new FloatParameter
	{
		value = 0f
	};

	public FloatParameter fadeToBlurDistance = new FloatParameter
	{
		value = 0f
	};

	public BlurTypeParameter blurType = new BlurTypeParameter
	{
		value = BlurType.StandardGauss
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class BlurOptimizedRenderer : PostProcessEffectRenderer<BlurOptimized>
{
	private int dataProperty = Shader.PropertyToID("_data");

	private Shader blurShader;

	public override void Init()
	{
		base.Init();
		blurShader = Shader.Find("Hidden/PostProcessing/BlurOptimized");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("BlurOptimized");
		int value = base.settings.downsample.value;
		float value2 = base.settings.fadeToBlurDistance.value;
		float value3 = base.settings.blurSize.value;
		int value4 = base.settings.blurIterations.value;
		BlurType value5 = base.settings.blurType.value;
		float num = 1f / (1f * (float)(1 << value));
		float num2 = 1f / Mathf.Clamp(value2, 0.001f, 10000f);
		PropertySheet propertySheet = context.propertySheets.Get(blurShader);
		propertySheet.properties.SetVector("_Parameter", new Vector4(value3 * num, (0f - value3) * num, num2, 0f));
		int num3 = context.width >> value;
		int num4 = context.height >> value;
		int num5 = Shader.PropertyToID("_BlurRT1");
		int num6 = Shader.PropertyToID("_BlurRT2");
		command.GetTemporaryRT(num5, num3, num4, 0, (FilterMode)1, context.sourceFormat, (RenderTextureReadWrite)0);
		command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(num5), propertySheet, 0, clear: false, null);
		int num7 = ((value5 != 0) ? 2 : 0);
		for (int i = 0; i < value4; i++)
		{
			float num8 = (float)i * 1f;
			propertySheet.properties.SetVector("_Parameter", new Vector4(value3 * num + num8, (0f - value3) * num - num8, num2, 0f));
			command.GetTemporaryRT(num6, num3, num4, 0, (FilterMode)1, context.sourceFormat);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), RenderTargetIdentifier.op_Implicit(num6), propertySheet, 1 + num7, clear: false, null);
			command.ReleaseTemporaryRT(num5);
			command.GetTemporaryRT(num5, num3, num4, 0, (FilterMode)1, context.sourceFormat);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num6), RenderTargetIdentifier.op_Implicit(num5), propertySheet, 2 + num7, clear: false, null);
			command.ReleaseTemporaryRT(num6);
		}
		if (value2 <= 0f)
		{
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), context.destination, clear: false, null);
		}
		else
		{
			command.SetGlobalTexture("_Source", context.source);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), context.destination, propertySheet, 5, clear: false, null);
		}
		command.ReleaseTemporaryRT(num5);
		command.EndSample("BlurOptimized");
	}
}


using UnityEngine;

[CreateAssetMenu]
public class CustomPostEffectsResources : ScriptableObject
{
	public Shader[] shaders;
}


public enum DOFBlurSampleCount
{
	Low,
	Medium,
	High,
	VeryHigh
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public class DOFBlurSampleCountParameter : ParameterOverride<DOFBlurSampleCount>
{
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(DepthOfFieldEffectRenderer), "Unity/Depth of Field (Custom)", false)]
public class DepthOfFieldEffect : PostProcessEffectSettings
{
	public FloatParameter focalLength = new FloatParameter
	{
		value = 10f
	};

	public FloatParameter focalSize = new FloatParameter
	{
		value = 0.05f
	};

	public FloatParameter aperture = new FloatParameter
	{
		value = 11.5f
	};

	[Range(0f, 3f)]
	public FloatParameter anamorphicSqueeze = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	public FloatParameter anamorphicBarrel = new FloatParameter
	{
		value = 0f
	};

	public FloatParameter maxBlurSize = new FloatParameter
	{
		value = 2f
	};

	public BoolParameter highResolution = new BoolParameter
	{
		value = true
	};

	public DOFBlurSampleCountParameter blurSampleCount = new DOFBlurSampleCountParameter
	{
		value = DOFBlurSampleCount.Low
	};

	public Transform focalTransform;
}


using ConVar;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class DepthOfFieldEffectRenderer : PostProcessEffectRenderer<DepthOfFieldEffect>
{
	private float focalDistance01 = 10f;

	private float internalBlurWidth = 1f;

	private Shader dofShader;

	public override void Init()
	{
		dofShader = Shader.Find("Hidden/PostProcessing/DepthOfFieldEffect");
	}

	private float FocalDistance01(Camera cam, float worldDist)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		return cam.WorldToViewportPoint((worldDist - cam.nearClipPlane) * ((Component)cam).transform.forward + ((Component)cam).transform.position).z / (cam.farClipPlane - cam.nearClipPlane);
	}

	private void WriteCoc(PostProcessRenderContext context, PropertySheet sheet)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		RenderTargetIdentifier source = context.source;
		RenderTextureFormat sourceFormat = context.sourceFormat;
		float num = 1f;
		int num2 = context.width / 2;
		int num3 = context.height / 2;
		int num4 = Shader.PropertyToID("DOFtemp1");
		int num5 = Shader.PropertyToID("DOFtemp2");
		command.GetTemporaryRT(num5, num2, num3, 0, (FilterMode)1, sourceFormat);
		command.BlitFullscreenTriangle(source, RenderTargetIdentifier.op_Implicit(num5), sheet, 1, clear: false, null);
		float num6 = internalBlurWidth * num;
		sheet.properties.SetVector("_Offsets", new Vector4(0f, num6, 0f, num6));
		command.GetTemporaryRT(num4, num2, num3, 0, (FilterMode)1, sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), RenderTargetIdentifier.op_Implicit(num4), sheet, 0, clear: false, null);
		command.ReleaseTemporaryRT(num5);
		sheet.properties.SetVector("_Offsets", new Vector4(num6, 0f, 0f, num6));
		command.GetTemporaryRT(num5, num2, num3, 0, (FilterMode)1, sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num4), RenderTargetIdentifier.op_Implicit(num5), sheet, 0, clear: false, null);
		command.ReleaseTemporaryRT(num4);
		command.SetGlobalTexture("_FgOverlap", RenderTargetIdentifier.op_Implicit(num5));
		command.BlitFullscreenTriangle(source, source, sheet, 3, (RenderBufferLoadAction)0, null);
		command.ReleaseTemporaryRT(num5);
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		PropertySheet propertySheet = context.propertySheets.Get(dofShader);
		CommandBuffer command = context.command;
		int width = context.width;
		int height = context.height;
		RenderTextureFormat sourceFormat = context.sourceFormat;
		bool value = base.settings.highResolution.value;
		DOFBlurSampleCountParameter blurSampleCount = base.settings.blurSampleCount;
		float value2 = base.settings.focalSize.value;
		float value3 = base.settings.focalLength.value;
		float value4 = base.settings.aperture.value;
		float value5 = base.settings.maxBlurSize.value;
		int num = Shader.PropertyToID("DOFrtLow");
		int num2 = Shader.PropertyToID("DOFrtLow2");
		value4 = Mathf.Clamp(value4, 1f, 32f);
		value5 = Mathf.Clamp(value5, 0.1f, 32f * ((float)context.height / 1080f));
		value2 = Mathf.Clamp(value2, 0f, 2f);
		internalBlurWidth = Mathf.Max(value5, 0f);
		focalDistance01 = FocalDistance01(context.camera, value3);
		propertySheet.properties.SetVector("_CurveParams", new Vector4(1f, value2, value4 / 10f, focalDistance01));
		propertySheet.properties.SetVector("_DistortionParams", new Vector4((float)base.settings.anamorphicSqueeze, (float)base.settings.anamorphicBarrel * 2f, 0f, 0f));
		if (value)
		{
			internalBlurWidth *= 2f;
		}
		WriteCoc(context, propertySheet);
		if (Graphics.dof_debug)
		{
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 5, clear: false, null);
			return;
		}
		command.GetTemporaryRT(num, width >> 1, height >> 1, 0, (FilterMode)1, sourceFormat);
		command.GetTemporaryRT(num2, width >> 1, height >> 1, 0, (FilterMode)1, sourceFormat);
		int pass = 2;
		if ((float)base.settings.anamorphicSqueeze > 0f || (float)base.settings.anamorphicBarrel > 0f)
		{
			command.EnableShaderKeyword("ANAMORPHIC_BOKEH");
		}
		else
		{
			command.DisableShaderKeyword("ANAMORPHIC_BOKEH");
		}
		propertySheet.properties.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0.025f, internalBlurWidth));
		propertySheet.properties.SetInt("_BlurCountMode", (int)blurSampleCount.value);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, pass, clear: false, null);
		command.ReleaseTemporaryRT(num);
		command.ReleaseTemporaryRT(num2);
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(DoubleVisionRenderer), PostProcessEvent.AfterStack, "Custom/DoubleVision", true)]
public class DoubleVision : PostProcessEffectSettings
{
	[Range(0f, 1f)]
	public Vector2Parameter displace = new Vector2Parameter
	{
		value = Vector2.zero
	};

	[Range(0f, 1f)]
	public FloatParameter amount = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class DoubleVisionRenderer : PostProcessEffectRenderer<DoubleVision>
{
	private int displaceProperty = Shader.PropertyToID("_displace");

	private int amountProperty = Shader.PropertyToID("_amount");

	private Shader doubleVisionShader;

	public override void Init()
	{
		base.Init();
		doubleVisionShader = Shader.Find("Hidden/PostProcessing/DoubleVision");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("DoubleVision");
		PropertySheet propertySheet = context.propertySheets.Get(doubleVisionShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetVector(displaceProperty, Vector4.op_Implicit(base.settings.displace.value));
		propertySheet.properties.SetFloat(amountProperty, base.settings.amount.value);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("DoubleVision");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(FlashbangEffectRenderer), PostProcessEvent.AfterStack, "Custom/FlashbangEffect", false)]
public class FlashbangEffect : PostProcessEffectSettings
{
	[Range(0f, 1f)]
	public FloatParameter burnIntensity = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	public FloatParameter whiteoutIntensity = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class FlashbangEffectRenderer : PostProcessEffectRenderer<FlashbangEffect>
{
	public static bool needsCapture;

	private Shader flashbangEffectShader;

	private RenderTexture screenRT;

	public override void Init()
	{
		base.Init();
		flashbangEffectShader = Shader.Find("Hidden/PostProcessing/FlashbangEffect");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		if (!Application.isPlaying)
		{
			context.command.BlitFullscreenTriangle(context.source, context.destination, clear: false, null);
			return;
		}
		CommandBuffer command = context.command;
		CheckCreateRenderTexture(ref screenRT, "Flashbang", context.width, context.height, context.sourceFormat);
		command.BeginSample("FlashbangEffect");
		if (needsCapture)
		{
			command.CopyTexture(context.source, RenderTargetIdentifier.op_Implicit((Texture)(object)screenRT));
			needsCapture = false;
		}
		PropertySheet propertySheet = context.propertySheets.Get(flashbangEffectShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetFloat("_BurnIntensity", base.settings.burnIntensity.value);
		propertySheet.properties.SetFloat("_WhiteoutIntensity", base.settings.whiteoutIntensity.value);
		if (Object.op_Implicit((Object)(object)screenRT))
		{
			propertySheet.properties.SetTexture("_BurnOverlay", (Texture)(object)screenRT);
		}
		context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("FlashbangEffect");
	}

	public override void Release()
	{
		base.Release();
		SafeDestroyRenderTexture(ref screenRT);
	}

	private static void CheckCreateRenderTexture(ref RenderTexture rt, string name, int width, int height, RenderTextureFormat format)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Expected O, but got Unknown
		if ((Object)(object)rt == (Object)null || ((Texture)rt).width != width || ((Texture)rt).height != height)
		{
			SafeDestroyRenderTexture(ref rt);
			rt = new RenderTexture(width, height, 0, format)
			{
				hideFlags = (HideFlags)52
			};
			((Object)rt).name = name;
			((Texture)rt).wrapMode = (TextureWrapMode)1;
			rt.Create();
		}
	}

	private static void SafeDestroyRenderTexture(ref RenderTexture rt)
	{
		if ((Object)(object)rt != (Object)null)
		{
			rt.Release();
			Object.DestroyImmediate((Object)(object)rt);
			rt = null;
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(FrostRenderer), PostProcessEvent.AfterStack, "Custom/Frost", true)]
public class Frost : PostProcessEffectSettings
{
	[Range(0f, 16f)]
	public FloatParameter scale = new FloatParameter
	{
		value = 0f
	};

	public BoolParameter enableVignette = new BoolParameter
	{
		value = true
	};

	[Range(0f, 100f)]
	public FloatParameter sharpness = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 100f)]
	public FloatParameter darkness = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class FrostRenderer : PostProcessEffectRenderer<Frost>
{
	private int scaleProperty = Shader.PropertyToID("_scale");

	private int sharpnessProperty = Shader.PropertyToID("_sharpness");

	private int darknessProperty = Shader.PropertyToID("_darkness");

	private Shader frostShader;

	public override void Init()
	{
		base.Init();
		frostShader = Shader.Find("Hidden/PostProcessing/Frost");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("Frost");
		PropertySheet propertySheet = context.propertySheets.Get(frostShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetFloat(scaleProperty, base.settings.scale.value);
		propertySheet.properties.SetFloat(sharpnessProperty, base.settings.sharpness.value * 0.01f);
		propertySheet.properties.SetFloat(darknessProperty, base.settings.darkness.value * 0.02f);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, base.settings.enableVignette.value ? 1 : 0, clear: false, null);
		command.EndSample("Frost");
	}
}


public enum BlendModeType
{
	Screen,
	Add
}


public enum ResolutionType
{
	Low,
	Normal,
	High
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class BlendModeTypeParameter : ParameterOverride<BlendModeType>
{
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class ResolutionTypeParameter : ParameterOverride<ResolutionType>
{
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(GodRaysRenderer), PostProcessEvent.BeforeStack, "Custom/GodRays", true)]
public class GodRays : PostProcessEffectSettings
{
	public BoolParameter UseDepth = new BoolParameter
	{
		value = true
	};

	public BlendModeTypeParameter BlendMode = new BlendModeTypeParameter
	{
		value = BlendModeType.Screen
	};

	public FloatParameter Intensity = new FloatParameter
	{
		value = 0f
	};

	public ResolutionTypeParameter Resolution = new ResolutionTypeParameter
	{
		value = ResolutionType.High
	};

	public IntParameter BlurIterations = new IntParameter
	{
		value = 2
	};

	public FloatParameter BlurRadius = new FloatParameter
	{
		value = 2f
	};

	public FloatParameter MaxRadius = new FloatParameter
	{
		value = 0.5f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class GodRaysRenderer : PostProcessEffectRenderer<GodRays>
{
	private const int PASS_SCREEN = 0;

	private const int PASS_ADD = 1;

	public Shader GodRayShader;

	public Shader ScreenClearShader;

	public Shader SkyMaskShader;

	public override void Init()
	{
		if (!Object.op_Implicit((Object)(object)GodRayShader))
		{
			GodRayShader = Shader.Find("Hidden/PostProcessing/GodRays");
		}
		if (!Object.op_Implicit((Object)(object)ScreenClearShader))
		{
			ScreenClearShader = Shader.Find("Hidden/PostProcessing/ScreenClear");
		}
		if (!Object.op_Implicit((Object)(object)SkyMaskShader))
		{
			SkyMaskShader = Shader.Find("Hidden/PostProcessing/SkyMask");
		}
	}

	private void DrawBorder(PostProcessRenderContext context, RenderTargetIdentifier buffer1)
	{
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		PropertySheet propertySheet = context.propertySheets.Get(ScreenClearShader);
		Rect value = default(Rect);
		((Rect)(ref value))..ctor(0f, (float)(context.height - 1), (float)context.width, 1f);
		Rect value2 = default(Rect);
		((Rect)(ref value2))..ctor(0f, 0f, (float)context.width, 1f);
		Rect value3 = default(Rect);
		((Rect)(ref value3))..ctor(0f, 0f, 1f, (float)context.height);
		Rect value4 = default(Rect);
		((Rect)(ref value4))..ctor((float)(context.width - 1), 0f, 1f, (float)context.height);
		context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), buffer1, propertySheet, 0, clear: false, value);
		context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), buffer1, propertySheet, 0, clear: false, value2);
		context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), buffer1, propertySheet, 0, clear: false, value3);
		context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), buffer1, propertySheet, 0, clear: false, value4);
	}

	private int GetSkyMask(PostProcessRenderContext context, ResolutionType resolution, Vector3 lightPos, int blurIterations, float blurRadius, float maxRadius)
	{
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Invalid comparison between Unknown and I4
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		Camera camera = context.camera;
		PropertySheet propertySheet = context.propertySheets.Get(SkyMaskShader);
		command.BeginSample("GodRays");
		int num;
		int num2;
		int num3;
		switch (resolution)
		{
		case ResolutionType.High:
			num = context.screenWidth;
			num2 = context.screenHeight;
			num3 = 0;
			break;
		case ResolutionType.Normal:
			num = context.screenWidth / 2;
			num2 = context.screenHeight / 2;
			num3 = 0;
			break;
		default:
			num = context.screenWidth / 4;
			num2 = context.screenHeight / 4;
			num3 = 0;
			break;
		}
		int num4 = Shader.PropertyToID("buffer1");
		int num5 = Shader.PropertyToID("buffer2");
		command.GetTemporaryRT(num4, num, num2, num3);
		propertySheet.properties.SetVector("_BlurRadius4", new Vector4(1f, 1f, 0f, 0f) * blurRadius);
		propertySheet.properties.SetVector("_LightPosition", new Vector4(lightPos.x, lightPos.y, lightPos.z, maxRadius));
		if ((camera.depthTextureMode & 1) != 0)
		{
			command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(num4), propertySheet, 1, clear: false, null);
		}
		else
		{
			command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(num4), propertySheet, 2, clear: false, null);
		}
		if ((int)camera.stereoActiveEye == 2)
		{
			DrawBorder(context, RenderTargetIdentifier.op_Implicit(num4));
		}
		float num6 = blurRadius * 0.0013020834f;
		propertySheet.properties.SetVector("_BlurRadius4", new Vector4(num6, num6, 0f, 0f));
		propertySheet.properties.SetVector("_LightPosition", new Vector4(lightPos.x, lightPos.y, lightPos.z, maxRadius));
		for (int i = 0; i < blurIterations; i++)
		{
			command.GetTemporaryRT(num5, num, num2, num3);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num4), RenderTargetIdentifier.op_Implicit(num5), propertySheet, 0, clear: false, null);
			command.ReleaseTemporaryRT(num4);
			num6 = blurRadius * (((float)i * 2f + 1f) * 6f) / 768f;
			propertySheet.properties.SetVector("_BlurRadius4", new Vector4(num6, num6, 0f, 0f));
			command.GetTemporaryRT(num4, num, num2, num3);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), RenderTargetIdentifier.op_Implicit(num4), propertySheet, 0, clear: false, null);
			command.ReleaseTemporaryRT(num5);
			num6 = blurRadius * (((float)i * 2f + 2f) * 6f) / 768f;
			propertySheet.properties.SetVector("_BlurRadius4", new Vector4(num6, num6, 0f, 0f));
		}
		command.EndSample("GodRays");
		return num4;
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		Camera camera = context.camera;
		TOD_Sky instance = TOD_Sky.Instance;
		if (!((Object)(object)instance == (Object)null))
		{
			Vector3 val = camera.WorldToViewportPoint(instance.Components.LightTransform.position);
			CommandBuffer command = context.command;
			PropertySheet propertySheet = context.propertySheets.Get(GodRayShader);
			int skyMask = GetSkyMask(context, base.settings.Resolution.value, val, base.settings.BlurIterations.value, base.settings.BlurRadius.value, base.settings.MaxRadius.value);
			Color val2 = Color.black;
			if ((double)val.z >= 0.0)
			{
				val2 = ((!instance.IsDay) ? (base.settings.Intensity.value * instance.MoonVisibility * instance.MoonRayColor) : (base.settings.Intensity.value * instance.SunVisibility * instance.SunRayColor));
			}
			propertySheet.properties.SetColor("_LightColor", val2);
			command.SetGlobalTexture("_SkyMask", RenderTargetIdentifier.op_Implicit(skyMask));
			if (base.settings.BlendMode.value == BlendModeType.Screen)
			{
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
			}
			else
			{
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 1, clear: false, null);
			}
			command.ReleaseTemporaryRT(skyMask);
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(GreyScaleRenderer), PostProcessEvent.AfterStack, "Custom/GreyScale", true)]
public class GreyScale : PostProcessEffectSettings
{
	[Range(0f, 1f)]
	public FloatParameter redLuminance = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	public FloatParameter greenLuminance = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	public FloatParameter blueLuminance = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	public FloatParameter amount = new FloatParameter
	{
		value = 0f
	};

	[ColorUsage(false, true)]
	public ColorParameter color = new ColorParameter
	{
		value = Color.white
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class GreyScaleRenderer : PostProcessEffectRenderer<GreyScale>
{
	private int dataProperty = Shader.PropertyToID("_data");

	private int colorProperty = Shader.PropertyToID("_color");

	private Shader greyScaleShader;

	public override void Init()
	{
		base.Init();
		greyScaleShader = Shader.Find("Hidden/PostProcessing/GreyScale");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("GreyScale");
		PropertySheet propertySheet = context.propertySheets.Get(greyScaleShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetVector(dataProperty, new Vector4(base.settings.redLuminance.value, base.settings.greenLuminance.value, base.settings.blueLuminance.value, base.settings.amount.value));
		propertySheet.properties.SetColor(colorProperty, base.settings.color.value);
		context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("GreyScale");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(LensDirtinessRenderer), PostProcessEvent.AfterStack, "Custom/LensDirtiness", true)]
public class LensDirtinessEffect : PostProcessEffectSettings
{
	public TextureParameter dirtinessTexture = new TextureParameter();

	public BoolParameter sceneTintsBloom = new BoolParameter
	{
		value = false
	};

	public FloatParameter gain = new FloatParameter
	{
		value = 1f
	};

	public FloatParameter threshold = new FloatParameter
	{
		value = 1f
	};

	public FloatParameter bloomSize = new FloatParameter
	{
		value = 5f
	};

	public FloatParameter dirtiness = new FloatParameter
	{
		value = 1f
	};

	public ColorParameter bloomColor = new ColorParameter
	{
		value = Color.white
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class LensDirtinessRenderer : PostProcessEffectRenderer<LensDirtinessEffect>
{
	private enum Pass
	{
		Threshold,
		Kawase,
		Compose
	}

	private int dataProperty = Shader.PropertyToID("_data");

	private Shader lensDirtinessShader;

	public override void Init()
	{
		base.Init();
		lensDirtinessShader = Shader.Find("Hidden/PostProcessing/LensDirtiness");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0308: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_0373: Unknown result type (might be due to invalid IL or missing references)
		//IL_037a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0396: Unknown result type (might be due to invalid IL or missing references)
		//IL_039d: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0410: Unknown result type (might be due to invalid IL or missing references)
		//IL_0412: Unknown result type (might be due to invalid IL or missing references)
		float value = base.settings.bloomSize.value;
		float value2 = base.settings.gain.value;
		float value3 = base.settings.threshold.value;
		float value4 = base.settings.dirtiness.value;
		Color value5 = base.settings.bloomColor.value;
		Texture value6 = base.settings.dirtinessTexture.value;
		bool value7 = base.settings.sceneTintsBloom.value;
		CommandBuffer command = context.command;
		command.BeginSample("LensDirtinessEffect");
		if (value7)
		{
			command.EnableShaderKeyword("_SCENE_TINTS_BLOOM");
		}
		PropertySheet propertySheet = context.propertySheets.Get(lensDirtinessShader);
		RenderTargetIdentifier source = context.source;
		RenderTargetIdentifier destination = context.destination;
		int width = context.width;
		int height = context.height;
		int num = Shader.PropertyToID("_RTT_BloomThreshold");
		int num2 = Shader.PropertyToID("_RTT_1");
		int num3 = Shader.PropertyToID("_RTT_2");
		int num4 = Shader.PropertyToID("_RTT_3");
		int num5 = Shader.PropertyToID("_RTT_4");
		int num6 = Shader.PropertyToID("_RTT_Bloom_1");
		int num7 = Shader.PropertyToID("_RTT_Bloom_2");
		propertySheet.properties.SetFloat("_Gain", value2);
		propertySheet.properties.SetFloat("_Threshold", value3);
		command.GetTemporaryRT(num, width / 2, height / 2, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(source, RenderTargetIdentifier.op_Implicit(num), propertySheet, 0, clear: false, null);
		propertySheet.properties.SetVector("_Offset", new Vector4(1f / (float)width, 1f / (float)height, 0f, 0f) * 2f);
		command.GetTemporaryRT(num2, width / 2, height / 2, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num), RenderTargetIdentifier.op_Implicit(num2), propertySheet, 1, clear: false, null);
		command.ReleaseTemporaryRT(num);
		command.GetTemporaryRT(num3, width / 4, height / 4, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num2), RenderTargetIdentifier.op_Implicit(num3), propertySheet, 1, clear: false, null);
		command.ReleaseTemporaryRT(num2);
		command.GetTemporaryRT(num4, width / 8, height / 8, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num3), RenderTargetIdentifier.op_Implicit(num4), propertySheet, 1, clear: false, null);
		command.ReleaseTemporaryRT(num3);
		command.GetTemporaryRT(num5, width / 16, height / 16, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num4), RenderTargetIdentifier.op_Implicit(num5), propertySheet, 1, clear: false, null);
		command.ReleaseTemporaryRT(num4);
		command.GetTemporaryRT(num6, width / 16, height / 16, 0, (FilterMode)1, context.sourceFormat);
		command.GetTemporaryRT(num7, width / 16, height / 16, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), RenderTargetIdentifier.op_Implicit(num6), clear: false, null);
		command.ReleaseTemporaryRT(num5);
		for (int i = 1; i <= 8; i++)
		{
			float num8 = value * (float)i / (float)width;
			float num9 = value * (float)i / (float)height;
			propertySheet.properties.SetVector("_Offset", new Vector4(num8, num9, 0f, 0f));
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num6), RenderTargetIdentifier.op_Implicit(num7), propertySheet, 1, clear: false, null);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num7), RenderTargetIdentifier.op_Implicit(num6), propertySheet, 1, clear: false, null);
		}
		command.SetGlobalTexture("_Bloom", RenderTargetIdentifier.op_Implicit(num7));
		propertySheet.properties.SetFloat("_Dirtiness", value4);
		propertySheet.properties.SetColor("_BloomColor", value5);
		propertySheet.properties.SetTexture("_DirtinessTexture", value6);
		command.BlitFullscreenTriangle(source, destination, propertySheet, 2, clear: false, null);
		command.ReleaseTemporaryRT(num6);
		command.ReleaseTemporaryRT(num7);
		command.EndSample("LensDirtinessEffect");
	}
}


private enum Pass
{
	Threshold,
	Kawase,
	Compose
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(NightLightEffectRenderer), PostProcessEvent.BeforeStack, "Custom/NightLight", true)]
public class NightLightEffect : PostProcessEffectSettings
{
	[Range(0f, 25f)]
	public FloatParameter distance = new FloatParameter
	{
		value = 5f
	};

	[Range(0f, 1f)]
	public FloatParameter fadeFraction = new FloatParameter
	{
		value = 0.1f
	};

	[Range(0f, 1f)]
	public FloatParameter brightness = new FloatParameter
	{
		value = 0.1f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class NightLightEffectRenderer : PostProcessEffectRenderer<NightLightEffect>
{
	private int distanceProperty = Shader.PropertyToID("_distance");

	private int fadeFractionProperty = Shader.PropertyToID("_fadefraction");

	private int brightnessProperty = Shader.PropertyToID("_brightness");

	private Shader nightlightShader;

	public override void Init()
	{
		base.Init();
		nightlightShader = Shader.Find("Hidden/PostProcessing/NightLightShader");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("NightLight");
		PropertySheet propertySheet = context.propertySheets.Get(nightlightShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetFloat(distanceProperty, base.settings.distance.value);
		propertySheet.properties.SetFloat(fadeFractionProperty, base.settings.fadeFraction.value);
		propertySheet.properties.SetFloat(brightnessProperty, base.settings.brightness.value);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("NightLight");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(PhotoFilterRenderer), PostProcessEvent.AfterStack, "Custom/PhotoFilter", true)]
public class PhotoFilter : PostProcessEffectSettings
{
	public ColorParameter color = new ColorParameter
	{
		value = Color.white
	};

	[Range(0f, 1f)]
	public FloatParameter density = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class PhotoFilterRenderer : PostProcessEffectRenderer<PhotoFilter>
{
	private int rgbProperty = Shader.PropertyToID("_rgb");

	private int densityProperty = Shader.PropertyToID("_density");

	private Shader greyScaleShader;

	public override void Init()
	{
		base.Init();
		greyScaleShader = Shader.Find("Hidden/PostProcessing/PhotoFilter");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("PhotoFilter");
		PropertySheet propertySheet = context.propertySheets.Get(greyScaleShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetColor(rgbProperty, base.settings.color.value);
		propertySheet.properties.SetFloat(densityProperty, base.settings.density.value);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("PhotoFilter");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(RadialBlurRenderer), PostProcessEvent.AfterStack, "Custom/RadialBlur", true)]
public class RadialBlur : PostProcessEffectSettings
{
	[Header("Radial Controls")]
	public Vector2Parameter center = new Vector2Parameter
	{
		value = new Vector2(0.5f, 0.5f)
	};

	[Range(0.1f, 2f)]
	public FloatParameter start = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 2f)]
	public FloatParameter amount = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 3f)]
	[Header("Blur Quality")]
	public FixedIntParameter downsample = new FixedIntParameter
	{
		value = 1
	};

	[Range(1f, 4f)]
	public FixedIntParameter iterations = new FixedIntParameter
	{
		value = 2
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class RadialBlurRenderer : PostProcessEffectRenderer<RadialBlur>
{
	private Shader shader;

	private int rt1ID = Shader.PropertyToID("_BlurRT1");

	private int rt2ID = Shader.PropertyToID("_BlurRT2");

	private int paramsID = Shader.PropertyToID("_Params");

	public override void Init()
	{
		base.Init();
		shader = Shader.Find("Hidden/PostProcessing/RadialBlur");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("RadialBlur");
		if (Mathf.Approximately((float)base.settings.start, 1f) && Mathf.Approximately((float)base.settings.amount, 0f))
		{
			command.BlitFullscreenTriangle(context.source, context.destination, clear: false, null);
		}
		else
		{
			PropertySheet propertySheet = context.propertySheets.Get(shader);
			propertySheet.properties.SetVector(paramsID, new Vector4(base.settings.center.value.x, base.settings.center.value.y, (float)base.settings.start, (float)base.settings.amount));
			int num = context.width >> (int)base.settings.downsample;
			int num2 = context.height >> (int)base.settings.downsample;
			int num3 = (int)base.settings.iterations / 2;
			int num4 = (int)base.settings.iterations % 2;
			command.GetTemporaryRT(rt1ID, num, num2, 0, (FilterMode)1, context.sourceFormat, (RenderTextureReadWrite)0);
			command.GetTemporaryRT(rt2ID, num, num2, 0, (FilterMode)1, context.sourceFormat, (RenderTextureReadWrite)0);
			command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(rt1ID), propertySheet, 0, clear: false, null);
			if ((int)base.settings.iterations > 1)
			{
				for (int i = 0; i < num3; i++)
				{
					command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(rt1ID), RenderTargetIdentifier.op_Implicit(rt2ID), propertySheet, 1, clear: false, null);
					if (i == num3 - 1 && num4 == 0)
					{
						command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(rt2ID), context.destination, propertySheet, 1, clear: false, null);
					}
					else
					{
						command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(rt2ID), RenderTargetIdentifier.op_Implicit(rt1ID), propertySheet, 1, clear: false, null);
					}
				}
			}
			if (num4 > 0)
			{
				command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(rt1ID), context.destination, propertySheet, 1, clear: false, null);
			}
			command.ReleaseTemporaryRT(rt1ID);
			command.ReleaseTemporaryRT(rt2ID);
		}
		command.EndSample("RadialBlur");
	}
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(RustTemporalAntialiasingRenderer), PostProcessEvent.BeforeStack, "Custom/RustTemporalAntialiasing", false)]
public sealed class RustTemporalAntialiasing : PostProcessEffectSettings
{
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class Jitter
{
	private readonly Vector2[] haltonSequence = (Vector2[])(object)new Vector2[16]
	{
		new Vector2(0.5f, 0.333333f),
		new Vector2(0.25f, 0.666667f),
		new Vector2(0.75f, 0.111111f),
		new Vector2(0.125f, 0.444444f),
		new Vector2(0.625f, 0.777778f),
		new Vector2(0.375f, 0.222222f),
		new Vector2(0.875f, 0.555556f),
		new Vector2(0.0625f, 0.888889f),
		new Vector2(0.5625f, 0.037037f),
		new Vector2(0.3125f, 0.37037f),
		new Vector2(0.8125f, 0.703704f),
		new Vector2(0.1875f, 0.148148f),
		new Vector2(0.6875f, 0.481481f),
		new Vector2(0.4375f, 0.814815f),
		new Vector2(0.9375f, 0.259259f),
		new Vector2(1f / 32f, 0.592593f)
	};

	public int SampleIndex { get; private set; }

	public int SampleCount { get; private set; } = 8;

	public Vector2 Offset { get; private set; } = Vector2.zero;

	public Vector2 TexelOffset { get; private set; } = Vector2.zero;

	public Jitter()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		SampleCount = haltonSequence.Length;
	}

	private Matrix4x4 GetJitteredProjectionMatrix(Camera camera)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		Offset = haltonSequence[++SampleIndex % 8] - new Vector2(0.5f, 0.5f);
		TexelOffset = new Vector2(Offset.x / (float)camera.pixelWidth, Offset.y / (float)camera.pixelHeight);
		return RuntimeUtilities.GetJitteredPerspectiveProjectionMatrix(camera, Offset);
	}

	public void ConfigureCameraJitter(PostProcessRenderContext context)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		Camera camera = context.camera;
		camera.nonJitteredProjectionMatrix = camera.projectionMatrix;
		camera.projectionMatrix = GetJitteredProjectionMatrix(camera);
		camera.useJitteredProjectionMatrixForTransparentRendering = true;
	}
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public sealed class RustTemporalAntialiasingRenderer : PostProcessEffectRenderer<RustTemporalAntialiasing>
{
	private const string BUFFER_NAME = "RustTemporalAntiAliasing";

	private static readonly int historyTextureId = Shader.PropertyToID("_HistoryTex");

	private static readonly int jitterTexelOffsetId = Shader.PropertyToID("_JitterTexelOffset");

	public readonly Jitter JitterSettings = new Jitter();

	private RenderTexture[] historyTextures = (RenderTexture[])(object)new RenderTexture[2];

	private readonly RenderTargetIdentifier[] multipleRenderTargets = (RenderTargetIdentifier[])(object)new RenderTargetIdentifier[2];

	private int pingPongValue;

	private Shader postProcessShader;

	public static RustTemporalAntialiasingRenderer Instance { get; private set; }

	public override void Init()
	{
		if (Instance == null)
		{
			Instance = this;
		}
		postProcessShader = Shader.Find("Hidden/PostProcessing/RustTemporalAntialiasing");
		if ((Object)(object)postProcessShader == (Object)null)
		{
			Debug.LogError((object)"Failed to initialize RustTemporalAntialiasing as the shader couldn't be found!");
		}
	}

	private bool IsValid()
	{
		return (Object)(object)postProcessShader != (Object)null;
	}

	private RenderTexture ConvertTextureToMatchCamera(RenderTexture texture, PostProcessRenderContext context)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Expected O, but got Unknown
		if ((Object)(object)texture == (Object)null || ((Texture)texture).width != context.width || ((Texture)texture).height != context.height)
		{
			if (texture != null)
			{
				texture.Release();
			}
			texture = new RenderTexture(context.width, context.height, 0, context.sourceFormat);
		}
		return texture;
	}

	private void RecreateRenderTexturesIfNeeded(PostProcessRenderContext context)
	{
		for (int i = 0; i < historyTextures.Length; i++)
		{
			historyTextures[i] = ConvertTextureToMatchCamera(historyTextures[i], context);
		}
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (!IsValid())
		{
			context.command.BlitFullscreenTriangle(context.source, context.destination, clear: false, null);
			return;
		}
		Camera camera = context.camera;
		camera.depthTextureMode = (DepthTextureMode)(camera.depthTextureMode | 5);
		JitterSettings.ConfigureCameraJitter(context);
		RecreateRenderTexturesIfNeeded(context);
		PropertySheet propertySheet = context.propertySheets.Get(postProcessShader);
		CommandBuffer command = context.command;
		RenderTexture val = historyTextures[pingPongValue++ % 2];
		RenderTexture val2 = historyTextures[pingPongValue++ % 2];
		pingPongValue++;
		multipleRenderTargets[0] = context.destination;
		multipleRenderTargets[1] = RenderTargetIdentifier.op_Implicit((Texture)(object)val);
		command.BeginSample("RustTemporalAntiAliasing");
		command.SetGlobalVector(jitterTexelOffsetId, Vector4.op_Implicit(JitterSettings.TexelOffset));
		command.SetGlobalTexture(historyTextureId, RenderTargetIdentifier.op_Implicit((Texture)(object)val2));
		command.BlitFullscreenTriangle(context.source, multipleRenderTargets, RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), propertySheet, 0, clear: false, null);
		command.EndSample("RustTemporalAntiAliasing");
	}

	public override void Release()
	{
		for (int i = 0; i < historyTextures.Length; i++)
		{
			RenderTexture obj = historyTextures[i];
			if (obj != null)
			{
				obj.Release();
			}
			historyTextures[i] = null;
		}
	}
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class RustTemporalAntialiasingOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;
}


public enum OverlayBlendMode
{
	Additive,
	ScreenBlend,
	Multiply,
	Overlay,
	AlphaBlend,
	AdditiveNonLit,
	AlpbaBlendConst
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class OverlayBlendModeParameter : ParameterOverride<OverlayBlendMode>
{
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(ScreenOverlayRenderer), PostProcessEvent.AfterStack, "Custom/ScreenOverlay", true)]
public class ScreenOverlay : PostProcessEffectSettings
{
	public OverlayBlendModeParameter blendMode = new OverlayBlendModeParameter
	{
		value = OverlayBlendMode.Multiply
	};

	public FloatParameter intensity = new FloatParameter
	{
		value = 0f
	};

	public TextureParameter texture = new TextureParameter
	{
		value = null
	};

	public TextureParameter normals = new TextureParameter
	{
		value = null
	};

	public BoolParameter respectUseLightingConvar = new BoolParameter
	{
		value = false
	};
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class ScreenOverlayRenderer : PostProcessEffectRenderer<ScreenOverlay>
{
	private Shader overlayShader;

	public override void Init()
	{
		base.Init();
		overlayShader = Shader.Find("Hidden/PostProcessing/ScreenOverlay");
	}

	public override void Render(PostProcessRenderContext context)
	{
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(SharpenAndVignetteRenderer), PostProcessEvent.AfterStack, "Custom/SharpenAndVignette", true)]
public class SharpenAndVignette : PostProcessEffectSettings
{
	[Header("Sharpen")]
	public BoolParameter applySharpen = new BoolParameter
	{
		value = true
	};

	[Range(0f, 5f)]
	public FloatParameter strength = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 1f)]
	public FloatParameter clamp = new FloatParameter
	{
		value = 1f
	};

	[Header("Vignette")]
	public BoolParameter applyVignette = new BoolParameter
	{
		value = true
	};

	[Range(-100f, 100f)]
	public FloatParameter sharpness = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 100f)]
	public FloatParameter darkness = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class SharpenAndVignetteRenderer : PostProcessEffectRenderer<SharpenAndVignette>
{
	private Shader sharpenAndVigenetteShader;

	public override void Init()
	{
		base.Init();
		sharpenAndVigenetteShader = Shader.Find("Hidden/PostProcessing/SharpenAndVignette");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("SharpenAndVignette");
		PropertySheet propertySheet = context.propertySheets.Get(sharpenAndVigenetteShader);
		propertySheet.properties.Clear();
		bool value = base.settings.applySharpen.value;
		bool value2 = base.settings.applyVignette.value;
		if (value)
		{
			propertySheet.properties.SetFloat("_px", 1f / (float)Screen.width);
			propertySheet.properties.SetFloat("_py", 1f / (float)Screen.height);
			propertySheet.properties.SetFloat("_strength", base.settings.strength.value);
			propertySheet.properties.SetFloat("_clamp", base.settings.clamp.value);
		}
		if (value2)
		{
			propertySheet.properties.SetFloat("_sharpness", base.settings.sharpness.value * 0.01f);
			propertySheet.properties.SetFloat("_darkness", base.settings.darkness.value * 0.02f);
		}
		if (value && !value2)
		{
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		}
		else if (value && value2)
		{
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 1, clear: false, null);
		}
		else if (!value && value2)
		{
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 2, clear: false, null);
		}
		else
		{
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		}
		command.EndSample("SharpenAndVignette");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(UnderWaterEffectRenderer), PostProcessEvent.AfterStack, "Custom/UnderWaterEffect", false)]
public class UnderwaterPostEffect : PostProcessEffectSettings
{
	[Header("Wiggle")]
	public BoolParameter wiggle = new BoolParameter();

	public FloatParameter speed = new FloatParameter
	{
		value = 1f
	};

	public FloatParameter scale = new FloatParameter
	{
		value = 12f
	};

	[Header("Water Line")]
	public ColorParameter waterLineColor = new ColorParameter();

	[Range(1f, 4f)]
	public FixedIntParameter waterLineBlurIterations = new FixedIntParameter
	{
		value = 1
	};

	[Range(0f, 10f)]
	public FloatParameter waterLineBlurSize = new FloatParameter
	{
		value = 0f
	};

	[Header("Blur")]
	[Range(0f, 2f)]
	public FixedIntParameter downsample = new FixedIntParameter
	{
		value = 0
	};

	[Range(1f, 4f)]
	public FixedIntParameter blurIterations = new FixedIntParameter
	{
		value = 1
	};

	[Range(0f, 10f)]
	public FloatParameter blurSize = new FloatParameter
	{
		value = 0f
	};

	public FloatParameter fadeToBlurDistance = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine.Rendering.PostProcessing;

public class UnderWaterEffectRenderer : PostProcessEffectRenderer<UnderwaterPostEffect>
{
	public override void Render(PostProcessRenderContext context)
	{
	}
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(WiggleRenderer), PostProcessEvent.AfterStack, "Custom/Wiggle", true)]
public class Wiggle : PostProcessEffectSettings
{
	public FloatParameter speed = new FloatParameter
	{
		value = 1f
	};

	public FloatParameter scale = new FloatParameter
	{
		value = 12f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class WiggleRenderer : PostProcessEffectRenderer<Wiggle>
{
	private int timerProperty = Shader.PropertyToID("_timer");

	private int scaleProperty = Shader.PropertyToID("_scale");

	private Shader wiggleShader;

	private float timer;

	public override void Init()
	{
		base.Init();
		wiggleShader = Shader.Find("Hidden/PostProcessing/Wiggle");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("Wiggle");
		timer += base.settings.speed.value * Time.deltaTime;
		PropertySheet propertySheet = context.propertySheets.Get(wiggleShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetFloat(timerProperty, timer);
		propertySheet.properties.SetFloat(scaleProperty, base.settings.scale.value);
		context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("Wiggle");
	}
}


using UnityEngine;

public class PostProcessVolumeLOD : MonoBehaviour, ILOD, IClientComponent
{
	public float distance;
}


using System;

public class BoundsCheck : PrefabAttribute
{
	public enum BlockType
	{
		Tree
	}

	public BlockType IsType;

	protected override Type GetIndexedType()
	{
		return typeof(BoundsCheck);
	}
}


public enum BlockType
{
	Tree
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class BoundsCheckEx
{
	public static bool ApplyBoundsChecks(this BaseEntity entity, BoundsCheck[] bounds, Vector3 pos, Quaternion rot, Vector3 scale, LayerMask rejectOnLayer)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		if (bounds.Length == 0 && LayerMask.op_Implicit(rejectOnLayer) == 0)
		{
			return true;
		}
		OBB obb = new OBB(pos + rot * Vector3.Scale(((Bounds)(ref entity.bounds)).center, scale), Vector3.Scale(((Bounds)(ref entity.bounds)).extents, scale), rot);
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapOBB(obb, list, 0x40000 | LayerMask.op_Implicit(rejectOnLayer), (QueryTriggerInteraction)2);
		SpawnableBoundsBlocker spawnableBoundsBlocker = default(SpawnableBoundsBlocker);
		foreach (Collider item in list)
		{
			if (!item.isTrigger && (((Component)item).gameObject.layer & LayerMask.op_Implicit(rejectOnLayer)) != 0)
			{
				Pool.FreeUnmanaged<Collider>(ref list);
				return false;
			}
			if (!((Component)item).TryGetComponent<SpawnableBoundsBlocker>(ref spawnableBoundsBlocker))
			{
				continue;
			}
			foreach (BoundsCheck boundsCheck in bounds)
			{
				if (spawnableBoundsBlocker.BlockType == boundsCheck.IsType)
				{
					Pool.FreeUnmanaged<Collider>(ref list);
					return false;
				}
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return true;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SpawnableBoundsBlocker : MonoBehaviour
{
	public BoundsCheck.BlockType BlockType;

	public BoxCollider BoxCollider;

	[Button("Clear Trees")]
	public void ClearTrees()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		List<TreeEntity> list = Pool.Get<List<TreeEntity>>();
		if ((Object)(object)BoxCollider != (Object)null)
		{
			GamePhysics.OverlapOBB<TreeEntity>(new OBB(((Component)this).transform.TransformPoint(BoxCollider.center), BoxCollider.size + Vector3.one, ((Component)this).transform.rotation), list, 1073741824, (QueryTriggerInteraction)2);
		}
		foreach (TreeEntity item in list)
		{
			BoundsCheck boundsCheck = PrefabAttribute.server.Find<BoundsCheck>(item.prefabID);
			if (boundsCheck != null && boundsCheck.IsType == BlockType)
			{
				item.Kill();
			}
		}
		Pool.FreeUnmanaged<TreeEntity>(ref list);
	}
}


using System;
using UnityEngine;

[Serializable]
public class ByteMap
{
	[SerializeField]
	private int size;

	[SerializeField]
	private int bytes;

	[SerializeField]
	private byte[] values;

	public int Size => size;

	public uint this[int x, int y]
	{
		get
		{
			int num = y * bytes * size + x * bytes;
			switch (bytes)
			{
			case 1:
				return values[num];
			case 2:
			{
				byte num7 = values[num];
				uint num3 = values[num + 1];
				return (uint)(num7 << 8) | num3;
			}
			case 3:
			{
				byte num6 = values[num];
				uint num3 = values[num + 1];
				uint num4 = values[num + 2];
				return (uint)(num6 << 16) | (num3 << 8) | num4;
			}
			default:
			{
				byte num2 = values[num];
				uint num3 = values[num + 1];
				uint num4 = values[num + 2];
				uint num5 = values[num + 3];
				return (uint)(num2 << 24) | (num3 << 16) | (num4 << 8) | num5;
			}
			}
		}
		set
		{
			int num = y * bytes * size + x * bytes;
			switch (bytes)
			{
			case 1:
				values[num] = (byte)(value & 0xFF);
				break;
			case 2:
				values[num] = (byte)((value >> 8) & 0xFF);
				values[num + 1] = (byte)(value & 0xFF);
				break;
			case 3:
				values[num] = (byte)((value >> 16) & 0xFF);
				values[num + 1] = (byte)((value >> 8) & 0xFF);
				values[num + 2] = (byte)(value & 0xFF);
				break;
			default:
				values[num] = (byte)((value >> 24) & 0xFF);
				values[num + 1] = (byte)((value >> 16) & 0xFF);
				values[num + 2] = (byte)((value >> 8) & 0xFF);
				values[num + 3] = (byte)(value & 0xFF);
				break;
			}
		}
	}

	public ByteMap(int size, int bytes = 1)
	{
		this.size = size;
		this.bytes = bytes;
		values = new byte[bytes * size * size];
	}

	public ByteMap(int size, byte[] values, int bytes = 1)
	{
		this.size = size;
		this.bytes = bytes;
		this.values = values;
	}
}


using System;
using UnityEngine;

[Serializable]
public sealed class ByteQuadtree
{
	public struct Element
	{
		private ByteQuadtree source;

		private int x;

		private int y;

		private int level;

		public bool IsLeaf => level == 0;

		public bool IsRoot => level == source.levels - 1;

		public int ByteMap => level;

		public uint Value => source.values[level][x, y];

		public Vector2 Coords => new Vector2((float)x, (float)y);

		public int Depth => source.levels - level - 1;

		public Element Parent
		{
			get
			{
				if (IsRoot)
				{
					throw new Exception("Element is the root and therefore has no parent.");
				}
				return new Element(source, x / 2, y / 2, level + 1);
			}
		}

		public Element Child1
		{
			get
			{
				if (IsLeaf)
				{
					throw new Exception("Element is a leaf and therefore has no children.");
				}
				return new Element(source, x * 2, y * 2, level - 1);
			}
		}

		public Element Child2
		{
			get
			{
				if (IsLeaf)
				{
					throw new Exception("Element is a leaf and therefore has no children.");
				}
				return new Element(source, x * 2 + 1, y * 2, level - 1);
			}
		}

		public Element Child3
		{
			get
			{
				if (IsLeaf)
				{
					throw new Exception("Element is a leaf and therefore has no children.");
				}
				return new Element(source, x * 2, y * 2 + 1, level - 1);
			}
		}

		public Element Child4
		{
			get
			{
				if (IsLeaf)
				{
					throw new Exception("Element is a leaf and therefore has no children.");
				}
				return new Element(source, x * 2 + 1, y * 2 + 1, level - 1);
			}
		}

		public Element MaxChild
		{
			get
			{
				Element child = Child1;
				Element child2 = Child2;
				Element child3 = Child3;
				Element child4 = Child4;
				uint value = child.Value;
				uint value2 = child2.Value;
				uint value3 = child3.Value;
				uint value4 = child4.Value;
				if (value >= value2 && value >= value3 && value >= value4)
				{
					return child;
				}
				if (value2 >= value3 && value2 >= value4)
				{
					return child2;
				}
				if (value3 >= value4)
				{
					return child3;
				}
				return child4;
			}
		}

		public Element RandChild
		{
			get
			{
				Element child = Child1;
				Element child2 = Child2;
				Element child3 = Child3;
				Element child4 = Child4;
				uint value = child.Value;
				uint value2 = child2.Value;
				uint value3 = child3.Value;
				uint value4 = child4.Value;
				float num = value + value2 + value3 + value4;
				float value5 = Random.value;
				if ((float)value / num >= value5)
				{
					return child;
				}
				if ((float)(value + value2) / num >= value5)
				{
					return child2;
				}
				if ((float)(value + value2 + value3) / num >= value5)
				{
					return child3;
				}
				return child4;
			}
		}

		public Element(ByteQuadtree source, int x, int y, int level)
		{
			this.source = source;
			this.x = x;
			this.y = y;
			this.level = level;
		}
	}

	[SerializeField]
	private int size;

	[SerializeField]
	private int levels;

	[SerializeField]
	private ByteMap[] values;

	public int Size => size;

	public Element Root => new Element(this, 0, 0, levels - 1);

	public void UpdateValues(byte[] baseValues)
	{
		size = Mathf.RoundToInt(Mathf.Sqrt((float)baseValues.Length));
		levels = Mathf.RoundToInt(Mathf.Max(Mathf.Log((float)size, 2f), 0f)) + 1;
		values = new ByteMap[levels];
		values[0] = new ByteMap(size, baseValues);
		for (int i = 1; i < levels; i++)
		{
			ByteMap byteMap = values[i - 1];
			ByteMap byteMap2 = (values[i] = CreateLevel(i));
			for (int j = 0; j < byteMap2.Size; j++)
			{
				for (int k = 0; k < byteMap2.Size; k++)
				{
					byteMap2[k, j] = byteMap[2 * k, 2 * j] + byteMap[2 * k + 1, 2 * j] + byteMap[2 * k, 2 * j + 1] + byteMap[2 * k + 1, 2 * j + 1];
				}
			}
		}
	}

	private ByteMap CreateLevel(int level)
	{
		int num = 1 << levels - level - 1;
		int bytes = 1 + (level + 3) / 4;
		return new ByteMap(num, bytes);
	}
}


using System;
using UnityEngine;

public struct Element
{
	private ByteQuadtree source;

	private int x;

	private int y;

	private int level;

	public bool IsLeaf => level == 0;

	public bool IsRoot => level == source.levels - 1;

	public int ByteMap => level;

	public uint Value => source.values[level][x, y];

	public Vector2 Coords => new Vector2((float)x, (float)y);

	public int Depth => source.levels - level - 1;

	public Element Parent
	{
		get
		{
			if (IsRoot)
			{
				throw new Exception("Element is the root and therefore has no parent.");
			}
			return new Element(source, x / 2, y / 2, level + 1);
		}
	}

	public Element Child1
	{
		get
		{
			if (IsLeaf)
			{
				throw new Exception("Element is a leaf and therefore has no children.");
			}
			return new Element(source, x * 2, y * 2, level - 1);
		}
	}

	public Element Child2
	{
		get
		{
			if (IsLeaf)
			{
				throw new Exception("Element is a leaf and therefore has no children.");
			}
			return new Element(source, x * 2 + 1, y * 2, level - 1);
		}
	}

	public Element Child3
	{
		get
		{
			if (IsLeaf)
			{
				throw new Exception("Element is a leaf and therefore has no children.");
			}
			return new Element(source, x * 2, y * 2 + 1, level - 1);
		}
	}

	public Element Child4
	{
		get
		{
			if (IsLeaf)
			{
				throw new Exception("Element is a leaf and therefore has no children.");
			}
			return new Element(source, x * 2 + 1, y * 2 + 1, level - 1);
		}
	}

	public Element MaxChild
	{
		get
		{
			Element child = Child1;
			Element child2 = Child2;
			Element child3 = Child3;
			Element child4 = Child4;
			uint value = child.Value;
			uint value2 = child2.Value;
			uint value3 = child3.Value;
			uint value4 = child4.Value;
			if (value >= value2 && value >= value3 && value >= value4)
			{
				return child;
			}
			if (value2 >= value3 && value2 >= value4)
			{
				return child2;
			}
			if (value3 >= value4)
			{
				return child3;
			}
			return child4;
		}
	}

	public Element RandChild
	{
		get
		{
			Element child = Child1;
			Element child2 = Child2;
			Element child3 = Child3;
			Element child4 = Child4;
			uint value = child.Value;
			uint value2 = child2.Value;
			uint value3 = child3.Value;
			uint value4 = child4.Value;
			float num = value + value2 + value3 + value4;
			float value5 = Random.value;
			if ((float)value / num >= value5)
			{
				return child;
			}
			if ((float)(value + value2) / num >= value5)
			{
				return child2;
			}
			if ((float)(value + value2 + value3) / num >= value5)
			{
				return child3;
			}
			return child4;
		}
	}

	public Element(ByteQuadtree source, int x, int y, int level)
	{
		this.source = source;
		this.x = x;
		this.y = y;
		this.level = level;
	}
}


using System;
using System.Collections.Generic;
using Unity.Collections;
using UnityEngine;

public static class ImageProcessing
{
	private static byte[] signaturePNG = new byte[8] { 137, 80, 78, 71, 13, 10, 26, 10 };

	private static byte[] signatureIHDR = new byte[8] { 0, 0, 0, 13, 73, 72, 68, 82 };

	public static void GaussianBlur2D(float[] data, int len1, int len2, int iterations = 1)
	{
		float[] array = data;
		float[] array2 = new float[len1 * len2];
		for (int i = 0; i < iterations; i++)
		{
			for (int j = 0; j < len1; j++)
			{
				int num = Mathf.Max(0, j - 1);
				int num2 = Mathf.Min(len1 - 1, j + 1);
				for (int k = 0; k < len2; k++)
				{
					int num3 = Mathf.Max(0, k - 1);
					int num4 = Mathf.Min(len2 - 1, k + 1);
					float num5 = array[j * len2 + k] * 4f + array[j * len2 + num3] + array[j * len2 + num4] + array[num * len2 + k] + array[num2 * len2 + k];
					array2[j * len2 + k] = num5 * 0.125f;
				}
			}
			GenericsUtil.Swap<float[]>(ref array, ref array2);
		}
		if (array != data)
		{
			Buffer.BlockCopy(array, 0, data, 0, data.Length * 4);
		}
	}

	public static void GaussianBlur2D(float[] data, int len1, int len2, int len3, int iterations = 1)
	{
		float[] src = data;
		float[] dst = new float[len1 * len2 * len3];
		for (int i = 0; i < iterations; i++)
		{
			Parallel.For(0, len1, (Action<int>)delegate(int x)
			{
				int num = Mathf.Max(0, x - 1);
				int num2 = Mathf.Min(len1 - 1, x + 1);
				for (int j = 0; j < len2; j++)
				{
					int num3 = Mathf.Max(0, j - 1);
					int num4 = Mathf.Min(len2 - 1, j + 1);
					for (int k = 0; k < len3; k++)
					{
						float num5 = src[(x * len2 + j) * len3 + k] * 4f + src[(x * len2 + num3) * len3 + k] + src[(x * len2 + num4) * len3 + k] + src[(num * len2 + j) * len3 + k] + src[(num2 * len2 + j) * len3 + k];
						dst[(x * len2 + j) * len3 + k] = num5 * 0.125f;
					}
				}
			});
			GenericsUtil.Swap<float[]>(ref src, ref dst);
		}
		if (src != data)
		{
			Buffer.BlockCopy(src, 0, data, 0, data.Length * 4);
		}
	}

	public static void Average2D(float[] data, int len1, int len2, int iterations = 1)
	{
		float[] src = data;
		float[] dst = new float[len1 * len2];
		for (int i = 0; i < iterations; i++)
		{
			Parallel.For(0, len1, (Action<int>)delegate(int x)
			{
				int num = Mathf.Max(0, x - 1);
				int num2 = Mathf.Min(len1 - 1, x + 1);
				for (int j = 0; j < len2; j++)
				{
					int num3 = Mathf.Max(0, j - 1);
					int num4 = Mathf.Min(len2 - 1, j + 1);
					float num5 = src[x * len2 + j] + src[x * len2 + num3] + src[x * len2 + num4] + src[num * len2 + j] + src[num2 * len2 + j];
					dst[x * len2 + j] = num5 * 0.2f;
				}
			});
			GenericsUtil.Swap<float[]>(ref src, ref dst);
		}
		if (src != data)
		{
			Buffer.BlockCopy(src, 0, data, 0, data.Length * 4);
		}
	}

	public static void Average2D(float[] data, int len1, int len2, int len3, int iterations = 1)
	{
		float[] src = data;
		float[] dst = new float[len1 * len2 * len3];
		for (int i = 0; i < iterations; i++)
		{
			Parallel.For(0, len1, (Action<int>)delegate(int x)
			{
				int num = Mathf.Max(0, x - 1);
				int num2 = Mathf.Min(len1 - 1, x + 1);
				for (int j = 0; j < len2; j++)
				{
					int num3 = Mathf.Max(0, j - 1);
					int num4 = Mathf.Min(len2 - 1, j + 1);
					for (int k = 0; k < len3; k++)
					{
						float num5 = src[(x * len2 + j) * len3 + k] + src[(x * len2 + num3) * len3 + k] + src[(x * len2 + num4) * len3 + k] + src[(num * len2 + j) * len3 + k] + src[(num2 * len2 + j) * len3 + k];
						dst[(x * len2 + j) * len3 + k] = num5 * 0.2f;
					}
				}
			});
			GenericsUtil.Swap<float[]>(ref src, ref dst);
		}
		if (src != data)
		{
			Buffer.BlockCopy(src, 0, data, 0, data.Length * 4);
		}
	}

	public static void Upsample2D(float[] src, int srclen1, int srclen2, float[] dst, int dstlen1, int dstlen2)
	{
		if (2 * srclen1 != dstlen1 || 2 * srclen2 != dstlen2)
		{
			return;
		}
		Parallel.For(0, srclen1, (Action<int>)delegate(int x)
		{
			int num = Mathf.Max(0, x - 1);
			int num2 = Mathf.Min(srclen1 - 1, x + 1);
			for (int i = 0; i < srclen2; i++)
			{
				int num3 = Mathf.Max(0, i - 1);
				int num4 = Mathf.Min(srclen2 - 1, i + 1);
				float num5 = src[x * srclen2 + i] * 6f;
				float num6 = num5 + src[num * srclen2 + i] + src[x * srclen2 + num3];
				dst[2 * x * dstlen2 + 2 * i] = num6 * 0.125f;
				float num7 = num5 + src[num2 * srclen2 + i] + src[x * srclen2 + num3];
				dst[(2 * x + 1) * dstlen2 + 2 * i] = num7 * 0.125f;
				float num8 = num5 + src[num * srclen2 + i] + src[x * srclen2 + num4];
				dst[2 * x * dstlen2 + (2 * i + 1)] = num8 * 0.125f;
				float num9 = num5 + src[num2 * srclen2 + i] + src[x * srclen2 + num4];
				dst[(2 * x + 1) * dstlen2 + (2 * i + 1)] = num9 * 0.125f;
			}
		});
	}

	public static void Upsample2D(float[] src, int srclen1, int srclen2, int srclen3, float[] dst, int dstlen1, int dstlen2, int dstlen3)
	{
		if (2 * srclen1 != dstlen1 || 2 * srclen2 != dstlen2 || srclen3 != dstlen3)
		{
			return;
		}
		Parallel.For(0, srclen1, (Action<int>)delegate(int x)
		{
			int num = Mathf.Max(0, x - 1);
			int num2 = Mathf.Min(srclen1 - 1, x + 1);
			for (int i = 0; i < srclen2; i++)
			{
				int num3 = Mathf.Max(0, i - 1);
				int num4 = Mathf.Min(srclen2 - 1, i + 1);
				for (int j = 0; j < srclen3; j++)
				{
					float num5 = src[(x * srclen2 + i) * srclen3 + j] * 6f;
					float num6 = num5 + src[(num * srclen2 + i) * srclen3 + j] + src[(x * srclen2 + num3) * srclen3 + j];
					dst[(2 * x * dstlen2 + 2 * i) * dstlen3 + j] = num6 * 0.125f;
					float num7 = num5 + src[(num2 * srclen2 + i) * srclen3 + j] + src[(x * srclen2 + num3) * srclen3 + j];
					dst[((2 * x + 1) * dstlen2 + 2 * i) * dstlen3 + j] = num7 * 0.125f;
					float num8 = num5 + src[(num * srclen2 + i) * srclen3 + j] + src[(x * srclen2 + num4) * srclen3 + j];
					dst[(2 * x * dstlen2 + (2 * i + 1)) * dstlen3 + j] = num8 * 0.125f;
					float num9 = num5 + src[(num2 * srclen2 + i) * srclen3 + j] + src[(x * srclen2 + num4) * srclen3 + j];
					dst[((2 * x + 1) * dstlen2 + (2 * i + 1)) * dstlen3 + j] = num9 * 0.125f;
				}
			}
		});
	}

	public static void Dilate2D(NativeArray<int> src, int len1, int len2, int srcmask, int radius, Action<int, int> action)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Parallel.For(0, len1, (Action<int>)delegate(int x)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Expected O, but got Unknown
			MaxQueue val = new MaxQueue(radius * 2 + 1);
			for (int i = 0; i < radius; i++)
			{
				val.Push(src[x * len2 + i] & srcmask);
			}
			for (int j = 0; j < len2; j++)
			{
				if (j > radius)
				{
					val.Pop();
				}
				if (j < len2 - radius)
				{
					val.Push(src[x * len2 + j + radius] & srcmask);
				}
				if (val.Max != 0)
				{
					action(x, j);
				}
			}
		});
		Parallel.For(0, len2, (Action<int>)delegate(int y)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Expected O, but got Unknown
			MaxQueue val2 = new MaxQueue(radius * 2 + 1);
			for (int k = 0; k < radius; k++)
			{
				val2.Push(src[k * len2 + y] & srcmask);
			}
			for (int l = 0; l < len1; l++)
			{
				if (l > radius)
				{
					val2.Pop();
				}
				if (l < len1 - radius)
				{
					val2.Push(src[(l + radius) * len2 + y] & srcmask);
				}
				if (val2.Max != 0)
				{
					action(l, y);
				}
			}
		});
	}

	public static void Dilate2D(int[] src, int len1, int len2, int srcmask, int radius, Action<int, int> action)
	{
		Parallel.For(0, len1, (Action<int>)delegate(int x)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Expected O, but got Unknown
			MaxQueue val = new MaxQueue(radius * 2 + 1);
			for (int i = 0; i < radius; i++)
			{
				val.Push(src[x * len2 + i] & srcmask);
			}
			for (int j = 0; j < len2; j++)
			{
				if (j > radius)
				{
					val.Pop();
				}
				if (j < len2 - radius)
				{
					val.Push(src[x * len2 + j + radius] & srcmask);
				}
				if (val.Max != 0)
				{
					action(x, j);
				}
			}
		});
		Parallel.For(0, len2, (Action<int>)delegate(int y)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Expected O, but got Unknown
			MaxQueue val2 = new MaxQueue(radius * 2 + 1);
			for (int k = 0; k < radius; k++)
			{
				val2.Push(src[k * len2 + y] & srcmask);
			}
			for (int l = 0; l < len1; l++)
			{
				if (l > radius)
				{
					val2.Pop();
				}
				if (l < len1 - radius)
				{
					val2.Push(src[(l + radius) * len2 + y] & srcmask);
				}
				if (val2.Max != 0)
				{
					action(l, y);
				}
			}
		});
	}

	public static void FloodFill2D(int x, int y, int[] data, int len1, int len2, int mask_any, int mask_not, Func<int, int> action)
	{
		Stack<KeyValuePair<int, int>> stack = new Stack<KeyValuePair<int, int>>();
		stack.Push(new KeyValuePair<int, int>(x, y));
		while (stack.Count > 0)
		{
			KeyValuePair<int, int> keyValuePair = stack.Pop();
			x = keyValuePair.Key;
			y = keyValuePair.Value;
			int num;
			for (num = y; num >= 0; num--)
			{
				int num2 = data[x * len2 + num];
				if ((num2 & mask_any) == 0 || (num2 & mask_not) != 0)
				{
					break;
				}
			}
			num++;
			bool flag;
			bool flag2 = (flag = false);
			for (; num < len2; num++)
			{
				int num3 = data[x * len2 + num];
				if ((num3 & mask_any) == 0 || (num3 & mask_not) != 0)
				{
					break;
				}
				data[x * len2 + num] = action(num3);
				if (x > 0)
				{
					int num4 = data[(x - 1) * len2 + num];
					bool flag3 = (num4 & mask_any) != 0 && (num4 & mask_not) == 0;
					if (!flag2 && flag3)
					{
						stack.Push(new KeyValuePair<int, int>(x - 1, num));
						flag2 = true;
					}
					else if (flag2 && !flag3)
					{
						flag2 = false;
					}
				}
				if (x < len1 - 1)
				{
					int num5 = data[(x + 1) * len2 + num];
					bool flag4 = (num5 & mask_any) != 0 && (num5 & mask_not) == 0;
					if (!flag && flag4)
					{
						stack.Push(new KeyValuePair<int, int>(x + 1, num));
						flag = true;
					}
					else if (flag && !flag4)
					{
						flag = false;
					}
				}
			}
		}
	}

	public static bool IsValidPNG(byte[] data, int maxSizeSquare)
	{
		return IsValidPNG(data, maxSizeSquare, maxSizeSquare);
	}

	public static bool IsValidPNG(byte[] data, int maxWidth, int maxHeight)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		if (data == null || data.Length < 29)
		{
			return false;
		}
		if (data.Length > 29 + maxWidth * maxHeight * 4)
		{
			return false;
		}
		for (int i = 0; i < signaturePNG.Length; i++)
		{
			if (data[i] != signaturePNG[i])
			{
				return false;
			}
		}
		for (int j = 0; j < signatureIHDR.Length; j++)
		{
			if (data[8 + j] != signatureIHDR[j])
			{
				return false;
			}
		}
		Union32 val = default(Union32);
		val.b4 = data[16];
		val.b3 = data[17];
		val.b2 = data[18];
		val.b1 = data[19];
		if (val.i < 1 || val.i > maxWidth)
		{
			return false;
		}
		Union32 val2 = default(Union32);
		val2.b4 = data[20];
		val2.b3 = data[21];
		val2.b2 = data[22];
		val2.b1 = data[23];
		if (val2.i < 1 || val2.i > maxHeight)
		{
			return false;
		}
		byte b = data[24];
		if (b != 8 && b != 16)
		{
			return false;
		}
		byte b2 = data[25];
		if (b2 != 2 && b2 != 6)
		{
			return false;
		}
		if (data[26] != 0)
		{
			return false;
		}
		if (data[27] != 0)
		{
			return false;
		}
		if (data[28] != 0)
		{
			return false;
		}
		return true;
	}

	public static bool IsValidJPG(byte[] data, int maxSizeSquare)
	{
		return IsValidJPG(data, maxSizeSquare, maxSizeSquare);
	}

	public static bool IsValidJPG(byte[] data, int maxWidth, int maxHeight)
	{
		if (data.Length < 30)
		{
			return false;
		}
		if (data.Length > 30 + maxWidth * maxHeight)
		{
			return false;
		}
		try
		{
			if (data[0] != byte.MaxValue || data[1] != 216)
			{
				return false;
			}
			if (data[2] != byte.MaxValue || data[3] != 224)
			{
				return false;
			}
			if (data[6] != 74 || data[7] != 70 || data[8] != 73 || data[9] != 70 || data[10] != 0)
			{
				return false;
			}
			if (data[13] != 0)
			{
				return false;
			}
			if (data[14] != data[16] || data[15] != data[17])
			{
				return false;
			}
			int num = 4;
			int num2 = (data[num] << 8) | data[num + 1];
			while (num < data.Length)
			{
				num += num2;
				if (num >= data.Length)
				{
					return false;
				}
				if (data[num] != byte.MaxValue)
				{
					return false;
				}
				if (data[num + 1] == 192 || data[num + 1] == 193 || data[num + 1] == 194)
				{
					int num3 = (data[num + 5] << 8) | data[num + 6];
					return ((data[num + 7] << 8) | data[num + 8]) <= maxWidth && num3 <= maxHeight;
				}
				num += 2;
				num2 = (data[num] << 8) | data[num + 1];
			}
			return false;
		}
		catch
		{
			return false;
		}
	}

	public static bool IsClear(Color32[] data)
	{
		for (int i = 0; i < data.Length; i++)
		{
			if (data[i].a > 5)
			{
				return false;
			}
		}
		return true;
	}
}


public static class ManagedNoise
{
	private static readonly int[] hash = new int[512]
	{
		151, 160, 137, 91, 90, 15, 131, 13, 201, 95,
		96, 53, 194, 233, 7, 225, 140, 36, 103, 30,
		69, 142, 8, 99, 37, 240, 21, 10, 23, 190,
		6, 148, 247, 120, 234, 75, 0, 26, 197, 62,
		94, 252, 219, 203, 117, 35, 11, 32, 57, 177,
		33, 88, 237, 149, 56, 87, 174, 20, 125, 136,
		171, 168, 68, 175, 74, 165, 71, 134, 139, 48,
		27, 166, 77, 146, 158, 231, 83, 111, 229, 122,
		60, 211, 133, 230, 220, 105, 92, 41, 55, 46,
		245, 40, 244, 102, 143, 54, 65, 25, 63, 161,
		1, 216, 80, 73, 209, 76, 132, 187, 208, 89,
		18, 169, 200, 196, 135, 130, 116, 188, 159, 86,
		164, 100, 109, 198, 173, 186, 3, 64, 52, 217,
		226, 250, 124, 123, 5, 202, 38, 147, 118, 126,
		255, 82, 85, 212, 207, 206, 59, 227, 47, 16,
		58, 17, 182, 189, 28, 42, 223, 183, 170, 213,
		119, 248, 152, 2, 44, 154, 163, 70, 221, 153,
		101, 155, 167, 43, 172, 9, 129, 22, 39, 253,
		19, 98, 108, 110, 79, 113, 224, 232, 178, 185,
		112, 104, 218, 246, 97, 228, 251, 34, 242, 193,
		238, 210, 144, 12, 191, 179, 162, 241, 81, 51,
		145, 235, 249, 14, 239, 107, 49, 192, 214, 31,
		181, 199, 106, 157, 184, 84, 204, 176, 115, 121,
		50, 45, 127, 4, 150, 254, 138, 236, 205, 93,
		222, 114, 67, 29, 24, 72, 243, 141, 128, 195,
		78, 66, 215, 61, 156, 180, 151, 160, 137, 91,
		90, 15, 131, 13, 201, 95, 96, 53, 194, 233,
		7, 225, 140, 36, 103, 30, 69, 142, 8, 99,
		37, 240, 21, 10, 23, 190, 6, 148, 247, 120,
		234, 75, 0, 26, 197, 62, 94, 252, 219, 203,
		117, 35, 11, 32, 57, 177, 33, 88, 237, 149,
		56, 87, 174, 20, 125, 136, 171, 168, 68, 175,
		74, 165, 71, 134, 139, 48, 27, 166, 77, 146,
		158, 231, 83, 111, 229, 122, 60, 211, 133, 230,
		220, 105, 92, 41, 55, 46, 245, 40, 244, 102,
		143, 54, 65, 25, 63, 161, 1, 216, 80, 73,
		209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
		135, 130, 116, 188, 159, 86, 164, 100, 109, 198,
		173, 186, 3, 64, 52, 217, 226, 250, 124, 123,
		5, 202, 38, 147, 118, 126, 255, 82, 85, 212,
		207, 206, 59, 227, 47, 16, 58, 17, 182, 189,
		28, 42, 223, 183, 170, 213, 119, 248, 152, 2,
		44, 154, 163, 70, 221, 153, 101, 155, 167, 43,
		172, 9, 129, 22, 39, 253, 19, 98, 108, 110,
		79, 113, 224, 232, 178, 185, 112, 104, 218, 246,
		97, 228, 251, 34, 242, 193, 238, 210, 144, 12,
		191, 179, 162, 241, 81, 51, 145, 235, 249, 14,
		239, 107, 49, 192, 214, 31, 181, 199, 106, 157,
		184, 84, 204, 176, 115, 121, 50, 45, 127, 4,
		150, 254, 138, 236, 205, 93, 222, 114, 67, 29,
		24, 72, 243, 141, 128, 195, 78, 66, 215, 61,
		156, 180
	};

	private const int hashMask = 255;

	private const double sqrt2 = 1.4142135623730951;

	private const double rsqrt2 = 0.7071067811865476;

	private const double squaresToTriangles = 0.2113248654051871;

	private const double trianglesToSquares = 0.36602540378443865;

	private const double simplexScale1D = 2.4074074074074074;

	private const double simplexScale2D = 32.99077398303956;

	private const double gradientScale2D = 4.0;

	private static double[] gradients1D = new double[2] { 1.0, -1.0 };

	private const int gradientsMask1D = 1;

	private static double[] gradients2Dx = new double[8] { 1.0, -1.0, 0.0, 0.0, 0.7071067811865476, -0.7071067811865476, 0.7071067811865476, -0.7071067811865476 };

	private static double[] gradients2Dy = new double[8] { 0.0, 0.0, 1.0, -1.0, 0.7071067811865476, 0.7071067811865476, -0.7071067811865476, -0.7071067811865476 };

	private const int gradientsMask2D = 7;

	public static double Simplex1D(double x)
	{
		double num = 0.0;
		int num2;
		int num3 = (num2 = Floor(x));
		double num4 = x - (double)num2;
		double num5 = 1.0 - num4 * num4;
		if (num5 > 0.0)
		{
			double num6 = num5 * num5;
			double num7 = num5 * num6;
			int num8 = hash[num2 & 0xFF] & 1;
			double num9 = gradients1D[num8] * num4;
			num += num9 * num7;
		}
		int num10 = num3 + 1;
		double num11 = x - (double)num10;
		double num12 = 1.0 - num11 * num11;
		if (num12 > 0.0)
		{
			double num13 = num12 * num12;
			double num14 = num12 * num13;
			int num15 = hash[num10 & 0xFF] & 1;
			double num16 = gradients1D[num15] * num11;
			num += num16 * num14;
		}
		return num * 2.4074074074074074;
	}

	public static double Simplex1D(double x, out double dx)
	{
		double num = 0.0;
		dx = 0.0;
		int num2;
		int num3 = (num2 = Floor(x));
		double num4 = x - (double)num2;
		double num5 = 1.0 - num4 * num4;
		if (num5 > 0.0)
		{
			double num6 = num5 * num5;
			double num7 = num5 * num6;
			int num8 = hash[num2 & 0xFF] & 1;
			double num9 = gradients1D[num8];
			double num10 = num9 * num4;
			double num11 = num10 * 6.0 * num6;
			dx += num9 * num7 - num11 * num4;
			num += num10 * num7;
		}
		int num12 = num3 + 1;
		double num13 = x - (double)num12;
		double num14 = 1.0 - num13 * num13;
		if (num14 > 0.0)
		{
			double num15 = num14 * num14;
			double num16 = num14 * num15;
			int num17 = hash[num12 & 0xFF] & 1;
			double num18 = gradients1D[num17];
			double num19 = num18 * num13;
			double num20 = num19 * 6.0 * num15;
			dx += num18 * num16 - num20 * num13;
			num += num19 * num16;
		}
		return num * 2.4074074074074074;
	}

	public static double Simplex2D(double x, double y)
	{
		double num = 0.0;
		double num2 = (x + y) * 0.36602540378443865;
		double num3 = x + num2;
		double num4 = y + num2;
		int num5 = Floor(num3);
		int num6 = Floor(num4);
		int num7 = num5;
		int num8 = num6;
		double num9 = (double)(num7 + num8) * 0.2113248654051871;
		double num10 = x - (double)num7 + num9;
		double num11 = y - (double)num8 + num9;
		double num12 = 0.5 - num10 * num10 - num11 * num11;
		if (num12 > 0.0)
		{
			double num13 = num12 * num12;
			double num14 = num12 * num13;
			int num15 = hash[(hash[num7 & 0xFF] + num8) & 0xFF] & 7;
			double num16 = gradients2Dx[num15];
			double num17 = gradients2Dy[num15];
			double num18 = num16 * num10 + num17 * num11;
			num += num18 * num14;
		}
		int num19 = num5 + 1;
		int num20 = num6 + 1;
		double num21 = (double)(num19 + num20) * 0.2113248654051871;
		double num22 = x - (double)num19 + num21;
		double num23 = y - (double)num20 + num21;
		double num24 = 0.5 - num22 * num22 - num23 * num23;
		if (num24 > 0.0)
		{
			double num25 = num24 * num24;
			double num26 = num24 * num25;
			int num27 = hash[(hash[num19 & 0xFF] + num20) & 0xFF] & 7;
			double num28 = gradients2Dx[num27];
			double num29 = gradients2Dy[num27];
			double num30 = num28 * num22 + num29 * num23;
			num += num30 * num26;
		}
		if (num3 - (double)num5 >= num4 - (double)num6)
		{
			int num31 = num5 + 1;
			int num32 = num6;
			double num33 = (double)(num31 + num32) * 0.2113248654051871;
			double num34 = x - (double)num31 + num33;
			double num35 = y - (double)num32 + num33;
			double num36 = 0.5 - num34 * num34 - num35 * num35;
			if (num36 > 0.0)
			{
				double num37 = num36 * num36;
				double num38 = num36 * num37;
				int num39 = hash[(hash[num31 & 0xFF] + num32) & 0xFF] & 7;
				double num40 = gradients2Dx[num39];
				double num41 = gradients2Dy[num39];
				double num42 = num40 * num34 + num41 * num35;
				num += num42 * num38;
			}
		}
		else
		{
			int num43 = num5;
			int num44 = num6 + 1;
			double num45 = (double)(num43 + num44) * 0.2113248654051871;
			double num46 = x - (double)num43 + num45;
			double num47 = y - (double)num44 + num45;
			double num48 = 0.5 - num46 * num46 - num47 * num47;
			if (num48 > 0.0)
			{
				double num49 = num48 * num48;
				double num50 = num48 * num49;
				int num51 = hash[(hash[num43 & 0xFF] + num44) & 0xFF] & 7;
				double num52 = gradients2Dx[num51];
				double num53 = gradients2Dy[num51];
				double num54 = num52 * num46 + num53 * num47;
				num += num54 * num50;
			}
		}
		return num * 32.99077398303956;
	}

	public static double Simplex2D(double x, double y, out double dx, out double dy)
	{
		double num = 0.0;
		dx = 0.0;
		dy = 0.0;
		double num2 = (x + y) * 0.36602540378443865;
		double num3 = x + num2;
		double num4 = y + num2;
		int num5 = Floor(num3);
		int num6 = Floor(num4);
		int num7 = num5;
		int num8 = num6;
		double num9 = (double)(num7 + num8) * 0.2113248654051871;
		double num10 = x - (double)num7 + num9;
		double num11 = y - (double)num8 + num9;
		double num12 = 0.5 - num10 * num10 - num11 * num11;
		if (num12 > 0.0)
		{
			double num13 = num12 * num12;
			double num14 = num12 * num13;
			int num15 = hash[(hash[num7 & 0xFF] + num8) & 0xFF] & 7;
			double num16 = gradients2Dx[num15];
			double num17 = gradients2Dy[num15];
			double num18 = num16 * num10 + num17 * num11;
			double num19 = num18 * 6.0 * num13;
			dx += num16 * num14 - num19 * num10;
			dy += num17 * num14 - num19 * num11;
			num += num18 * num14;
		}
		int num20 = num5 + 1;
		int num21 = num6 + 1;
		double num22 = (double)(num20 + num21) * 0.2113248654051871;
		double num23 = x - (double)num20 + num22;
		double num24 = y - (double)num21 + num22;
		double num25 = 0.5 - num23 * num23 - num24 * num24;
		if (num25 > 0.0)
		{
			double num26 = num25 * num25;
			double num27 = num25 * num26;
			int num28 = hash[(hash[num20 & 0xFF] + num21) & 0xFF] & 7;
			double num29 = gradients2Dx[num28];
			double num30 = gradients2Dy[num28];
			double num31 = num29 * num23 + num30 * num24;
			double num32 = num31 * 6.0 * num26;
			dx += num29 * num27 - num32 * num23;
			dy += num30 * num27 - num32 * num24;
			num += num31 * num27;
		}
		if (num3 - (double)num5 >= num4 - (double)num6)
		{
			int num33 = num5 + 1;
			int num34 = num6;
			double num35 = (double)(num33 + num34) * 0.2113248654051871;
			double num36 = x - (double)num33 + num35;
			double num37 = y - (double)num34 + num35;
			double num38 = 0.5 - num36 * num36 - num37 * num37;
			if (num38 > 0.0)
			{
				double num39 = num38 * num38;
				double num40 = num38 * num39;
				int num41 = hash[(hash[num33 & 0xFF] + num34) & 0xFF] & 7;
				double num42 = gradients2Dx[num41];
				double num43 = gradients2Dy[num41];
				double num44 = num42 * num36 + num43 * num37;
				double num45 = num44 * 6.0 * num39;
				dx += num42 * num40 - num45 * num36;
				dy += num43 * num40 - num45 * num37;
				num += num44 * num40;
			}
		}
		else
		{
			int num46 = num5;
			int num47 = num6 + 1;
			double num48 = (double)(num46 + num47) * 0.2113248654051871;
			double num49 = x - (double)num46 + num48;
			double num50 = y - (double)num47 + num48;
			double num51 = 0.5 - num49 * num49 - num50 * num50;
			if (num51 > 0.0)
			{
				double num52 = num51 * num51;
				double num53 = num51 * num52;
				int num54 = hash[(hash[num46 & 0xFF] + num47) & 0xFF] & 7;
				double num55 = gradients2Dx[num54];
				double num56 = gradients2Dy[num54];
				double num57 = num55 * num49 + num56 * num50;
				double num58 = num57 * 6.0 * num52;
				dx += num55 * num53 - num58 * num49;
				dy += num56 * num53 - num58 * num50;
				num += num57 * num53;
			}
		}
		dx *= 4.0;
		dy *= 4.0;
		return num * 32.99077398303956;
	}

	public static double Turbulence(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		for (int i = 0; i < octaves; i++)
		{
			double num4 = Simplex2D(x * num2, y * num2);
			num += num3 * num4;
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double Billow(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		for (int i = 0; i < octaves; i++)
		{
			double x2 = Simplex2D(x * num2, y * num2);
			num += num3 * Abs(x2);
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double Ridge(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		for (int i = 0; i < octaves; i++)
		{
			double x2 = Simplex2D(x * num2, y * num2);
			num += num3 * (1.0 - Abs(x2));
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double Sharp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		for (int i = 0; i < octaves; i++)
		{
			double num4 = Simplex2D(x * num2, y * num2);
			num += num3 * (num4 * num4);
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double TurbulenceIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D(x * num2, y * num2, out dx, out dy);
			num4 += dx;
			num5 += dy;
			num += num3 * num6 / (1.0 + (num4 * num4 + num5 * num5));
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double BillowIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double x2 = Simplex2D(x * num2, y * num2, out dx, out dy);
			num4 += dx;
			num5 += dy;
			num += num3 * Abs(x2) / (1.0 + (num4 * num4 + num5 * num5));
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double RidgeIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double x2 = Simplex2D(x * num2, y * num2, out dx, out dy);
			num4 += dx;
			num5 += dy;
			num += num3 * (1.0 - Abs(x2)) / (1.0 + (num4 * num4 + num5 * num5));
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double SharpIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D(x * num2, y * num2, out dx, out dy);
			num4 += dx;
			num5 += dy;
			num += num3 * (num6 * num6) / (1.0 + (num4 * num4 + num5 * num5));
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double TurbulenceWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D((x + warp * num4) * num2, (y + warp * num5) * num2, out dx, out dy);
			num += num3 * num6;
			num4 += num3 * dx * (0.0 - num6);
			num5 += num3 * dy * (0.0 - num6);
			num2 *= lacunarity;
			num3 *= gain * Saturate(num);
		}
		return num * amplitude;
	}

	public static double BillowWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D((x + warp * num4) * num2, (y + warp * num5) * num2, out dx, out dy);
			num += num3 * Abs(num6);
			num4 += num3 * dx * (0.0 - num6);
			num5 += num3 * dy * (0.0 - num6);
			num2 *= lacunarity;
			num3 *= gain * Saturate(num);
		}
		return num * amplitude;
	}

	public static double RidgeWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D((x + warp * num4) * num2, (y + warp * num5) * num2, out dx, out dy);
			num += num3 * (1.0 - Abs(num6));
			num4 += num3 * dx * (0.0 - num6);
			num5 += num3 * dy * (0.0 - num6);
			num2 *= lacunarity;
			num3 *= gain * Saturate(num);
		}
		return num * amplitude;
	}

	public static double SharpWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D((x + warp * num4) * num2, (y + warp * num5) * num2, out dx, out dy);
			num += num3 * (num6 * num6);
			num4 += num3 * dx * (0.0 - num6);
			num5 += num3 * dy * (0.0 - num6);
			num2 *= lacunarity;
			num3 *= gain * Saturate(num);
		}
		return num * amplitude;
	}

	public static double Jordan(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp, double damp, double damp_scale)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		double num6 = 0.0;
		double num7 = 0.0;
		double num8 = num2 * gain;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num9 = Simplex2D(x * num3 + num4, y * num3 + num5, out dx, out dy);
			double num10 = num9 * num9;
			double num11 = dx * num9;
			double num12 = dy * num9;
			num += num8 * num10;
			num4 += warp * num11;
			num5 += warp * num12;
			num6 += damp * num11;
			num7 += damp * num12;
			num3 *= lacunarity;
			num2 *= gain;
			num8 = num2 * (1.0 - damp_scale / (1.0 + (num6 * num6 + num7 * num7)));
		}
		return num * amplitude;
	}

	private static int Floor(double x)
	{
		if (!(x >= 0.0))
		{
			return (int)x - 1;
		}
		return (int)x;
	}

	private static double Abs(double x)
	{
		if (!(x >= 0.0))
		{
			return 0.0 - x;
		}
		return x;
	}

	private static double Saturate(double x)
	{
		if (!(x > 1.0))
		{
			if (!(x < 0.0))
			{
				return x;
			}
			return 0.0;
		}
		return 1.0;
	}
}


using System.Runtime.InteropServices;
using System.Security;

[SuppressUnmanagedCodeSecurity]
public static class NativeNoise
{
	[DllImport("RustNative", EntryPoint = "snoise1_32")]
	public static extern float Simplex1D(float x);

	[DllImport("RustNative", EntryPoint = "sdnoise1_32")]
	public static extern float Simplex1D(float x, out float dx);

	[DllImport("RustNative", EntryPoint = "snoise2_32")]
	public static extern float Simplex2D(float x, float y);

	[DllImport("RustNative", EntryPoint = "sdnoise2_32")]
	public static extern float Simplex2D(float x, float y, out float dx, out float dy);

	[DllImport("RustNative", EntryPoint = "turbulence_32")]
	public static extern float Turbulence(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "billow_32")]
	public static extern float Billow(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "ridge_32")]
	public static extern float Ridge(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "sharp_32")]
	public static extern float Sharp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "turbulence_iq_32")]
	public static extern float TurbulenceIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "billow_iq_32")]
	public static extern float BillowIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "ridge_iq_32")]
	public static extern float RidgeIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "sharp_iq_32")]
	public static extern float SharpIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "turbulence_warp_32")]
	public static extern float TurbulenceWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);

	[DllImport("RustNative", EntryPoint = "billow_warp_32")]
	public static extern float BillowWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);

	[DllImport("RustNative", EntryPoint = "ridge_warp_32")]
	public static extern float RidgeWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);

	[DllImport("RustNative", EntryPoint = "sharp_warp_32")]
	public static extern float SharpWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);

	[DllImport("RustNative", EntryPoint = "jordan_32")]
	public static extern float Jordan(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp, float damp, float damp_scale);
}


public static class Noise
{
	public const float MIN = -1000000f;

	public const float MAX = 1000000f;

	public static float SimplexSigned(float x)
	{
		return NativeNoise.Simplex1D(x);
	}

	public static float SimplexSigned(float x, float y)
	{
		return NativeNoise.Simplex2D(x, y);
	}

	public static float SimplexUnsigned(float x)
	{
		return NativeNoise.Simplex1D(x) * 0.5f + 1f;
	}

	public static float SimplexUnsigned(float x, float y)
	{
		return NativeNoise.Simplex2D(x, y) * 0.5f + 1f;
	}

	public static float Turbulence(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.Turbulence(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float Billow(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.Billow(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float Ridge(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.Ridge(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float Sharp(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.Sharp(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float TurbulenceIQ(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.TurbulenceIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float BillowIQ(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.BillowIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float RidgeIQ(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.RidgeIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float SharpIQ(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.SharpIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float TurbulenceWarp(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f, float warp = 0.25f)
	{
		return NativeNoise.TurbulenceWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
	}

	public static float BillowWarp(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f, float warp = 0.25f)
	{
		return NativeNoise.BillowWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
	}

	public static float RidgeWarp(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f, float warp = 0.25f)
	{
		return NativeNoise.RidgeWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
	}

	public static float SharpWarp(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f, float warp = 0.25f)
	{
		return NativeNoise.SharpWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
	}

	public static float Jordan(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f, float warp = 1f, float damp = 1f, float damp_scale = 1f)
	{
		return NativeNoise.Jordan(x, y, octaves, frequency, amplitude, lacunarity, gain, warp, damp, damp_scale);
	}
}


using System;

[Serializable]
public struct NoiseParameters
{
	public int Octaves;

	public float Frequency;

	public float Amplitude;

	public float Offset;

	public NoiseParameters(int octaves, float frequency, float amplitude, float offset)
	{
		Octaves = octaves;
		Frequency = frequency;
		Amplitude = amplitude;
		Offset = offset;
	}
}


