using UnityEngine;

public class TriggerRagdollRelocate : TriggerBase
{
	public Transform targetLocation;

	internal override void OnObjectAdded(GameObject obj, Collider col)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		base.OnObjectAdded(obj, col);
		BaseEntity baseEntity = obj.transform.ToBaseEntity();
		if ((Object)(object)baseEntity != (Object)null && baseEntity.isServer)
		{
			RepositionTransform(((Component)baseEntity).transform);
		}
		Ragdoll componentInParent = obj.GetComponentInParent<Ragdoll>();
		if (!((Object)(object)componentInParent != (Object)null))
		{
			return;
		}
		RepositionTransform(((Component)componentInParent).transform);
		foreach (Rigidbody rigidbody in componentInParent.rigidbodies)
		{
			if (((Component)rigidbody).transform.position.y < ((Component)this).transform.position.y)
			{
				RepositionTransform(((Component)rigidbody).transform);
			}
		}
	}

	private void RepositionTransform(Transform t)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = targetLocation.InverseTransformPoint(t.position);
		val.y = 0f;
		val = targetLocation.TransformPoint(val);
		t.position = val;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class TriggerSafeZone : TriggerBase
{
	public static List<TriggerSafeZone> allSafeZones = new List<TriggerSafeZone>();

	public float maxDepth = 20f;

	public float maxAltitude = -1f;

	public Collider triggerCollider { get; private set; }

	protected override void Awake()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		base.Awake();
		triggerCollider = ((Component)this).GetComponent<Collider>();
		base.InterestLayers = LayerMask.op_Implicit(LayerMask.op_Implicit(base.InterestLayers) | 0x200);
	}

	protected void OnEnable()
	{
		allSafeZones.Add(this);
	}

	protected override void OnDisable()
	{
		base.OnDisable();
		allSafeZones.Remove(this);
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public bool PassesHeightChecks(Vector3 entPos)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		float num = Mathf.Abs(position.y - entPos.y);
		if (maxDepth != -1f && entPos.y < position.y && num > maxDepth)
		{
			return false;
		}
		if (maxAltitude != -1f && entPos.y > position.y && num > maxAltitude)
		{
			return false;
		}
		return true;
	}

	public float GetSafeLevel(Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		if (!PassesHeightChecks(pos))
		{
			return 0f;
		}
		return 1f;
	}
}


using UnityEngine;

public class TriggerSnowmobileAchievement : TriggerBase
{
	internal override GameObject InterestedInObject(GameObject obj)
	{
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity != (Object)null && baseEntity.isServer && (Object)(object)baseEntity.ToPlayer() != (Object)null)
		{
			return ((Component)baseEntity).gameObject;
		}
		return null;
	}
}


using UnityEngine;

public class TriggerStashPlayer : TriggerBase
{
	public StashContainer Stash;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BasePlayer basePlayer = obj.ToBaseEntity() as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null)
		{
			return null;
		}
		if (basePlayer.isClient)
		{
			return null;
		}
		return ((Component)basePlayer).gameObject;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		if (entityContents == null || !entityContents.Contains(ent))
		{
			base.OnEntityEnter(ent);
			if (ent is BasePlayer basePlayer)
			{
				basePlayer.AddNeabyStash(Stash);
			}
		}
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
		if (ent is BasePlayer basePlayer)
		{
			basePlayer.RemoveNearbyStash(Stash);
		}
	}
}


using UnityEngine;

public class TriggerSubmarineMoonpool : TriggerBase, IServerComponent
{
	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isServer && baseEntity is BaseSubmarine baseSubmarine)
		{
			return ((Component)baseSubmarine).gameObject;
		}
		return null;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if (ent is BaseSubmarine baseSubmarine)
		{
			baseSubmarine.OnSurfacedInMoonpool();
		}
	}
}


using ConVar;
using UnityEngine;

public class TriggerTemperature : TriggerBase
{
	public float Temperature = 50f;

	public float triggerSize;

	public float minSize;

	public bool sunlightBlocker;

	public float sunlightBlockAmount;

	[Range(0f, 24f)]
	public float blockMinHour = 8.5f;

	[Range(0f, 24f)]
	public float blockMaxHour = 18.5f;

	private void OnValidate()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)((Component)this).GetComponent<SphereCollider>() != (Object)null)
		{
			triggerSize = ((Component)this).GetComponent<SphereCollider>().radius * ((Component)this).transform.localScale.y;
			return;
		}
		Vector3 val = Vector3.Scale(((Component)this).GetComponent<BoxCollider>().size, ((Component)this).transform.localScale);
		triggerSize = Vector3Ex.Max(val) * 0.5f;
	}

	public float WorkoutTemperature(Vector3 position, float oldTemperature)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (sunlightBlocker)
		{
			float time = Env.time;
			if (time >= blockMinHour && time <= blockMaxHour)
			{
				Vector3 position2 = TOD_Sky.Instance.Components.SunTransform.position;
				if (!GamePhysics.LineOfSight(position, position2, 256))
				{
					return oldTemperature - sunlightBlockAmount;
				}
			}
			return oldTemperature;
		}
		float num = Vector3.Distance(((Component)this).gameObject.transform.position, position);
		float num2 = Mathf.InverseLerp(triggerSize, minSize, num);
		return Mathf.Lerp(oldTemperature, Temperature, num2);
	}

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class TriggerWakeAIZ : TriggerBase, IServerComponent
{
	public float SleepDelaySeconds = 30f;

	public List<AIInformationZone> zones = new List<AIInformationZone>();

	private AIInformationZone aiz;

	public void Init(AIInformationZone zone = null)
	{
		if ((Object)(object)zone != (Object)null)
		{
			aiz = zone;
		}
		else if (zones == null || zones.Count == 0)
		{
			Transform val = ((Component)this).transform.parent;
			if ((Object)(object)val == (Object)null)
			{
				val = ((Component)this).transform;
			}
			aiz = ((Component)val).GetComponentInChildren<AIInformationZone>();
		}
		SetZonesSleeping(flag: true);
	}

	protected override void Awake()
	{
		base.Awake();
		Init();
	}

	private void SetZonesSleeping(bool flag)
	{
		if ((Object)(object)aiz != (Object)null)
		{
			if (flag)
			{
				aiz.SleepAI();
			}
			else
			{
				aiz.WakeAI();
			}
		}
		if (zones == null || zones.Count <= 0)
		{
			return;
		}
		foreach (AIInformationZone zone in zones)
		{
			if ((Object)(object)zone != (Object)null)
			{
				if (flag)
				{
					zone.SleepAI();
				}
				else
				{
					zone.WakeAI();
				}
			}
		}
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		BasePlayer basePlayer = baseEntity as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null && basePlayer.IsNpc)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if (!((Object)(object)aiz == (Object)null) || (zones != null && zones.Count != 0))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SleepAI);
			SetZonesSleeping(flag: false);
		}
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
		if ((!((Object)(object)aiz == (Object)null) || (zones != null && zones.Count != 0)) && (entityContents == null || entityContents.Count == 0))
		{
			DelayedSleepAI();
		}
	}

	private void DelayedSleepAI()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)SleepAI);
		((FacepunchBehaviour)this).Invoke((Action)SleepAI, SleepDelaySeconds);
	}

	private void SleepAI()
	{
		SetZonesSleeping(flag: true);
	}
}


using UnityEngine;

public class TriggerWetness : TriggerBase
{
	public float Wetness = 0.25f;

	public SphereCollider TargetCollider;

	public Transform OriginTransform;

	public bool ApplyLocalHeightCheck;

	public float MinLocalHeight;

	public float WorkoutWetness(Vector3 position)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (ApplyLocalHeightCheck && ((Component)this).transform.InverseTransformPoint(position).y < MinLocalHeight)
		{
			return 0f;
		}
		float num = Vector3Ex.Distance2D(OriginTransform.position, position) / TargetCollider.radius;
		num = Mathf.Clamp01(num);
		num = 1f - num;
		return Mathf.Lerp(0f, Wetness, num);
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using UnityEngine;

public class TriggerWorkbench : TriggerBase
{
	public Workbench parentBench;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public float WorkbenchLevel()
	{
		return parentBench.Workbenchlevel;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if (ent is BasePlayer basePlayer)
		{
			basePlayer.metabolism.ForceUpdateWorkbenchFlags();
		}
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
		if (ent is BasePlayer basePlayer)
		{
			basePlayer.metabolism.ForceUpdateWorkbenchFlags();
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class TubeRenderer : FacepunchBehaviour
{
	[Range(3f, 64f)]
	[Header("Settings")]
	public int Segments = 12;

	public float Radius = 0.1f;

	public bool useLocalPositions;

	[Header("Caps")]
	public bool EnableCaps = true;

	[Range(1f, 8f)]
	public int HemisphereRings = 4;

	[NonSerialized]
	public List<Vector3> points = new List<Vector3>();

	private Mesh mesh;

	public void ClearPositions()
	{
		points.Clear();
	}

	public void SetPosition(int index, Vector3 position)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (index >= 0 && index < points.Count)
		{
			points[index] = position;
		}
	}

	public void SetPositions(List<Vector3> positions)
	{
		points.Clear();
		points.AddRange(positions);
	}

	public void UpdateRenderer()
	{
		GenerateTube(points, Radius, Segments, HemisphereRings);
	}

	private void SetupMesh()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Expected O, but got Unknown
		mesh = new Mesh
		{
			name = "Tube Mesh"
		};
		mesh.MarkDynamic();
		MeshFilter val = ((Component)this).GetComponent<MeshFilter>();
		if ((Object)(object)val == (Object)null)
		{
			val = ((Component)this).gameObject.AddComponent<MeshFilter>();
		}
		val.mesh = mesh;
		if ((Object)(object)((Component)this).GetComponent<MeshRenderer>() == (Object)null)
		{
			((Component)this).gameObject.AddComponent<MeshRenderer>();
		}
	}

	private void GenerateTube(List<Vector3> points, float radius, int segments, int rings)
	{
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		if (points == null || points.Count < 2)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("TubeRenderer.GenerateTube", 0);
		try
		{
			if ((Object)(object)mesh == (Object)null)
			{
				SetupMesh();
			}
			List<Vector3> list = Pool.Get<List<Vector3>>();
			List<int> list2 = Pool.Get<List<int>>();
			List<Vector2> list3 = Pool.Get<List<Vector2>>();
			List<Quaternion> list4 = Pool.Get<List<Quaternion>>();
			List<float> list5 = Pool.Get<List<float>>();
			int vertOffset = 0;
			ComputeParallelTransportFrames(points, list4);
			list5.Add(0f);
			float num = 0f;
			for (int i = 1; i < points.Count; i++)
			{
				float num2 = Vector3.Distance(points[i - 1], points[i]);
				num += num2;
				list5.Add(num);
			}
			for (int j = 0; j < points.Count; j++)
			{
				Vector3 center = (useLocalPositions ? points[j] : ((Component)this).transform.InverseTransformPoint(points[j]));
				float v = ((num > 0f) ? (list5[j] / num) : 0f);
				AppendRing(list, list3, list4[j], center, radius, segments, v);
				if (j > 0)
				{
					BridgeLastTwoRings(list2, vertOffset, segments);
				}
				vertOffset += segments + 1;
			}
			if (EnableCaps)
			{
				AppendHemisphereCap(list, list2, list3, ref vertOffset, points[0], list4[0], radius, segments, rings, -1);
				List<Vector3> verts = list;
				List<int> tris = list2;
				List<Vector2> uvs = list3;
				Vector3 position = points[points.Count - 1];
				List<Quaternion> list6 = list4;
				AppendHemisphereCap(verts, tris, uvs, ref vertOffset, position, list6[list6.Count - 1], radius, segments, rings, 1);
			}
			else
			{
				AppendFlatCap(list, list2, list3, ref vertOffset, points[0], list4[0], radius, segments, -1);
				List<Vector3> verts2 = list;
				List<int> tris2 = list2;
				List<Vector2> uvs2 = list3;
				Vector3 position2 = points[points.Count - 1];
				List<Quaternion> list7 = list4;
				AppendFlatCap(verts2, tris2, uvs2, ref vertOffset, position2, list7[list7.Count - 1], radius, segments, 1);
			}
			mesh.Clear();
			mesh.SetVertices(list);
			mesh.SetUVs(0, list3);
			mesh.SetTriangles(list2, 0);
			mesh.RecalculateNormals();
			mesh.RecalculateBounds();
			Pool.FreeUnmanaged<Vector3>(ref list);
			Pool.FreeUnmanaged<int>(ref list2);
			Pool.FreeUnmanaged<Quaternion>(ref list4);
			Pool.FreeUnmanaged<Vector2>(ref list3);
			Pool.FreeUnmanaged<float>(ref list5);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void ComputeParallelTransportFrames(List<Vector3> points, List<Quaternion> rotations)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		rotations.Clear();
		if (points.Count >= 2)
		{
			Vector3 val = points[1] - points[0];
			Vector3 val2 = ((Vector3)(ref val)).normalized;
			Vector3 val3 = ((Mathf.Abs(Vector3.Dot(val2, Vector3.up)) < 0.99f) ? Vector3.up : Vector3.right);
			val = Vector3.Cross(val2, val3);
			Vector3 val4 = ((Vector3)(ref val)).normalized;
			val = Vector3.Cross(val2, val4);
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			rotations.Add(Quaternion.LookRotation(val2, normalized));
			for (int i = 1; i < points.Count; i++)
			{
				val = points[i] - points[i - 1];
				Vector3 normalized2 = ((Vector3)(ref val)).normalized;
				Vector3 val5 = Quaternion.FromToRotation(val2, normalized2) * val4;
				val = Vector3.Cross(normalized2, val5);
				Vector3 normalized3 = ((Vector3)(ref val)).normalized;
				rotations.Add(Quaternion.LookRotation(normalized2, normalized3));
				val2 = normalized2;
				val4 = val5;
			}
		}
	}

	private void AppendRing(List<Vector3> verts, List<Vector2> uvs, Quaternion rotation, Vector3 center, float radius, int segments, float v)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = rotation * Vector3.right;
		Vector3 val2 = rotation * Vector3.up;
		for (int i = 0; i <= segments; i++)
		{
			float num = (float)i / (float)segments * MathF.PI * 2f;
			Vector3 val3 = Mathf.Cos(num) * val + Mathf.Sin(num) * val2;
			verts.Add(center + val3 * radius);
			uvs.Add(new Vector2((float)i / (float)segments, v));
		}
	}

	private void BridgeLastTwoRings(List<int> tris, int vertOffset, int segments)
	{
		int num = vertOffset - (segments + 1);
		for (int i = 0; i < segments; i++)
		{
			int item = num + i;
			int item2 = num + i + 1;
			int item3 = vertOffset + i;
			int item4 = vertOffset + i + 1;
			tris.Add(item);
			tris.Add(item2);
			tris.Add(item3);
			tris.Add(item2);
			tris.Add(item4);
			tris.Add(item3);
		}
	}

	private void AppendFlatCap(List<Vector3> verts, List<int> tris, List<Vector2> uvs, ref int vertOffset, Vector3 position, Quaternion rotation, float radius, int segments, int direction)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		position = (useLocalPositions ? position : ((Component)this).transform.InverseTransformPoint(position));
		Vector3 val = rotation * Vector3.right;
		Vector3 val2 = rotation * Vector3.up;
		int count = verts.Count;
		verts.Add(position);
		uvs.Add(new Vector2(0.5f, 0.5f));
		for (int i = 0; i <= segments; i++)
		{
			float num = (float)i / (float)segments * MathF.PI * 2f;
			Vector3 val3 = Mathf.Cos(num) * val + Mathf.Sin(num) * val2;
			verts.Add(position + val3 * radius);
			float num2 = Mathf.Cos(num) * 0.5f + 0.5f;
			float num3 = Mathf.Sin(num) * 0.5f + 0.5f;
			uvs.Add(new Vector2(num2, num3));
		}
		for (int j = 0; j < segments; j++)
		{
			int item = count + j + 1;
			int item2 = count + j + 2;
			if (direction == 1)
			{
				tris.Add(count);
				tris.Add(item);
				tris.Add(item2);
			}
			else
			{
				tris.Add(count);
				tris.Add(item2);
				tris.Add(item);
			}
		}
		vertOffset += segments + 2;
	}

	private void AppendHemisphereCap(List<Vector3> verts, List<int> tris, List<Vector2> uvs, ref int vertOffset, Vector3 position, Quaternion rotation, float radius, int segments, int rings, int direction)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		position = (useLocalPositions ? position : ((Component)this).transform.InverseTransformPoint(position));
		List<Vector3> list = Pool.Get<List<Vector3>>();
		List<Vector2> list2 = Pool.Get<List<Vector2>>();
		Vector3 val = default(Vector3);
		for (int i = 0; i <= rings; i++)
		{
			float num = (float)i / (float)rings * MathF.PI / 2f;
			for (int j = 0; j <= segments; j++)
			{
				float num2 = (float)j / (float)segments * MathF.PI * 2f;
				float num3 = Mathf.Sin(num);
				((Vector3)(ref val))..ctor(Mathf.Cos(num2) * num3, Mathf.Sin(num2) * num3, Mathf.Cos(num) * (float)direction);
				Vector3 item = rotation * (val * radius) + position;
				list.Add(item);
				float num4 = Mathf.Cos(num2) * num3 * 0.5f + 0.5f;
				float num5 = Mathf.Sin(num2) * num3 * 0.5f + 0.5f;
				list2.Add(new Vector2(num4, num5));
			}
		}
		int count = verts.Count;
		verts.AddRange(list);
		uvs.AddRange(list2);
		for (int k = 0; k < rings; k++)
		{
			for (int l = 0; l < segments; l++)
			{
				int num6 = count + k * (segments + 1) + l;
				int item2 = num6 + 1;
				int num7 = num6 + (segments + 1);
				int item3 = num7 + 1;
				if (direction == 0)
				{
					tris.Add(num6);
					tris.Add(item2);
					tris.Add(num7);
					tris.Add(item2);
					tris.Add(item3);
					tris.Add(num7);
				}
				else
				{
					tris.Add(num6);
					tris.Add(num7);
					tris.Add(item2);
					tris.Add(item2);
					tris.Add(num7);
					tris.Add(item3);
				}
			}
		}
		vertOffset += list.Count;
		Pool.FreeUnmanaged<Vector3>(ref list);
		Pool.FreeUnmanaged<Vector2>(ref list2);
	}
}


using UnityEngine;

public class ValidBounds : SingletonComponent<ValidBounds>
{
	public Bounds worldBounds;

	public static bool Test(BaseEntity entity, Vector3 vPos)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)SingletonComponent<ValidBounds>.Instance))
		{
			return true;
		}
		if ((Object)(object)entity != (Object)null && entity.net != null && entity.net.group != null && TutorialIsland.IsTutorialNetworkGroup(entity.net.group.ID))
		{
			return SingletonComponent<ValidBounds>.Instance.IsInsideOuterBounds(vPos);
		}
		return SingletonComponent<ValidBounds>.Instance.IsInsideInnerBounds(vPos);
	}

	public static float TestDist(BaseEntity entity, Vector3 vPos)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)SingletonComponent<ValidBounds>.Instance))
		{
			return float.MaxValue;
		}
		if ((Object)(object)entity != (Object)null && entity.net != null && entity.net.group != null && TutorialIsland.IsTutorialNetworkGroup(entity.net.group.ID))
		{
			return float.MaxValue;
		}
		return SingletonComponent<ValidBounds>.Instance.DistToWorldEdge2D(vPos);
	}

	public static bool TestInnerBounds(Vector3 vPos)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)SingletonComponent<ValidBounds>.Instance))
		{
			return true;
		}
		return SingletonComponent<ValidBounds>.Instance.IsInsideInnerBounds(vPos);
	}

	public static bool TestOuterBounds(Vector3 vPos)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)SingletonComponent<ValidBounds>.Instance))
		{
			return true;
		}
		return SingletonComponent<ValidBounds>.Instance.IsInsideOuterBounds(vPos);
	}

	internal bool IsInsideInnerBounds(Vector3 vPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3Ex.IsNaNOrInfinity(vPos))
		{
			return false;
		}
		if (!((Bounds)(ref worldBounds)).Contains(vPos))
		{
			return false;
		}
		if ((Object)(object)TerrainMeta.Terrain != (Object)null)
		{
			if (World.Procedural && vPos.y < TerrainMeta.Position.y)
			{
				return false;
			}
			if (TerrainMeta.OutOfMargin(vPos))
			{
				return false;
			}
		}
		return true;
	}

	internal bool IsInsideOuterBounds(Vector3 vPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3Ex.IsNaNOrInfinity(vPos))
		{
			return false;
		}
		Bounds val = default(Bounds);
		((Bounds)(ref val))..ctor(((Bounds)(ref worldBounds)).center, new Vector3(((Bounds)(ref worldBounds)).size.x + TutorialIsland.TutorialBoundsSize * 2f, ((Bounds)(ref worldBounds)).size.y, ((Bounds)(ref worldBounds)).size.z + TutorialIsland.TutorialBoundsSize * 2f));
		if (!((Bounds)(ref val)).Contains(vPos))
		{
			return false;
		}
		if ((Object)(object)TerrainMeta.Terrain != (Object)null)
		{
			if (World.Procedural && vPos.y < TerrainMeta.Position.y)
			{
				return false;
			}
			if (TerrainMeta.OutOfMarginPlusTutorialBounds(vPos))
			{
				return false;
			}
		}
		return true;
	}

	public static float GetMaximumPointTutorial()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)SingletonComponent<ValidBounds>.Instance == (Object)null)
		{
			return 0f;
		}
		return Mathf.Min(TerrainMeta.Position.x + TerrainMeta.Size.x * 2f + TutorialIsland.TutorialBoundsSize, ((Bounds)(ref SingletonComponent<ValidBounds>.Instance.worldBounds)).extents.x + TutorialIsland.TutorialBoundsSize);
	}

	public static float GetMaximumPoint()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)SingletonComponent<ValidBounds>.Instance == (Object)null)
		{
			return 0f;
		}
		float num = ((Bounds)(ref SingletonComponent<ValidBounds>.Instance.worldBounds)).max.x;
		if ((Object)(object)TerrainMeta.Terrain != (Object)null)
		{
			num = Mathf.Min(TerrainMeta.Position.x + TerrainMeta.Size.x, num);
		}
		return num;
	}

	internal float DistToWorldEdge2D(Vector3 vPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (!IsInsideInnerBounds(vPos))
		{
			return -1f;
		}
		float num = worldBounds.InnerDistToEdge2D(vPos);
		if ((Object)(object)TerrainMeta.Terrain != (Object)null)
		{
			float num2 = TerrainMeta.InnerDistToEdge2D(vPos);
			return Mathf.Min(num, num2);
		}
		return num;
	}
}


using System.Collections.Generic;
using UnityEngine;

public static class Vis
{
	private static int colCount = 0;

	public static Collider[] colBuffer = (Collider[])(object)new Collider[32768];

	private static HashSet<object> hashSet = new HashSet<object>();

	private static void Buffer(Vector3 position, float radius, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		layerMask = GamePhysics.HandleIgnoreCollision(position, layerMask);
		int num = colCount;
		colCount = Physics.OverlapSphereNonAlloc(position, radius, colBuffer, layerMask, triggerInteraction);
		for (int i = colCount; i < num; i++)
		{
			colBuffer[i] = null;
		}
		if (colCount >= colBuffer.Length)
		{
			Debug.LogWarning((object)"Vis query is exceeding collider buffer length.");
			colCount = colBuffer.Length;
		}
	}

	public static bool AnyColliders(Vector3 position, float radius, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		Buffer(position, radius, layerMask, triggerInteraction);
		return colCount > 0;
	}

	public static void Colliders<T>(Vector3 position, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : Collider
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		Buffer(position, radius, layerMask, triggerInteraction);
		for (int i = 0; i < colCount; i++)
		{
			Collider obj = colBuffer[i];
			T val = (T)(object)((obj is T) ? obj : null);
			if (!((Object)(object)val == (Object)null) && ((Collider)val).enabled)
			{
				list.Add(val);
			}
		}
	}

	public static void Components<T>(Vector3 position, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : Component
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		Buffer(position, radius, layerMask, triggerInteraction);
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if (!((Object)(object)val == (Object)null) && val.enabled)
			{
				T component = ((Component)val).GetComponent<T>();
				if (!((Object)(object)component == (Object)null))
				{
					list.Add(component);
				}
			}
		}
	}

	public static void Entities<T>(Vector3 position, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : class
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		Buffer(position, radius, layerMask, triggerInteraction);
		hashSet.Clear();
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if (!((Object)(object)val == (Object)null) && val.enabled && val.ToBaseEntity() is T item && !hashSet.Contains(item))
			{
				hashSet.Add(item);
				list.Add(item);
			}
		}
	}

	public static void EntityComponents<T>(Vector3 position, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : EntityComponentBase
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		Buffer(position, radius, layerMask, triggerInteraction);
		hashSet.Clear();
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if ((Object)(object)val == (Object)null || !val.enabled)
			{
				continue;
			}
			BaseEntity baseEntity = val.ToBaseEntity();
			if (!((Object)(object)baseEntity == (Object)null) && !hashSet.Contains(baseEntity))
			{
				hashSet.Add(baseEntity);
				T component = ((Component)baseEntity).GetComponent<T>();
				if (!((Object)(object)component == (Object)null))
				{
					list.Add(component);
				}
			}
		}
	}

	private static void Buffer(OBB bounds, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		layerMask = GamePhysics.HandleIgnoreCollision(bounds.position, layerMask);
		int num = colCount;
		colCount = Physics.OverlapBoxNonAlloc(bounds.position, bounds.extents, colBuffer, bounds.rotation, layerMask, triggerInteraction);
		for (int i = colCount; i < num; i++)
		{
			colBuffer[i] = null;
		}
		if (colCount >= colBuffer.Length)
		{
			Debug.LogWarning((object)"Vis query is exceeding collider buffer length.");
			colCount = colBuffer.Length;
		}
	}

	public static void Colliders<T>(OBB bounds, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : Collider
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Buffer(bounds, layerMask, triggerInteraction);
		for (int i = 0; i < colCount; i++)
		{
			Collider obj = colBuffer[i];
			T val = (T)(object)((obj is T) ? obj : null);
			if (!((Object)(object)val == (Object)null) && ((Collider)val).enabled)
			{
				list.Add(val);
			}
		}
	}

	public static void Components<T>(OBB bounds, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : Component
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Buffer(bounds, layerMask, triggerInteraction);
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if (!((Object)(object)val == (Object)null) && val.enabled)
			{
				T component = ((Component)val).GetComponent<T>();
				if (!((Object)(object)component == (Object)null))
				{
					list.Add(component);
				}
			}
		}
	}

	public static void Entities<T>(OBB bounds, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : class
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Buffer(bounds, layerMask, triggerInteraction);
		hashSet.Clear();
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if (!((Object)(object)val == (Object)null) && val.enabled && val.ToBaseEntity() is T item && !hashSet.Contains(item))
			{
				hashSet.Add(item);
				list.Add(item);
			}
		}
	}

	public static void EntityComponents<T>(OBB bounds, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : EntityComponentBase
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Buffer(bounds, layerMask, triggerInteraction);
		hashSet.Clear();
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if ((Object)(object)val == (Object)null || !val.enabled)
			{
				continue;
			}
			BaseEntity baseEntity = val.ToBaseEntity();
			if (!((Object)(object)baseEntity == (Object)null) && !hashSet.Contains(baseEntity))
			{
				hashSet.Add(baseEntity);
				T component = ((Component)baseEntity).GetComponent<T>();
				if (!((Object)(object)component == (Object)null))
				{
					list.Add(component);
				}
			}
		}
	}

	private static void Buffer(Vector3 startPosition, Vector3 endPosition, float radius, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		layerMask = GamePhysics.HandleIgnoreCollision(startPosition, layerMask);
		int num = colCount;
		colCount = Physics.OverlapCapsuleNonAlloc(startPosition, endPosition, radius, colBuffer, layerMask, triggerInteraction);
		for (int i = colCount; i < num; i++)
		{
			colBuffer[i] = null;
		}
		if (colCount >= colBuffer.Length)
		{
			Debug.LogWarning((object)"Vis query is exceeding collider buffer length.");
			colCount = colBuffer.Length;
		}
	}

	public static void Colliders<T>(Vector3 startPosition, Vector3 endPosition, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : Collider
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		Buffer(startPosition, endPosition, radius, layerMask, triggerInteraction);
		for (int i = 0; i < colCount; i++)
		{
			Collider obj = colBuffer[i];
			T val = (T)(object)((obj is T) ? obj : null);
			if (!((Object)(object)val == (Object)null) && ((Collider)val).enabled)
			{
				list.Add(val);
			}
		}
	}

	public static void Components<T>(Vector3 startPosition, Vector3 endPosition, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : Component
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		Buffer(startPosition, endPosition, radius, layerMask, triggerInteraction);
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if (!((Object)(object)val == (Object)null) && val.enabled)
			{
				T component = ((Component)val).GetComponent<T>();
				if (!((Object)(object)component == (Object)null))
				{
					list.Add(component);
				}
			}
		}
	}

	public static void Entities<T>(Vector3 startPosition, Vector3 endPosition, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : class
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		Buffer(startPosition, endPosition, radius, layerMask, triggerInteraction);
		hashSet.Clear();
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if (!((Object)(object)val == (Object)null) && val.enabled && val.ToBaseEntity() is T item && !hashSet.Contains(item))
			{
				hashSet.Add(item);
				list.Add(item);
			}
		}
	}

	public static void EntityComponents<T>(Vector3 startPosition, Vector3 endPosition, float radius, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = 2) where T : EntityComponentBase
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		Buffer(startPosition, endPosition, radius, layerMask, triggerInteraction);
		hashSet.Clear();
		for (int i = 0; i < colCount; i++)
		{
			Collider val = colBuffer[i];
			if ((Object)(object)val == (Object)null || !val.enabled)
			{
				continue;
			}
			BaseEntity baseEntity = val.ToBaseEntity();
			if (!((Object)(object)baseEntity == (Object)null) && !hashSet.Contains(baseEntity))
			{
				hashSet.Add(baseEntity);
				T component = ((Component)baseEntity).GetComponent<T>();
				if (!((Object)(object)component == (Object)null))
				{
					list.Add(component);
				}
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;
using UtilityJobs;
using WaterLevelJobs;

public static class WaterLevel
{
	public struct WaterInfo
	{
		public bool isValid;

		public float currentDepth;

		public float overallDepth;

		public float surfaceLevel;

		public float terrainHeight;

		public bool artificalWater;

		public int topology;
	}

	public const float InvalidWaterHeight = -1000f;

	private static NativeReference<int> CounterRef;

	private static NativeArray<Vector3> Centers;

	private static NativeArray<float> WaterHeights;

	private static NativeArray<float> TerrainHeights;

	private static NativeArray<int> Indices;

	private static NativeArray<bool> GetIgnoreResults;

	private static NativeArray<Vector3> GetIgnoreHeadStarts;

	private static NativeArray<float> GetIgnoreHeadRadii;

	private static NativeArray<Vector2> UVs;

	private static NativeArray<int> Topologies;

	private static NativeArray<float> ShoreDists;

	private static NativeArray<float> WaveHeights;

	public static float Factor(Vector3 start, Vector3 end, float radius, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.Factor", 0);
		try
		{
			return Factor(GetWaterInfo(start, end, radius, waves, volumes, forEntity), start, end, radius);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float Factor(in WaterInfo info, Vector3 start, Vector3 end, float radius)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!info.isValid)
		{
			return 0f;
		}
		return Mathf.InverseLerp(Mathf.Min(start.y, end.y) - radius, Mathf.Max(start.y, end.y) + radius, info.surfaceLevel);
	}

	public static float Factor(Bounds bounds, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.Factor", 0);
		try
		{
			if (((Bounds)(ref bounds)).size == Vector3.zero)
			{
				((Bounds)(ref bounds)).size = new Vector3(0.1f, 0.1f, 0.1f);
			}
			WaterInfo waterInfo = GetWaterInfo(bounds, waves, volumes, forEntity);
			return waterInfo.isValid ? Mathf.InverseLerp(((Bounds)(ref bounds)).min.y, ((Bounds)(ref bounds)).max.y, waterInfo.surfaceLevel) : 0f;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float Factor(in WaterInfo info, Bounds bounds)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if (((Bounds)(ref bounds)).size == Vector3.zero)
		{
			((Bounds)(ref bounds)).size = new Vector3(0.1f, 0.1f, 0.1f);
		}
		if (!info.isValid)
		{
			return 0f;
		}
		return Mathf.InverseLerp(((Bounds)(ref bounds)).min.y, ((Bounds)(ref bounds)).max.y, info.surfaceLevel);
	}

	public static bool Test(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.Test", 0);
		try
		{
			return GetWaterInfo(pos, waves, volumes, forEntity).isValid;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool Test(in WaterInfo info, bool volumes, Vector3 pos, BaseEntity forEntity = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		bool flag = pos.y >= info.terrainHeight - 1f && pos.y <= info.surfaceLevel;
		if (!flag && volumes)
		{
			flag = GetWaterInfoFromVolumes(pos, forEntity).isValid;
		}
		return flag;
	}

	public static (float, float) GetWaterAndTerrainSurface(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterDepth", 0);
		try
		{
			WaterInfo waterInfo = GetWaterInfo(pos, waves, volumes, forEntity);
			return (waterInfo.surfaceLevel, waterInfo.terrainHeight);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float GetWaterOrTerrainSurface(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterDepth", 0);
		try
		{
			WaterInfo waterInfo = GetWaterInfo(pos, waves, volumes, forEntity);
			return Mathf.Max(waterInfo.surfaceLevel, waterInfo.terrainHeight);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float GetWaterSurface(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterDepth", 0);
		try
		{
			return GetWaterInfo(pos, waves, volumes, forEntity).surfaceLevel;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float GetWaterDepth(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterDepth", 0);
		try
		{
			return GetWaterInfo(pos, waves, volumes, forEntity).currentDepth;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float GetOverallWaterDepth(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetOverallWaterDepth", 0);
		try
		{
			return GetWaterInfo(pos, waves, volumes, forEntity).overallDepth;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static Vector3 GetWaterFlowDirection(Vector3 worldPosition)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.WaterFlowMap == (Object)null)
		{
			return Vector3.zero;
		}
		return TerrainMeta.WaterFlowMap.GetFlowDirection(worldPosition);
	}

	public static Vector3 GetWaterNormal(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.up;
	}

	public static WaterInfo GetBuoyancyWaterInfo(Vector3 pos, Vector2 posUV, float terrainHeight, float waterHeight, bool doDeepwaterChecks, BaseEntity forEntity)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterInfo", 0);
		try
		{
			WaterInfo result = default(WaterInfo);
			if (pos.y > waterHeight)
			{
				return GetWaterInfoFromVolumes(pos, forEntity);
			}
			bool flag = pos.y < terrainHeight - 1f;
			if (flag)
			{
				return GetWaterInfoFromVolumes(pos, forEntity);
			}
			bool flag2 = doDeepwaterChecks && (pos.y < waterHeight - 10f || TerrainMeta.OutOfBounds(pos));
			int num = (Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap) ? TerrainMeta.TopologyMap.GetTopologyFast(posUV) : 0);
			if ((flag || flag2 || (num & 0x3C180) == 0) && Object.op_Implicit((Object)(object)WaterSystem.Collision) && WaterSystem.Collision.GetIgnore(pos))
			{
				return result;
			}
			RaycastHit val2 = default(RaycastHit);
			if (flag2 && Physics.Raycast(pos, Vector3.up, ref val2, 5f, 16, (QueryTriggerInteraction)2))
			{
				float num2 = waterHeight;
				Bounds bounds = ((RaycastHit)(ref val2)).collider.bounds;
				waterHeight = Mathf.Min(num2, ((Bounds)(ref bounds)).max.y);
			}
			result.isValid = true;
			result.currentDepth = Mathf.Max(0f, waterHeight - pos.y);
			result.overallDepth = Mathf.Max(0f, waterHeight - terrainHeight);
			result.surfaceLevel = waterHeight;
			result.terrainHeight = terrainHeight;
			result.topology = num;
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static WaterInfo GetWaterInfo(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterInfo", 0);
		try
		{
			WaterInfo result = default(WaterInfo);
			float num = GetWaterLevel(pos, waves);
			float num2 = ((Object.op_Implicit((Object)(object)TerrainMeta.HeightMap) && TerrainMeta.HeightMap.isInitialized) ? TerrainMeta.HeightMap.GetHeight(pos) : 0f);
			result.isValid = true;
			if (pos.y > num)
			{
				result.isValid = false;
			}
			else if (pos.y < num2 - 1f)
			{
				result.isValid = false;
			}
			bool flag = false;
			if (!result.isValid && volumes)
			{
				result = GetWaterInfoFromVolumes(pos, forEntity);
				if (result.isValid)
				{
					flag = true;
					num = result.surfaceLevel;
				}
			}
			if (result.isValid && Object.op_Implicit((Object)(object)WaterSystem.Collision) && WaterSystem.Collision.GetIgnore(pos))
			{
				result.isValid = false;
				num = -1000f;
			}
			result.currentDepth = Mathf.Max(0f, num - pos.y);
			if (!flag)
			{
				result.overallDepth = Mathf.Max(0f, num - num2);
			}
			result.surfaceLevel = num;
			result.terrainHeight = num2;
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static WaterInfo GetWaterInfo(Bounds bounds, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterInfo", 0);
		try
		{
			WaterInfo result = default(WaterInfo);
			float num = GetWaterLevel(((Bounds)(ref bounds)).center, waves);
			float num2 = (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap) ? TerrainMeta.HeightMap.GetHeight(((Bounds)(ref bounds)).center) : 0f);
			result.isValid = true;
			if (((Bounds)(ref bounds)).min.y > num)
			{
				result.isValid = false;
			}
			else if (((Bounds)(ref bounds)).max.y < num2 - 1f)
			{
				result.isValid = false;
			}
			if (!result.isValid && volumes)
			{
				result = GetWaterInfoFromVolumes(bounds, forEntity);
				if (result.isValid)
				{
					num = result.surfaceLevel;
				}
			}
			if (result.isValid && Object.op_Implicit((Object)(object)WaterSystem.Collision) && WaterSystem.Collision.GetIgnore(bounds))
			{
				result.isValid = false;
				num = -1000f;
			}
			result.currentDepth = Mathf.Max(0f, num - ((Bounds)(ref bounds)).min.y);
			result.overallDepth = Mathf.Max(0f, num - num2);
			result.surfaceLevel = num;
			result.terrainHeight = num2;
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void InitInternalState(int initCap)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		DisposeInternalState();
		CounterRef = new NativeReference<int>(AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)0);
		Centers = new NativeArray<Vector3>(initCap, (Allocator)4, (NativeArrayOptions)0);
		WaterHeights = new NativeArray<float>(initCap, (Allocator)4, (NativeArrayOptions)0);
		TerrainHeights = new NativeArray<float>(initCap, (Allocator)4, (NativeArrayOptions)0);
		Indices = new NativeArray<int>(initCap, (Allocator)4, (NativeArrayOptions)0);
		GetIgnoreResults = new NativeArray<bool>(initCap, (Allocator)4, (NativeArrayOptions)0);
		GetIgnoreHeadStarts = new NativeArray<Vector3>(initCap, (Allocator)4, (NativeArrayOptions)0);
		GetIgnoreHeadRadii = new NativeArray<float>(initCap, (Allocator)4, (NativeArrayOptions)0);
		UVs = new NativeArray<Vector2>(initCap, (Allocator)4, (NativeArrayOptions)0);
		Topologies = new NativeArray<int>(initCap, (Allocator)4, (NativeArrayOptions)0);
		ShoreDists = new NativeArray<float>(initCap, (Allocator)4, (NativeArrayOptions)0);
		WaveHeights = new NativeArray<float>(initCap, (Allocator)4, (NativeArrayOptions)0);
	}

	public static void DisposeInternalState()
	{
		NativeReferenceEx.SafeDispose(ref CounterRef);
		Centers.SafeDispose<Vector3>();
		NativeArrayEx.SafeDispose(ref WaterHeights);
		NativeArrayEx.SafeDispose(ref TerrainHeights);
		NativeArrayEx.SafeDispose(ref Indices);
		NativeArrayEx.SafeDispose(ref GetIgnoreResults);
		GetIgnoreHeadStarts.SafeDispose<Vector3>();
		NativeArrayEx.SafeDispose(ref GetIgnoreHeadRadii);
		UVs.SafeDispose<Vector2>();
		NativeArrayEx.SafeDispose(ref Topologies);
		NativeArrayEx.SafeDispose(ref ShoreDists);
		NativeArrayEx.SafeDispose(ref WaveHeights);
	}

	public static void GetWaterInfos(ReadOnly<Vector3> starts, ReadOnly<Vector3> ends, ReadOnly<float> radii, ReadOnlySpan<BaseEntity> entities, ReadOnly<int> indices, bool waves, bool volumes, NativeArray<WaterInfo> results)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0433: Unknown result type (might be due to invalid IL or missing references)
		//IL_0435: Unknown result type (might be due to invalid IL or missing references)
		//IL_043c: Unknown result type (might be due to invalid IL or missing references)
		//IL_043d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0444: Unknown result type (might be due to invalid IL or missing references)
		//IL_0445: Unknown result type (might be due to invalid IL or missing references)
		//IL_044c: Unknown result type (might be due to invalid IL or missing references)
		//IL_044d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0459: Unknown result type (might be due to invalid IL or missing references)
		//IL_045e: Unknown result type (might be due to invalid IL or missing references)
		//IL_046a: Unknown result type (might be due to invalid IL or missing references)
		//IL_046f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0476: Unknown result type (might be due to invalid IL or missing references)
		//IL_0478: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_02aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02af: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_0308: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0314: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0325: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_032d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0334: Unknown result type (might be due to invalid IL or missing references)
		//IL_0335: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_033d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0387: Unknown result type (might be due to invalid IL or missing references)
		//IL_0391: Unknown result type (might be due to invalid IL or missing references)
		//IL_0398: Unknown result type (might be due to invalid IL or missing references)
		//IL_039d: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03de: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ef: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetWaterInfos", 0);
		try
		{
			Centers.Expand<Vector3>(starts.Length, (NativeArrayOptions)0, copyContents: false);
			CalcCenterJobIndirect calcCenterJobIndirect = default(CalcCenterJobIndirect);
			calcCenterJobIndirect.Results = Centers;
			calcCenterJobIndirect.Starts = starts;
			calcCenterJobIndirect.Ends = ends;
			calcCenterJobIndirect.Indices = indices;
			CalcCenterJobIndirect calcCenterJobIndirect2 = calcCenterJobIndirect;
			IJobExtensions.RunByRef<CalcCenterJobIndirect>(ref calcCenterJobIndirect2);
			NativeArrayEx.Expand(ref WaterHeights, starts.Length, (NativeArrayOptions)0, copyContents: false);
			GetWaterLevels(Centers.AsReadOnly(), indices, waves, WaterHeights);
			NativeArrayEx.Expand(ref TerrainHeights, starts.Length, (NativeArrayOptions)0, copyContents: false);
			TerrainMeta.HeightMap?.GetHeightsIndirect(Centers.AsReadOnly(), indices, TerrainHeights);
			NativeArrayEx.Expand(ref Indices, starts.Length, (NativeArrayOptions)0, copyContents: false);
			InitialValidateInfoJobIndirect initialValidateInfoJobIndirect = default(InitialValidateInfoJobIndirect);
			initialValidateInfoJobIndirect.Results = results;
			initialValidateInfoJobIndirect.Starts = starts;
			initialValidateInfoJobIndirect.Ends = ends;
			initialValidateInfoJobIndirect.Radii = radii;
			initialValidateInfoJobIndirect.WaterHeights = WaterHeights.AsReadOnly();
			initialValidateInfoJobIndirect.TerrainHeights = TerrainHeights.AsReadOnly();
			initialValidateInfoJobIndirect.Indices = indices;
			InitialValidateInfoJobIndirect initialValidateInfoJobIndirect2 = initialValidateInfoJobIndirect;
			IJobExtensions.RunByRef<InitialValidateInfoJobIndirect>(ref initialValidateInfoJobIndirect2);
			if (volumes)
			{
				TimeWarning val2 = TimeWarning.New("WaterTestFromVolumes", 0);
				try
				{
					GatherInvalidInfosJobIndirect gatherInvalidInfosJobIndirect = default(GatherInvalidInfosJobIndirect);
					gatherInvalidInfosJobIndirect.InvalidIndices = Indices;
					gatherInvalidInfosJobIndirect.InvalidIndexCount = CounterRef;
					gatherInvalidInfosJobIndirect.Infos = results.AsReadOnly();
					gatherInvalidInfosJobIndirect.Indices = indices;
					GatherInvalidInfosJobIndirect gatherInvalidInfosJobIndirect2 = gatherInvalidInfosJobIndirect;
					IJobExtensions.RunByRef<GatherInvalidInfosJobIndirect>(ref gatherInvalidInfosJobIndirect2);
					int value = CounterRef.Value;
					if (value > 0)
					{
						NativeArray<int> subArray = Indices.GetSubArray(0, value);
						BaseEntity.WaterTestFromVolumesIndirect(entities, ReadOnly<Vector3>.op_Implicit(ref starts), ReadOnly<Vector3>.op_Implicit(ref ends), ReadOnly<float>.op_Implicit(ref radii), NativeArray<int>.op_Implicit(ref subArray), NativeArray<WaterInfo>.op_Implicit(ref results));
						UpdateWaterHeightsJobIndirect updateWaterHeightsJobIndirect = default(UpdateWaterHeightsJobIndirect);
						updateWaterHeightsJobIndirect.WaterHeights = WaterHeights;
						updateWaterHeightsJobIndirect.Infos = results;
						updateWaterHeightsJobIndirect.Indices = subArray;
						UpdateWaterHeightsJobIndirect updateWaterHeightsJobIndirect2 = updateWaterHeightsJobIndirect;
						IJobExtensions.RunByRef<UpdateWaterHeightsJobIndirect>(ref updateWaterHeightsJobIndirect2);
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			if (Object.op_Implicit((Object)(object)WaterSystem.Collision))
			{
				TimeWarning val3 = TimeWarning.New("WaterSystem.Collision", 0);
				try
				{
					GatherValidInfosJobIndirect gatherValidInfosJobIndirect = default(GatherValidInfosJobIndirect);
					gatherValidInfosJobIndirect.ValidIndices = Indices;
					gatherValidInfosJobIndirect.ValidIndexCount = CounterRef;
					gatherValidInfosJobIndirect.Infos = results.AsReadOnly();
					gatherValidInfosJobIndirect.Indices = indices;
					GatherValidInfosJobIndirect gatherValidInfosJobIndirect2 = gatherValidInfosJobIndirect;
					IJobExtensions.RunByRef<GatherValidInfosJobIndirect>(ref gatherValidInfosJobIndirect2);
					int value2 = CounterRef.Value;
					if (value2 > 0)
					{
						TimeWarning val4 = TimeWarning.New("WaterSystem.Collision.Entity", 0);
						try
						{
							NativeArray<int> subArray2 = Indices.GetSubArray(0, value2);
							NativeArrayEx.Expand(ref GetIgnoreResults, starts.Length, (NativeArrayOptions)0, copyContents: false);
							WaterSystem.Collision.GetIgnoreIndirect(starts, ends, radii, subArray2.AsReadOnly(), GetIgnoreResults);
							GetIgnoreHeadStarts.Expand<Vector3>(starts.Length, (NativeArrayOptions)0, copyContents: false);
							NativeArrayEx.Expand(ref GetIgnoreHeadRadii, starts.Length, (NativeArrayOptions)0, copyContents: false);
							SetupHeadQueryJobIndirect setupHeadQueryJobIndirect = default(SetupHeadQueryJobIndirect);
							setupHeadQueryJobIndirect.Indices = subArray2;
							setupHeadQueryJobIndirect.QueryIndexCount = CounterRef;
							setupHeadQueryJobIndirect.QueryStarts = GetIgnoreHeadStarts;
							setupHeadQueryJobIndirect.QueryRadii = GetIgnoreHeadRadii;
							setupHeadQueryJobIndirect.ValidInfos = GetIgnoreResults.AsReadOnly();
							setupHeadQueryJobIndirect.Starts = starts;
							setupHeadQueryJobIndirect.Ends = ends;
							setupHeadQueryJobIndirect.Radii = radii;
							SetupHeadQueryJobIndirect setupHeadQueryJobIndirect2 = setupHeadQueryJobIndirect;
							IJobExtensions.RunByRef<SetupHeadQueryJobIndirect>(ref setupHeadQueryJobIndirect2);
							int value3 = CounterRef.Value;
							if (value3 > 0)
							{
								TimeWarning val5 = TimeWarning.New("WaterSystem.Collision.Head", 0);
								try
								{
									NativeArray<int> subArray3 = Indices.GetSubArray(0, value3);
									WaterSystem.Collision.GetIgnoreIndirect(GetIgnoreHeadStarts.AsReadOnly(), GetIgnoreHeadRadii.AsReadOnly(), subArray3.AsReadOnly(), GetIgnoreResults);
									ApplyHeadQueryResultsJobIndirect applyHeadQueryResultsJobIndirect = default(ApplyHeadQueryResultsJobIndirect);
									applyHeadQueryResultsJobIndirect.WaterHeights = WaterHeights;
									applyHeadQueryResultsJobIndirect.Infos = results;
									applyHeadQueryResultsJobIndirect.Indices = subArray3.AsReadOnly();
									applyHeadQueryResultsJobIndirect.ValidInfos = GetIgnoreResults.AsReadOnly();
									applyHeadQueryResultsJobIndirect.Starts = GetIgnoreHeadStarts.AsReadOnly();
									ApplyHeadQueryResultsJobIndirect applyHeadQueryResultsJobIndirect2 = applyHeadQueryResultsJobIndirect;
									IJobExtensions.RunByRef<ApplyHeadQueryResultsJobIndirect>(ref applyHeadQueryResultsJobIndirect2);
								}
								finally
								{
									((IDisposable)val5)?.Dispose();
								}
							}
						}
						finally
						{
							((IDisposable)val4)?.Dispose();
						}
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
			ResolveWaterInfosJobIndirect resolveWaterInfosJobIndirect = default(ResolveWaterInfosJobIndirect);
			resolveWaterInfosJobIndirect.Infos = results;
			resolveWaterInfosJobIndirect.Starts = starts;
			resolveWaterInfosJobIndirect.Ends = ends;
			resolveWaterInfosJobIndirect.Radii = radii;
			resolveWaterInfosJobIndirect.WaterHeights = WaterHeights.AsReadOnly();
			resolveWaterInfosJobIndirect.TerrainHeights = TerrainHeights.AsReadOnly();
			resolveWaterInfosJobIndirect.Indices = indices;
			ResolveWaterInfosJobIndirect resolveWaterInfosJobIndirect2 = resolveWaterInfosJobIndirect;
			IJobExtensions.RunByRef<ResolveWaterInfosJobIndirect>(ref resolveWaterInfosJobIndirect2);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static WaterInfo GetWaterInfo(Vector3 start, Vector3 end, float radius, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterInfo", 0);
		try
		{
			WaterInfo result = default(WaterInfo);
			Vector3 val2 = (start + end) * 0.5f;
			float num = Mathf.Min(start.y, end.y) - radius;
			float num2 = Mathf.Max(start.y, end.y) + radius;
			float num3 = GetWaterLevel(val2, waves);
			float num4 = (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap) ? TerrainMeta.HeightMap.GetHeight(val2) : 0f);
			result.isValid = true;
			if (num > num3)
			{
				result.isValid = false;
			}
			else if (num2 < num4 - 1f)
			{
				result.isValid = false;
			}
			if (!result.isValid && volumes)
			{
				result = GetWaterInfoFromVolumes(start, end, radius, forEntity);
				if (result.isValid)
				{
					num3 = result.surfaceLevel;
				}
			}
			if (result.isValid && Object.op_Implicit((Object)(object)WaterSystem.Collision) && WaterSystem.Collision.GetIgnore(start, end, radius))
			{
				Vector3 val3 = Vector3Ex.WithY(val2, Mathf.Lerp(num, num2, 0.75f));
				if (!WaterSystem.Collision.GetIgnore(val3))
				{
					num3 = Mathf.Min(num3, val3.y);
				}
				else
				{
					result.isValid = false;
					num3 = -1000f;
				}
			}
			result.currentDepth = Mathf.Max(0f, num3 - num);
			result.overallDepth = Mathf.Max(0f, num3 - num4);
			result.surfaceLevel = num3;
			result.terrainHeight = num4;
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static WaterInfo GetWaterInfo(Camera cam, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevel.GetWaterInfo", 0);
		try
		{
			waves = waves && (Object)(object)WaterSystem.Instance != (Object)null;
			float num = WaterSystem.OceanLevel;
			if (waves)
			{
				num += WaterSystem.Instance.oceanSimulation.MinLevel();
			}
			if (((Component)cam).transform.position.y < num - 1f)
			{
				return GetWaterInfo(((Component)cam).transform.position, waves, volumes, forEntity);
			}
			return GetWaterInfo(((Component)cam).transform.position - Vector3.up, waves, volumes, forEntity);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static float GetWaterLevel(Vector3 pos, bool waves)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		waves = waves && (Object)(object)WaterSystem.Instance != (Object)null;
		float normX = TerrainMeta.NormalizeX(pos.x);
		float normZ = TerrainMeta.NormalizeZ(pos.z);
		float num = (Object.op_Implicit((Object)(object)TerrainMeta.WaterMap) ? TerrainMeta.WaterMap.GetHeight(normX, normZ) : TerrainMeta.Position.y);
		float num2 = WaterSystem.OceanLevel;
		if (waves)
		{
			num2 += WaterSystem.Instance.oceanSimulation.MaxLevel();
		}
		if (num < num2 && (!Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap) || TerrainMeta.TopologyMap.GetTopology(normX, normZ, 384)))
		{
			float num3 = WaterSystem.OceanLevel;
			if (waves)
			{
				num3 += WaterSystem.Instance.oceanSimulation.GetHeight(pos);
			}
			return Mathf.Max(num, num3);
		}
		return num;
	}

	public static float RaycastWaterColliders(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (!Physics.Raycast(Vector3Ex.WithY(pos, TerrainMeta.Max.y), Vector3.down, ref val, TerrainMeta.Size.y, 16, (QueryTriggerInteraction)2))
		{
			return WaterSystem.OceanLevel;
		}
		return ((RaycastHit)(ref val)).point.y;
	}

	public static void GetWaterLevels(ReadOnly<Vector3> positions, ReadOnly<int> indices, bool waves, NativeArray<float> heights)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0315: Unknown result type (might be due to invalid IL or missing references)
		//IL_031a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0340: Unknown result type (might be due to invalid IL or missing references)
		//IL_0346: Unknown result type (might be due to invalid IL or missing references)
		//IL_0350: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_0357: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_036c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0378: Unknown result type (might be due to invalid IL or missing references)
		//IL_037d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0384: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterLevels", 0);
		try
		{
			waves = waves && (Object)(object)WaterSystem.Instance != (Object)null;
			float num = WaterSystem.OceanLevel;
			if (waves)
			{
				num += WaterSystem.Instance.oceanSimulation.MaxLevel();
			}
			UVs.Expand<Vector2>(positions.Length, (NativeArrayOptions)0, copyContents: false);
			NativeArray<Vector2> subArray = UVs.GetSubArray(0, positions.Length);
			ToUVJobIndirect toUVJobIndirect = default(ToUVJobIndirect);
			toUVJobIndirect.UV = subArray;
			toUVJobIndirect.Pos = positions;
			toUVJobIndirect.Indices = indices;
			toUVJobIndirect.TerrainPos = Vector3Ex.XZ2D(TerrainMeta.Position);
			toUVJobIndirect.TerrainOneOverSize = Vector3Ex.XZ2D(TerrainMeta.OneOverSize);
			ToUVJobIndirect toUVJobIndirect2 = toUVJobIndirect;
			IJobExtensions.RunByRef<ToUVJobIndirect>(ref toUVJobIndirect2);
			if (Object.op_Implicit((Object)(object)TerrainMeta.WaterMap))
			{
				TerrainMeta.WaterMap.GetHeightsIndirect(subArray.AsReadOnly(), indices, heights);
			}
			else
			{
				FillJob<float> fillJob = default(FillJob<float>);
				fillJob.Values = heights;
				fillJob.Value = TerrainMeta.Position.y;
				FillJob<float> fillJob2 = fillJob;
				IJobExtensions.RunByRef<FillJob<float>>(ref fillJob2);
			}
			NativeArrayEx.Expand(ref Topologies, positions.Length, (NativeArrayOptions)0, copyContents: false);
			NativeArray<int> subArray2 = Topologies.GetSubArray(0, positions.Length);
			if (Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap))
			{
				TerrainMeta.TopologyMap.GetTopologiesIndirect(subArray.AsReadOnly(), indices, subArray2);
			}
			else
			{
				FillJob<int> fillJob3 = default(FillJob<int>);
				fillJob3.Values = subArray2;
				fillJob3.Value = 384;
				FillJob<int> fillJob4 = fillJob3;
				IJobExtensions.RunByRef<FillJob<int>>(ref fillJob4);
			}
			if (!waves)
			{
				ApplyMaxHeightsJobIndirect applyMaxHeightsJobIndirect = default(ApplyMaxHeightsJobIndirect);
				applyMaxHeightsJobIndirect.Heights = heights;
				applyMaxHeightsJobIndirect.Topologies = subArray2.AsReadOnly();
				applyMaxHeightsJobIndirect.Indices = indices;
				applyMaxHeightsJobIndirect.WaterLevel = num;
				applyMaxHeightsJobIndirect.OceanLevel = WaterSystem.OceanLevel;
				ApplyMaxHeightsJobIndirect applyMaxHeightsJobIndirect2 = applyMaxHeightsJobIndirect;
				IJobExtensions.RunByRef<ApplyMaxHeightsJobIndirect>(ref applyMaxHeightsJobIndirect2);
				return;
			}
			NativeArrayEx.Expand(ref Indices, positions.Length, (NativeArrayOptions)0, copyContents: false);
			GatherWavesIndicesJobIndirect gatherWavesIndicesJobIndirect = default(GatherWavesIndicesJobIndirect);
			gatherWavesIndicesJobIndirect.WaveIndices = Indices;
			gatherWavesIndicesJobIndirect.WaveIndexCount = CounterRef;
			gatherWavesIndicesJobIndirect.Topologies = subArray2.AsReadOnly();
			gatherWavesIndicesJobIndirect.Heights = heights.AsReadOnly();
			gatherWavesIndicesJobIndirect.Indices = indices;
			gatherWavesIndicesJobIndirect.WaterLevel = num;
			GatherWavesIndicesJobIndirect gatherWavesIndicesJobIndirect2 = gatherWavesIndicesJobIndirect;
			IJobExtensions.RunByRef<GatherWavesIndicesJobIndirect>(ref gatherWavesIndicesJobIndirect2);
			int value = CounterRef.Value;
			if (value == 0)
			{
				return;
			}
			TimeWarning val2 = TimeWarning.New("Waves", 0);
			try
			{
				NativeArrayEx.Expand(ref TerrainHeights, positions.Length, (NativeArrayOptions)0, copyContents: false);
				NativeArrayEx.Expand(ref ShoreDists, positions.Length, (NativeArrayOptions)0, copyContents: false);
				NativeArrayEx.Expand(ref WaveHeights, positions.Length, (NativeArrayOptions)0, copyContents: false);
				ReadOnly<int> indices2 = Indices.GetSubArray(0, value).AsReadOnly();
				if (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap))
				{
					TerrainMeta.HeightMap.GetHeightsFastIndirect(subArray.AsReadOnly(), indices2, TerrainHeights);
				}
				else
				{
					FillJob<float> fillJob = default(FillJob<float>);
					fillJob.Values = TerrainHeights;
					fillJob.Value = 0f;
					FillJob<float> fillJob5 = fillJob;
					IJobExtensions.RunByRef<FillJob<float>>(ref fillJob5);
				}
				if (Object.op_Implicit((Object)(object)TerrainTexturing.Instance))
				{
					TerrainTexturing.Instance.GetCoarseDistancesToShoreIndirect(subArray.AsReadOnly(), indices2, ShoreDists);
				}
				else
				{
					FillJob<float> fillJob = default(FillJob<float>);
					fillJob.Values = ShoreDists;
					fillJob.Value = 0f;
					FillJob<float> fillJob6 = fillJob;
					IJobExtensions.RunByRef<FillJob<float>>(ref fillJob6);
				}
				WaterSystem.Instance.oceanSimulation.GetHeightsIndirect(positions, ShoreDists.AsReadOnly(), TerrainHeights.AsReadOnly(), indices2, WaveHeights);
				SelectMaxWaterLevelJobIndirect selectMaxWaterLevelJobIndirect = default(SelectMaxWaterLevelJobIndirect);
				selectMaxWaterLevelJobIndirect.Heights = heights;
				selectMaxWaterLevelJobIndirect.DynamicHeights = WaveHeights.AsReadOnly();
				selectMaxWaterLevelJobIndirect.Indices = indices2;
				selectMaxWaterLevelJobIndirect.OceanLevel = WaterSystem.OceanLevel;
				SelectMaxWaterLevelJobIndirect selectMaxWaterLevelJobIndirect2 = selectMaxWaterLevelJobIndirect;
				IJobExtensions.RunByRef<SelectMaxWaterLevelJobIndirect>(ref selectMaxWaterLevelJobIndirect2);
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static WaterInfo GetWaterInfoFromVolumes(Bounds bounds, BaseEntity forEntity)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		WaterInfo info = default(WaterInfo);
		if ((Object)(object)forEntity == (Object)null)
		{
			List<WaterVolume> list = Pool.Get<List<WaterVolume>>();
			Vis.Components<WaterVolume>(new OBB(bounds), list, 262144, (QueryTriggerInteraction)2);
			using (List<WaterVolume>.Enumerator enumerator = list.GetEnumerator())
			{
				while (enumerator.MoveNext() && !enumerator.Current.Test(bounds, out info))
				{
				}
			}
			Pool.FreeUnmanaged<WaterVolume>(ref list);
			return info;
		}
		forEntity.WaterTestFromVolumes(bounds, out info);
		return info;
	}

	private static WaterInfo GetWaterInfoFromVolumes(Vector3 pos, BaseEntity forEntity)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		WaterInfo info = default(WaterInfo);
		if ((Object)(object)forEntity == (Object)null)
		{
			List<WaterVolume> list = Pool.Get<List<WaterVolume>>();
			Vis.Components<WaterVolume>(pos, 0.1f, list, 262144, (QueryTriggerInteraction)2);
			foreach (WaterVolume item in list)
			{
				if (item.Test(pos, out info))
				{
					info.artificalWater = !item.naturalSource;
					break;
				}
			}
			Pool.FreeUnmanaged<WaterVolume>(ref list);
			return info;
		}
		forEntity.WaterTestFromVolumes(pos, out info);
		return info;
	}

	private static WaterInfo GetWaterInfoFromVolumes(Vector3 start, Vector3 end, float radius, BaseEntity forEntity)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		WaterInfo info = default(WaterInfo);
		if ((Object)(object)forEntity == (Object)null)
		{
			List<WaterVolume> list = Pool.Get<List<WaterVolume>>();
			Vis.Components<WaterVolume>(start, end, radius, list, 262144, (QueryTriggerInteraction)2);
			using (List<WaterVolume>.Enumerator enumerator = list.GetEnumerator())
			{
				while (enumerator.MoveNext() && !enumerator.Current.Test(start, end, radius, out info))
				{
				}
			}
			Pool.FreeUnmanaged<WaterVolume>(ref list);
			return info;
		}
		forEntity.WaterTestFromVolumes(start, end, radius, out info);
		return info;
	}

	public static WaterInfo InitialValidate(Vector3 start, Vector3 end, float radius, float waterHeight, float terrainHeight)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		WaterInfo result = default(WaterInfo);
		result.isValid = true;
		float num = Mathf.Min(start.y, end.y) - radius;
		float num2 = Mathf.Max(start.y, end.y) + radius;
		if (num > waterHeight)
		{
			result.isValid = false;
		}
		else if (num2 < terrainHeight - 1f)
		{
			result.isValid = false;
		}
		return result;
	}
}


public struct WaterInfo
{
	public bool isValid;

	public float currentDepth;

	public float overallDepth;

	public float surfaceLevel;

	public float terrainHeight;

	public bool artificalWater;

	public int topology;
}


using UnityEngine;

public class WaterResource
{
	public static ItemDefinition SV_GetAtPoint(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (IsRadioactive(pos))
		{
			return WaterTypes.RadioactiveWaterItemDef;
		}
		if (!IsFreshWater(pos))
		{
			return WaterTypes.SaltWaterItemDef;
		}
		return WaterTypes.WaterItemDef;
	}

	public static WaterBody FindWaterBodyAtPos(Vector3 pos)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		float num = 1.5f;
		RaycastHit hitInfo;
		bool num2 = GamePhysics.Trace(new Ray(pos + Vector3.up * num, Vector3.down), 0f, out hitInfo, 3f, 16, (QueryTriggerInteraction)0);
		WaterBody result = null;
		if (num2)
		{
			result = hitInfo.GetWaterBody();
		}
		return result;
	}

	public static bool IsRadioactive(WaterBody body)
	{
		return body.Type == WaterBodyType.Radioactive;
	}

	public static bool IsRadioactive(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		WaterBody waterBody = FindWaterBodyAtPos(pos);
		if (Object.op_Implicit((Object)(object)waterBody))
		{
			return waterBody.Type == WaterBodyType.Radioactive;
		}
		return false;
	}

	public static bool IsFreshWater(Vector3 pos)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.TopologyMap == (Object)null)
		{
			return false;
		}
		return TerrainMeta.TopologyMap.GetTopology(pos, 245760);
	}

	public static ItemDefinition Merge(ItemDefinition first, ItemDefinition second)
	{
		if ((Object)(object)first == (Object)(object)second)
		{
			return first;
		}
		if ((Object)(object)first == (Object)(object)WaterTypes.RadioactiveWaterItemDef || (Object)(object)second == (Object)(object)WaterTypes.RadioactiveWaterItemDef)
		{
			return WaterTypes.RadioactiveWaterItemDef;
		}
		if ((Object)(object)first == (Object)(object)WaterTypes.SaltWaterItemDef || (Object)(object)second == (Object)(object)WaterTypes.SaltWaterItemDef)
		{
			return WaterTypes.SaltWaterItemDef;
		}
		return WaterTypes.WaterItemDef;
	}
}


using UnityEngine;

public static class WaterTypes
{
	private static ItemDefinition _waterItemDef;

	private static ItemDefinition _saltWaterItemDef;

	private static ItemDefinition _radioactiveWaterItemDef;

	public static ItemDefinition WaterItemDef
	{
		get
		{
			if ((Object)(object)_waterItemDef == (Object)null)
			{
				_waterItemDef = ItemManager.FindItemDefinition("water");
			}
			return _waterItemDef;
		}
	}

	public static ItemDefinition SaltWaterItemDef
	{
		get
		{
			if ((Object)(object)_saltWaterItemDef == (Object)null)
			{
				_saltWaterItemDef = ItemManager.FindItemDefinition("water.salt");
			}
			return _saltWaterItemDef;
		}
	}

	public static ItemDefinition RadioactiveWaterItemDef
	{
		get
		{
			if ((Object)(object)_radioactiveWaterItemDef == (Object)null)
			{
				_radioactiveWaterItemDef = ItemManager.FindItemDefinition("water.radioactive");
			}
			return _radioactiveWaterItemDef;
		}
	}
}


using UnityEngine;

public class WaterVolume : TriggerBase
{
	public Bounds WaterBounds = new Bounds(Vector3.zero, Vector3.one);

	private OBB cachedBounds;

	private Transform cachedTransform;

	public Transform[] cutOffPlanes = (Transform[])(object)new Transform[0];

	[Tooltip("Allows filling bota bags, jugs, etc. Don't turn this on if the player is responsible for filling this water volume as that will allow water duplication")]
	public bool naturalSource;

	public bool waterEnabled = true;

	private void OnEnable()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		cachedTransform = ((Component)this).transform;
		cachedBounds = new OBB(cachedTransform, WaterBounds);
	}

	private Plane GetWaterPlane()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		return new Plane(cachedBounds.up, cachedBounds.position);
	}

	public bool Test(Vector3 pos, out WaterLevel.WaterInfo info)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		if (!waterEnabled)
		{
			info = default(WaterLevel.WaterInfo);
			return false;
		}
		UpdateCachedTransform();
		if (((OBB)(ref cachedBounds)).Contains(pos))
		{
			if (!CheckCutOffPlanes(pos, out var bottomCutY))
			{
				info = default(WaterLevel.WaterInfo);
				return false;
			}
			Plane waterPlane = GetWaterPlane();
			Vector3 val = ((Plane)(ref waterPlane)).ClosestPointOnPlane(pos);
			float y = (val + cachedBounds.up * cachedBounds.extents.y).y;
			float y2 = (val + -cachedBounds.up * cachedBounds.extents.y).y;
			y2 = Mathf.Max(y2, bottomCutY);
			info = default(WaterLevel.WaterInfo);
			info.isValid = true;
			info.currentDepth = Mathf.Max(0f, y - pos.y);
			info.overallDepth = Mathf.Max(0f, y - y2);
			info.surfaceLevel = y;
			return true;
		}
		info = default(WaterLevel.WaterInfo);
		return false;
	}

	public bool Test(Bounds bounds, out WaterLevel.WaterInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		if (!waterEnabled)
		{
			info = default(WaterLevel.WaterInfo);
			return false;
		}
		UpdateCachedTransform();
		if (((OBB)(ref cachedBounds)).Contains(((Bounds)(ref bounds)).ClosestPoint(cachedBounds.position)))
		{
			if (!CheckCutOffPlanes(((Bounds)(ref bounds)).center, out var bottomCutY))
			{
				info = default(WaterLevel.WaterInfo);
				return false;
			}
			Plane waterPlane = GetWaterPlane();
			Vector3 val = ((Plane)(ref waterPlane)).ClosestPointOnPlane(((Bounds)(ref bounds)).center);
			float y = (val + cachedBounds.up * cachedBounds.extents.y).y;
			float y2 = (val + -cachedBounds.up * cachedBounds.extents.y).y;
			y2 = Mathf.Max(y2, bottomCutY);
			info = default(WaterLevel.WaterInfo);
			info.isValid = true;
			info.currentDepth = Mathf.Max(0f, y - ((Bounds)(ref bounds)).min.y);
			info.overallDepth = Mathf.Max(0f, y - y2);
			info.surfaceLevel = y;
			return true;
		}
		info = default(WaterLevel.WaterInfo);
		return false;
	}

	public bool Test(Vector3 start, Vector3 end, float radius, out WaterLevel.WaterInfo info)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		if (!waterEnabled)
		{
			info = default(WaterLevel.WaterInfo);
			return false;
		}
		UpdateCachedTransform();
		Vector3 val = (start + end) * 0.5f;
		float num = Mathf.Min(start.y, end.y) - radius;
		if (((OBB)(ref cachedBounds)).Distance(start) < radius || ((OBB)(ref cachedBounds)).Distance(end) < radius)
		{
			if (!CheckCutOffPlanes(val, out var bottomCutY))
			{
				info = default(WaterLevel.WaterInfo);
				return false;
			}
			Plane waterPlane = GetWaterPlane();
			Vector3 val2 = ((Plane)(ref waterPlane)).ClosestPointOnPlane(val);
			float y = (val2 + cachedBounds.up * cachedBounds.extents.y).y;
			float y2 = (val2 + -cachedBounds.up * cachedBounds.extents.y).y;
			y2 = Mathf.Max(y2, bottomCutY);
			info = default(WaterLevel.WaterInfo);
			info.isValid = true;
			info.currentDepth = Mathf.Max(0f, y - num);
			info.overallDepth = Mathf.Max(0f, y - y2);
			info.surfaceLevel = y;
			return true;
		}
		info = default(WaterLevel.WaterInfo);
		return false;
	}

	private bool CheckCutOffPlanes(Vector3 pos, out float bottomCutY)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		int num = cutOffPlanes.Length;
		bottomCutY = float.MaxValue;
		bool flag = true;
		for (int i = 0; i < num; i++)
		{
			if ((Object)(object)cutOffPlanes[i] != (Object)null)
			{
				Vector3 val = cutOffPlanes[i].InverseTransformPoint(pos);
				Vector3 position = cutOffPlanes[i].position;
				if (Vector3.Dot(cutOffPlanes[i].up, cachedBounds.up) < -0.1f)
				{
					bottomCutY = Mathf.Min(bottomCutY, position.y);
				}
				if (val.y > 0f)
				{
					flag = false;
					break;
				}
			}
		}
		if (!flag)
		{
			return false;
		}
		return true;
	}

	private void UpdateCachedTransform()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)cachedTransform != (Object)null && cachedTransform.hasChanged)
		{
			cachedBounds = new OBB(cachedTransform, WaterBounds);
			cachedTransform.hasChanged = false;
		}
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using UnityEngine;

public class Wearable : MonoBehaviour, IItemSetup, IPrefabPreProcess
{
	[Flags]
	public enum RemoveSkin
	{
		Torso = 1,
		Feet = 2,
		Hands = 4,
		Legs = 8,
		Head = 0x10
	}

	[Flags]
	public enum RemoveHair
	{
		Head = 1,
		Eyebrow = 2,
		Facial = 4,
		Armpit = 8,
		Pubic = 0x10
	}

	[Flags]
	public enum DeformHair
	{
		None = 0,
		BaseballCap = 1,
		BoonieHat = 2,
		CandleHat = 3,
		MinersHat = 4,
		WoodHelmet = 5
	}

	[Flags]
	public enum OccupationSlots
	{
		HeadTop = 1,
		Face = 2,
		HeadBack = 4,
		TorsoFront = 8,
		TorsoBack = 0x10,
		LeftShoulder = 0x20,
		RightShoulder = 0x40,
		LeftArm = 0x80,
		RightArm = 0x100,
		LeftHand = 0x200,
		RightHand = 0x400,
		Groin = 0x800,
		Bum = 0x1000,
		LeftKnee = 0x2000,
		RightKnee = 0x4000,
		LeftLeg = 0x8000,
		RightLeg = 0x10000,
		LeftFoot = 0x20000,
		RightFoot = 0x40000,
		Mouth = 0x80000,
		Eyes = 0x100000,
		Back = 0x200000
	}

	[Serializable]
	public struct PartRandomizer
	{
		public PartCollection[] groups;
	}

	[Serializable]
	public struct PartCollection
	{
		public GameObject[] parts;
	}

	[InspectorFlags]
	public RemoveSkin removeSkin;

	[InspectorFlags]
	public RemoveSkin removeSkinFirstPerson;

	[InspectorFlags]
	public RemoveHair removeHair;

	[InspectorFlags]
	public DeformHair deformHair;

	[InspectorFlags]
	public OccupationSlots occupationUnder;

	[InspectorFlags]
	public OccupationSlots occupationOver;

	[InspectorFlags]
	public OccupationSlots stripOccupation;

	public bool IsBackpack;

	public bool HideInPlayerPreview;

	public bool OnlyShowOnPlayerPreview;

	public bool showCensorshipCube;

	public bool showCensorshipCubeBreasts;

	public bool forceHideCensorshipBreasts;

	public string followBone;

	public bool disableRigStripping;

	public bool overrideDownLimit;

	public float downLimit = 70f;

	[NonSerialized]
	public bool hasClothingUnderNotifier;

	[Range(0f, 1f)]
	public float handcuffsSize;

	[HideInInspector]
	public PlayerModelHair playerModelHair;

	[HideInInspector]
	public PlayerModelHairCap playerModelHairCap;

	[HideInInspector]
	public WearableReplacementByRace wearableReplacementByRace;

	[HideInInspector]
	public WearableShadowLod wearableShadowLod;

	[HideInInspector]
	public List<Renderer> renderers = new List<Renderer>();

	[HideInInspector]
	public List<PlayerModelSkin> playerModelSkins = new List<PlayerModelSkin>();

	[HideInInspector]
	public List<BoneRetarget> boneRetargets = new List<BoneRetarget>();

	[HideInInspector]
	public List<SkinnedMeshRenderer> skinnedRenderers = new List<SkinnedMeshRenderer>();

	[HideInInspector]
	public List<SkeletonSkin> skeletonSkins = new List<SkeletonSkin>();

	[HideInInspector]
	public List<ComponentInfo> componentInfos = new List<ComponentInfo>();

	[HideInInspector]
	public List<WearableNotify> notifies = new List<WearableNotify>();

	public bool HideInEyesView;

	[Header("First Person Legs")]
	[Tooltip("If this is true, we'll hide this item in the first person view. Usually done for items that you definitely won't see in first person view, like facemasks and hats.")]
	public bool HideInFirstPerson;

	[Tooltip("Use this if the clothing item clips into the player view. It'll push the chest legs model backwards.")]
	[Range(0f, 5f)]
	public float ExtraLeanBack;

	[Tooltip("Enable this to check for BoneRetargets which need to be preserved in first person view")]
	public bool PreserveBones;

	public bool LegFade;

	public Renderer[] RenderersLod0;

	public Renderer[] RenderersLod1;

	public Renderer[] RenderersLod2;

	public Renderer[] RenderersLod3;

	public Renderer[] RenderersLod4;

	public Renderer[] SkipInFirstPersonLegs;

	private static LOD[] emptyLOD = (LOD[])(object)new LOD[1];

	public PartRandomizer[] randomParts;

	public bool stripOccupationCollisions => stripOccupation != (OccupationSlots)0;

	public void OnItemSetup(Item item)
	{
	}

	public virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		LODGroup[] componentsInChildren = ((Component)this).GetComponentsInChildren<LODGroup>(true);
		foreach (LODGroup val in componentsInChildren)
		{
			val.SetLODs(emptyLOD);
			preProcess.RemoveComponent((Component)(object)val);
		}
	}

	public void CacheComponents()
	{
		playerModelHairCap = ((Component)this).GetComponent<PlayerModelHairCap>();
		playerModelHair = ((Component)this).GetComponent<PlayerModelHair>();
		wearableReplacementByRace = ((Component)this).GetComponent<WearableReplacementByRace>();
		wearableShadowLod = ((Component)this).GetComponent<WearableShadowLod>();
		((Component)this).GetComponentsInChildren<Renderer>(true, renderers);
		((Component)this).GetComponentsInChildren<PlayerModelSkin>(true, playerModelSkins);
		((Component)this).GetComponentsInChildren<BoneRetarget>(true, boneRetargets);
		((Component)this).GetComponentsInChildren<SkinnedMeshRenderer>(true, skinnedRenderers);
		((Component)this).GetComponentsInChildren<SkeletonSkin>(true, skeletonSkins);
		((Component)this).GetComponentsInChildren<ComponentInfo>(true, componentInfos);
		((Component)this).GetComponentsInChildren<WearableNotify>(true, notifies);
		RenderersLod0 = renderers.Where((Renderer x) => ((Object)((Component)x).gameObject).name.EndsWith("0")).ToArray();
		RenderersLod1 = renderers.Where((Renderer x) => ((Object)((Component)x).gameObject).name.EndsWith("1")).ToArray();
		RenderersLod2 = renderers.Where((Renderer x) => ((Object)((Component)x).gameObject).name.EndsWith("2")).ToArray();
		RenderersLod3 = renderers.Where((Renderer x) => ((Object)((Component)x).gameObject).name.EndsWith("3")).ToArray();
		RenderersLod4 = renderers.Where((Renderer x) => ((Object)((Component)x).gameObject).name.EndsWith("4")).ToArray();
		foreach (Renderer renderer in renderers)
		{
			((Component)renderer).gameObject.AddComponent<ObjectMotionVectorFix>();
			renderer.motionVectorGenerationMode = (MotionVectorGenerationMode)2;
		}
	}

	public void StripRig(IPrefabProcessor preProcess, SkinnedMeshRenderer skinnedMeshRenderer)
	{
		if (disableRigStripping)
		{
			return;
		}
		Transform val = skinnedMeshRenderer.FindRig();
		if (!((Object)(object)val != (Object)null))
		{
			return;
		}
		List<Transform> list = Pool.Get<List<Transform>>();
		((Component)val).GetComponentsInChildren<Transform>(list);
		for (int num = list.Count - 1; num >= 0; num--)
		{
			if (preProcess != null)
			{
				preProcess.NominateForDeletion(((Component)list[num]).gameObject);
			}
			else
			{
				Object.DestroyImmediate((Object)(object)((Component)list[num]).gameObject);
			}
		}
		Pool.FreeUnmanaged<Transform>(ref list);
	}

	public void SetupRendererCache(IPrefabProcessor preProcess)
	{
	}
}


using System;

[Flags]
public enum RemoveSkin
{
	Torso = 1,
	Feet = 2,
	Hands = 4,
	Legs = 8,
	Head = 0x10
}


using System;

[Flags]
public enum RemoveHair
{
	Head = 1,
	Eyebrow = 2,
	Facial = 4,
	Armpit = 8,
	Pubic = 0x10
}


using System;

[Flags]
public enum DeformHair
{
	None = 0,
	BaseballCap = 1,
	BoonieHat = 2,
	CandleHat = 3,
	MinersHat = 4,
	WoodHelmet = 5
}


using System;

[Flags]
public enum OccupationSlots
{
	HeadTop = 1,
	Face = 2,
	HeadBack = 4,
	TorsoFront = 8,
	TorsoBack = 0x10,
	LeftShoulder = 0x20,
	RightShoulder = 0x40,
	LeftArm = 0x80,
	RightArm = 0x100,
	LeftHand = 0x200,
	RightHand = 0x400,
	Groin = 0x800,
	Bum = 0x1000,
	LeftKnee = 0x2000,
	RightKnee = 0x4000,
	LeftLeg = 0x8000,
	RightLeg = 0x10000,
	LeftFoot = 0x20000,
	RightFoot = 0x40000,
	Mouth = 0x80000,
	Eyes = 0x100000,
	Back = 0x200000
}


using System;

[Serializable]
public struct PartRandomizer
{
	public PartCollection[] groups;
}


using System;
using UnityEngine;

[Serializable]
public struct PartCollection
{
	public GameObject[] parts;
}


using UnityEngine;

public class WearableEyeViewAdjustment : MonoBehaviour
{
}


using UnityEngine;

public class WearableEyeViewAdjustment_Submesh : WearableEyeViewAdjustment
{
	public int TargetSubmesh;

	public Material HideMaterial;

	public Material DefaultMaterial;
}


using UnityEngine;

public class WearableFadeToggle : MonoBehaviour, IClientComponent
{
}


using System;
using UnityEngine;

public class WearableHolsterOffset : MonoBehaviour
{
	[Serializable]
	public class offsetInfo
	{
		public enum OverrideBone
		{
			None,
			Spine4
		}

		public HeldEntity.HolsterInfo.HolsterSlot type;

		public Vector3 offset;

		public Vector3 rotationOffset;

		public int priority;

		public Vector3 rightBackpackSlotOffset;

		public Vector3 rightBackpackSlotRotationOffset;

		public OverrideBone overrideBone;
	}

	public offsetInfo[] Offsets;
}


using System;
using UnityEngine;

[Serializable]
public class offsetInfo
{
	public enum OverrideBone
	{
		None,
		Spine4
	}

	public HeldEntity.HolsterInfo.HolsterSlot type;

	public Vector3 offset;

	public Vector3 rotationOffset;

	public int priority;

	public Vector3 rightBackpackSlotOffset;

	public Vector3 rightBackpackSlotRotationOffset;

	public OverrideBone overrideBone;
}


public enum OverrideBone
{
	None,
	Spine4
}


using UnityEngine;

public class WearableNotify : MonoBehaviour
{
}


using System.Collections.Generic;
using UnityEngine;

public class WearableNotifyConditionalClothing : WearableNotify
{
	public List<GameObject> MinClothing = new List<GameObject>();

	public List<GameObject> MaxClothing = new List<GameObject>();
}


using UnityEngine;

public class WearableNotifyHasBackpack : WearableNotify
{
	public GameObject[] ObjectsToHide = (GameObject[])(object)new GameObject[0];
}


using UnityEngine.Events;

public class WearableNotifyLifestate : WearableNotify
{
	public BaseCombatEntity.LifeState TargetState;

	public UnityEvent OnTargetState = new UnityEvent();

	public UnityEvent OnTargetStateFailed = new UnityEvent();
}


using UnityEngine;
using UnityEngine.Events;

public class WearableNotifyTrophyMounted : WearableNotify
{
	public UnityEvent OnMounted = new UnityEvent();

	public Renderer[] EmissionToggles;
}


using UnityEngine;

public class WearableReplacementByRace : MonoBehaviour
{
	public GameObjectRef[] replacements;

	public GameObjectRef GetReplacement(int meshIndex)
	{
		int num = Mathf.Clamp(meshIndex, 0, replacements.Length - 1);
		return replacements[num];
	}
}


using UnityEngine;

public class WearableShadowLod : MonoBehaviour, IClientComponent
{
	public Renderer[] DisableShadows;
}


using UnityEngine;

public abstract class WeatherEffect : BaseMonoBehaviour, IClientComponent
{
	public ParticleSystem[] emitOnStart;

	public ParticleSystem[] emitOnStop;

	public ParticleSystem[] emitOnLoop;
}


public class AuroraEffect : WeatherEffect
{
}


public class RainbowEffect : WeatherEffect
{
}


public class RainEffect : WeatherEffect
{
	public int FadeStartDistance = 10;

	public int FadeEndDistance = 50;

	public int FadeFalloff = 3;

	public bool Stormy;
}


public class SnowEffect : WeatherEffect
{
	public int FadeStartDistance = 10;

	public int FadeEndDistance = 50;

	public int FadeFalloff = 3;

	public bool Stormy;
}


public class UnderwaterEffect : WeatherEffect
{
}


public abstract class WeatherEffectSting : BaseMonoBehaviour, IClientComponent
{
	public float frequency = 600f;

	public float variance = 300f;

	public GameObjectRef[] effects;
}


public class RainEffectSting : WeatherEffectSting
{
}


public enum WeatherPresetType
{
	Clear,
	Overcast,
	Storm,
	Dust,
	Fog,
	Rain,
	Cinematic
}


using System.Text;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/WeatherPreset")]
public class WeatherPreset : ScriptableObject
{
	public WeatherPresetType Type;

	public float Wind;

	public float Rain;

	public float Thunder;

	public float Rainbow;

	public TOD_AtmosphereParameters Atmosphere;

	public TOD_CloudParameters Clouds;

	[Range(0f, 1f)]
	public float AmbientLightMultiplier = 1f;

	[Range(0f, 1f)]
	public float DirectionalLightMultiplier = 1f;

	[Range(0f, 1f)]
	public float ReflectionMultiplier = 1f;

	[Range(0f, 1f)]
	public float SunMeshBrightnessMultiplier = 1f;

	[Range(0f, 1f)]
	public float MoonMeshBrightnessMultiplier = 1f;

	[Range(0f, 10f)]
	public float OceanScale;

	public void Apply(TOD_Sky sky)
	{
		sky.Atmosphere.RayleighMultiplier = Atmosphere.RayleighMultiplier;
		sky.Atmosphere.MieMultiplier = Atmosphere.MieMultiplier;
		sky.Atmosphere.Brightness = Atmosphere.Brightness;
		sky.Atmosphere.Contrast = Atmosphere.Contrast;
		sky.Atmosphere.Directionality = Atmosphere.Directionality;
		sky.Atmosphere.Fogginess = Atmosphere.Fogginess;
		sky.Clouds.Size = Clouds.Size;
		sky.Clouds.Opacity = Clouds.Opacity;
		sky.Clouds.Coverage = Clouds.Coverage;
		sky.Clouds.Sharpness = Clouds.Sharpness;
		sky.Clouds.Coloring = Clouds.Coloring;
		sky.Clouds.Attenuation = Clouds.Attenuation;
		sky.Clouds.Saturation = Clouds.Saturation;
		sky.Clouds.Scattering = Clouds.Scattering;
		sky.Clouds.Brightness = Clouds.Brightness;
	}

	public void Copy(TOD_Sky sky)
	{
		Atmosphere.RayleighMultiplier = sky.Atmosphere.RayleighMultiplier;
		Atmosphere.MieMultiplier = sky.Atmosphere.MieMultiplier;
		Atmosphere.Brightness = sky.Atmosphere.Brightness;
		Atmosphere.Contrast = sky.Atmosphere.Contrast;
		Atmosphere.Directionality = sky.Atmosphere.Directionality;
		Atmosphere.Fogginess = sky.Atmosphere.Fogginess;
		Clouds.Size = sky.Clouds.Size;
		Clouds.Opacity = sky.Clouds.Opacity;
		Clouds.Coverage = sky.Clouds.Coverage;
		Clouds.Sharpness = sky.Clouds.Sharpness;
		Clouds.Coloring = sky.Clouds.Coloring;
		Clouds.Attenuation = sky.Clouds.Attenuation;
		Clouds.Saturation = sky.Clouds.Saturation;
		Clouds.Scattering = sky.Clouds.Scattering;
		Clouds.Brightness = sky.Clouds.Brightness;
	}

	public void Reset()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Expected O, but got Unknown
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Expected O, but got Unknown
		Wind = -1f;
		Rain = -1f;
		Thunder = -1f;
		Rainbow = -1f;
		Atmosphere = new TOD_AtmosphereParameters();
		Atmosphere.RayleighMultiplier = -1f;
		Atmosphere.MieMultiplier = -1f;
		Atmosphere.Brightness = -1f;
		Atmosphere.Contrast = -1f;
		Atmosphere.Directionality = -1f;
		Atmosphere.Fogginess = -1f;
		Clouds = new TOD_CloudParameters();
		Clouds.Size = -1f;
		Clouds.Opacity = -1f;
		Clouds.Coverage = -1f;
		Clouds.Sharpness = -1f;
		Clouds.Coloring = -1f;
		Clouds.Attenuation = -1f;
		Clouds.Saturation = -1f;
		Clouds.Scattering = -1f;
		Clouds.Brightness = -1f;
		AmbientLightMultiplier = -1f;
		DirectionalLightMultiplier = -1f;
		ReflectionMultiplier = -1f;
		SunMeshBrightnessMultiplier = -1f;
		MoonMeshBrightnessMultiplier = -1f;
		OceanScale = -1f;
	}

	public void Set(WeatherPreset other)
	{
		Wind = other.Wind;
		Rain = other.Rain;
		Thunder = other.Thunder;
		Rainbow = other.Rainbow;
		Atmosphere.RayleighMultiplier = other.Atmosphere.RayleighMultiplier;
		Atmosphere.MieMultiplier = other.Atmosphere.MieMultiplier;
		Atmosphere.Brightness = other.Atmosphere.Brightness;
		Atmosphere.Contrast = other.Atmosphere.Contrast;
		Atmosphere.Directionality = other.Atmosphere.Directionality;
		Atmosphere.Fogginess = other.Atmosphere.Fogginess;
		Clouds.Size = other.Clouds.Size;
		Clouds.Opacity = other.Clouds.Opacity;
		Clouds.Coverage = other.Clouds.Coverage;
		Clouds.Sharpness = other.Clouds.Sharpness;
		Clouds.Coloring = other.Clouds.Coloring;
		Clouds.Attenuation = other.Clouds.Attenuation;
		Clouds.Saturation = other.Clouds.Saturation;
		Clouds.Scattering = other.Clouds.Scattering;
		Clouds.Brightness = other.Clouds.Brightness;
		AmbientLightMultiplier = other.AmbientLightMultiplier;
		DirectionalLightMultiplier = other.DirectionalLightMultiplier;
		ReflectionMultiplier = other.ReflectionMultiplier;
		SunMeshBrightnessMultiplier = other.SunMeshBrightnessMultiplier;
		MoonMeshBrightnessMultiplier = other.MoonMeshBrightnessMultiplier;
		OceanScale = other.OceanScale;
	}

	public override string ToString()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"Wind {Wind}");
		stringBuilder.AppendLine($"Rain {Rain}");
		stringBuilder.AppendLine($"Thunder {Thunder}");
		stringBuilder.AppendLine($"Rainbow {Rainbow}");
		stringBuilder.AppendLine($"RayleighMultiplier {Atmosphere.RayleighMultiplier}");
		stringBuilder.AppendLine($"MieMultiplier {Atmosphere.MieMultiplier}");
		stringBuilder.AppendLine($"Brightness {Atmosphere.Brightness}");
		stringBuilder.AppendLine($"Contrast {Atmosphere.Contrast}");
		stringBuilder.AppendLine($"Directionality {Atmosphere.Directionality}");
		stringBuilder.AppendLine($"Fogginess {Atmosphere.Fogginess}");
		stringBuilder.AppendLine($"Size {Clouds.Size}");
		stringBuilder.AppendLine($"Opacity {Clouds.Opacity}");
		stringBuilder.AppendLine($"Coverage {Clouds.Coverage}");
		stringBuilder.AppendLine($"Sharpness {Clouds.Sharpness}");
		stringBuilder.AppendLine($"Coloring {Clouds.Coloring}");
		stringBuilder.AppendLine($"Attenuation {Clouds.Attenuation}");
		stringBuilder.AppendLine($"Saturation {Clouds.Saturation}");
		stringBuilder.AppendLine($"Scattering {Clouds.Scattering}");
		stringBuilder.AppendLine($"Brightness {Clouds.Brightness}");
		stringBuilder.AppendLine($"AmbientLightMultiplier {AmbientLightMultiplier}");
		stringBuilder.AppendLine($"DirectionalLightMultiplier {DirectionalLightMultiplier}");
		stringBuilder.AppendLine($"ReflectionMultiplier {ReflectionMultiplier}");
		stringBuilder.AppendLine($"SunMeshBrightnessMultiplier {SunMeshBrightnessMultiplier}");
		stringBuilder.AppendLine($"MoonMeshBrightnessMultiplier {MoonMeshBrightnessMultiplier}");
		stringBuilder.AppendLine($"Ocean {OceanScale}");
		return stringBuilder.ToString();
	}

	public void Fade(WeatherPreset a, WeatherPreset b, float t)
	{
		Fade(ref Wind, a.Wind, b.Wind, t);
		Fade(ref Rain, a.Rain, b.Rain, t);
		Fade(ref Thunder, a.Thunder, b.Thunder, t);
		Fade(ref Rainbow, a.Rainbow, b.Rainbow, t);
		Fade(ref Atmosphere.RayleighMultiplier, a.Atmosphere.RayleighMultiplier, b.Atmosphere.RayleighMultiplier, t);
		Fade(ref Atmosphere.MieMultiplier, a.Atmosphere.MieMultiplier, b.Atmosphere.MieMultiplier, t);
		Fade(ref Atmosphere.Brightness, a.Atmosphere.Brightness, b.Atmosphere.Brightness, t);
		Fade(ref Atmosphere.Contrast, a.Atmosphere.Contrast, b.Atmosphere.Contrast, t);
		Fade(ref Atmosphere.Directionality, a.Atmosphere.Directionality, b.Atmosphere.Directionality, t);
		Fade(ref Atmosphere.Fogginess, a.Atmosphere.Fogginess, b.Atmosphere.Fogginess, t);
		Fade(ref Clouds.Size, a.Clouds.Size, b.Clouds.Size, t);
		Fade(ref Clouds.Opacity, a.Clouds.Opacity, b.Clouds.Opacity, t);
		Fade(ref Clouds.Coverage, a.Clouds.Coverage, b.Clouds.Coverage, t);
		Fade(ref Clouds.Sharpness, a.Clouds.Sharpness, b.Clouds.Sharpness, t);
		Fade(ref Clouds.Coloring, a.Clouds.Coloring, b.Clouds.Coloring, t);
		Fade(ref Clouds.Attenuation, a.Clouds.Attenuation, b.Clouds.Attenuation, t);
		Fade(ref Clouds.Saturation, a.Clouds.Saturation, b.Clouds.Saturation, t);
		Fade(ref Clouds.Scattering, a.Clouds.Scattering, b.Clouds.Scattering, t);
		Fade(ref Clouds.Brightness, a.Clouds.Brightness, b.Clouds.Brightness, t);
		Fade(ref AmbientLightMultiplier, a.AmbientLightMultiplier, b.AmbientLightMultiplier, t);
		Fade(ref DirectionalLightMultiplier, a.DirectionalLightMultiplier, b.DirectionalLightMultiplier, t);
		Fade(ref ReflectionMultiplier, a.ReflectionMultiplier, b.ReflectionMultiplier, t);
		Fade(ref SunMeshBrightnessMultiplier, a.SunMeshBrightnessMultiplier, b.SunMeshBrightnessMultiplier, t);
		Fade(ref MoonMeshBrightnessMultiplier, a.MoonMeshBrightnessMultiplier, b.MoonMeshBrightnessMultiplier, t);
		Fade(ref OceanScale, a.OceanScale, b.OceanScale, t);
	}

	public void Override(WeatherPreset other)
	{
		Override(ref Wind, other.Wind);
		Override(ref Rain, other.Rain);
		Override(ref Thunder, other.Thunder);
		Override(ref Rainbow, other.Rainbow);
		Override(ref Atmosphere.RayleighMultiplier, other.Atmosphere.RayleighMultiplier);
		Override(ref Atmosphere.MieMultiplier, other.Atmosphere.MieMultiplier);
		Override(ref Atmosphere.Brightness, other.Atmosphere.Brightness);
		Override(ref Atmosphere.Contrast, other.Atmosphere.Contrast);
		Override(ref Atmosphere.Directionality, other.Atmosphere.Directionality);
		Override(ref Atmosphere.Fogginess, other.Atmosphere.Fogginess);
		Override(ref Clouds.Size, other.Clouds.Size);
		Override(ref Clouds.Opacity, other.Clouds.Opacity);
		Override(ref Clouds.Coverage, other.Clouds.Coverage);
		Override(ref Clouds.Sharpness, other.Clouds.Sharpness);
		Override(ref Clouds.Coloring, other.Clouds.Coloring);
		Override(ref Clouds.Attenuation, other.Clouds.Attenuation);
		Override(ref Clouds.Saturation, other.Clouds.Saturation);
		Override(ref Clouds.Scattering, other.Clouds.Scattering);
		Override(ref Clouds.Brightness, other.Clouds.Brightness);
		Override(ref AmbientLightMultiplier, other.AmbientLightMultiplier);
		Override(ref DirectionalLightMultiplier, other.DirectionalLightMultiplier);
		Override(ref ReflectionMultiplier, other.ReflectionMultiplier);
		Override(ref SunMeshBrightnessMultiplier, other.SunMeshBrightnessMultiplier);
		Override(ref MoonMeshBrightnessMultiplier, other.MoonMeshBrightnessMultiplier);
		Override(ref OceanScale, other.OceanScale);
	}

	public void Max(WeatherPreset other)
	{
		Max(ref Wind, other.Wind);
		Max(ref Rain, other.Rain);
		Max(ref Thunder, other.Thunder);
		Max(ref Rainbow, other.Rainbow);
		Max(ref Atmosphere.RayleighMultiplier, other.Atmosphere.RayleighMultiplier);
		Max(ref Atmosphere.MieMultiplier, other.Atmosphere.MieMultiplier);
		Max(ref Atmosphere.Brightness, other.Atmosphere.Brightness);
		Max(ref Atmosphere.Contrast, other.Atmosphere.Contrast);
		Max(ref Atmosphere.Directionality, other.Atmosphere.Directionality);
		Max(ref Atmosphere.Fogginess, other.Atmosphere.Fogginess);
		Max(ref Clouds.Size, other.Clouds.Size);
		Max(ref Clouds.Opacity, other.Clouds.Opacity);
		Max(ref Clouds.Coverage, other.Clouds.Coverage);
		Max(ref Clouds.Sharpness, other.Clouds.Sharpness);
		Max(ref Clouds.Coloring, other.Clouds.Coloring);
		Max(ref Clouds.Attenuation, other.Clouds.Attenuation);
		Max(ref Clouds.Saturation, other.Clouds.Saturation);
		Max(ref Clouds.Scattering, other.Clouds.Scattering);
		Max(ref Clouds.Brightness, other.Clouds.Brightness);
		Min(ref AmbientLightMultiplier, other.AmbientLightMultiplier);
		Min(ref DirectionalLightMultiplier, other.DirectionalLightMultiplier);
		Min(ref ReflectionMultiplier, other.ReflectionMultiplier);
		Min(ref SunMeshBrightnessMultiplier, other.SunMeshBrightnessMultiplier);
		Min(ref MoonMeshBrightnessMultiplier, other.MoonMeshBrightnessMultiplier);
		Max(ref OceanScale, other.OceanScale);
	}

	public void Min(WeatherPreset other)
	{
		Min(ref Wind, other.Wind);
		Min(ref Rain, other.Rain);
		Min(ref Thunder, other.Thunder);
		Min(ref Rainbow, other.Rainbow);
		Min(ref Atmosphere.RayleighMultiplier, other.Atmosphere.RayleighMultiplier);
		Min(ref Atmosphere.MieMultiplier, other.Atmosphere.MieMultiplier);
		Min(ref Atmosphere.Brightness, other.Atmosphere.Brightness);
		Min(ref Atmosphere.Contrast, other.Atmosphere.Contrast);
		Min(ref Atmosphere.Directionality, other.Atmosphere.Directionality);
		Min(ref Atmosphere.Fogginess, other.Atmosphere.Fogginess);
		Min(ref Clouds.Size, other.Clouds.Size);
		Min(ref Clouds.Opacity, other.Clouds.Opacity);
		Min(ref Clouds.Coverage, other.Clouds.Coverage);
		Min(ref Clouds.Sharpness, other.Clouds.Sharpness);
		Min(ref Clouds.Coloring, other.Clouds.Coloring);
		Min(ref Clouds.Attenuation, other.Clouds.Attenuation);
		Min(ref Clouds.Saturation, other.Clouds.Saturation);
		Min(ref Clouds.Scattering, other.Clouds.Scattering);
		Min(ref Clouds.Brightness, other.Clouds.Brightness);
		Min(ref AmbientLightMultiplier, other.AmbientLightMultiplier);
		Min(ref DirectionalLightMultiplier, other.DirectionalLightMultiplier);
		Min(ref ReflectionMultiplier, other.ReflectionMultiplier);
		Min(ref SunMeshBrightnessMultiplier, other.SunMeshBrightnessMultiplier);
		Min(ref MoonMeshBrightnessMultiplier, other.MoonMeshBrightnessMultiplier);
		Min(ref OceanScale, other.OceanScale);
	}

	private void Fade(ref float x, float a, float b, float t)
	{
		x = Mathf.SmoothStep(a, b, t);
	}

	private void Override(ref float x, float other)
	{
		if (other >= 0f)
		{
			x = other;
		}
	}

	private void Max(ref float x, float other)
	{
		x = Mathf.Max(x, other);
	}

	private void Min(ref float x, float other)
	{
		if (other >= 0f)
		{
			x = Mathf.Min(x, other);
		}
	}
}


using UnityEngine;

public class LegacyWeatherState
{
	private WeatherPreset preset;

	public float Wind
	{
		get
		{
			return preset.Wind;
		}
		set
		{
			preset.Wind = value;
		}
	}

	public float Rain
	{
		get
		{
			return preset.Rain;
		}
		set
		{
			preset.Rain = value;
		}
	}

	public float Clouds
	{
		get
		{
			return preset.Clouds.Coverage;
		}
		set
		{
			preset.Clouds.Opacity = Mathf.Sign(value);
			preset.Clouds.Coverage = value;
		}
	}

	public float Fog
	{
		get
		{
			return preset.Atmosphere.Fogginess;
		}
		set
		{
			preset.Atmosphere.Fogginess = value;
		}
	}

	public LegacyWeatherState(WeatherPreset preset)
	{
		this.preset = preset;
	}
}


public static class WordFilter
{
	public static string Filter(string str)
	{
		return str;
	}
}


public class WorldGrid : SingletonComponent<WorldGrid>, IClientComponent
{
	public static bool Paused;

	public float CellSize = 50f;

	public float MaxMilliseconds = 0.1f;

	public const float MaxRefreshDistance = 500f;

	public const float MinTimeBetweenRefreshes = 1f;
}


using UnityEngine;

public class WorldModel : MonoBehaviour
{
	public float mass = 1f;
}


using System;
using UnityEngine;

[Serializable]
public class PegConfig
{
	public enum PegType
	{
		Small,
		Large
	}

	public PegType Type;

	public Vector3 VerticalMountLocalRotation;

	public Vector3 VerticalMountLocalOffset;

	public void Init(PegType t, Vector3 localRot, Vector3 localOffset)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Type = t;
		VerticalMountLocalRotation = localRot;
		VerticalMountLocalOffset = localOffset;
	}
}


public enum PegType
{
	Small,
	Large
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class WorldModelRackMountConfig : MonoBehaviour
{
	[Serializable]
	public class CustomPosition
	{
		public WeaponRack.SpecialRackType RackType;

		public Vector3 CenterOffset;

		public Vector3 Rotation;
	}

	public List<WeaponRack.RackType> ExcludedRackTypes = new List<WeaponRack.RackType>();

	public Vector3 CenterOffsfet;

	public Vector3 LeftOffset;

	public Vector3 VerticalMountLocalRotation;

	public Vector3 VerticalMountLocalOffset;

	public int XSize = 3;

	public int YSize = 2;

	public int ZSize = 1;

	public List<PegConfig> Pegs = new List<PegConfig>();

	public List<PegConfig> VerticalPegs = new List<PegConfig>();

	public bool OverrideScale;

	public Vector3 Scale = Vector3.one;

	public bool UseManualRenderBounds;

	public Bounds ManualRenderBounds;

	public bool CanReloadOnWeaponRack = true;

	[Header("Special Rack Types")]
	public List<CustomPosition> CustomPositions = new List<CustomPosition>();

	public static WorldModelRackMountConfig GetForItemDef(ItemDefinition itemDef)
	{
		GameObjectRef worldModelPrefab = itemDef.worldModelPrefab;
		if (!worldModelPrefab.isValid)
		{
			return null;
		}
		return worldModelPrefab.Get().GetComponent<WorldModelRackMountConfig>();
	}

	public void ApplyTransformDefaults(Transform displayItem)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)displayItem == (Object)null))
		{
			if (OverrideScale)
			{
				displayItem.localScale = Scale;
			}
			displayItem.localPosition = VerticalMountLocalOffset;
			displayItem.localEulerAngles = VerticalMountLocalRotation;
		}
	}

	public CustomPosition FindCustomRackPosition(WeaponRack.SpecialRackType rackType)
	{
		if (CustomPositions == null)
		{
			return null;
		}
		foreach (CustomPosition customPosition in CustomPositions)
		{
			if (customPosition.RackType == rackType)
			{
				return customPosition;
			}
		}
		return null;
	}
}


using System;
using UnityEngine;

[Serializable]
public class CustomPosition
{
	public WeaponRack.SpecialRackType RackType;

	public Vector3 CenterOffset;

	public Vector3 Rotation;
}


using UnityEngine;

public class WorldModelRandomiser : MonoBehaviour
{
	public Wearable.PartRandomizer[] randomParts;
}


using UnityEngine;

public class WorldModelVisualConfig : MonoBehaviour, IClientComponent
{
	public FoodViewModel.FoodVisualConfig VisualConfig;

	public void Init(ItemDefinition itemDef)
	{
		if (VisualConfig != null && !((Object)(object)itemDef == (Object)null))
		{
			VisualConfig.InitForItemDef(itemDef);
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Gestures/Gesture Collection")]
public class GestureCollection : BaseScriptableObject
{
	public static uint HeavyLandingId = 3204230781u;

	private static GestureCollection _instance = null;

	public GestureConfig[] AllGestures;

	public float GestureVmInDuration = 0.25f;

	public AnimationCurve GestureInCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public float GestureVmOutDuration = 0.25f;

	public AnimationCurve GestureOutCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public float GestureViewmodelDeployDelay = 0.25f;

	public Sprite EmptyGestureSlotSprite;

	public Phrase EmptySlotTitle;

	public Phrase EmptySlotDescription;

	public static GestureCollection Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = FileSystem.Load<GestureCollection>("assets/prefabs/player/gestures/gesturecollection.asset", true);
			}
			return _instance;
		}
	}

	public GestureConfig IdToGesture(uint id)
	{
		GestureConfig[] allGestures = AllGestures;
		foreach (GestureConfig gestureConfig in allGestures)
		{
			if (gestureConfig.gestureId == id)
			{
				return gestureConfig;
			}
		}
		return null;
	}

	public GestureConfig StringToGesture(string gestureName)
	{
		if (string.IsNullOrEmpty(gestureName))
		{
			return null;
		}
		GestureConfig[] allGestures = AllGestures;
		foreach (GestureConfig gestureConfig in allGestures)
		{
			if (gestureConfig.convarName == gestureName)
			{
				return gestureConfig;
			}
		}
		return null;
	}
}


using ConVar;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Video;

[CreateAssetMenu(menuName = "Rust/Gestures/Gesture Config")]
public class GestureConfig : ScriptableObject
{
	public enum GestureType
	{
		Player,
		NPC,
		Cinematic
	}

	public enum PlayerModelLayer
	{
		UpperBody = 3,
		FullBody
	}

	public enum MovementCapabilities
	{
		FullMovement,
		NoMovement
	}

	public enum AnimationType
	{
		OneShot,
		Loop
	}

	public enum GestureActionType
	{
		None,
		ShowNameTag,
		DanceAchievement,
		Surrender,
		RockPaperScissors
	}

	[ReadOnly]
	public uint gestureId;

	public string gestureCommand;

	public string convarName;

	public Phrase gestureName;

	public Phrase gestureDescription;

	public Sprite icon;

	public AnimationType animationType;

	public float duration = 1.5f;

	public bool canCancel = true;

	public MovementCapabilities movementMode;

	public BasePlayer.CameraMode viewMode;

	public bool hideInWheel;

	public VideoClip previewClip;

	[Header("Player model setup")]
	public PlayerModelLayer playerModelLayer = PlayerModelLayer.UpperBody;

	public GestureType gestureType;

	public bool hideHeldEntity = true;

	public bool canDuckDuringGesture;

	public bool hasViewmodelAnimation = true;

	public float viewmodelHolsterDelay;

	public bool useRootMotion;

	public bool forceForwardRotation;

	[Header("Interaction")]
	public bool hasMultiplayerInteraction;

	public Phrase joinPlayerPhrase = new Phrase("", "");

	public Phrase joinPlayerDescPhrase = new Phrase("", "");

	[Header("Ownership")]
	public GestureActionType actionType;

	public bool forceUnlock;

	public SteamDLCItem dlcItem;

	public SteamInventoryItem inventoryItem;

	public bool IsOwnedBy(BasePlayer player, bool allowCinematic = false)
	{
		object obj = Interface.CallHook("CanUseGesture", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (forceUnlock)
		{
			return true;
		}
		if (gestureType == GestureType.NPC)
		{
			if ((Object)(object)player != (Object)null)
			{
				return player.IsNpc;
			}
			return false;
		}
		if (gestureType == GestureType.Cinematic)
		{
			if (!allowCinematic && (!((Object)(object)player != (Object)null) || !player.IsAdmin))
			{
				return Server.cinematic;
			}
			return true;
		}
		if ((Object)(object)dlcItem != (Object)null && (Object)(object)player != (Object)null)
		{
			return dlcItem.CanUse(player);
		}
		if ((Object)(object)inventoryItem != (Object)null && (Object)(object)player != (Object)null && player.blueprints.steamInventory.HasItem(inventoryItem.id))
		{
			return true;
		}
		return false;
	}

	public bool CanBeUsedBy(BasePlayer player)
	{
		if (player.isMounted)
		{
			if (playerModelLayer == PlayerModelLayer.FullBody)
			{
				return false;
			}
			if (player.GetMounted().allowedGestures == BaseMountable.MountGestureType.None)
			{
				return false;
			}
		}
		if (player.IsSwimming() && playerModelLayer == PlayerModelLayer.FullBody)
		{
			return false;
		}
		if (playerModelLayer == PlayerModelLayer.FullBody && player.modelState.ducked)
		{
			return false;
		}
		return true;
	}
}


public enum GestureType
{
	Player,
	NPC,
	Cinematic
}


public enum PlayerModelLayer
{
	UpperBody = 3,
	FullBody
}


public enum MovementCapabilities
{
	FullMovement,
	NoMovement
}


public enum AnimationType
{
	OneShot,
	Loop
}


public enum GestureActionType
{
	None,
	ShowNameTag,
	DanceAchievement,
	Surrender,
	RockPaperScissors
}


using Rust.UI;
using UnityEngine;

public class RockPaperScissorsDialog : SingletonComponent<RockPaperScissorsDialog>
{
	public RustText[] InputTexts;

	public RustSlider TimerBar;

	public GameObject ActiveRoot;

	public GameObject[] MadeSelection;
}


using System.Collections.Generic;
using UnityEngine;

public class OutlineManager : MonoBehaviour, IClientComponent
{
	public static Material blurMat;

	public List<OutlineObject> objectsToRender;

	public float blurAmount = 2f;

	public Material glowSolidMaterial;

	public Material blendGlowMaterial;
}


using UnityEngine;

public class OutlineObject : MonoBehaviour, IClientComponent
{
	public Mesh[] meshes;

	public Transform[] meshTransforms;
}


public class WorldModelOutline : OutlineObject
{
	public bool AlwaysRender;
}


using UnityEngine;

[ExecuteInEditMode]
public class LinearFog : MonoBehaviour
{
	public Material fogMaterial;

	public Color fogColor = Color.white;

	public float fogStart;

	public float fogRange = 1f;

	public float fogDensity = 1f;

	public bool fogSky;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)fogMaterial))
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		fogMaterial.SetColor("_FogColor", fogColor);
		fogMaterial.SetFloat("_Start", fogStart);
		fogMaterial.SetFloat("_Range", fogRange);
		fogMaterial.SetFloat("_Density", fogDensity);
		if (fogSky)
		{
			fogMaterial.SetFloat("_CutOff", 2f);
		}
		else
		{
			fogMaterial.SetFloat("_CutOff", 1f);
		}
		for (int i = 0; i < fogMaterial.passCount; i++)
		{
			Graphics.Blit((Texture)(object)source, destination, fogMaterial, i);
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class MaterialOverlay : MonoBehaviour
{
	public Material material;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (!Object.op_Implicit((Object)(object)material))
		{
			Graphics.Blit((Texture)(object)source, destination);
			return;
		}
		for (int i = 0; i < material.passCount; i++)
		{
			Graphics.Blit((Texture)(object)source, destination, material, i);
		}
	}
}


using UnityEngine;

[RequireComponent(typeof(Camera))]
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Natural Bloom and Dirty Lens")]
public class NaturalBloomAndDirtyLens : MonoBehaviour
{
	public Shader shader;

	public Texture2D lensDirtTexture;

	public float range = 10000f;

	public float cutoff = 1f;

	[Range(0f, 1f)]
	public float bloomIntensity = 0.05f;

	[Range(0f, 1f)]
	public float lensDirtIntensity = 0.05f;

	[Range(0f, 4f)]
	public float spread = 1f;

	[Range(0f, 4f)]
	public int iterations = 1;

	[Range(1f, 10f)]
	public int mips = 6;

	public float[] mipWeights = new float[6] { 0.5f, 0.6f, 0.6f, 0.45f, 0.35f, 0.23f };

	public bool highPrecision;

	public bool downscaleSource;

	public bool debug;

	public bool temporalFilter;

	[Range(0.01f, 1f)]
	public float temporalFilterWeight = 0.75f;
}


using UnityEngine;

public class ImageRenderController : SingletonComponent<ImageRenderController>
{
	public Camera Camera;
}


public enum BUTTON
{
	FORWARD = 2,
	BACKWARD = 4,
	LEFT = 8,
	RIGHT = 0x10,
	JUMP = 0x20,
	DUCK = 0x40,
	SPRINT = 0x80,
	USE = 0x100,
	FIRE_PRIMARY = 0x400,
	FIRE_SECONDARY = 0x800,
	RELOAD = 0x2000,
	FIRE_THIRD = 0x8000000
}


using UnityEngine;

public class InputState
{
	public InputMessage current = new InputMessage
	{
		ShouldPool = false
	};

	public InputMessage previous = new InputMessage
	{
		ShouldPool = false
	};

	private int SwallowedButtons;

	public bool IsDown(BUTTON btn)
	{
		if (current == null)
		{
			return false;
		}
		if (((uint)SwallowedButtons & (uint)btn) == (uint)btn)
		{
			return false;
		}
		return ((uint)current.buttons & (uint)btn) == (uint)btn;
	}

	public bool WasDown(BUTTON btn)
	{
		if (previous == null)
		{
			return false;
		}
		return ((uint)previous.buttons & (uint)btn) == (uint)btn;
	}

	public bool IsAnyDown()
	{
		if (current == null)
		{
			return false;
		}
		return (float)(current.buttons & ~SwallowedButtons) > 0f;
	}

	public bool WasJustPressed(BUTTON btn)
	{
		if (IsDown(btn))
		{
			return !WasDown(btn);
		}
		return false;
	}

	public bool WasJustReleased(BUTTON btn)
	{
		if (!IsDown(btn))
		{
			return WasDown(btn);
		}
		return false;
	}

	public void SwallowButton(BUTTON btn)
	{
		if (current != null)
		{
			SwallowedButtons |= (int)btn;
		}
	}

	public Quaternion AimAngle()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		if (current == null)
		{
			return Quaternion.identity;
		}
		return Quaternion.Euler(current.aimAngles);
	}

	public Vector3 MouseDelta()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		if (current == null)
		{
			return Vector3.zero;
		}
		return current.mouseDelta;
	}

	public void Flip(InputMessage newcurrent)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		SwallowedButtons = 0;
		previous.aimAngles = current.aimAngles;
		previous.buttons = current.buttons;
		previous.mouseDelta = current.mouseDelta;
		current.aimAngles = newcurrent.aimAngles;
		current.buttons = newcurrent.buttons;
		current.mouseDelta = newcurrent.mouseDelta;
	}

	public void Clear()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		current.buttons = 0;
		previous.buttons = 0;
		SetMouseDelta(Vector3.zero);
		SwallowedButtons = 0;
	}

	public void SetMouseDelta(Vector3 d)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		previous.mouseDelta = d;
		current.mouseDelta = d;
	}
}


using System.Collections.Generic;
using ProtoBuf;

public class ItemCraftTask
{
	public ItemBlueprint blueprint;

	public float endTime;

	public int taskUID;

	public bool cancelled;

	public InstanceData instanceData;

	public int amount = 1;

	public int skinID;

	public List<Item> takenItems;

	public int numCrafted;

	public float conditionScale = 1f;

	public BaseEntity workbenchEntity;
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class ItemCrafter : EntityComponent<BasePlayer>
{
	public List<ItemContainer> containers = new List<ItemContainer>();

	public LinkedList<ItemCraftTask> queue = new LinkedList<ItemCraftTask>();

	public int taskUID;

	[NonSerialized]
	public BasePlayer owner;

	public void AddContainer(ItemContainer container)
	{
		containers.Add(container);
	}

	public static float GetScaledDuration(ItemBlueprint bp, float workbenchLevel, bool isInTutorial)
	{
		float num = workbenchLevel - (float)bp.GetWorkbenchLevel();
		if (isInTutorial)
		{
			return bp.GetCraftTime() * 0.25f;
		}
		if (num == 1f)
		{
			return bp.GetCraftTime() * 0.5f;
		}
		if (num >= 2f)
		{
			return bp.GetCraftTime() * 0.25f;
		}
		return bp.GetCraftTime();
	}

	public void ServerUpdate(float delta)
	{
		if (queue.Count == 0)
		{
			return;
		}
		ItemCraftTask value = queue.First.Value;
		if (value.cancelled)
		{
			owner.Command("note.craft_done", value.taskUID, 0);
			queue.RemoveFirst();
			return;
		}
		float currentCraftLevel = owner.currentCraftLevel;
		if (value.endTime > Time.realtimeSinceStartup)
		{
			return;
		}
		if (value.endTime == 0f)
		{
			float scaledDuration = GetScaledDuration(value.blueprint, currentCraftLevel, owner.IsInTutorial);
			value.endTime = Time.realtimeSinceStartup + scaledDuration;
			value.workbenchEntity = owner.GetCachedCraftLevelWorkbench();
			if ((Object)(object)owner != (Object)null)
			{
				owner.Command("note.craft_start", value.taskUID, scaledDuration, value.amount);
				if (owner.IsAdmin && Craft.instant)
				{
					value.endTime = Time.realtimeSinceStartup + 1f;
				}
			}
		}
		else
		{
			FinishCrafting(value);
			if (value.amount <= 0)
			{
				queue.RemoveFirst();
			}
			else
			{
				value.endTime = 0f;
			}
		}
	}

	private void CollectIngredient(int item, int amount, List<Item> collect, bool takeBroken = true)
	{
		foreach (ItemContainer container in containers)
		{
			amount -= container.Take(collect, item, amount, takeBroken);
			if (amount <= 0)
			{
				break;
			}
		}
	}

	private void CollectIngredients(ItemBlueprint bp, ItemCraftTask task, int amount = 1, BasePlayer player = null, bool takeBroken = true)
	{
		if (Interface.CallHook("OnIngredientsCollect", (object)this, (object)bp, (object)task, (object)amount, (object)player, (object)takeBroken) != null)
		{
			return;
		}
		List<Item> list = new List<Item>();
		foreach (ItemAmount ingredient in bp.GetIngredients())
		{
			CollectIngredient(ingredient.itemid, (int)ingredient.amount * amount, list, takeBroken);
		}
		foreach (Item item in list)
		{
			item.CollectedForCrafting(player);
		}
		task.takenItems = list;
	}

	public bool CraftItem(ItemBlueprint bp, BasePlayer owner, InstanceData instanceData = null, int amount = 1, int skinID = 0, Item fromTempBlueprint = null, bool free = false)
	{
		if ((Object)(object)owner != (Object)null && (owner.IsTransferring() || owner.IsSleeping()))
		{
			return false;
		}
		if (!CanCraft(bp, amount, free))
		{
			return false;
		}
		taskUID++;
		ItemCraftTask itemCraftTask = Pool.Get<ItemCraftTask>();
		itemCraftTask.blueprint = bp;
		if (!free)
		{
			CollectIngredients(bp, itemCraftTask, amount, owner, takeBroken: false);
		}
		itemCraftTask.endTime = 0f;
		itemCraftTask.taskUID = taskUID;
		itemCraftTask.instanceData = instanceData;
		if (itemCraftTask.instanceData != null)
		{
			itemCraftTask.instanceData.ShouldPool = false;
		}
		itemCraftTask.amount = amount;
		itemCraftTask.skinID = skinID;
		if (fromTempBlueprint != null && itemCraftTask.takenItems != null)
		{
			fromTempBlueprint.RemoveFromContainer();
			itemCraftTask.takenItems.Add(fromTempBlueprint);
			itemCraftTask.conditionScale = 0.5f;
		}
		object obj = Interface.CallHook("OnItemCraft", (object)itemCraftTask, (object)owner, (object)fromTempBlueprint);
		if (obj is bool)
		{
			if (fromTempBlueprint != null && itemCraftTask.instanceData != null)
			{
				fromTempBlueprint.instanceData = itemCraftTask.instanceData;
			}
			return (bool)obj;
		}
		queue.AddLast(itemCraftTask);
		if ((Object)(object)owner != (Object)null)
		{
			owner.Command("note.craft_add", itemCraftTask.taskUID, itemCraftTask.blueprint.targetItem.itemid, amount, itemCraftTask.skinID);
		}
		return true;
	}

	public void FinishCrafting(ItemCraftTask task)
	{
		//IL_0370: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_037e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0384: Unknown result type (might be due to invalid IL or missing references)
		task.amount--;
		task.numCrafted++;
		ulong skin = ItemDefinition.FindSkin(task.blueprint.targetItem.itemid, task.skinID);
		Item item2 = ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, 1, skin);
		item2.amount = task.blueprint.amountToCreate;
		int amount = item2.amount;
		_ = owner.currentCraftLevel;
		bool inSafezone = owner.InSafeZone();
		if (item2.hasCondition && task.conditionScale != 1f)
		{
			item2.maxCondition *= task.conditionScale;
			item2.condition = item2.maxCondition;
		}
		item2.OnVirginSpawn(owner);
		item2.SetItemOwnership(owner, ItemOwnershipPhrases.CraftedPhrase);
		foreach (ItemAmount ingredient in task.blueprint.GetIngredients())
		{
			int num = (int)ingredient.amount;
			if (task.takenItems == null)
			{
				continue;
			}
			foreach (Item takenItem in task.takenItems)
			{
				if ((Object)(object)takenItem.info == (Object)(object)ingredient.itemDef)
				{
					int num2 = Mathf.Min(takenItem.amount, num);
					Analytics.Azure.OnCraftMaterialConsumed(takenItem.info.shortname, num, base.baseEntity, task.workbenchEntity, inSafezone, item2.info.shortname);
					takenItem.UseItem(num);
					num -= num2;
				}
				if (num <= 0)
				{
					break;
				}
			}
		}
		task.takenItems?.RemoveAll((Item item) => item.amount == 0);
		Analytics.Azure.OnCraftItem(item2.info.shortname, item2.amount, base.baseEntity, task.workbenchEntity, inSafezone);
		owner.Command("note.craft_done", task.taskUID, 1, task.amount);
		Interface.CallHook("OnItemCraftFinished", (object)task, (object)item2, (object)this);
		if (task.instanceData != null)
		{
			item2.instanceData = task.instanceData;
		}
		if (!string.IsNullOrEmpty(task.blueprint.UnlockAchievment))
		{
			owner.GiveAchievement(task.blueprint.UnlockAchievment);
		}
		owner.ProcessMissionEvent(BaseMission.MissionEventType.CRAFT_ITEM, item2.info.itemid, amount);
		if (owner.inventory.GiveItem(item2))
		{
			owner.Command("note.inv", item2.info.itemid, amount);
			return;
		}
		ItemContainer itemContainer = containers.First();
		owner.Command("note.inv", item2.info.itemid, amount);
		owner.Command("note.inv", item2.info.itemid, -item2.amount);
		item2.Drop(itemContainer.dropPosition, itemContainer.dropVelocity);
	}

	public bool CancelTask(int iID)
	{
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		if (queue.Count == 0)
		{
			return false;
		}
		if ((Object)(object)owner != (Object)null && owner.IsTransferring())
		{
			return false;
		}
		ItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) => x.taskUID == iID && !x.cancelled);
		if (itemCraftTask == null)
		{
			return false;
		}
		itemCraftTask.cancelled = true;
		if ((Object)(object)owner == (Object)null)
		{
			return true;
		}
		Interface.CallHook("OnItemCraftCancelled", (object)itemCraftTask, (object)this);
		owner.Command("note.craft_done", itemCraftTask.taskUID, 0);
		if (itemCraftTask.takenItems != null && itemCraftTask.takenItems.Count > 0)
		{
			foreach (Item takenItem in itemCraftTask.takenItems)
			{
				if (takenItem != null && takenItem.amount > 0)
				{
					if (takenItem.IsBlueprint() && (Object)(object)takenItem.blueprintTargetDef == (Object)(object)itemCraftTask.blueprint.targetItem)
					{
						takenItem.UseItem(itemCraftTask.numCrafted);
					}
					if (takenItem.amount > 0 && !takenItem.MoveToContainer(owner.inventory.containerMain))
					{
						takenItem.Drop(owner.inventory.containerMain.dropPosition + Random.value * Vector3.down + Random.insideUnitSphere, owner.inventory.containerMain.dropVelocity);
						owner.Command("note.inv", takenItem.info.itemid, -takenItem.amount);
					}
				}
			}
			itemCraftTask.takenItems.Clear();
		}
		return true;
	}

	public bool CancelBlueprint(int itemid)
	{
		if (queue.Count == 0)
		{
			return false;
		}
		if ((Object)(object)owner != (Object)null && owner.IsTransferring())
		{
			return false;
		}
		ItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) => x.blueprint.targetItem.itemid == itemid && !x.cancelled);
		if (itemCraftTask == null)
		{
			return false;
		}
		return CancelTask(itemCraftTask.taskUID);
	}

	public void CancelAll()
	{
		foreach (ItemCraftTask item in queue)
		{
			CancelTask(item.taskUID);
		}
	}

	private bool DoesHaveOKConditionItem(int item, int iAmount = 1)
	{
		int num = 0;
		foreach (ItemContainer container in containers)
		{
			num += container.GetOkConditionAmount(item, onlyUsableAmounts: true);
		}
		return num >= iAmount;
	}

	public bool DoesHaveUsableItem(int item, int iAmount)
	{
		int num = 0;
		foreach (ItemContainer container in containers)
		{
			num += container.GetAmount(item, onlyUsableAmounts: true);
		}
		return num >= iAmount;
	}

	public bool CanCraft(ItemBlueprint bp, int amount = 1, bool free = false)
	{
		if (!bp.targetItem.IsAllowedInEra((EraRestriction)4))
		{
			return false;
		}
		if ((Object)(object)base.baseEntity != (Object)null && base.baseEntity.IsRestrained)
		{
			Handcuffs restraintItem = base.baseEntity.Belt.GetRestraintItem();
			if ((Object)(object)restraintItem != (Object)null && restraintItem.BlockCrafting)
			{
				return false;
			}
		}
		float num = (float)amount / (float)bp.targetItem.craftingStackable;
		foreach (ItemCraftTask item in queue)
		{
			if (!item.cancelled)
			{
				num += (float)item.amount / (float)item.blueprint.targetItem.craftingStackable;
			}
		}
		if (num > 8f)
		{
			return false;
		}
		object obj = Interface.CallHook("CanCraft", (object)this, (object)bp, (object)amount, (object)free);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (amount < 1 || amount > bp.targetItem.craftingStackable)
		{
			return false;
		}
		foreach (ItemAmount ingredient in bp.GetIngredients())
		{
			if (!DoesHaveUsableItem(ingredient.itemid, (int)ingredient.amount * amount))
			{
				return false;
			}
			if (ingredient.itemDef.condition.enabled && !DoesHaveOKConditionItem(ingredient.itemid, (int)ingredient.amount * amount))
			{
				return false;
			}
		}
		return true;
	}

	public bool CanCraft(ItemDefinition def, int amount = 1, bool free = false)
	{
		ItemBlueprint component = ((Component)def).GetComponent<ItemBlueprint>();
		if (CanCraft(component, amount, free))
		{
			return true;
		}
		return false;
	}

	public bool FastTrackTask(int taskID)
	{
		int taskID2 = taskID;
		if (queue.Count == 0)
		{
			return false;
		}
		if ((Object)(object)owner != (Object)null && owner.IsTransferring())
		{
			return false;
		}
		ItemCraftTask value = queue.First.Value;
		if (value == null)
		{
			return false;
		}
		ItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) => x.taskUID == taskID2 && !x.cancelled);
		if (itemCraftTask == null)
		{
			return false;
		}
		if (itemCraftTask == value)
		{
			return false;
		}
		object obj = Interface.CallHook("CanFastTrackCraftTask", (object)this, (object)itemCraftTask, (object)taskID);
		if (obj is bool)
		{
			return (bool)obj;
		}
		value.endTime = 0f;
		queue.Remove(itemCraftTask);
		queue.AddFirst(itemCraftTask);
		owner.Command("note.craft_fasttracked", taskID2);
		return true;
	}

	public ItemCrafter Save()
	{
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		ItemCrafter val = Pool.Get<ItemCrafter>();
		val.queue = Pool.Get<List<Task>>();
		foreach (ItemCraftTask item in queue)
		{
			Task val2 = Pool.Get<Task>();
			val2.itemID = item.blueprint.targetItem.itemid;
			val2.remainingTime = ((item.endTime > 0f) ? (item.endTime - Time.realtimeSinceStartup) : 0f);
			val2.taskUID = item.taskUID;
			val2.cancelled = item.cancelled;
			InstanceData instanceData = item.instanceData;
			val2.instanceData = ((instanceData != null) ? instanceData.Copy() : null);
			val2.amount = item.amount;
			val2.skinID = item.skinID;
			val2.takenItems = SaveItems(item.takenItems);
			val2.numCrafted = item.numCrafted;
			val2.conditionScale = item.conditionScale;
			val2.workbenchEntity = (NetworkableId)(item.workbenchEntity.IsValid() ? item.workbenchEntity.net.ID : default(NetworkableId));
			val.queue.Add(val2);
		}
		return val;
		static List<Item> SaveItems(List<Item> items)
		{
			List<Item> list = Pool.Get<List<Item>>();
			if (items != null)
			{
				foreach (Item item2 in items)
				{
					list.Add(item2.Save(bIncludeContainer: true));
				}
			}
			return list;
		}
	}

	public void Load(ItemCrafter proto)
	{
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		if (proto?.queue == null)
		{
			return;
		}
		queue.Clear();
		ItemBlueprint blueprint = default(ItemBlueprint);
		foreach (Task item in proto.queue)
		{
			ItemDefinition itemDefinition = ItemManager.FindItemDefinition(item.itemID);
			if ((Object)(object)itemDefinition == (Object)null || !((Component)itemDefinition).TryGetComponent<ItemBlueprint>(ref blueprint))
			{
				Debug.LogWarning((object)$"ItemCrafter has queue task for item ID {item.itemID}, but it was not found or has no blueprint. Skipping it");
				continue;
			}
			ItemCraftTask itemCraftTask = Pool.Get<ItemCraftTask>();
			itemCraftTask.blueprint = blueprint;
			itemCraftTask.endTime = ((item.remainingTime > 0f) ? (Time.realtimeSinceStartup + item.remainingTime) : 0f);
			itemCraftTask.taskUID = item.taskUID;
			itemCraftTask.cancelled = item.cancelled;
			InstanceData instanceData = item.instanceData;
			itemCraftTask.instanceData = ((instanceData != null) ? instanceData.Copy() : null);
			itemCraftTask.amount = item.amount;
			itemCraftTask.skinID = item.skinID;
			itemCraftTask.takenItems = LoadItems(item.takenItems);
			itemCraftTask.numCrafted = item.numCrafted;
			itemCraftTask.conditionScale = item.conditionScale;
			itemCraftTask.workbenchEntity = new EntityRef<BaseEntity>
			{
				uid = item.workbenchEntity
			}.Get(serverside: true);
			queue.AddLast(itemCraftTask);
			taskUID = Mathf.Max(taskUID, itemCraftTask.taskUID);
		}
		static List<Item> LoadItems(List<Item> itemProtos)
		{
			List<Item> list = new List<Item>();
			if (itemProtos != null)
			{
				foreach (Item itemProto in itemProtos)
				{
					list.Add(ItemManager.Load(itemProto, null, isServer: true));
				}
			}
			return list;
		}
	}

	public void SendToOwner()
	{
		if (!owner.IsValid() || !owner.IsConnected)
		{
			return;
		}
		foreach (ItemCraftTask item in queue)
		{
			owner.Command("note.craft_add", item.taskUID, item.blueprint.targetItem.itemid, item.amount, item.skinID);
		}
	}
}


using UnityEngine;
using UnityEngine.Events;

public class ItemEventFlag : MonoBehaviour, IItemUpdate
{
	public Item.Flag flag;

	public UnityEvent onEnabled = new UnityEvent();

	public UnityEvent onDisable = new UnityEvent();

	internal bool firstRun = true;

	internal bool lastState;

	public virtual void OnItemUpdate(Item item)
	{
		bool flag = item.HasFlag(this.flag);
		if (firstRun || flag != lastState)
		{
			if (flag)
			{
				onEnabled.Invoke();
			}
			else
			{
				onDisable.Invoke();
			}
			lastState = flag;
			firstRun = false;
		}
	}
}


using System.Collections.Generic;
using Rust;

public interface IAmmoContainer
{
	Item FindAmmo(AmmoTypes ammoType);

	void FindAmmo(List<Item> list, AmmoTypes ammoType);

	Item FindItemByItemID(int id);

	List<Item> FindItemsByItemID(int id);

	Item FindItemByItemName(string name);

	bool HasAmmo(AmmoTypes ammoType);

	Item FindItemByUID(ItemId iUID);

	bool GiveItem(Item item, ItemContainer container = null);
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class Item : IPooled
{
	[Flags]
	public enum Flag
	{
		None = 0,
		Placeholder = 1,
		IsOn = 2,
		OnFire = 4,
		IsLocked = 8,
		Cooking = 0x10,
		Radioactive = 0x20,
		Refrigerated = 0x40
	}

	private const string DefaultArmourBreakEffectPath = "assets/bundled/prefabs/fx/armor_break.prefab";

	public float _condition;

	public float _maxCondition = 100f;

	public ItemDefinition info;

	public ItemId uid;

	public bool dirty;

	public int amount = 1;

	public int position;

	public float busyTime;

	public float removeTime;

	public float fuel;

	public bool isServer;

	public InstanceData instanceData;

	public ulong skin;

	public string name;

	public string streamerName;

	public string text;

	public float cookTimeLeft;

	public float radioactivity;

	public List<ItemOwnershipShare> ownershipShares;

	public Flag flags;

	public ItemContainer contents;

	public ItemContainer parent;

	private EntityRef worldEnt;

	private EntityRef heldEntity;

	public float condition
	{
		get
		{
			return _condition;
		}
		set
		{
			float num = _condition;
			_condition = Mathf.Clamp(value, 0f, maxCondition);
			if (isServer && Mathf.Ceil(value) != Mathf.Ceil(num))
			{
				MarkDirty();
			}
		}
	}

	public float maxCondition
	{
		get
		{
			return _maxCondition;
		}
		set
		{
			_maxCondition = Mathf.Clamp(value, 0f, info.condition.max);
			if (isServer)
			{
				MarkDirty();
			}
		}
	}

	public float maxConditionNormalized => _maxCondition / info.condition.max;

	public float conditionNormalized
	{
		get
		{
			if (!hasCondition)
			{
				return 1f;
			}
			return condition / maxCondition;
		}
		set
		{
			if (hasCondition)
			{
				condition = value * maxCondition;
			}
		}
	}

	public bool hasCondition
	{
		get
		{
			if ((Object)(object)info != (Object)null && info.condition.enabled)
			{
				return info.condition.max > 0f;
			}
			return false;
		}
	}

	public bool isBroken
	{
		get
		{
			if (hasCondition)
			{
				return condition <= 0f;
			}
			return false;
		}
	}

	public int despawnMultiplier
	{
		get
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Expected I4, but got Unknown
			Rarity val = info.despawnRarity;
			if ((int)val == 0)
			{
				val = info.rarity;
			}
			if (!((Object)(object)info != (Object)null))
			{
				return 1;
			}
			return Mathf.Clamp((val - 1) * 4, 1, 100);
		}
	}

	public ItemDefinition blueprintTargetDef
	{
		get
		{
			if (!IsBlueprint())
			{
				return null;
			}
			return ItemManager.FindItemDefinition(blueprintTarget);
		}
	}

	public int blueprintTarget
	{
		get
		{
			if (instanceData == null)
			{
				return 0;
			}
			return instanceData.blueprintTarget;
		}
		set
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Expected O, but got Unknown
			if (instanceData == null)
			{
				instanceData = new InstanceData();
			}
			instanceData.ShouldPool = false;
			instanceData.blueprintTarget = value;
		}
	}

	public int blueprintAmount
	{
		get
		{
			return amount;
		}
		set
		{
			amount = value;
		}
	}

	public Item parentItem
	{
		get
		{
			if (parent == null)
			{
				return null;
			}
			return parent.parent;
		}
	}

	public float temperature
	{
		get
		{
			if (parent != null)
			{
				return parent.GetTemperature(position);
			}
			return 15f;
		}
	}

	public BaseEntity.TraitFlag Traits => info.Traits;

	public event Action<Item> OnDirty;

	public event Action<Item, float> onCycle;

	public void LoseCondition(float amount)
	{
		if (hasCondition && !Debugging.disablecondition && Interface.CallHook("IOnLoseCondition", (object)this, (object)amount) == null)
		{
			float num = condition;
			condition -= amount;
			if (Global.developer > 0)
			{
				Debug.Log((object)(info.shortname + " was damaged by: " + amount + "cond is: " + condition + "/" + maxCondition));
			}
			if (condition <= 0f && condition < num)
			{
				OnBroken();
			}
		}
	}

	public void RepairCondition(float amount)
	{
		if (hasCondition)
		{
			condition += amount;
		}
	}

	public void DoRepair(float maxLossFraction)
	{
		if (hasCondition)
		{
			if (info.condition.maintainMaxCondition)
			{
				maxLossFraction = 0f;
			}
			float num = 1f - condition / maxCondition;
			maxLossFraction = Mathf.Clamp(maxLossFraction, 0f, info.condition.max);
			maxCondition *= 1f - maxLossFraction * num;
			condition = maxCondition;
			BaseEntity baseEntity = GetHeldEntity();
			if ((Object)(object)baseEntity != (Object)null)
			{
				baseEntity.SetFlag(BaseEntity.Flags.Broken, b: false);
			}
			if (Global.developer > 0)
			{
				Debug.Log((object)(info.shortname + " was repaired! new cond is: " + condition + "/" + maxCondition));
			}
		}
	}

	public ItemContainer GetRootContainer()
	{
		ItemContainer itemContainer = parent;
		int num = 0;
		while (itemContainer != null && num <= 8 && itemContainer.parent != null && itemContainer.parent.parent != null)
		{
			itemContainer = itemContainer.parent.parent;
			num++;
		}
		if (num == 8)
		{
			Debug.LogWarning((object)"GetRootContainer failed with 8 iterations");
		}
		return itemContainer;
	}

	public virtual void OnBroken()
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		if (!hasCondition)
		{
			return;
		}
		BaseEntity baseEntity = GetHeldEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			baseEntity.SetFlag(BaseEntity.Flags.Broken, b: true);
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (Object.op_Implicit((Object)(object)ownerPlayer))
		{
			if (ownerPlayer.GetActiveItem() == this)
			{
				Effect.server.Run("assets/bundled/prefabs/fx/item_break.prefab", ownerPlayer, 0u, Vector3.zero, Vector3.zero);
				ownerPlayer.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ActiveItemBroken, false);
			}
			ItemModWearable itemModWearable = default(ItemModWearable);
			if (((Component)info).TryGetComponent<ItemModWearable>(ref itemModWearable) && ownerPlayer.inventory.containerWear.itemList.Contains(this))
			{
				if (itemModWearable.breakEffect.isValid)
				{
					Effect.server.Run(itemModWearable.breakEffect.resourcePath, ownerPlayer, 0u, Vector3.zero, Vector3.zero);
				}
				else
				{
					Effect.server.Run("assets/bundled/prefabs/fx/armor_break.prefab", ownerPlayer, 0u, Vector3.zero, Vector3.zero);
				}
			}
		}
		if (info.condition.breakEffect != null && info.condition.breakEffect.isValid)
		{
			BasePlayer playerOwner = GetRootContainer().playerOwner;
			if ((Object)(object)playerOwner != (Object)null)
			{
				Effect.server.Run(info.condition.breakEffect.resourcePath, playerOwner, 0u, Vector3.zero, Vector3.zero);
			}
		}
		if ((!info.condition.repairable && !Object.op_Implicit((Object)(object)((Component)info).GetComponent<ItemModRepair>())) || maxCondition <= 5f)
		{
			UnloadAmmo();
			Remove();
		}
		else if (parent != null && parent.HasFlag(ItemContainer.Flag.NoBrokenItems))
		{
			ItemContainer rootContainer = GetRootContainer();
			if (rootContainer.HasFlag(ItemContainer.Flag.NoBrokenItems))
			{
				Remove();
			}
			else
			{
				BasePlayer playerOwner2 = rootContainer.playerOwner;
				if ((Object)(object)playerOwner2 != (Object)null && !MoveToContainer(playerOwner2.inventory.containerMain))
				{
					Drop(((Component)playerOwner2).transform.position, playerOwner2.eyes.BodyForward() * 1.5f);
				}
			}
		}
		ItemModEntity itemModEntity = default(ItemModEntity);
		if (((Component)info).TryGetComponent<ItemModEntity>(ref itemModEntity) && itemModEntity.destroyEntityWhenBroken)
		{
			baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);
		}
		MarkDirty();
	}

	void IPooled.EnterPool()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		info = null;
		uid = default(ItemId);
		dirty = false;
		amount = 1;
		position = 0;
		busyTime = 0f;
		removeTime = 0f;
		fuel = 0f;
		isServer = false;
		instanceData = null;
		skin = 0uL;
		name = null;
		streamerName = null;
		text = null;
		cookTimeLeft = 0f;
		radioactivity = 0f;
		flags = Flag.None;
		if (contents != null)
		{
			Pool.Free<ItemContainer>(ref contents);
		}
		parent = null;
		heldEntity = default(EntityRef);
		worldEnt = default(EntityRef);
		this.onCycle = null;
		this.OnDirty = null;
		_condition = 0f;
		_maxCondition = 100f;
		ownershipShares = null;
	}

	void IPooled.LeavePool()
	{
	}

	public string GetName(bool? streamerModeOverride = null)
	{
		if (streamerModeOverride.HasValue)
		{
			if (!streamerModeOverride.Value)
			{
				return name;
			}
			return streamerName ?? name;
		}
		return name;
	}

	public bool IsBlueprint()
	{
		return blueprintTarget != 0;
	}

	public bool HasFlag(Flag f)
	{
		return (flags & f) == f;
	}

	public void SetFlag(Flag f, bool b)
	{
		if (b)
		{
			flags |= f;
		}
		else
		{
			flags &= ~f;
		}
	}

	public bool IsOn()
	{
		return HasFlag(Flag.IsOn);
	}

	public bool IsOnFire()
	{
		return HasFlag(Flag.OnFire);
	}

	public bool IsCooking()
	{
		return HasFlag(Flag.Cooking);
	}

	public bool IsLocked()
	{
		if (!HasFlag(Flag.IsLocked))
		{
			if (parent != null)
			{
				return parent.IsLocked();
			}
			return false;
		}
		return true;
	}

	public bool IsRadioactive()
	{
		return HasFlag(Flag.Radioactive);
	}

	public bool IsRefrigerated()
	{
		return HasFlag(Flag.Refrigerated);
	}

	public void MarkDirty()
	{
		OnChanged();
		dirty = true;
		if (parent != null)
		{
			parent.MarkDirty();
		}
		if (this.OnDirty != null)
		{
			this.OnDirty(this);
		}
	}

	public void OnChanged()
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].OnChanged(this);
		}
		if (contents != null)
		{
			contents.OnChanged();
		}
	}

	public void CollectedForCrafting(BasePlayer crafter)
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].CollectedForCrafting(this, crafter);
		}
	}

	public void ReturnedFromCancelledCraft(BasePlayer crafter)
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].ReturnedFromCancelledCraft(this, crafter);
		}
	}

	public void Initialize(ItemDefinition template)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		uid = new ItemId(Net.sv.TakeUID());
		float num = (maxCondition = info.condition.max);
		condition = num;
		SetRadioactivity(template);
		InitializeItemOwnership();
		OnItemCreated();
	}

	public void OnItemCreated()
	{
		this.onCycle = null;
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].OnItemCreated(this);
		}
	}

	public void OnVirginSpawn(BasePlayer creatingPlayer = null)
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].OnVirginItem(this, creatingPlayer);
		}
	}

	public float GetDespawnDuration()
	{
		if (info.quickDespawn)
		{
			return ConVar.Server.itemdespawn_quick;
		}
		int num = 0;
		if (contents != null && contents.itemList != null)
		{
			foreach (Item item in contents.itemList)
			{
				num += item.despawnMultiplier;
			}
		}
		return (float)Mathf.Min(Mathf.Max(despawnMultiplier, num), ConVar.Server.itemdespawn_container_max_multiplier) * ConVar.Server.itemdespawn;
	}

	public void RemoveFromWorld()
	{
		BaseEntity worldEntity = GetWorldEntity();
		if ((Object)(object)worldEntity == (Object)null)
		{
			return;
		}
		SetWorldEntity(null);
		OnRemovedFromWorld();
		if (contents != null)
		{
			contents.OnRemovedFromWorld();
		}
		if (worldEntity.IsValid())
		{
			if (worldEntity is WorldItem worldItem)
			{
				worldItem.RemoveItem();
			}
			worldEntity.Kill();
		}
	}

	public void OnRemovedFromWorld()
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].OnRemovedFromWorld(this);
		}
	}

	public void RemoveFromContainer()
	{
		if (parent != null)
		{
			SetParent(null);
		}
	}

	public bool DoItemSlotsConflict(Item other)
	{
		return (info.occupySlots & other.info.occupySlots) != 0;
	}

	public void AddItemOwnership(string username, string reason, int shareAmount)
	{
		if (ownershipShares == null)
		{
			return;
		}
		if (ownershipShares.Count > 0)
		{
			for (int i = 0; i < ownershipShares.Count; i++)
			{
				ItemOwnershipShare value = ownershipShares[i];
				if (value.username == username && value.reason == reason)
				{
					value.amount += shareAmount;
					ownershipShares[i] = value;
					shareAmount = 0;
					break;
				}
			}
		}
		if (shareAmount > 0)
		{
			ItemOwnershipShare itemOwnershipShare = default(ItemOwnershipShare);
			itemOwnershipShare.username = username;
			itemOwnershipShare.reason = reason;
			itemOwnershipShare.amount = shareAmount;
			ItemOwnershipShare item = itemOwnershipShare;
			ownershipShares.Add(item);
		}
		MarkDirty();
	}

	public void MigrateItemOwnership(Item targetItem, int amount)
	{
		if (ownershipShares != null && targetItem.ownershipShares != null)
		{
			TransferOwnership(targetItem, amount);
		}
	}

	public ItemOwnershipShare TakeOwnershipShare()
	{
		if (!HasItemOwnership())
		{
			return default(ItemOwnershipShare);
		}
		ItemOwnershipShare itemOwnershipShare = ownershipShares[0];
		itemOwnershipShare.amount--;
		ownershipShares[0] = itemOwnershipShare;
		if (itemOwnershipShare.amount <= 0)
		{
			ownershipShares.RemoveAt(0);
		}
		return itemOwnershipShare;
	}

	public void ReduceItemOwnership(int amount)
	{
		if (ownershipShares != null)
		{
			TransferOwnership(null, amount);
		}
	}

	private void TransferOwnership(Item targetItem, int amount)
	{
		for (int num = ownershipShares.Count - 1; num >= 0; num--)
		{
			if (amount <= 0)
			{
				return;
			}
			ItemOwnershipShare value = ownershipShares[num];
			int num2 = Mathf.Min(value.amount, amount);
			targetItem?.AddItemOwnership(value.username, value.reason, num2);
			amount -= num2;
			value.amount -= num2;
			if (value.amount == 0)
			{
				ownershipShares.RemoveAt(num);
			}
			else
			{
				ownershipShares[num] = value;
			}
		}
		MarkDirty();
	}

	public bool HasItemOwnership()
	{
		if (ownershipShares != null)
		{
			return ownershipShares.Count > 0;
		}
		return false;
	}

	public Item SetItemOwnership(BasePlayer player, Phrase reason)
	{
		return SetItemOwnership(((Object)(object)player != (Object)null && !player.IsDestroyed) ? player.displayName : "", reason.token);
	}

	public Item SetItemOwnership(ItemOwnershipShare ownership)
	{
		return SetItemOwnership(ownership.username, ownership.reason);
	}

	public Item SetItemOwnership(BasePlayer player, string reason)
	{
		return SetItemOwnership(((Object)(object)player != (Object)null && !player.IsDestroyed) ? player.displayName : "", reason);
	}

	public Item SetItemOwnership(string username, Phrase reason)
	{
		return SetItemOwnership(username, reason?.token ?? "");
	}

	public Item SetItemOwnership(string username, string reason)
	{
		if (ownershipShares == null)
		{
			return this;
		}
		ownershipShares?.Clear();
		AddItemOwnership(username, reason, amount);
		return this;
	}

	public void InitializeItemOwnership()
	{
		if (!((Object)(object)info == (Object)null) && info.SupportsItemOwnership() && ownershipShares == null)
		{
			ownershipShares = Pool.Get<List<ItemOwnershipShare>>();
		}
	}

	public void SetParent(ItemContainer target)
	{
		if (target == parent)
		{
			return;
		}
		if (parent != null)
		{
			parent.Remove(this);
			parent = null;
		}
		if (target == null)
		{
			position = 0;
		}
		else
		{
			parent = target;
			if (!parent.Insert(this))
			{
				Remove();
				Debug.LogError((object)"Item.SetParent caused remove - this shouldn't ever happen");
			}
		}
		MarkDirty();
		RecalulateParentEntity(children: false);
		if (parent != null)
		{
			ItemContainer itemContainer = parent;
			BasePlayer basePlayer = null;
			do
			{
				basePlayer = itemContainer.GetOwnerPlayer();
				itemContainer = itemContainer?.parent?.parent;
			}
			while (itemContainer != null && (Object)(object)basePlayer == (Object)null);
			if ((Object)(object)basePlayer != (Object)null)
			{
				if (!basePlayer.enableSaving)
				{
					ForbidHeldEntitySaving();
				}
				else
				{
					RestoreHeldEntitySaving();
				}
			}
		}
		else
		{
			RestoreHeldEntitySaving();
		}
	}

	public void RecalulateParentEntity(bool children)
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].OnParentChanged(this);
		}
		if (!children || contents == null)
		{
			return;
		}
		foreach (Item item in contents.itemList)
		{
			item.RecalulateParentEntity(children: false);
		}
	}

	private void ForbidHeldEntitySaving()
	{
		if (heldEntity.IsValid(serverside: true))
		{
			heldEntity.Get(serverside: true).EnableSaving(wants: false);
		}
		if (contents == null)
		{
			return;
		}
		foreach (Item item in contents.itemList)
		{
			item.ForbidHeldEntitySaving();
		}
	}

	private void RestoreHeldEntitySaving()
	{
		if (heldEntity.IsValid(serverside: true))
		{
			heldEntity.Get(serverside: true).RestoreCanSave();
		}
		if (contents == null)
		{
			return;
		}
		foreach (Item item in contents.itemList)
		{
			item.RestoreHeldEntitySaving();
		}
	}

	public void OnAttacked(HitInfo hitInfo)
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].OnAttacked(this, hitInfo);
		}
	}

	public BaseEntity GetEntityOwner()
	{
		return parent?.GetEntityOwner();
	}

	public bool IsChildContainer(ItemContainer c)
	{
		if (contents == null)
		{
			return false;
		}
		if (contents == c)
		{
			return true;
		}
		foreach (Item item in contents.itemList)
		{
			if (item.IsChildContainer(c))
			{
				return true;
			}
		}
		return false;
	}

	public bool CanMoveTo(ItemContainer newcontainer, int iTargetPos = -1)
	{
		if (IsChildContainer(newcontainer))
		{
			return false;
		}
		if (newcontainer.CanAcceptItem(this, iTargetPos) != 0)
		{
			return false;
		}
		if (iTargetPos >= newcontainer.capacity)
		{
			return false;
		}
		if (parent != null && newcontainer == parent && iTargetPos == position)
		{
			return false;
		}
		return true;
	}

	public bool MoveToContainer(ItemContainer newcontainer, int iTargetPos = -1, bool allowStack = true, bool ignoreStackLimit = false, BasePlayer sourcePlayer = null, bool allowSwap = true)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0584: Unknown result type (might be due to invalid IL or missing references)
		//IL_058a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0591: Unknown result type (might be due to invalid IL or missing references)
		//IL_0597: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("MoveToContainer", 0);
		try
		{
			BasePlayer playerOwner = newcontainer.playerOwner;
			if ((Object)(object)playerOwner != (Object)null && playerOwner.IsDead() && parent != null)
			{
				return false;
			}
			bool flag = iTargetPos == -1;
			ItemContainer itemContainer = parent;
			if (iTargetPos == -1)
			{
				if (allowStack && info.stackable > 1)
				{
					BufferList<Item> val2 = Pool.Get<BufferList<Item>>();
					newcontainer.FindItemsByItemID(info.itemid, val2);
					Enumerator<Item> enumerator = val2.GetEnumerator();
					try
					{
						while (enumerator.MoveNext())
						{
							Item current = enumerator.Current;
							if (current.position > iTargetPos && current.CanStack(this) && (ignoreStackLimit || current.amount < current.MaxStackable()))
							{
								iTargetPos = current.position;
							}
						}
					}
					finally
					{
						((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
					}
					Pool.Free<Item>(ref val2, false);
				}
				if (iTargetPos == -1 && newcontainer.GetEntityOwner(returnHeldEntity: true) is IIdealSlotEntity idealSlotEntity)
				{
					iTargetPos = idealSlotEntity.GetIdealSlot(sourcePlayer, newcontainer, this);
					if (iTargetPos == int.MinValue)
					{
						return false;
					}
				}
				if (iTargetPos == -1)
				{
					if (newcontainer == parent)
					{
						return false;
					}
					bool flag2 = newcontainer.HasFlag(ItemContainer.Flag.Clothing) && info.isWearable;
					ItemModWearable itemModWearable = info.ItemModWearable;
					for (int i = 0; i < newcontainer.capacity; i++)
					{
						Item slot = newcontainer.GetSlot(i);
						if (slot == null)
						{
							if (CanMoveTo(newcontainer, i))
							{
								iTargetPos = i;
								break;
							}
							continue;
						}
						if (flag2 && slot != null && !slot.info.ItemModWearable.CanExistWith(itemModWearable))
						{
							iTargetPos = i;
							break;
						}
						if (newcontainer.HasAvailableSlotsDefined && DoItemSlotsConflict(slot))
						{
							iTargetPos = i;
							break;
						}
					}
					if (flag2 && iTargetPos == -1)
					{
						iTargetPos = newcontainer.capacity - 1;
					}
				}
			}
			if (iTargetPos == -1)
			{
				return false;
			}
			if (!CanMoveTo(newcontainer, iTargetPos))
			{
				return false;
			}
			if (iTargetPos >= 0 && newcontainer.SlotTaken(this, iTargetPos))
			{
				Item slot2 = newcontainer.GetSlot(iTargetPos);
				if (slot2 == this)
				{
					return false;
				}
				if (allowStack && slot2 != null)
				{
					int num = slot2.MaxStackable();
					if (slot2.CanStack(this))
					{
						if (ignoreStackLimit)
						{
							num = int.MaxValue;
						}
						if (slot2.amount >= num)
						{
							return false;
						}
						int num2 = Mathf.Min(num - slot2.amount, amount);
						slot2.amount += num2;
						if (slot2.instanceData != null && instanceData != null && Object.op_Implicit((Object)(object)((Component)info).GetComponent<ItemModFoodSpoiling>()))
						{
							slot2.instanceData.dataFloat = Mathf.Min(slot2.instanceData.dataFloat, instanceData.dataFloat);
						}
						newcontainer.onItemAddedToStack?.Invoke(slot2, num2);
						amount -= num2;
						slot2.MarkDirty();
						Interface.CallHook("OnItemStacked", (object)slot2, (object)this, (object)newcontainer, (object)num2);
						MarkDirty();
						MigrateItemOwnership(slot2, num2);
						if (amount <= 0)
						{
							RemoveFromWorld();
							RemoveFromContainer();
							Remove();
							return true;
						}
						if (flag)
						{
							return MoveToContainer(newcontainer, -1, allowStack, ignoreStackLimit, sourcePlayer);
						}
						return false;
					}
				}
				if (parent != null && allowSwap && slot2 != null)
				{
					ItemContainer itemContainer2 = parent;
					int iTargetPos2 = position;
					ItemContainer newcontainer2 = slot2.parent;
					int num3 = slot2.position;
					if (!slot2.CanMoveTo(itemContainer2, iTargetPos2))
					{
						return false;
					}
					if (itemContainer2.maxStackSize > 0 && slot2.amount > itemContainer2.maxStackSize)
					{
						Item item = slot2.SplitItem(slot2.amount - itemContainer2.maxStackSize);
						if (item == null || !item.MoveToContainer(newcontainer2, -1, allowStack: false, ignoreStackLimit: false, sourcePlayer, allowSwap: false))
						{
							slot2.amount += item.amount;
							item.MigrateItemOwnership(slot2, item.amount);
							item.Remove();
							return false;
						}
					}
					BaseEntity entityOwner = GetEntityOwner();
					BaseEntity entityOwner2 = slot2.GetEntityOwner();
					RemoveFromContainer();
					slot2.RemoveFromContainer();
					RemoveConflictingSlots(newcontainer, entityOwner, sourcePlayer);
					slot2.RemoveConflictingSlots(itemContainer2, entityOwner2, sourcePlayer);
					if (!slot2.MoveToContainer(itemContainer2, iTargetPos2, allowStack: true, ignoreStackLimit: false, sourcePlayer) || !MoveToContainer(newcontainer, iTargetPos, allowStack: true, ignoreStackLimit: false, sourcePlayer))
					{
						RemoveFromContainer();
						slot2.RemoveFromContainer();
						SetParent(itemContainer2);
						position = iTargetPos2;
						slot2.SetParent(newcontainer2);
						slot2.position = num3;
						return true;
					}
					return true;
				}
				return false;
			}
			if (parent == newcontainer)
			{
				if (iTargetPos >= 0 && iTargetPos != position && !parent.SlotTaken(this, iTargetPos))
				{
					newcontainer.onItemPositionChanged?.Invoke(this, position, iTargetPos);
					position = iTargetPos;
					MarkDirty();
					return true;
				}
				return false;
			}
			if (newcontainer.maxStackSize > 0 && newcontainer.maxStackSize < amount)
			{
				Item item2 = SplitItem(newcontainer.maxStackSize);
				if (item2 != null && !item2.MoveToContainer(newcontainer, iTargetPos, allowStack: false, ignoreStackLimit: false, sourcePlayer) && (itemContainer == null || !item2.MoveToContainer(itemContainer, -1, allowStack: true, ignoreStackLimit: false, sourcePlayer)))
				{
					DroppedItem droppedItem = item2.Drop(newcontainer.dropPosition, newcontainer.dropVelocity) as DroppedItem;
					if ((Object)(object)droppedItem != (Object)null)
					{
						droppedItem.DroppedBy = sourcePlayer?.userID ?? ((EncryptedValue<ulong>)0uL);
					}
				}
				Interface.CallHook("OnItemStacked", (object)item2, (object)this, (object)newcontainer);
				return true;
			}
			if (!newcontainer.CanAccept(this))
			{
				return false;
			}
			BaseEntity entityOwner3 = GetEntityOwner();
			RemoveFromContainer();
			RemoveFromWorld();
			RemoveConflictingSlots(newcontainer, entityOwner3, sourcePlayer);
			position = iTargetPos;
			SetParent(newcontainer);
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void RemoveConflictingSlots(ItemContainer container, BaseEntity entityOwner, BasePlayer sourcePlayer)
	{
		if (!isServer || !container.HasAvailableSlotsDefined)
		{
			return;
		}
		List<Item> list = Pool.Get<List<Item>>();
		list.AddRange(container.itemList);
		foreach (Item item in list)
		{
			if (item.DoItemSlotsConflict(this))
			{
				item.RemoveFromContainer();
				if (entityOwner is BasePlayer basePlayer)
				{
					basePlayer.GiveItem(item);
				}
				else if (entityOwner is IItemContainerEntity itemContainerEntity)
				{
					item.MoveToContainer(itemContainerEntity.inventory, -1, allowStack: true, ignoreStackLimit: false, sourcePlayer);
				}
			}
		}
		Pool.Free<Item>(ref list, false);
	}

	public BaseEntity CreateWorldObject(Vector3 pos, Quaternion rotation = default(Quaternion), BaseEntity parentEnt = null, uint parentBone = 0u)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity worldEntity = GetWorldEntity();
		if ((Object)(object)worldEntity != (Object)null)
		{
			return worldEntity;
		}
		worldEntity = GameManager.server.CreateEntity("assets/prefabs/misc/burlap sack/generic_world.prefab", pos, rotation);
		if ((Object)(object)worldEntity == (Object)null)
		{
			Debug.LogWarning((object)"Couldn't create world object for prefab: items/generic_world");
			return null;
		}
		WorldItem worldItem = worldEntity as WorldItem;
		if ((Object)(object)worldItem != (Object)null)
		{
			worldItem.InitializeItem(this);
		}
		if ((Object)(object)parentEnt != (Object)null)
		{
			worldEntity.SetParent(parentEnt, parentBone);
		}
		worldEntity.Spawn();
		SetWorldEntity(worldEntity);
		return GetWorldEntity();
	}

	public BaseEntity Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation = default(Quaternion))
	{
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		ulong droppedBy = GetRootContainer()?.playerOwner?.userID ?? ((EncryptedValue<ulong>)0uL);
		RemoveFromWorld();
		if (info.AlignWorldModelOnDrop)
		{
			Quaternion val = Quaternion.LookRotation(((Vector3)(ref vVelocity)).normalized, Vector3.up);
			rotation = Quaternion.Euler(0f, ((Quaternion)(ref val)).eulerAngles.y, 0f);
			rotation = Quaternion.Euler(info.WorldModelDropOffset) * rotation;
		}
		BaseEntity baseEntity = null;
		if (vPos != Vector3.zero && !info.HasFlag(ItemDefinition.Flag.NoDropping))
		{
			baseEntity = CreateWorldObject(vPos, rotation);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.SetVelocity(vVelocity);
			}
			if (baseEntity is DroppedItem droppedItem)
			{
				droppedItem.DroppedBy = droppedBy;
				if (info.AdjustCenterOfMassOnDrop)
				{
					droppedItem.Rigidbody.centerOfMass = info.DropCenterOfMass;
				}
			}
		}
		else
		{
			Remove();
		}
		Interface.CallHook("OnItemDropped", (object)this, (object)baseEntity);
		RemoveFromContainer();
		return baseEntity;
	}

	public BaseEntity DropAndTossUpwards(Vector3 vPos, float force = 2f)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		float num = Random.value * MathF.PI * 2f;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(Mathf.Sin(num), 1f, Mathf.Cos(num));
		return Drop(vPos + Vector3.up * 0.1f, val * force);
	}

	public bool IsBusy()
	{
		if (busyTime > Time.time)
		{
			return true;
		}
		return false;
	}

	public void BusyFor(float fTime)
	{
		busyTime = Time.time + fTime;
	}

	public bool IsRemoved()
	{
		return removeTime > 0f;
	}

	public void Remove(float fTime = 0f)
	{
		if (removeTime > 0f || Interface.CallHook("OnItemRemove", (object)this) != null)
		{
			return;
		}
		if (isServer)
		{
			ItemMod[] itemMods = info.itemMods;
			for (int i = 0; i < itemMods.Length; i++)
			{
				itemMods[i].OnRemove(this);
			}
		}
		this.onCycle = null;
		removeTime = Time.time + fTime;
		this.OnDirty = null;
		position = -1;
		ItemManager.RemoveItem(this, fTime);
	}

	public void DoRemove()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		this.OnDirty = null;
		this.onCycle = null;
		if (isServer && ((ItemId)(ref uid)).IsValid && Net.sv != null)
		{
			Net.sv.ReturnUID(uid.Value);
			uid = default(ItemId);
		}
		if (contents != null)
		{
			Pool.Free<ItemContainer>(ref contents);
		}
		if (isServer)
		{
			RemoveFromWorld();
			RemoveFromContainer();
		}
		BaseEntity baseEntity = GetHeldEntity();
		if (baseEntity.IsValid())
		{
			Debug.LogWarning((object)("Item's Held Entity not removed!" + info.displayName.english + " -> " + (object)baseEntity), (Object)(object)baseEntity);
		}
	}

	public void SwitchOnOff(bool bNewState)
	{
		if (HasFlag(Flag.IsOn) != bNewState)
		{
			SetFlag(Flag.IsOn, bNewState);
			MarkDirty();
		}
	}

	public void LockUnlock(bool bNewState)
	{
		if (HasFlag(Flag.IsLocked) != bNewState && (!bNewState || Interface.CallHook("OnItemLock", (object)this) == null) && (bNewState || Interface.CallHook("OnItemUnlock", (object)this) == null))
		{
			SetFlag(Flag.IsLocked, bNewState);
			MarkDirty();
		}
	}

	public BasePlayer GetOwnerPlayer()
	{
		if (parent == null)
		{
			return null;
		}
		return parent.GetOwnerPlayer();
	}

	public bool IsBackpack()
	{
		if ((Object)(object)info != (Object)null)
		{
			return (info.flags & ItemDefinition.Flag.Backpack) != 0;
		}
		return false;
	}

	public int GetChildItemCount()
	{
		return (contents?.itemList?.Count).GetValueOrDefault();
	}

	public int GetItemVolume()
	{
		if (IsBackpack() && (contents?.itemList?.Count).GetValueOrDefault() > 0)
		{
			ItemModBackpack component = ((Component)info).GetComponent<ItemModBackpack>();
			if ((Object)(object)component != (Object)null)
			{
				return component.containerVolumeWhenFilled;
			}
		}
		return info.volume;
	}

	public Item SplitItem(int split_Amount)
	{
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Expected O, but got Unknown
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Expected O, but got Unknown
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Expected O, but got Unknown
		Assert.IsTrue(split_Amount > 0, "split_Amount <= 0");
		if (split_Amount <= 0)
		{
			return null;
		}
		if (split_Amount >= amount)
		{
			return null;
		}
		object obj = Interface.CallHook("OnItemSplit", (object)this, (object)split_Amount);
		if (obj is Item)
		{
			return (Item)obj;
		}
		amount -= split_Amount;
		Item item = ItemManager.CreateByItemID(info.itemid, 1, 0uL);
		item.amount = split_Amount;
		item.skin = skin;
		MigrateItemOwnership(item, split_Amount);
		if (IsBlueprint())
		{
			item.blueprintTarget = blueprintTarget;
		}
		if (info.amountType == ItemDefinition.AmountType.Genetics && instanceData != null && instanceData.dataInt != 0)
		{
			item.instanceData = new InstanceData();
			item.instanceData.dataInt = instanceData.dataInt;
			item.instanceData.ShouldPool = false;
		}
		if (instanceData != null && instanceData.dataInt > 0 && (Object)(object)info != (Object)null && (Object)(object)info.Blueprint != (Object)null && info.Blueprint.GetWorkbenchLevel() == 3)
		{
			item.instanceData = new InstanceData();
			item.instanceData.dataInt = instanceData.dataInt;
			item.instanceData.ShouldPool = false;
			item.SetFlag(Flag.IsOn, IsOn());
		}
		if (instanceData != null && Object.op_Implicit((Object)(object)((Component)info).GetComponent<ItemModFoodSpoiling>()))
		{
			item.instanceData = new InstanceData();
			item.instanceData.dataFloat = instanceData.dataFloat;
			item.instanceData.ShouldPool = false;
		}
		MarkDirty();
		return item;
	}

	public void UnloadAmmo()
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		BaseProjectile baseProjectile = GetHeldEntity() as BaseProjectile;
		if ((Object)(object)baseProjectile == (Object)null)
		{
			return;
		}
		while (baseProjectile.primaryMagazine.contents > 0)
		{
			int num = Mathf.Min(baseProjectile.primaryMagazine.contents, baseProjectile.primaryMagazine.ammoType.stackable);
			baseProjectile.primaryMagazine.contents -= num;
			Item item = ItemManager.Create(baseProjectile.primaryMagazine.ammoType, num, 0uL);
			BasePlayer basePlayer = GetRootContainer()?.playerOwner;
			if ((Object)(object)basePlayer != (Object)null)
			{
				basePlayer.GiveItem(item);
			}
			else if (!item.MoveToContainer(parent) && (Object)(object)item.Drop(parent.dropPosition, parent.dropVelocity) == (Object)null)
			{
				item.Remove();
			}
		}
	}

	public bool CanBeHeld()
	{
		if (isBroken)
		{
			return false;
		}
		if ((Object)(object)((Component)info).GetComponent<ItemModShield>() != (Object)null)
		{
			return false;
		}
		return true;
	}

	public bool CanStack(Item item)
	{
		object obj = Interface.CallHook("CanStackItem", (object)this, (object)item);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (item == this)
		{
			return false;
		}
		if (MaxStackable() <= 1)
		{
			return false;
		}
		if (item.info.stackable <= 1)
		{
			return false;
		}
		if (item.info.itemid != info.itemid)
		{
			return false;
		}
		if (hasCondition && condition != item.info.condition.max)
		{
			return false;
		}
		if (item.hasCondition && item.condition != item.info.condition.max)
		{
			return false;
		}
		if (!IsValid())
		{
			return false;
		}
		if (IsBlueprint() && blueprintTarget != item.blueprintTarget)
		{
			return false;
		}
		if (item.skin != skin)
		{
			return false;
		}
		if (item.info.amountType == ItemDefinition.AmountType.Genetics || info.amountType == ItemDefinition.AmountType.Genetics)
		{
			int num = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));
			int num2 = ((instanceData != null) ? instanceData.dataInt : (-1));
			if (num != num2)
			{
				return false;
			}
		}
		if (item.instanceData != null && instanceData != null && (item.IsOn() != IsOn() || (item.instanceData.dataInt != instanceData.dataInt && (Object)(object)item.info.Blueprint != (Object)null && item.info.Blueprint.GetWorkbenchLevel() == 3)))
		{
			return false;
		}
		if (instanceData != null && ((NetworkableId)(ref instanceData.subEntity)).IsValid && Object.op_Implicit((Object)(object)((Component)info).GetComponent<ItemModSign>()))
		{
			return false;
		}
		if (item.instanceData != null && ((NetworkableId)(ref item.instanceData.subEntity)).IsValid && Object.op_Implicit((Object)(object)((Component)item.info).GetComponent<ItemModSign>()))
		{
			return false;
		}
		if (BlockStackFoodItem(item, this))
		{
			return false;
		}
		return true;
	}

	public static bool BlockStackFoodItem(Item a, Item b)
	{
		ItemModFoodSpoiling itemModFoodSpoiling = default(ItemModFoodSpoiling);
		if (a.instanceData != null && b.instanceData != null && ((Component)a.info).TryGetComponent<ItemModFoodSpoiling>(ref itemModFoodSpoiling))
		{
			bool flag = false;
			float dataFloat = a.instanceData.dataFloat;
			float dataFloat2 = b.instanceData.dataFloat;
			if (Mathf.Abs(dataFloat - dataFloat2) < ConVar.Server.maxFoodSpoilTimeDiffForItemStack)
			{
				flag = true;
			}
			float num = itemModFoodSpoiling.TotalSpoilTimeHours * 60f * 60f;
			float num2 = a.instanceData.dataFloat / num;
			float num3 = b.instanceData.dataFloat / num;
			if (num2 > ConVar.Server.normalisedFoodSpoilTimeStackThreshold && num3 > ConVar.Server.normalisedFoodSpoilTimeStackThreshold)
			{
				flag = true;
			}
			if (!flag)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsValid()
	{
		if (removeTime > 0f)
		{
			return false;
		}
		return true;
	}

	public bool IsDroppedInWorld(bool serverside)
	{
		return worldEnt.IsValid(serverside);
	}

	public void SetWorldEntity(BaseEntity ent)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (!ent.IsValid())
		{
			worldEnt.Set(null);
			MarkDirty();
		}
		else if (!(worldEnt.uid == ent.net.ID))
		{
			worldEnt.Set(ent);
			MarkDirty();
			OnMovedToWorld();
			if (contents != null)
			{
				contents.OnMovedToWorld();
			}
		}
	}

	public void OnMovedToWorld()
	{
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].OnMovedToWorld(this);
		}
	}

	public BaseEntity GetWorldEntity()
	{
		return worldEnt.Get(isServer);
	}

	public void SetHeldEntity(BaseEntity ent)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (!ent.IsValid())
		{
			this.heldEntity.Set(null);
			MarkDirty();
		}
		else
		{
			if (this.heldEntity.uid == ent.net.ID)
			{
				return;
			}
			this.heldEntity.Set(ent);
			MarkDirty();
			if (ent.IsValid())
			{
				HeldEntity heldEntity = ent as HeldEntity;
				if ((Object)(object)heldEntity != (Object)null)
				{
					heldEntity.SetupHeldEntity(this);
				}
			}
		}
	}

	public BaseEntity GetHeldEntity()
	{
		return heldEntity.Get(isServer);
	}

	public void OnCycle(float delta)
	{
		if (this.onCycle != null)
		{
			this.onCycle(this, delta);
		}
	}

	public void ServerCommand(string command, BasePlayer player)
	{
		HeldEntity heldEntity = GetHeldEntity() as HeldEntity;
		if ((Object)(object)heldEntity != (Object)null)
		{
			heldEntity.ServerCommand(this, command, player);
		}
		ItemMod[] itemMods = info.itemMods;
		for (int i = 0; i < itemMods.Length; i++)
		{
			itemMods[i].ServerCommand(this, command, player);
		}
	}

	public void UseItem(int amountToConsume = 1)
	{
		if (amountToConsume > 0)
		{
			object obj = Interface.CallHook("OnItemUse", (object)this, (object)amountToConsume);
			if (obj is int)
			{
				amountToConsume = (int)obj;
			}
			amount -= amountToConsume;
			ReduceItemOwnership(amountToConsume);
			if (amount <= 0)
			{
				amount = 0;
				Remove();
			}
			else
			{
				MarkDirty();
			}
		}
	}

	public bool HasAmmo(AmmoTypes ammoType)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		ItemModProjectile itemModProjectile = default(ItemModProjectile);
		if (((Component)info).TryGetComponent<ItemModProjectile>(ref itemModProjectile) && itemModProjectile.IsAmmo(ammoType))
		{
			return true;
		}
		if (contents != null)
		{
			ItemModContainer itemModContainer = default(ItemModContainer);
			if ((Object)(object)info != (Object)null && ((Component)info).TryGetComponent<ItemModContainer>(ref itemModContainer) && itemModContainer.blockAmmoSource)
			{
				return false;
			}
			return contents.HasAmmo(ammoType);
		}
		return false;
	}

	public Item FindAmmo(AmmoTypes ammoType)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		ItemModProjectile itemModProjectile = default(ItemModProjectile);
		if (((Component)info).TryGetComponent<ItemModProjectile>(ref itemModProjectile) && itemModProjectile.IsAmmo(ammoType))
		{
			return this;
		}
		if (contents != null)
		{
			return contents.FindAmmo(ammoType);
		}
		return null;
	}

	public void FindAmmo(List<Item> list, AmmoTypes ammoType)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		ItemModProjectile itemModProjectile = default(ItemModProjectile);
		if (((Component)info).TryGetComponent<ItemModProjectile>(ref itemModProjectile) && itemModProjectile.IsAmmo(ammoType))
		{
			list.Add(this);
		}
		else if (contents != null)
		{
			contents.FindAmmo(list, ammoType);
		}
	}

	public int GetAmmoAmount(AmmoTypes ammoType)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		ItemModProjectile itemModProjectile = default(ItemModProjectile);
		if (((Component)info).TryGetComponent<ItemModProjectile>(ref itemModProjectile) && itemModProjectile.IsAmmo(ammoType))
		{
			num += amount;
		}
		if (contents != null)
		{
			num += contents.GetAmmoAmount(ammoType);
		}
		return num;
	}

	public int GetAmmoAmount(List<AmmoTypes> ammoTypes)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		ItemModProjectile itemModProjectile = default(ItemModProjectile);
		if (((Component)info).TryGetComponent<ItemModProjectile>(ref itemModProjectile))
		{
			foreach (AmmoTypes ammoType in ammoTypes)
			{
				if (itemModProjectile.IsAmmo(ammoType))
				{
					num += amount;
				}
			}
		}
		if (contents != null)
		{
			foreach (AmmoTypes ammoType2 in ammoTypes)
			{
				num += contents.GetAmmoAmount(ammoType2);
			}
		}
		return num;
	}

	public override string ToString()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		string[] obj = new string[6]
		{
			"Item.",
			info.shortname,
			"x",
			amount.ToString(),
			".",
			null
		};
		ItemId val = uid;
		obj[5] = ((object)(ItemId)(ref val)/*cast due to .constrained prefix*/).ToString();
		return string.Concat(obj);
	}

	public Item FindItem(ItemId iUID)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (uid == iUID)
		{
			return this;
		}
		if (contents == null)
		{
			return null;
		}
		return contents.FindItemByUID(iUID);
	}

	public int MaxStackable()
	{
		int num = info.stackable;
		if (parent != null && parent.maxStackSize > 0)
		{
			num = Mathf.Min(parent.maxStackSize, num);
		}
		object obj = Interface.CallHook("OnMaxStackable", (object)this);
		if (obj is int)
		{
			return (int)obj;
		}
		return num;
	}

	private void SetRadioactivity(ItemDefinition template)
	{
		if (!((Object)(object)template == (Object)null))
		{
			radioactivity = template.baseRadioactivity;
			if (radioactivity > 0f)
			{
				SetFlag(Flag.Radioactive, b: true);
			}
		}
	}

	public GameObjectRef GetWorldModel()
	{
		return info.GetWorldModel(amount);
	}

	public virtual Item Save(bool bIncludeContainer = false, bool bIncludeOwners = true)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		dirty = false;
		Item val = Pool.Get<Item>();
		val.UID = uid;
		val.itemid = info.itemid;
		val.slot = position;
		val.amount = amount;
		val.flags = (int)flags;
		val.removetime = removeTime;
		val.locktime = busyTime;
		val.instanceData = instanceData;
		val.worldEntity = worldEnt.uid;
		val.heldEntity = heldEntity.uid;
		val.skinid = skin;
		val.name = name;
		val.streamerName = streamerName;
		val.text = text;
		val.cooktime = cookTimeLeft;
		if (ownershipShares != null)
		{
			val.ownership = Pool.Get<List<ItemOwnershipAmount>>();
			foreach (ItemOwnershipShare ownershipShare in ownershipShares)
			{
				ItemOwnershipAmount val2 = Pool.Get<ItemOwnershipAmount>();
				val2.username = ownershipShare.username;
				val2.reason = ownershipShare.reason;
				val2.amount = ownershipShare.amount;
				val.ownership.Add(val2);
			}
		}
		val.ammoCount = 0;
		NetworkableId val3 = heldEntity.uid;
		if (((NetworkableId)(ref val3)).IsValid)
		{
			BaseEntity baseEntity = GetHeldEntity();
			if (baseEntity is BaseProjectile baseProjectile)
			{
				val.ammoCount = baseProjectile.primaryMagazine.contents + 1;
			}
			else if (baseEntity is Chainsaw chainsaw)
			{
				val.ammoCount = chainsaw.ammo + 1;
			}
			else if (baseEntity is FlameThrower flameThrower)
			{
				val.ammoCount = flameThrower.ammo + 1;
			}
		}
		if (hasCondition)
		{
			val.conditionData = Pool.Get<ConditionData>();
			val.conditionData.maxCondition = _maxCondition;
			val.conditionData.condition = _condition;
		}
		if (contents != null && bIncludeContainer)
		{
			val.contents = contents.Save(bIncludeContainer);
		}
		return val;
	}

	public virtual void Load(Item load)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)info == (Object)null || info.itemid != load.itemid)
		{
			info = ItemManager.FindItemDefinition(load.itemid);
		}
		if ((Object)(object)info == (Object)null)
		{
			Debug.LogError((object)$"Load invalid item id {load.itemid} from item {load.UID} (no ItemDefinition found)");
			return;
		}
		uid = load.UID;
		name = load.name;
		streamerName = load.streamerName;
		text = load.text;
		cookTimeLeft = load.cooktime;
		amount = load.amount;
		position = load.slot;
		busyTime = load.locktime;
		removeTime = load.removetime;
		flags = (Flag)load.flags;
		worldEnt.uid = load.worldEntity;
		heldEntity.uid = load.heldEntity;
		if (load.ownership != null && load.ownership.Count > 0)
		{
			if (ownershipShares == null)
			{
				ownershipShares = Pool.Get<List<ItemOwnershipShare>>();
			}
			else
			{
				ownershipShares.Clear();
			}
			foreach (ItemOwnershipAmount item2 in load.ownership)
			{
				ItemOwnershipShare itemOwnershipShare = default(ItemOwnershipShare);
				itemOwnershipShare.username = item2.username;
				itemOwnershipShare.reason = item2.reason;
				itemOwnershipShare.amount = item2.amount;
				ItemOwnershipShare item = itemOwnershipShare;
				ownershipShares.Add(item);
			}
		}
		else if (ownershipShares != null)
		{
			Pool.FreeUnmanaged<ItemOwnershipShare>(ref ownershipShares);
		}
		SetRadioactivity(info);
		InitializeItemOwnership();
		if (isServer)
		{
			Net.sv.RegisterUID(uid.Value);
		}
		if (instanceData != null)
		{
			instanceData.ShouldPool = true;
			instanceData.ResetToPool();
			instanceData = null;
		}
		instanceData = load.instanceData;
		if (instanceData != null)
		{
			instanceData.ShouldPool = false;
		}
		skin = load.skinid;
		_condition = 0f;
		_maxCondition = 0f;
		if (load.conditionData != null)
		{
			_condition = load.conditionData.condition;
			_maxCondition = load.conditionData.maxCondition;
		}
		else if (info.condition.enabled)
		{
			_condition = info.condition.max;
			_maxCondition = info.condition.max;
		}
		if (load.contents != null)
		{
			if (contents == null)
			{
				contents = Pool.Get<ItemContainer>();
				if (isServer)
				{
					contents.ServerInitialize(this, load.contents.slots);
				}
			}
			contents.Load(load.contents);
		}
		if (isServer)
		{
			removeTime = 0f;
			OnItemCreated();
		}
	}
}


using System;

[Flags]
public enum Flag
{
	None = 0,
	Placeholder = 1,
	IsOn = 2,
	OnFire = 4,
	IsLocked = 8,
	Cooking = 0x10,
	Radioactive = 0x20,
	Refrigerated = 0x40
}


public interface IItemUpdate
{
	void OnItemUpdate(Item item);
}


public interface IItemSetup
{
	void OnItemSetup(Item item);
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public sealed class ItemContainer : IAmmoContainer, IPooled
{
	[Flags]
	public enum Flag
	{
		IsPlayer = 1,
		Clothing = 2,
		Belt = 4,
		SingleType = 8,
		IsLocked = 0x10,
		ShowSlotsOnIcon = 0x20,
		NoBrokenItems = 0x40,
		NoItemInput = 0x80,
		ContentsHidden = 0x100,
		IsArmor = 0x200
	}

	[Flags]
	public enum ContentsType
	{
		Generic = 1,
		Liquid = 2
	}

	public enum LimitStack
	{
		None,
		Existing,
		All
	}

	public enum CanAcceptResult
	{
		CanAccept,
		CannotAccept,
		CannotAcceptRightNow
	}

	public const int BackpackSlotIndex = 7;

	public Flag flags;

	public ContentsType allowedContents;

	public ItemDefinition[] onlyAllowedItems;

	public HashSet<ItemDefinition> blockedItems;

	public List<ItemSlot> availableSlots = new List<ItemSlot>();

	public int capacity = 2;

	public ItemContainerId uid;

	public bool dirty;

	public List<Item> itemList = new List<Item>();

	public float temperature = 15f;

	public Item parent;

	public BasePlayer playerOwner;

	public BaseEntity entityOwner;

	public bool isServer;

	public int maxStackSize;

	public int containerVolume;

	public Func<Item, int, bool> canAcceptItem;

	public Func<Item, int, bool> slotIsReserved;

	public Action<Item, bool> onItemAddedRemoved;

	public Action<Item, int, int> onItemPositionChanged;

	public Action<Item, bool> onItemContentsChanged;

	public Action<Item, int> onItemAddedToStack;

	public Action<Item, int> onItemRemovedFromStack;

	public Action<Item> onPreItemRemove;

	public Action<Item, float> onItemRadiationChanged;

	public Action<Item, Item> onItemParentChanged;

	public bool HasAvailableSlotsDefined => !availableSlots.IsEmpty();

	public bool HasLimitedAllowedItems
	{
		get
		{
			if (onlyAllowedItems != null)
			{
				return onlyAllowedItems.Length != 0;
			}
			return false;
		}
	}

	public Vector3 dropPosition
	{
		get
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)playerOwner))
			{
				return playerOwner.GetDropPosition();
			}
			if (Object.op_Implicit((Object)(object)entityOwner))
			{
				return entityOwner.GetDropPosition();
			}
			if (parent != null)
			{
				BaseEntity worldEntity = parent.GetWorldEntity();
				if ((Object)(object)worldEntity != (Object)null)
				{
					return worldEntity.GetDropPosition();
				}
			}
			Debug.LogWarning((object)"ItemContainer.dropPosition dropped through");
			return Vector3.zero;
		}
	}

	public Vector3 dropVelocity
	{
		get
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)playerOwner))
			{
				return playerOwner.GetDropVelocity();
			}
			if (Object.op_Implicit((Object)(object)entityOwner))
			{
				return entityOwner.GetDropVelocity();
			}
			if (parent != null)
			{
				BaseEntity worldEntity = parent.GetWorldEntity();
				if ((Object)(object)worldEntity != (Object)null)
				{
					return worldEntity.GetDropVelocity();
				}
			}
			Debug.LogWarning((object)"ItemContainer.dropVelocity dropped through");
			return Vector3.zero;
		}
	}

	public event Action onDirty;

	public void UpdateAvailableSlots(List<ItemSlot> newSlots)
	{
		availableSlots.Clear();
		if (newSlots != null)
		{
			availableSlots.AddRange(newSlots);
		}
	}

	public bool HasFlag(Flag f)
	{
		return (flags & f) == f;
	}

	public void SetFlag(Flag f, bool b)
	{
		if (b)
		{
			flags |= f;
		}
		else
		{
			flags &= ~f;
		}
	}

	public bool IsLocked()
	{
		return HasFlag(Flag.IsLocked);
	}

	public bool PlayerItemInputBlocked()
	{
		return HasFlag(Flag.NoItemInput);
	}

	void IPooled.EnterPool()
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		flags = (Flag)0;
		allowedContents = (ContentsType)0;
		onlyAllowedItems = null;
		blockedItems = null;
		availableSlots.Clear();
		capacity = 2;
		if (((ItemContainerId)(ref uid)).IsValid && Net.sv != null)
		{
			Net.sv.ReturnUID(uid.Value);
		}
		uid = default(ItemContainerId);
		temperature = 15f;
		parent = null;
		playerOwner = null;
		entityOwner = null;
		isServer = false;
		maxStackSize = 0;
		containerVolume = 0;
		this.onDirty = null;
		canAcceptItem = null;
		slotIsReserved = null;
		onItemAddedRemoved = null;
		onItemContentsChanged = null;
		onItemAddedToStack = null;
		onItemRemovedFromStack = null;
		onPreItemRemove = null;
		onItemRadiationChanged = null;
		onItemParentChanged = null;
		Clear();
		dirty = false;
	}

	void IPooled.LeavePool()
	{
	}

	public float GetTemperature(int slot)
	{
		if (entityOwner is BaseOven baseOven)
		{
			return baseOven.GetTemperature(slot);
		}
		return temperature;
	}

	public void ServerInitialize(Item parentItem, int iMaxCapacity)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		parent = parentItem;
		capacity = iMaxCapacity;
		uid = default(ItemContainerId);
		isServer = true;
		if (allowedContents == (ContentsType)0)
		{
			allowedContents = ContentsType.Generic;
		}
		onItemRadiationChanged = (Action<Item, float>)Delegate.Combine(onItemRadiationChanged, new Action<Item, float>(BubbleUpRadiationChanged));
		MarkDirty();
	}

	public void GiveUID()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsTrue(!((ItemContainerId)(ref uid)).IsValid, "Calling GiveUID - but already has a uid!");
		uid = new ItemContainerId(Net.sv.TakeUID());
	}

	public void MarkDirty()
	{
		dirty = true;
		parent?.MarkDirty();
		this.onDirty?.Invoke();
	}

	public DroppedItemContainer Drop(string prefab, Vector3 pos, Quaternion rot, float destroyPercent)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (itemList == null || itemList.Count == 0)
		{
			return null;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefab, pos, rot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		DroppedItemContainer droppedItemContainer = baseEntity as DroppedItemContainer;
		if ((Object)(object)droppedItemContainer != (Object)null)
		{
			droppedItemContainer.TakeFrom(new ItemContainer[1] { this }, destroyPercent);
		}
		droppedItemContainer.Spawn();
		return droppedItemContainer;
	}

	public static DroppedItemContainer Drop(string prefab, Vector3 pos, Quaternion rot, params ItemContainer[] containers)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		foreach (ItemContainer itemContainer in containers)
		{
			num += ((itemContainer.itemList != null) ? itemContainer.itemList.Count : 0);
		}
		if (num == 0)
		{
			return null;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefab, pos, rot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		DroppedItemContainer droppedItemContainer = baseEntity as DroppedItemContainer;
		if ((Object)(object)droppedItemContainer != (Object)null)
		{
			droppedItemContainer.TakeFrom(containers, 0f);
		}
		droppedItemContainer.Spawn();
		return droppedItemContainer;
	}

	public BaseEntity GetEntityOwner(bool returnHeldEntity = false)
	{
		ItemContainer itemContainer = this;
		for (int i = 0; i < 10; i++)
		{
			if ((Object)(object)itemContainer.entityOwner != (Object)null)
			{
				return itemContainer.entityOwner;
			}
			if ((Object)(object)itemContainer.playerOwner != (Object)null)
			{
				return itemContainer.playerOwner;
			}
			if (returnHeldEntity)
			{
				BaseEntity baseEntity = itemContainer.parent?.GetHeldEntity();
				if ((Object)(object)baseEntity != (Object)null)
				{
					return baseEntity;
				}
			}
			ItemContainer itemContainer2 = itemContainer.parent?.parent;
			if (itemContainer2 == null || itemContainer2 == itemContainer)
			{
				return null;
			}
			itemContainer = itemContainer2;
		}
		return null;
	}

	public void OnChanged()
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			itemList[i].OnChanged();
		}
	}

	public Item FindItemByUID(ItemId iUID)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < itemList.Count; i++)
		{
			Item item = itemList[i];
			if (item.IsValid())
			{
				Item item2 = item.FindItem(iUID);
				if (item2 != null)
				{
					return item2;
				}
			}
		}
		return null;
	}

	public bool IsFull(bool checkForPartialStacks = false)
	{
		if (!checkForPartialStacks)
		{
			return itemList.Count >= capacity;
		}
		if (itemList.Count < capacity)
		{
			return false;
		}
		foreach (Item item in itemList)
		{
			if (item.IsValid() && item.amount < item.MaxStackable())
			{
				return false;
			}
		}
		return true;
	}

	public bool HasSpaceFor(Item item)
	{
		if (!IsFull())
		{
			return true;
		}
		return HasPartialStack(item);
	}

	public bool IsEmpty()
	{
		return itemList.Count == 0;
	}

	public bool HasPartialStack(Item toStack, out int slot)
	{
		slot = -1;
		foreach (Item item in itemList)
		{
			if (item.info.itemid == toStack.info.itemid && item.amount < item.MaxStackable() && toStack.CanStack(item))
			{
				slot = item.position;
				return true;
			}
		}
		return false;
	}

	public float GetRadioactiveMaterialInContainer()
	{
		float num = 0f;
		foreach (Item item in itemList)
		{
			num += item.radioactivity;
		}
		return num;
	}

	public bool HasPartialStack(Item toStack)
	{
		int slot;
		return HasPartialStack(toStack, out slot);
	}

	public bool CanAccept(Item item)
	{
		if (IsFull())
		{
			return false;
		}
		return true;
	}

	public int GetMaxTransferAmount(ItemDefinition def)
	{
		int num = ContainerMaxStackSize();
		foreach (Item item in itemList)
		{
			if ((Object)(object)item.info == (Object)(object)def)
			{
				num -= item.amount;
				if (num <= 0)
				{
					return 0;
				}
			}
		}
		return num;
	}

	public void SetOnlyAllowedItem(ItemDefinition def)
	{
		SetOnlyAllowedItems(def);
	}

	public void SetOnlyAllowedItems(ItemDefinition[] baseItems, params ItemDefinition[] additionalItems)
	{
		onlyAllowedItems = (from item in baseItems.Concat(additionalItems)
			where (Object)(object)item != (Object)null
			select item).ToArray();
	}

	public void SetOnlyAllowedItems(params ItemDefinition[] defs)
	{
		int num = 0;
		ItemDefinition[] array = defs;
		for (int i = 0; i < array.Length; i++)
		{
			if ((Object)(object)array[i] != (Object)null)
			{
				num++;
			}
		}
		onlyAllowedItems = new ItemDefinition[num];
		int num2 = 0;
		array = defs;
		foreach (ItemDefinition itemDefinition in array)
		{
			if ((Object)(object)itemDefinition != (Object)null)
			{
				onlyAllowedItems[num2] = itemDefinition;
				num2++;
			}
		}
	}

	public void SetBlacklist(ItemDefinition[] defs)
	{
		if (defs != null && defs.Length != 0)
		{
			blockedItems = new HashSet<ItemDefinition>(defs);
		}
	}

	public bool Insert(Item item)
	{
		if (itemList.Contains(item))
		{
			return false;
		}
		if (IsFull())
		{
			return false;
		}
		itemList.Add(item);
		item.parent = this;
		if (!FindPosition(item))
		{
			return false;
		}
		MarkDirty();
		if (onItemAddedRemoved != null)
		{
			onItemAddedRemoved(item, arg2: true);
		}
		ItemContainer itemContainer = parent?.parent;
		if (itemContainer != null && itemContainer.onItemContentsChanged != null)
		{
			itemContainer.onItemContentsChanged(item, arg2: true);
		}
		Interface.CallHook("OnItemAddedToContainer", (object)this, (object)item);
		return true;
	}

	public bool SlotTaken(Item item, int i)
	{
		if (slotIsReserved != null && slotIsReserved(item, i))
		{
			return true;
		}
		return GetSlot(i) != null;
	}

	public Item GetSlot(int slot)
	{
		if (slot == -1)
		{
			return null;
		}
		_ = itemList.Count;
		foreach (Item item in itemList)
		{
			if (item.position == slot)
			{
				return item;
			}
		}
		return null;
	}

	public bool QuickIndustrialPreCheck(Item toTransfer, Vector2i range, int fakeSlots, out int foundSlot)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		int num = range.y - range.x + 1;
		int count = itemList.Count;
		int num2 = 0;
		foundSlot = -1;
		for (int i = 0; i < count; i++)
		{
			Item item = itemList[i];
			int position = item.position;
			if (position < range.x || position > range.y)
			{
				continue;
			}
			num2++;
			if (item.amount >= item.info.stackable || item.IsRemoved())
			{
				continue;
			}
			if (toTransfer.IsBlueprint())
			{
				if (item.blueprintTarget != toTransfer.blueprintTarget)
				{
					continue;
				}
			}
			else if ((Object)(object)item.info != (Object)(object)toTransfer.info)
			{
				continue;
			}
			if (item.instanceData == null || item.CanStack(toTransfer))
			{
				foundSlot = position;
				return true;
			}
		}
		return num2 + fakeSlots < num;
	}

	public bool FindPosition(Item item)
	{
		int position = item.position;
		item.position = -1;
		if (position >= 0 && !SlotTaken(item, position))
		{
			item.position = position;
			return true;
		}
		for (int i = 0; i < capacity; i++)
		{
			if (!SlotTaken(item, i))
			{
				item.position = i;
				return true;
			}
		}
		return false;
	}

	public bool HasItem(ItemDefinition searchFor)
	{
		if ((Object)(object)searchFor == (Object)null)
		{
			return false;
		}
		foreach (Item item in itemList)
		{
			if (item != null && (Object)(object)item.info == (Object)(object)searchFor)
			{
				return true;
			}
		}
		return false;
	}

	public void SetLocked(bool isLocked, bool lockSubItems = false)
	{
		SetFlag(Flag.IsLocked, isLocked);
		if (lockSubItems)
		{
			SetSubItemsLocked(isLocked);
		}
		MarkDirty();
	}

	private void SetSubItemsLocked(bool isLocked)
	{
		if (itemList == null)
		{
			return;
		}
		foreach (Item item in itemList)
		{
			if (item != null && item.contents != null)
			{
				item.contents.SetLocked(isLocked);
			}
		}
	}

	public bool Remove(Item item)
	{
		if (!itemList.Contains(item))
		{
			return false;
		}
		onPreItemRemove?.Invoke(item);
		itemList.Remove(item);
		item.parent = null;
		onItemParentChanged?.Invoke(parent, item);
		onItemAddedRemoved?.Invoke(item, arg2: false);
		ItemContainer itemContainer = parent?.parent;
		if (itemContainer != null && itemContainer.onItemContentsChanged != null)
		{
			itemContainer.onItemContentsChanged(item, arg2: false);
		}
		MarkDirty();
		Interface.CallHook("OnItemRemovedFromContainer", (object)this, (object)item);
		return true;
	}

	public void Clear()
	{
		if (itemList.Count == 0)
		{
			return;
		}
		foreach (Item item in itemList)
		{
			onPreItemRemove?.Invoke(item);
			item.parent = null;
			item.Remove();
			onItemAddedRemoved?.Invoke(item, arg2: false);
			ItemContainer itemContainer = parent?.parent;
			if (itemContainer != null && itemContainer.onItemContentsChanged != null)
			{
				itemContainer.onItemContentsChanged(item, arg2: false);
			}
		}
		itemList.Clear();
		MarkDirty();
	}

	public void Kill()
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		parent = null;
		this.onDirty = null;
		canAcceptItem = null;
		slotIsReserved = null;
		onItemAddedRemoved = null;
		onItemContentsChanged = null;
		onPreItemRemove = null;
		if (((ItemContainerId)(ref uid)).IsValid && Net.sv != null)
		{
			Net.sv.ReturnUID(uid.Value);
			uid = default(ItemContainerId);
		}
		Clear();
	}

	public int GetAmount(int itemid, bool onlyUsableAmounts)
	{
		int num = 0;
		foreach (Item item in itemList)
		{
			if (item.info.itemid == itemid && (!onlyUsableAmounts || !item.IsBusy()))
			{
				num += item.amount;
			}
		}
		return num;
	}

	public int GetAmount(int blueprintBaseId, int itemId, bool onlyUsableAmounts)
	{
		int num = 0;
		foreach (Item item in itemList)
		{
			if (item.info.itemid == blueprintBaseId && item.blueprintTarget == itemId && (!onlyUsableAmounts || !item.IsBusy()))
			{
				num += item.amount;
			}
		}
		return num;
	}

	public int GetOkConditionAmount(int itemid, bool onlyUsableAmounts)
	{
		int num = 0;
		foreach (Item item in itemList)
		{
			if (item.info.itemid == itemid && (!onlyUsableAmounts || !item.IsBusy()) && !(item.condition <= 0f))
			{
				num += item.amount;
			}
		}
		return num;
	}

	public Item FindItemByItemID(int itemid)
	{
		foreach (Item item in itemList)
		{
			if (item.info.itemid == itemid)
			{
				return item;
			}
		}
		return null;
	}

	public Item FindItemByItemName(string name)
	{
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(name);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return null;
		}
		for (int i = 0; i < itemList.Count; i++)
		{
			if ((Object)(object)itemList[i].info == (Object)(object)itemDefinition)
			{
				return itemList[i];
			}
		}
		return null;
	}

	public Item FindBySubEntityID(NetworkableId subEntityID)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (!((NetworkableId)(ref subEntityID)).IsValid)
		{
			return null;
		}
		foreach (Item item in itemList)
		{
			if (item.instanceData != null && item.instanceData.subEntity == subEntityID)
			{
				return item;
			}
		}
		return null;
	}

	public List<Item> FindItemsByItemID(int itemid)
	{
		return itemList.FindAll((Item x) => x.info.itemid == itemid);
	}

	public void FindItemsByItemID(int itemId, BufferList<Item> found)
	{
		found.Clear();
		foreach (Item item in itemList)
		{
			if (item.info.itemid == itemId)
			{
				found.Add(item);
			}
		}
	}

	public ItemContainer Save(bool bIncludeContainer = true)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		ItemContainer val = Pool.Get<ItemContainer>();
		val.contents = Pool.Get<List<Item>>();
		val.UID = uid;
		val.slots = capacity;
		val.temperature = temperature;
		val.allowedContents = (int)allowedContents;
		if (HasLimitedAllowedItems)
		{
			val.allowedItems = Pool.Get<List<int>>();
			for (int i = 0; i < onlyAllowedItems.Length; i++)
			{
				if ((Object)(object)onlyAllowedItems[i] != (Object)null)
				{
					val.allowedItems.Add(onlyAllowedItems[i].itemid);
				}
			}
		}
		val.flags = (int)flags;
		val.maxStackSize = maxStackSize;
		val.volume = containerVolume;
		if (availableSlots != null && availableSlots.Count > 0)
		{
			val.availableSlots = Pool.Get<List<int>>();
			for (int j = 0; j < availableSlots.Count; j++)
			{
				val.availableSlots.Add((int)availableSlots[j]);
			}
		}
		for (int k = 0; k < itemList.Count; k++)
		{
			Item item = itemList[k];
			if (item.IsValid())
			{
				val.contents.Add(item.Save(bIncludeContainer));
			}
		}
		return val;
	}

	public void Load(ItemContainer container)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("ItemContainer.Load", 0);
		try
		{
			uid = container.UID;
			capacity = container.slots;
			List<Item> list = itemList;
			itemList = Pool.Get<List<Item>>();
			temperature = container.temperature;
			flags = (Flag)container.flags;
			allowedContents = ((container.allowedContents == 0) ? ContentsType.Generic : ((ContentsType)container.allowedContents));
			if (container.allowedItems != null && container.allowedItems.Count > 0)
			{
				onlyAllowedItems = new ItemDefinition[container.allowedItems.Count];
				for (int i = 0; i < container.allowedItems.Count; i++)
				{
					onlyAllowedItems[i] = ItemManager.FindItemDefinition(container.allowedItems[i]);
				}
			}
			else
			{
				onlyAllowedItems = null;
			}
			maxStackSize = container.maxStackSize;
			containerVolume = container.volume;
			availableSlots.Clear();
			if (container.availableSlots != null)
			{
				for (int j = 0; j < container.availableSlots.Count; j++)
				{
					availableSlots.Add((ItemSlot)container.availableSlots[j]);
				}
			}
			TimeWarning val2 = TimeWarning.New("container.contents", 0);
			try
			{
				foreach (Item content in container.contents)
				{
					Item created = null;
					foreach (Item item in list)
					{
						if (item.uid == content.UID)
						{
							created = item;
							break;
						}
					}
					created = ItemManager.Load(content, created, isServer);
					if (created != null)
					{
						created.parent = this;
						created.position = content.slot;
						Insert(created);
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			val2 = TimeWarning.New("Delete old items", 0);
			try
			{
				foreach (Item item2 in list)
				{
					if (!itemList.Contains(item2))
					{
						item2.Remove();
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			dirty = true;
			Pool.Free<Item>(ref list, false);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public BasePlayer GetOwnerPlayer()
	{
		return playerOwner;
	}

	public int ContainerMaxStackSize()
	{
		if (maxStackSize <= 0)
		{
			return int.MaxValue;
		}
		return maxStackSize;
	}

	public int Take(List<Item> collect, int itemid, int iAmount, bool takeBroken = true)
	{
		int num = 0;
		if (iAmount == 0)
		{
			return num;
		}
		List<Item> list = Pool.Get<List<Item>>();
		foreach (Item item2 in itemList)
		{
			if (item2.info.itemid != itemid || (!takeBroken && item2.info.condition.enabled && item2.condition <= 0f))
			{
				continue;
			}
			int num2 = iAmount - num;
			if (num2 <= 0)
			{
				continue;
			}
			if (item2.amount > num2)
			{
				num += num2;
				Item item = item2.SplitItem(num2);
				if (item != null)
				{
					item.CollectedForCrafting(playerOwner);
					collect?.Add(item);
				}
				break;
			}
			if (item2.amount <= num2)
			{
				num += item2.amount;
				list.Add(item2);
				collect?.Add(item2);
			}
			if (num == iAmount)
			{
				break;
			}
		}
		foreach (Item item3 in list)
		{
			item3.RemoveFromContainer();
		}
		Pool.Free<Item>(ref list, false);
		return num;
	}

	public bool TryTakeOne(int itemid, out Item item)
	{
		item = null;
		foreach (Item item3 in itemList)
		{
			if (item3.info.itemid == itemid)
			{
				if (item3.amount > 1)
				{
					item3.MarkDirty();
					item3.amount--;
					Item item2 = ItemManager.CreateByItemID(itemid, 1, 0uL);
					item2.amount = 1;
					item2.CollectedForCrafting(playerOwner);
					item = item2;
				}
				else
				{
					item = item3;
				}
				break;
			}
		}
		if (item != null)
		{
			item.RemoveFromContainer();
			return true;
		}
		return false;
	}

	public bool GiveItem(Item item, ItemContainer container = null)
	{
		if (item == null)
		{
			return false;
		}
		if (container != null && item.MoveToContainer(container))
		{
			return true;
		}
		return item.MoveToContainer(this);
	}

	public void OnCycle(float delta)
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			if (itemList[i].IsValid())
			{
				itemList[i].OnCycle(delta);
			}
		}
	}

	public Item FindAmmo(AmmoTypes ammoType)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < itemList.Count; i++)
		{
			Item item = itemList[i].FindAmmo(ammoType);
			if (item != null)
			{
				return item;
			}
		}
		return null;
	}

	public void FindAmmo(List<Item> list, AmmoTypes ammoType)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < itemList.Count; i++)
		{
			itemList[i].FindAmmo(list, ammoType);
		}
	}

	public bool HasAmmo(AmmoTypes ammoType)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < itemList.Count; i++)
		{
			if (itemList[i].HasAmmo(ammoType))
			{
				return true;
			}
		}
		return false;
	}

	public int GetAmmoAmount(ItemDefinition specificAmmo)
	{
		int num = 0;
		for (int i = 0; i < itemList.Count; i++)
		{
			num += (((Object)(object)itemList[i].info == (Object)(object)specificAmmo) ? itemList[i].amount : 0);
		}
		return num;
	}

	public int GetAmmoAmount(AmmoTypes ammoType)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		for (int i = 0; i < itemList.Count; i++)
		{
			num += itemList[i].GetAmmoAmount(ammoType);
		}
		return num;
	}

	public int TotalItemAmount()
	{
		int num = 0;
		for (int i = 0; i < itemList.Count; i++)
		{
			num += itemList[i].amount;
		}
		return num;
	}

	public bool HasAny(ItemDefinition itemDef)
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			Item item = itemList[i];
			if ((Object)(object)item.info == (Object)(object)itemDef && item.amount > 0)
			{
				return true;
			}
		}
		return false;
	}

	public bool HasAnyWithSpace(ItemDefinition itemDef)
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			Item item = itemList[i];
			if ((Object)(object)item.info == (Object)(object)itemDef && item.amount > 0 && item.amount < item.info.stackable)
			{
				return true;
			}
		}
		return false;
	}

	public int GetTotalItemAmount(Item item, int slotStartInclusive, int slotEndInclusive)
	{
		int num = 0;
		for (int i = slotStartInclusive; i <= slotEndInclusive; i++)
		{
			Item slot = GetSlot(i);
			if (slot == null)
			{
				continue;
			}
			if (item.IsBlueprint())
			{
				if (slot.IsBlueprint() && slot.blueprintTarget == item.blueprintTarget)
				{
					num += slot.amount;
				}
			}
			else if ((Object)(object)slot.info == (Object)(object)item.info || (Object)(object)slot.info.isRedirectOf == (Object)(object)item.info || (Object)(object)item.info.isRedirectOf == (Object)(object)slot.info)
			{
				num += slot.amount;
			}
			else if ((Object)(object)slot.info.isRedirectOf != (Object)null && (Object)(object)slot.info.isRedirectOf == (Object)(object)item.info.isRedirectOf)
			{
				num += slot.amount;
			}
		}
		return num;
	}

	public int TotalItemAmount(ItemDefinition itemDef)
	{
		int num = 0;
		for (int i = 0; i < itemList.Count; i++)
		{
			Item item = itemList[i];
			if ((Object)(object)item.info == (Object)(object)itemDef)
			{
				num += item.amount;
			}
		}
		return num;
	}

	public int GetTotalCategoryAmount(ItemCategory category, int slotStartInclusive, int slotEndInclusive)
	{
		int num = 0;
		for (int i = slotStartInclusive; i <= slotEndInclusive; i++)
		{
			Item slot = GetSlot(i);
			if (slot != null && slot.info.category == category)
			{
				num += slot.amount;
			}
		}
		return num;
	}

	public void AddItem(ItemDefinition itemToCreate, int amount, ulong skin = 0uL, LimitStack limitStack = LimitStack.Existing)
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			if (amount == 0)
			{
				return;
			}
			if ((Object)(object)itemList[i].info != (Object)(object)itemToCreate)
			{
				continue;
			}
			int num = itemList[i].MaxStackable();
			if (num <= itemList[i].amount && limitStack != 0)
			{
				continue;
			}
			MarkDirty();
			itemList[i].amount += amount;
			amount -= amount;
			if (itemList[i].amount > num && limitStack != 0)
			{
				amount = itemList[i].amount - num;
				if (amount > 0)
				{
					itemList[i].amount -= amount;
				}
			}
		}
		if (amount == 0)
		{
			return;
		}
		int num2 = ((limitStack == LimitStack.All) ? Mathf.Min(itemToCreate.stackable, ContainerMaxStackSize()) : int.MaxValue);
		if (num2 <= 0)
		{
			return;
		}
		while (amount > 0)
		{
			int num3 = Mathf.Min(amount, num2);
			Item item = ItemManager.Create(itemToCreate, num3, skin);
			amount -= num3;
			if (!item.MoveToContainer(this))
			{
				item.Remove();
			}
		}
	}

	public void MoveAllItems(ItemContainer target)
	{
		for (int num = itemList.Count - 1; num >= 0; num--)
		{
			itemList[num].MoveToContainer(target);
		}
	}

	public void RemoveFractionOfContainer(List<Item> removedItems, float removeFraction)
	{
		removeFraction = Mathf.Clamp01(removeFraction);
		if (itemList.Count == 0 || removeFraction == 0f)
		{
			return;
		}
		List<Item> list = Pool.Get<List<Item>>();
		Dictionary<ItemDefinition, float> dictionary = Pool.Get<Dictionary<ItemDefinition, float>>();
		for (int num = itemList.Count - 1; num >= 0; num--)
		{
			Item item = itemList[num];
			if (item.amount == 1)
			{
				list.Add(item);
			}
			else
			{
				float num2 = (float)item.amount * removeFraction;
				int num3 = Mathf.FloorToInt(num2);
				float num4 = num2 - (float)num3;
				if (num4 > 0f)
				{
					if (!dictionary.TryGetValue(item.info, out var value))
					{
						float num5 = num4;
						if (Random.Range(0f, 1f) < num5)
						{
							num4 = -1f + num5;
							num3++;
						}
						else
						{
							num4 += removeFraction;
						}
						dictionary.Add(item.info, num4);
					}
					else
					{
						num4 += value;
						if (num4 > 1f)
						{
							num3++;
							num4 -= 1f;
						}
						dictionary[item.info] = num4;
					}
				}
				if (num3 > 0)
				{
					if (num3 == item.amount)
					{
						removedItems.Add(item);
						item.RemoveFromContainer();
					}
					else
					{
						removedItems.Add(item.SplitItem(num3));
					}
				}
			}
		}
		int num6 = Mathf.RoundToInt((float)list.Count * removeFraction);
		ListEx.Shuffle<Item>(list, (uint)Random.Range(0, 1000000000));
		for (int i = 0; i < num6; i++)
		{
			Item item2 = list[i];
			removedItems.Add(item2);
			item2.RemoveFromContainer();
		}
		Pool.FreeUnmanaged<Item>(ref list);
		Pool.FreeUnmanaged<ItemDefinition, float>(ref dictionary);
	}

	public void RemoveItemsFromContainer(List<Item> removedItems, string[] targetItems)
	{
		for (int num = itemList.Count - 1; num >= 0; num--)
		{
			Item item = itemList[num];
			foreach (string text in targetItems)
			{
				if (item.info.shortname == text)
				{
					item.RemoveFromContainer();
					removedItems.Add(item);
					break;
				}
			}
		}
	}

	public void MergeAllStacks()
	{
		List<Item> list = Pool.Get<List<Item>>();
		list.AddRange(itemList);
		foreach (Item item in list)
		{
			item.RemoveFromContainer();
		}
		foreach (Item item2 in list)
		{
			item2.MoveToContainer(this);
		}
		Pool.Free<Item>(ref list, false);
	}

	public void OnMovedToWorld()
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			itemList[i].OnMovedToWorld();
		}
	}

	public void OnRemovedFromWorld()
	{
		for (int i = 0; i < itemList.Count; i++)
		{
			itemList[i].OnRemovedFromWorld();
		}
	}

	public uint ContentsDeepHash(bool ignoreBackContents = false)
	{
		uint num = 0u;
		for (int i = 0; i < capacity; i++)
		{
			Item slot = GetSlot(i);
			if (slot == null)
			{
				continue;
			}
			num = CRC.Compute32(num, slot.info.itemid);
			num = CRC.Compute32(num, slot.skin);
			num = CRC.Compute32(num, slot.uid.Value);
			if ((slot.IsBackpack() && ignoreBackContents) || slot.contents == null)
			{
				continue;
			}
			for (int j = 0; j < slot.contents.capacity; j++)
			{
				if (slot.contents.GetSlot(j) != null)
				{
					num = CRC.Compute32(num, slot.info.itemid);
				}
			}
		}
		return num;
	}

	public ItemContainer FindContainer(ItemContainerId id)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (id == uid)
		{
			return this;
		}
		for (int i = 0; i < itemList.Count; i++)
		{
			Item item = itemList[i];
			if (item.contents != null)
			{
				ItemContainer itemContainer = item.contents.FindContainer(id);
				if (itemContainer != null)
				{
					return itemContainer;
				}
			}
		}
		return null;
	}

	public CanAcceptResult CanAcceptItem(Item item, int targetPos)
	{
		if (canAcceptItem != null && !canAcceptItem(item, targetPos))
		{
			return CanAcceptResult.CannotAccept;
		}
		if (isServer && availableSlots != null && availableSlots.Count > 0)
		{
			if (item.info.occupySlots == (ItemSlot)0 || item.info.occupySlots == ItemSlot.None)
			{
				return CanAcceptResult.CannotAccept;
			}
			if (item.isBroken)
			{
				return CanAcceptResult.CannotAccept;
			}
			int num = 0;
			foreach (ItemSlot availableSlot in availableSlots)
			{
				num |= (int)availableSlot;
			}
			if (((uint)num & (uint)item.info.occupySlots) != (uint)item.info.occupySlots)
			{
				return CanAcceptResult.CannotAcceptRightNow;
			}
		}
		if ((allowedContents & item.info.itemType) != item.info.itemType)
		{
			return CanAcceptResult.CannotAccept;
		}
		if (HasLimitedAllowedItems)
		{
			bool flag = false;
			for (int i = 0; i < onlyAllowedItems.Length; i++)
			{
				if ((Object)(object)onlyAllowedItems[i] == (Object)(object)item.info)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return CanAcceptResult.CannotAccept;
			}
		}
		object obj = Interface.CallHook("CanAcceptItem", (object)this, (object)item, (object)targetPos);
		if (obj is CanAcceptResult)
		{
			return (CanAcceptResult)obj;
		}
		if (blockedItems != null && blockedItems.Contains(item.info))
		{
			return CanAcceptResult.CannotAccept;
		}
		if (item.GetItemVolume() > containerVolume)
		{
			return CanAcceptResult.CannotAccept;
		}
		return CanAcceptResult.CanAccept;
	}

	public bool HasBackpackItem()
	{
		foreach (Item item in itemList)
		{
			if (!item.isBroken && item.IsBackpack())
			{
				return true;
			}
		}
		return false;
	}

	public void BubbleUpRadiationChanged(Item item, float amount)
	{
		if (parent != null && parent.parent != null)
		{
			parent?.parent?.onItemRadiationChanged?.Invoke(parent, 0f);
		}
	}
}


using System;

[Flags]
public enum Flag
{
	IsPlayer = 1,
	Clothing = 2,
	Belt = 4,
	SingleType = 8,
	IsLocked = 0x10,
	ShowSlotsOnIcon = 0x20,
	NoBrokenItems = 0x40,
	NoItemInput = 0x80,
	ContentsHidden = 0x100,
	IsArmor = 0x200
}


using System;

[Flags]
public enum ContentsType
{
	Generic = 1,
	Liquid = 2
}


public enum LimitStack
{
	None,
	Existing,
	All
}


public enum CanAcceptResult
{
	CanAccept,
	CannotAccept,
	CannotAcceptRightNow
}


using UnityEngine;

public class ItemCorpseOverride : MonoBehaviour
{
	public GameObjectRef MaleCorpse;

	public GameObjectRef FemaleCorpse;

	public bool BlockWearableCopy;
}


using System;
using System.Collections.Generic;
using ConVar;
using Rust;
using UnityEngine;

public class ItemBlueprint : MonoBehaviour
{
	[Serializable]
	public struct BlueprintOverride
	{
		public Era TargetEra;

		public List<ItemAmount> Ingredients;

		public float craftTime;

		public int workbenchLevel;

		public BlueprintOverride(ItemBlueprint bp)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			TargetEra = (Era)0;
			Ingredients = bp.ingredients;
			craftTime = bp.time;
			workbenchLevel = bp.workbenchLevelRequired;
		}
	}

	public List<ItemAmount> ingredients = new List<ItemAmount>();

	public List<ItemDefinition> additionalUnlocks = new List<ItemDefinition>();

	public bool defaultBlueprint;

	public bool userCraftable = true;

	public bool isResearchable = true;

	public bool forceShowInConveyorFilter;

	public Rarity rarity;

	[Header("Workbench")]
	public int workbenchLevelRequired;

	[Header("Scrap")]
	public int scrapRequired;

	public int scrapFromRecycle;

	[Tooltip("This item won't show anywhere unless you have the corresponding SteamItem in your inventory - which is defined on the ItemDefinition")]
	[Header("Unlocking")]
	public bool NeedsSteamItem;

	public ItemDefinition RequireUnlockedItem;

	public int blueprintStackSize = -1;

	public float time = 1f;

	public int amountToCreate = 1;

	public bool ForceThisCraftTime;

	public string UnlockAchievment;

	public string RecycleStat;

	public List<BlueprintOverride> Overrides = new List<BlueprintOverride>();

	public ItemDefinition targetItem => ((Component)this).GetComponent<ItemDefinition>();

	public bool NeedsSteamDLC => (Object)(object)targetItem.steamDlc != (Object)null;

	public List<ItemAmount> GetIngredients()
	{
		BlueprintOverride recipeOverride = GetRecipeOverride();
		if (recipeOverride.Ingredients != null && recipeOverride.Ingredients.Count > 0)
		{
			return recipeOverride.Ingredients;
		}
		return ingredients;
	}

	public float GetCraftTime()
	{
		float craftTime = time;
		float num = 5f;
		ItemDefinition itemDefinition = targetItem;
		if ((Object)(object)itemDefinition != (Object)null && (itemDefinition.stackable == 1 || itemDefinition.isHoldable || itemDefinition.isWearable || itemDefinition.isUsable || itemDefinition.category == ItemCategory.Construction || itemDefinition.category == ItemCategory.Traps))
		{
			num += (float)Mathf.Max(workbenchLevelRequired, 1) * 10f;
		}
		BlueprintOverride recipeOverride = GetRecipeOverride();
		if (recipeOverride.craftTime > 0f)
		{
			craftTime = recipeOverride.craftTime;
		}
		if (ForceThisCraftTime)
		{
			return craftTime;
		}
		return Mathf.Min(num, craftTime);
	}

	public BlueprintOverride GetRecipeOverride()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (Overrides.Count == 0)
		{
			return new BlueprintOverride(this);
		}
		foreach (BlueprintOverride @override in Overrides)
		{
			if (@override.TargetEra == ConVar.Server.Era)
			{
				return @override;
			}
		}
		return new BlueprintOverride(this);
	}

	public int GetWorkbenchLevel()
	{
		BlueprintOverride recipeOverride = GetRecipeOverride();
		if (recipeOverride.workbenchLevel != 0)
		{
			return Mathf.Max(0, recipeOverride.workbenchLevel);
		}
		return workbenchLevelRequired;
	}
}


using System;
using System.Collections.Generic;
using Rust;

[Serializable]
public struct BlueprintOverride
{
	public Era TargetEra;

	public List<ItemAmount> Ingredients;

	public float craftTime;

	public int workbenchLevel;

	public BlueprintOverride(ItemBlueprint bp)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		TargetEra = (Era)0;
		Ingredients = bp.ingredients;
		craftTime = bp.time;
		workbenchLevel = bp.workbenchLevelRequired;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Rust;
using UnityEngine;

public class ItemDefinition : MonoBehaviour
{
	[Serializable]
	public struct Condition
	{
		[Serializable]
		public class WorldSpawnCondition
		{
			public float fractionMin = 1f;

			public float fractionMax = 1f;
		}

		public bool enabled;

		[Tooltip("The maximum condition this item type can have, new items will start with this value")]
		public float max;

		[Tooltip("If false then item will destroy when condition reaches 0")]
		public bool repairable;

		[Tooltip("If true, never lose max condition when repaired")]
		public bool maintainMaxCondition;

		public bool ovenCondition;

		public WorldSpawnCondition foundCondition;

		public bool hideConditionBar;

		public GameObjectRef breakEffect;
	}

	[Serializable]
	public struct OverrideWorldModel
	{
		public GameObjectRef worldModel;

		public int minStackSize;
	}

	public enum RedirectVendingBehaviour
	{
		NoListing,
		ListAsUniqueItem
	}

	[Flags]
	public enum Flag
	{
		NoDropping = 1,
		NotStraightToBelt = 2,
		NotAllowedInBelt = 4,
		Backpack = 8
	}

	public enum AmountType
	{
		Count,
		Millilitre,
		Feet,
		Genetics,
		OxygenSeconds,
		Frequency,
		Generic,
		BagLimit,
		ShelterLimit,
		ContentCount,
		TurretLimit,
		NucleusGrades
	}

	[ReadOnly]
	[Header("Item")]
	public int itemid;

	[Tooltip("The shortname should be unique. A hash will be generated from it to identify the item type. If this name changes at any point it will make all saves incompatible")]
	public string shortname;

	public Era era;

	public EraRestriction eraRestrictions;

	[Header("Appearance")]
	public Phrase displayName;

	public Phrase displayDescription;

	public Sprite iconSprite;

	public ItemCategory category;

	public ItemSelectionPanel selectionPanel;

	[Header("Containment")]
	public int maxDraggable;

	public ItemContainer.ContentsType itemType = ItemContainer.ContentsType.Generic;

	public AmountType amountType;

	[InspectorFlags]
	public ItemSlot occupySlots = ItemSlot.None;

	public int stackable;

	public int volume;

	public float baseRadioactivity;

	public bool quickDespawn;

	public bool blockStealingInSafeZone;

	public BasePlayer.TutorialItemAllowance tutorialAllowance;

	[Tooltip("If true, this item will support item ownership even if it's stacksize is >1")]
	public bool supportsStackableOwnership;

	[Tooltip("How rare this item is and how much it costs to research")]
	[Header("Spawn Tables")]
	public Rarity rarity;

	public Rarity despawnRarity;

	public bool spawnAsBlueprint;

	[Header("Sounds")]
	public SoundDefinition inventoryGrabSound;

	public SoundDefinition inventoryDropSound;

	public SoundDefinition physImpactSoundDef;

	public Condition condition;

	[Header("Misc")]
	public bool hidden;

	[InspectorFlags]
	public Flag flags;

	public bool hideSelectedPanel;

	[Tooltip("User can craft this item on any server if they have this steam item")]
	public SteamInventoryItem steamItem;

	[Tooltip("User can craft this item if they have this DLC purchased")]
	public SteamDLCItem steamDlc;

	[Tooltip("Can only craft this item if the parent is craftable (tech tree)")]
	public ItemDefinition Parent;

	[Header("World Model")]
	public GameObjectRef worldModelPrefab;

	public OverrideWorldModel[] worldModelOverrides;

	public bool treatAsComponentForRepairs;

	public bool AlignWorldModelOnDrop;

	public Vector3 WorldModelDropOffset;

	public bool AdjustCenterOfMassOnDrop;

	public Vector3 DropCenterOfMass;

	public ItemDefinition isRedirectOf;

	public RedirectVendingBehaviour redirectVendingBehaviour;

	[NonSerialized]
	public ItemMod[] itemMods;

	public BaseEntity.TraitFlag Traits;

	[NonSerialized]
	public ItemSkinDirectory.Skin[] skins;

	[NonSerialized]
	public IPlayerItemDefinition[] _skins2;

	private float _worldModelMass;

	[Tooltip("Panel to show in the inventory menu when selected")]
	public GameObject panel;

	[NonSerialized]
	public ItemDefinition[] Children = new ItemDefinition[0];

	public IPlayerItemDefinition[] skins2
	{
		get
		{
			if (_skins2 != null)
			{
				return _skins2;
			}
			if (PlatformService.Instance.IsValid && PlatformService.Instance.ItemDefinitions != null)
			{
				string prefabname = ((Object)this).name;
				_skins2 = PlatformService.Instance.ItemDefinitions.Where((IPlayerItemDefinition x) => (x.ItemShortName == shortname || x.ItemShortName == prefabname) && x.WorkshopId != 0).ToArray();
			}
			return _skins2;
		}
	}

	public ItemBlueprint Blueprint => ((Component)this).GetComponent<ItemBlueprint>();

	public int craftingStackable => Mathf.Max(10, stackable);

	public bool isWearable => (Object)(object)ItemModWearable != (Object)null;

	public ItemModWearable ItemModWearable { get; set; }

	public ItemModBurnable ItemModBurnable { get; set; }

	public ItemModCookable ItemModCookable { get; set; }

	public bool isHoldable { get; private set; }

	public bool isUsable { get; private set; }

	public bool HasSkins
	{
		get
		{
			if (skins2 != null && skins2.Length != 0)
			{
				return true;
			}
			if (skins != null && skins.Length != 0)
			{
				return true;
			}
			return false;
		}
	}

	public bool CraftableWithSkin { get; private set; }

	public bool Hidden()
	{
		return hidden;
	}

	public void InvalidateWorkshopSkinCache()
	{
		_skins2 = null;
	}

	public bool IsAllowedInEra(EraRestriction targetRestriction)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		if ((int)ConVar.Server.Era == 0)
		{
			return true;
		}
		return IsAllowedInEra(targetRestriction, ConVar.Server.Era);
	}

	public bool IsAllowedInEra(EraRestriction targetRestriction, Era serverEra)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Invalid comparison between Unknown and I4
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if ((int)serverEra == 0)
		{
			return true;
		}
		if ((Object)(object)isRedirectOf != (Object)null)
		{
			return isRedirectOf.IsAllowedInEra(targetRestriction);
		}
		Era val = era;
		if ((int)val != 0)
		{
			if ((int)val == 1)
			{
				return true;
			}
			if (era <= serverEra)
			{
				if ((int)targetRestriction != 0 && (int)eraRestrictions != 0 && (EraRestriction)(eraRestrictions & targetRestriction) != eraRestrictions)
				{
					return false;
				}
				return true;
			}
			return false;
		}
		return true;
	}

	public static ulong FindSkin(int itemID, int skinID)
	{
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemID);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return 0uL;
		}
		IPlayerItemDefinition itemDefinition2 = PlatformService.Instance.GetItemDefinition(skinID);
		if (itemDefinition2 != null)
		{
			ulong workshopDownload = itemDefinition2.WorkshopDownload;
			if (workshopDownload != 0L)
			{
				string itemShortName = itemDefinition2.ItemShortName;
				if (itemShortName == itemDefinition.shortname || itemShortName == ((Object)itemDefinition).name)
				{
					return workshopDownload;
				}
			}
		}
		for (int i = 0; i < itemDefinition.skins.Length; i++)
		{
			if (itemDefinition.skins[i].id == skinID)
			{
				return (ulong)skinID;
			}
		}
		return 0uL;
	}

	public float GetWorldModelMass()
	{
		if (_worldModelMass != 0f)
		{
			return _worldModelMass;
		}
		GameObject val = worldModelPrefab?.Get();
		if ((Object)(object)val != (Object)null)
		{
			WorldModel component = val.GetComponent<WorldModel>();
			if ((Object)(object)component != (Object)null && component.mass != 0f)
			{
				_worldModelMass = component.mass;
				return _worldModelMass;
			}
		}
		_worldModelMass = 1f;
		return _worldModelMass;
	}

	public bool HasFlag(Flag f)
	{
		return (flags & f) == f;
	}

	public void Initialize(List<ItemDefinition> itemList)
	{
		if (itemMods != null)
		{
			Debug.LogError((object)("Item Definition Initializing twice: " + ((Object)this).name));
		}
		skins = ItemSkinDirectory.ForItem(this);
		itemMods = ((Component)this).GetComponentsInChildren<ItemMod>(true);
		ItemMod[] array = itemMods;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].ModInit();
		}
		Children = itemList.Where((ItemDefinition x) => (Object)(object)x.Parent == (Object)(object)this).ToArray();
		ItemModWearable = ((Component)this).GetComponent<ItemModWearable>();
		ItemModBurnable = ((Component)this).GetComponent<ItemModBurnable>();
		ItemModCookable = ((Component)this).GetComponent<ItemModCookable>();
		isHoldable = (Object)(object)((Component)this).GetComponent<ItemModEntity>() != (Object)null;
		isUsable = (Object)(object)((Component)this).GetComponent<ItemModEntity>() != (Object)null || (Object)(object)((Component)this).GetComponent<ItemModConsume>() != (Object)null;
	}

	public GameObjectRef GetWorldModel(int amount)
	{
		if (worldModelOverrides == null || worldModelOverrides.Length == 0)
		{
			return worldModelPrefab;
		}
		for (int num = worldModelOverrides.Length - 1; num >= 0; num--)
		{
			if (amount >= worldModelOverrides[num].minStackSize)
			{
				return worldModelOverrides[num].worldModel;
			}
		}
		return worldModelPrefab;
	}

	public int GetWorldModelIndex(int amount)
	{
		if (worldModelOverrides == null || worldModelOverrides.Length == 0)
		{
			return -1;
		}
		for (int num = worldModelOverrides.Length - 1; num >= 0; num--)
		{
			if (amount >= worldModelOverrides[num].minStackSize)
			{
				return num;
			}
		}
		return -1;
	}

	public bool SupportsItemOwnership()
	{
		if (stackable != 1)
		{
			if (supportsStackableOwnership)
			{
				return Inventory.stackable_item_ownership;
			}
			return false;
		}
		return true;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct Condition
{
	[Serializable]
	public class WorldSpawnCondition
	{
		public float fractionMin = 1f;

		public float fractionMax = 1f;
	}

	public bool enabled;

	[Tooltip("The maximum condition this item type can have, new items will start with this value")]
	public float max;

	[Tooltip("If false then item will destroy when condition reaches 0")]
	public bool repairable;

	[Tooltip("If true, never lose max condition when repaired")]
	public bool maintainMaxCondition;

	public bool ovenCondition;

	public WorldSpawnCondition foundCondition;

	public bool hideConditionBar;

	public GameObjectRef breakEffect;
}


using System;

[Serializable]
public class WorldSpawnCondition
{
	public float fractionMin = 1f;

	public float fractionMax = 1f;
}


using System;

[Serializable]
public struct OverrideWorldModel
{
	public GameObjectRef worldModel;

	public int minStackSize;
}


public enum RedirectVendingBehaviour
{
	NoListing,
	ListAsUniqueItem
}


using System;

[Flags]
public enum Flag
{
	NoDropping = 1,
	NotStraightToBelt = 2,
	NotAllowedInBelt = 4,
	Backpack = 8
}


public enum AmountType
{
	Count,
	Millilitre,
	Feet,
	Genetics,
	OxygenSeconds,
	Frequency,
	Generic,
	BagLimit,
	ShelterLimit,
	ContentCount,
	TurretLimit,
	NucleusGrades
}


public enum ItemCategory
{
	Weapon,
	Construction,
	Items,
	Resources,
	Attire,
	Tool,
	Medical,
	Food,
	Ammunition,
	Traps,
	Misc,
	All,
	Common,
	Component,
	Search,
	Favourite,
	Electrical,
	Fun
}


using System;

[Flags]
public enum ItemSlot
{
	None = 1,
	Barrel = 2,
	Silencer = 4,
	Scope = 8,
	UnderBarrel = 0x10,
	Magazine = 0x20,
	Internal = 0x40,
	InternalTargeting = 0x80
}


public enum ItemSelectionPanel
{
	None,
	Vessel,
	Modifications,
	GunInformation
}


using UnityEngine;

public class ItemSelector : PropertyAttribute
{
	public ItemCategory category = ItemCategory.All;

	public ItemSelector(ItemCategory category = ItemCategory.All)
	{
		this.category = category;
	}
}


using UnityEngine;

public class ItemMod : MonoBehaviour
{
	protected ItemMod[] siblingMods;

	public virtual void ModInit()
	{
		siblingMods = ((Component)this).GetComponents<ItemMod>();
	}

	public virtual void OnItemCreated(Item item)
	{
	}

	public virtual void OnVirginItem(Item item, BasePlayer creatingPlayer)
	{
	}

	public virtual void ServerCommand(Item item, string command, BasePlayer player)
	{
	}

	public virtual void DoAction(Item item, BasePlayer player)
	{
	}

	public virtual void OnRemove(Item item)
	{
	}

	public virtual void OnParentChanged(Item item)
	{
	}

	public virtual void CollectedForCrafting(Item item, BasePlayer crafter)
	{
	}

	public virtual void ReturnedFromCancelledCraft(Item item, BasePlayer crafter)
	{
	}

	public virtual void OnAttacked(Item item, HitInfo info)
	{
	}

	public virtual void OnChanged(Item item)
	{
	}

	public virtual bool CanDoAction(Item item, BasePlayer player)
	{
		ItemMod[] array = siblingMods;
		for (int i = 0; i < array.Length; i++)
		{
			if (!array[i].Passes(item))
			{
				return false;
			}
		}
		return true;
	}

	public virtual bool Passes(Item item)
	{
		return true;
	}

	public virtual void OnRemovedFromWorld(Item item)
	{
	}

	public virtual void OnMovedToWorld(Item item)
	{
	}
}


using UnityEngine;

public class ItemModActionChange : ItemMod
{
	public ItemMod[] actions;

	public override void OnChanged(Item item)
	{
		if (!item.isServer)
		{
			return;
		}
		BasePlayer ownerPlayer = item.GetOwnerPlayer();
		ItemMod[] array = actions;
		foreach (ItemMod itemMod in array)
		{
			if (itemMod.CanDoAction(item, ownerPlayer))
			{
				itemMod.DoAction(item, ownerPlayer);
			}
		}
	}

	private void OnValidate()
	{
		if (actions == null)
		{
			Debug.LogWarning((object)"ItemModMenuOption: actions is null!", (Object)(object)((Component)this).gameObject);
		}
	}
}


using UnityEngine;

public class ItemModActionContainerChange : ItemMod
{
	public ItemMod[] actions;

	public override void OnParentChanged(Item item)
	{
		if (!item.isServer)
		{
			return;
		}
		BasePlayer ownerPlayer = item.GetOwnerPlayer();
		ItemMod[] array = actions;
		foreach (ItemMod itemMod in array)
		{
			if (itemMod.CanDoAction(item, ownerPlayer))
			{
				itemMod.DoAction(item, ownerPlayer);
			}
		}
	}

	private void OnValidate()
	{
		if (actions == null)
		{
			Debug.LogWarning((object)"ItemModMenuOption: actions is null!", (Object)(object)((Component)this).gameObject);
		}
	}
}


public class ItemModAlterCondition : ItemMod
{
	public float conditionChange;

	public override void DoAction(Item item, BasePlayer player)
	{
		if (item.amount >= 1)
		{
			if (conditionChange < 0f)
			{
				item.LoseCondition(conditionChange * -1f);
			}
			else
			{
				item.RepairCondition(conditionChange);
			}
		}
	}
}


public class ItemModAnimalEquipment : ItemMod
{
	public enum SlotType
	{
		Basic,
		Armor,
		Saddle,
		Bit,
		Feet,
		SaddleDouble
	}

	public BaseEntity.Flags WearableFlag;

	public bool hideHair;

	public ProtectionProperties animalProtection;

	public ProtectionProperties riderProtection;

	public int additionalInventorySlots;

	public float speedModifier;

	public float staminaUseModifier;

	public SlotType slot;
}


public enum SlotType
{
	Basic,
	Armor,
	Saddle,
	Bit,
	Feet,
	SaddleDouble
}


public class ItemModArmorInsert : ItemMod
{
	public ProtectionProperties protectionProperties;

	public float SpeedReduction;
}


using ProtoBuf;
using UnityEngine;

public abstract class ItemModAssociatedEntity<T> : ItemMod where T : BaseEntity
{
	public GameObjectRef entityPrefab;

	protected virtual bool AllowNullParenting => false;

	protected virtual bool AllowHeldEntityParenting => false;

	protected virtual bool ShouldAutoCreateEntity => true;

	protected virtual bool OwnedByParentPlayer => false;

	public override void OnItemCreated(Item item)
	{
		base.OnItemCreated(item);
		if (ShouldAutoCreateEntity)
		{
			CreateAssociatedEntity(item);
		}
	}

	public T CreateAssociatedEntity(Item item)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Expected O, but got Unknown
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		if (item.instanceData != null)
		{
			return null;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(entityPrefab.resourcePath, Vector3.zero);
		T component = ((Component)baseEntity).GetComponent<T>();
		OnAssociatedItemCreated(component);
		baseEntity.Spawn();
		item.instanceData = new InstanceData();
		item.instanceData.ShouldPool = false;
		item.instanceData.subEntity = baseEntity.net.ID;
		item.MarkDirty();
		return component;
	}

	protected virtual void OnAssociatedItemCreated(T ent)
	{
	}

	public override void OnRemove(Item item)
	{
		base.OnRemove(item);
		T associatedEntity = GetAssociatedEntity(item);
		if (Object.op_Implicit((Object)(object)associatedEntity))
		{
			associatedEntity.Kill();
		}
	}

	public override void OnMovedToWorld(Item item)
	{
		UpdateParent(item);
		base.OnMovedToWorld(item);
	}

	public override void OnRemovedFromWorld(Item item)
	{
		UpdateParent(item);
		base.OnRemovedFromWorld(item);
	}

	public void UpdateParent(Item item)
	{
		T associatedEntity = GetAssociatedEntity(item);
		if ((Object)(object)associatedEntity == (Object)null)
		{
			return;
		}
		BaseEntity entityForParenting = GetEntityForParenting(item);
		if ((Object)(object)entityForParenting == (Object)null)
		{
			if (AllowNullParenting)
			{
				associatedEntity.SetParent(null, worldPositionStays: false, sendImmediate: true);
			}
			if (OwnedByParentPlayer)
			{
				associatedEntity.OwnerID = 0uL;
			}
		}
		else if (entityForParenting.isServer && entityForParenting.IsFullySpawned())
		{
			associatedEntity.SetParent(entityForParenting, worldPositionStays: false, sendImmediate: true);
			if (OwnedByParentPlayer && entityForParenting is BasePlayer basePlayer)
			{
				associatedEntity.OwnerID = basePlayer.userID;
			}
		}
	}

	public override void OnParentChanged(Item item)
	{
		base.OnParentChanged(item);
		UpdateParent(item);
	}

	public BaseEntity GetEntityForParenting(Item item = null)
	{
		if (item != null)
		{
			Item item2 = item;
			Item parentItem = item.parentItem;
			if (parentItem != null && parentItem.IsBackpack())
			{
				item2 = item.parentItem;
			}
			BasePlayer ownerPlayer = item2.GetOwnerPlayer();
			if (Object.op_Implicit((Object)(object)ownerPlayer))
			{
				return ownerPlayer;
			}
			BaseEntity baseEntity = ((item2.parent == null) ? null : item2.parent.entityOwner);
			if ((Object)(object)baseEntity != (Object)null)
			{
				return baseEntity;
			}
			BaseEntity worldEntity = item2.GetWorldEntity();
			if (Object.op_Implicit((Object)(object)worldEntity))
			{
				return worldEntity;
			}
			if (AllowHeldEntityParenting && item.parentItem != null && (Object)(object)item.parentItem.GetHeldEntity() != (Object)null)
			{
				return item.parentItem.GetHeldEntity();
			}
			return null;
		}
		return null;
	}

	public static bool GetAssociatedEntity(Item item, out T result, bool isServer = true)
	{
		result = GetAssociatedEntity(item, isServer);
		return (Object)(object)result != (Object)null;
	}

	public static T GetAssociatedEntity(Item item, bool isServer = true)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if (item?.instanceData == null)
		{
			return null;
		}
		BaseNetworkable baseNetworkable = null;
		if (isServer)
		{
			baseNetworkable = BaseNetworkable.serverEntities.Find(item.instanceData.subEntity);
		}
		if (Object.op_Implicit((Object)(object)baseNetworkable))
		{
			return ((Component)baseNetworkable).GetComponent<T>();
		}
		return null;
	}
}


using System;
using UnityEngine;

public class ItemModBackpack : ItemMod
{
	public SoundDefinition ZipSound;

	[Header("Should the 'selected' panel be hidden when the backpack is selected when equipped")]
	public bool hideSelectedPanel;

	[Header("Backpack's item volume when items are in it")]
	public int containerVolumeWhenFilled = 1;

	public bool DropWhenDowned;

	public override void OnItemCreated(Item item)
	{
		base.OnItemCreated(item);
		if (item.contents != null)
		{
			ItemContainer contents = item.contents;
			contents.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(contents.canAcceptItem, (Func<Item, int, bool>)((Item subItem, int slot) => CanAcceptItem(item, subItem, slot)));
		}
	}

	public bool CanAcceptItem(Item backpack, Item item, int slot)
	{
		if (backpack.parent == null)
		{
			return true;
		}
		if (backpack.parent.HasFlag(ItemContainer.Flag.Clothing))
		{
			return true;
		}
		return false;
	}
}


using UnityEngine;

public class ItemModBaitContainer : ItemModContainer
{
	protected override bool ForceAcceptItemCheck => true;

	protected override bool CanAcceptItem(Item item, int count)
	{
		ItemModCompostable component = ((Component)item.info).GetComponent<ItemModCompostable>();
		if ((Object)(object)component != (Object)null)
		{
			return component.BaitValue > 0f;
		}
		return false;
	}

	protected override void SetAllowedItems(ItemContainer container)
	{
		FishLookup.LoadFish();
		container.SetOnlyAllowedItems(FishLookup.BaitItems);
	}
}


using UnityEngine;

public class ItemModBlueprintCraft : ItemMod
{
	public static readonly Phrase CraftItemTitle = new Phrase("craft_item", "Craft");

	public static readonly Phrase CraftItemDesc = new Phrase("craft_item_desc", "Create the item the blueprint is referring to");

	public static readonly Phrase CraftAllTitle = new Phrase("craft_all", "Craft All");

	public static readonly Phrase CraftAllDesc = new Phrase("craft_all_desc", "Craft all available blueprints into items");

	public GameObjectRef successEffect;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)item.GetOwnerPlayer() != (Object)(object)player)
		{
			return;
		}
		if (command == "craft")
		{
			if (!item.IsBlueprint() || !player.inventory.crafting.CanCraft(item.blueprintTargetDef.Blueprint))
			{
				return;
			}
			Item fromTempBlueprint = item;
			if (item.amount > 1)
			{
				fromTempBlueprint = item.SplitItem(1);
			}
			player.inventory.crafting.CraftItem(item.blueprintTargetDef.Blueprint, player, null, 1, 0, fromTempBlueprint);
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
		if (command == "craft_all" && item.IsBlueprint() && player.inventory.crafting.CanCraft(item.blueprintTargetDef.Blueprint, item.amount))
		{
			player.inventory.crafting.CraftItem(item.blueprintTargetDef.Blueprint, player, null, item.amount, 0, item);
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}
}


public class ItemModBurnable : ItemMod
{
	public float fuelAmount = 10f;

	[ItemSelector(ItemCategory.All)]
	public ItemDefinition byproductItem;

	public int byproductAmount = 1;

	public float byproductChance = 0.5f;

	public override void OnItemCreated(Item item)
	{
		item.fuel = fuelAmount;
	}
}


public class ItemModCassetteContainer : ItemModContainer
{
	public ItemDefinition[] CassetteItems;

	protected override bool ForceAcceptItemCheck => true;

	protected override void SetAllowedItems(ItemContainer container)
	{
		container.SetOnlyAllowedItems(CassetteItems);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class ItemModCatapultBoulder : MonoBehaviour
{
	[Serializable]
	public struct ProjectileSettings
	{
		public GameObjectRef prefab;

		public int count;

		public float gravityModifier;
	}

	[SerializeField]
	public List<ProjectileSettings> projectileSettings = new List<ProjectileSettings>();

	public float spreadAngle = 6f;
}


using System;

[Serializable]
public struct ProjectileSettings
{
	public GameObjectRef prefab;

	public int count;

	public float gravityModifier;
}


public class ItemModChildIO : ItemMod
{
	public GameObjectRef TargetChildIO;
}


using UnityEngine;

public class ItemModCompostable : MonoBehaviour
{
	public float TotalFertilizerProduced = 0.2f;

	public float BaitValue = 1f;

	public int MaxBaitStack;
}


public class ItemModConditionContainerFlag : ItemMod
{
	public ItemContainer.Flag flag;

	public bool requiredState;

	public override bool Passes(Item item)
	{
		if (item.parent == null)
		{
			return !requiredState;
		}
		if (!item.parent.HasFlag(flag))
		{
			return !requiredState;
		}
		return requiredState;
	}
}


using UnityEngine;

public class ItemModConditionHasCondition : ItemMod
{
	public float conditionTarget = 1f;

	[Tooltip("If set to above 0 will check for fraction instead of raw value")]
	public float conditionFractionTarget = -1f;

	public bool lessThan;

	public override bool Passes(Item item)
	{
		if (!item.hasCondition)
		{
			return false;
		}
		if (conditionFractionTarget > 0f)
		{
			if (lessThan || !(item.conditionNormalized > conditionFractionTarget))
			{
				if (lessThan)
				{
					return item.conditionNormalized < conditionFractionTarget;
				}
				return false;
			}
			return true;
		}
		if (lessThan || !(item.condition >= conditionTarget))
		{
			if (lessThan)
			{
				return item.condition < conditionTarget;
			}
			return false;
		}
		return true;
	}
}


using System.Linq;
using UnityEngine;

public class ItemModConditionHasContents : ItemMod
{
	[Tooltip("Can be null to mean any item")]
	public ItemDefinition itemDef;

	public bool requiredState;

	public override bool Passes(Item item)
	{
		if (item.contents == null)
		{
			return !requiredState;
		}
		if (item.contents.itemList.Count == 0)
		{
			return !requiredState;
		}
		if (Object.op_Implicit((Object)(object)itemDef) && !item.contents.itemList.Any((Item x) => (Object)(object)x.info == (Object)(object)itemDef))
		{
			return !requiredState;
		}
		return requiredState;
	}
}


public class ItemModConditionHasFlag : ItemMod
{
	public Item.Flag flag;

	public bool requiredState;

	public override bool Passes(Item item)
	{
		return item.HasFlag(flag) == requiredState;
	}
}


using UnityEngine;

public class ItemModConditionInWater : ItemMod
{
	public bool requiredState;

	public override bool Passes(Item item)
	{
		BasePlayer ownerPlayer = item.GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null)
		{
			return false;
		}
		return ownerPlayer.IsHeadUnderwater() == requiredState;
	}
}


using UnityEngine;

public class ItemModConditionIsSleeping : ItemMod
{
	public bool requiredState;

	public override bool Passes(Item item)
	{
		BasePlayer ownerPlayer = item.GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null)
		{
			return false;
		}
		return ownerPlayer.IsSleeping() == requiredState;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class ItemModConsumable : MonoBehaviour
{
	[Serializable]
	public class ConsumableEffect
	{
		public MetabolismAttribute.Type type;

		public float amount;

		public float time;

		public float onlyIfHealthLessThan = 1f;
	}

	public int amountToConsume = 1;

	public float conditionFractionToLose;

	public string achievementWhenEaten;

	public bool chickenCoopFood;

	public List<ConsumableEffect> effects = new List<ConsumableEffect>();

	public List<ModifierDefintion> modifiers = new List<ModifierDefintion>();

	public float GetIfType(MetabolismAttribute.Type typeToPick)
	{
		for (int i = 0; i < effects.Count; i++)
		{
			if (effects[i].type == typeToPick)
			{
				return effects[i].amount;
			}
		}
		return 0f;
	}
}


using System;

[Serializable]
public class ConsumableEffect
{
	public MetabolismAttribute.Type type;

	public float amount;

	public float time;

	public float onlyIfHealthLessThan = 1f;
}


using Facepunch.Rust;
using Oxide.Core;
using Rust;
using UnityEngine;

[RequireComponent(typeof(ItemModConsumable))]
public class ItemModConsume : ItemMod
{
	public GameObjectRef consumeEffect;

	public string eatGesture = "eat_2hand";

	[Tooltip("Items that are given on consumption of this item")]
	public ItemAmountRandom[] product;

	public ItemModConsumable primaryConsumable;

	public virtual ItemModConsumable GetConsumable()
	{
		if (Object.op_Implicit((Object)(object)primaryConsumable))
		{
			return primaryConsumable;
		}
		return ((Component)this).GetComponent<ItemModConsumable>();
	}

	public virtual GameObjectRef GetConsumeEffect()
	{
		return consumeEffect;
	}

	public override void DoAction(Item item, BasePlayer player)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		if (item.amount < 1)
		{
			return;
		}
		GameObjectRef gameObjectRef = GetConsumeEffect();
		if (gameObjectRef.isValid)
		{
			Vector3 posLocal = (player.IsDucked() ? new Vector3(0f, 1f, 0f) : new Vector3(0f, 2f, 0f));
			Effect.server.Run(gameObjectRef.resourcePath, player, 0u, posLocal, Vector3.zero);
		}
		player.metabolism.MarkConsumption();
		ItemModConsumable consumable = GetConsumable();
		if (!string.IsNullOrEmpty(consumable.achievementWhenEaten))
		{
			player.GiveAchievement(consumable.achievementWhenEaten);
		}
		Analytics.Azure.OnConsumableUsed(player, item);
		float num = Mathf.Max(consumable.amountToConsume, 1);
		float num2 = Mathf.Min((float)item.amount, num);
		float num3 = num2 / num;
		float num4 = item.conditionNormalized;
		if (consumable.conditionFractionToLose > 0f)
		{
			num4 = consumable.conditionFractionToLose;
		}
		foreach (ItemModConsumable.ConsumableEffect effect in consumable.effects)
		{
			if (Mathf.Clamp01(player.healthFraction + player.metabolism.pending_health.Fraction()) > effect.onlyIfHealthLessThan)
			{
				continue;
			}
			if (effect.type == MetabolismAttribute.Type.Health)
			{
				if (effect.amount < 0f)
				{
					player.OnAttacked(new HitInfo(player, player, DamageType.Generic, (0f - effect.amount) * num3 * num4, ((Component)player).transform.position + ((Component)player).transform.forward * 1f));
				}
				else
				{
					player.health += effect.amount * num3 * num4;
				}
			}
			else
			{
				player.metabolism.ApplyChange(effect.type, effect.amount * num3 * num4, effect.time * num3 * num4);
			}
		}
		player.ProcessMissionEvent(BaseMission.MissionEventType.CONSUME, item.info.itemid, 1f);
		if ((Object)(object)player.modifiers != (Object)null && Interface.CallHook("OnPlayerAddModifiers", (object)player, (object)item, (object)consumable) == null)
		{
			player.modifiers.Add(consumable.modifiers);
		}
		if (product != null)
		{
			ItemAmountRandom[] array = product;
			foreach (ItemAmountRandom itemAmountRandom in array)
			{
				int num5 = Mathf.RoundToInt((float)itemAmountRandom.RandomAmount() * num4);
				if (num5 > 0)
				{
					Item item2 = ItemManager.Create(itemAmountRandom.itemDef, num5, 0uL);
					player.GiveItem(item2);
				}
			}
		}
		if (string.IsNullOrEmpty(eatGesture))
		{
			player.SignalBroadcast(BaseEntity.Signal.Gesture, eatGesture);
		}
		if (consumable.conditionFractionToLose > 0f)
		{
			item.LoseCondition(consumable.conditionFractionToLose * item.maxCondition);
		}
		else
		{
			item.UseItem((int)num2);
		}
	}

	public override bool CanDoAction(Item item, BasePlayer player)
	{
		return player.metabolism.CanConsume();
	}
}


using UnityEngine;

public class ItemModConsumeChance : ItemModConsume
{
	public float chanceForSecondaryConsume = 0.5f;

	public GameObjectRef secondaryConsumeEffect;

	public ItemModConsumable secondaryConsumable;

	private bool GetChance()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		State state = Random.state;
		Random.InitState(Time.frameCount);
		bool result = Random.Range(0f, 1f) <= chanceForSecondaryConsume;
		Random.state = state;
		return result;
	}

	public override ItemModConsumable GetConsumable()
	{
		if (GetChance())
		{
			return secondaryConsumable;
		}
		return base.GetConsumable();
	}

	public override GameObjectRef GetConsumeEffect()
	{
		if (GetChance())
		{
			return secondaryConsumeEffect;
		}
		return base.GetConsumeEffect();
	}
}


using UnityEngine;

public class ItemModConsumeContents : ItemMod
{
	public GameObjectRef consumeEffect;

	public override void DoAction(Item item, BasePlayer player)
	{
		foreach (Item item2 in item.contents.itemList)
		{
			ItemModConsume component = ((Component)item2.info).GetComponent<ItemModConsume>();
			if (!((Object)(object)component == (Object)null) && component.CanDoAction(item2, player))
			{
				component.DoAction(item2, player);
				item.contents?.onItemRemovedFromStack?.Invoke(item2, 0);
				break;
			}
		}
	}

	public override bool CanDoAction(Item item, BasePlayer player)
	{
		if (!player.metabolism.CanConsume())
		{
			return false;
		}
		if (item.contents == null)
		{
			return false;
		}
		foreach (Item item2 in item.contents.itemList)
		{
			ItemModConsume component = ((Component)item2.info).GetComponent<ItemModConsume>();
			if (!((Object)(object)component == (Object)null) && component.CanDoAction(item2, player))
			{
				return true;
			}
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

public class ItemModContainer : ItemMod
{
	public int capacity = 6;

	public int maxStackSize;

	public int containerVolume;

	public bool canLootInWorld;

	public float pickupInWorldDelay;

	public float maxWeight = -1f;

	public float worldWeightScale = 1f;

	[InspectorFlags]
	public ItemContainer.Flag containerFlags;

	public ItemContainer.ContentsType onlyAllowedContents = ItemContainer.ContentsType.Generic;

	public ItemDefinition onlyAllowedItemType;

	public List<ItemSlot> availableSlots = new List<ItemSlot>();

	public ItemDefinition[] validItemWhitelist = new ItemDefinition[0];

	public bool openInDeployed = true;

	public bool openInInventory = true;

	public List<ItemAmount> defaultContents = new List<ItemAmount>();

	[Tooltip("If true items in this container won't be usable as ammo for reloads")]
	public bool blockAmmoSource;

	[Header("Sounds")]
	public SoundDefinition openSound;

	public SoundDefinition closeSound;

	protected virtual bool ForceAcceptItemCheck => false;

	public override void OnItemCreated(Item item)
	{
		CreateContents(item);
	}

	protected void CreateContents(Item item)
	{
		if (!item.isServer || capacity <= 0)
		{
			return;
		}
		if (item.contents != null)
		{
			if (validItemWhitelist != null && validItemWhitelist.Length != 0)
			{
				item.contents.canAcceptItem = CanAcceptItem;
			}
			return;
		}
		Debug.Assert(item.contents == null, "Double init of contents!");
		item.contents = Pool.Get<ItemContainer>();
		item.contents.flags = containerFlags;
		item.contents.allowedContents = ((onlyAllowedContents == (ItemContainer.ContentsType)0) ? ItemContainer.ContentsType.Generic : onlyAllowedContents);
		SetAllowedItems(item.contents);
		item.contents.UpdateAvailableSlots(availableSlots);
		ItemContainer contents = item.contents;
		contents.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(contents.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedOrRemoved));
		if ((validItemWhitelist != null && validItemWhitelist.Length != 0) || ForceAcceptItemCheck)
		{
			item.contents.canAcceptItem = CanAcceptItem;
		}
		item.contents.ServerInitialize(item, capacity);
		item.contents.containerVolume = containerVolume;
		item.contents.maxStackSize = maxStackSize;
		item.contents.GiveUID();
	}

	protected virtual void SetAllowedItems(ItemContainer container)
	{
		container.SetOnlyAllowedItem(onlyAllowedItemType);
	}

	protected virtual bool CanAcceptItem(Item item, int count)
	{
		ItemDefinition[] array = validItemWhitelist;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].itemid == item.info.itemid)
			{
				return true;
			}
		}
		return false;
	}

	private void OnItemAddedOrRemoved(Item item, bool added)
	{
		if (!Application.isLoadingSave)
		{
			DroppedItem droppedItem = item.parentItem?.GetWorldEntity() as DroppedItem;
			if (!((Object)(object)droppedItem == (Object)null))
			{
				droppedItem.UpdateItemMass();
			}
		}
	}

	public override void OnVirginItem(Item item, BasePlayer creatingPlayer)
	{
		base.OnVirginItem(item, creatingPlayer);
		foreach (ItemAmount defaultContent in defaultContents)
		{
			ItemManager.Create(defaultContent.itemDef, (int)defaultContent.amount, 0uL)?.MoveToContainer(item.contents);
		}
	}

	public override void CollectedForCrafting(Item item, BasePlayer crafter)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (item.contents == null)
		{
			return;
		}
		for (int num = item.contents.itemList.Count - 1; num >= 0; num--)
		{
			Item item2 = item.contents.itemList[num];
			if (!item2.MoveToContainer(crafter.inventory.containerMain))
			{
				item2.Drop(crafter.GetDropPosition(), crafter.GetDropVelocity());
			}
		}
	}
}


using Rust;
using UnityEngine;

public class ItemModContainerArmorSlot : ItemModContainer
{
	public int MinSlots;

	public int MaxSlots = 3;

	public bool CraftedItemsOnly = true;

	private static float[] RollChances = new float[3] { 0.25f, 0.1f, 0.05f };

	public override void OnVirginItem(Item item, BasePlayer creatingPlayer)
	{
		if (item.isServer)
		{
			base.OnVirginItem(item, creatingPlayer);
			CreateForPlayer(item, creatingPlayer);
		}
	}

	private static int GetRandomSlotCount(float improveChance, int min, int max)
	{
		float num = Random.Range(0f, 1f - improveChance);
		int num2 = 0;
		if (num <= 0.5f || improveChance > 0f)
		{
			num2 = min;
			for (int i = 0; i < max - min && num <= RollChances[Mathf.Clamp(i, 0, RollChances.Length)]; i++)
			{
				num2++;
			}
		}
		return num2;
	}

	public void CreateForPlayer(Item item, BasePlayer player)
	{
		if (!((Object)(object)player == (Object)null) || !CraftedItemsOnly)
		{
			int cap = 0;
			if ((Object)(object)player != (Object)null)
			{
				cap = GetRandomSlotCount(Mathf.Clamp01(player.modifiers.GetValue(Modifier.ModifierType.Crafting_Quality)), MinSlots, MaxSlots);
			}
			CreateAtCapacity(cap, item);
		}
	}

	public void SetSlotAmount(Item item, int amount)
	{
		if (item.contents != null)
		{
			item.contents.capacity = amount;
			item.MarkDirty();
		}
		else
		{
			CreateAtCapacity(amount, item);
		}
	}

	public void CreateAtCapacity(int cap, Item item)
	{
		capacity = cap;
		if (capacity != 0)
		{
			CreateContents(item);
			if (item != null && item.contents != null)
			{
				item.contents.canAcceptItem = CanAcceptArmorItem;
			}
		}
	}

	public override void OnItemCreated(Item item)
	{
		if (capacity > 0 && item != null && item.contents != null)
		{
			item.contents.canAcceptItem = CanAcceptArmorItem;
		}
	}

	protected bool CanAcceptArmorItem(Item item, int count)
	{
		if (item == null || (Object)(object)item.info == (Object)null)
		{
			return false;
		}
		if ((Object)(object)((Component)item.info).GetComponent<ItemModArmorInsert>() == (Object)null)
		{
			return false;
		}
		return true;
	}

	public float TotalSpeedReduction(Item item)
	{
		if (item == null)
		{
			return 0f;
		}
		if (item.contents == null)
		{
			return 0f;
		}
		if (item.contents.itemList == null)
		{
			return 0f;
		}
		float num = 0f;
		ItemModArmorInsert itemModArmorInsert = default(ItemModArmorInsert);
		foreach (Item item2 in item.contents.itemList)
		{
			if (((Component)item2.info).TryGetComponent<ItemModArmorInsert>(ref itemModArmorInsert))
			{
				num += itemModArmorInsert.SpeedReduction;
			}
		}
		return num;
	}

	public float GetProtection(Item item, DamageType damageType)
	{
		if (item == null)
		{
			return 0f;
		}
		if (item.contents == null)
		{
			return 0f;
		}
		if (item.contents.itemList == null)
		{
			return 0f;
		}
		float num = 0f;
		ItemModArmorInsert itemModArmorInsert = default(ItemModArmorInsert);
		foreach (Item item2 in item.contents.itemList)
		{
			if (((Component)item2.info).TryGetComponent<ItemModArmorInsert>(ref itemModArmorInsert))
			{
				num += itemModArmorInsert.protectionProperties.amounts[(int)damageType];
			}
		}
		return num;
	}

	public void CollectProtection(Item item, ProtectionProperties protection)
	{
		if (item == null || item.contents == null || (Object)(object)protection == (Object)null)
		{
			return;
		}
		ItemModArmorInsert itemModArmorInsert = default(ItemModArmorInsert);
		foreach (Item item2 in item.contents.itemList)
		{
			if (((Component)item2.info).TryGetComponent<ItemModArmorInsert>(ref itemModArmorInsert) && !((Object)(object)itemModArmorInsert.protectionProperties == (Object)null))
			{
				protection.Add(itemModArmorInsert.protectionProperties, 1f);
			}
		}
	}
}


using System;

public class ItemModContainerRads : ItemModContainer
{
	public override void OnItemCreated(Item item)
	{
		base.OnItemCreated(item);
		if (item != null && item.contents != null)
		{
			CountRads(item.contents);
			ItemContainer contents = item.contents;
			contents.onItemParentChanged = (Action<Item, Item>)Delegate.Combine(contents.onItemParentChanged, new Action<Item, Item>(OnItemParentChanged));
			ItemContainer contents2 = item.contents;
			contents2.onItemRadiationChanged = (Action<Item, float>)Delegate.Combine(contents2.onItemRadiationChanged, new Action<Item, float>(OnItemRadiationChanged));
			ItemContainer contents3 = item.contents;
			contents3.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(contents3.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
			ItemContainer contents4 = item.contents;
			contents4.onItemAddedToStack = (Action<Item, int>)Delegate.Combine(contents4.onItemAddedToStack, new Action<Item, int>(OnItemAddedToStack));
			ItemContainer contents5 = item.contents;
			contents5.onItemRemovedFromStack = (Action<Item, int>)Delegate.Combine(contents5.onItemRemovedFromStack, new Action<Item, int>(OnItemRemovedFromStack));
		}
	}

	public override void OnRemove(Item item)
	{
		base.OnRemove(item);
		if (item != null && item.contents != null)
		{
			ItemContainer contents = item.contents;
			contents.onItemParentChanged = (Action<Item, Item>)Delegate.Remove(contents.onItemParentChanged, new Action<Item, Item>(OnItemParentChanged));
			ItemContainer contents2 = item.contents;
			contents2.onItemRadiationChanged = (Action<Item, float>)Delegate.Remove(contents2.onItemRadiationChanged, new Action<Item, float>(OnItemRadiationChanged));
			ItemContainer contents3 = item.contents;
			contents3.onItemAddedRemoved = (Action<Item, bool>)Delegate.Remove(contents3.onItemAddedRemoved, new Action<Item, bool>(OnItemAddedRemoved));
			ItemContainer contents4 = item.contents;
			contents4.onItemAddedToStack = (Action<Item, int>)Delegate.Remove(contents4.onItemAddedToStack, new Action<Item, int>(OnItemAddedToStack));
			ItemContainer contents5 = item.contents;
			contents5.onItemRemovedFromStack = (Action<Item, int>)Delegate.Remove(contents5.onItemRemovedFromStack, new Action<Item, int>(OnItemRemovedFromStack));
		}
	}

	public override void OnParentChanged(Item item)
	{
		ProcessRadCountFromParent(item);
	}

	private void OnItemParentChanged(Item parent, Item child)
	{
		ProcessRadCountFromParent(parent);
	}

	private void OnItemRadiationChanged(Item item, float rads)
	{
		ProcessRadCountFromChild(item);
	}

	private void OnItemAddedRemoved(Item childItem, bool added)
	{
		if (childItem != null)
		{
			ProcessRadCountFromChild(childItem);
		}
	}

	private void OnItemRemovedFromStack(Item childItem, int amount)
	{
		ProcessRadCountFromChild(childItem);
	}

	private void OnItemAddedToStack(Item childItem, int amount)
	{
		ProcessRadCountFromChild(childItem);
	}

	private void ProcessRadCountFromChild(Item childItem)
	{
		ItemContainer parent = childItem.parent;
		if (parent != null)
		{
			CountRads(parent);
		}
	}

	private void ProcessRadCountFromParent(Item item, bool skipEvent = false)
	{
		ItemContainer contents = item.contents;
		if (contents != null)
		{
			CountRads(contents, skipEvent);
		}
	}

	private void CountRads(ItemContainer container, bool skipEvent = false)
	{
		Item parent = container.parent;
		if (container?.itemList == null)
		{
			return;
		}
		if (container.itemList.Count == 0)
		{
			parent.radioactivity = 0f;
			if (!skipEvent)
			{
				parent.parent?.onItemRadiationChanged?.Invoke(parent, 0f);
			}
		}
		else
		{
			if (container.itemList[0] == null)
			{
				return;
			}
			float num = 0f;
			foreach (Item item in container.itemList)
			{
				num += (float)item.amount * item.radioactivity;
			}
			if (parent == null)
			{
				return;
			}
			if (num > 0f)
			{
				if (!parent.HasFlag(Item.Flag.Radioactive))
				{
					parent.SetFlag(Item.Flag.Radioactive, b: true);
				}
			}
			else if (parent.HasFlag(Item.Flag.Radioactive))
			{
				parent.SetFlag(Item.Flag.Radioactive, b: false);
			}
			parent.radioactivity = num;
			if (parent.parent != null && !skipEvent)
			{
				parent.parent.onItemRadiationChanged?.Invoke(parent, num);
			}
		}
	}
}


using System;
using UnityEngine;

public class ItemModContainerRestriction : ItemMod
{
	[Flags]
	public enum SlotFlags
	{
		Map = 1
	}

	[InspectorFlags]
	public SlotFlags slotFlags;

	public bool CanExistWith(ItemModContainerRestriction other)
	{
		if ((Object)(object)other == (Object)null)
		{
			return true;
		}
		if ((slotFlags & other.slotFlags) != 0)
		{
			return false;
		}
		return true;
	}
}


using System;

[Flags]
public enum SlotFlags
{
	Map = 1
}


using UnityEngine;

public class ItemModConversation : ItemMod
{
	public static readonly Phrase SquakTitle = new Phrase("squak", "MISSING SQUAK PHRASE");

	public static readonly Phrase SquakDesc = new Phrase("squak_desc", "MISSING SQUAK DESC PHRASE");

	public ConversationData conversationData;

	public GameObjectRef conversationEntity;

	public GameObjectRef squakEffect;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		if (command == "squak")
		{
			if (squakEffect.isValid)
			{
				Effect.server.Run(squakEffect.resourcePath, player.eyes.position);
			}
			Debug.Log((object)"Starting conversation");
			BaseEntity baseEntity = GameManager.server.CreateEntity(conversationEntity.resourcePath, ((Component)player).transform.position + Vector3.up * -2f);
			((Component)baseEntity).GetComponent<NPCMissionProvider>().conversations[0] = conversationData;
			baseEntity.Spawn();
			((MonoBehaviour)baseEntity).Invoke("Kill", 600f);
		}
	}
}


using Facepunch.Rust;
using UnityEngine;

public class ItemModCookable : ItemMod
{
	[ItemSelector(ItemCategory.All)]
	public ItemDefinition becomeOnCooked;

	public float cookTime = 30f;

	public int amountOfBecome = 1;

	public int lowTemp;

	public int highTemp;

	public bool setCookingFlag;

	public void OnValidate()
	{
		if (amountOfBecome < 1)
		{
			amountOfBecome = 1;
		}
		if ((Object)(object)becomeOnCooked == (Object)null)
		{
			Debug.LogWarning((object)("[ItemModCookable] becomeOnCooked is unset! [" + ((Object)this).name + "]"), (Object)(object)((Component)this).gameObject);
		}
	}

	public bool CanBeCookedByAtTemperature(float temperature)
	{
		if (temperature > (float)lowTemp)
		{
			return temperature < (float)highTemp;
		}
		return false;
	}

	private void CycleCooking(Item item, float delta)
	{
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		if (!CanBeCookedByAtTemperature(item.temperature) || item.cookTimeLeft < 0f)
		{
			if (setCookingFlag && item.HasFlag(Item.Flag.Cooking))
			{
				item.SetFlag(Item.Flag.Cooking, b: false);
				item.MarkDirty();
			}
			return;
		}
		if (setCookingFlag && !item.HasFlag(Item.Flag.Cooking))
		{
			item.SetFlag(Item.Flag.Cooking, b: true);
			item.MarkDirty();
		}
		item.cookTimeLeft -= delta;
		if (item.cookTimeLeft > 0f)
		{
			item.MarkDirty();
			return;
		}
		float num = item.cookTimeLeft * -1f;
		int num2 = 1 + Mathf.FloorToInt(num / cookTime);
		item.cookTimeLeft = cookTime - num % cookTime;
		BaseOven baseOven = item.GetEntityOwner() as BaseOven;
		num2 = Mathf.Min(num2, item.amount);
		if (item.amount > num2)
		{
			item.amount -= num2;
			item.MarkDirty();
		}
		else
		{
			item.Remove();
		}
		Analytics.Azure.AddPendingItems(baseOven, item.info.shortname, num2, "smelt");
		if (!((Object)(object)becomeOnCooked != (Object)null))
		{
			return;
		}
		Item item2 = ItemManager.Create(becomeOnCooked, amountOfBecome * num2, 0uL);
		Analytics.Azure.AddPendingItems(baseOven, item2.info.shortname, item2.amount, "smelt", consumed: false);
		if ((Object)(object)item.parent.entityOwner != (Object)null && item.parent.entityOwner.net.group.restricted)
		{
			TutorialIsland closestTutorialIsland = TutorialIsland.GetClosestTutorialIsland(((Component)item.parent.entityOwner).transform.position, 50f);
			if ((Object)(object)closestTutorialIsland != (Object)null)
			{
				BasePlayer basePlayer = closestTutorialIsland.ForPlayer.Get(serverside: true);
				if ((Object)(object)basePlayer != (Object)null)
				{
					basePlayer.ProcessMissionEvent(BaseMission.MissionEventType.COOK, new BaseMission.MissionEventPayload
					{
						IntIdentifier = item2.info.itemid,
						WorldPosition = ((Component)item.parent.entityOwner).transform.position,
						NetworkIdentifier = item.parent.entityOwner.net.ID
					}, item2.amount);
				}
			}
		}
		if (item2 != null && !item2.MoveToContainer(item.parent) && !item2.MoveToContainer(item.parent))
		{
			item2.Drop(item.parent.dropPosition, item.parent.dropVelocity);
			if (Object.op_Implicit((Object)(object)item.parent.entityOwner) && (Object)(object)baseOven != (Object)null)
			{
				baseOven.OvenFull();
			}
		}
	}

	public override void OnItemCreated(Item itemcreated)
	{
		itemcreated.cookTimeLeft = cookTime;
		itemcreated.onCycle += CycleCooking;
	}
}


using UnityEngine;

public class ItemModCycle : ItemMod
{
	public ItemMod[] actions;

	public float timeBetweenCycles = 1f;

	public float timerStart;

	public bool onlyAdvanceTimerWhenPass;

	public override void OnItemCreated(Item itemcreated)
	{
		float timeTaken = timerStart;
		itemcreated.onCycle += delegate(Item item, float delta)
		{
			if (!onlyAdvanceTimerWhenPass || CanCycle(item))
			{
				timeTaken += delta;
				if (!(timeTaken < timeBetweenCycles))
				{
					timeTaken = 0f;
					if (onlyAdvanceTimerWhenPass || CanCycle(item))
					{
						CustomCycle(item, delta);
					}
				}
			}
		};
	}

	private bool CanCycle(Item item)
	{
		ItemMod[] array = actions;
		for (int i = 0; i < array.Length; i++)
		{
			if (!array[i].CanDoAction(item, item.GetOwnerPlayer()))
			{
				return false;
			}
		}
		return true;
	}

	public void CustomCycle(Item item, float delta)
	{
		BasePlayer ownerPlayer = item.GetOwnerPlayer();
		ItemMod[] array = actions;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].DoAction(item, ownerPlayer);
		}
	}

	private void OnValidate()
	{
		if (actions == null)
		{
			Debug.LogWarning((object)"ItemModMenuOption: actions is null", (Object)(object)((Component)this).gameObject);
		}
	}
}


using Oxide.Core;
using UnityEngine;

public class ItemModDeployable : MonoBehaviour
{
	public GameObjectRef entityPrefab = new GameObjectRef();

	[Header("Tooltips")]
	public bool showCrosshair;

	public string UnlockAchievement;

	public Deployable GetDeployable(BaseEntity entity)
	{
		if ((Object)(object)entity.gameManager.FindPrefab(entityPrefab.resourcePath) == (Object)null)
		{
			return null;
		}
		return entity.prefabAttribute.Find<Deployable>(entityPrefab.resourceID);
	}

	internal void OnDeployed(BaseEntity ent, BasePlayer player)
	{
		if (player.IsValid() && !string.IsNullOrEmpty(UnlockAchievement))
		{
			player.GiveAchievement(UnlockAchievement);
		}
		if (ent is BuildingPrivlidge buildingPrivlidge && Interface.CallHook("OnCupboardAuthorize", (object)buildingPrivlidge, (object)player) == null)
		{
			buildingPrivlidge.AddPlayer(player, player.userID);
		}
	}
}


using UnityEngine;

public class ItemModEntity : ItemMod
{
	public GameObjectRef entityPrefab = new GameObjectRef();

	public string defaultBone;

	public bool playerOnlyEntity;

	public bool destroyEntityWhenBroken;

	public override void OnChanged(Item item)
	{
		HeldEntity heldEntity = item.GetHeldEntity() as HeldEntity;
		if ((Object)(object)heldEntity != (Object)null)
		{
			heldEntity.OnItemChanged(item);
		}
		base.OnChanged(item);
	}

	public override void OnItemCreated(Item item)
	{
		if ((Object)(object)item.GetHeldEntity() == (Object)null && !playerOnlyEntity)
		{
			CreateEntity(item);
		}
	}

	private void CreateEntity(Item item)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (!destroyEntityWhenBroken || !item.isBroken)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(entityPrefab.resourcePath);
			if ((Object)(object)baseEntity == (Object)null)
			{
				Debug.LogWarning((object)("Couldn't create item entity " + item.info.displayName.english + " (" + entityPrefab.resourcePath + ")"));
			}
			else
			{
				baseEntity.skinID = item.skin;
				baseEntity.limitNetworking = true;
				baseEntity.Spawn();
				item.SetHeldEntity(baseEntity);
			}
		}
	}

	public override void OnRemove(Item item)
	{
		BaseEntity heldEntity = item.GetHeldEntity();
		if (!((Object)(object)heldEntity == (Object)null))
		{
			heldEntity.Kill();
			item.SetHeldEntity(null);
		}
	}

	private bool ParentToParent(Item item, BaseEntity ourEntity)
	{
		Item parentItem = item.parentItem;
		if (parentItem == null)
		{
			return false;
		}
		if (parentItem.IsBackpack())
		{
			return false;
		}
		BaseEntity baseEntity = parentItem.GetWorldEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			baseEntity = item.parentItem.GetHeldEntity();
		}
		ourEntity.SetFlag(BaseEntity.Flags.Disabled, b: false);
		ourEntity.limitNetworking = false;
		ourEntity.SetParent(baseEntity, defaultBone);
		return true;
	}

	private bool ParentToPlayer(Item item, BaseEntity ourEntity)
	{
		HeldEntity heldEntity = ourEntity as HeldEntity;
		if ((Object)(object)heldEntity == (Object)null)
		{
			return false;
		}
		BasePlayer basePlayer = item.GetRootContainer()?.GetOwnerPlayer();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			heldEntity.SetOwnerPlayer(basePlayer);
			return true;
		}
		heldEntity.ClearOwnerPlayer();
		return true;
	}

	public override void OnParentChanged(Item item)
	{
		BaseEntity baseEntity = item.GetHeldEntity();
		if (playerOnlyEntity)
		{
			BasePlayer ownerPlayer = item.GetOwnerPlayer();
			if ((Object)(object)ownerPlayer == (Object)null && (Object)(object)baseEntity != (Object)null)
			{
				baseEntity.Kill();
				baseEntity = null;
				item.SetHeldEntity(null);
			}
			else if ((Object)(object)ownerPlayer != (Object)null && (Object)(object)baseEntity == (Object)null)
			{
				CreateEntity(item);
				baseEntity = item.GetHeldEntity();
			}
		}
		if (!((Object)(object)baseEntity == (Object)null) && !ParentToParent(item, baseEntity) && !ParentToPlayer(item, baseEntity))
		{
			baseEntity.SetParent(null);
			baseEntity.limitNetworking = true;
			baseEntity.SetFlag(BaseEntity.Flags.Disabled, b: true);
		}
	}

	public override void CollectedForCrafting(Item item, BasePlayer crafter)
	{
		BaseEntity heldEntity = item.GetHeldEntity();
		if (!((Object)(object)heldEntity == (Object)null))
		{
			HeldEntity heldEntity2 = heldEntity as HeldEntity;
			if (!((Object)(object)heldEntity2 == (Object)null))
			{
				heldEntity2.CollectedForCrafting(item, crafter);
			}
		}
	}

	public override void ReturnedFromCancelledCraft(Item item, BasePlayer crafter)
	{
		BaseEntity heldEntity = item.GetHeldEntity();
		if (!((Object)(object)heldEntity == (Object)null))
		{
			HeldEntity heldEntity2 = heldEntity as HeldEntity;
			if (!((Object)(object)heldEntity2 == (Object)null))
			{
				heldEntity2.ReturnedFromCancelledCraft(item, crafter);
			}
		}
	}
}


using UnityEngine;

public class ItemModEntityReference : MonoBehaviour
{
	public GameObjectRef entityPrefab;
}


public class ItemModEntityThrow : ItemMod
{
	public GameObjectRef entityPrefab;

	public float throwVelocity = 5f;

	public bool consumeOnThrow = true;
}


using UnityEngine;

public class ItemModFishable : ItemMod
{
	public bool CanBeFished = true;

	[Header("Catching Behaviour")]
	public float StrainModifier = 1f;

	public float MoveMultiplier = 1f;

	public float ReelInSpeedMultiplier = 1f;

	public float CatchWaitTimeMultiplier = 1f;

	[Header("Catch Criteria")]
	public float MinimumBaitLevel;

	public float MaximumBaitLevel;

	public float MinimumWaterDepth;

	public float MaximumWaterDepth;

	[InspectorFlags]
	public WaterBody.FishingTag RequiredTag;

	[Range(0f, 1f)]
	public float Chance;

	public string SteamStatName;

	[Header("Mounting")]
	public bool CanBeMounted;

	public int FishMountIndex;
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ItemModFoodSpoiling : ItemMod
{
	public class FoodSpoilingWorkQueue : PersistentObjectWorkQueue<Item>
	{
		private Dictionary<Item, TimeSince> lastUpdated = new Dictionary<Item, TimeSince>();

		protected override void RunJob(Item foodItem)
		{
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			float timeToApply = 0f;
			if (lastUpdated.TryGetValue(foodItem, out var value))
			{
				timeToApply = TimeSince.op_Implicit(value);
				lastUpdated[foodItem] = TimeSince.op_Implicit(0f);
			}
			else
			{
				lastUpdated.Add(foodItem, TimeSince.op_Implicit(0f));
			}
			DeductTimeFromFoodItem(foodItem, timeToApply, setDirty: false);
		}

		public static void DeductTimeFromFoodItem(Item foodItem, float timeToApply, bool setDirty)
		{
			//IL_019b: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_0128: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_013e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0148: Unknown result type (might be due to invalid IL or missing references)
			//IL_014d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0152: Unknown result type (might be due to invalid IL or missing references)
			//IL_0159: Unknown result type (might be due to invalid IL or missing references)
			//IL_015f: Unknown result type (might be due to invalid IL or missing references)
			if (foodItem.instanceData != null)
			{
				float dataFloat = foodItem.instanceData.dataFloat;
				float num = 1f;
				IFoodSpoilModifier foodSpoilModifier = default(IFoodSpoilModifier);
				if (foodItem.parent != null && (Object)(object)foodItem.parent.entityOwner != (Object)null && ((Component)foodItem.parent.entityOwner).TryGetComponent<IFoodSpoilModifier>(ref foodSpoilModifier))
				{
					num = foodSpoilModifier.GetSpoilMultiplier(foodItem);
				}
				bool flag = num != 1f;
				if (foodItem.HasFlag(Item.Flag.Refrigerated) != flag)
				{
					foodItem.SetFlag(Item.Flag.Refrigerated, flag);
					foodItem.MarkDirty();
					if ((Object)(object)foodItem.GetEntityOwner() != (Object)null)
					{
						foodItem.GetEntityOwner().SendNetworkUpdate();
					}
				}
				InstanceData instanceData = foodItem.instanceData;
				instanceData.dataFloat -= timeToApply * num;
				if (!(foodItem.instanceData.dataFloat <= 0f) || !(dataFloat > 0f))
				{
					return;
				}
				int amount = foodItem.amount;
				ItemContainer parent = foodItem.parent;
				foodItem.RemoveFromContainer();
				Item item = ItemManager.Create(((Component)foodItem.info).GetComponent<ItemModFoodSpoiling>().SpoilItem, amount, 0uL);
				if (parent != null && !parent.GiveItem(item))
				{
					if ((Object)(object)parent.entityOwner != (Object)null)
					{
						item.Drop(((Component)parent.entityOwner).transform.position + Vector3.up * ((Bounds)(ref parent.entityOwner.bounds)).size.y, Vector3.zero);
					}
					else
					{
						item.Remove();
					}
				}
				else if (item.parent == null)
				{
					BaseEntity worldEntity = foodItem.GetWorldEntity();
					if ((Object)(object)worldEntity != (Object)null)
					{
						item.Drop(((Component)worldEntity).transform.position, Vector3.zero, ((Component)worldEntity).transform.rotation);
					}
					else
					{
						item.Remove();
					}
				}
				foodItem.Remove();
				ItemManager.DoRemoves();
			}
			else if (setDirty)
			{
				foodItem.MarkDirty();
				if ((Object)(object)foodItem.GetEntityOwner() != (Object)null)
				{
					foodItem.GetEntityOwner().SendNetworkUpdate();
				}
			}
		}
	}

	public float TotalSpoilTimeHours = 12f;

	public ItemDefinition SpoilItem;

	public static FoodSpoilingWorkQueue foodSpoilItems = new FoodSpoilingWorkQueue();

	public override void OnItemCreated(Item item)
	{
		base.OnItemCreated(item);
		if (item.instanceData == null)
		{
			item.instanceData = Pool.Get<InstanceData>();
			item.instanceData.dataFloat = 3600f * TotalSpoilTimeHours;
			item.instanceData.ShouldPool = false;
		}
		((PersistentObjectWorkQueue<Item>)foodSpoilItems).Add(item);
	}

	public override void OnRemove(Item item)
	{
		base.OnRemove(item);
		((PersistentObjectWorkQueue<Item>)foodSpoilItems).Remove(item);
	}

	public static void DeductTimeFromAll(TimeSpan span)
	{
		((PersistentObjectWorkQueue<Item>)foodSpoilItems).RunOnAll((Action<Item>)delegate(Item foodItem)
		{
			FoodSpoilingWorkQueue.DeductTimeFromFoodItem(foodItem, (float)span.TotalSeconds, setDirty: true);
		});
	}
}


using System.Collections.Generic;
using ProtoBuf;
using UnityEngine;

public class FoodSpoilingWorkQueue : PersistentObjectWorkQueue<Item>
{
	private Dictionary<Item, TimeSince> lastUpdated = new Dictionary<Item, TimeSince>();

	protected override void RunJob(Item foodItem)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		float timeToApply = 0f;
		if (lastUpdated.TryGetValue(foodItem, out var value))
		{
			timeToApply = TimeSince.op_Implicit(value);
			lastUpdated[foodItem] = TimeSince.op_Implicit(0f);
		}
		else
		{
			lastUpdated.Add(foodItem, TimeSince.op_Implicit(0f));
		}
		DeductTimeFromFoodItem(foodItem, timeToApply, setDirty: false);
	}

	public static void DeductTimeFromFoodItem(Item foodItem, float timeToApply, bool setDirty)
	{
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		if (foodItem.instanceData != null)
		{
			float dataFloat = foodItem.instanceData.dataFloat;
			float num = 1f;
			IFoodSpoilModifier foodSpoilModifier = default(IFoodSpoilModifier);
			if (foodItem.parent != null && (Object)(object)foodItem.parent.entityOwner != (Object)null && ((Component)foodItem.parent.entityOwner).TryGetComponent<IFoodSpoilModifier>(ref foodSpoilModifier))
			{
				num = foodSpoilModifier.GetSpoilMultiplier(foodItem);
			}
			bool flag = num != 1f;
			if (foodItem.HasFlag(Item.Flag.Refrigerated) != flag)
			{
				foodItem.SetFlag(Item.Flag.Refrigerated, flag);
				foodItem.MarkDirty();
				if ((Object)(object)foodItem.GetEntityOwner() != (Object)null)
				{
					foodItem.GetEntityOwner().SendNetworkUpdate();
				}
			}
			InstanceData instanceData = foodItem.instanceData;
			instanceData.dataFloat -= timeToApply * num;
			if (!(foodItem.instanceData.dataFloat <= 0f) || !(dataFloat > 0f))
			{
				return;
			}
			int amount = foodItem.amount;
			ItemContainer parent = foodItem.parent;
			foodItem.RemoveFromContainer();
			Item item = ItemManager.Create(((Component)foodItem.info).GetComponent<ItemModFoodSpoiling>().SpoilItem, amount, 0uL);
			if (parent != null && !parent.GiveItem(item))
			{
				if ((Object)(object)parent.entityOwner != (Object)null)
				{
					item.Drop(((Component)parent.entityOwner).transform.position + Vector3.up * ((Bounds)(ref parent.entityOwner.bounds)).size.y, Vector3.zero);
				}
				else
				{
					item.Remove();
				}
			}
			else if (item.parent == null)
			{
				BaseEntity worldEntity = foodItem.GetWorldEntity();
				if ((Object)(object)worldEntity != (Object)null)
				{
					item.Drop(((Component)worldEntity).transform.position, Vector3.zero, ((Component)worldEntity).transform.rotation);
				}
				else
				{
					item.Remove();
				}
			}
			foodItem.Remove();
			ItemManager.DoRemoves();
		}
		else if (setDirty)
		{
			foodItem.MarkDirty();
			if ((Object)(object)foodItem.GetEntityOwner() != (Object)null)
			{
				foodItem.GetEntityOwner().SendNetworkUpdate();
			}
		}
	}
}


public interface IFoodSpoilModifier
{
	float GetSpoilMultiplier(Item item);
}


public class ItemModForceSelectFromBelt : ItemMod
{
	public bool IfIsOn = true;

	public bool IfPlayerRestrained = true;
}


public class ItemModForceWearFromBelt : ItemMod
{
	public bool IfPlayerRestrained = true;
}


public interface IAirSupply
{
	ItemModGiveOxygen.AirSupplyType AirType { get; }

	float GetAirTimeRemaining(Item forItem);
}


using UnityEngine;

public class ItemModGiveOxygen : ItemMod, IAirSupply
{
	public enum AirSupplyType
	{
		Lungs,
		ScubaTank,
		Submarine
	}

	public AirSupplyType airType = AirSupplyType.ScubaTank;

	public int amountToConsume = 1;

	public GameObjectRef inhaleEffect;

	public GameObjectRef exhaleEffect;

	public GameObjectRef bubblesEffect;

	private float cycleTime;

	private bool inhaled;

	public AirSupplyType AirType => airType;

	public float GetAirTimeRemaining(Item forItem)
	{
		return ConditionToTime(forItem);
	}

	public override void ModInit()
	{
		base.ModInit();
		cycleTime = 1f;
		ItemMod[] array = siblingMods;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] is ItemModCycle itemModCycle)
			{
				cycleTime = itemModCycle.timeBetweenCycles;
			}
		}
	}

	public override void DoAction(Item item, BasePlayer player)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		if (!item.hasCondition || item.conditionNormalized == 0f || (Object)(object)player == (Object)null)
		{
			return;
		}
		float num = Mathf.Clamp01(0.525f);
		if (!(player.AirFactor() > num) && item.parent != null && item.parent == player.inventory.containerWear)
		{
			Effect.server.Run((!inhaled) ? inhaleEffect.resourcePath : exhaleEffect.resourcePath, player, StringPool.Get("jaw"), Vector3.zero, Vector3.forward);
			inhaled = !inhaled;
			if (!inhaled && WaterLevel.GetWaterDepth(player.eyes.position, waves: true, volumes: true, player) > 3f)
			{
				Effect.server.Run(bubblesEffect.resourcePath, player, StringPool.Get("jaw"), Vector3.zero, Vector3.forward);
			}
			item.LoseCondition(amountToConsume);
			player.metabolism.oxygen.Add(1f);
		}
	}

	private float ConditionToTime(Item item)
	{
		if (item == null || !item.hasCondition)
		{
			return 0f;
		}
		return item.condition * ((float)amountToConsume / cycleTime);
	}
}


public enum AirSupplyType
{
	Lungs,
	ScubaTank,
	Submarine
}


using UnityEngine;

public class ItemModHABEquipment : ItemMod
{
	public enum SlotType
	{
		Basic,
		Armor
	}

	public SlotType slot;

	public GameObjectRef Prefab;

	public int MaxEquipCount = 1;

	public bool GroundEquipOnly = true;

	public float DelayNextUpgradeOnRemoveDuration = 60f;

	public Phrase MenuOptionTitle;

	public Phrase MenuOptionDesc;

	public bool CanEquipToHAB(HotAirBalloon hab)
	{
		if (!hab.CanModifyEquipment())
		{
			return false;
		}
		if (hab.GetEquipmentCount(this) >= MaxEquipCount)
		{
			return false;
		}
		if (GroundEquipOnly && !hab.Grounded)
		{
			return false;
		}
		if (hab.NextUpgradeTime > Time.time)
		{
			return false;
		}
		return true;
	}

	public void ApplyToHAB(HotAirBalloon hab)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (hab.isServer && CanEquipToHAB(hab) && Prefab.isValid)
		{
			HotAirBalloonEquipment hotAirBalloonEquipment = GameManager.server.CreateEntity(Prefab.resourcePath, ((Component)hab).transform.position, ((Component)hab).transform.rotation) as HotAirBalloonEquipment;
			if (Object.op_Implicit((Object)(object)hotAirBalloonEquipment))
			{
				hotAirBalloonEquipment.SetParent(hab, worldPositionStays: true);
				hotAirBalloonEquipment.Spawn();
				hotAirBalloonEquipment.DelayNextUpgradeOnRemoveDuration = DelayNextUpgradeOnRemoveDuration;
			}
		}
	}
}


public enum SlotType
{
	Basic,
	Armor
}


public class ItemModHead : ItemModAssociatedEntity<HeadEntity>
{
	protected override bool AllowNullParenting => true;
}


public class ItemModHideInfoPanel : ItemMod
{
}


public class ItemModKeycard : ItemMod
{
	public int accessLevel;
}


using UnityEngine;

public class ItemModMenuOption : ItemMod
{
	public string commandName;

	public ItemMod actionTarget;

	public BaseEntity.Menu.Option option;

	[Tooltip("If true, this is the command that will run when an item is 'selected' on the toolbar")]
	public bool isPrimaryOption = true;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (!(command != commandName) && actionTarget.CanDoAction(item, player))
		{
			actionTarget.DoAction(item, player);
		}
	}

	private void OnValidate()
	{
		if ((Object)(object)actionTarget == (Object)null)
		{
			Debug.LogWarning((object)"ItemModMenuOption: actionTarget is null!", (Object)(object)((Component)this).gameObject);
		}
		if (string.IsNullOrEmpty(commandName))
		{
			Debug.LogWarning((object)"ItemModMenuOption: commandName can't be empty!", (Object)(object)((Component)this).gameObject);
		}
		if ((Object)(object)option.icon == (Object)null)
		{
			Debug.LogWarning((object)("No icon set for ItemModMenuOption " + ((Object)((Component)this).gameObject).name), (Object)(object)((Component)this).gameObject);
		}
	}
}


using UnityEngine;

[RequireComponent(typeof(ItemModWearable))]
public class ItemModPaintable : ItemModAssociatedEntity<PaintedItemStorageEntity>
{
	public static readonly Phrase ItemPaintTitle = new Phrase("item.paint", "Paint");

	public static readonly Phrase ItemPaintDesc = new Phrase("item.paint.desc", "Paint on this item.");

	public GameObjectRef ChangeSignTextDialog;

	public MeshPaintableSource[] PaintableSources;

	protected override bool AllowNullParenting => true;

	protected override bool OwnedByParentPlayer => true;
}


using UnityEngine;

public class ItemModPetStats : ItemMod
{
	[Tooltip("Speed modifier. Value, not percentage.")]
	public float SpeedModifier;

	[Tooltip("HP amount to modify max health by. Value, not percentage.")]
	public float MaxHealthModifier;

	[Tooltip("Damage amount to modify base attack damage by. Value, not percentage.")]
	public float AttackDamageModifier;

	[Tooltip("Attack rate (seconds) to modify base attack rate by. Value, not percentage.")]
	public float AttackRateModifier;

	public void Apply(BasePet pet)
	{
		if (!((Object)(object)pet == (Object)null))
		{
			pet.SetMaxHealth(pet.MaxHealth() + MaxHealthModifier);
			if ((Object)(object)pet.Brain != (Object)null && (Object)(object)pet.Brain.Navigator != (Object)null)
			{
				pet.Brain.Navigator.Speed += SpeedModifier;
			}
			pet.BaseAttackRate += AttackRateModifier;
			pet.BaseAttackDamge += AttackDamageModifier;
		}
	}
}


using Rust;
using UnityEngine;

public class ItemModProjectile : MonoBehaviour
{
	public GameObjectRef projectileObject = new GameObjectRef();

	public ItemModProjectileMod[] mods;

	public AmmoTypes ammoType;

	public int numProjectiles = 1;

	public float projectileSpread;

	public float projectileVelocity = 100f;

	public float projectileVelocitySpread;

	public bool useCurve;

	public AnimationCurve spreadScalar;

	public GameObjectRef attackEffectOverride;

	public float barrelConditionLoss;

	public string category = "bullet";

	public float GetRandomVelocity()
	{
		return projectileVelocity + Random.Range(0f - projectileVelocitySpread, projectileVelocitySpread);
	}

	public float GetSpreadScalar()
	{
		if (useCurve)
		{
			return spreadScalar.Evaluate(Random.Range(0f, 1f));
		}
		return 1f;
	}

	public float GetIndexedSpreadScalar(int shotIndex, int maxShots)
	{
		float num = 0f;
		if (shotIndex != -1)
		{
			float num2 = 1f / (float)maxShots;
			num = (float)shotIndex * num2;
		}
		else
		{
			num = Random.Range(0f, 1f);
		}
		return spreadScalar.Evaluate(num);
	}

	public float GetAverageVelocity()
	{
		return projectileVelocity;
	}

	public float GetMinVelocity()
	{
		return projectileVelocity - projectileVelocitySpread;
	}

	public float GetMaxVelocity()
	{
		return projectileVelocity + projectileVelocitySpread;
	}

	public bool IsAmmo(AmmoTypes ammo)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Invalid comparison between Unknown and I4
		return (ammoType & ammo) > 0;
	}

	public virtual void ServerProjectileHit(HitInfo info)
	{
		if (mods == null)
		{
			return;
		}
		ItemModProjectileMod[] array = mods;
		foreach (ItemModProjectileMod itemModProjectileMod in array)
		{
			if (!((Object)(object)itemModProjectileMod == (Object)null))
			{
				itemModProjectileMod.ServerProjectileHit(info);
			}
		}
	}

	public virtual void ServerProjectileHitEntity(HitInfo hitInfo)
	{
		if (mods == null)
		{
			return;
		}
		ItemModProjectileMod[] array = mods;
		foreach (ItemModProjectileMod itemModProjectileMod in array)
		{
			if (!((Object)(object)itemModProjectileMod == (Object)null))
			{
				itemModProjectileMod.ServerProjectileHitEntity(hitInfo);
			}
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class ItemModProjectileDart : ItemModProjectileMod
{
	public List<ModifierDefintion> modifiers;

	public List<ItemModConsumable.ConsumableEffect> effects;

	public float TurretEffectScale = 0.5f;

	public float TurretDurationScale = 0.5f;

	public override void ServerProjectileHitEntity(HitInfo info)
	{
		base.ServerProjectileHitEntity(info);
		BasePlayer basePlayer = info.HitEntity as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		float effectScale = 1f;
		float durationScale = 1f;
		if ((Object)(object)info.Initiator != (Object)null && info.Initiator is AutoTurret)
		{
			effectScale = TurretEffectScale;
			durationScale = TurretDurationScale;
		}
		PlayerModifiers.AddToPlayer(basePlayer, modifiers, effectScale, durationScale);
		if (effects == null)
		{
			return;
		}
		foreach (ItemModConsumable.ConsumableEffect effect in effects)
		{
			if (!(Mathf.Clamp01(basePlayer.healthFraction + basePlayer.metabolism.pending_health.Fraction()) > effect.onlyIfHealthLessThan))
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					basePlayer.health += effect.amount;
				}
				else
				{
					basePlayer.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
		}
	}
}


using UnityEngine;

public class ItemModProjectileMod : MonoBehaviour
{
	public virtual void ServerProjectileHit(HitInfo info)
	{
	}

	public virtual void ServerProjectileHitEntity(HitInfo info)
	{
	}
}


using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

public class ItemModProjectileRadialDamage : ItemModProjectileMod
{
	public float radius = 0.5f;

	public DamageTypeEntry damage;

	public GameObjectRef effect;

	public bool ignoreHitObject = true;

	public bool onlyDoors;

	public int vibrationLevel = 2;

	public override void ServerProjectileHit(HitInfo info)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		if (effect.isValid)
		{
			Effect.server.Run(effect.resourcePath, info.HitPositionWorld, info.HitNormalWorld);
		}
		List<BaseCombatEntity> list = Pool.Get<List<BaseCombatEntity>>();
		List<BaseCombatEntity> list2 = Pool.Get<List<BaseCombatEntity>>();
		Vis.Entities(info.HitPositionWorld, radius, list2, 1237003025, (QueryTriggerInteraction)2);
		if (damage.type == DamageType.Explosion)
		{
			SeismicSensor.Notify(info.HitPositionWorld, vibrationLevel);
		}
		foreach (BaseCombatEntity item in list2)
		{
			if (!item.isServer || list.Contains(item) || (onlyDoors && !(item is Door)) || ((Object)(object)item == (Object)(object)info.HitEntity && ignoreHitObject))
			{
				continue;
			}
			item.CenterPoint();
			Vector3 val = item.ClosestPoint(info.HitPositionWorld);
			float num = Vector3.Distance(val, info.HitPositionWorld) / radius;
			if (num > 1f)
			{
				continue;
			}
			float num2 = 1f - num;
			if (!item.IsVisibleAndCanSeeLegacy(info.HitPositionWorld - ((Vector3)(ref info.ProjectileVelocity)).normalized * 0.1f))
			{
				continue;
			}
			Vector3 hitPositionWorld = info.HitPositionWorld;
			Vector3 val2 = val - info.HitPositionWorld;
			if (item.IsVisibleAndCanSeeLegacy(hitPositionWorld - ((Vector3)(ref val2)).normalized * 0.1f))
			{
				list.Add(item);
				BasePlayer component = ((Component)item).GetComponent<BasePlayer>();
				if ((Object)(object)component != (Object)null && component.GetActiveShield(out var foundShield) && (Object)(object)info.Initiator != (Object)null && foundShield.SphereCastAgainstColliders(info.HitPositionWorld, radius))
				{
					foundShield.OnAttacked(new HitInfo(info.Initiator, item, damage.type, damage.amount * num2));
				}
				else
				{
					item.OnAttacked(new HitInfo(info.Initiator, item, damage.type, damage.amount * num2));
				}
			}
		}
		Pool.FreeUnmanaged<BaseCombatEntity>(ref list);
		Pool.FreeUnmanaged<BaseCombatEntity>(ref list2);
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class ItemModProjectileRagdoll : ItemModProjectileMod
{
	public float radius = 0.5f;

	public float velocityInheritFactor = 0.25f;

	public override void ServerProjectileHit(HitInfo info)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Vis.Entities(info.HitPositionWorld, radius, list, 131072, (QueryTriggerInteraction)2);
		foreach (BasePlayer item in list)
		{
			if (item.isServer && !item.IsDead() && !item.InSafeZone())
			{
				Vector3 val;
				if ((Object)(object)info.HitEntity == (Object)(object)item)
				{
					val = info.ProjectileVelocity * velocityInheritFactor;
				}
				else
				{
					Vector3 val2 = ((Component)item).transform.position - info.HitPositionWorld + Vector3.up;
					val = ((Vector3)(ref val2)).normalized * 7.5f;
				}
				item.Ragdoll(item.GetWorldVelocity() + val);
			}
		}
	}
}


using ConVar;
using UnityEngine;

public class ItemModProjectileSpawn : ItemModProjectile
{
	public float createOnImpactChance;

	public GameObjectRef createOnImpact = new GameObjectRef();

	public float spreadAngle = 30f;

	public float spreadVelocityMin = 1f;

	public float spreadVelocityMax = 3f;

	public int numToCreateChances = 1;

	public override void ServerProjectileHit(HitInfo info)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < numToCreateChances; i++)
		{
			if (!createOnImpact.isValid || !(Random.Range(0f, 1f) < createOnImpactChance))
			{
				continue;
			}
			Vector3 hitPositionWorld = info.HitPositionWorld;
			Vector3 pointStart = info.PointStart;
			Vector3 normalized = ((Vector3)(ref info.ProjectileVelocity)).normalized;
			Vector3 normalized2 = ((Vector3)(ref info.HitNormalWorld)).normalized;
			Vector3 val = hitPositionWorld - normalized * 0.1f;
			Quaternion rotation = Quaternion.LookRotation(-normalized);
			int num = 1075904512;
			if (ConVar.AntiHack.projectile_terraincheck)
			{
				num |= 0x800000;
			}
			if (ConVar.AntiHack.projectile_vehiclecheck)
			{
				num |= 0x8000000;
			}
			if (!GamePhysics.LineOfSight(pointStart, val, num))
			{
				continue;
			}
			BaseEntity baseEntity = GameManager.server.CreateEntity(createOnImpact.resourcePath);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				((Component)baseEntity).transform.position = val;
				((Component)baseEntity).transform.rotation = rotation;
				baseEntity.Spawn();
				if (spreadAngle > 0f)
				{
					Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(spreadAngle, normalized2);
					baseEntity.SetVelocity(modifiedAimConeDirection * Random.Range(spreadVelocityMin, spreadVelocityMax));
				}
			}
		}
		base.ServerProjectileHit(info);
	}
}


public class ItemModRackMountable : ItemMod
{
}


using UnityEngine;

public class ItemModRecycleInto : ItemMod
{
	public static readonly Phrase RecycleIntoTitle = new Phrase("recycle_into", "MISSING RECYCLE INTO PHRASE");

	public static readonly Phrase RecycleIntoDesc = new Phrase("recycle_into_desc", "MISSING RECYCLE INTO DESC PHRASE");

	public ItemDefinition recycleIntoItem;

	public int numRecycledItemMin = 1;

	public int numRecycledItemMax = 1;

	public GameObjectRef successEffect;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		if (!(command == "recycle_item"))
		{
			return;
		}
		int num = Random.Range(numRecycledItemMin, numRecycledItemMax + 1);
		item.UseItem();
		if (num > 0)
		{
			Item item2 = ItemManager.Create(recycleIntoItem, num, 0uL);
			item2.SetItemOwnership(player, ItemOwnershipPhrases.Recycler);
			if (!item2.MoveToContainer(player.inventory.containerMain))
			{
				item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}
}


using UnityEngine;

public class ItemModReload : ItemMod
{
	public float conditionLost;

	public GameObjectRef successEffect;

	public int workbenchLvlRequired;

	public Phrase reloadPhrase = new Phrase("reload_item", "Reload Item");

	public bool HasCraftLevel(BasePlayer player = null)
	{
		if ((Object)(object)player != (Object)null && player.isServer)
		{
			return player.currentCraftLevel >= (float)workbenchLvlRequired;
		}
		return false;
	}

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		if (!(command == "reload") || player.IsSwimming() || !HasCraftLevel(player))
		{
			return;
		}
		BaseEntity heldEntity = item.GetHeldEntity();
		if ((Object)(object)heldEntity == (Object)null)
		{
			return;
		}
		BaseProjectile component = ((Component)heldEntity).GetComponent<BaseProjectile>();
		if (!((Object)(object)component == (Object)null))
		{
			int num = component.primaryMagazine.capacity - component.primaryMagazine.contents;
			if (num != 0 && component.TryReloadMagazine(player.inventory, num) && successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}
}


using Facepunch.Rust;
using Oxide.Core;
using UnityEngine;

public class ItemModRepair : ItemMod
{
	public static readonly Phrase RefillItemTitle = new Phrase("refill_item", "Refill");

	public static readonly Phrase RefillItemDesc = new Phrase("refill_item_desc", "Refill the item.");

	public float conditionLost = 0.05f;

	public GameObjectRef successEffect;

	public int workbenchLvlRequired;

	public bool canUseRepairBench;

	public bool HasCraftLevel(BasePlayer player = null)
	{
		if ((Object)(object)player != (Object)null && player.isServer)
		{
			return player.currentCraftLevel >= (float)workbenchLvlRequired;
		}
		return false;
	}

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		if (command == "refill" && !player.IsSwimming() && HasCraftLevel(player) && !(item.conditionNormalized >= 1f) && Interface.CallHook("OnItemRefill", (object)item, (object)player) == null)
		{
			float conditionNormalized = item.conditionNormalized;
			float maxConditionNormalized = item.maxConditionNormalized;
			item.DoRepair(conditionLost);
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
			Analytics.Azure.OnItemRepaired(player, player.GetCachedCraftLevelWorkbench(), item, conditionNormalized, maxConditionNormalized);
		}
	}
}


public class ItemModRestraint : ItemMod
{
}


using UnityEngine;

public class ItemModReveal : ItemMod
{
	public static readonly Phrase RevealItemTitle = new Phrase("reveal_item", "Reveal BP");

	public static readonly Phrase RevealItemDesc = new Phrase("reveal_item_desc", "Reveal blueprint");

	public int numForReveal = 10;

	public ItemDefinition revealedItemOverride;

	public int revealedItemAmount = 1;

	public LootSpawn revealList;

	public GameObjectRef successEffect;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		if (command == "reveal" && item.amount >= numForReveal)
		{
			int position = item.position;
			item.UseItem(numForReveal);
			Item item2 = null;
			if (Object.op_Implicit((Object)(object)revealedItemOverride))
			{
				item2 = ItemManager.Create(revealedItemOverride, revealedItemAmount, 0uL);
			}
			if (item2 != null && !item2.MoveToContainer(player.inventory.containerMain, (item.amount == 0) ? position : (-1)))
			{
				item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}
}


using Rust;
using UnityEngine;

public class ItemModSound : ItemMod
{
	public enum Type
	{
		OnAttachToWeapon
	}

	public GameObjectRef effect = new GameObjectRef();

	public Type actionType;

	public override void OnParentChanged(Item item)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoadingSave || actionType != 0 || item.parentItem == null || item.parentItem.info.category != 0)
		{
			return;
		}
		ItemContainer rootContainer = item.parentItem.GetRootContainer();
		if (rootContainer != null)
		{
			BasePlayer ownerPlayer = rootContainer.GetOwnerPlayer();
			if (!((Object)(object)ownerPlayer == (Object)null) && !ownerPlayer.IsNpc)
			{
				Effect.server.Run(effect.resourcePath, ownerPlayer, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}
}


public enum Type
{
	OnAttachToWeapon
}


using Facepunch.Rust;
using Oxide.Core;
using UnityEngine;

public class ItemModStudyBlueprint : ItemMod
{
	public GameObjectRef studyEffect;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		if (command != "study" || !item.IsBlueprint())
		{
			return;
		}
		if ((Object)(object)item.GetOwnerPlayer() != (Object)(object)player && player.inventory.GetBackpackWithInventory()?.contents != item.parent)
		{
			bool flag = false;
			foreach (ItemContainer container in player.inventory.loot.containers)
			{
				if (item.GetRootContainer() == container)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return;
			}
		}
		if (IsBlueprintUnlocked(item, player, out var blueprintTargetDef, out var blueprint) || Interface.CallHook("OnPlayerStudyBlueprint", (object)player, (object)item) != null)
		{
			return;
		}
		Item item2 = item;
		if (item.amount > 1)
		{
			item2 = item.SplitItem(1);
		}
		item2.UseItem();
		player.blueprints.Unlock(blueprintTargetDef);
		Analytics.Azure.OnBlueprintLearned(player, blueprintTargetDef, "blueprint", ResearchTable.ScrapForResearch(blueprintTargetDef), player);
		if ((Object)(object)blueprint != (Object)null && blueprint.additionalUnlocks != null && blueprint.additionalUnlocks.Count > 0)
		{
			foreach (ItemDefinition additionalUnlock in blueprint.additionalUnlocks)
			{
				player.blueprints.Unlock(additionalUnlock);
				Analytics.Azure.OnBlueprintLearned(player, additionalUnlock, "blueprint", 0, player);
			}
		}
		if (studyEffect.isValid)
		{
			Effect.server.Run(studyEffect.resourcePath, player, StringPool.Get("head"), Vector3.zero, Vector3.zero);
		}
	}

	private static bool IsBlueprintUnlocked(Item item, BasePlayer player, out ItemDefinition blueprintTargetDef, out ItemBlueprint blueprint)
	{
		blueprintTargetDef = item.blueprintTargetDef;
		blueprint = blueprintTargetDef.Blueprint;
		bool flag = IsBlueprintUnlocked(blueprintTargetDef, player);
		if (flag && (Object)(object)blueprint != (Object)null && blueprint.additionalUnlocks != null && blueprint.additionalUnlocks.Count > 0)
		{
			foreach (ItemDefinition additionalUnlock in blueprint.additionalUnlocks)
			{
				if (!IsBlueprintUnlocked(additionalUnlock, player))
				{
					flag = false;
				}
			}
		}
		if ((Object)(object)blueprint != (Object)null && blueprint.defaultBlueprint)
		{
			flag = true;
		}
		if (flag)
		{
			return true;
		}
		return false;
	}

	public static bool IsBlueprintUnlocked(ItemDefinition def, BasePlayer player)
	{
		return player.blueprints.IsUnlocked(def);
	}
}


using ConVar;
using UnityEngine;

public class ItemModSummerSunglassesEquip : ItemMod
{
	public float SunsetTime;

	public float SunriseTime;

	public string AchivementName;

	public override void DoAction(Item item, BasePlayer player)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		base.DoAction(item, player);
		if ((Object)(object)player != (Object)null && !string.IsNullOrEmpty(AchivementName) && player.inventory.containerWear.FindItemByUID(item.uid) != null)
		{
			float time = Env.time;
			if (time < SunriseTime || time > SunsetTime)
			{
				player.GiveAchievement(AchivementName);
			}
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust;
using UnityEngine;

public class ItemModSwap : ItemMod
{
	public GameObjectRef actionEffect;

	public ItemAmount[] becomeItem;

	public bool sendPlayerPickupNotification;

	public bool sendPlayerDropNotification;

	public float xpScale = 1f;

	public List<ItemAmount> RandomOptions;

	public List<float> RandomWeights;

	public Phrase OwnershipPhrase;

	public bool ApplyHarvestingTea;

	public override void DoAction(Item item, BasePlayer player)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		if (item.amount < 1 && RandomWeights.Count == 0 && RandomOptions.Count == 0)
		{
			return;
		}
		ItemAmount[] array = becomeItem;
		foreach (ItemAmount itemAmount in array)
		{
			if (itemAmount.itemDef.IsAllowedInEra((EraRestriction)0))
			{
				SpawnItem(itemAmount, player, item.parent, allowTeaBonus: true);
			}
		}
		if (RandomOptions.Count > 0)
		{
			List<ItemAmount> list = null;
			List<float> list2 = null;
			List<ItemAmount> options = RandomOptions;
			List<float> weights = RandomWeights;
			if ((int)ConVar.Server.Era != 0)
			{
				list = Pool.Get<List<ItemAmount>>();
				list2 = Pool.Get<List<float>>();
				options = list;
				if (RandomWeights.Count != 0 && RandomWeights.Count == RandomOptions.Count)
				{
					weights = list2;
				}
				for (int j = 0; j < RandomOptions.Count; j++)
				{
					ItemAmount itemAmount2 = RandomOptions[j];
					if (itemAmount2.itemDef.IsAllowedInEra((EraRestriction)0))
					{
						if (j < RandomWeights.Count)
						{
							list2.Add(RandomWeights.Count);
						}
						list.Add(itemAmount2);
					}
				}
			}
			ItemAmount itemAmount3 = ((RandomWeights.Count == 0 || RandomWeights.Count != RandomOptions.Count) ? PickRandomChoice(options) : PickWeightedRandomChoice(options, weights));
			if (itemAmount3 != null)
			{
				SpawnItem(itemAmount3, player, item.parent, allowTeaBonus: false);
			}
			if (list != null)
			{
				Pool.FreeUnmanaged<ItemAmount>(ref list);
			}
			if (list2 != null)
			{
				Pool.FreeUnmanaged<float>(ref list2);
			}
		}
		if (sendPlayerDropNotification)
		{
			player.Command("note.inv", item.info.itemid, -1);
		}
		if (actionEffect.isValid)
		{
			Effect.server.Run(actionEffect.resourcePath, ((Component)player).transform.position, Vector3.up);
		}
		item.UseItem();
	}

	private void SpawnItem(ItemAmount itemAmount, BasePlayer player, ItemContainer container, bool allowTeaBonus)
	{
		float num = 1f;
		if (ApplyHarvestingTea && itemAmount.amount > 1f && allowTeaBonus)
		{
			num += player.modifiers.GetValue(Modifier.ModifierType.Harvesting);
		}
		Item item = ItemManager.Create(itemAmount.itemDef, (int)(itemAmount.amount * num), 0uL);
		if (item != null)
		{
			if (OwnershipPhrase != null && !string.IsNullOrEmpty(OwnershipPhrase.token))
			{
				item.SetItemOwnership(player, OwnershipPhrase);
			}
			else
			{
				item.SetItemOwnership(player, ItemOwnershipPhrases.GenericPhrase);
			}
			AugmentItem(item);
			if (!item.MoveToContainer(container))
			{
				player.GiveItem(item);
			}
			if (sendPlayerPickupNotification)
			{
				player.Command("note.inv", item.info.itemid, item.amount);
			}
		}
	}

	protected virtual void AugmentItem(Item item)
	{
	}

	private ItemAmount PickRandomChoice(List<ItemAmount> options)
	{
		int index = Random.Range(0, options.Count);
		return options[index];
	}

	private ItemAmount PickWeightedRandomChoice(List<ItemAmount> options, List<float> weights)
	{
		float num = 0f;
		foreach (float weight in weights)
		{
			num += weight;
		}
		float num2 = Random.Range(0f, num);
		float num3 = 0f;
		for (int i = 0; i < options.Count; i++)
		{
			num3 += weights[i];
			if (num2 <= num3)
			{
				return options[i];
			}
		}
		return options[options.Count - 1];
	}
}


public class ItemModSwitchFlag : ItemMod
{
	public Item.Flag flag;

	public bool state;

	public override void DoAction(Item item, BasePlayer player)
	{
		if (item.amount >= 1 && item.HasFlag(flag) != state)
		{
			item.SetFlag(flag, state);
			item.MarkDirty();
		}
	}
}


using Oxide.Core;
using UnityEngine;

public class ItemModUpgrade : ItemMod
{
	public static readonly Phrase UpgradeItemTitle = new Phrase("upgrade_item", "Upgrade");

	public static readonly Phrase UpgradeItemDesc = new Phrase("upgrade_item_desc", "Upgrade item");

	public int numForUpgrade = 10;

	public float upgradeSuccessChance = 1f;

	public int numToLoseOnFail = 2;

	public ItemDefinition upgradedItem;

	public int numUpgradedItem = 1;

	public GameObjectRef successEffect;

	public GameObjectRef failEffect;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		if (!(command == "upgrade_item") || item.amount < numForUpgrade)
		{
			return;
		}
		if (Random.Range(0f, 1f) <= upgradeSuccessChance)
		{
			item.UseItem(numForUpgrade);
			Item item2 = ItemManager.Create(upgradedItem, numUpgradedItem, 0uL);
			Interface.CallHook("OnItemUpgrade", (object)item, (object)item2, (object)player);
			item2.SetItemOwnership(player, ItemOwnershipPhrases.UpgradeItem);
			if (!item2.MoveToContainer(player.inventory.containerMain))
			{
				item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
		else
		{
			item.UseItem(numToLoseOnFail);
			if (failEffect.isValid)
			{
				Effect.server.Run(failEffect.resourcePath, player.eyes.position);
			}
		}
	}
}


public class ItemModUseContent : ItemMod
{
	public int amountToConsume = 1;

	public override void DoAction(Item item, BasePlayer player)
	{
		if (item.contents != null && item.contents.itemList.Count != 0)
		{
			item.contents.itemList[0].UseItem(amountToConsume);
		}
	}
}


using Rust;
using UnityEngine;

public class ItemModWearable : ItemMod
{
	public GameObjectRef entityPrefab = new GameObjectRef();

	public GameObjectRef entityPrefabFemale = new GameObjectRef();

	public ProtectionProperties protectionProperties;

	public ArmorProperties armorProperties;

	public ClothingMovementProperties movementProperties;

	public UIBlackoutOverlay.blackoutType occlusionType = UIBlackoutOverlay.blackoutType.NONE;

	public bool blocksAiming;

	public bool emissive;

	public float accuracyBonus;

	public bool blocksEquipping;

	public float eggVision;

	public float weight;

	public bool equipOnRightClick = true;

	public bool equipOnPickup;

	public bool npcOnly;

	public GameObjectRef breakEffect = new GameObjectRef();

	public bool preventsMounting;

	public bool preventsMap;

	public GameObjectRef viewmodelAddition;

	public Wearable targetWearable
	{
		get
		{
			if (entityPrefab.isValid)
			{
				return entityPrefab.Get().GetComponent<Wearable>();
			}
			return null;
		}
	}

	private void DoPrepare()
	{
		if (!entityPrefab.isValid)
		{
			Debug.LogWarning((object)("ItemModWearable: entityPrefab is null! " + (object)((Component)this).gameObject), (Object)(object)((Component)this).gameObject);
		}
		if (entityPrefab.isValid && (Object)(object)targetWearable == (Object)null)
		{
			Debug.LogWarning((object)("ItemModWearable: entityPrefab doesn't have a Wearable component! " + (object)((Component)this).gameObject), (Object)(object)entityPrefab.Get());
		}
	}

	public override void ModInit()
	{
		if (string.IsNullOrEmpty(entityPrefab.resourcePath))
		{
			Debug.LogWarning((object)(((object)this)?.ToString() + " - entityPrefab is null or something.. - " + entityPrefab.guid));
		}
	}

	public bool ProtectsArea(HitArea area)
	{
		if ((Object)(object)armorProperties == (Object)null)
		{
			return false;
		}
		return armorProperties.Contains(area);
	}

	public bool ProtectsWholeBody()
	{
		bool num = ProtectsArea(HitArea.Head);
		bool flag = ProtectsArea(HitArea.Chest);
		bool flag2 = ProtectsArea(HitArea.Leg);
		return num && flag && flag2;
	}

	public bool HasProtections()
	{
		return (Object)(object)protectionProperties != (Object)null;
	}

	public float GetProtection(Item item, DamageType damageType)
	{
		if ((Object)(object)protectionProperties == (Object)null)
		{
			return 0f;
		}
		float num = protectionProperties.Get(damageType);
		float num2 = 0f;
		ItemModContainerArmorSlot itemModContainerArmorSlot = default(ItemModContainerArmorSlot);
		if (((Component)this).TryGetComponent<ItemModContainerArmorSlot>(ref itemModContainerArmorSlot))
		{
			num2 = itemModContainerArmorSlot.GetProtection(item, damageType);
		}
		return (num + num2) * ConditionProtectionScale(item);
	}

	public float ConditionProtectionScale(Item item)
	{
		if (!item.isBroken)
		{
			return 1f;
		}
		return 0.25f;
	}

	public void CollectProtection(Item item, ProtectionProperties protection)
	{
		if ((Object)(object)protectionProperties != (Object)null)
		{
			protection.Add(protectionProperties, ConditionProtectionScale(item));
		}
		ItemModContainerArmorSlot itemModContainerArmorSlot = default(ItemModContainerArmorSlot);
		if (((Component)this).TryGetComponent<ItemModContainerArmorSlot>(ref itemModContainerArmorSlot))
		{
			itemModContainerArmorSlot.CollectProtection(item, protection);
		}
	}

	private bool IsHeadgear()
	{
		Wearable component = entityPrefab.Get().GetComponent<Wearable>();
		if ((Object)(object)component != (Object)null && (component.occupationOver & (Wearable.OccupationSlots.HeadTop | Wearable.OccupationSlots.Face | Wearable.OccupationSlots.HeadBack)) != 0)
		{
			return true;
		}
		return false;
	}

	public bool IsFootwear()
	{
		Wearable component = entityPrefab.Get().GetComponent<Wearable>();
		if ((Object)(object)component != (Object)null && (component.occupationOver & (Wearable.OccupationSlots.LeftFoot | Wearable.OccupationSlots.RightFoot)) != 0)
		{
			return true;
		}
		return false;
	}

	public override void OnAttacked(Item item, HitInfo info)
	{
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		if (!item.hasCondition)
		{
			return;
		}
		float num = 0f;
		for (int i = 0; i < 26; i++)
		{
			DamageType damageType = (DamageType)i;
			if (info.damageTypes.Has(damageType))
			{
				num += Mathf.Clamp(info.damageTypes.types[i] * GetProtection(item, damageType), 0f, item.condition);
				if (num >= item.condition)
				{
					break;
				}
			}
		}
		item.LoseCondition(num);
		if (item != null && item.isBroken && Object.op_Implicit((Object)(object)item.GetOwnerPlayer()) && IsHeadgear() && info.damageTypes.Total() >= item.GetOwnerPlayer().health)
		{
			Vector3 vPos = ((Component)item.GetOwnerPlayer()).transform.position + new Vector3(0f, 1.8f, 0f);
			Vector3 vVelocity = item.GetOwnerPlayer().GetInheritedDropVelocity() + Vector3.up * 3f;
			Quaternion rotation = default(Quaternion);
			BaseEntity baseEntity = item.Drop(vPos, vVelocity, rotation);
			rotation = Random.rotation;
			baseEntity.SetAngularVelocity(((Quaternion)(ref rotation)).eulerAngles * 5f);
		}
	}

	public bool CanExistWith(ItemModWearable wearable)
	{
		if ((Object)(object)wearable == (Object)null)
		{
			return true;
		}
		Wearable wearable2 = targetWearable;
		Wearable wearable3 = wearable.targetWearable;
		if ((wearable2.occupationOver & wearable3.occupationOver) != 0)
		{
			return false;
		}
		if ((wearable2.occupationUnder & wearable3.occupationUnder) != 0)
		{
			return false;
		}
		return true;
	}
}


public class ItemModXPWhenUsed : ItemMod
{
	public float xpPerUnit;

	public int unitSize = 1;

	public void GiveConsumeXP(Item item)
	{
	}
}


using UnityEngine;

public class ItemFootstepSounds : MonoBehaviour
{
	public bool setEffectFolder = true;

	public string effectFolder = "barefoot";

	public SoundDefinition accentSound;
}


public static class ItemOwnershipPhrases
{
	public static Phrase BornPhrase = new Phrase("ownership.born", "Born with {0}");

	public static Phrase SpawnedPhrase = new Phrase("ownership.spawned", "Spawned by {0}");

	public static Phrase CraftedPhrase = new Phrase("ownership.crafted", "Crafted by {0}");

	public static Phrase LootedPhrase = new Phrase("ownership.looted", "Looted by {0}");

	public static Phrase MissionRewardPhrase = new Phrase("ownership.mission_reward", "Mission Reward for {0}");

	public static Phrase AdventCalendar = new Phrase("ownership.advent_calendar", "Found In Advent Calendar by {0}");

	public static Phrase PickedUp = new Phrase("ownership.pick_up", "Picked Up by {0}");

	public static Phrase VendorSale = new Phrase("ownership.vendor_purchase", "Purchased by {0}");

	public static Phrase MetalDetector = new Phrase("ownership.metal_detector", "Detected Underground by {0}");

	public static Phrase GatheredPhrase = new Phrase("ownership.gathered_generic", "Gathered by {0}");

	public static Phrase MixingTable = new Phrase("ownership.mixing_table", "Mixed by {0}");

	public static Phrase IndustrialCrafter = new Phrase("ownership.industrial_crafter", "Industrial Crafted by {0}");

	public static Phrase Fishing = new Phrase("ownership.fished", "Fished by {0}");

	public static Phrase SurvivalTrap = new Phrase("ownership.trap_caught", "Trapped by {0}");

	public static Phrase Recycler = new Phrase("ownership.recycled", "Recycled by {0}");

	public static Phrase ResearchTable = new Phrase("ownership.research", "Researched by {0}");

	public static Phrase UpgradeItem = new Phrase("ownership.upgrade_item", "Upgraded by {0}");

	public static Phrase Wrap = new Phrase("ownership.wrapped", "Wrapped by {0}");

	public static Phrase Recorded = new Phrase("ownership.recorded", "Recorded by {0}");

	public static Phrase Photographed = new Phrase("ownership.photographed", "Photographed by {0}");

	public static Phrase Cloned = new Phrase("ownership.cloned", "Cloned by {0}");

	public static Phrase Harvested = new Phrase("ownership.harvested", "Harvested by {0}");

	public static Phrase Shredded = new Phrase("ownership.shredded", "Shredded by {0}");

	public static Phrase Beheaded = new Phrase("ownership.beheaded", "Beheaded by {0}");

	public static Phrase Pooped = new Phrase("ownership.pooped", "Pooped by {0}");

	public static Phrase GenericRewardPhrase = new Phrase("ownership.generic_reward", "Rewarded to {0}");

	public static Phrase GenericPhrase = new Phrase("ownership.generic", "Created by {0}");
}


public struct ItemOwnershipShare
{
	public string username;

	public string reason;

	public int amount;

	public bool IsValid()
	{
		return !string.IsNullOrEmpty(reason);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

[Serializable]
public class ItemAmount : ISerializationCallbackReceiver
{
	[ItemSelector(ItemCategory.All)]
	public ItemDefinition itemDef;

	public float amount;

	[NonSerialized]
	public float startAmount;

	public bool ignoreInTutorial;

	public bool isBP;

	public int itemid
	{
		get
		{
			if ((Object)(object)itemDef == (Object)null)
			{
				return 0;
			}
			return itemDef.itemid;
		}
	}

	public ItemAmount(ItemDefinition item = null, float amt = 0f)
	{
		itemDef = item;
		amount = amt;
		startAmount = amount;
	}

	public virtual float GetAmount()
	{
		return amount;
	}

	public virtual void OnAfterDeserialize()
	{
		startAmount = amount;
	}

	public virtual void OnBeforeSerialize()
	{
	}

	public static ItemAmountList SerialiseList(List<ItemAmount> list)
	{
		ItemAmountList val = Pool.Get<ItemAmountList>();
		val.amount = Pool.Get<List<float>>();
		val.itemID = Pool.Get<List<int>>();
		foreach (ItemAmount item in list)
		{
			val.amount.Add(item.amount);
			val.itemID.Add(item.itemid);
		}
		return val;
	}

	public static void DeserialiseList(List<ItemAmount> target, ItemAmountList source)
	{
		target.Clear();
		if (source.amount.Count == source.itemID.Count)
		{
			for (int i = 0; i < source.amount.Count; i++)
			{
				target.Add(new ItemAmount(ItemManager.FindItemDefinition(source.itemID[i]), source.amount[i]));
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class ItemAmountRandom
{
	[ItemSelector(ItemCategory.All)]
	public ItemDefinition itemDef;

	public AnimationCurve amount = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
	{
		new Keyframe(0f, 0f),
		new Keyframe(1f, 1f)
	});

	public int RandomAmount()
	{
		return Mathf.RoundToInt(amount.Evaluate(Random.Range(0f, 1f)));
	}
}


using System;
using UnityEngine;

[Serializable]
public class ItemAmountRanged : ItemAmount
{
	public float maxAmount = -1f;

	public override void OnAfterDeserialize()
	{
		base.OnAfterDeserialize();
	}

	public ItemAmountRanged(ItemDefinition item = null, float amt = 0f, float max = -1f)
		: base(item, amt)
	{
		maxAmount = max;
	}

	public override float GetAmount()
	{
		if (maxAmount > 0f && maxAmount > amount)
		{
			return Random.Range(amount, maxAmount);
		}
		return amount;
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ItemManager
{
	private struct ItemRemove
	{
		public Item item;

		public float time;
	}

	[ServerVar]
	public static bool EnablePooling = true;

	public static List<ItemDefinition> itemList;

	public static Dictionary<int, ItemDefinition> itemDictionary;

	public static Dictionary<string, ItemDefinition> itemDictionaryByName;

	public static List<ItemBlueprint> bpList;

	public static int[] defaultBlueprints;

	public static ItemDefinition blueprintBaseDef;

	private static List<ItemRemove> ItemRemoves = new List<ItemRemove>();

	public static void InvalidateWorkshopSkinCache()
	{
		if (itemList == null)
		{
			return;
		}
		foreach (ItemDefinition item in itemList)
		{
			item.InvalidateWorkshopSkinCache();
		}
	}

	public static void Initialize()
	{
		if (itemList != null)
		{
			return;
		}
		Stopwatch stopwatch = new Stopwatch();
		stopwatch.Start();
		GameObject[] array = FileSystem.LoadAllFromBundle<GameObject>("items.preload.bundle", "l:ItemDefinition");
		if (array.Length == 0)
		{
			throw new Exception("items.preload.bundle has no items!");
		}
		if (stopwatch.Elapsed.TotalSeconds > 1.0)
		{
			Debug.Log((object)("Loading Items Took: " + stopwatch.Elapsed.TotalMilliseconds / 1000.0 + " seconds"));
		}
		List<ItemDefinition> list = (from x in array
			select x.GetComponent<ItemDefinition>() into x
			where (Object)(object)x != (Object)null
			select x).ToList();
		List<ItemBlueprint> list2 = (from x in array
			select x.GetComponent<ItemBlueprint>() into x
			where (Object)(object)x != (Object)null && x.userCraftable
			select x).ToList();
		Dictionary<int, ItemDefinition> dictionary = new Dictionary<int, ItemDefinition>();
		Dictionary<string, ItemDefinition> dictionary2 = new Dictionary<string, ItemDefinition>(StringComparer.OrdinalIgnoreCase);
		foreach (ItemDefinition item in list)
		{
			item.Initialize(list);
			if (dictionary.ContainsKey(item.itemid))
			{
				ItemDefinition itemDefinition = dictionary[item.itemid];
				Debug.LogWarning((object)("Item ID duplicate " + item.itemid + " (" + ((Object)item).name + ") - have you given your items unique shortnames?"), (Object)(object)((Component)item).gameObject);
				Debug.LogWarning((object)("Other item is " + ((Object)itemDefinition).name), (Object)(object)itemDefinition);
			}
			else if (string.IsNullOrEmpty(item.shortname))
			{
				Debug.LogWarning((object)$"{item} has a null short name! id: {item.itemid} {item.displayName.english}");
			}
			else
			{
				dictionary.Add(item.itemid, item);
				dictionary2.Add(item.shortname, item);
			}
		}
		stopwatch.Stop();
		if (stopwatch.Elapsed.TotalSeconds > 1.0)
		{
			Debug.Log((object)("Building Items Took: " + stopwatch.Elapsed.TotalMilliseconds / 1000.0 + " seconds / Items: " + list.Count + " / Blueprints: " + list2.Count));
		}
		defaultBlueprints = (from x in list2
			where !x.NeedsSteamItem && !x.NeedsSteamDLC && x.defaultBlueprint
			select x.targetItem.itemid).ToArray();
		itemList = list;
		bpList = list2;
		itemDictionary = dictionary;
		itemDictionaryByName = dictionary2;
		blueprintBaseDef = FindItemDefinition("blueprintbase");
	}

	public static Item CreateByName(string strName, int iAmount = 1, ulong skin = 0uL)
	{
		ItemDefinition itemDefinition = itemList.Find((ItemDefinition x) => x.shortname == strName);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return null;
		}
		return CreateByItemID(itemDefinition.itemid, iAmount, skin);
	}

	public static Item CreateByPartialName(string strName, int iAmount = 1, ulong skin = 0uL)
	{
		ItemDefinition itemDefinition = FindDefinitionByPartialName(strName);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return null;
		}
		return CreateByItemID(itemDefinition.itemid, iAmount, skin);
	}

	public static ItemDefinition FindDefinitionByPartialName(string strName)
	{
		ItemDefinition itemDefinition = itemList.Find((ItemDefinition x) => x.shortname == strName);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			itemDefinition = itemList.Find((ItemDefinition x) => StringEx.Contains(x.shortname, strName, CompareOptions.IgnoreCase));
		}
		return itemDefinition;
	}

	public static Item CreateByItemID(int itemID, int iAmount = 1, ulong skin = 0uL)
	{
		ItemDefinition itemDefinition = FindItemDefinition(itemID);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return null;
		}
		return Create(itemDefinition, iAmount, skin);
	}

	public static Item Create(ItemDefinition template, int iAmount = 1, ulong skin = 0uL, bool isServerSide = true)
	{
		Debug.Assert(isServerSide, "Tried to create client item on server!");
		TrySkinChangeItem(ref template, ref skin);
		if ((Object)(object)template == (Object)null)
		{
			Debug.LogWarning((object)"Creating invalid/missing item!");
			return null;
		}
		if (iAmount <= 0)
		{
			Debug.LogError((object)("Creating item with less than 1 amount! (" + template.displayName.english + ")"));
			return null;
		}
		Item item = ((EnablePooling && isServerSide) ? Pool.Get<Item>() : new Item());
		item.isServer = isServerSide;
		item.info = template;
		item.amount = iAmount;
		item.skin = skin;
		item.Initialize(template);
		RustLog.Log(RustLog.EntryType.Item, 1, null, "Created <color={0}>{1}</color>", item.isServer ? "yellow" : "cyan", item);
		return item;
	}

	private static void TrySkinChangeItem(ref ItemDefinition template, ref ulong skinId)
	{
		if (skinId == 0L)
		{
			return;
		}
		ItemSkinDirectory.Skin skin = ItemSkinDirectory.FindByInventoryDefinitionId((int)skinId);
		if (skin.id != 0)
		{
			ItemSkin itemSkin = skin.invItem as ItemSkin;
			if (!((Object)(object)itemSkin == (Object)null) && !((Object)(object)itemSkin.Redirect == (Object)null))
			{
				template = itemSkin.Redirect;
				skinId = 0uL;
			}
		}
	}

	public static Item Load(Item load, Item created, bool isServer)
	{
		if (created == null)
		{
			created = ((EnablePooling && isServer) ? Pool.Get<Item>() : new Item());
		}
		created.isServer = isServer;
		created.Load(load);
		if ((Object)(object)created.info == (Object)null)
		{
			Debug.LogWarning((object)"Item loading failed - item is invalid");
			return null;
		}
		if ((Object)(object)created.info == (Object)(object)blueprintBaseDef && (Object)(object)created.blueprintTargetDef == (Object)null)
		{
			Debug.LogWarning((object)"Blueprint item loading failed - invalid item target");
			return null;
		}
		RustLog.Log(RustLog.EntryType.Item, 1, null, "Loaded <color={0}>{1}</color>", created.isServer ? "yellow" : "cyan", created);
		return created;
	}

	public static ItemDefinition FindItemDefinition(int itemID)
	{
		Initialize();
		if (itemDictionary.TryGetValue(itemID, out var value))
		{
			return value;
		}
		return null;
	}

	public static ItemDefinition FindItemDefinition(string shortName)
	{
		Initialize();
		if (itemDictionaryByName.TryGetValue(shortName, out var value))
		{
			return value;
		}
		return null;
	}

	public static ItemBlueprint FindBlueprint(ItemDefinition item)
	{
		return ((Component)item).GetComponent<ItemBlueprint>();
	}

	public static List<ItemDefinition> GetItemDefinitions()
	{
		Initialize();
		return itemList;
	}

	public static List<ItemBlueprint> GetBlueprints()
	{
		Initialize();
		return bpList;
	}

	public static void DoRemoves()
	{
		TimeWarning val = TimeWarning.New("DoRemoves", 0);
		try
		{
			for (int i = 0; i < ItemRemoves.Count; i++)
			{
				if (!(ItemRemoves[i].time > Time.time))
				{
					Item item = ItemRemoves[i].item;
					ItemRemoves.RemoveAt(i--);
					RustLog.Log(RustLog.EntryType.Item, 1, null, "Removing <color={0}>{1}</color>", item.isServer ? "yellow" : "cyan", item);
					item.DoRemove();
					if (EnablePooling)
					{
						Pool.Free<Item>(ref item);
					}
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void Heartbeat()
	{
		DoRemoves();
	}

	public static void RemoveItem(Item item, float fTime = 0f)
	{
		RustLog.Log(RustLog.EntryType.Item, 2, null, "Scheduled removal of <color={0}>{1}</color>", item.isServer ? "yellow" : "cyan", item);
		ItemRemove item2 = default(ItemRemove);
		item2.item = item;
		item2.time = Time.time + fTime;
		ItemRemoves.Add(item2);
	}

	public static IEnumerable<Item> GetAllItems()
	{
		Queue<Item> buffer = new Queue<Item>();
		HashSet<Item> bufferHash = new HashSet<Item>();
		foreach (Item item in GetAllItemsInternal())
		{
			if (item == null)
			{
				continue;
			}
			yield return item;
			if (item.contents == null)
			{
				continue;
			}
			bufferHash.Clear();
			buffer.Enqueue(item);
			Item result;
			while (buffer.TryDequeue(out result))
			{
				if (result.contents?.itemList == null)
				{
					continue;
				}
				foreach (Item child in result.contents.itemList)
				{
					yield return child;
					if (bufferHash.Add(child))
					{
						buffer.Enqueue(child);
					}
				}
			}
		}
	}

	private static IEnumerable<Item> GetAllItemsInternal()
	{
		List<ItemContainer> buffer = new List<ItemContainer>();
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				if (current is IInventoryProvider inventoryProvider)
				{
					buffer.Clear();
					inventoryProvider.GetAllInventories(buffer);
					foreach (ItemContainer item in buffer)
					{
						foreach (Item item2 in item.itemList)
						{
							yield return item2;
						}
					}
				}
				else if (current is DroppedItem droppedItem)
				{
					yield return droppedItem.item;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}
}


private struct ItemRemove
{
	public Item item;

	public float time;
}


using UnityEngine;

public class LeavesBlowing : MonoBehaviour
{
	public ParticleSystem m_psLeaves;

	public float m_flSwirl;

	public float m_flSpeed;

	public float m_flEmissionRate;

	private void Start()
	{
	}

	private void Update()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.RotateAround(((Component)this).transform.position, Vector3.up, Time.deltaTime * m_flSwirl);
		if ((Object)(object)m_psLeaves != (Object)null)
		{
			m_psLeaves.startSpeed = m_flSpeed;
			ParticleSystem psLeaves = m_psLeaves;
			psLeaves.startSpeed += Mathf.Sin(Time.time * 0.4f) * (m_flSpeed * 0.75f);
			m_psLeaves.emissionRate = m_flEmissionRate + Mathf.Sin(Time.time * 1f) * (m_flEmissionRate * 0.3f);
		}
	}
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/MaterialEffect")]
public class MaterialEffect : ScriptableObject
{
	[Serializable]
	public class Entry
	{
		public PhysicMaterial Material;

		public GameObjectRef Effect;

		public SoundDefinition SoundDefinition;
	}

	public GameObjectRef DefaultEffect;

	public SoundDefinition DefaultSoundDefinition;

	public Entry[] Entries;

	public int waterFootstepIndex = -1;

	public Entry deepWaterEntry;

	public float deepWaterDepth = -1f;

	public Entry submergedWaterEntry;

	public float submergedWaterDepth = -1f;

	public bool ScaleVolumeWithSpeed;

	public AnimationCurve SpeedGainCurve;

	public Entry GetEntryFromMaterial(PhysicMaterial mat)
	{
		Entry[] entries = Entries;
		foreach (Entry entry in entries)
		{
			if ((Object)(object)entry.Material == (Object)(object)mat)
			{
				return entry;
			}
		}
		return null;
	}

	public Entry GetWaterEntry()
	{
		if (waterFootstepIndex == -1)
		{
			for (int i = 0; i < Entries.Length; i++)
			{
				if (((Object)Entries[i].Material).name == "Water")
				{
					waterFootstepIndex = i;
					break;
				}
			}
		}
		if (waterFootstepIndex != -1)
		{
			return Entries[waterFootstepIndex];
		}
		Debug.LogWarning((object)("Unable to find water effect for :" + ((Object)this).name));
		return null;
	}

	public void SpawnOnRay(Ray ray, int mask, float length = 0.5f, Vector3 forward = default(Vector3), float speed = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		if (!GamePhysics.Trace(ray, 0f, out var hitInfo, length, mask, (QueryTriggerInteraction)0))
		{
			Effect.client.Run(DefaultEffect.resourcePath, ((Ray)(ref ray)).origin, ((Ray)(ref ray)).direction * -1f, forward);
			if ((Object)(object)DefaultSoundDefinition != (Object)null)
			{
				PlaySound(DefaultSoundDefinition, ((RaycastHit)(ref hitInfo)).point, speed);
			}
			return;
		}
		WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(((Ray)(ref ray)).origin, waves: true, volumes: false);
		if (waterInfo.isValid)
		{
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(((Ray)(ref ray)).origin.x, waterInfo.surfaceLevel, ((Ray)(ref ray)).origin.z);
			Entry waterEntry = GetWaterEntry();
			if (submergedWaterDepth > 0f && waterInfo.currentDepth >= submergedWaterDepth)
			{
				waterEntry = submergedWaterEntry;
			}
			else if (deepWaterDepth > 0f && waterInfo.currentDepth >= deepWaterDepth)
			{
				waterEntry = deepWaterEntry;
			}
			if (waterEntry != null)
			{
				Effect.client.Run(waterEntry.Effect.resourcePath, val, Vector3.up);
				if ((Object)(object)waterEntry.SoundDefinition != (Object)null)
				{
					PlaySound(waterEntry.SoundDefinition, val, speed);
				}
			}
			return;
		}
		PhysicMaterial materialAt = ((RaycastHit)(ref hitInfo)).collider.GetMaterialAt(((RaycastHit)(ref hitInfo)).point);
		Entry entryFromMaterial = GetEntryFromMaterial(materialAt);
		if (entryFromMaterial == null)
		{
			Effect.client.Run(DefaultEffect.resourcePath, ((RaycastHit)(ref hitInfo)).point, ((RaycastHit)(ref hitInfo)).normal, forward);
			if ((Object)(object)DefaultSoundDefinition != (Object)null)
			{
				PlaySound(DefaultSoundDefinition, ((RaycastHit)(ref hitInfo)).point, speed);
			}
		}
		else
		{
			Effect.client.Run(entryFromMaterial.Effect.resourcePath, ((RaycastHit)(ref hitInfo)).point, ((RaycastHit)(ref hitInfo)).normal, forward);
			if ((Object)(object)entryFromMaterial.SoundDefinition != (Object)null)
			{
				PlaySound(entryFromMaterial.SoundDefinition, ((RaycastHit)(ref hitInfo)).point, speed);
			}
		}
	}

	public void PlaySound(SoundDefinition definition, Vector3 position, float velocity = 0f)
	{
	}
}


using System;
using UnityEngine;

[Serializable]
public class Entry
{
	public PhysicMaterial Material;

	public GameObjectRef Effect;

	public SoundDefinition SoundDefinition;
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/MaterialSound")]
public class MaterialSound : ScriptableObject
{
	[Serializable]
	public class Entry
	{
		public PhysicMaterial Material;

		public SoundDefinition Sound;
	}

	public SoundDefinition DefaultSound;

	public Entry[] Entries;
}


using System;
using UnityEngine;

[Serializable]
public class Entry
{
	public PhysicMaterial Material;

	public SoundDefinition Sound;
}


using UnityEngine;

public class MaxSpawnDistance : MonoBehaviour, IClientComponent
{
	public float maxDistance = 30f;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Rust;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(menuName = "Rust/Missions/BaseMission")]
public class BaseMission : BaseScriptableObject
{
	[Serializable]
	public class MissionDependancy
	{
		public BaseMission targetMission;

		public MissionStatus targetMissionDesiredStatus;

		public bool everAttempted;

		public uint targetMissionID
		{
			get
			{
				if (!(targetMission != null))
				{
					return 0u;
				}
				return StringEx.ManifestHash(targetMission.shortname);
			}
		}
	}

	public enum MissionStatus
	{
		Default,
		Active,
		Accomplished,
		Failed,
		Completed
	}

	public enum MissionEventType
	{
		CUSTOM,
		HARVEST,
		CONVERSATION,
		KILL_ENTITY,
		ACQUIRE_ITEM,
		FREE_CRATE,
		MOUNT_ENTITY,
		HURT_ENTITY,
		PLAYER_TICK,
		CRAFT_ITEM,
		DEPLOY,
		HEAL,
		CLOTHINGCHANGED,
		STARTOVEN,
		CONSUME,
		ACQUITE_ITEM_STACK,
		OPEN_STORAGE,
		COOK,
		ENTER_TRIGGER,
		UPGRADE_BUILDING_GRADE,
		RESPAWN,
		METAL_DETECTOR_FIND
	}

	[Serializable]
	public class MissionObjectiveEntry
	{
		public Phrase description;

		public int[] startAfterCompletedObjectives;

		public int[] autoCompleteOtherObjectives;

		public bool onlyProgressIfStarted = true;

		public bool isRequired = true;

		public MissionObjective objective;

		public string[] requiredEntities;

		public ItemAmount[] bonusRewards;

		public MissionObjective Get()
		{
			return objective;
		}
	}

	public struct MissionEventPayload
	{
		public NetworkableId NetworkIdentifier;

		public uint UintIdentifier;

		public int IntIdentifier;

		public Vector3 WorldPosition;
	}

	public class MissionInstance : IPooled
	{
		[Serializable]
		public class ObjectiveStatus
		{
			public bool started;

			public bool completed;

			public bool failed;

			public float progressTarget;

			public float progressCurrent;

			public RealTimeSince sinceLastThink;
		}

		public enum ObjectiveType
		{
			MOVE,
			KILL
		}

		private BaseEntity _cachedProviderEntity;

		private BaseMission _cachedMission;

		public NetworkableId providerID;

		public uint missionID;

		public MissionStatus status;

		public float startTime;

		public float endTime;

		public Vector3 missionLocation;

		public float timePassed;

		public Dictionary<string, Vector3> missionPoints = new Dictionary<string, Vector3>();

		public Dictionary<string, MissionEntity> missionEntities = new Dictionary<string, MissionEntity>();

		private int playerInputCounter;

		public ObjectiveStatus[] objectiveStatuses;

		public BaseEntity ProviderEntity()
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)_cachedProviderEntity == (Object)null)
			{
				_cachedProviderEntity = BaseNetworkable.serverEntities.Find(providerID) as BaseEntity;
			}
			return _cachedProviderEntity;
		}

		public BaseMission GetMission()
		{
			if (_cachedMission == null)
			{
				_cachedMission = MissionManifest.GetFromID(missionID);
			}
			return _cachedMission;
		}

		public bool ShouldShowOnMap()
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			if (status == MissionStatus.Active || status == MissionStatus.Accomplished)
			{
				return missionLocation != Vector3.zero;
			}
			return false;
		}

		public bool ShouldShowOnCompass()
		{
			return ShouldShowOnMap();
		}

		public bool NeedsPlayerInput()
		{
			return playerInputCounter > 0;
		}

		public void EnablePlayerInput()
		{
			playerInputCounter++;
		}

		public void DisablePlayerInput()
		{
			playerInputCounter--;
			if (playerInputCounter < 0)
			{
				playerInputCounter = 0;
			}
		}

		public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionEventType type, MissionEventPayload payload, float amount)
		{
			if (status == MissionStatus.Active)
			{
				BaseMission mission = GetMission();
				for (int i = 0; i < mission.objectives.Length; i++)
				{
					mission.objectives[i].objective.ProcessMissionEvent(playerFor, this, i, type, payload, amount);
				}
			}
		}

		public void Think(BasePlayer assignee, float delta)
		{
			if (status != MissionStatus.Failed && status != MissionStatus.Completed)
			{
				BaseMission mission = GetMission();
				timePassed += delta;
				mission.Think(this, assignee, delta);
				if (mission.timeLimitSeconds > 0f && timePassed >= mission.timeLimitSeconds)
				{
					mission.MissionFailed(this, assignee, MissionFailReason.TimeOut);
				}
			}
		}

		public Vector3 GetMissionPoint(string identifier, BasePlayer playerFor, int depth = 0)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			if (identifier == null)
			{
				identifier = "";
			}
			if (missionPoints.TryGetValue(identifier, out var value))
			{
				return value;
			}
			BaseMission mission = GetMission();
			if ((Object)(object)playerFor == (Object)null)
			{
				Debug.LogError((object)("Massive mission failure to get point, correct mission definition of: " + mission.shortname + " (player is null)"));
				return Vector3.zero;
			}
			PositionGenerator positionGenerator = List.FindWith<PositionGenerator, string>((IReadOnlyCollection<PositionGenerator>)(object)mission.positionGenerators, (Func<PositionGenerator, string>)((PositionGenerator p) => p.identifier), identifier, (IEqualityComparer<string>)null);
			if (positionGenerator == null)
			{
				Debug.LogError((object)("Massive mission failure to get point, correct mission definition of: " + mission.shortname + " (cannot find position '" + identifier + "')"));
				return Vector3.zero;
			}
			Vector3 position = positionGenerator.GetPosition(this, playerFor, depth);
			missionPoints.Add(identifier, position);
			AddBlocker(position);
			return position;
		}

		public MissionEntity GetMissionEntity(string identifier, BasePlayer playerFor)
		{
			//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
			if (identifier == null)
			{
				identifier = "";
			}
			if (missionEntities.TryGetValue(identifier, out var value))
			{
				return value;
			}
			MissionEntityEntry missionEntityEntry = List.FindWith<MissionEntityEntry, string>((IReadOnlyCollection<MissionEntityEntry>)(object)GetMission().missionEntities, (Func<MissionEntityEntry, string>)((MissionEntityEntry e) => e.identifier), identifier, (IEqualityComparer<string>)null);
			if (missionEntityEntry == null)
			{
				Debug.LogError((object)$"Cannot spawn mission entity, identifier '{identifier}' not found in mission ID {missionID}");
				value = null;
			}
			else if (!missionEntityEntry.entityRef.isValid)
			{
				Debug.LogError((object)$"Cannot spawn mission entity, identifier '{identifier}' has no entity set in mission ID {missionID}");
				value = null;
			}
			else
			{
				Vector3 missionPoint = GetMissionPoint(missionEntityEntry.spawnPositionToUse, playerFor);
				BaseEntity baseEntity = GameManager.server.CreateEntity(missionEntityEntry.entityRef.resourcePath, missionPoint, Quaternion.identity);
				MissionEntity missionEntity = default(MissionEntity);
				MissionEntity obj = (((Component)baseEntity).gameObject.TryGetComponent<MissionEntity>(ref missionEntity) ? missionEntity : ((Component)baseEntity).gameObject.AddComponent<MissionEntity>());
				obj.Setup(playerFor, this, identifier, missionEntityEntry.cleanupOnMissionSuccess, missionEntityEntry.cleanupOnMissionFailed);
				baseEntity.Spawn();
				value = obj;
			}
			missionEntities.Add(identifier, value);
			if ((Object)(object)value != (Object)null)
			{
				value.MissionStarted(playerFor, this);
			}
			return value;
		}

		public void PostServerLoad(BasePlayer player)
		{
			BaseMission mission = GetMission();
			for (int i = 0; i < mission.objectives.Length; i++)
			{
				if (i >= 0 && i < objectiveStatuses.Length)
				{
					mission.objectives[i].objective.PostServerLoad(player, objectiveStatuses[i]);
				}
			}
		}

		public int GetTotalRequiredRewardItemSlots()
		{
			BaseMission mission = GetMission();
			int num = 0;
			for (int i = 0; i < mission.objectives.Length; i++)
			{
				if (!mission.objectives[i].isRequired && objectiveStatuses[i].completed)
				{
					num += mission.objectives[i].bonusRewards.Length;
				}
			}
			return mission.GetMissionRewards().Length + num;
		}

		public void Reset()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			providerID = default(NetworkableId);
			missionID = 0u;
			status = MissionStatus.Default;
			startTime = -1f;
			endTime = -1f;
			missionLocation = Vector3.zero;
			_cachedMission = null;
			timePassed = 0f;
			missionPoints.Clear();
			missionEntities.Clear();
		}

		public void EnterPool()
		{
			Reset();
		}

		public void LeavePool()
		{
		}
	}

	[Serializable]
	public class PositionGenerator
	{
		public enum RelativeType
		{
			Player,
			Provider,
			Position
		}

		public enum PositionType
		{
			MissionPoint,
			WorldPositionGenerator,
			DungeonPoint,
			Radius
		}

		public string identifier;

		public float minDistForMovePoint;

		public float maxDistForMovePoint = 25f;

		public bool allowDoubleDistanceIfNoOptionsAreFound;

		public RelativeType relativeTo;

		public PositionType positionType;

		public string centerOnPositionIdentifier = "";

		[InspectorFlags]
		public MissionPoint.MissionPointEnum Flags = (MissionPoint.MissionPointEnum)(-1);

		[InspectorFlags]
		public MissionPoint.MissionPointEnum ExclusionFlags;

		public WorldPositionGenerator worldPositionGenerator;

		public bool IsDependant()
		{
			return !string.IsNullOrEmpty(centerOnPositionIdentifier);
		}

		public bool Validate(BasePlayer assignee, BaseMission missionDef)
		{
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			Vector3 position;
			if (positionType == PositionType.MissionPoint)
			{
				List<MissionPoint> points = Pool.Get<List<MissionPoint>>();
				bool missionPoints = MissionPoint.GetMissionPoints(ref points, ((Component)assignee).transform.position, minDistForMovePoint, maxDistForMovePoint, (int)Flags, (int)ExclusionFlags);
				if (!missionPoints && allowDoubleDistanceIfNoOptionsAreFound)
				{
					points.Clear();
					missionPoints = MissionPoint.GetMissionPoints(ref points, ((Component)assignee).transform.position, minDistForMovePoint, maxDistForMovePoint * 2f, (int)Flags, (int)ExclusionFlags);
				}
				Pool.FreeUnmanaged<MissionPoint>(ref points);
				if (!missionPoints)
				{
					Debug.Log((object)"FAILED TO FIND MISSION POINTS");
					return false;
				}
			}
			else if (positionType == PositionType.WorldPositionGenerator && (Object)(object)worldPositionGenerator != (Object)null && !worldPositionGenerator.TrySample(((Component)assignee).transform.position, minDistForMovePoint, maxDistForMovePoint, out position, blockedPoints))
			{
				Debug.Log((object)"FAILED TO GENERATE WORLD POSITION!!!!!");
				return false;
			}
			return true;
		}

		public Vector3 GetPosition(MissionInstance instance, BasePlayer assignee, int depth = 0)
		{
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0150: Unknown result type (might be due to invalid IL or missing references)
			//IL_0155: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_015b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0160: Unknown result type (might be due to invalid IL or missing references)
			//IL_0175: Unknown result type (might be due to invalid IL or missing references)
			//IL_0176: Unknown result type (might be due to invalid IL or missing references)
			//IL_0189: Unknown result type (might be due to invalid IL or missing references)
			//IL_018e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0193: Unknown result type (might be due to invalid IL or missing references)
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0115: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0138: Unknown result type (might be due to invalid IL or missing references)
			//IL_0139: Unknown result type (might be due to invalid IL or missing references)
			//IL_0120: Unknown result type (might be due to invalid IL or missing references)
			//IL_0122: Unknown result type (might be due to invalid IL or missing references)
			if (depth > 10)
			{
				Debug.LogError((object)$"Exceeded max depth while calculating position! missionID={instance.missionID} identifier={identifier}");
				return ((Component)assignee).transform.position;
			}
			Vector3 relativeToPosition = GetRelativeToPosition(instance, assignee, depth);
			Vector3 result;
			if (positionType == PositionType.MissionPoint)
			{
				List<MissionPoint> points = Pool.Get<List<MissionPoint>>();
				bool missionPoints = MissionPoint.GetMissionPoints(ref points, relativeToPosition, minDistForMovePoint, maxDistForMovePoint, (int)Flags, (int)ExclusionFlags);
				if (!missionPoints && allowDoubleDistanceIfNoOptionsAreFound)
				{
					points.Clear();
					missionPoints = MissionPoint.GetMissionPoints(ref points, relativeToPosition, minDistForMovePoint, maxDistForMovePoint * 2f, (int)Flags, (int)ExclusionFlags);
				}
				if (missionPoints)
				{
					result = points[Random.Range(0, points.Count)].GetPosition();
				}
				else
				{
					Debug.LogError((object)"UNABLE TO FIND MISSIONPOINT FOR MISSION!");
					result = relativeToPosition;
				}
				Pool.FreeUnmanaged<MissionPoint>(ref points);
			}
			else if (positionType == PositionType.WorldPositionGenerator && (Object)(object)worldPositionGenerator != (Object)null)
			{
				int num = 0;
				while (true)
				{
					if (worldPositionGenerator.TrySample(relativeToPosition, minDistForMovePoint, maxDistForMovePoint, out var position, blockedPoints) && TryAlignToGround(position, out var correctedPosition))
					{
						result = correctedPosition;
						break;
					}
					if (num >= 10)
					{
						Debug.LogError((object)"UNABLE TO FIND WORLD POINT FOR MISSION!");
						result = relativeToPosition;
						break;
					}
					num++;
				}
			}
			else if (positionType == PositionType.DungeonPoint)
			{
				result = DynamicDungeon.GetNextDungeonPoint();
			}
			else
			{
				int num2 = 0;
				while (true)
				{
					Vector3 onUnitSphere = Random.onUnitSphere;
					onUnitSphere.y = 0f;
					((Vector3)(ref onUnitSphere)).Normalize();
					Vector3 val = relativeToPosition + onUnitSphere * Random.Range(minDistForMovePoint, maxDistForMovePoint);
					val.y = WaterLevel.GetWaterOrTerrainSurface(val, waves: false, volumes: false);
					if (TryAlignToGround(val, out var correctedPosition2))
					{
						result = correctedPosition2;
						break;
					}
					if (num2 >= 10)
					{
						Debug.LogError((object)"UNABLE TO FIND WORLD POINT FOR MISSION!");
						result = relativeToPosition;
						break;
					}
					num2++;
				}
			}
			return result;
		}

		private Vector3 GetRelativeToPosition(MissionInstance instance, BasePlayer assignee, int depth)
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			switch (relativeTo)
			{
			case RelativeType.Position:
				return instance.GetMissionPoint(centerOnPositionIdentifier, assignee, depth + 1);
			case RelativeType.Provider:
			{
				BaseEntity baseEntity = instance.ProviderEntity();
				if ((Object)(object)baseEntity != (Object)null)
				{
					return ((Component)baseEntity).transform.position;
				}
				break;
			}
			}
			if ((Object)(object)assignee != (Object)null)
			{
				return ((Component)assignee).transform.position;
			}
			Debug.LogError((object)$"Cannot get mission point origin - assigne playere is null! missionID={instance.missionID} relativeTo={relativeTo}");
			return Vector3.zero;
		}

		private static bool TryAlignToGround(Vector3 wishPosition, out Vector3 correctedPosition)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = Vector3Ex.WithY(wishPosition, wishPosition.y + 50f);
			RaycastHit hit = default(RaycastHit);
			if (!Physics.Raycast(new Ray(val, Vector3.down), ref hit, 50f, 1218652417, (QueryTriggerInteraction)1))
			{
				correctedPosition = wishPosition;
				return true;
			}
			if ((Object)(object)hit.GetEntity() != (Object)null)
			{
				correctedPosition = wishPosition;
				return false;
			}
			correctedPosition = ((RaycastHit)(ref hit)).point;
			return true;
		}
	}

	[Serializable]
	public class MissionEntityEntry
	{
		[FormerlySerializedAs("entityIdentifier")]
		public string identifier;

		public GameObjectRef entityRef;

		public string spawnPositionToUse;

		public bool spawnOnMissionStart = true;

		public bool cleanupOnMissionFailed;

		public bool cleanupOnMissionSuccess;
	}

	[Serializable]
	public class MissionRewards
	{
		public ItemAmount[] items;

		public Era[] Eras;
	}

	public enum MissionFailReason
	{
		TimeOut,
		Disconnect,
		ResetPlayerState,
		Abandon,
		ObjectiveFailed
	}

	[ServerVar]
	public static bool missionsenabled = true;

	public string shortname;

	public Phrase missionName;

	public Phrase missionDesc;

	public bool canBeAbandoned = true;

	public bool completeSilently;

	public bool blockMissionStat;

	public TutorialMissionHelpSet showHelpInfo;

	public MissionObjectiveEntry[] objectives;

	public static List<Vector3> blockedPoints = new List<Vector3>();

	public const string MISSION_COMPLETE_STAT = "missions_completed";

	public GameObjectRef acceptEffect;

	public GameObjectRef failedEffect;

	public GameObjectRef victoryEffect;

	public BasePlayer.TutorialItemAllowance AllowedTutorialItems;

	public BaseMission followupMission;

	public int repeatDelaySecondsSuccess = -1;

	public int repeatDelaySecondsFailed = -1;

	public float timeLimitSeconds;

	public Sprite icon;

	public Sprite providerIcon;

	public bool hideStagesNotStarted;

	public MissionDependancy[] acceptDependancies;

	public MissionEntityEntry[] missionEntities;

	public PositionGenerator[] positionGenerators;

	public ItemAmount[] baseRewards;

	public MissionRewards[] alternativeRewards;

	public uint id => StringEx.ManifestHash(shortname);

	public bool isRepeatable
	{
		get
		{
			if (repeatDelaySecondsSuccess < 0)
			{
				return repeatDelaySecondsFailed >= 0;
			}
			return true;
		}
	}

	public static void PlayerDisconnected(BasePlayer player)
	{
		if (player.IsNpc)
		{
			return;
		}
		int activeMission = player.GetActiveMission();
		if (activeMission != -1 && activeMission < player.missions.Count)
		{
			MissionInstance missionInstance = player.missions[activeMission];
			BaseMission mission = missionInstance.GetMission();
			if (mission.missionEntities.Length != 0)
			{
				mission.MissionFailed(missionInstance, player, MissionFailReason.Disconnect);
			}
		}
	}

	public static void PlayerKilled(BasePlayer player)
	{
	}

	public ItemAmount[] GetMissionRewards()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Invalid comparison between I4 and Unknown
		if ((int)ConVar.Server.Era == 0)
		{
			return baseRewards;
		}
		if (alternativeRewards != null)
		{
			MissionRewards[] array = alternativeRewards;
			foreach (MissionRewards missionRewards in array)
			{
				if (missionRewards.Eras == null)
				{
					continue;
				}
				Era[] eras = missionRewards.Eras;
				for (int j = 0; j < eras.Length; j++)
				{
					if ((int)eras[j] == (int)ConVar.Server.Era && missionRewards.items != null)
					{
						return missionRewards.items;
					}
				}
			}
		}
		return baseRewards;
	}

	public virtual Sprite GetIcon(MissionInstance instance)
	{
		return icon;
	}

	public static void AddBlocker(Vector3 point)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (point != Vector3.zero && !blockedPoints.Contains(point))
		{
			blockedPoints.Add(point);
		}
	}

	public static void RemoveBlockers(MissionInstance instance)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		foreach (KeyValuePair<string, Vector3> missionPoint in instance.missionPoints)
		{
			blockedPoints.Remove(missionPoint.Value);
		}
	}

	public static void DoMissionEffect(string effectString, BasePlayer assignee)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Effect effect = new Effect();
		effect.Init(Effect.Type.Generic, assignee, StringPool.Get("head"), Vector3.zero, Vector3.forward);
		effect.pooledString = effectString;
		EffectNetwork.Send(effect, assignee.net.connection);
	}

	public virtual void MissionStart(MissionInstance instance, BasePlayer assignee)
	{
		if (Interface.CallHook("OnMissionStart", (object)this, (object)instance, (object)assignee) != null)
		{
			return;
		}
		for (int i = 0; i < objectives.Length; i++)
		{
			objectives[i].Get().MissionStarted(i, instance, assignee);
		}
		if (acceptEffect.isValid)
		{
			DoMissionEffect(acceptEffect.resourcePath, assignee);
		}
		MissionEntityEntry[] array = missionEntities;
		foreach (MissionEntityEntry missionEntityEntry in array)
		{
			if (missionEntityEntry.spawnOnMissionStart)
			{
				instance.GetMissionEntity(missionEntityEntry.identifier, assignee);
			}
		}
		if (AllowedTutorialItems != 0)
		{
			assignee.SetTutorialAllowance(AllowedTutorialItems);
		}
		Interface.CallHook("OnMissionStarted", (object)this, (object)instance, (object)assignee);
	}

	public void CheckObjectives(MissionInstance instance, BasePlayer assignee)
	{
		bool flag = true;
		bool flag2 = false;
		for (int i = 0; i < objectives.Length; i++)
		{
			if (objectives[i].isRequired && (!instance.objectiveStatuses[i].completed || instance.objectiveStatuses[i].failed))
			{
				flag = false;
			}
			if (instance.objectiveStatuses[i].failed && objectives[i].isRequired)
			{
				flag2 = true;
			}
		}
		if (instance.status == MissionStatus.Active)
		{
			if (flag2)
			{
				MissionFailed(instance, assignee, MissionFailReason.ObjectiveFailed);
			}
			else if (flag)
			{
				MissionSuccess(instance, assignee);
			}
		}
	}

	public virtual void Think(MissionInstance instance, BasePlayer assignee, float delta)
	{
		for (int i = 0; i < objectives.Length; i++)
		{
			objectives[i].Get().Think(i, instance, assignee, delta);
		}
		CheckObjectives(instance, assignee);
	}

	public virtual void MissionComplete(MissionInstance instance, BasePlayer assignee)
	{
		DoMissionEffect(victoryEffect.resourcePath, assignee);
		if (!instance.GetMission().completeSilently)
		{
			assignee.ChatMessage("You have completed the mission : " + missionName.english);
		}
		BaseMission mission = instance.GetMission();
		if (mission != null)
		{
			ItemAmount[] missionRewards = mission.GetMissionRewards();
			if (missionRewards != null)
			{
				ItemAmount[] array = missionRewards;
				foreach (ItemAmount reward2 in array)
				{
					GiveReward(assignee, reward2);
				}
			}
			for (int j = 0; j < mission.objectives.Length; j++)
			{
				MissionObjectiveEntry missionObjectiveEntry = mission.objectives[j];
				if (!missionObjectiveEntry.isRequired && missionObjectiveEntry.bonusRewards != null && instance.objectiveStatuses[j].completed && !instance.objectiveStatuses[j].failed)
				{
					ItemAmount[] array = missionObjectiveEntry.bonusRewards;
					foreach (ItemAmount reward3 in array)
					{
						GiveReward(assignee, reward3);
					}
				}
			}
		}
		Analytics.Azure.OnMissionComplete(assignee, this, null);
		instance.status = MissionStatus.Completed;
		assignee.SetActiveMission(-1);
		assignee.MissionDirty();
		if (followupMission != null)
		{
			assignee.RegisterFollowupMission(followupMission, instance.ProviderEntity() as IMissionProvider);
		}
		if (GameInfo.HasAchievements && mission != null && !mission.blockMissionStat)
		{
			assignee.stats.Add("missions_completed", 1, Stats.All);
			assignee.stats.Save(forceSteamSave: true);
		}
		if (assignee.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = assignee.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null && currentTutorialIsland.FinalMission == this)
			{
				currentTutorialIsland.StartEndingCinematic(assignee);
			}
		}
		static void GiveReward(BasePlayer player, ItemAmount reward)
		{
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)reward.itemDef == (Object)null || reward.amount == 0f)
			{
				Debug.LogError((object)"BIG REWARD SCREWUP, NULL ITEM DEF");
			}
			else if (!reward.itemDef.IsAllowedInEra((EraRestriction)8))
			{
				Debug.LogError((object)$"Blocking mission reward '{reward.itemDef.shortname}' not allowed in era '{ConVar.Server.Era}'");
			}
			else
			{
				Item item = (reward.isBP ? ItemManager.Create(ItemManager.blueprintBaseDef, Mathf.CeilToInt(reward.amount), 0uL) : ItemManager.Create(reward.itemDef, Mathf.CeilToInt(reward.amount), 0uL));
				if (reward.isBP)
				{
					item.blueprintTarget = reward.itemDef.itemid;
				}
				item.SetItemOwnership(player, ItemOwnershipPhrases.MissionRewardPhrase);
				if (item != null)
				{
					player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
				}
			}
		}
	}

	public virtual void MissionSuccess(MissionInstance instance, BasePlayer assignee)
	{
		instance.status = MissionStatus.Accomplished;
		MissionEnded(instance, assignee);
		MissionComplete(instance, assignee);
		Interface.CallHook("OnMissionSucceeded", (object)this, (object)instance, (object)assignee);
	}

	public virtual void MissionFailed(MissionInstance instance, BasePlayer assignee, MissionFailReason failReason)
	{
		if (!instance.GetMission().completeSilently)
		{
			assignee.ChatMessage("You have failed the mission : " + missionName.english);
		}
		DoMissionEffect(failedEffect.resourcePath, assignee);
		Analytics.Azure.OnMissionComplete(assignee, this, failReason);
		instance.status = MissionStatus.Failed;
		MissionEnded(instance, assignee);
		Interface.CallHook("OnMissionFailed", (object)this, (object)instance, (object)assignee, (object)failReason);
	}

	public virtual void MissionEnded(MissionInstance instance, BasePlayer assignee)
	{
		if (instance.missionEntities != null)
		{
			List<MissionEntity> list = Pool.Get<List<MissionEntity>>();
			foreach (MissionEntity value in instance.missionEntities.Values)
			{
				list.Add(value);
			}
			foreach (MissionEntity item in list)
			{
				if (!((Object)(object)item == (Object)null))
				{
					item.MissionEnded(assignee, instance);
				}
			}
			Pool.FreeUnmanaged<MissionEntity>(ref list);
		}
		RemoveBlockers(instance);
		instance.endTime = Time.time;
		assignee.SetActiveMission(-1);
		assignee.MissionDirty();
	}

	public void OnObjectiveCompleted(int objectiveIndex, MissionInstance instance, BasePlayer playerFor)
	{
		MissionObjectiveEntry missionObjectiveEntry = objectives[objectiveIndex];
		if (missionObjectiveEntry.autoCompleteOtherObjectives.Length != 0)
		{
			int[] autoCompleteOtherObjectives = missionObjectiveEntry.autoCompleteOtherObjectives;
			foreach (int num in autoCompleteOtherObjectives)
			{
				MissionObjectiveEntry missionObjectiveEntry2 = objectives[num];
				if (!instance.objectiveStatuses[num].completed)
				{
					missionObjectiveEntry2.objective.CompleteObjective(num, instance, playerFor);
				}
			}
		}
		CheckObjectives(instance, playerFor);
	}

	public void OnObjectiveFailed(int objectiveIndex, MissionInstance instance, BasePlayer playerFor)
	{
		CheckObjectives(instance, playerFor);
	}

	public static bool AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)
	{
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		if (!missionsenabled)
		{
			return false;
		}
		if (!mission.IsEligableForMission(assignee, provider))
		{
			return false;
		}
		object obj = Interface.CallHook("CanAssignMission", (object)assignee, (object)mission, (object)provider);
		if (obj is bool)
		{
			return (bool)obj;
		}
		int num = List.FindIndexWith<MissionInstance, uint>((IReadOnlyList<MissionInstance>)assignee.missions, (Func<MissionInstance, uint>)((MissionInstance i) => i.missionID), mission.id, (IEqualityComparer<uint>)null);
		MissionInstance missionInstance;
		int activeMission;
		if (num >= 0)
		{
			missionInstance = assignee.missions[num];
			activeMission = num;
			missionInstance.Reset();
		}
		else
		{
			missionInstance = Pool.Get<MissionInstance>();
			activeMission = assignee.missions.Count;
			assignee.missions.Add(missionInstance);
		}
		missionInstance.missionID = mission.id;
		missionInstance.startTime = Time.time;
		missionInstance.providerID = provider.ProviderID();
		missionInstance.status = MissionStatus.Active;
		missionInstance.objectiveStatuses = new MissionInstance.ObjectiveStatus[mission.objectives.Length];
		for (int j = 0; j < mission.objectives.Length; j++)
		{
			missionInstance.objectiveStatuses[j] = new MissionInstance.ObjectiveStatus();
		}
		mission.MissionStart(missionInstance, assignee);
		assignee.SetActiveMission(activeMission);
		assignee.MissionDirty();
		Interface.CallHook("OnMissionAssigned", (object)mission, (object)provider, (object)assignee);
		return true;
	}

	public bool IsEligableForMission(BasePlayer player, IMissionProvider provider)
	{
		if (!missionsenabled)
		{
			return false;
		}
		foreach (MissionInstance mission in player.missions)
		{
			if (mission.status == MissionStatus.Accomplished || mission.status == MissionStatus.Active)
			{
				return false;
			}
		}
		return true;
	}
}


using System;
using UnityEngine;

[Serializable]
public class MissionDependancy
{
	public BaseMission targetMission;

	public MissionStatus targetMissionDesiredStatus;

	public bool everAttempted;

	public uint targetMissionID
	{
		get
		{
			if (!(targetMission != null))
			{
				return 0u;
			}
			return StringEx.ManifestHash(targetMission.shortname);
		}
	}
}


public enum MissionStatus
{
	Default,
	Active,
	Accomplished,
	Failed,
	Completed
}


public enum MissionEventType
{
	CUSTOM,
	HARVEST,
	CONVERSATION,
	KILL_ENTITY,
	ACQUIRE_ITEM,
	FREE_CRATE,
	MOUNT_ENTITY,
	HURT_ENTITY,
	PLAYER_TICK,
	CRAFT_ITEM,
	DEPLOY,
	HEAL,
	CLOTHINGCHANGED,
	STARTOVEN,
	CONSUME,
	ACQUITE_ITEM_STACK,
	OPEN_STORAGE,
	COOK,
	ENTER_TRIGGER,
	UPGRADE_BUILDING_GRADE,
	RESPAWN,
	METAL_DETECTOR_FIND
}


using System;

[Serializable]
public class MissionObjectiveEntry
{
	public Phrase description;

	public int[] startAfterCompletedObjectives;

	public int[] autoCompleteOtherObjectives;

	public bool onlyProgressIfStarted = true;

	public bool isRequired = true;

	public MissionObjective objective;

	public string[] requiredEntities;

	public ItemAmount[] bonusRewards;

	public MissionObjective Get()
	{
		return objective;
	}
}


using UnityEngine;

public struct MissionEventPayload
{
	public NetworkableId NetworkIdentifier;

	public uint UintIdentifier;

	public int IntIdentifier;

	public Vector3 WorldPosition;
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.Extend;
using UnityEngine;

public class MissionInstance : IPooled
{
	[Serializable]
	public class ObjectiveStatus
	{
		public bool started;

		public bool completed;

		public bool failed;

		public float progressTarget;

		public float progressCurrent;

		public RealTimeSince sinceLastThink;
	}

	public enum ObjectiveType
	{
		MOVE,
		KILL
	}

	private BaseEntity _cachedProviderEntity;

	private BaseMission _cachedMission;

	public NetworkableId providerID;

	public uint missionID;

	public MissionStatus status;

	public float startTime;

	public float endTime;

	public Vector3 missionLocation;

	public float timePassed;

	public Dictionary<string, Vector3> missionPoints = new Dictionary<string, Vector3>();

	public Dictionary<string, MissionEntity> missionEntities = new Dictionary<string, MissionEntity>();

	private int playerInputCounter;

	public ObjectiveStatus[] objectiveStatuses;

	public BaseEntity ProviderEntity()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)_cachedProviderEntity == (Object)null)
		{
			_cachedProviderEntity = BaseNetworkable.serverEntities.Find(providerID) as BaseEntity;
		}
		return _cachedProviderEntity;
	}

	public BaseMission GetMission()
	{
		if (_cachedMission == null)
		{
			_cachedMission = MissionManifest.GetFromID(missionID);
		}
		return _cachedMission;
	}

	public bool ShouldShowOnMap()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if (status == MissionStatus.Active || status == MissionStatus.Accomplished)
		{
			return missionLocation != Vector3.zero;
		}
		return false;
	}

	public bool ShouldShowOnCompass()
	{
		return ShouldShowOnMap();
	}

	public bool NeedsPlayerInput()
	{
		return playerInputCounter > 0;
	}

	public void EnablePlayerInput()
	{
		playerInputCounter++;
	}

	public void DisablePlayerInput()
	{
		playerInputCounter--;
		if (playerInputCounter < 0)
		{
			playerInputCounter = 0;
		}
	}

	public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionEventType type, MissionEventPayload payload, float amount)
	{
		if (status == MissionStatus.Active)
		{
			BaseMission mission = GetMission();
			for (int i = 0; i < mission.objectives.Length; i++)
			{
				mission.objectives[i].objective.ProcessMissionEvent(playerFor, this, i, type, payload, amount);
			}
		}
	}

	public void Think(BasePlayer assignee, float delta)
	{
		if (status != MissionStatus.Failed && status != MissionStatus.Completed)
		{
			BaseMission mission = GetMission();
			timePassed += delta;
			mission.Think(this, assignee, delta);
			if (mission.timeLimitSeconds > 0f && timePassed >= mission.timeLimitSeconds)
			{
				mission.MissionFailed(this, assignee, MissionFailReason.TimeOut);
			}
		}
	}

	public Vector3 GetMissionPoint(string identifier, BasePlayer playerFor, int depth = 0)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		if (identifier == null)
		{
			identifier = "";
		}
		if (missionPoints.TryGetValue(identifier, out var value))
		{
			return value;
		}
		BaseMission mission = GetMission();
		if ((Object)(object)playerFor == (Object)null)
		{
			Debug.LogError((object)("Massive mission failure to get point, correct mission definition of: " + mission.shortname + " (player is null)"));
			return Vector3.zero;
		}
		PositionGenerator positionGenerator = List.FindWith<PositionGenerator, string>((IReadOnlyCollection<PositionGenerator>)(object)mission.positionGenerators, (Func<PositionGenerator, string>)((PositionGenerator p) => p.identifier), identifier, (IEqualityComparer<string>)null);
		if (positionGenerator == null)
		{
			Debug.LogError((object)("Massive mission failure to get point, correct mission definition of: " + mission.shortname + " (cannot find position '" + identifier + "')"));
			return Vector3.zero;
		}
		Vector3 position = positionGenerator.GetPosition(this, playerFor, depth);
		missionPoints.Add(identifier, position);
		AddBlocker(position);
		return position;
	}

	public MissionEntity GetMissionEntity(string identifier, BasePlayer playerFor)
	{
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		if (identifier == null)
		{
			identifier = "";
		}
		if (missionEntities.TryGetValue(identifier, out var value))
		{
			return value;
		}
		MissionEntityEntry missionEntityEntry = List.FindWith<MissionEntityEntry, string>((IReadOnlyCollection<MissionEntityEntry>)(object)GetMission().missionEntities, (Func<MissionEntityEntry, string>)((MissionEntityEntry e) => e.identifier), identifier, (IEqualityComparer<string>)null);
		if (missionEntityEntry == null)
		{
			Debug.LogError((object)$"Cannot spawn mission entity, identifier '{identifier}' not found in mission ID {missionID}");
			value = null;
		}
		else if (!missionEntityEntry.entityRef.isValid)
		{
			Debug.LogError((object)$"Cannot spawn mission entity, identifier '{identifier}' has no entity set in mission ID {missionID}");
			value = null;
		}
		else
		{
			Vector3 missionPoint = GetMissionPoint(missionEntityEntry.spawnPositionToUse, playerFor);
			BaseEntity baseEntity = GameManager.server.CreateEntity(missionEntityEntry.entityRef.resourcePath, missionPoint, Quaternion.identity);
			MissionEntity missionEntity = default(MissionEntity);
			MissionEntity obj = (((Component)baseEntity).gameObject.TryGetComponent<MissionEntity>(ref missionEntity) ? missionEntity : ((Component)baseEntity).gameObject.AddComponent<MissionEntity>());
			obj.Setup(playerFor, this, identifier, missionEntityEntry.cleanupOnMissionSuccess, missionEntityEntry.cleanupOnMissionFailed);
			baseEntity.Spawn();
			value = obj;
		}
		missionEntities.Add(identifier, value);
		if ((Object)(object)value != (Object)null)
		{
			value.MissionStarted(playerFor, this);
		}
		return value;
	}

	public void PostServerLoad(BasePlayer player)
	{
		BaseMission mission = GetMission();
		for (int i = 0; i < mission.objectives.Length; i++)
		{
			if (i >= 0 && i < objectiveStatuses.Length)
			{
				mission.objectives[i].objective.PostServerLoad(player, objectiveStatuses[i]);
			}
		}
	}

	public int GetTotalRequiredRewardItemSlots()
	{
		BaseMission mission = GetMission();
		int num = 0;
		for (int i = 0; i < mission.objectives.Length; i++)
		{
			if (!mission.objectives[i].isRequired && objectiveStatuses[i].completed)
			{
				num += mission.objectives[i].bonusRewards.Length;
			}
		}
		return mission.GetMissionRewards().Length + num;
	}

	public void Reset()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		providerID = default(NetworkableId);
		missionID = 0u;
		status = MissionStatus.Default;
		startTime = -1f;
		endTime = -1f;
		missionLocation = Vector3.zero;
		_cachedMission = null;
		timePassed = 0f;
		missionPoints.Clear();
		missionEntities.Clear();
	}

	public void EnterPool()
	{
		Reset();
	}

	public void LeavePool()
	{
	}
}


using System;

[Serializable]
public class ObjectiveStatus
{
	public bool started;

	public bool completed;

	public bool failed;

	public float progressTarget;

	public float progressCurrent;

	public RealTimeSince sinceLastThink;
}


public enum ObjectiveType
{
	MOVE,
	KILL
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[Serializable]
public class PositionGenerator
{
	public enum RelativeType
	{
		Player,
		Provider,
		Position
	}

	public enum PositionType
	{
		MissionPoint,
		WorldPositionGenerator,
		DungeonPoint,
		Radius
	}

	public string identifier;

	public float minDistForMovePoint;

	public float maxDistForMovePoint = 25f;

	public bool allowDoubleDistanceIfNoOptionsAreFound;

	public RelativeType relativeTo;

	public PositionType positionType;

	public string centerOnPositionIdentifier = "";

	[InspectorFlags]
	public MissionPoint.MissionPointEnum Flags = (MissionPoint.MissionPointEnum)(-1);

	[InspectorFlags]
	public MissionPoint.MissionPointEnum ExclusionFlags;

	public WorldPositionGenerator worldPositionGenerator;

	public bool IsDependant()
	{
		return !string.IsNullOrEmpty(centerOnPositionIdentifier);
	}

	public bool Validate(BasePlayer assignee, BaseMission missionDef)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position;
		if (positionType == PositionType.MissionPoint)
		{
			List<MissionPoint> points = Pool.Get<List<MissionPoint>>();
			bool missionPoints = MissionPoint.GetMissionPoints(ref points, ((Component)assignee).transform.position, minDistForMovePoint, maxDistForMovePoint, (int)Flags, (int)ExclusionFlags);
			if (!missionPoints && allowDoubleDistanceIfNoOptionsAreFound)
			{
				points.Clear();
				missionPoints = MissionPoint.GetMissionPoints(ref points, ((Component)assignee).transform.position, minDistForMovePoint, maxDistForMovePoint * 2f, (int)Flags, (int)ExclusionFlags);
			}
			Pool.FreeUnmanaged<MissionPoint>(ref points);
			if (!missionPoints)
			{
				Debug.Log((object)"FAILED TO FIND MISSION POINTS");
				return false;
			}
		}
		else if (positionType == PositionType.WorldPositionGenerator && (Object)(object)worldPositionGenerator != (Object)null && !worldPositionGenerator.TrySample(((Component)assignee).transform.position, minDistForMovePoint, maxDistForMovePoint, out position, blockedPoints))
		{
			Debug.Log((object)"FAILED TO GENERATE WORLD POSITION!!!!!");
			return false;
		}
		return true;
	}

	public Vector3 GetPosition(MissionInstance instance, BasePlayer assignee, int depth = 0)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		if (depth > 10)
		{
			Debug.LogError((object)$"Exceeded max depth while calculating position! missionID={instance.missionID} identifier={identifier}");
			return ((Component)assignee).transform.position;
		}
		Vector3 relativeToPosition = GetRelativeToPosition(instance, assignee, depth);
		Vector3 result;
		if (positionType == PositionType.MissionPoint)
		{
			List<MissionPoint> points = Pool.Get<List<MissionPoint>>();
			bool missionPoints = MissionPoint.GetMissionPoints(ref points, relativeToPosition, minDistForMovePoint, maxDistForMovePoint, (int)Flags, (int)ExclusionFlags);
			if (!missionPoints && allowDoubleDistanceIfNoOptionsAreFound)
			{
				points.Clear();
				missionPoints = MissionPoint.GetMissionPoints(ref points, relativeToPosition, minDistForMovePoint, maxDistForMovePoint * 2f, (int)Flags, (int)ExclusionFlags);
			}
			if (missionPoints)
			{
				result = points[Random.Range(0, points.Count)].GetPosition();
			}
			else
			{
				Debug.LogError((object)"UNABLE TO FIND MISSIONPOINT FOR MISSION!");
				result = relativeToPosition;
			}
			Pool.FreeUnmanaged<MissionPoint>(ref points);
		}
		else if (positionType == PositionType.WorldPositionGenerator && (Object)(object)worldPositionGenerator != (Object)null)
		{
			int num = 0;
			while (true)
			{
				if (worldPositionGenerator.TrySample(relativeToPosition, minDistForMovePoint, maxDistForMovePoint, out var position, blockedPoints) && TryAlignToGround(position, out var correctedPosition))
				{
					result = correctedPosition;
					break;
				}
				if (num >= 10)
				{
					Debug.LogError((object)"UNABLE TO FIND WORLD POINT FOR MISSION!");
					result = relativeToPosition;
					break;
				}
				num++;
			}
		}
		else if (positionType == PositionType.DungeonPoint)
		{
			result = DynamicDungeon.GetNextDungeonPoint();
		}
		else
		{
			int num2 = 0;
			while (true)
			{
				Vector3 onUnitSphere = Random.onUnitSphere;
				onUnitSphere.y = 0f;
				((Vector3)(ref onUnitSphere)).Normalize();
				Vector3 val = relativeToPosition + onUnitSphere * Random.Range(minDistForMovePoint, maxDistForMovePoint);
				val.y = WaterLevel.GetWaterOrTerrainSurface(val, waves: false, volumes: false);
				if (TryAlignToGround(val, out var correctedPosition2))
				{
					result = correctedPosition2;
					break;
				}
				if (num2 >= 10)
				{
					Debug.LogError((object)"UNABLE TO FIND WORLD POINT FOR MISSION!");
					result = relativeToPosition;
					break;
				}
				num2++;
			}
		}
		return result;
	}

	private Vector3 GetRelativeToPosition(MissionInstance instance, BasePlayer assignee, int depth)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		switch (relativeTo)
		{
		case RelativeType.Position:
			return instance.GetMissionPoint(centerOnPositionIdentifier, assignee, depth + 1);
		case RelativeType.Provider:
		{
			BaseEntity baseEntity = instance.ProviderEntity();
			if ((Object)(object)baseEntity != (Object)null)
			{
				return ((Component)baseEntity).transform.position;
			}
			break;
		}
		}
		if ((Object)(object)assignee != (Object)null)
		{
			return ((Component)assignee).transform.position;
		}
		Debug.LogError((object)$"Cannot get mission point origin - assigne playere is null! missionID={instance.missionID} relativeTo={relativeTo}");
		return Vector3.zero;
	}

	private static bool TryAlignToGround(Vector3 wishPosition, out Vector3 correctedPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3Ex.WithY(wishPosition, wishPosition.y + 50f);
		RaycastHit hit = default(RaycastHit);
		if (!Physics.Raycast(new Ray(val, Vector3.down), ref hit, 50f, 1218652417, (QueryTriggerInteraction)1))
		{
			correctedPosition = wishPosition;
			return true;
		}
		if ((Object)(object)hit.GetEntity() != (Object)null)
		{
			correctedPosition = wishPosition;
			return false;
		}
		correctedPosition = ((RaycastHit)(ref hit)).point;
		return true;
	}
}


public enum RelativeType
{
	Player,
	Provider,
	Position
}


public enum PositionType
{
	MissionPoint,
	WorldPositionGenerator,
	DungeonPoint,
	Radius
}


using System;
using UnityEngine.Serialization;

[Serializable]
public class MissionEntityEntry
{
	[FormerlySerializedAs("entityIdentifier")]
	public string identifier;

	public GameObjectRef entityRef;

	public string spawnPositionToUse;

	public bool spawnOnMissionStart = true;

	public bool cleanupOnMissionFailed;

	public bool cleanupOnMissionSuccess;
}


using System;
using Rust;

[Serializable]
public class MissionRewards
{
	public ItemAmount[] items;

	public Era[] Eras;
}


public enum MissionFailReason
{
	TimeOut,
	Disconnect,
	ResetPlayerState,
	Abandon,
	ObjectiveFailed
}


public class DebugWorldPosition : ListComponent<DebugWorldPosition>
{
	public WorldPositionGenerator GeneratorToFake;
}


using UnityEngine;

public class MissionEntity : BaseMonoBehaviour, IOnParentDestroying
{
	public string identifier;

	public bool cleanupOnMissionSuccess = true;

	public bool cleanupOnMissionFailed = true;

	public void OnParentDestroying()
	{
		Object.Destroy((Object)(object)this);
	}

	public virtual void Setup(BasePlayer assignee, BaseMission.MissionInstance instance, string identifier, bool wantsSuccessCleanup, bool wantsFailedCleanup)
	{
		this.identifier = identifier;
		cleanupOnMissionFailed = wantsFailedCleanup;
		cleanupOnMissionSuccess = wantsSuccessCleanup;
		BaseEntity entity = GetEntity();
		if (Object.op_Implicit((Object)(object)entity))
		{
			((Component)entity).SendMessage("MissionSetupPlayer", (object)assignee, (SendMessageOptions)1);
		}
	}

	public virtual void MissionStarted(BasePlayer assignee, BaseMission.MissionInstance instance)
	{
		IMissionEntityListener[] componentsInChildren = ((Component)this).GetComponentsInChildren<IMissionEntityListener>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].MissionStarted(assignee, instance);
		}
	}

	public virtual void MissionEnded(BasePlayer assignee, BaseMission.MissionInstance instance)
	{
		IMissionEntityListener[] componentsInChildren = ((Component)this).GetComponentsInChildren<IMissionEntityListener>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].MissionEnded(assignee, instance);
		}
		instance.missionEntities.Remove(identifier);
		if ((cleanupOnMissionSuccess && (instance.status == BaseMission.MissionStatus.Completed || instance.status == BaseMission.MissionStatus.Accomplished)) || (cleanupOnMissionFailed && instance.status == BaseMission.MissionStatus.Failed))
		{
			BaseEntity entity = GetEntity();
			if (Object.op_Implicit((Object)(object)entity))
			{
				entity.Kill();
			}
		}
	}

	public BaseEntity GetEntity()
	{
		return ((Component)this).GetComponent<BaseEntity>();
	}
}


public interface IMissionEntityListener
{
	void MissionStarted(BasePlayer assignee, BaseMission.MissionInstance instance);

	void MissionEnded(BasePlayer assignee, BaseMission.MissionInstance instance);
}


using UnityEngine;

public interface IMissionProvider
{
	NetworkableId ProviderID();

	Vector3 ProviderPosition();

	BaseEntity Entity();
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/MissionManifest")]
public class MissionManifest : ScriptableObject
{
	public ScriptableObjectRef[] missionList;

	public WorldPositionGenerator[] positionGenerators;

	public static MissionManifest instance;

	public static MissionManifest Get()
	{
		if ((Object)(object)instance == (Object)null)
		{
			instance = Resources.Load<MissionManifest>("MissionManifest");
			WorldPositionGenerator[] array = instance.positionGenerators;
			foreach (WorldPositionGenerator worldPositionGenerator in array)
			{
				if ((Object)(object)worldPositionGenerator != (Object)null)
				{
					worldPositionGenerator.PrecalculatePositions();
				}
			}
		}
		return instance;
	}

	public static BaseMission GetFromShortName(string shortname)
	{
		ScriptableObjectRef[] array = Get().missionList;
		for (int i = 0; i < array.Length; i++)
		{
			BaseMission baseMission = array[i].Get() as BaseMission;
			if (baseMission.shortname == shortname)
			{
				return baseMission;
			}
		}
		return null;
	}

	public static BaseMission GetFromID(uint id)
	{
		MissionManifest missionManifest = Get();
		if (missionManifest.missionList == null)
		{
			return null;
		}
		ScriptableObjectRef[] array = missionManifest.missionList;
		for (int i = 0; i < array.Length; i++)
		{
			BaseMission baseMission = array[i].Get() as BaseMission;
			if (baseMission.id == id)
			{
				return baseMission;
			}
		}
		return null;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

public class MissionPoint : MonoBehaviour
{
	public enum MissionPointEnum
	{
		EasyMonument = 1,
		MediumMonument = 2,
		HardMonument = 4,
		Item_Hidespot = 8,
		Underwater = 0x80,
		Tutorial_Bear = 0x100
	}

	public bool dropToGround = true;

	public const int COUNT = 8;

	public const int EVERYTHING = -1;

	public const int NOTHING = 0;

	public const int EASY_MONUMENT = 1;

	public const int MED_MONUMENT = 2;

	public const int HARD_MONUMENT = 4;

	public const int ITEM_HIDESPOT = 8;

	public const int UNDERWATER = 128;

	public const int TUTORIAL_BEAR = 256;

	public const int EASY_MONUMENT_IDX = 0;

	public const int MED_MONUMENT_IDX = 1;

	public const int HARD_MONUMENT_IDX = 2;

	public const int ITEM_HIDESPOT_IDX = 3;

	public const int FOREST_IDX = 4;

	public const int ROADSIDE_IDX = 5;

	public const int BEACH = 6;

	public const int UNDERWATER_IDX = 7;

	public const int TUTORIAL_BEAR_IDX = 8;

	private static Dictionary<int, int> type2index = new Dictionary<int, int>
	{
		{ 1, 0 },
		{ 2, 1 },
		{ 4, 2 },
		{ 8, 3 },
		{ 128, 7 },
		{ 256, 8 }
	};

	[InspectorFlags]
	public MissionPointEnum Flags = (MissionPointEnum)(-1);

	public static List<MissionPoint> all = new List<MissionPoint>();

	public static int TypeToIndex(int id)
	{
		return type2index[id];
	}

	public static int IndexToType(int idx)
	{
		return 1 << idx;
	}

	public void Awake()
	{
		all.Add(this);
	}

	private void Start()
	{
		if (dropToGround)
		{
			((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)DropToGround, 0.5f);
		}
	}

	private void DropToGround()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)this))
		{
			if (Application.isLoading)
			{
				((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)DropToGround, 0.5f);
				return;
			}
			_ = ((Component)this).transform.position;
			((Component)this).transform.DropToGround();
		}
	}

	public void OnDisable()
	{
		if (all.Contains(this))
		{
			all.Remove(this);
		}
	}

	public virtual Vector3 GetPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public virtual Quaternion GetRotation()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.rotation;
	}

	public static bool GetMissionPoints(ref List<MissionPoint> points, Vector3 near, float minDistance, float maxDistance, int flags, int exclusionFlags)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		List<MissionPoint> list = Pool.Get<List<MissionPoint>>();
		foreach (MissionPoint item in all)
		{
			if (((uint)item.Flags & (uint)flags) != (uint)flags || (exclusionFlags != 0 && ((uint)item.Flags & (uint)exclusionFlags) != 0))
			{
				continue;
			}
			float num = Vector3.Distance(((Component)item).transform.position, near);
			if (!(num <= maxDistance) || !(num > minDistance))
			{
				continue;
			}
			if (BaseMission.blockedPoints.Count > 0)
			{
				bool flag = false;
				foreach (Vector3 blockedPoint in BaseMission.blockedPoints)
				{
					if (Vector3.Distance(blockedPoint, ((Component)item).transform.position) < 3f)
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					continue;
				}
			}
			list.Add(item);
		}
		if (list.Count == 0)
		{
			return false;
		}
		foreach (MissionPoint item2 in list)
		{
			points.Add(item2);
		}
		Pool.FreeUnmanaged<MissionPoint>(ref list);
		return true;
	}
}


public enum MissionPointEnum
{
	EasyMonument = 1,
	MediumMonument = 2,
	HardMonument = 4,
	Item_Hidespot = 8,
	Underwater = 0x80,
	Tutorial_Bear = 0x100
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/MoveMission")]
public class MoveMission : BaseMission
{
	public float minDistForMovePoint = 20f;

	public float maxDistForMovePoint = 25f;

	private float minDistFromLocation = 3f;

	public override void MissionStart(MissionInstance instance, BasePlayer assignee)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		Vector3 onUnitSphere = Random.onUnitSphere;
		onUnitSphere.y = 0f;
		((Vector3)(ref onUnitSphere)).Normalize();
		Vector3 val = ((Component)assignee).transform.position + onUnitSphere * Random.Range(minDistForMovePoint, maxDistForMovePoint);
		val.y = WaterLevel.GetWaterOrTerrainSurface(val, waves: false, volumes: false);
		instance.missionLocation = val;
		base.MissionStart(instance, assignee);
	}

	public override void MissionEnded(MissionInstance instance, BasePlayer assignee)
	{
		base.MissionEnded(instance, assignee);
	}

	public override Sprite GetIcon(MissionInstance instance)
	{
		if (instance.status != MissionStatus.Accomplished)
		{
			return icon;
		}
		return providerIcon;
	}

	public override void Think(MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3.Distance(instance.missionLocation, ((Component)assignee).transform.position);
		if (instance.status == MissionStatus.Active && num <= minDistFromLocation)
		{
			MissionSuccess(instance, assignee);
			BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(instance.providerID);
			if (Object.op_Implicit((Object)(object)baseNetworkable))
			{
				instance.missionLocation = ((Component)baseNetworkable).transform.position;
			}
		}
		else
		{
			if (instance.status == MissionStatus.Accomplished)
			{
				_ = minDistFromLocation;
			}
			base.Think(instance, assignee, delta);
		}
	}
}


using Rust.UI;
using UnityEngine;

public class MissionUIPanel : MonoBehaviour
{
	public GameObject activeMissionParent;

	public RustText missionTitleText;

	public RustText missionDescText;

	public GameObject rewardsParent;

	public VirtualItemIcon[] rewardIcons;

	public GameObject bonusRewardsParent;

	public VirtualItemIcon[] bonusIcons;

	public Phrase noMissionText;

	public GameObject abandonButton;
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public abstract class MissionObjective : ScriptableObject
{
	public virtual void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
	}

	public virtual void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		instance.objectiveStatuses[index].started = true;
		BaseMission mission = instance.GetMission();
		if (mission != null && mission.objectives[index].requiredEntities != null)
		{
			string[] requiredEntities = mission.objectives[index].requiredEntities;
			foreach (string identifier in requiredEntities)
			{
				instance.GetMissionEntity(identifier, playerFor);
			}
		}
		playerFor.MissionDirty();
	}

	public virtual void ObjectiveCompleted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
	}

	public virtual void ObjectiveFailed(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
	}

	public bool IsStarted(int index, BaseMission.MissionInstance instance)
	{
		if (instance == null || instance.objectiveStatuses.Length <= index)
		{
			return false;
		}
		return instance.objectiveStatuses[index].started;
	}

	public bool CanProgress(int index, BaseMission.MissionInstance instance)
	{
		if (instance.GetMission().objectives[index].onlyProgressIfStarted)
		{
			return IsStarted(index, instance);
		}
		return true;
	}

	public bool ShouldObjectiveStart(int index, BaseMission.MissionInstance instance)
	{
		int[] startAfterCompletedObjectives = instance.GetMission().objectives[index].startAfterCompletedObjectives;
		foreach (int num in startAfterCompletedObjectives)
		{
			if (!instance.objectiveStatuses[num].completed && !instance.objectiveStatuses[num].failed)
			{
				return false;
			}
		}
		return true;
	}

	public bool IsCompleted(int index, BaseMission.MissionInstance instance)
	{
		if (!instance.objectiveStatuses[index].completed)
		{
			return instance.objectiveStatuses[index].failed;
		}
		return true;
	}

	public virtual bool ShouldThink(int index, BaseMission.MissionInstance instance)
	{
		return !IsCompleted(index, instance);
	}

	public void ResetObjective(int index, BaseMission.MissionInstance instance, BasePlayer playerFor)
	{
		if (instance.objectiveStatuses[index].completed || instance.objectiveStatuses[index].failed)
		{
			instance.objectiveStatuses[index].completed = false;
			instance.objectiveStatuses[index].failed = false;
			playerFor.MissionDirty();
		}
	}

	public void CompleteObjective(int index, BaseMission.MissionInstance instance, BasePlayer playerFor)
	{
		if (!instance.objectiveStatuses[index].completed && !instance.objectiveStatuses[index].failed)
		{
			instance.objectiveStatuses[index].completed = true;
			instance.GetMission().OnObjectiveCompleted(index, instance, playerFor);
			playerFor.MissionDirty();
			ObjectiveCompleted(playerFor, index, instance);
		}
	}

	public void FailObjective(int index, BaseMission.MissionInstance instance, BasePlayer playerFor)
	{
		if (!instance.objectiveStatuses[index].completed && !instance.objectiveStatuses[index].failed)
		{
			instance.objectiveStatuses[index].failed = true;
			instance.GetMission().OnObjectiveFailed(index, instance, playerFor);
			playerFor.MissionDirty();
			ObjectiveFailed(playerFor, index, instance);
		}
	}

	public virtual void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
	}

	public virtual void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		if (ShouldObjectiveStart(index, instance) && !IsStarted(index, instance))
		{
			ObjectiveStarted(assignee, index, instance);
		}
	}

	protected bool TryFindNearby<T>(Vector3 origin, Func<T, bool> filter, out T entity, float radius = 20f) where T : BaseEntity
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		List<T> list = Pool.Get<List<T>>();
		Vis.Entities(origin, radius, list, -1, (QueryTriggerInteraction)2);
		int num = -1;
		float num2 = float.PositiveInfinity;
		for (int i = 0; i < list.Count; i++)
		{
			T val = list[i];
			if (filter == null || filter(val))
			{
				float num3 = Vector3.Distance(((Component)val).transform.position, origin);
				if (num3 < num2)
				{
					num = i;
					num2 = num3;
				}
			}
		}
		bool flag = num != -1;
		entity = (flag ? list[num] : null);
		Pool.FreeUnmanaged<T>(ref list);
		return flag;
	}

	public virtual void PostServerLoad(BasePlayer player, BaseMission.MissionInstance.ObjectiveStatus status)
	{
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/AcquireItem")]
public class MissionObjective_AcquireItem : MissionObjective
{
	[ItemSelector(ItemCategory.All)]
	public ItemDefinition targetItem;

	public int targetItemAmount;

	public bool allowStackEvents;

	public bool showResourcePings;

	public bool acceptExistingItems;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetItemAmount;
		if (showResourcePings)
		{
			forPlayer.EnableResourcePings(targetItem, BasePlayer.PingType.GoTo);
		}
		if (acceptExistingItems)
		{
			int amount = forPlayer.inventory.GetAmount(targetItem);
			if (amount > 0)
			{
				ProcessMissionEvent(forPlayer, instance, index, BaseMission.MissionEventType.ACQUIRE_ITEM, new BaseMission.MissionEventPayload
				{
					IntIdentifier = targetItem.itemid
				}, amount);
			}
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (((type == BaseMission.MissionEventType.ACQUITE_ITEM_STACK && allowStackEvents) || type == BaseMission.MissionEventType.ACQUIRE_ITEM) && !IsCompleted(index, instance) && CanProgress(index, instance) && targetItem.itemid == payload.IntIdentifier)
		{
			instance.objectiveStatuses[index].progressCurrent += (int)amount;
			if (instance.objectiveStatuses[index].progressCurrent >= (float)targetItemAmount)
			{
				CompleteObjective(index, instance, playerFor);
			}
			if (showResourcePings)
			{
				playerFor.DisableResourcePings(targetItem, BasePlayer.PingType.GoTo);
			}
			playerFor.MissionDirty();
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		base.Think(index, instance, assignee, delta);
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Consume")]
public class MissionObjective_Consume : MissionObjective
{
	public ItemDefinition TargetItem;

	public int RequiredAmount;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = RequiredAmount;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.CONSUME && !IsCompleted(index, instance) && CanProgress(index, instance) && payload.IntIdentifier == TargetItem.itemid)
		{
			instance.objectiveStatuses[index].progressCurrent += 1f;
			if (instance.objectiveStatuses[index].progressCurrent >= instance.objectiveStatuses[index].progressTarget)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionDirty();
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/CookItem")]
public class MissionObjective_CookItem : MissionObjective
{
	[Tooltip("The cooked result that this objective is looking for (eg cooked chicken, not raw)")]
	[ItemSelector(ItemCategory.All)]
	public ItemDefinition targetItem;

	public int targetItemAmount;

	public BaseEntityRef[] pingEntitiesOnTutorialIsland;

	public BasePlayer.PingType pingType = BasePlayer.PingType.GoTo;

	public bool checkExistingInventory;

	private bool HasPings
	{
		get
		{
			if (pingEntitiesOnTutorialIsland != null)
			{
				return pingEntitiesOnTutorialIsland.Length != 0;
			}
			return false;
		}
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetItemAmount;
	}

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		base.ObjectiveStarted(playerFor, index, instance);
		if (HasPings)
		{
			TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				List<TutorialBuildTarget> list = Pool.Get<List<TutorialBuildTarget>>();
				BaseEntityRef[] array = pingEntitiesOnTutorialIsland;
				foreach (BaseEntityRef baseEntityRef in array)
				{
					list.Clear();
					currentTutorialIsland.GetBuildTargets(list, baseEntityRef.Get().prefabID);
					if (list.Count > 0)
					{
						List<BaseOven> list2 = Pool.Get<List<BaseOven>>();
						Vis.Entities(((Component)list[0]).transform.position, 0.25f, list2, 153092352, (QueryTriggerInteraction)2);
						if (list2.Count > 0)
						{
							playerFor.RegisterPingedEntity(list2[0], pingType);
						}
						Pool.FreeUnmanaged<BaseOven>(ref list2);
						break;
					}
				}
				Pool.FreeUnmanaged<TutorialBuildTarget>(ref list);
			}
		}
		if (checkExistingInventory)
		{
			int amount = playerFor.inventory.GetAmount(targetItem);
			if (amount > 0)
			{
				ProcessMissionEvent(playerFor, instance, index, BaseMission.MissionEventType.COOK, new BaseMission.MissionEventPayload
				{
					IntIdentifier = targetItem.itemid
				}, amount);
			}
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.COOK || IsCompleted(index, instance) || !CanProgress(index, instance) || targetItem.itemid != payload.IntIdentifier)
		{
			return;
		}
		instance.objectiveStatuses[index].progressCurrent += (int)amount;
		if (instance.objectiveStatuses[index].progressCurrent >= (float)targetItemAmount)
		{
			CompleteObjective(index, instance, playerFor);
			if (HasPings)
			{
				playerFor.DeregisterPingedEntity(payload.NetworkIdentifier, pingType);
			}
		}
		playerFor.MissionDirty();
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Craft")]
public class MissionObjective_Craft : MissionObjective
{
	[ItemSelector(ItemCategory.All)]
	public ItemDefinition[] targetItems;

	public int targetItemAmount;

	public bool checkExistingInventory;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetItemAmount;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.CRAFT_ITEM || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		ItemDefinition[] array = targetItems;
		foreach (ItemDefinition itemDefinition in array)
		{
			ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(payload.IntIdentifier);
			bool flag = (Object)(object)itemDefinition2 != (Object)null && (Object)(object)itemDefinition2.isRedirectOf != (Object)null && itemDefinition2.isRedirectOf.itemid == itemDefinition.itemid;
			if (itemDefinition.itemid == payload.IntIdentifier || flag)
			{
				instance.objectiveStatuses[index].progressCurrent += (int)amount;
				if (instance.objectiveStatuses[index].progressCurrent >= (float)targetItemAmount)
				{
					CompleteObjective(index, instance, playerFor);
				}
				playerFor.MissionDirty();
				break;
			}
		}
	}

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		if (checkExistingInventory)
		{
			int num = 0;
			ItemDefinition[] array = targetItems;
			foreach (ItemDefinition definition in array)
			{
				num += playerFor.inventory.GetAmount(definition);
			}
			if (num > 0)
			{
				ProcessMissionEvent(playerFor, instance, index, BaseMission.MissionEventType.CRAFT_ITEM, new BaseMission.MissionEventPayload
				{
					IntIdentifier = targetItems[0].itemid
				}, num);
			}
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Deploy")]
public class MissionObjective_DeployItem : MissionObjective
{
	public BaseEntity[] PossibleOptions = new BaseEntity[0];

	public ItemDefinition[] PossibleItems = new ItemDefinition[0];

	public int RequiredAmount = 1;

	public bool PingTutorialTargets;

	private const BasePlayer.PingType PingType = BasePlayer.PingType.Build;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = RequiredAmount;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		if (IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.DEPLOY && Matches(payload))
		{
			instance.objectiveStatuses[index].progressCurrent += amount;
			if (PingTutorialTargets)
			{
				UpdatePings(playerFor);
			}
			if (instance.objectiveStatuses[index].progressCurrent >= instance.objectiveStatuses[index].progressTarget)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionDirty();
		}
	}

	private bool Matches(BaseMission.MissionEventPayload payload)
	{
		BaseEntity[] possibleOptions = PossibleOptions;
		for (int i = 0; i < possibleOptions.Length; i++)
		{
			if (possibleOptions[i].prefabID == payload.UintIdentifier)
			{
				return true;
			}
		}
		ItemDefinition itemDefinition = null;
		ItemDefinition[] possibleItems = PossibleItems;
		foreach (ItemDefinition itemDefinition2 in possibleItems)
		{
			if (itemDefinition2.itemid == payload.IntIdentifier)
			{
				return true;
			}
			if ((Object)(object)itemDefinition == (Object)null)
			{
				itemDefinition = ItemManager.FindItemDefinition(payload.IntIdentifier);
			}
			if ((Object)(object)itemDefinition != (Object)null && (Object)(object)itemDefinition.isRedirectOf == (Object)(object)itemDefinition2)
			{
				return true;
			}
		}
		return false;
	}

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		if (PingTutorialTargets)
		{
			UpdatePings(playerFor);
		}
	}

	private void UpdatePings(BasePlayer playerFor)
	{
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
		if (!((Object)(object)currentTutorialIsland != (Object)null))
		{
			return;
		}
		List<TutorialBuildTarget> list = Pool.Get<List<TutorialBuildTarget>>();
		BaseEntity[] possibleOptions = PossibleOptions;
		foreach (BaseEntity baseEntity in possibleOptions)
		{
			currentTutorialIsland.GetBuildTargets(list, baseEntity.prefabID);
		}
		foreach (TutorialBuildTarget item in list)
		{
			item.UpdateActive(playerFor);
			if (((Component)item).gameObject.activeSelf)
			{
				playerFor.AddPingAtLocation(BasePlayer.PingType.Build, ((Component)item).transform.position, 86400f, currentTutorialIsland.net.ID);
			}
			else
			{
				playerFor.RemovePingAtLocation(BasePlayer.PingType.Build, ((Component)item).transform.position, 0.5f, currentTutorialIsland.net.ID);
			}
		}
		Pool.FreeUnmanaged<TutorialBuildTarget>(ref list);
	}
}


using UnityEngine;

public class MissionObjective_EnterTrigger : MissionObjective
{
	public string positionName = "default";

	public float distForCompletion = 3f;

	public bool use2D;

	public BaseMountable requiredMountable;

	public bool shouldPing;

	public BasePlayer.PingType pingType = BasePlayer.PingType.GoTo;

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		base.ObjectiveStarted(playerFor, index, instance);
		instance.missionLocation = instance.GetMissionPoint(positionName, playerFor);
		playerFor.MissionDirty();
		if (shouldPing)
		{
			TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				playerFor.AddPingAtLocation(pingType, instance.missionLocation, 86400f, currentTutorialIsland.net.ID);
			}
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (!ShouldThink(index, instance) || type != BaseMission.MissionEventType.ENTER_TRIGGER || ((Object)(object)requiredMountable != (Object)null && (!playerFor.isMounted || playerFor.GetMounted().prefabID != requiredMountable.prefabID)))
		{
			return;
		}
		CompleteObjective(index, instance, playerFor);
		if (shouldPing)
		{
			TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				playerFor.RemovePingAtLocation(pingType, instance.missionLocation, float.MaxValue, currentTutorialIsland.net.ID);
			}
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Equip Clothing")]
public class MissionObjective_EquipClothing : MissionObjective
{
	public ItemDefinition[] RequiredItems = new ItemDefinition[0];

	public bool CheckExistingClothingOnStart = true;

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		if (CheckExistingClothingOnStart)
		{
			ProcessMissionEvent(playerFor, instance, index, BaseMission.MissionEventType.CLOTHINGCHANGED, default(BaseMission.MissionEventPayload), 0f);
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (IsCompleted(index, instance) || !CanProgress(index, instance) || type != BaseMission.MissionEventType.CLOTHINGCHANGED)
		{
			return;
		}
		ItemDefinition[] requiredItems = RequiredItems;
		foreach (ItemDefinition searchFor in requiredItems)
		{
			if (!playerFor.inventory.containerWear.HasItem(searchFor))
			{
				return;
			}
		}
		CompleteObjective(index, instance, playerFor);
		playerFor.MissionDirty();
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Fill Tutorial TC")]
public class MissionObjective_FillTutorialToolCupboard : MissionObjective
{
	public int RequiredUpkeepHours = 24;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = RequiredUpkeepHours;
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		base.Think(index, instance, assignee, delta);
		if (!IsStarted(index, instance))
		{
			return;
		}
		BuildingPrivlidge buildingPrivilege = assignee.GetBuildingPrivilege();
		if (!((Object)(object)buildingPrivilege != (Object)null))
		{
			return;
		}
		int num = Mathf.RoundToInt(buildingPrivilege.GetProtectedMinutes() / 60f);
		if (num != Mathf.RoundToInt(instance.objectiveStatuses[index].progressCurrent))
		{
			instance.objectiveStatuses[index].progressCurrent = num;
			if (num >= RequiredUpkeepHours)
			{
				CompleteObjective(index, instance, assignee);
			}
			assignee.MissionDirty();
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/FreeCrate")]
public class MissionObjective_FreeCrate : MissionObjective
{
	public int targetAmount;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetAmount;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.FREE_CRATE && !IsCompleted(index, instance) && CanProgress(index, instance))
		{
			instance.objectiveStatuses[index].progressCurrent += (int)amount;
			if (instance.objectiveStatuses[index].progressCurrent >= (float)targetAmount)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionDirty();
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		base.Think(index, instance, assignee, delta);
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Harvest")]
public class MissionObjective_Harvest : MissionObjective
{
	[ItemSelector(ItemCategory.All)]
	public ItemDefinition[] targetItems;

	public int targetItemAmount;

	public ItemDefinition[] pingResourceDispensers;

	public BasePlayer.PingType pingType = BasePlayer.PingType.GoTo;

	public bool countExisting;

	public override void PostServerLoad(BasePlayer player, BaseMission.MissionInstance.ObjectiveStatus status)
	{
		base.PostServerLoad(player, status);
		if (status.started && !status.completed)
		{
			InitialiseResourcePings(player);
		}
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetItemAmount;
	}

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		InitialiseResourcePings(playerFor);
		if (countExisting && targetItems.Length != 0)
		{
			int num = 0;
			ItemDefinition[] array = targetItems;
			foreach (ItemDefinition definition in array)
			{
				num += playerFor.inventory.GetAmount(definition);
			}
			ProcessMissionEvent(playerFor, instance, index, BaseMission.MissionEventType.HARVEST, new BaseMission.MissionEventPayload
			{
				IntIdentifier = targetItems[0].itemid
			}, num);
		}
	}

	private void InitialiseResourcePings(BasePlayer forPlayer)
	{
		if (pingResourceDispensers != null)
		{
			ItemDefinition[] array = pingResourceDispensers;
			foreach (ItemDefinition forItem in array)
			{
				forPlayer.EnableResourcePings(forItem, pingType);
			}
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.HARVEST || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		ItemDefinition[] array = targetItems;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].itemid == payload.IntIdentifier)
			{
				instance.objectiveStatuses[index].progressCurrent += (int)amount;
				if (instance.objectiveStatuses[index].progressCurrent >= (float)targetItemAmount)
				{
					CompleteObjective(index, instance, playerFor);
				}
				playerFor.MissionDirty();
				break;
			}
		}
	}

	public override void ObjectiveCompleted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveCompleted(playerFor, index, instance);
		if (pingResourceDispensers != null)
		{
			ItemDefinition[] array = pingResourceDispensers;
			foreach (ItemDefinition forItem in array)
			{
				playerFor.DisableResourcePings(forItem, pingType);
			}
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/HaveItem")]
public class MissionObjective_HaveItem : MissionObjective
{
	[ItemSelector(ItemCategory.All)]
	public ItemDefinition targetItem;

	public int targetItemAmount;

	public bool canBeReset = true;

	public BaseEntityRef[] pingEntitiesOnTutorialIsland;

	public BasePlayer.PingType pingType = BasePlayer.PingType.GoTo;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetItemAmount;
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		base.Think(index, instance, assignee, delta);
		if (!IsStarted(index, instance) || (Object)(object)targetItem == (Object)null)
		{
			return;
		}
		int amount = assignee.inventory.GetAmount(targetItem.itemid);
		bool completed = instance.objectiveStatuses[index].completed;
		bool flag = amount >= targetItemAmount;
		if (!canBeReset && completed)
		{
			return;
		}
		if (completed != flag)
		{
			if (flag)
			{
				CompleteObjective(index, instance, assignee);
			}
			else
			{
				ResetObjective(index, instance, assignee);
			}
		}
		if (amount != (int)instance.objectiveStatuses[index].progressCurrent)
		{
			instance.objectiveStatuses[index].progressCurrent = amount;
			assignee.MissionDirty();
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Heal")]
public class MissionObjective_Heal : MissionObjective
{
	[Range(0f, 1f)]
	public float RequiredHealthNormalised = 0.5f;

	public BaseEntityRef RequireHealSource;

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (!IsCompleted(index, instance) && CanProgress(index, instance) && type == BaseMission.MissionEventType.HEAL && (RequireHealSource == null || RequireHealSource.Get().prefabID == payload.UintIdentifier) && playerFor.healthFraction >= RequiredHealthNormalised)
		{
			CompleteObjective(index, instance, playerFor);
			playerFor.MissionDirty();
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Extend;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/HurtEntityType")]
public class MissionObjective_HurtEntityType : MissionObjective
{
	public BaseEntityRef[] targetEntities;

	public float targetDamage = 1f;

	public bool shouldUpdateMissionLocation = true;

	private bool isInitalized;

	private uint[] targetPrefabIDs;

	private Func<BaseCombatEntity, bool> searchFilter;

	private void EnsureInitialized()
	{
		if (!isInitalized)
		{
			isInitalized = true;
			targetPrefabIDs = (from e in targetEntities
				where e.isValid
				select e.Get().prefabID).ToArray();
		}
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetDamage;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.HURT_ENTITY || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		EnsureInitialized();
		EntityRef<BaseCombatEntity> entityRef = default(EntityRef<BaseCombatEntity>);
		entityRef.uid = payload.NetworkIdentifier;
		EntityRef<BaseCombatEntity> entityRef2 = entityRef;
		BaseCombatEntity baseCombatEntity = entityRef2.Get(serverside: true);
		if (!baseCombatEntity.IsValid())
		{
			return;
		}
		uint[] array = targetPrefabIDs;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] == baseCombatEntity.prefabID)
			{
				instance.objectiveStatuses[index].progressCurrent += amount;
				if (instance.objectiveStatuses[index].progressCurrent >= targetDamage)
				{
					CompleteObjective(index, instance, playerFor);
				}
				playerFor.MissionDirty();
				break;
			}
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		base.Think(index, instance, assignee, delta);
		if (!shouldUpdateMissionLocation || !IsStarted(index, instance))
		{
			return;
		}
		ref RealTimeSince sinceLastThink = ref instance.objectiveStatuses[index].sinceLastThink;
		if (RealTimeSince.op_Implicit(sinceLastThink) < 1f)
		{
			return;
		}
		sinceLastThink = RealTimeSince.op_Implicit(0f);
		if (searchFilter == null)
		{
			searchFilter = (BaseCombatEntity e) => List.TryFindWith<uint, uint>((IReadOnlyCollection<uint>)(object)targetPrefabIDs, (Func<uint, uint>)((uint id) => id), e.prefabID, (IEqualityComparer<uint>)null).HasValue && e.IsAlive();
		}
		if (TryFindNearby(((Component)assignee).transform.position, searchFilter, out var entity))
		{
			instance.missionLocation = ((Component)entity).transform.position;
			assignee.MissionDirty();
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/HurtMissionEntity")]
public class MissionObjective_HurtMissionEntity : MissionObjective
{
	public string targetIdentifier;

	public float targetDamage = 1f;

	public bool shouldUpdateMissionLocation = true;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetDamage;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.HURT_ENTITY || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		MissionEntity missionEntity = instance.GetMissionEntity(targetIdentifier, playerFor);
		if ((Object)(object)missionEntity == (Object)null)
		{
			FailObjective(index, instance, playerFor);
			return;
		}
		BaseEntity entity = missionEntity.GetEntity();
		if (!entity.IsValid())
		{
			FailObjective(index, instance, playerFor);
			return;
		}
		EntityRef<BaseCombatEntity> entityRef = default(EntityRef<BaseCombatEntity>);
		entityRef.uid = payload.NetworkIdentifier;
		EntityRef<BaseCombatEntity> entityRef2 = entityRef;
		BaseCombatEntity baseCombatEntity = entityRef2.Get(serverside: true);
		if (baseCombatEntity.IsValid() && baseCombatEntity.EqualNetID((BaseNetworkable)entity))
		{
			instance.objectiveStatuses[index].progressCurrent += amount;
			if (instance.objectiveStatuses[index].progressCurrent >= targetDamage)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionDirty();
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		base.Think(index, instance, assignee, delta);
		if (!IsStarted(index, instance) || IsCompleted(index, instance))
		{
			return;
		}
		ref RealTimeSince sinceLastThink = ref instance.objectiveStatuses[index].sinceLastThink;
		if (RealTimeSince.op_Implicit(sinceLastThink) < 1f)
		{
			return;
		}
		sinceLastThink = RealTimeSince.op_Implicit(0f);
		MissionEntity missionEntity = instance.GetMissionEntity(targetIdentifier, assignee);
		if ((Object)(object)missionEntity == (Object)null)
		{
			FailObjective(index, instance, assignee);
		}
		else if (shouldUpdateMissionLocation)
		{
			Vector3 position = ((Component)missionEntity).transform.position;
			if (position != instance.missionLocation)
			{
				instance.missionLocation = position;
				assignee.MissionDirty();
			}
		}
	}
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Ignite Oven")]
public class MissionObjective_IgniteOven : MissionObjective
{
	public BaseEntityRef TargetOven;

	public bool PingTarget;

	public BasePlayer.PingType PingType = BasePlayer.PingType.GoTo;

	private Func<BaseCombatEntity, bool> searchFilter;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		base.MissionStarted(index, instance, forPlayer);
		if (searchFilter == null)
		{
			searchFilter = (BaseCombatEntity e) => e.IsAlive() && e.prefabID == TargetOven.resourceID;
		}
		if (PingTarget && TryFindNearby(((Component)forPlayer).transform.position, searchFilter, out var entity, 200f))
		{
			instance.missionLocation = ((Component)entity).transform.position;
			forPlayer.RegisterPingedEntity(entity, PingType);
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.STARTOVEN || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		if (TargetOven.resourceID == payload.UintIdentifier)
		{
			CompleteObjective(index, instance, playerFor);
			if (PingTarget)
			{
				playerFor.DeregisterPingedEntity(payload.NetworkIdentifier, PingType);
			}
		}
		playerFor.MissionDirty();
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Extend;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Kill")]
public class MissionObjective_KillEntity : MissionObjective
{
	public BaseEntityRef[] targetEntities;

	public int numToKill;

	public bool shouldUpdateMissionLocation;

	public bool pingTargets;

	private bool isInitalized;

	private uint[] targetPrefabIDs;

	private Func<BaseCombatEntity, bool> searchFilter;

	private void EnsureInitialized()
	{
		if (!isInitalized)
		{
			isInitalized = true;
			targetPrefabIDs = (from e in targetEntities
				where e.isValid
				select e.Get().prefabID).ToArray();
		}
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = numToKill;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.KILL_ENTITY || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		EnsureInitialized();
		uint[] array = targetPrefabIDs;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] == payload.UintIdentifier)
			{
				instance.objectiveStatuses[index].progressCurrent += (int)amount;
				if (instance.objectiveStatuses[index].progressCurrent >= (float)numToKill)
				{
					CompleteObjective(index, instance, playerFor);
				}
				playerFor.DeregisterPingedEntitiesOfType(BasePlayer.PingType.Hostile);
				playerFor.MissionDirty();
				break;
			}
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		base.Think(index, instance, assignee, delta);
		if (!shouldUpdateMissionLocation || !IsStarted(index, instance))
		{
			return;
		}
		ref RealTimeSince sinceLastThink = ref instance.objectiveStatuses[index].sinceLastThink;
		if (RealTimeSince.op_Implicit(sinceLastThink) < 1f)
		{
			return;
		}
		EnsureInitialized();
		sinceLastThink = RealTimeSince.op_Implicit(0f);
		if (searchFilter == null)
		{
			searchFilter = (BaseCombatEntity e) => List.TryFindWith<uint, uint>((IReadOnlyCollection<uint>)(object)targetPrefabIDs, (Func<uint, uint>)((uint id) => id), e.prefabID, (IEqualityComparer<uint>)null).HasValue && e.IsAlive();
		}
		if (IsCompleted(index, instance))
		{
			return;
		}
		assignee.DeregisterPingedEntitiesOfType(BasePlayer.PingType.Hostile);
		if (TryFindNearby(((Component)assignee).transform.position, searchFilter, out var entity, pingTargets ? 200f : 20f))
		{
			instance.missionLocation = ((Component)entity).transform.position;
			assignee.MissionDirty();
			if (pingTargets)
			{
				assignee.RegisterPingedEntity(entity, BasePlayer.PingType.Hostile);
			}
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Metal Detector")]
public class MissionObjective_MetalDetectorFind : MissionObjective
{
	public int RequiredFinds = 3;

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = RequiredFinds;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.METAL_DETECTOR_FIND && !IsCompleted(index, instance) && CanProgress(index, instance))
		{
			instance.objectiveStatuses[index].progressCurrent += 1f;
			if (instance.objectiveStatuses[index].progressCurrent >= instance.objectiveStatuses[index].progressTarget)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionDirty();
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Extend;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/MountEntityType")]
public class MissionObjective_MountEntityType : MissionObjective
{
	public BaseEntityRef[] targetEntities;

	public int numToMount = 1;

	public bool shouldUpdateMissionLocation = true;

	private bool isInitalized;

	private uint[] targetPrefabIDs;

	private Func<BaseEntity, bool> searchFilter;

	private void EnsureInitialized()
	{
		if (!isInitalized)
		{
			isInitalized = true;
			targetPrefabIDs = (from e in targetEntities
				where e.isValid
				select e.Get().prefabID).ToArray();
		}
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		if (numToMount > 1)
		{
			instance.objectiveStatuses[index].progressTarget = numToMount;
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.MOUNT_ENTITY || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		EnsureInitialized();
		EntityRef<BaseMountable> entityRef = default(EntityRef<BaseMountable>);
		entityRef.uid = payload.NetworkIdentifier;
		EntityRef<BaseMountable> entityRef2 = entityRef;
		BaseMountable baseMountable = entityRef2.Get(serverside: true);
		if (!baseMountable.IsValid())
		{
			return;
		}
		uint[] array = targetPrefabIDs;
		foreach (uint num in array)
		{
			BaseVehicle baseVehicle = baseMountable.VehicleParent();
			if (num == baseMountable.prefabID || (!((Object)(object)baseVehicle == (Object)null) && num == baseVehicle.prefabID))
			{
				instance.objectiveStatuses[index].progressCurrent += (int)amount;
				if (instance.objectiveStatuses[index].progressCurrent >= (float)numToMount)
				{
					CompleteObjective(index, instance, playerFor);
				}
				playerFor.MissionDirty();
				break;
			}
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		base.Think(index, instance, assignee, delta);
		if (!shouldUpdateMissionLocation || !IsStarted(index, instance))
		{
			return;
		}
		ref RealTimeSince sinceLastThink = ref instance.objectiveStatuses[index].sinceLastThink;
		if (RealTimeSince.op_Implicit(sinceLastThink) < 1f)
		{
			return;
		}
		sinceLastThink = RealTimeSince.op_Implicit(0f);
		if (searchFilter == null)
		{
			searchFilter = (BaseEntity e) => List.TryFindWith<uint, uint>((IReadOnlyCollection<uint>)(object)targetPrefabIDs, (Func<uint, uint>)((uint id) => id), e.prefabID, (IEqualityComparer<uint>)null).HasValue;
		}
		if (TryFindNearby(((Component)assignee).transform.position, searchFilter, out var entity))
		{
			instance.missionLocation = ((Component)entity).transform.position;
			assignee.MissionDirty();
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/MountMissionEntity")]
public class MissionObjective_MountMissionEntity : MissionObjective
{
	public string targetIdentifier;

	public bool shouldUpdateMissionLocation = true;

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		instance.GetMissionEntity(targetIdentifier, playerFor);
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.MOUNT_ENTITY || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		MissionEntity missionEntity = instance.GetMissionEntity(targetIdentifier, playerFor);
		if ((Object)(object)missionEntity == (Object)null)
		{
			FailObjective(index, instance, playerFor);
			return;
		}
		BaseEntity entity = missionEntity.GetEntity();
		if (!entity.IsValid())
		{
			FailObjective(index, instance, playerFor);
			return;
		}
		EntityRef<BaseMountable> entityRef = default(EntityRef<BaseMountable>);
		entityRef.uid = payload.NetworkIdentifier;
		EntityRef<BaseMountable> entityRef2 = entityRef;
		BaseMountable baseMountable = entityRef2.Get(serverside: true);
		if (baseMountable.IsValid())
		{
			BaseVehicle baseVehicle = baseMountable.VehicleParent();
			if (baseMountable.EqualNetID((BaseNetworkable)entity) || ((Object)(object)baseVehicle != (Object)null && baseVehicle.EqualNetID((BaseNetworkable)entity)))
			{
				CompleteObjective(index, instance, playerFor);
			}
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		base.Think(index, instance, assignee, delta);
		if (!IsStarted(index, instance) || IsCompleted(index, instance))
		{
			return;
		}
		ref RealTimeSince sinceLastThink = ref instance.objectiveStatuses[index].sinceLastThink;
		if (RealTimeSince.op_Implicit(sinceLastThink) < 1f)
		{
			return;
		}
		sinceLastThink = RealTimeSince.op_Implicit(0f);
		MissionEntity missionEntity = instance.GetMissionEntity(targetIdentifier, assignee);
		if ((Object)(object)missionEntity == (Object)null)
		{
			FailObjective(index, instance, assignee);
		}
		else if (shouldUpdateMissionLocation)
		{
			Vector3 position = ((Component)missionEntity).transform.position;
			if (position != instance.missionLocation)
			{
				instance.missionLocation = position;
				assignee.MissionDirty();
			}
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Move")]
public class MissionObjective_Move : MissionObjective
{
	public string positionName = "default";

	public float distForCompletion = 3f;

	public bool use2D;

	public BaseMountable requiredMountable;

	public bool shouldPing;

	public BasePlayer.PingType pingType = BasePlayer.PingType.GoTo;

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		base.ObjectiveStarted(playerFor, index, instance);
		instance.missionLocation = instance.GetMissionPoint(positionName, playerFor);
		playerFor.MissionDirty();
		if (shouldPing)
		{
			TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				playerFor.AddPingAtLocation(pingType, instance.missionLocation, 86400f, currentTutorialIsland.net.ID);
			}
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		base.Think(index, instance, assignee, delta);
		if (!ShouldThink(index, instance) || ((Object)(object)requiredMountable != (Object)null && (!assignee.isMounted || assignee.GetMounted().prefabID != requiredMountable.prefabID)))
		{
			return;
		}
		Vector3 missionPoint = instance.GetMissionPoint(positionName, assignee);
		if (!((use2D ? Vector3Ex.Distance2D(missionPoint, ((Component)assignee).transform.position) : Vector3.Distance(missionPoint, ((Component)assignee).transform.position)) <= distForCompletion))
		{
			return;
		}
		CompleteObjective(index, instance, assignee);
		if (shouldPing)
		{
			TutorialIsland currentTutorialIsland = assignee.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				assignee.RemovePingAtLocation(pingType, instance.missionLocation, float.MaxValue, currentTutorialIsland.net.ID);
			}
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Open Tutorial Storage")]
public class MissionObjective_OpenTutorialStorageContainer : MissionObjective
{
	public ItemAmount[] Items;

	public BaseEntity TargetEntity;

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
		if ((Object)(object)currentTutorialIsland != (Object)null && (Object)(object)currentTutorialIsland.TutorialContainer != (Object)null)
		{
			currentTutorialIsland.TutorialContainer.LoadStorage(Items);
		}
		playerFor.RegisterPingedEntity(currentTutorialIsland.TutorialContainer, BasePlayer.PingType.Loot);
	}

	public override void ObjectiveCompleted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveCompleted(playerFor, index, instance);
		DeregisterPing(playerFor);
	}

	private void DeregisterPing(BasePlayer playerFor)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
		if ((Object)(object)currentTutorialIsland != (Object)null && (Object)(object)currentTutorialIsland.TutorialContainer != (Object)null)
		{
			playerFor.DeregisterPingedEntity(currentTutorialIsland.TutorialContainer.net.ID, BasePlayer.PingType.Loot);
		}
	}

	public override void ObjectiveFailed(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveFailed(playerFor, index, instance);
		DeregisterPing(playerFor);
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.OPEN_STORAGE && !IsCompleted(index, instance) && CanProgress(index, instance) && payload.UintIdentifier == TargetEntity.prefabID)
		{
			CompleteObjective(index, instance, playerFor);
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/PlayerInput")]
public class MissionObjective_PlayerInput : MissionObjective
{
	public BUTTON requiredButton;

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		instance.EnablePlayerInput();
	}

	public override void ObjectiveCompleted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveCompleted(playerFor, index, instance);
		instance.DisablePlayerInput();
	}

	public override void ObjectiveFailed(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveFailed(playerFor, index, instance);
		instance.DisablePlayerInput();
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.PLAYER_TICK && !IsCompleted(index, instance) && CanProgress(index, instance) && playerFor.serverInput.IsDown(requiredButton))
		{
			CompleteObjective(index, instance, playerFor);
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Respawn")]
public class MissionObjective_Respawn : MissionObjective
{
	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.RESPAWN && !IsCompleted(index, instance) && CanProgress(index, instance))
		{
			CompleteObjective(index, instance, playerFor);
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Retrieve Items from corpse")]
public class MissionObjective_RetrieveItemsFromCorpse : MissionObjective
{
	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		base.ObjectiveStarted(playerFor, index, instance);
		if (playerFor.ServerCurrentDeathNote == null)
		{
			return;
		}
		List<PlayerCorpse> list = Pool.Get<List<PlayerCorpse>>();
		Vis.Entities(playerFor.ServerCurrentDeathNote.worldPosition, 3f, list, 512, (QueryTriggerInteraction)2);
		foreach (PlayerCorpse item in list)
		{
			if ((Object)(object)item != (Object)null && item.isServer)
			{
				playerFor.RegisterPingedEntity(item, BasePlayer.PingType.Loot);
				break;
			}
		}
		Pool.FreeUnmanaged<PlayerCorpse>(ref list);
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.OPEN_STORAGE || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(payload.NetworkIdentifier);
		if ((Object)(object)baseNetworkable != (Object)null)
		{
			bool flag = baseNetworkable is PlayerCorpse playerCorpse && playerCorpse.playerSteamID == (ulong)playerFor.userID;
			if (!flag && baseNetworkable is DroppedItemContainer droppedItemContainer && droppedItemContainer.playerSteamID == (ulong)playerFor.userID)
			{
				flag = true;
			}
			if (flag)
			{
				playerFor.DeregisterPingedEntity(payload.NetworkIdentifier, BasePlayer.PingType.Loot);
				CompleteObjective(index, instance, playerFor);
			}
		}
	}
}


using ConVar;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/SpeakWith")]
public class MissionObjective_SpeakWith : MissionObjective
{
	public ItemAmount[] requiredReturnItems = new ItemAmount[0];

	public bool destroyReturnItems;

	public bool showPing;

	public bool checkSpaceForRewards;

	public static Phrase NoSpaceInInventoryPhrase = new Phrase("no_space_mission_reward", "No space for rewards in inventory, please clear some space");

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = instance.ProviderEntity();
		if (Object.op_Implicit((Object)(object)baseEntity) && !showPing)
		{
			instance.missionLocation = ((Component)baseEntity).transform.position;
			playerFor.MissionDirty();
		}
		base.ObjectiveStarted(playerFor, index, instance);
		if ((Object)(object)baseEntity != (Object)null && showPing)
		{
			playerFor.RegisterPingedEntity(baseEntity, BasePlayer.PingType.GoTo);
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.CONVERSATION)
		{
			return;
		}
		if (Debugging.printMissionSpeakInfo)
		{
			Debug.Log((object)$"Speak info: IsCompleted:{IsCompleted(index, instance)} CanProgress:{CanProgress(index, instance)}");
		}
		if (IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		BaseEntity baseEntity = instance.ProviderEntity();
		if (Debugging.printMissionSpeakInfo)
		{
			Debug.Log((object)$"Looking for Provider: {instance.providerID.Value}/{baseEntity} Supplied NPC:{payload.NetworkIdentifier}");
		}
		if (!Object.op_Implicit((Object)(object)baseEntity))
		{
			return;
		}
		IMissionProvider component = ((Component)baseEntity).GetComponent<IMissionProvider>();
		if (component == null || !(component.ProviderID() == payload.NetworkIdentifier) || amount != 1f)
		{
			return;
		}
		bool flag = true;
		if (component.ProviderID() == payload.NetworkIdentifier && amount == 1f)
		{
			ItemAmount[] array = requiredReturnItems;
			foreach (ItemAmount itemAmount in array)
			{
				if ((float)playerFor.inventory.GetAmount(itemAmount.itemDef.itemid) < itemAmount.amount)
				{
					flag = false;
					break;
				}
			}
			if (flag && destroyReturnItems)
			{
				if (!CheckRewardsSpace())
				{
					return;
				}
				array = requiredReturnItems;
				foreach (ItemAmount itemAmount2 in array)
				{
					playerFor.inventory.Take(null, itemAmount2.itemDef.itemid, (int)itemAmount2.amount);
				}
			}
		}
		if (CheckRewardsSpace() && (requiredReturnItems == null || requiredReturnItems.Length == 0 || flag))
		{
			CompleteObjective(index, instance, playerFor);
		}
		bool CheckRewardsSpace()
		{
			if (checkSpaceForRewards && !playerFor.inventory.HasEmptySlots(instance.GetTotalRequiredRewardItemSlots()))
			{
				playerFor.ShowToast(GameTip.Styles.Red_Normal, NoSpaceInInventoryPhrase, false);
				return false;
			}
			return true;
		}
	}

	public override void ObjectiveCompleted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveCompleted(playerFor, index, instance);
		if (showPing)
		{
			DeregisterPing(playerFor, instance);
		}
	}

	private static void DeregisterPing(BasePlayer playerFor, BaseMission.MissionInstance instance)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = instance.ProviderEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			playerFor.DeregisterPingedEntity(baseEntity.net.ID, BasePlayer.PingType.GoTo);
		}
	}

	public override void ObjectiveFailed(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveFailed(playerFor, index, instance);
		if (showPing)
		{
			DeregisterPing(playerFor, instance);
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Upgrade Building Block")]
public class MissionObjective_UpgradeBuildingBlock : MissionObjective
{
	public bool ShouldPingBlocksLessThanTargetGrade;

	public BasePlayer.PingType PingType;

	public BuildingGrade.Enum TargetGrade;

	public int RequiredCount = 6;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = RequiredCount;
		if (!ShouldPingBlocksLessThanTargetGrade)
		{
			return;
		}
		TutorialIsland currentTutorialIsland = forPlayer.GetCurrentTutorialIsland();
		if (!((Object)(object)currentTutorialIsland != (Object)null))
		{
			return;
		}
		Vector3 worldPosOfBuildTarget = currentTutorialIsland.GetWorldPosOfBuildTarget(0);
		List<BuildingBlock> list = Pool.Get<List<BuildingBlock>>();
		Vis.Entities(worldPosOfBuildTarget, 32f, list, 2097152, (QueryTriggerInteraction)2);
		if (list.Count != RequiredCount)
		{
			Debug.LogWarning((object)("Non matching building block count, check RequiredCount on " + ((Object)this).name));
		}
		foreach (BuildingBlock item in list)
		{
			forPlayer.RegisterPingedEntity(item, PingType);
		}
		Pool.FreeUnmanaged<BuildingBlock>(ref list);
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.UPGRADE_BUILDING_GRADE && !IsCompleted(index, instance) && CanProgress(index, instance) && payload.IntIdentifier >= (int)TargetGrade)
		{
			instance.objectiveStatuses[index].progressCurrent += 1f;
			if (instance.objectiveStatuses[index].progressCurrent >= (float)RequiredCount)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionDirty();
			if (ShouldPingBlocksLessThanTargetGrade)
			{
				playerFor.DeregisterPingedEntity(payload.NetworkIdentifier, PingType);
			}
		}
	}
}


using UnityEngine;

public class PVPMissionManager : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}


using System;
using UnityEngine;

public class TriggerMission : TriggerBase
{
	private BasePlayer cachedPlayer;

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if ((Object)(object)ent.ToPlayer() != (Object)null)
		{
			cachedPlayer = ent.ToPlayer();
			((FacepunchBehaviour)this).Invoke((Action)DelayedEntityCallback, 0f);
		}
	}

	private void DelayedEntityCallback()
	{
		if ((Object)(object)cachedPlayer != (Object)null)
		{
			cachedPlayer.ProcessMissionEvent(BaseMission.MissionEventType.ENTER_TRIGGER, 0, 0f);
		}
		cachedPlayer = null;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/WorldPositionGenerator")]
public class WorldPositionGenerator : ScriptableObject
{
	public SpawnFilter Filter = new SpawnFilter();

	public float FilterCutoff;

	public bool aboveWater;

	public float MaxSlopeRadius;

	public float MaxSlopeDegrees = 90f;

	public float CheckSphereRadius;

	public LayerMask CheckSphereMask;

	private Vector3 _origin;

	private Vector3 _area;

	private ByteQuadtree _quadtree;

	public bool TrySample(Vector3 origin, float minDist, float maxDist, out Vector3 position, List<Vector3> blocked = null)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		if (_quadtree == null)
		{
			PrecalculatePositions();
		}
		Rect inclusion = new Rect(origin.x - maxDist, origin.z - maxDist, maxDist * 2f, maxDist * 2f);
		Rect exclusion = new Rect(origin.x - minDist, origin.z - minDist, minDist * 2f, minDist * 2f);
		List<Rect> blockedRects = Pool.Get<List<Rect>>();
		if (blocked != null)
		{
			float num = 10f;
			Rect item = default(Rect);
			foreach (Vector3 item2 in blocked)
			{
				((Rect)(ref item))..ctor(item2.x - num, item2.z - num, num * 2f, num * 2f);
				blockedRects.Add(item);
			}
		}
		List<ByteQuadtree.Element> candidates = Pool.Get<List<ByteQuadtree.Element>>();
		candidates.Add(_quadtree.Root);
		for (int i = 0; i < candidates.Count; i++)
		{
			ByteQuadtree.Element element2 = candidates[i];
			if (!element2.IsLeaf)
			{
				ListEx.RemoveUnordered<ByteQuadtree.Element>(candidates, i--);
				EvaluateCandidate(element2.Child1);
				EvaluateCandidate(element2.Child2);
				EvaluateCandidate(element2.Child3);
				EvaluateCandidate(element2.Child4);
			}
		}
		if (candidates.Count == 0)
		{
			position = origin;
			Pool.FreeUnmanaged<ByteQuadtree.Element>(ref candidates);
			Pool.FreeUnmanaged<Rect>(ref blockedRects);
			return false;
		}
		Vector3 val2;
		if (CheckSphereRadius <= float.Epsilon)
		{
			ByteQuadtree.Element random = ListEx.GetRandom<ByteQuadtree.Element>(candidates);
			Rect val = GetElementRect(random);
			val2 = Vector3Ex.XZ3D(((Rect)(ref val)).min + ((Rect)(ref val)).size * new Vector2(Random.value, Random.value));
		}
		else
		{
			Vector3 val4;
			while (true)
			{
				if (candidates.Count == 0)
				{
					position = Vector3.zero;
					return false;
				}
				int index = Random.Range(0, candidates.Count);
				ByteQuadtree.Element element3 = candidates[index];
				Rect val3 = GetElementRect(element3);
				val4 = Vector3Ex.XZ3D(((Rect)(ref val3)).center);
				val4.y = TerrainMeta.HeightMap.GetHeight(val4);
				if (!Physics.CheckSphere(val4, CheckSphereRadius, ((LayerMask)(ref CheckSphereMask)).value))
				{
					break;
				}
				candidates.RemoveAt(index);
			}
			val2 = val4;
		}
		position = Vector3Ex.WithY(val2, aboveWater ? WaterLevel.GetWaterOrTerrainSurface(val2, waves: false, volumes: false) : TerrainMeta.HeightMap.GetHeight(val2));
		Pool.FreeUnmanaged<ByteQuadtree.Element>(ref candidates);
		Pool.FreeUnmanaged<Rect>(ref blockedRects);
		return true;
		void EvaluateCandidate(ByteQuadtree.Element child)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			if (child.Value != 0)
			{
				Rect val5 = GetElementRect(child);
				if (((Rect)(ref val5)).Overlaps(inclusion) && (!((Rect)(ref exclusion)).Contains(((Rect)(ref val5)).min) || !((Rect)(ref exclusion)).Contains(((Rect)(ref val5)).max)))
				{
					if (blockedRects.Count > 0)
					{
						foreach (Rect item3 in blockedRects)
						{
							Rect current2 = item3;
							if (((Rect)(ref current2)).Contains(((Rect)(ref val5)).min) && ((Rect)(ref current2)).Contains(((Rect)(ref val5)).max))
							{
								return;
							}
						}
					}
					candidates.Add(child);
				}
			}
		}
		Rect GetElementRect(ByteQuadtree.Element element)
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			int num2 = 1 << element.Depth;
			float num3 = 1f / (float)num2;
			Vector2 val6 = element.Coords * num3;
			return new Rect(_origin.x + val6.x * _area.x, _origin.z + val6.y * _area.z, _area.x * num3, _area.z * num3);
		}
	}

	public void PrecalculatePositions()
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		int res = Mathf.NextPowerOfTwo((int)((float)World.Size * 0.25f));
		byte[] map = new byte[res * res];
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			for (int i = 0; i < res; i++)
			{
				float normX = ((float)i + 0.5f) / (float)res;
				float normZ = ((float)z + 0.5f) / (float)res;
				float factor = Filter.GetFactor(normX, normZ);
				if (factor > 0f && MaxSlopeRadius > 0f)
				{
					TerrainMeta.HeightMap.ForEach(normX, normZ, MaxSlopeRadius / (float)res, delegate(int slopeX, int slopeZ)
					{
						if (TerrainMeta.HeightMap.GetSlope(slopeX, slopeZ) > MaxSlopeDegrees)
						{
							factor = 0f;
						}
					});
				}
				map[z * res + i] = (byte)((factor >= FilterCutoff) ? (255f * factor) : 0f);
			}
		});
		_origin = TerrainMeta.Position;
		_area = TerrainMeta.Size;
		_quadtree = new ByteQuadtree();
		_quadtree.UpdateValues(map);
	}
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public class CargoShipContainer : BaseEntity
{
	public GameObject[] DressingVariants;

	public const Flags Descending = Flags.Reserved1;

	public const Flags Targeted = Flags.Reserved2;

	private int dressingVariant;

	public override float MaxVelocity()
	{
		return 1f;
	}

	public override void PreInitShared()
	{
		base.PreInitShared();
		AssignVariant();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		UpdateDressingVariant();
	}

	public override void PostMapEntitySpawn()
	{
		base.PostMapEntitySpawn();
		UpdateDressingVariant();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.cargoShipContainer = Pool.Get<CargoShipContainer>();
		info.msg.cargoShipContainer.dressingVariant = dressingVariant;
	}

	private void AssignVariant()
	{
		dressingVariant = Random.Range(0, DressingVariants.Length);
	}

	public void ToggleHurtCollider(bool state)
	{
		SetFlag(Flags.Reserved1, state);
	}

	public void SetTargeted(bool state)
	{
		SetFlag(Flags.Reserved2, state);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.cargoShipContainer != null)
		{
			dressingVariant = info.msg.cargoShipContainer.dressingVariant;
		}
		UpdateDressingVariant();
	}

	private void UpdateDressingVariant()
	{
		for (int i = 0; i < DressingVariants.Length; i++)
		{
			DressingVariants[i].SetActive(dressingVariant == i);
		}
	}
}


public class CargoShipContainerSounds : FacepunchBehaviour, IClientComponent
{
	public SoundDefinition liftDef;

	public SoundDefinition dropDef;
}


using UnityEngine;

public class HarborBridgeSounds : MonoBehaviour, IClientComponent
{
	public HarborProximityEntity bridge;

	public SoundDefinition rootRotationLoopDef;

	public SoundDefinition rootRotationStartDef;

	public SoundDefinition rootRotationStopDef;
}


using UnityEngine;

public class HarborCrane : HarborProximityEntity
{
	public Transform CraneGrab;

	public Transform ArmRoot;

	public Transform ArmSupportLower;

	public Transform ArmSupportUpper;

	public TransformLineRenderer[] LineRenderers;

	protected void UpdateArmSupports(Vector3 fwd)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)ArmSupportUpper == (Object)null) && !((Object)(object)ArmSupportLower == (Object)null))
		{
			Vector3 val = ArmSupportUpper.position - ArmSupportLower.position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			ArmSupportLower.rotation = Quaternion.LookRotation(fwd, normalized);
			ArmSupportUpper.rotation = Quaternion.LookRotation(fwd, normalized);
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class HarborCraneContainerPickup : HarborCrane
{
	public struct ContainerStack
	{
		public Transform RootPoint;

		public int MaxStackSize;

		public int CurrentStackSize { get; set; }
	}

	private struct QueuedMove
	{
		public EntityRef<CargoShipContainer> TargetEntity;

		public Vector3 TargetWorldPosition;

		public Quaternion TargetWorldRotation;

		public bool HasTarget;
	}

	private enum PickupState
	{
		RotateToFace,
		Lift,
		RotateToTarget,
		Drop,
		Reset
	}

	public Transform ServerTowerGrab;

	public float LockTime = 5f;

	public float MaxMoveDistance = 32f;

	public float PickedUpObjectRotationSpeed = 30f;

	private List<ContainerStack> Stacks;

	public GameObjectRef ContainerPrefab;

	private const float ContainerSize = 3f;

	public int MaxContainerStackSize = 3;

	public bool DebugContainerSpawns;

	public bool DebugContainerDestinations;

	private Vector3 grabOffset = new Vector3(0f, 19f, 0f);

	public static ListHashSet<HarborCraneContainerPickup> AllCranes = new ListHashSet<HarborCraneContainerPickup>();

	private Vector3 startForward;

	private List<QueuedMove> movesToMake = new List<QueuedMove>();

	private QueuedMove? moveInProcess;

	private EntityRef<CargoShip> toParent;

	private float moveDelay;

	private PickupState currentPickupState;

	private float lockOnTime;

	private float maxTargetHeight;

	public override void ServerInit()
	{
		base.ServerInit();
		AllCranes.Add(this);
		List<HarborCraneContainerSpawnPoint> list = Pool.Get<List<HarborCraneContainerSpawnPoint>>();
		FindNearbyContainerSpawns(list);
		Stacks = new List<ContainerStack>();
		foreach (HarborCraneContainerSpawnPoint item in list)
		{
			Stacks.Add(new ContainerStack
			{
				RootPoint = ((Component)item).transform,
				MaxStackSize = item.MaxStackSize
			});
		}
		Pool.FreeUnmanaged<HarborCraneContainerSpawnPoint>(ref list);
		UpdateArm();
		SendNetworkUpdate();
	}

	public override void PostMapEntitySpawn()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.PostMapEntitySpawn();
		startForward = ((Component)this).transform.forward;
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		AllCranes.Remove(this);
	}

	private void FindNearbyContainerSpawns(List<HarborCraneContainerSpawnPoint> foundPoints)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		Vis.Components<HarborCraneContainerSpawnPoint>(((Component)this).transform.position, MaxMoveDistance, foundPoints, 1218652417, (QueryTriggerInteraction)2);
	}

	private void ReplenishContainers(int totalContainers)
	{
		for (int i = 0; i < Stacks.Count; i++)
		{
			ContainerStack value = Stacks[i];
			value.CurrentStackSize = 0;
			Stacks[i] = value;
		}
		maxTargetHeight = 0f;
		int count = Stacks.Count;
		if (count == 0)
		{
			return;
		}
		int num = Random.Range(0, count);
		int num2 = 0;
		while (totalContainers > 0 && num2 < 50)
		{
			num2++;
			num++;
			if (num >= count)
			{
				num = 0;
			}
			ContainerStack containerStack = Stacks[num];
			if (SpawnContainerOnStack(containerStack))
			{
				containerStack.CurrentStackSize++;
				totalContainers--;
				Stacks[num] = containerStack;
			}
		}
		movesToMake.Reverse();
		bool SpawnContainerOnStack(ContainerStack stack)
		{
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00af: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			if (stack.CurrentStackSize >= MaxContainerStackSize || stack.CurrentStackSize >= stack.MaxStackSize)
			{
				return false;
			}
			if (CargoShip.docking_debug)
			{
				Debug.Log((object)$"Spawning container on stack {stack.RootPoint.position}");
			}
			Vector3 position = stack.RootPoint.position;
			position.y += (float)stack.CurrentStackSize * 3f;
			List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
			Vis.Entities(new OBB(position, stack.RootPoint.rotation, new Bounds(new Vector3(0f, 1.5f, 0f), new Vector3(4.5f, 1.5f, 1.5f) * 0.8f)), list, 1218685185, (QueryTriggerInteraction)2);
			bool num3 = list.Count == 0;
			if (!num3 && CargoShip.docking_debug)
			{
				Debug.Log((object)("Container spawn blocked by " + ((Object)((Component)list[0]).gameObject).name), (Object)(object)list[0]);
			}
			Pool.FreeUnmanaged<BaseEntity>(ref list);
			if (!num3)
			{
				return false;
			}
			CargoShipContainer cargoShipContainer = GameManager.server.CreateEntity(ContainerPrefab.resourcePath, position, stack.RootPoint.rotation) as CargoShipContainer;
			cargoShipContainer.Spawn();
			QueuedMove item = default(QueuedMove);
			item.TargetEntity.Set(cargoShipContainer);
			item.HasTarget = false;
			movesToMake.Add(item);
			return true;
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.harborCrane = Pool.Get<HarborCrane>();
		info.msg.harborCrane.depth = ServerTowerGrab.localPosition.z;
		info.msg.harborCrane.height = ServerTowerGrab.localPosition.y;
		info.msg.harborCrane.time = GetNetworkTime();
		info.msg.harborCrane.maxMoveHeight = maxTargetHeight;
		info.msg.harborCrane.toParent = toParent.uid;
		info.msg.harborCrane.startForward = startForward;
		info.msg.harborCrane.moveDelay = moveDelay;
		if (moveInProcess.HasValue)
		{
			info.msg.harborCrane.currentMove = Pool.Get<QueuedMove>();
			CreateMove(moveInProcess.Value, info.msg.harborCrane.currentMove);
		}
		if (movesToMake.Count > 0)
		{
			info.msg.harborCrane.queuedMoves = Pool.Get<List<QueuedMove>>();
			foreach (QueuedMove item in movesToMake)
			{
				QueuedMove val = Pool.Get<QueuedMove>();
				CreateMove(item, val);
				info.msg.harborCrane.queuedMoves.Add(val);
			}
		}
		info.msg.harborCrane.currentPickupState = (int)currentPickupState;
	}

	private QueuedMove CreateMove(QueuedMove from)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		QueuedMove result = default(QueuedMove);
		result.TargetEntity = new EntityRef<CargoShipContainer>(from.targetEntity);
		result.TargetWorldPosition = from.targetWorldPosition;
		result.TargetWorldRotation = new Quaternion(from.targetWorldRotation.x, from.targetWorldRotation.y, from.targetWorldRotation.z, from.targetWorldRotation.w);
		result.HasTarget = from.hasTarget;
		return result;
	}

	private void CreateMove(QueuedMove move, QueuedMove target)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		target.hasTarget = move.HasTarget;
		target.targetEntity = move.TargetEntity.uid;
		target.targetWorldPosition = move.TargetWorldPosition;
		target.targetWorldRotation = new Vector4(move.TargetWorldRotation.x, move.TargetWorldRotation.y, move.TargetWorldRotation.z, move.TargetWorldRotation.w);
	}

	private void CountdownDelay()
	{
		moveDelay -= Time.deltaTime;
		if (moveDelay <= 0f)
		{
			moveDelay = 0f;
			((FacepunchBehaviour)this).CancelInvoke((Action)CountdownDelay);
			CheckMoveQueue();
		}
	}

	private void CheckMoveQueue()
	{
		if (moveDelay > 0f && movesToMake.Count > 0 && !((FacepunchBehaviour)this).IsInvoking((Action)CountdownDelay))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)CountdownDelay, 0f, 0f);
		}
		else if (movesToMake.Count > 0 && !IsBusy() && movesToMake[0].HasTarget)
		{
			moveInProcess = movesToMake[0];
			movesToMake.RemoveAt(0);
			currentPickupState = PickupState.RotateToFace;
			lockOnTime = 0f;
			SetFlag(Flags.Busy, b: true);
			((FacepunchBehaviour)this).InvokeRepeating((Action)ProcessCraneMovement, 0f, 0f);
		}
	}

	private void ProcessCraneMovement()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0348: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0358: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0362: Unknown result type (might be due to invalid IL or missing references)
		//IL_0364: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_036c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_037f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0401: Unknown result type (might be due to invalid IL or missing references)
		//IL_0406: Unknown result type (might be due to invalid IL or missing references)
		//IL_040b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0419: Unknown result type (might be due to invalid IL or missing references)
		//IL_041e: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_043e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0440: Unknown result type (might be due to invalid IL or missing references)
		//IL_0446: Unknown result type (might be due to invalid IL or missing references)
		//IL_044b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0467: Unknown result type (might be due to invalid IL or missing references)
		//IL_0469: Unknown result type (might be due to invalid IL or missing references)
		//IL_0476: Unknown result type (might be due to invalid IL or missing references)
		//IL_047b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0483: Unknown result type (might be due to invalid IL or missing references)
		//IL_0496: Unknown result type (might be due to invalid IL or missing references)
		//IL_049c: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_030a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0584: Unknown result type (might be due to invalid IL or missing references)
		//IL_058a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0594: Unknown result type (might be due to invalid IL or missing references)
		//IL_0599: Unknown result type (might be due to invalid IL or missing references)
		//IL_059e: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0612: Unknown result type (might be due to invalid IL or missing references)
		//IL_0618: Unknown result type (might be due to invalid IL or missing references)
		//IL_061d: Unknown result type (might be due to invalid IL or missing references)
		if (!moveInProcess.HasValue)
		{
			return;
		}
		QueuedMove value = moveInProcess.Value;
		CargoShipContainer cargoShipContainer = value.TargetEntity.Get(serverside: true);
		if ((Object)(object)cargoShipContainer == (Object)null)
		{
			return;
		}
		Vector3 position = ((Component)this).transform.position;
		float num = Mathf.Max(15.585f, Mathf.Max(value.TargetWorldPosition.y, maxTargetHeight));
		float num2 = num;
		Vector3 val = ((Component)cargoShipContainer).transform.position;
		Vector3 val2 = Vector3Ex.WithY(val, position.y) - position;
		float num3 = Vector3.Angle(((Component)this).transform.forward, ((Vector3)(ref val2)).normalized);
		Vector3 localPosition = ServerTowerGrab.localPosition;
		bool flag = false;
		float num4 = 0f;
		switch (currentPickupState)
		{
		case PickupState.RotateToFace:
			cargoShipContainer.SetTargeted(state: true);
			if (!(num3 < 2f))
			{
				break;
			}
			num2 = ((Component)this).transform.InverseTransformPoint(new Vector3(0f, ((Component)cargoShipContainer).transform.position.y + ((Bounds)(ref cargoShipContainer.bounds)).max.y, 0f)).y;
			if (Mathf.Abs(num2 - localPosition.y) < 0.1f)
			{
				lockOnTime += Time.deltaTime;
				if (lockOnTime > LockTime)
				{
					currentPickupState = PickupState.Lift;
					lockOnTime = 0f;
				}
			}
			break;
		case PickupState.Lift:
			flag = true;
			if (Mathf.Abs(num2 - localPosition.y) < 0.1f)
			{
				currentPickupState = PickupState.RotateToTarget;
			}
			break;
		case PickupState.RotateToTarget:
			flag = true;
			val = value.TargetWorldPosition;
			val2 = Vector3Ex.WithY(val, position.y) - position;
			num3 = Vector3.Angle(((Component)this).transform.forward, ((Vector3)(ref val2)).normalized);
			((Component)cargoShipContainer).transform.rotation = Quaternion.RotateTowards(((Component)cargoShipContainer).transform.rotation, value.TargetWorldRotation, PickedUpObjectRotationSpeed * Time.deltaTime);
			if (num3 < 0.1f)
			{
				currentPickupState = PickupState.Drop;
			}
			break;
		case PickupState.Drop:
			flag = true;
			val = value.TargetWorldPosition;
			val2 = Vector3Ex.WithY(val, position.y) - position;
			num2 = ((Component)this).transform.InverseTransformPoint(value.TargetWorldPosition).y + ((Bounds)(ref cargoShipContainer.bounds)).size.y;
			((Component)cargoShipContainer).transform.rotation = Quaternion.RotateTowards(((Component)cargoShipContainer).transform.rotation, value.TargetWorldRotation, PickedUpObjectRotationSpeed * Time.deltaTime);
			if (Mathf.Abs(num2 - localPosition.y) < 0.1f)
			{
				lockOnTime += Time.deltaTime;
				if (lockOnTime > LockTime)
				{
					currentPickupState = PickupState.Reset;
					((Component)cargoShipContainer).transform.SetPositionAndRotation(value.TargetWorldPosition, (PickedUpObjectRotationSpeed > 0f) ? value.TargetWorldRotation : ((Component)cargoShipContainer).transform.rotation);
					cargoShipContainer.SetParent(toParent.Get(serverside: true), worldPositionStays: true);
					cargoShipContainer.SetTargeted(state: false);
					lockOnTime = 0f;
				}
			}
			break;
		case PickupState.Reset:
			num2 = num;
			val = ((Component)this).transform.position + startForward * 26f;
			val2 = Vector3Ex.WithY(val, position.y) - position;
			num3 = Vector3.Angle(((Component)this).transform.forward, ((Vector3)(ref val2)).normalized);
			if (num3 < 0.1f)
			{
				lockOnTime += Time.deltaTime;
				if (lockOnTime > 5f)
				{
					lockOnTime = 0f;
					SetFlag(Flags.Busy, b: false);
					((FacepunchBehaviour)this).CancelInvoke((Action)ProcessCraneMovement);
					CheckMoveQueue();
				}
			}
			break;
		}
		cargoShipContainer.ToggleHurtCollider(currentPickupState == PickupState.Drop);
		Quaternion val3 = Quaternion.LookRotation(((Vector3)(ref val2)).normalized, Vector3.up);
		((Component)this).transform.rotation = Quaternion.RotateTowards(((Component)this).transform.rotation, val3, 5f * Time.deltaTime);
		float num5 = ((num4 > 0f) ? num4 : Vector3.Distance(Vector3Ex.WithY(val, position.y), position));
		Vector3 val4 = default(Vector3);
		((Vector3)(ref val4))..ctor(0f, num2, num5);
		localPosition = Vector3.MoveTowards(localPosition, val4, Time.deltaTime * 2f);
		ServerTowerGrab.localPosition = localPosition;
		CraneGrab.position = ServerTowerGrab.position + grabOffset;
		if (flag)
		{
			((Component)cargoShipContainer).transform.position = ServerTowerGrab.position - Vector3.up * ((Bounds)(ref cargoShipContainer.bounds)).size.y;
		}
		UpdateArm();
		SendNetworkUpdate();
		CargoShip cargoShip = toParent.Get(serverside: true);
		if (!((Object)(object)cargoShip != (Object)null) || cargoShip.HasFlag(Flags.Reserved1))
		{
			return;
		}
		foreach (QueuedMove item in movesToMake)
		{
			item.TargetEntity.Get(serverside: true).Kill();
		}
		if ((Object)(object)cargoShipContainer != (Object)null && currentPickupState != PickupState.Reset)
		{
			cargoShipContainer.Kill();
		}
		val = ((Component)this).transform.position + startForward * 26f;
		val2 = Vector3Ex.WithY(val, position.y) - position;
		num2 = num;
		num5 = Vector3.Distance(Vector3Ex.WithY(val, position.y), position);
		((Vector3)(ref val4))..ctor(0f, num2, num5);
		((Component)this).transform.rotation = Quaternion.LookRotation(((Vector3)(ref val2)).normalized, Vector3.up);
		ServerTowerGrab.localPosition = val4;
		CraneGrab.position = ServerTowerGrab.position + grabOffset;
		UpdateArm();
		SendNetworkUpdate();
		SetFlag(Flags.Busy, b: false);
		((FacepunchBehaviour)this).CancelInvoke((Action)ProcessCraneMovement);
	}

	public void ReplenishContainers()
	{
		ReplenishContainers(Random.Range(2, 4));
	}

	public void AssignDestination(List<Transform> destinations, CargoShip targetShip, float delay)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		if (startForward == Vector3.zero)
		{
			startForward = ((Component)targetShip).transform.forward;
		}
		toParent.Set(targetShip);
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < movesToMake.Count; i++)
		{
			QueuedMove value = movesToMake[i];
			Transform val = destinations[num];
			value.TargetWorldRotation = val.rotation;
			value.TargetWorldPosition = val.position + Vector3.up * ((float)num2 * 3f);
			maxTargetHeight = Mathf.Max(value.TargetWorldPosition.y, maxTargetHeight);
			value.HasTarget = true;
			movesToMake[i] = value;
			num++;
			if (num >= destinations.Count)
			{
				num = 0;
				num2++;
			}
		}
		moveDelay = delay;
		CheckMoveQueue();
	}

	public bool IsDestinationValidForCrane(CargoShipContainerDestination destination)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		Vector3 val = Vector3Ex.WithY(((Component)destination).transform.position, position.y);
		Vector3 val2 = position;
		return Vector3.Distance(val, val2) < MaxMoveDistance - 2f;
	}

	public override void Load(LoadInfo info)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (!base.isServer)
		{
			return;
		}
		startForward = info.msg.harborCrane.startForward;
		ServerTowerGrab.localPosition = new Vector3(0f, info.msg.harborCrane.height, info.msg.harborCrane.depth);
		toParent.uid = info.msg.harborCrane.toParent;
		moveDelay = info.msg.harborCrane.moveDelay;
		if (moveDelay > 0f && !((FacepunchBehaviour)this).IsInvoking((Action)CountdownDelay))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)CountdownDelay, 0f, 0f);
		}
		if (info.msg.harborCrane.currentMove != null)
		{
			moveInProcess = CreateMove(info.msg.harborCrane.currentMove);
		}
		movesToMake.Clear();
		if (info.msg.harborCrane.queuedMoves != null)
		{
			foreach (QueuedMove queuedMove in info.msg.harborCrane.queuedMoves)
			{
				movesToMake.Add(CreateMove(queuedMove));
			}
			Pool.Free<QueuedMove>(ref info.msg.harborCrane.queuedMoves, false);
		}
		currentPickupState = (PickupState)info.msg.harborCrane.currentPickupState;
		if (IsBusy() && !((FacepunchBehaviour)this).IsInvoking((Action)ProcessCraneMovement))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)ProcessCraneMovement, 0f, 0f);
		}
		maxTargetHeight = info.msg.harborCrane.maxMoveHeight;
	}

	private void UpdateArm()
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ArmRoot != (Object)null && (Object)(object)CraneGrab != (Object)null)
		{
			Vector3 position = ((Component)this).transform.position;
			Vector3 position2 = CraneGrab.position;
			float num = Vector3.Distance(position, Vector3Ex.WithY(position2, position.y));
			if (num < MaxMoveDistance + 2f)
			{
				float num2 = Mathf.Acos(num / (MaxMoveDistance + 3f));
				ArmRoot.localEulerAngles = new Vector3(0f - num2 * 57.29578f, 90f, 0f);
			}
		}
		UpdateArmSupports(((Component)this).transform.right);
	}
}


using UnityEngine;

public struct ContainerStack
{
	public Transform RootPoint;

	public int MaxStackSize;

	public int CurrentStackSize { get; set; }
}


using UnityEngine;

private struct QueuedMove
{
	public EntityRef<CargoShipContainer> TargetEntity;

	public Vector3 TargetWorldPosition;

	public Quaternion TargetWorldRotation;

	public bool HasTarget;
}


private enum PickupState
{
	RotateToFace,
	Lift,
	RotateToTarget,
	Drop,
	Reset
}


using UnityEngine;

public class HarborCraneContainerSpawnPoint : MonoBehaviour
{
	public int MaxStackSize = 1;
}


using UnityEngine;

public class HarborCraneSounds : MonoBehaviour, IClientComponent
{
	public HarborCrane crane;

	public SoundDefinition rootRotationLoopDef;

	public SoundDefinition rootRotationStartDef;

	public SoundDefinition rootRotationStopDef;

	public SoundDefinition armRotationLoopDef;

	public SoundDefinition armRotationStartDef;

	public SoundDefinition armRotationStopDef;

	public Transform grabSoundPosition;

	public SoundDefinition grabMoveLoopDef;

	public SoundDefinition grabMoveStartDef;

	public SoundDefinition grabMoveStopDef;
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public class HarborCraneStatic : HarborCrane
{
	public float StartingDepth;

	public float StartingHeight;

	public float StartingAngle;

	public Transform HangingLadder;

	public override void PostMapEntitySpawn()
	{
		base.PostMapEntitySpawn();
		SetArmPos(StartingAngle, StartingHeight, StartingDepth);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.harborCrane = Pool.Get<HarborCrane>();
		info.msg.harborCrane.depth = CraneGrab.localPosition.x;
		info.msg.harborCrane.height = CraneGrab.localPosition.y;
		info.msg.harborCrane.yaw = ArmRoot.localEulerAngles.z;
	}

	private void SetArmPos(float angle, float height, float depth)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		ArmRoot.localEulerAngles = new Vector3(0f, 0f, angle);
		CraneGrab.localPosition = new Vector3(depth, height, 0f);
		HangingLadder.rotation = Quaternion.LookRotation(((Component)this).transform.right, Vector3.up);
		UpdateArmSupports(((Component)this).transform.forward);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.harborCrane != null)
		{
			SetArmPos(info.msg.harborCrane.yaw, info.msg.harborCrane.height, info.msg.harborCrane.depth);
		}
	}
}


using System;
using UnityEngine;

public class HarborProximityEntity : BaseEntity
{
	public bool SupportChildDeployables;

	public const Flags IsMoving = Flags.Reserved1;

	private static ListHashSet<HarborProximityEntity> harborEntities = new ListHashSet<HarborProximityEntity>();

	public override void ServerInit()
	{
		base.ServerInit();
		harborEntities.Add(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		harborEntities.Remove(this);
	}

	public static HarborProximityEntity GetEntity(Vector3 worldPos)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<HarborProximityEntity> enumerator = harborEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				HarborProximityEntity current = enumerator.Current;
				if (Vector3.Distance(Vector3Ex.WithY(((Component)current).transform.position, worldPos.y), worldPos) < 3f)
				{
					return current;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return null;
	}

	public void NotifyStart()
	{
		SetFlag(Flags.Reserved1, b: true);
	}

	public void NotifyEnd()
	{
		SetFlag(Flags.Reserved1, b: false);
	}

	public override bool SupportsChildDeployables()
	{
		return SupportChildDeployables;
	}
}


using System;
using UnityEngine;

public class HarborProximityManager : MonoBehaviour, IServerComponent
{
	[Serializable]
	public class MoveToMake
	{
		public Transform EntityReferencePoint;

		public Transform MinimumPoint;

		public Transform MaximumPoint;

		public AnimationCurve Animation = AnimationCurve.Linear(0f, 0f, 1f, 1f);

		public bool UseToggleMode;

		public float ToggleSpeed = 1f;

		private float toggleState;

		private BaseEntity cachedEntity;

		private bool isMoving;

		public void Apply(float normalisedTime)
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)cachedEntity == (Object)null)
			{
				cachedEntity = HarborProximityEntity.GetEntity(EntityReferencePoint.position);
			}
			if ((Object)(object)cachedEntity == (Object)null)
			{
				return;
			}
			EvaluatePositionRotation(normalisedTime, out var rotToApply, out var posToApply);
			if (((Component)cachedEntity).transform.position != posToApply || ((Component)cachedEntity).transform.rotation != rotToApply)
			{
				if (!isMoving)
				{
					isMoving = true;
					if (cachedEntity is HarborProximityEntity harborProximityEntity)
					{
						harborProximityEntity.NotifyStart();
					}
				}
				((Component)cachedEntity).transform.SetPositionAndRotation(posToApply, rotToApply);
			}
			else if (isMoving)
			{
				isMoving = false;
				if (cachedEntity is HarborProximityEntity harborProximityEntity2)
				{
					harborProximityEntity2.NotifyEnd();
				}
			}
		}

		public void OnDockingEnded()
		{
			if (isMoving)
			{
				isMoving = false;
				if (cachedEntity is HarborProximityEntity harborProximityEntity)
				{
					harborProximityEntity.NotifyEnd();
				}
			}
		}

		public void EvaluatePositionRotation(float normalisedTime, out Quaternion rotToApply, out Vector3 posToApply)
		{
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			float num = Animation.Evaluate(normalisedTime);
			if (UseToggleMode)
			{
				if (Application.isPlaying)
				{
					toggleState = Mathf.MoveTowards(toggleState, num, Time.deltaTime * ToggleSpeed);
				}
				else
				{
					toggleState = num;
				}
				num = toggleState;
			}
			rotToApply = Quaternion.Lerp(MinimumPoint.rotation, MaximumPoint.rotation, num);
			posToApply = Vector3.Lerp(MinimumPoint.position, MaximumPoint.position, num);
		}
	}

	public MoveToMake[] Moves;

	public bool DebugCargo;

	[Range(0f, 1f)]
	public float DebugVisPoint;

	private float localNormalisedState;

	public void StartMovement()
	{
		localNormalisedState = 0f;
		Apply(0f);
	}

	public void UpdateNormalisedState(float f)
	{
		localNormalisedState = Mathf.Max(localNormalisedState, f);
		localNormalisedState = f;
		Apply(localNormalisedState);
	}

	public void EndMovement()
	{
		Apply(0f);
		MoveToMake[] moves = Moves;
		for (int i = 0; i < moves.Length; i++)
		{
			moves[i].OnDockingEnded();
		}
	}

	private void Apply(float f)
	{
		MoveToMake[] moves = Moves;
		for (int i = 0; i < moves.Length; i++)
		{
			moves[i].Apply(f);
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class MoveToMake
{
	public Transform EntityReferencePoint;

	public Transform MinimumPoint;

	public Transform MaximumPoint;

	public AnimationCurve Animation = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public bool UseToggleMode;

	public float ToggleSpeed = 1f;

	private float toggleState;

	private BaseEntity cachedEntity;

	private bool isMoving;

	public void Apply(float normalisedTime)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)cachedEntity == (Object)null)
		{
			cachedEntity = HarborProximityEntity.GetEntity(EntityReferencePoint.position);
		}
		if ((Object)(object)cachedEntity == (Object)null)
		{
			return;
		}
		EvaluatePositionRotation(normalisedTime, out var rotToApply, out var posToApply);
		if (((Component)cachedEntity).transform.position != posToApply || ((Component)cachedEntity).transform.rotation != rotToApply)
		{
			if (!isMoving)
			{
				isMoving = true;
				if (cachedEntity is HarborProximityEntity harborProximityEntity)
				{
					harborProximityEntity.NotifyStart();
				}
			}
			((Component)cachedEntity).transform.SetPositionAndRotation(posToApply, rotToApply);
		}
		else if (isMoving)
		{
			isMoving = false;
			if (cachedEntity is HarborProximityEntity harborProximityEntity2)
			{
				harborProximityEntity2.NotifyEnd();
			}
		}
	}

	public void OnDockingEnded()
	{
		if (isMoving)
		{
			isMoving = false;
			if (cachedEntity is HarborProximityEntity harborProximityEntity)
			{
				harborProximityEntity.NotifyEnd();
			}
		}
	}

	public void EvaluatePositionRotation(float normalisedTime, out Quaternion rotToApply, out Vector3 posToApply)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		float num = Animation.Evaluate(normalisedTime);
		if (UseToggleMode)
		{
			if (Application.isPlaying)
			{
				toggleState = Mathf.MoveTowards(toggleState, num, Time.deltaTime * ToggleSpeed);
			}
			else
			{
				toggleState = num;
			}
			num = toggleState;
		}
		rotToApply = Quaternion.Lerp(MinimumPoint.rotation, MaximumPoint.rotation, num);
		posToApply = Vector3.Lerp(MinimumPoint.position, MaximumPoint.position, num);
	}
}


using UnityEngine;

public class MovementSounds : MonoBehaviour
{
	public SoundDefinition waterMovementDef;

	public float waterMovementFadeInSpeed = 1f;

	public float waterMovementFadeOutSpeed = 1f;

	public SoundDefinition enterWaterSmall;

	public SoundDefinition enterWaterMedium;

	public SoundDefinition enterWaterLarge;

	private Sound waterMovement;

	private SoundModulation.Modulator waterGainMod;

	public bool inWater;

	public float waterLevel;

	public bool mute;
}


using UnityEngine;

public class MoveOverTime : MonoBehaviour
{
	[Range(-10f, 10f)]
	public float speed = 1f;

	public Vector3 position;

	public Vector3 rotation;

	public Vector3 scale;

	private void Update()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)this).transform;
		Quaternion val = ((Component)this).transform.rotation;
		transform.rotation = Quaternion.Euler(((Quaternion)(ref val)).eulerAngles + rotation * speed * Time.deltaTime);
		Transform transform2 = ((Component)this).transform;
		transform2.localScale += scale * speed * Time.deltaTime;
		Transform transform3 = ((Component)this).transform;
		transform3.localPosition += position * speed * Time.deltaTime;
	}
}


using System;
using Network;

public abstract class NetworkCryptography : INetworkCryptography
{
	private byte[] buffer = new byte[8388608];

	public unsafe ArraySegment<byte> EncryptCopy(Connection connection, ArraySegment<byte> data)
	{
		ArraySegment<byte> src = new ArraySegment<byte>(data.Array, data.Offset, data.Count);
		ArraySegment<byte> dst = new ArraySegment<byte>(buffer, data.Offset, buffer.Length - data.Offset);
		if (data.Offset > 0)
		{
			fixed (byte* array2 = dst.Array)
			{
				fixed (byte* array = data.Array)
				{
					Buffer.MemoryCopy(array, array2, dst.Array.Length, data.Offset);
				}
			}
		}
		EncryptionHandler(connection, src, ref dst);
		return dst;
	}

	public unsafe ArraySegment<byte> DecryptCopy(Connection connection, ArraySegment<byte> data)
	{
		ArraySegment<byte> src = new ArraySegment<byte>(data.Array, data.Offset, data.Count);
		ArraySegment<byte> dst = new ArraySegment<byte>(buffer, data.Offset, buffer.Length - data.Offset);
		if (data.Offset > 0)
		{
			fixed (byte* array2 = dst.Array)
			{
				fixed (byte* array = data.Array)
				{
					Buffer.MemoryCopy(array, array2, dst.Array.Length, data.Offset);
				}
			}
		}
		DecryptionHandler(connection, src, ref dst);
		return dst;
	}

	public void Encrypt(Connection connection, ref ArraySegment<byte> data)
	{
		ArraySegment<byte> src = new ArraySegment<byte>(data.Array, data.Offset, data.Count);
		ArraySegment<byte> dst = new ArraySegment<byte>(data.Array, data.Offset, data.Array.Length - data.Offset);
		EncryptionHandler(connection, src, ref dst);
		data = dst;
	}

	public void Decrypt(Connection connection, ref ArraySegment<byte> data)
	{
		ArraySegment<byte> src = new ArraySegment<byte>(data.Array, data.Offset, data.Count);
		ArraySegment<byte> dst = new ArraySegment<byte>(data.Array, data.Offset, data.Array.Length - data.Offset);
		DecryptionHandler(connection, src, ref dst);
		data = dst;
	}

	protected abstract void EncryptionHandler(Connection connection, ArraySegment<byte> src, ref ArraySegment<byte> dst);

	protected abstract void DecryptionHandler(Connection connection, ArraySegment<byte> src, ref ArraySegment<byte> dst);
}


using System;
using Network;

public class NetworkCryptographyServer : NetworkCryptography
{
	protected override void EncryptionHandler(Connection connection, ArraySegment<byte> src, ref ArraySegment<byte> dst)
	{
		if (connection.encryptionLevel > 1)
		{
			EACServer.Encrypt(connection, src, ref dst);
		}
		else
		{
			Craptography.XOR(2590u, src, ref dst);
		}
	}

	protected override void DecryptionHandler(Connection connection, ArraySegment<byte> src, ref ArraySegment<byte> dst)
	{
		if (connection.encryptionLevel > 1)
		{
			EACServer.Decrypt(connection, src, ref dst);
		}
		else
		{
			Craptography.XOR(2590u, src, ref dst);
		}
	}
}


using System;
using ConVar;
using Network;
using Network.Visibility;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Serialization;

public class NetworkVisibilityGrid : MonoBehaviour, Provider
{
	public const int overworldLayer = 0;

	public const int cavesLayer = 1;

	public const int tunnelsLayer = 2;

	public const int tutorialsLayer = 3;

	public const int dynamicDungeonsFirstLayer = 10;

	public int startID = 1024;

	public int gridSize = 100;

	public int cellCount = 32;

	[FormerlySerializedAs("visibilityRadius")]
	public int visibilityRadiusFar = 2;

	public int visibilityRadiusNear = 1;

	public float switchTolerance = 20f;

	public static float cavesThreshold = -5f;

	public static float tunnelsThreshold = -50f;

	public float dynamicDungeonsThreshold = 1000f;

	public float dynamicDungeonsInterval = 100f;

	private float halfGridSize;

	private float cellSize;

	private float halfCellSize;

	private int numIDsPerLayer;

	public static void ResetUndergroundThresholds()
	{
		cavesThreshold = -5f;
		tunnelsThreshold = -50f;
	}

	public static void RegisterEnvironmentVolume(EnvironmentVolume volume)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if ((volume.NetworkType & NetworkGroupType.Canyon) == NetworkGroupType.Canyon)
		{
			tunnelsThreshold = Mathf.Min(tunnelsThreshold, ((Component)volume).transform.position.y + volume.Center.y - volume.Size.y * 0.5f);
		}
	}

	private void Awake()
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Expected O, but got Unknown
		Debug.Assert(Net.sv != null, "Network.Net.sv is NULL when creating Visibility Grid");
		Debug.Assert(Net.sv.visibility == null, "Network.Net.sv.visibility is being set multiple times");
		Net.sv.visibility = new Manager((Provider)(object)this);
	}

	private void OnEnable()
	{
		halfGridSize = (float)gridSize / 2f;
		cellSize = (float)gridSize / (float)cellCount;
		halfCellSize = cellSize / 2f;
		numIDsPerLayer = cellCount * cellCount;
	}

	private void OnDisable()
	{
		if (!Application.isQuitting && Net.sv != null && Net.sv.visibility != null)
		{
			Net.sv.visibility.Dispose();
			Net.sv.visibility = null;
		}
	}

	private void OnDrawGizmosSelected()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.blue;
		Vector3 position = ((Component)this).transform.position;
		for (int i = 0; i <= cellCount; i++)
		{
			float num = 0f - halfGridSize + (float)i * cellSize - halfCellSize;
			Gizmos.DrawLine(new Vector3(halfGridSize, position.y, num), new Vector3(0f - halfGridSize, position.y, num));
			Gizmos.DrawLine(new Vector3(num, position.y, halfGridSize), new Vector3(num, position.y, 0f - halfGridSize));
		}
	}

	private int PositionToGrid(float value)
	{
		return Mathf.Clamp(Mathf.RoundToInt((value + halfGridSize) / cellSize), 0, cellCount - 1);
	}

	private float GridToPosition(int value)
	{
		return (float)value * cellSize - halfGridSize;
	}

	private int PositionToLayer(float x, float y, float z)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (y < tunnelsThreshold)
		{
			return 2;
		}
		if (y < cavesThreshold)
		{
			return 1;
		}
		if (y >= dynamicDungeonsThreshold)
		{
			return 10 + Mathf.FloorToInt((y - dynamicDungeonsThreshold) / dynamicDungeonsInterval);
		}
		if (TerrainMeta.IsPointWithinTutorialBounds(new Vector3(x, 0f, z)))
		{
			return 3;
		}
		return 0;
	}

	private uint CoordToID(int x, int y, int layer)
	{
		return (uint)(layer * numIDsPerLayer + (x * cellCount + y) + startID);
	}

	private uint GetID(Vector3 vPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		int num = PositionToGrid(vPos.x);
		int num2 = PositionToGrid(vPos.z);
		int num3 = PositionToLayer(vPos.x, vPos.y, vPos.z);
		if (num3 == 3)
		{
			Enumerator<TutorialIsland.IslandBounds> enumerator = TutorialIsland.BoundsListServer.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					TutorialIsland.IslandBounds current = enumerator.Current;
					if (current.Contains(vPos))
					{
						return current.Id;
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		uint num4 = CoordToID(num, num2, num3);
		if (num4 < startID)
		{
			Debug.LogError((object)$"NetworkVisibilityGrid.GetID - group is below range {num} {num2} {num3} {num4} {cellCount}");
		}
		return num4;
	}

	private (int x, int y, int layer) DeconstructGroupId(int groupId)
	{
		groupId -= startID;
		int result;
		int item = Math.DivRem(groupId, numIDsPerLayer, out result);
		int result2;
		return (x: Math.DivRem(result, cellCount, out result2), y: result2, layer: item);
	}

	private Bounds GetBounds(uint uid)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		var (value, value2, num) = DeconstructGroupId((int)uid);
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(GridToPosition(value) - halfCellSize, 0f, GridToPosition(value2) - halfCellSize);
		Vector3 max = default(Vector3);
		((Vector3)(ref max))..ctor(val.x + cellSize, 0f, val.z + cellSize);
		if (num == 0 || num == 3)
		{
			val.y = cavesThreshold;
			max.y = dynamicDungeonsThreshold;
		}
		else if (num == 1)
		{
			val.y = tunnelsThreshold;
			max.y = cavesThreshold - float.Epsilon;
		}
		else if (num == 2)
		{
			val.y = -10000f;
			max.y = tunnelsThreshold - float.Epsilon;
		}
		else if (num >= 10)
		{
			int num2 = num - 10;
			val.y = dynamicDungeonsThreshold + (float)num2 * dynamicDungeonsInterval + float.Epsilon;
			max.y = val.y + dynamicDungeonsInterval;
		}
		else
		{
			Debug.LogError((object)$"Cannot get bounds for unknown layer {num}!", (Object)(object)this);
		}
		Bounds result = default(Bounds);
		((Bounds)(ref result)).min = val;
		((Bounds)(ref result)).max = max;
		return result;
	}

	public void OnGroupAdded(Group group)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (!group.restricted)
		{
			group.bounds = GetBounds(group.ID);
		}
	}

	public bool IsInside(Group group, Vector3 vPos)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false || group.ID == 0 || ((Bounds)(ref group.bounds)).Contains(vPos);
		if (!group.restricted)
		{
			flag = flag || ((Bounds)(ref group.bounds)).SqrDistance(vPos) < switchTolerance;
		}
		return flag;
	}

	public Group GetGroup(Vector3 vPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		uint iD = GetID(vPos);
		if (iD == 0)
		{
			return null;
		}
		Group val = Net.sv.visibility.Get(iD);
		if (Net.network_group_debug && !IsInside(val, vPos))
		{
			float num = ((Bounds)(ref val.bounds)).SqrDistance(vPos);
			string[] obj = new string[6]
			{
				"Group is inside is all fucked ",
				iD.ToString(),
				"/",
				num.ToString(),
				"/",
				null
			};
			Vector3 val2 = vPos;
			obj[5] = ((object)(Vector3)(ref val2)/*cast due to .constrained prefix*/).ToString();
			Debug.Log((object)string.Concat(obj));
		}
		return val;
	}

	public void GetVisibleFromFar(Group group, ListHashSet<Group> groups)
	{
		int visibilityRadiusFarOverride = Net.visibilityRadiusFarOverride;
		int radius = ((visibilityRadiusFarOverride > 0) ? visibilityRadiusFarOverride : visibilityRadiusFar);
		GetVisibleFrom(group, groups, radius);
	}

	public void GetVisibleFromNear(Group group, ListHashSet<Group> groups)
	{
		int visibilityRadiusNearOverride = Net.visibilityRadiusNearOverride;
		int radius = ((visibilityRadiusNearOverride > 0) ? visibilityRadiusNearOverride : visibilityRadiusNear);
		GetVisibleFrom(group, groups, radius);
	}

	private void GetVisibleFrom(Group group, ListHashSet<Group> groups, int radius)
	{
		if (Interface.CallHook("OnNetworkSubscriptionsGather", (object)this, (object)group, (object)groups, (object)radius) != null)
		{
			return;
		}
		ListHashSet<Group> groups2 = groups;
		groups2.Add(Net.sv.visibility.Get(0u));
		if (group.restricted)
		{
			groups2.Add(group);
			return;
		}
		int iD = (int)group.ID;
		if (iD < startID)
		{
			return;
		}
		var (num, num2, groupLayer2) = DeconstructGroupId(iD);
		AddLayers(num, num2, groupLayer2);
		for (int i = 1; i <= radius; i++)
		{
			AddLayers(num - i, num2, groupLayer2);
			AddLayers(num + i, num2, groupLayer2);
			AddLayers(num, num2 - i, groupLayer2);
			AddLayers(num, num2 + i, groupLayer2);
			for (int j = 1; j < i; j++)
			{
				AddLayers(num - i, num2 - j, groupLayer2);
				AddLayers(num - i, num2 + j, groupLayer2);
				AddLayers(num + i, num2 - j, groupLayer2);
				AddLayers(num + i, num2 + j, groupLayer2);
				AddLayers(num - j, num2 - i, groupLayer2);
				AddLayers(num + j, num2 - i, groupLayer2);
				AddLayers(num - j, num2 + i, groupLayer2);
				AddLayers(num + j, num2 + i, groupLayer2);
			}
			AddLayers(num - i, num2 - i, groupLayer2);
			AddLayers(num - i, num2 + i, groupLayer2);
			AddLayers(num + i, num2 - i, groupLayer2);
			AddLayers(num + i, num2 + i, groupLayer2);
		}
		void Add(int groupX, int groupY, int groupLayer)
		{
			groups2.Add(Net.sv.visibility.Get(CoordToID(groupX, groupY, groupLayer)));
		}
		void AddLayers(int groupX, int groupY, int groupLayer)
		{
			Add(groupX, groupY, groupLayer);
			if (groupLayer == 0)
			{
				Add(groupX, groupY, 1);
			}
			if (groupLayer == 1)
			{
				Add(groupX, groupY, 2);
				Add(groupX, groupY, 0);
			}
			if (groupLayer == 2)
			{
				Add(groupX, groupY, 1);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Network;
using Network.Visibility;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public static class ServerOcclusion
{
	public readonly struct Grid : IEquatable<Grid>
	{
		public readonly int x;

		public readonly int y;

		public readonly int z;

		public const float Resolution = 16f;

		public const float HalfResolution = 8f;

		public Grid(int x, int y, int z)
		{
			this.x = x;
			this.y = y;
			this.z = z;
		}

		public int GetOffset(float axis)
		{
			return Mathf.RoundToInt(axis / 2f / 16f);
		}

		public Vector3 GetCenterPoint()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			return new Vector3((float)(x - GetOffset(TerrainMeta.Size.x)) * 16f, (float)(y - GetOffset(MaxY)) * 16f, (float)(z - GetOffset(TerrainMeta.Size.z)) * 16f);
		}

		public override string ToString()
		{
			return $"(x: {x}, y: {y}, z: {z})";
		}

		public bool Equals(Grid other)
		{
			if (x == other.x && y == other.y)
			{
				return z == other.z;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(x, y, z);
		}

		public bool IsBlocked()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			return GamePhysics.CheckBounds(new Bounds(GetCenterPoint(), new Vector3(16f, 16f, 16f)), 8388608, (QueryTriggerInteraction)0);
		}

		public int GetIndex()
		{
			return GetGridIndex(x, y, z);
		}
	}

	public readonly struct SubGrid : IEquatable<SubGrid>
	{
		public readonly int x;

		public readonly int y;

		public readonly int z;

		public const float Resolution = 2f;

		public const float HalfResolution = 1f;

		public SubGrid(int x, int y, int z)
		{
			this.x = x;
			this.y = y;
			this.z = z;
		}

		public SubGrid(int3 p)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			x = p.x;
			y = p.y;
			z = p.z;
		}

		public int GetOffset(float axis)
		{
			return Mathf.RoundToInt(axis / 2f / 2f);
		}

		public Vector3 GetCenterPoint()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			return new Vector3((float)(x - GetOffset(TerrainMeta.Size.x)) * 2f, (float)(y - GetOffset(MaxY)) * 2f, (float)(z - GetOffset(TerrainMeta.Size.z)) * 2f);
		}

		public override string ToString()
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			return $"(x: {x}, y: {y}, z: {z}) - {GetCenterPoint()}, {IsBlocked()}";
		}

		public bool Equals(SubGrid other)
		{
			if (x == other.x && y == other.y)
			{
				return z == other.z;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(x, y, z);
		}

		public bool IsBlocked()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			bool flag = false;
			for (int i = 0; i < GridOffsets.Length; i++)
			{
				Vector3 pos = GetCenterPoint() + GridOffsets[i];
				flag = false;
				if (OcclusionIncludeRocks)
				{
					flag = AntiHack.IsInsideMesh(pos);
				}
				if (!flag && !AntiHack.TestInsideTerrain(pos))
				{
					return false;
				}
			}
			if (flag)
			{
				return ((Component)((RaycastHit)(ref AntiHack.isInsideRayHit)).collider).gameObject.HasCustomTag(GameObjectTag.AllowBarricadePlacement);
			}
			return true;
		}

		public int GetIndex()
		{
			return GetSubGridIndex(x, y, z);
		}

		public int GetDistance(SubGrid other)
		{
			return Mathf.Abs(x - other.x) + Mathf.Abs(y - other.y) + Mathf.Abs(z - other.z);
		}
	}

	public static int MaxY = 200;

	public static int ChunkCountX;

	public static int ChunkCountY;

	public static int ChunkCountZ;

	public static int SubChunkCountX;

	public static int SubChunkCountY;

	public static int SubChunkCountZ;

	public static float AxisX;

	public static float AxisY;

	public static float AxisZ;

	public static LimitDictionary<(SubGrid, SubGrid), bool> OcclusionCache = new LimitDictionary<(SubGrid, SubGrid), bool>(32768);

	public static NativeArray<NativeBitArray> OcclusionSubGridBlocked;

	public static NativeReference<bool> ReturnHolder;

	public const int OcclusionChunkSize = 16;

	public const int OcclusionChunkResolution = 8;

	public static Dictionary<Group, ListHashSet<BaseNetworkable>> Occludees = new Dictionary<Group, ListHashSet<BaseNetworkable>>();

	public static readonly Vector3[] GridOffsets = (Vector3[])(object)new Vector3[2]
	{
		new Vector3(0f, 0f, 0f),
		new Vector3(0f, 1f, 0f)
	};

	public static readonly (int, int, int)[] neighbours = new(int, int, int)[6]
	{
		(1, 0, 0),
		(-1, 0, 0),
		(0, 1, 0),
		(0, -1, 0),
		(0, 0, 1),
		(0, 0, -1)
	};

	[ServerVar]
	public static bool UseJob = true;

	public static bool OcclusionEnabled { get; set; } = true;

	public static bool OcclusionIncludeRocks { get; set; } = true;

	public static float OcclusionPollRate => 2f;

	public static int MinOcclusionDistance => 25;

	public static string SubGridFilePath
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			return Server.rootFolder + "/" + World.MapFileName.Replace(".map", "") + "_occlusion.dat";
		}
	}

	public static int GetGridIndex(int x, int y, int z)
	{
		return z * ChunkCountX * ChunkCountY + y * ChunkCountZ + x;
	}

	public static int GetSubGridIndex(int x, int y, int z)
	{
		return z * SubChunkCountX * SubChunkCountY + y * SubChunkCountX + x;
	}

	public static int GetGrid(float position, float axis)
	{
		return Mathf.RoundToInt(position / 16f + axis / 16f);
	}

	public static Grid GetGrid(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		int grid = GetGrid(position.x, AxisX);
		int grid2 = GetGrid(position.y, AxisY);
		int grid3 = GetGrid(position.z, AxisZ);
		if (IsValidGrid(grid, grid2, grid3))
		{
			return new Grid(grid, grid2, grid3);
		}
		return default(Grid);
	}

	public static int GetSubGrid(float position, float axis)
	{
		return Mathf.RoundToInt(position / 2f + axis / 2f);
	}

	public static SubGrid GetSubGrid(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		int subGrid = GetSubGrid(position.x, AxisX);
		int subGrid2 = GetSubGrid(position.y, AxisY);
		int subGrid3 = GetSubGrid(position.z, AxisZ);
		if (IsValidSubGrid(subGrid, subGrid2, subGrid3))
		{
			return new SubGrid(subGrid, subGrid2, subGrid3);
		}
		return default(SubGrid);
	}

	public static bool IsBlocked(int x, int y, int z)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		int result;
		int x2 = Math.DivRem(x, 8, out result);
		int result2;
		int y2 = Math.DivRem(y, 8, out result2);
		int result3;
		int z2 = Math.DivRem(z, 8, out result3);
		int gridIndex = GetGridIndex(x2, y2, z2);
		NativeBitArray val = (NativeBitArray)(IsValidGrid(x2, y2, z2) ? OcclusionSubGridBlocked[gridIndex] : default(NativeBitArray));
		int num = result3 * 8 * 8 + result2 * 8 + result;
		if (((NativeBitArray)(ref val)).IsCreated)
		{
			return ((NativeBitArray)(ref val)).IsSet(num);
		}
		return false;
	}

	public static bool IsBlocked(SubGrid sub)
	{
		return IsBlocked(sub.x, sub.y, sub.z);
	}

	public static bool IsValidGrid(int x, int y, int z)
	{
		if (x < 0 || y < 0 || z < 0)
		{
			return false;
		}
		if (x >= ChunkCountX || y >= ChunkCountY || z >= ChunkCountZ)
		{
			return false;
		}
		return true;
	}

	public static bool IsValidSubGrid(int x, int y, int z)
	{
		if (x < 0 || y < 0 || z < 0)
		{
			return false;
		}
		if (x >= SubChunkCountX || y >= SubChunkCountY || z >= SubChunkCountZ)
		{
			return false;
		}
		return true;
	}

	public static void CalculatePathBetweenGridsJob(SubGrid grid1, SubGrid grid2, out bool pathBlocked)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		pathBlocked = false;
		NativeReference<bool> returnHolder = ReturnHolder;
		CalculatePathBetweenGridsJob calculatePathBetweenGridsJob = default(CalculatePathBetweenGridsJob);
		calculatePathBetweenGridsJob.Grid1 = grid1;
		calculatePathBetweenGridsJob.Grid2 = grid2;
		calculatePathBetweenGridsJob.PathBlocked = returnHolder;
		calculatePathBetweenGridsJob.OcclusionSubGridBlocked = OcclusionSubGridBlocked;
		calculatePathBetweenGridsJob.server_occlusion_blocked_grid_threshold = ConVar.AntiHack.server_occlusion_blocked_grid_threshold;
		calculatePathBetweenGridsJob.server_occlusion_neighbour_threshold = ConVar.AntiHack.server_occlusion_neighbour_threshold;
		calculatePathBetweenGridsJob.server_occlusion_use_neighbour_thresholds = ConVar.AntiHack.server_occlusion_use_neighbour_thresholds;
		calculatePathBetweenGridsJob.ChunkCount = new int3(ChunkCountX, ChunkCountY, ChunkCountZ);
		calculatePathBetweenGridsJob.SubChunkCount = new int3(SubChunkCountX, SubChunkCountY, SubChunkCountZ);
		CalculatePathBetweenGridsJob calculatePathBetweenGridsJob2 = calculatePathBetweenGridsJob;
		IJobExtensions.RunByRef<CalculatePathBetweenGridsJob>(ref calculatePathBetweenGridsJob2);
		pathBlocked = returnHolder.Value;
	}

	public static void CalculatePathBetweenGrids(SubGrid grid1, SubGrid grid2, out bool pathBlocked)
	{
		if (UseJob)
		{
			CalculatePathBetweenGridsJob(grid1, grid2, out pathBlocked);
			return;
		}
		int num = 0;
		int neighboursChecked = 0;
		pathBlocked = false;
		int num2 = grid1.x;
		int num3 = grid1.y;
		int num4 = grid1.z;
		int x = grid2.x;
		int y = grid2.y;
		int z = grid2.z;
		int num5 = x - grid1.x;
		int num6 = y - grid1.y;
		int num7 = z - grid1.z;
		int num8 = Mathf.Abs(num5);
		int num9 = Mathf.Abs(num6);
		int num10 = Mathf.Abs(num7);
		int num11 = num8 << 1;
		int num12 = num9 << 1;
		int num13 = num10 << 1;
		int xStep = ((num5 >= 0) ? 1 : (-1));
		int yStep = ((num6 >= 0) ? 1 : (-1));
		int zStep = ((num7 >= 0) ? 1 : (-1));
		int num14;
		int num15;
		if (num8 >= num9 && num8 >= num10)
		{
			num14 = num12 - num8;
			num15 = num13 - num8;
			for (int i = 0; i < num8; i++)
			{
				if (!AddToGridArea(new SubGrid(num2, num3, num4)) && ++num > ConVar.AntiHack.server_occlusion_blocked_grid_threshold)
				{
					pathBlocked = true;
					break;
				}
				if (num14 > 0)
				{
					num3 += yStep;
					num14 -= num11;
				}
				if (num15 > 0)
				{
					num4 += zStep;
					num15 -= num11;
				}
				num14 += num12;
				num15 += num13;
				num2 += xStep;
			}
			return;
		}
		if (num9 >= num8 && num9 >= num10)
		{
			num14 = num11 - num9;
			num15 = num13 - num9;
			for (int j = 0; j < num9; j++)
			{
				if (!AddToGridArea(new SubGrid(num2, num3, num4)) && ++num > ConVar.AntiHack.server_occlusion_blocked_grid_threshold)
				{
					pathBlocked = true;
					break;
				}
				if (num14 > 0)
				{
					num2 += xStep;
					num14 -= num12;
				}
				if (num15 > 0)
				{
					num4 += zStep;
					num15 -= num12;
				}
				num14 += num11;
				num15 += num13;
				num3 += yStep;
			}
			return;
		}
		num14 = num12 - num10;
		num15 = num11 - num10;
		for (int k = 0; k < num10; k++)
		{
			if (!AddToGridArea(new SubGrid(num2, num3, num4)) && ++num > ConVar.AntiHack.server_occlusion_blocked_grid_threshold)
			{
				pathBlocked = true;
				break;
			}
			if (num14 > 0)
			{
				num3 += yStep;
				num14 -= num13;
			}
			if (num15 > 0)
			{
				num2 += xStep;
				num15 -= num13;
			}
			num14 += num12;
			num15 += num11;
			num4 += zStep;
		}
		bool AddNeighbours(SubGrid grid)
		{
			for (int l = 0; l < neighbours.Length; l++)
			{
				if (neighbours[l].Item1 != -xStep && neighbours[l].Item2 != -yStep && neighbours[l].Item3 != -zStep)
				{
					int x2 = grid.x + neighbours[l].Item1;
					int y2 = grid.y + neighbours[l].Item2;
					int z2 = grid.z + neighbours[l].Item3;
					if (IsValidSubGrid(x2, y2, z2) && !IsBlocked(new SubGrid(x2, y2, z2)))
					{
						return true;
					}
				}
			}
			return false;
		}
		bool AddToGridArea(SubGrid grid)
		{
			if (!IsBlocked(grid))
			{
				return true;
			}
			if (!ConVar.AntiHack.server_occlusion_use_neighbour_thresholds || ++neighboursChecked <= ConVar.AntiHack.server_occlusion_neighbour_threshold)
			{
				return AddNeighbours(grid);
			}
			return false;
		}
	}

	public static void SetupGrid()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		Stopwatch stopwatch = new Stopwatch();
		stopwatch.Start();
		Vector3 size = TerrainMeta.Size;
		ChunkCountX = Mathf.Max(Mathf.CeilToInt(size.x / 16f), 1);
		ChunkCountY = Mathf.Max(Mathf.CeilToInt((float)MaxY / 16f), 1);
		ChunkCountZ = Mathf.Max(Mathf.CeilToInt(size.z / 16f), 1);
		SubChunkCountX = Mathf.Max(Mathf.CeilToInt(size.x / 2f), 1);
		SubChunkCountY = Mathf.Max(Mathf.CeilToInt((float)MaxY / 2f), 1);
		SubChunkCountZ = Mathf.Max(Mathf.CeilToInt(size.z / 2f), 1);
		AxisX = TerrainMeta.Size.x / 2f;
		AxisY = MaxY / 2;
		AxisZ = TerrainMeta.Size.z / 2f;
		bool server_occlusion_save_grid = ConVar.AntiHack.server_occlusion_save_grid;
		if (!server_occlusion_save_grid || !ReadGridFromFile(SubGridFilePath))
		{
			OcclusionSubGridBlocked = new NativeArray<NativeBitArray>(ChunkCountX * ChunkCountY * ChunkCountZ, (Allocator)4, (NativeArrayOptions)1);
			ReturnHolder = new NativeReference<bool>(AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)1);
			Debug.Log((object)$"Preparing Occlusion Grid ({SubChunkCountX}, {SubChunkCountY}, {SubChunkCountZ})");
			for (int i = 0; i < ChunkCountX; i++)
			{
				for (int j = 0; j < ChunkCountY; j++)
				{
					for (int k = 0; k < ChunkCountZ; k++)
					{
						Grid cell2 = new Grid(i, j, k);
						if (cell2.IsBlocked())
						{
							PopulateSubGrid(cell2);
						}
					}
				}
			}
			if (server_occlusion_save_grid)
			{
				WriteGridToFile(ChunkCountX * ChunkCountY * ChunkCountZ, OcclusionSubGridBlocked);
			}
			Debug.Log((object)$"Initialized {SubChunkCountX * SubChunkCountY * SubChunkCountZ} occlusion sub-chunks - took {stopwatch.Elapsed.TotalMilliseconds / 1000.0} seconds");
		}
		else
		{
			Debug.Log((object)$"Loaded {SubChunkCountX * SubChunkCountY * SubChunkCountZ} occlusion sub-chunks from file - took {stopwatch.Elapsed.TotalMilliseconds / 1000.0} seconds");
		}
		foreach (BasePlayer allPlayer in BasePlayer.allPlayerList)
		{
			if (OcclusionEnabled && allPlayer.SupportsServerOcclusion())
			{
				allPlayer.SubGrid = GetSubGrid(allPlayer.GetOcclusionOffset());
				ListHashSet<Group> val = Pool.Get<ListHashSet<Group>>();
				Net.sv.visibility.GetVisibleFromFar(allPlayer.net.group, val);
				allPlayer.GroupAddOccludee(allPlayer.net.group);
				for (int l = 0; l < val.Count; l++)
				{
					allPlayer.GroupAddOccludee(val[l]);
				}
				Pool.FreeUnmanaged<Group>(ref val);
			}
		}
		static void PopulateSubGrid(Grid cell)
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			int num = cell.x * 8;
			int num2 = cell.y * 8;
			int num3 = cell.z * 8;
			int index = cell.GetIndex();
			NativeBitArray val2 = OcclusionSubGridBlocked[index];
			NativeBitArray val3;
			if (!((NativeBitArray)(ref val2)).IsCreated)
			{
				((NativeBitArray)(ref val2))..ctor(512, AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)1);
				OcclusionSubGridBlocked[index] = val2;
				val3 = val2;
			}
			else
			{
				val3 = OcclusionSubGridBlocked[index];
			}
			NativeBitArray val4 = val3;
			for (int m = 0; m < 8; m++)
			{
				for (int n = 0; n < 8; n++)
				{
					for (int num4 = 0; num4 < 8; num4++)
					{
						int num5 = num4 * 8 * 8 + n * 8 + m;
						((NativeBitArray)(ref val4)).Set(num5, new SubGrid(num + m, num2 + n, num3 + num4).IsBlocked());
					}
				}
			}
		}
	}

	public static void Dispose()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (OcclusionSubGridBlocked.IsCreated)
		{
			for (int i = 0; i < OcclusionSubGridBlocked.Length; i++)
			{
				NativeBitArray val = OcclusionSubGridBlocked[i];
				if (((NativeBitArray)(ref val)).IsCreated)
				{
					((NativeBitArray)(ref val)).Dispose();
				}
			}
			OcclusionSubGridBlocked.Dispose();
		}
		if (ReturnHolder.IsCreated)
		{
			ReturnHolder.Dispose();
		}
	}

	private static void WriteGridToFile(int length, NativeArray<NativeBitArray> data)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			using BinaryWriter binaryWriter = new BinaryWriter(File.Open(SubGridFilePath, FileMode.Create));
			binaryWriter.Write(length);
			binaryWriter.Write(OcclusionIncludeRocks);
			Enumerator<NativeBitArray> enumerator = data.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					NativeBitArray current = enumerator.Current;
					if (!((NativeBitArray)(ref current)).IsCreated)
					{
						binaryWriter.Write(0);
						continue;
					}
					binaryWriter.Write(((NativeBitArray)(ref current)).Length);
					byte[] array = new byte[(((NativeBitArray)(ref current)).Length + 7) / 8];
					((NativeBitArray)(ref current)).AsNativeArray<byte>().CopyTo(array);
					binaryWriter.Write(array);
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)ex.Message);
		}
	}

	public static bool ReadGridFromFile(string path)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			if (!File.Exists(path))
			{
				return false;
			}
			using (BinaryReader binaryReader = new BinaryReader(File.Open(path, FileMode.Open)))
			{
				int num = binaryReader.ReadInt32();
				if (binaryReader.ReadBoolean() != OcclusionIncludeRocks)
				{
					Debug.LogWarning((object)"Grid file and occlusion parameters don't match, rebuilding grid");
					binaryReader.Close();
					File.Delete(path);
					return false;
				}
				OcclusionSubGridBlocked = new NativeArray<NativeBitArray>(num, (Allocator)4, (NativeArrayOptions)1);
				ReturnHolder = new NativeReference<bool>(AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)1);
				for (int i = 0; i < num; i++)
				{
					int num2 = binaryReader.ReadInt32();
					if (num2 != 0)
					{
						byte[] array = binaryReader.ReadBytes((num2 + 7) / 8);
						OcclusionSubGridBlocked[i] = new NativeBitArray(num2, AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)1);
						NativeBitArray val = OcclusionSubGridBlocked[i];
						((NativeBitArray)(ref val)).AsNativeArray<byte>().CopyFrom(array);
					}
				}
			}
			return true;
		}
		catch (Exception ex)
		{
			Debug.LogError((object)ex.Message);
			return false;
		}
	}

	[ServerVar(Help = "Tests occlusion visibility between two positions")]
	public static string serverocclusiondebug(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vector = arg.GetVector3(0, default(Vector3));
		Vector3 vector2 = arg.GetVector3(1, default(Vector3));
		SubGrid subGrid = GetSubGrid(vector);
		SubGrid subGrid2 = GetSubGrid(vector2);
		if (subGrid.Equals(default(SubGrid)) || subGrid2.Equals(default(SubGrid)))
		{
			return $"Invalid grid(s), positions provided: {vector} - {vector2}";
		}
		CalculatePathBetweenGrids(subGrid, subGrid2, out var pathBlocked);
		return $"Grid 1: {subGrid}, Grid 2: {subGrid2}\nPath blocked: {pathBlocked}";
	}
}


using System;
using UnityEngine;

public readonly struct Grid : IEquatable<Grid>
{
	public readonly int x;

	public readonly int y;

	public readonly int z;

	public const float Resolution = 16f;

	public const float HalfResolution = 8f;

	public Grid(int x, int y, int z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}

	public int GetOffset(float axis)
	{
		return Mathf.RoundToInt(axis / 2f / 16f);
	}

	public Vector3 GetCenterPoint()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3((float)(x - GetOffset(TerrainMeta.Size.x)) * 16f, (float)(y - GetOffset(MaxY)) * 16f, (float)(z - GetOffset(TerrainMeta.Size.z)) * 16f);
	}

	public override string ToString()
	{
		return $"(x: {x}, y: {y}, z: {z})";
	}

	public bool Equals(Grid other)
	{
		if (x == other.x && y == other.y)
		{
			return z == other.z;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(x, y, z);
	}

	public bool IsBlocked()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		return GamePhysics.CheckBounds(new Bounds(GetCenterPoint(), new Vector3(16f, 16f, 16f)), 8388608, (QueryTriggerInteraction)0);
	}

	public int GetIndex()
	{
		return GetGridIndex(x, y, z);
	}
}


using System;
using Unity.Mathematics;
using UnityEngine;

public readonly struct SubGrid : IEquatable<SubGrid>
{
	public readonly int x;

	public readonly int y;

	public readonly int z;

	public const float Resolution = 2f;

	public const float HalfResolution = 1f;

	public SubGrid(int x, int y, int z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}

	public SubGrid(int3 p)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		x = p.x;
		y = p.y;
		z = p.z;
	}

	public int GetOffset(float axis)
	{
		return Mathf.RoundToInt(axis / 2f / 2f);
	}

	public Vector3 GetCenterPoint()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3((float)(x - GetOffset(TerrainMeta.Size.x)) * 2f, (float)(y - GetOffset(MaxY)) * 2f, (float)(z - GetOffset(TerrainMeta.Size.z)) * 2f);
	}

	public override string ToString()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		return $"(x: {x}, y: {y}, z: {z}) - {GetCenterPoint()}, {IsBlocked()}";
	}

	public bool Equals(SubGrid other)
	{
		if (x == other.x && y == other.y)
		{
			return z == other.z;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(x, y, z);
	}

	public bool IsBlocked()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		for (int i = 0; i < GridOffsets.Length; i++)
		{
			Vector3 pos = GetCenterPoint() + GridOffsets[i];
			flag = false;
			if (OcclusionIncludeRocks)
			{
				flag = AntiHack.IsInsideMesh(pos);
			}
			if (!flag && !AntiHack.TestInsideTerrain(pos))
			{
				return false;
			}
		}
		if (flag)
		{
			return ((Component)((RaycastHit)(ref AntiHack.isInsideRayHit)).collider).gameObject.HasCustomTag(GameObjectTag.AllowBarricadePlacement);
		}
		return true;
	}

	public int GetIndex()
	{
		return GetSubGridIndex(x, y, z);
	}

	public int GetDistance(SubGrid other)
	{
		return Mathf.Abs(x - other.x) + Mathf.Abs(y - other.y) + Mathf.Abs(z - other.z);
	}
}


using System;
using System.Runtime.CompilerServices;
using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct CalculatePathBetweenGridsJob : IJob
{
	public ServerOcclusion.SubGrid Grid1;

	public ServerOcclusion.SubGrid Grid2;

	public NativeReference<bool> PathBlocked;

	[NativeDisableContainerSafetyRestriction]
	[ReadOnly]
	public NativeArray<NativeBitArray> OcclusionSubGridBlocked;

	public int server_occlusion_blocked_grid_threshold;

	public int server_occlusion_neighbour_threshold;

	public bool server_occlusion_use_neighbour_thresholds;

	public int3 ChunkCount;

	public int3 SubChunkCount;

	private static readonly int3[] neighbours = (int3[])(object)new int3[6]
	{
		math.int3(1, 0, 0),
		math.int3(-1, 0, 0),
		math.int3(0, 1, 0),
		math.int3(0, -1, 0),
		math.int3(0, 0, 1),
		math.int3(0, 0, -1)
	};

	public void Execute()
	{
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		int neighboursChecked = 0;
		PathBlocked.Value = false;
		int num2 = Grid1.x;
		int num3 = Grid1.y;
		int num4 = Grid1.z;
		int x = Grid2.x;
		int y = Grid2.y;
		int z = Grid2.z;
		int num5 = x - Grid1.x;
		int num6 = y - Grid1.y;
		int num7 = z - Grid1.z;
		int num8 = Mathf.Abs(num5);
		int num9 = Mathf.Abs(num6);
		int num10 = Mathf.Abs(num7);
		int num11 = num8 << 1;
		int num12 = num9 << 1;
		int num13 = num10 << 1;
		int num14 = ((num5 >= 0) ? 1 : (-1));
		int num15 = ((num6 >= 0) ? 1 : (-1));
		int num16 = ((num7 >= 0) ? 1 : (-1));
		int3 nStep = -math.int3(num14, num15, num16);
		int num17;
		int num18;
		if (num8 >= num9 && num8 >= num10)
		{
			num17 = num12 - num8;
			num18 = num13 - num8;
			for (int i = 0; i < num8; i++)
			{
				ServerOcclusion.SubGrid grid = new ServerOcclusion.SubGrid(num2, num3, num4);
				if (!AddToGridArea(grid, nStep, ref neighboursChecked) && ++num > server_occlusion_blocked_grid_threshold)
				{
					PathBlocked.Value = true;
					break;
				}
				if (num17 > 0)
				{
					num3 += num15;
					num17 -= num11;
				}
				if (num18 > 0)
				{
					num4 += num16;
					num18 -= num11;
				}
				num17 += num12;
				num18 += num13;
				num2 += num14;
			}
			return;
		}
		if (num9 >= num8 && num9 >= num10)
		{
			num17 = num11 - num9;
			num18 = num13 - num9;
			for (int j = 0; j < num9; j++)
			{
				ServerOcclusion.SubGrid grid2 = new ServerOcclusion.SubGrid(num2, num3, num4);
				if (!AddToGridArea(grid2, nStep, ref neighboursChecked) && ++num > server_occlusion_blocked_grid_threshold)
				{
					PathBlocked.Value = true;
					break;
				}
				if (num17 > 0)
				{
					num2 += num14;
					num17 -= num12;
				}
				if (num18 > 0)
				{
					num4 += num16;
					num18 -= num12;
				}
				num17 += num11;
				num18 += num13;
				num3 += num15;
			}
			return;
		}
		num17 = num12 - num10;
		num18 = num11 - num10;
		for (int k = 0; k < num10; k++)
		{
			ServerOcclusion.SubGrid grid3 = new ServerOcclusion.SubGrid(num2, num3, num4);
			if (!AddToGridArea(grid3, nStep, ref neighboursChecked) && ++num > server_occlusion_blocked_grid_threshold)
			{
				PathBlocked.Value = true;
				break;
			}
			if (num17 > 0)
			{
				num3 += num15;
				num17 -= num13;
			}
			if (num18 > 0)
			{
				num2 += num14;
				num18 -= num13;
			}
			num17 += num12;
			num18 += num11;
			num4 += num16;
		}
	}

	private bool IsValidGrid(int3 p)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (p.x < 0 || p.y < 0 || p.z < 0)
		{
			return false;
		}
		if (p.x >= ChunkCount.x || p.y >= ChunkCount.y || p.z >= ChunkCount.z)
		{
			return false;
		}
		return true;
	}

	private bool IsValidSubGrid(int3 p)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (p.x < 0 || p.y < 0 || p.z < 0)
		{
			return false;
		}
		if (p.x >= SubChunkCount.x || p.y >= SubChunkCount.y || p.z >= SubChunkCount.z)
		{
			return false;
		}
		return true;
	}

	private bool AddNeighbours(ServerOcclusion.SubGrid grid, int3 nStep)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		int3 val = math.int3(grid.x, grid.y, grid.z);
		for (int i = 0; i < neighbours.Length; i++)
		{
			int3 val2 = neighbours[i];
			if (!math.any(val2 == nStep))
			{
				int3 p = val + val2;
				if (IsValidSubGrid(p) && !IsBlocked(p))
				{
					return true;
				}
			}
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private int GetGridIndex(int x, int y, int z)
	{
		return z * ChunkCount.x * ChunkCount.y + y * ChunkCount.z + x;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private bool IsBlocked(ServerOcclusion.SubGrid grid)
	{
		return IsBlocked(grid.x, grid.y, grid.z);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private bool IsBlocked(int3 p)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return IsBlocked(p.x, p.y, p.z);
	}

	private bool IsBlocked(int x, int y, int z)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		int result;
		int num = Math.DivRem(x, 8, out result);
		int result2;
		int num2 = Math.DivRem(y, 8, out result2);
		int result3;
		int num3 = Math.DivRem(z, 8, out result3);
		int gridIndex = GetGridIndex(num, num2, num3);
		NativeBitArray val = (NativeBitArray)(IsValidGrid(math.int3(num, num2, num3)) ? OcclusionSubGridBlocked[gridIndex] : default(NativeBitArray));
		int num4 = result3 * 8 * 8 + result2 * 8 + result;
		if (((NativeBitArray)(ref val)).IsCreated)
		{
			return ((NativeBitArray)(ref val)).IsSet(num4);
		}
		return false;
	}

	private bool AddToGridArea(ServerOcclusion.SubGrid grid, int3 nStep, ref int neighboursChecked)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (!IsBlocked(grid))
		{
			return true;
		}
		if (!server_occlusion_use_neighbour_thresholds || ++neighboursChecked <= server_occlusion_neighbour_threshold)
		{
			return AddNeighbours(grid, nStep);
		}
		return false;
	}
}


using System;

[AttributeUsage(AttributeTargets.Property)]
public class SyncAttribute : Attribute
{
	public bool Pack { get; set; } = true;

	public bool Autosave { get; set; }

	public bool RequireChange { get; set; } = true;
}


using UnityEngine;

public class DisableIfDlssNotSupported : MonoBehaviour
{
	private void OnEnable()
	{
		((Component)this).gameObject.SetActive(false);
	}
}


using UnityEngine;

public class NVidiaReflex : MonoBehaviour
{
}


using System;
using UnityEngine;

[Serializable]
public class PIDController
{
	[SerializeField]
	public float p;

	[SerializeField]
	public float i;

	[SerializeField]
	public float d;

	private float oldError;

	private float integralSum;

	public float Update(float dt, float current, float target)
	{
		float num = target - current;
		float num2 = p * num;
		float num3 = (num - oldError) / dt;
		oldError = num;
		float num4 = d * num3;
		integralSum += num * dt;
		float num5 = i * integralSum;
		return num2 + num5 + num4;
	}
}


public enum BlurType
{
	StandardGauss,
	SgxGauss
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class BlurTypeParameter : ParameterOverride<BlurType>
{
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class FixedIntParameter : ParameterOverride<int>
{
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(BlurOptimizedRenderer), PostProcessEvent.AfterStack, "Custom/BlurOptimized", true)]
public class BlurOptimized : PostProcessEffectSettings
{
	[Range(0f, 2f)]
	public FixedIntParameter downsample = new FixedIntParameter
	{
		value = 0
	};

	[Range(1f, 4f)]
	public FixedIntParameter blurIterations = new FixedIntParameter
	{
		value = 1
	};

	[Range(0f, 10f)]
	public FloatParameter blurSize = new FloatParameter
	{
		value = 0f
	};

	public FloatParameter fadeToBlurDistance = new FloatParameter
	{
		value = 0f
	};

	public BlurTypeParameter blurType = new BlurTypeParameter
	{
		value = BlurType.StandardGauss
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class BlurOptimizedRenderer : PostProcessEffectRenderer<BlurOptimized>
{
	private int dataProperty = Shader.PropertyToID("_data");

	private Shader blurShader;

	public override void Init()
	{
		base.Init();
		blurShader = Shader.Find("Hidden/PostProcessing/BlurOptimized");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("BlurOptimized");
		int value = base.settings.downsample.value;
		float value2 = base.settings.fadeToBlurDistance.value;
		float value3 = base.settings.blurSize.value;
		int value4 = base.settings.blurIterations.value;
		BlurType value5 = base.settings.blurType.value;
		float num = 1f / (1f * (float)(1 << value));
		float num2 = 1f / Mathf.Clamp(value2, 0.001f, 10000f);
		PropertySheet propertySheet = context.propertySheets.Get(blurShader);
		propertySheet.properties.SetVector("_Parameter", new Vector4(value3 * num, (0f - value3) * num, num2, 0f));
		int num3 = context.width >> value;
		int num4 = context.height >> value;
		int num5 = Shader.PropertyToID("_BlurRT1");
		int num6 = Shader.PropertyToID("_BlurRT2");
		command.GetTemporaryRT(num5, num3, num4, 0, (FilterMode)1, context.sourceFormat, (RenderTextureReadWrite)0);
		command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(num5), propertySheet, 0, clear: false, null);
		int num7 = ((value5 != 0) ? 2 : 0);
		for (int i = 0; i < value4; i++)
		{
			float num8 = (float)i * 1f;
			propertySheet.properties.SetVector("_Parameter", new Vector4(value3 * num + num8, (0f - value3) * num - num8, num2, 0f));
			command.GetTemporaryRT(num6, num3, num4, 0, (FilterMode)1, context.sourceFormat);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), RenderTargetIdentifier.op_Implicit(num6), propertySheet, 1 + num7, clear: false, null);
			command.ReleaseTemporaryRT(num5);
			command.GetTemporaryRT(num5, num3, num4, 0, (FilterMode)1, context.sourceFormat);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num6), RenderTargetIdentifier.op_Implicit(num5), propertySheet, 2 + num7, clear: false, null);
			command.ReleaseTemporaryRT(num6);
		}
		if (value2 <= 0f)
		{
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), context.destination, clear: false, null);
		}
		else
		{
			command.SetGlobalTexture("_Source", context.source);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), context.destination, propertySheet, 5, clear: false, null);
		}
		command.ReleaseTemporaryRT(num5);
		command.EndSample("BlurOptimized");
	}
}


using UnityEngine;

[CreateAssetMenu]
public class CustomPostEffectsResources : ScriptableObject
{
	public Shader[] shaders;
}


public enum DOFBlurSampleCount
{
	Low,
	Medium,
	High,
	VeryHigh
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public class DOFBlurSampleCountParameter : ParameterOverride<DOFBlurSampleCount>
{
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(DepthOfFieldEffectRenderer), "Unity/Depth of Field (Custom)", false)]
public class DepthOfFieldEffect : PostProcessEffectSettings
{
	public FloatParameter focalLength = new FloatParameter
	{
		value = 10f
	};

	public FloatParameter focalSize = new FloatParameter
	{
		value = 0.05f
	};

	public FloatParameter aperture = new FloatParameter
	{
		value = 11.5f
	};

	[Range(0f, 3f)]
	public FloatParameter anamorphicSqueeze = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	public FloatParameter anamorphicBarrel = new FloatParameter
	{
		value = 0f
	};

	public FloatParameter maxBlurSize = new FloatParameter
	{
		value = 2f
	};

	public BoolParameter highResolution = new BoolParameter
	{
		value = true
	};

	public DOFBlurSampleCountParameter blurSampleCount = new DOFBlurSampleCountParameter
	{
		value = DOFBlurSampleCount.Low
	};

	public Transform focalTransform;
}


using ConVar;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class DepthOfFieldEffectRenderer : PostProcessEffectRenderer<DepthOfFieldEffect>
{
	private float focalDistance01 = 10f;

	private float internalBlurWidth = 1f;

	private Shader dofShader;

	public override void Init()
	{
		dofShader = Shader.Find("Hidden/PostProcessing/DepthOfFieldEffect");
	}

	private float FocalDistance01(Camera cam, float worldDist)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		return cam.WorldToViewportPoint((worldDist - cam.nearClipPlane) * ((Component)cam).transform.forward + ((Component)cam).transform.position).z / (cam.farClipPlane - cam.nearClipPlane);
	}

	private void WriteCoc(PostProcessRenderContext context, PropertySheet sheet)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		RenderTargetIdentifier source = context.source;
		RenderTextureFormat sourceFormat = context.sourceFormat;
		float num = 1f;
		int num2 = context.width / 2;
		int num3 = context.height / 2;
		int num4 = Shader.PropertyToID("DOFtemp1");
		int num5 = Shader.PropertyToID("DOFtemp2");
		command.GetTemporaryRT(num5, num2, num3, 0, (FilterMode)1, sourceFormat);
		command.BlitFullscreenTriangle(source, RenderTargetIdentifier.op_Implicit(num5), sheet, 1, clear: false, null);
		float num6 = internalBlurWidth * num;
		sheet.properties.SetVector("_Offsets", new Vector4(0f, num6, 0f, num6));
		command.GetTemporaryRT(num4, num2, num3, 0, (FilterMode)1, sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), RenderTargetIdentifier.op_Implicit(num4), sheet, 0, clear: false, null);
		command.ReleaseTemporaryRT(num5);
		sheet.properties.SetVector("_Offsets", new Vector4(num6, 0f, 0f, num6));
		command.GetTemporaryRT(num5, num2, num3, 0, (FilterMode)1, sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num4), RenderTargetIdentifier.op_Implicit(num5), sheet, 0, clear: false, null);
		command.ReleaseTemporaryRT(num4);
		command.SetGlobalTexture("_FgOverlap", RenderTargetIdentifier.op_Implicit(num5));
		command.BlitFullscreenTriangle(source, source, sheet, 3, (RenderBufferLoadAction)0, null);
		command.ReleaseTemporaryRT(num5);
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		PropertySheet propertySheet = context.propertySheets.Get(dofShader);
		CommandBuffer command = context.command;
		int width = context.width;
		int height = context.height;
		RenderTextureFormat sourceFormat = context.sourceFormat;
		bool value = base.settings.highResolution.value;
		DOFBlurSampleCountParameter blurSampleCount = base.settings.blurSampleCount;
		float value2 = base.settings.focalSize.value;
		float value3 = base.settings.focalLength.value;
		float value4 = base.settings.aperture.value;
		float value5 = base.settings.maxBlurSize.value;
		int num = Shader.PropertyToID("DOFrtLow");
		int num2 = Shader.PropertyToID("DOFrtLow2");
		value4 = Mathf.Clamp(value4, 1f, 32f);
		value5 = Mathf.Clamp(value5, 0.1f, 32f * ((float)context.height / 1080f));
		value2 = Mathf.Clamp(value2, 0f, 2f);
		internalBlurWidth = Mathf.Max(value5, 0f);
		focalDistance01 = FocalDistance01(context.camera, value3);
		propertySheet.properties.SetVector("_CurveParams", new Vector4(1f, value2, value4 / 10f, focalDistance01));
		propertySheet.properties.SetVector("_DistortionParams", new Vector4((float)base.settings.anamorphicSqueeze, (float)base.settings.anamorphicBarrel * 2f, 0f, 0f));
		if (value)
		{
			internalBlurWidth *= 2f;
		}
		WriteCoc(context, propertySheet);
		if (Graphics.dof_debug)
		{
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 5, clear: false, null);
			return;
		}
		command.GetTemporaryRT(num, width >> 1, height >> 1, 0, (FilterMode)1, sourceFormat);
		command.GetTemporaryRT(num2, width >> 1, height >> 1, 0, (FilterMode)1, sourceFormat);
		int pass = 2;
		if ((float)base.settings.anamorphicSqueeze > 0f || (float)base.settings.anamorphicBarrel > 0f)
		{
			command.EnableShaderKeyword("ANAMORPHIC_BOKEH");
		}
		else
		{
			command.DisableShaderKeyword("ANAMORPHIC_BOKEH");
		}
		propertySheet.properties.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0.025f, internalBlurWidth));
		propertySheet.properties.SetInt("_BlurCountMode", (int)blurSampleCount.value);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, pass, clear: false, null);
		command.ReleaseTemporaryRT(num);
		command.ReleaseTemporaryRT(num2);
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(DoubleVisionRenderer), PostProcessEvent.AfterStack, "Custom/DoubleVision", true)]
public class DoubleVision : PostProcessEffectSettings
{
	[Range(0f, 1f)]
	public Vector2Parameter displace = new Vector2Parameter
	{
		value = Vector2.zero
	};

	[Range(0f, 1f)]
	public FloatParameter amount = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class DoubleVisionRenderer : PostProcessEffectRenderer<DoubleVision>
{
	private int displaceProperty = Shader.PropertyToID("_displace");

	private int amountProperty = Shader.PropertyToID("_amount");

	private Shader doubleVisionShader;

	public override void Init()
	{
		base.Init();
		doubleVisionShader = Shader.Find("Hidden/PostProcessing/DoubleVision");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("DoubleVision");
		PropertySheet propertySheet = context.propertySheets.Get(doubleVisionShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetVector(displaceProperty, Vector4.op_Implicit(base.settings.displace.value));
		propertySheet.properties.SetFloat(amountProperty, base.settings.amount.value);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("DoubleVision");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(FlashbangEffectRenderer), PostProcessEvent.AfterStack, "Custom/FlashbangEffect", false)]
public class FlashbangEffect : PostProcessEffectSettings
{
	[Range(0f, 1f)]
	public FloatParameter burnIntensity = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	public FloatParameter whiteoutIntensity = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class FlashbangEffectRenderer : PostProcessEffectRenderer<FlashbangEffect>
{
	public static bool needsCapture;

	private Shader flashbangEffectShader;

	private RenderTexture screenRT;

	public override void Init()
	{
		base.Init();
		flashbangEffectShader = Shader.Find("Hidden/PostProcessing/FlashbangEffect");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		if (!Application.isPlaying)
		{
			context.command.BlitFullscreenTriangle(context.source, context.destination, clear: false, null);
			return;
		}
		CommandBuffer command = context.command;
		CheckCreateRenderTexture(ref screenRT, "Flashbang", context.width, context.height, context.sourceFormat);
		command.BeginSample("FlashbangEffect");
		if (needsCapture)
		{
			command.CopyTexture(context.source, RenderTargetIdentifier.op_Implicit((Texture)(object)screenRT));
			needsCapture = false;
		}
		PropertySheet propertySheet = context.propertySheets.Get(flashbangEffectShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetFloat("_BurnIntensity", base.settings.burnIntensity.value);
		propertySheet.properties.SetFloat("_WhiteoutIntensity", base.settings.whiteoutIntensity.value);
		if (Object.op_Implicit((Object)(object)screenRT))
		{
			propertySheet.properties.SetTexture("_BurnOverlay", (Texture)(object)screenRT);
		}
		context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("FlashbangEffect");
	}

	public override void Release()
	{
		base.Release();
		SafeDestroyRenderTexture(ref screenRT);
	}

	private static void CheckCreateRenderTexture(ref RenderTexture rt, string name, int width, int height, RenderTextureFormat format)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Expected O, but got Unknown
		if ((Object)(object)rt == (Object)null || ((Texture)rt).width != width || ((Texture)rt).height != height)
		{
			SafeDestroyRenderTexture(ref rt);
			rt = new RenderTexture(width, height, 0, format)
			{
				hideFlags = (HideFlags)52
			};
			((Object)rt).name = name;
			((Texture)rt).wrapMode = (TextureWrapMode)1;
			rt.Create();
		}
	}

	private static void SafeDestroyRenderTexture(ref RenderTexture rt)
	{
		if ((Object)(object)rt != (Object)null)
		{
			rt.Release();
			Object.DestroyImmediate((Object)(object)rt);
			rt = null;
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(FrostRenderer), PostProcessEvent.AfterStack, "Custom/Frost", true)]
public class Frost : PostProcessEffectSettings
{
	[Range(0f, 16f)]
	public FloatParameter scale = new FloatParameter
	{
		value = 0f
	};

	public BoolParameter enableVignette = new BoolParameter
	{
		value = true
	};

	[Range(0f, 100f)]
	public FloatParameter sharpness = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 100f)]
	public FloatParameter darkness = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class FrostRenderer : PostProcessEffectRenderer<Frost>
{
	private int scaleProperty = Shader.PropertyToID("_scale");

	private int sharpnessProperty = Shader.PropertyToID("_sharpness");

	private int darknessProperty = Shader.PropertyToID("_darkness");

	private Shader frostShader;

	public override void Init()
	{
		base.Init();
		frostShader = Shader.Find("Hidden/PostProcessing/Frost");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("Frost");
		PropertySheet propertySheet = context.propertySheets.Get(frostShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetFloat(scaleProperty, base.settings.scale.value);
		propertySheet.properties.SetFloat(sharpnessProperty, base.settings.sharpness.value * 0.01f);
		propertySheet.properties.SetFloat(darknessProperty, base.settings.darkness.value * 0.02f);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, base.settings.enableVignette.value ? 1 : 0, clear: false, null);
		command.EndSample("Frost");
	}
}


public enum BlendModeType
{
	Screen,
	Add
}


public enum ResolutionType
{
	Low,
	Normal,
	High
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class BlendModeTypeParameter : ParameterOverride<BlendModeType>
{
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class ResolutionTypeParameter : ParameterOverride<ResolutionType>
{
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(GodRaysRenderer), PostProcessEvent.BeforeStack, "Custom/GodRays", true)]
public class GodRays : PostProcessEffectSettings
{
	public BoolParameter UseDepth = new BoolParameter
	{
		value = true
	};

	public BlendModeTypeParameter BlendMode = new BlendModeTypeParameter
	{
		value = BlendModeType.Screen
	};

	public FloatParameter Intensity = new FloatParameter
	{
		value = 0f
	};

	public ResolutionTypeParameter Resolution = new ResolutionTypeParameter
	{
		value = ResolutionType.High
	};

	public IntParameter BlurIterations = new IntParameter
	{
		value = 2
	};

	public FloatParameter BlurRadius = new FloatParameter
	{
		value = 2f
	};

	public FloatParameter MaxRadius = new FloatParameter
	{
		value = 0.5f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class GodRaysRenderer : PostProcessEffectRenderer<GodRays>
{
	private const int PASS_SCREEN = 0;

	private const int PASS_ADD = 1;

	public Shader GodRayShader;

	public Shader ScreenClearShader;

	public Shader SkyMaskShader;

	public override void Init()
	{
		if (!Object.op_Implicit((Object)(object)GodRayShader))
		{
			GodRayShader = Shader.Find("Hidden/PostProcessing/GodRays");
		}
		if (!Object.op_Implicit((Object)(object)ScreenClearShader))
		{
			ScreenClearShader = Shader.Find("Hidden/PostProcessing/ScreenClear");
		}
		if (!Object.op_Implicit((Object)(object)SkyMaskShader))
		{
			SkyMaskShader = Shader.Find("Hidden/PostProcessing/SkyMask");
		}
	}

	private void DrawBorder(PostProcessRenderContext context, RenderTargetIdentifier buffer1)
	{
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		PropertySheet propertySheet = context.propertySheets.Get(ScreenClearShader);
		Rect value = default(Rect);
		((Rect)(ref value))..ctor(0f, (float)(context.height - 1), (float)context.width, 1f);
		Rect value2 = default(Rect);
		((Rect)(ref value2))..ctor(0f, 0f, (float)context.width, 1f);
		Rect value3 = default(Rect);
		((Rect)(ref value3))..ctor(0f, 0f, 1f, (float)context.height);
		Rect value4 = default(Rect);
		((Rect)(ref value4))..ctor((float)(context.width - 1), 0f, 1f, (float)context.height);
		context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), buffer1, propertySheet, 0, clear: false, value);
		context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), buffer1, propertySheet, 0, clear: false, value2);
		context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), buffer1, propertySheet, 0, clear: false, value3);
		context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), buffer1, propertySheet, 0, clear: false, value4);
	}

	private int GetSkyMask(PostProcessRenderContext context, ResolutionType resolution, Vector3 lightPos, int blurIterations, float blurRadius, float maxRadius)
	{
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Invalid comparison between Unknown and I4
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		Camera camera = context.camera;
		PropertySheet propertySheet = context.propertySheets.Get(SkyMaskShader);
		command.BeginSample("GodRays");
		int num;
		int num2;
		int num3;
		switch (resolution)
		{
		case ResolutionType.High:
			num = context.screenWidth;
			num2 = context.screenHeight;
			num3 = 0;
			break;
		case ResolutionType.Normal:
			num = context.screenWidth / 2;
			num2 = context.screenHeight / 2;
			num3 = 0;
			break;
		default:
			num = context.screenWidth / 4;
			num2 = context.screenHeight / 4;
			num3 = 0;
			break;
		}
		int num4 = Shader.PropertyToID("buffer1");
		int num5 = Shader.PropertyToID("buffer2");
		command.GetTemporaryRT(num4, num, num2, num3);
		propertySheet.properties.SetVector("_BlurRadius4", new Vector4(1f, 1f, 0f, 0f) * blurRadius);
		propertySheet.properties.SetVector("_LightPosition", new Vector4(lightPos.x, lightPos.y, lightPos.z, maxRadius));
		if ((camera.depthTextureMode & 1) != 0)
		{
			command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(num4), propertySheet, 1, clear: false, null);
		}
		else
		{
			command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(num4), propertySheet, 2, clear: false, null);
		}
		if ((int)camera.stereoActiveEye == 2)
		{
			DrawBorder(context, RenderTargetIdentifier.op_Implicit(num4));
		}
		float num6 = blurRadius * 0.0013020834f;
		propertySheet.properties.SetVector("_BlurRadius4", new Vector4(num6, num6, 0f, 0f));
		propertySheet.properties.SetVector("_LightPosition", new Vector4(lightPos.x, lightPos.y, lightPos.z, maxRadius));
		for (int i = 0; i < blurIterations; i++)
		{
			command.GetTemporaryRT(num5, num, num2, num3);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num4), RenderTargetIdentifier.op_Implicit(num5), propertySheet, 0, clear: false, null);
			command.ReleaseTemporaryRT(num4);
			num6 = blurRadius * (((float)i * 2f + 1f) * 6f) / 768f;
			propertySheet.properties.SetVector("_BlurRadius4", new Vector4(num6, num6, 0f, 0f));
			command.GetTemporaryRT(num4, num, num2, num3);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), RenderTargetIdentifier.op_Implicit(num4), propertySheet, 0, clear: false, null);
			command.ReleaseTemporaryRT(num5);
			num6 = blurRadius * (((float)i * 2f + 2f) * 6f) / 768f;
			propertySheet.properties.SetVector("_BlurRadius4", new Vector4(num6, num6, 0f, 0f));
		}
		command.EndSample("GodRays");
		return num4;
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		Camera camera = context.camera;
		TOD_Sky instance = TOD_Sky.Instance;
		if (!((Object)(object)instance == (Object)null))
		{
			Vector3 val = camera.WorldToViewportPoint(instance.Components.LightTransform.position);
			CommandBuffer command = context.command;
			PropertySheet propertySheet = context.propertySheets.Get(GodRayShader);
			int skyMask = GetSkyMask(context, base.settings.Resolution.value, val, base.settings.BlurIterations.value, base.settings.BlurRadius.value, base.settings.MaxRadius.value);
			Color val2 = Color.black;
			if ((double)val.z >= 0.0)
			{
				val2 = ((!instance.IsDay) ? (base.settings.Intensity.value * instance.MoonVisibility * instance.MoonRayColor) : (base.settings.Intensity.value * instance.SunVisibility * instance.SunRayColor));
			}
			propertySheet.properties.SetColor("_LightColor", val2);
			command.SetGlobalTexture("_SkyMask", RenderTargetIdentifier.op_Implicit(skyMask));
			if (base.settings.BlendMode.value == BlendModeType.Screen)
			{
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
			}
			else
			{
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 1, clear: false, null);
			}
			command.ReleaseTemporaryRT(skyMask);
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(GreyScaleRenderer), PostProcessEvent.AfterStack, "Custom/GreyScale", true)]
public class GreyScale : PostProcessEffectSettings
{
	[Range(0f, 1f)]
	public FloatParameter redLuminance = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	public FloatParameter greenLuminance = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	public FloatParameter blueLuminance = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	public FloatParameter amount = new FloatParameter
	{
		value = 0f
	};

	[ColorUsage(false, true)]
	public ColorParameter color = new ColorParameter
	{
		value = Color.white
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class GreyScaleRenderer : PostProcessEffectRenderer<GreyScale>
{
	private int dataProperty = Shader.PropertyToID("_data");

	private int colorProperty = Shader.PropertyToID("_color");

	private Shader greyScaleShader;

	public override void Init()
	{
		base.Init();
		greyScaleShader = Shader.Find("Hidden/PostProcessing/GreyScale");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("GreyScale");
		PropertySheet propertySheet = context.propertySheets.Get(greyScaleShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetVector(dataProperty, new Vector4(base.settings.redLuminance.value, base.settings.greenLuminance.value, base.settings.blueLuminance.value, base.settings.amount.value));
		propertySheet.properties.SetColor(colorProperty, base.settings.color.value);
		context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("GreyScale");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(LensDirtinessRenderer), PostProcessEvent.AfterStack, "Custom/LensDirtiness", true)]
public class LensDirtinessEffect : PostProcessEffectSettings
{
	public TextureParameter dirtinessTexture = new TextureParameter();

	public BoolParameter sceneTintsBloom = new BoolParameter
	{
		value = false
	};

	public FloatParameter gain = new FloatParameter
	{
		value = 1f
	};

	public FloatParameter threshold = new FloatParameter
	{
		value = 1f
	};

	public FloatParameter bloomSize = new FloatParameter
	{
		value = 5f
	};

	public FloatParameter dirtiness = new FloatParameter
	{
		value = 1f
	};

	public ColorParameter bloomColor = new ColorParameter
	{
		value = Color.white
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class LensDirtinessRenderer : PostProcessEffectRenderer<LensDirtinessEffect>
{
	private enum Pass
	{
		Threshold,
		Kawase,
		Compose
	}

	private int dataProperty = Shader.PropertyToID("_data");

	private Shader lensDirtinessShader;

	public override void Init()
	{
		base.Init();
		lensDirtinessShader = Shader.Find("Hidden/PostProcessing/LensDirtiness");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0308: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_0373: Unknown result type (might be due to invalid IL or missing references)
		//IL_037a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0396: Unknown result type (might be due to invalid IL or missing references)
		//IL_039d: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0410: Unknown result type (might be due to invalid IL or missing references)
		//IL_0412: Unknown result type (might be due to invalid IL or missing references)
		float value = base.settings.bloomSize.value;
		float value2 = base.settings.gain.value;
		float value3 = base.settings.threshold.value;
		float value4 = base.settings.dirtiness.value;
		Color value5 = base.settings.bloomColor.value;
		Texture value6 = base.settings.dirtinessTexture.value;
		bool value7 = base.settings.sceneTintsBloom.value;
		CommandBuffer command = context.command;
		command.BeginSample("LensDirtinessEffect");
		if (value7)
		{
			command.EnableShaderKeyword("_SCENE_TINTS_BLOOM");
		}
		PropertySheet propertySheet = context.propertySheets.Get(lensDirtinessShader);
		RenderTargetIdentifier source = context.source;
		RenderTargetIdentifier destination = context.destination;
		int width = context.width;
		int height = context.height;
		int num = Shader.PropertyToID("_RTT_BloomThreshold");
		int num2 = Shader.PropertyToID("_RTT_1");
		int num3 = Shader.PropertyToID("_RTT_2");
		int num4 = Shader.PropertyToID("_RTT_3");
		int num5 = Shader.PropertyToID("_RTT_4");
		int num6 = Shader.PropertyToID("_RTT_Bloom_1");
		int num7 = Shader.PropertyToID("_RTT_Bloom_2");
		propertySheet.properties.SetFloat("_Gain", value2);
		propertySheet.properties.SetFloat("_Threshold", value3);
		command.GetTemporaryRT(num, width / 2, height / 2, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(source, RenderTargetIdentifier.op_Implicit(num), propertySheet, 0, clear: false, null);
		propertySheet.properties.SetVector("_Offset", new Vector4(1f / (float)width, 1f / (float)height, 0f, 0f) * 2f);
		command.GetTemporaryRT(num2, width / 2, height / 2, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num), RenderTargetIdentifier.op_Implicit(num2), propertySheet, 1, clear: false, null);
		command.ReleaseTemporaryRT(num);
		command.GetTemporaryRT(num3, width / 4, height / 4, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num2), RenderTargetIdentifier.op_Implicit(num3), propertySheet, 1, clear: false, null);
		command.ReleaseTemporaryRT(num2);
		command.GetTemporaryRT(num4, width / 8, height / 8, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num3), RenderTargetIdentifier.op_Implicit(num4), propertySheet, 1, clear: false, null);
		command.ReleaseTemporaryRT(num3);
		command.GetTemporaryRT(num5, width / 16, height / 16, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num4), RenderTargetIdentifier.op_Implicit(num5), propertySheet, 1, clear: false, null);
		command.ReleaseTemporaryRT(num4);
		command.GetTemporaryRT(num6, width / 16, height / 16, 0, (FilterMode)1, context.sourceFormat);
		command.GetTemporaryRT(num7, width / 16, height / 16, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), RenderTargetIdentifier.op_Implicit(num6), clear: false, null);
		command.ReleaseTemporaryRT(num5);
		for (int i = 1; i <= 8; i++)
		{
			float num8 = value * (float)i / (float)width;
			float num9 = value * (float)i / (float)height;
			propertySheet.properties.SetVector("_Offset", new Vector4(num8, num9, 0f, 0f));
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num6), RenderTargetIdentifier.op_Implicit(num7), propertySheet, 1, clear: false, null);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num7), RenderTargetIdentifier.op_Implicit(num6), propertySheet, 1, clear: false, null);
		}
		command.SetGlobalTexture("_Bloom", RenderTargetIdentifier.op_Implicit(num7));
		propertySheet.properties.SetFloat("_Dirtiness", value4);
		propertySheet.properties.SetColor("_BloomColor", value5);
		propertySheet.properties.SetTexture("_DirtinessTexture", value6);
		command.BlitFullscreenTriangle(source, destination, propertySheet, 2, clear: false, null);
		command.ReleaseTemporaryRT(num6);
		command.ReleaseTemporaryRT(num7);
		command.EndSample("LensDirtinessEffect");
	}
}


private enum Pass
{
	Threshold,
	Kawase,
	Compose
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(NightLightEffectRenderer), PostProcessEvent.BeforeStack, "Custom/NightLight", true)]
public class NightLightEffect : PostProcessEffectSettings
{
	[Range(0f, 25f)]
	public FloatParameter distance = new FloatParameter
	{
		value = 5f
	};

	[Range(0f, 1f)]
	public FloatParameter fadeFraction = new FloatParameter
	{
		value = 0.1f
	};

	[Range(0f, 1f)]
	public FloatParameter brightness = new FloatParameter
	{
		value = 0.1f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class NightLightEffectRenderer : PostProcessEffectRenderer<NightLightEffect>
{
	private int distanceProperty = Shader.PropertyToID("_distance");

	private int fadeFractionProperty = Shader.PropertyToID("_fadefraction");

	private int brightnessProperty = Shader.PropertyToID("_brightness");

	private Shader nightlightShader;

	public override void Init()
	{
		base.Init();
		nightlightShader = Shader.Find("Hidden/PostProcessing/NightLightShader");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("NightLight");
		PropertySheet propertySheet = context.propertySheets.Get(nightlightShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetFloat(distanceProperty, base.settings.distance.value);
		propertySheet.properties.SetFloat(fadeFractionProperty, base.settings.fadeFraction.value);
		propertySheet.properties.SetFloat(brightnessProperty, base.settings.brightness.value);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("NightLight");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(PhotoFilterRenderer), PostProcessEvent.AfterStack, "Custom/PhotoFilter", true)]
public class PhotoFilter : PostProcessEffectSettings
{
	public ColorParameter color = new ColorParameter
	{
		value = Color.white
	};

	[Range(0f, 1f)]
	public FloatParameter density = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class PhotoFilterRenderer : PostProcessEffectRenderer<PhotoFilter>
{
	private int rgbProperty = Shader.PropertyToID("_rgb");

	private int densityProperty = Shader.PropertyToID("_density");

	private Shader greyScaleShader;

	public override void Init()
	{
		base.Init();
		greyScaleShader = Shader.Find("Hidden/PostProcessing/PhotoFilter");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("PhotoFilter");
		PropertySheet propertySheet = context.propertySheets.Get(greyScaleShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetColor(rgbProperty, base.settings.color.value);
		propertySheet.properties.SetFloat(densityProperty, base.settings.density.value);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("PhotoFilter");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(RadialBlurRenderer), PostProcessEvent.AfterStack, "Custom/RadialBlur", true)]
public class RadialBlur : PostProcessEffectSettings
{
	[Header("Radial Controls")]
	public Vector2Parameter center = new Vector2Parameter
	{
		value = new Vector2(0.5f, 0.5f)
	};

	[Range(0.1f, 2f)]
	public FloatParameter start = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 2f)]
	public FloatParameter amount = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 3f)]
	[Header("Blur Quality")]
	public FixedIntParameter downsample = new FixedIntParameter
	{
		value = 1
	};

	[Range(1f, 4f)]
	public FixedIntParameter iterations = new FixedIntParameter
	{
		value = 2
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class RadialBlurRenderer : PostProcessEffectRenderer<RadialBlur>
{
	private Shader shader;

	private int rt1ID = Shader.PropertyToID("_BlurRT1");

	private int rt2ID = Shader.PropertyToID("_BlurRT2");

	private int paramsID = Shader.PropertyToID("_Params");

	public override void Init()
	{
		base.Init();
		shader = Shader.Find("Hidden/PostProcessing/RadialBlur");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("RadialBlur");
		if (Mathf.Approximately((float)base.settings.start, 1f) && Mathf.Approximately((float)base.settings.amount, 0f))
		{
			command.BlitFullscreenTriangle(context.source, context.destination, clear: false, null);
		}
		else
		{
			PropertySheet propertySheet = context.propertySheets.Get(shader);
			propertySheet.properties.SetVector(paramsID, new Vector4(base.settings.center.value.x, base.settings.center.value.y, (float)base.settings.start, (float)base.settings.amount));
			int num = context.width >> (int)base.settings.downsample;
			int num2 = context.height >> (int)base.settings.downsample;
			int num3 = (int)base.settings.iterations / 2;
			int num4 = (int)base.settings.iterations % 2;
			command.GetTemporaryRT(rt1ID, num, num2, 0, (FilterMode)1, context.sourceFormat, (RenderTextureReadWrite)0);
			command.GetTemporaryRT(rt2ID, num, num2, 0, (FilterMode)1, context.sourceFormat, (RenderTextureReadWrite)0);
			command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(rt1ID), propertySheet, 0, clear: false, null);
			if ((int)base.settings.iterations > 1)
			{
				for (int i = 0; i < num3; i++)
				{
					command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(rt1ID), RenderTargetIdentifier.op_Implicit(rt2ID), propertySheet, 1, clear: false, null);
					if (i == num3 - 1 && num4 == 0)
					{
						command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(rt2ID), context.destination, propertySheet, 1, clear: false, null);
					}
					else
					{
						command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(rt2ID), RenderTargetIdentifier.op_Implicit(rt1ID), propertySheet, 1, clear: false, null);
					}
				}
			}
			if (num4 > 0)
			{
				command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(rt1ID), context.destination, propertySheet, 1, clear: false, null);
			}
			command.ReleaseTemporaryRT(rt1ID);
			command.ReleaseTemporaryRT(rt2ID);
		}
		command.EndSample("RadialBlur");
	}
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(RustTemporalAntialiasingRenderer), PostProcessEvent.BeforeStack, "Custom/RustTemporalAntialiasing", false)]
public sealed class RustTemporalAntialiasing : PostProcessEffectSettings
{
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class Jitter
{
	private readonly Vector2[] haltonSequence = (Vector2[])(object)new Vector2[16]
	{
		new Vector2(0.5f, 0.333333f),
		new Vector2(0.25f, 0.666667f),
		new Vector2(0.75f, 0.111111f),
		new Vector2(0.125f, 0.444444f),
		new Vector2(0.625f, 0.777778f),
		new Vector2(0.375f, 0.222222f),
		new Vector2(0.875f, 0.555556f),
		new Vector2(0.0625f, 0.888889f),
		new Vector2(0.5625f, 0.037037f),
		new Vector2(0.3125f, 0.37037f),
		new Vector2(0.8125f, 0.703704f),
		new Vector2(0.1875f, 0.148148f),
		new Vector2(0.6875f, 0.481481f),
		new Vector2(0.4375f, 0.814815f),
		new Vector2(0.9375f, 0.259259f),
		new Vector2(1f / 32f, 0.592593f)
	};

	public int SampleIndex { get; private set; }

	public int SampleCount { get; private set; } = 8;

	public Vector2 Offset { get; private set; } = Vector2.zero;

	public Vector2 TexelOffset { get; private set; } = Vector2.zero;

	public Jitter()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		SampleCount = haltonSequence.Length;
	}

	private Matrix4x4 GetJitteredProjectionMatrix(Camera camera)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		Offset = haltonSequence[++SampleIndex % 8] - new Vector2(0.5f, 0.5f);
		TexelOffset = new Vector2(Offset.x / (float)camera.pixelWidth, Offset.y / (float)camera.pixelHeight);
		return RuntimeUtilities.GetJitteredPerspectiveProjectionMatrix(camera, Offset);
	}

	public void ConfigureCameraJitter(PostProcessRenderContext context)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		Camera camera = context.camera;
		camera.nonJitteredProjectionMatrix = camera.projectionMatrix;
		camera.projectionMatrix = GetJitteredProjectionMatrix(camera);
		camera.useJitteredProjectionMatrixForTransparentRendering = true;
	}
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public sealed class RustTemporalAntialiasingRenderer : PostProcessEffectRenderer<RustTemporalAntialiasing>
{
	private const string BUFFER_NAME = "RustTemporalAntiAliasing";

	private static readonly int historyTextureId = Shader.PropertyToID("_HistoryTex");

	private static readonly int jitterTexelOffsetId = Shader.PropertyToID("_JitterTexelOffset");

	public readonly Jitter JitterSettings = new Jitter();

	private RenderTexture[] historyTextures = (RenderTexture[])(object)new RenderTexture[2];

	private readonly RenderTargetIdentifier[] multipleRenderTargets = (RenderTargetIdentifier[])(object)new RenderTargetIdentifier[2];

	private int pingPongValue;

	private Shader postProcessShader;

	public static RustTemporalAntialiasingRenderer Instance { get; private set; }

	public override void Init()
	{
		if (Instance == null)
		{
			Instance = this;
		}
		postProcessShader = Shader.Find("Hidden/PostProcessing/RustTemporalAntialiasing");
		if ((Object)(object)postProcessShader == (Object)null)
		{
			Debug.LogError((object)"Failed to initialize RustTemporalAntialiasing as the shader couldn't be found!");
		}
	}

	private bool IsValid()
	{
		return (Object)(object)postProcessShader != (Object)null;
	}

	private RenderTexture ConvertTextureToMatchCamera(RenderTexture texture, PostProcessRenderContext context)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Expected O, but got Unknown
		if ((Object)(object)texture == (Object)null || ((Texture)texture).width != context.width || ((Texture)texture).height != context.height)
		{
			if (texture != null)
			{
				texture.Release();
			}
			texture = new RenderTexture(context.width, context.height, 0, context.sourceFormat);
		}
		return texture;
	}

	private void RecreateRenderTexturesIfNeeded(PostProcessRenderContext context)
	{
		for (int i = 0; i < historyTextures.Length; i++)
		{
			historyTextures[i] = ConvertTextureToMatchCamera(historyTextures[i], context);
		}
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (!IsValid())
		{
			context.command.BlitFullscreenTriangle(context.source, context.destination, clear: false, null);
			return;
		}
		Camera camera = context.camera;
		camera.depthTextureMode = (DepthTextureMode)(camera.depthTextureMode | 5);
		JitterSettings.ConfigureCameraJitter(context);
		RecreateRenderTexturesIfNeeded(context);
		PropertySheet propertySheet = context.propertySheets.Get(postProcessShader);
		CommandBuffer command = context.command;
		RenderTexture val = historyTextures[pingPongValue++ % 2];
		RenderTexture val2 = historyTextures[pingPongValue++ % 2];
		pingPongValue++;
		multipleRenderTargets[0] = context.destination;
		multipleRenderTargets[1] = RenderTargetIdentifier.op_Implicit((Texture)(object)val);
		command.BeginSample("RustTemporalAntiAliasing");
		command.SetGlobalVector(jitterTexelOffsetId, Vector4.op_Implicit(JitterSettings.TexelOffset));
		command.SetGlobalTexture(historyTextureId, RenderTargetIdentifier.op_Implicit((Texture)(object)val2));
		command.BlitFullscreenTriangle(context.source, multipleRenderTargets, RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), propertySheet, 0, clear: false, null);
		command.EndSample("RustTemporalAntiAliasing");
	}

	public override void Release()
	{
		for (int i = 0; i < historyTextures.Length; i++)
		{
			RenderTexture obj = historyTextures[i];
			if (obj != null)
			{
				obj.Release();
			}
			historyTextures[i] = null;
		}
	}
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class RustTemporalAntialiasingOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;
}


public enum OverlayBlendMode
{
	Additive,
	ScreenBlend,
	Multiply,
	Overlay,
	AlphaBlend,
	AdditiveNonLit,
	AlpbaBlendConst
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class OverlayBlendModeParameter : ParameterOverride<OverlayBlendMode>
{
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(ScreenOverlayRenderer), PostProcessEvent.AfterStack, "Custom/ScreenOverlay", true)]
public class ScreenOverlay : PostProcessEffectSettings
{
	public OverlayBlendModeParameter blendMode = new OverlayBlendModeParameter
	{
		value = OverlayBlendMode.Multiply
	};

	public FloatParameter intensity = new FloatParameter
	{
		value = 0f
	};

	public TextureParameter texture = new TextureParameter
	{
		value = null
	};

	public TextureParameter normals = new TextureParameter
	{
		value = null
	};

	public BoolParameter respectUseLightingConvar = new BoolParameter
	{
		value = false
	};
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class ScreenOverlayRenderer : PostProcessEffectRenderer<ScreenOverlay>
{
	private Shader overlayShader;

	public override void Init()
	{
		base.Init();
		overlayShader = Shader.Find("Hidden/PostProcessing/ScreenOverlay");
	}

	public override void Render(PostProcessRenderContext context)
	{
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(SharpenAndVignetteRenderer), PostProcessEvent.AfterStack, "Custom/SharpenAndVignette", true)]
public class SharpenAndVignette : PostProcessEffectSettings
{
	[Header("Sharpen")]
	public BoolParameter applySharpen = new BoolParameter
	{
		value = true
	};

	[Range(0f, 5f)]
	public FloatParameter strength = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 1f)]
	public FloatParameter clamp = new FloatParameter
	{
		value = 1f
	};

	[Header("Vignette")]
	public BoolParameter applyVignette = new BoolParameter
	{
		value = true
	};

	[Range(-100f, 100f)]
	public FloatParameter sharpness = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 100f)]
	public FloatParameter darkness = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class SharpenAndVignetteRenderer : PostProcessEffectRenderer<SharpenAndVignette>
{
	private Shader sharpenAndVigenetteShader;

	public override void Init()
	{
		base.Init();
		sharpenAndVigenetteShader = Shader.Find("Hidden/PostProcessing/SharpenAndVignette");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("SharpenAndVignette");
		PropertySheet propertySheet = context.propertySheets.Get(sharpenAndVigenetteShader);
		propertySheet.properties.Clear();
		bool value = base.settings.applySharpen.value;
		bool value2 = base.settings.applyVignette.value;
		if (value)
		{
			propertySheet.properties.SetFloat("_px", 1f / (float)Screen.width);
			propertySheet.properties.SetFloat("_py", 1f / (float)Screen.height);
			propertySheet.properties.SetFloat("_strength", base.settings.strength.value);
			propertySheet.properties.SetFloat("_clamp", base.settings.clamp.value);
		}
		if (value2)
		{
			propertySheet.properties.SetFloat("_sharpness", base.settings.sharpness.value * 0.01f);
			propertySheet.properties.SetFloat("_darkness", base.settings.darkness.value * 0.02f);
		}
		if (value && !value2)
		{
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		}
		else if (value && value2)
		{
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 1, clear: false, null);
		}
		else if (!value && value2)
		{
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 2, clear: false, null);
		}
		else
		{
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		}
		command.EndSample("SharpenAndVignette");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(UnderWaterEffectRenderer), PostProcessEvent.AfterStack, "Custom/UnderWaterEffect", false)]
public class UnderwaterPostEffect : PostProcessEffectSettings
{
	[Header("Wiggle")]
	public BoolParameter wiggle = new BoolParameter();

	public FloatParameter speed = new FloatParameter
	{
		value = 1f
	};

	public FloatParameter scale = new FloatParameter
	{
		value = 12f
	};

	[Header("Water Line")]
	public ColorParameter waterLineColor = new ColorParameter();

	[Range(1f, 4f)]
	public FixedIntParameter waterLineBlurIterations = new FixedIntParameter
	{
		value = 1
	};

	[Range(0f, 10f)]
	public FloatParameter waterLineBlurSize = new FloatParameter
	{
		value = 0f
	};

	[Header("Blur")]
	[Range(0f, 2f)]
	public FixedIntParameter downsample = new FixedIntParameter
	{
		value = 0
	};

	[Range(1f, 4f)]
	public FixedIntParameter blurIterations = new FixedIntParameter
	{
		value = 1
	};

	[Range(0f, 10f)]
	public FloatParameter blurSize = new FloatParameter
	{
		value = 0f
	};

	public FloatParameter fadeToBlurDistance = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine.Rendering.PostProcessing;

public class UnderWaterEffectRenderer : PostProcessEffectRenderer<UnderwaterPostEffect>
{
	public override void Render(PostProcessRenderContext context)
	{
	}
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(WiggleRenderer), PostProcessEvent.AfterStack, "Custom/Wiggle", true)]
public class Wiggle : PostProcessEffectSettings
{
	public FloatParameter speed = new FloatParameter
	{
		value = 1f
	};

	public FloatParameter scale = new FloatParameter
	{
		value = 12f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class WiggleRenderer : PostProcessEffectRenderer<Wiggle>
{
	private int timerProperty = Shader.PropertyToID("_timer");

	private int scaleProperty = Shader.PropertyToID("_scale");

	private Shader wiggleShader;

	private float timer;

	public override void Init()
	{
		base.Init();
		wiggleShader = Shader.Find("Hidden/PostProcessing/Wiggle");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("Wiggle");
		timer += base.settings.speed.value * Time.deltaTime;
		PropertySheet propertySheet = context.propertySheets.Get(wiggleShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetFloat(timerProperty, timer);
		propertySheet.properties.SetFloat(scaleProperty, base.settings.scale.value);
		context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("Wiggle");
	}
}


using UnityEngine;

public class PostProcessVolumeLOD : MonoBehaviour, ILOD, IClientComponent
{
	public float distance;
}


using System;

public class BoundsCheck : PrefabAttribute
{
	public enum BlockType
	{
		Tree
	}

	public BlockType IsType;

	protected override Type GetIndexedType()
	{
		return typeof(BoundsCheck);
	}
}


public enum BlockType
{
	Tree
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class BoundsCheckEx
{
	public static bool ApplyBoundsChecks(this BaseEntity entity, BoundsCheck[] bounds, Vector3 pos, Quaternion rot, Vector3 scale, LayerMask rejectOnLayer)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		if (bounds.Length == 0 && LayerMask.op_Implicit(rejectOnLayer) == 0)
		{
			return true;
		}
		OBB obb = new OBB(pos + rot * Vector3.Scale(((Bounds)(ref entity.bounds)).center, scale), Vector3.Scale(((Bounds)(ref entity.bounds)).extents, scale), rot);
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapOBB(obb, list, 0x40000 | LayerMask.op_Implicit(rejectOnLayer), (QueryTriggerInteraction)2);
		SpawnableBoundsBlocker spawnableBoundsBlocker = default(SpawnableBoundsBlocker);
		foreach (Collider item in list)
		{
			if (!item.isTrigger && (((Component)item).gameObject.layer & LayerMask.op_Implicit(rejectOnLayer)) != 0)
			{
				Pool.FreeUnmanaged<Collider>(ref list);
				return false;
			}
			if (!((Component)item).TryGetComponent<SpawnableBoundsBlocker>(ref spawnableBoundsBlocker))
			{
				continue;
			}
			foreach (BoundsCheck boundsCheck in bounds)
			{
				if (spawnableBoundsBlocker.BlockType == boundsCheck.IsType)
				{
					Pool.FreeUnmanaged<Collider>(ref list);
					return false;
				}
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return true;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SpawnableBoundsBlocker : MonoBehaviour
{
	public BoundsCheck.BlockType BlockType;

	public BoxCollider BoxCollider;

	[Button("Clear Trees")]
	public void ClearTrees()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		List<TreeEntity> list = Pool.Get<List<TreeEntity>>();
		if ((Object)(object)BoxCollider != (Object)null)
		{
			GamePhysics.OverlapOBB<TreeEntity>(new OBB(((Component)this).transform.TransformPoint(BoxCollider.center), BoxCollider.size + Vector3.one, ((Component)this).transform.rotation), list, 1073741824, (QueryTriggerInteraction)2);
		}
		foreach (TreeEntity item in list)
		{
			BoundsCheck boundsCheck = PrefabAttribute.server.Find<BoundsCheck>(item.prefabID);
			if (boundsCheck != null && boundsCheck.IsType == BlockType)
			{
				item.Kill();
			}
		}
		Pool.FreeUnmanaged<TreeEntity>(ref list);
	}
}


using System;
using UnityEngine;

[Serializable]
public class ByteMap
{
	[SerializeField]
	private int size;

	[SerializeField]
	private int bytes;

	[SerializeField]
	private byte[] values;

	public int Size => size;

	public uint this[int x, int y]
	{
		get
		{
			int num = y * bytes * size + x * bytes;
			switch (bytes)
			{
			case 1:
				return values[num];
			case 2:
			{
				byte num7 = values[num];
				uint num3 = values[num + 1];
				return (uint)(num7 << 8) | num3;
			}
			case 3:
			{
				byte num6 = values[num];
				uint num3 = values[num + 1];
				uint num4 = values[num + 2];
				return (uint)(num6 << 16) | (num3 << 8) | num4;
			}
			default:
			{
				byte num2 = values[num];
				uint num3 = values[num + 1];
				uint num4 = values[num + 2];
				uint num5 = values[num + 3];
				return (uint)(num2 << 24) | (num3 << 16) | (num4 << 8) | num5;
			}
			}
		}
		set
		{
			int num = y * bytes * size + x * bytes;
			switch (bytes)
			{
			case 1:
				values[num] = (byte)(value & 0xFF);
				break;
			case 2:
				values[num] = (byte)((value >> 8) & 0xFF);
				values[num + 1] = (byte)(value & 0xFF);
				break;
			case 3:
				values[num] = (byte)((value >> 16) & 0xFF);
				values[num + 1] = (byte)((value >> 8) & 0xFF);
				values[num + 2] = (byte)(value & 0xFF);
				break;
			default:
				values[num] = (byte)((value >> 24) & 0xFF);
				values[num + 1] = (byte)((value >> 16) & 0xFF);
				values[num + 2] = (byte)((value >> 8) & 0xFF);
				values[num + 3] = (byte)(value & 0xFF);
				break;
			}
		}
	}

	public ByteMap(int size, int bytes = 1)
	{
		this.size = size;
		this.bytes = bytes;
		values = new byte[bytes * size * size];
	}

	public ByteMap(int size, byte[] values, int bytes = 1)
	{
		this.size = size;
		this.bytes = bytes;
		this.values = values;
	}
}


using System;
using UnityEngine;

[Serializable]
public sealed class ByteQuadtree
{
	public struct Element
	{
		private ByteQuadtree source;

		private int x;

		private int y;

		private int level;

		public bool IsLeaf => level == 0;

		public bool IsRoot => level == source.levels - 1;

		public int ByteMap => level;

		public uint Value => source.values[level][x, y];

		public Vector2 Coords => new Vector2((float)x, (float)y);

		public int Depth => source.levels - level - 1;

		public Element Parent
		{
			get
			{
				if (IsRoot)
				{
					throw new Exception("Element is the root and therefore has no parent.");
				}
				return new Element(source, x / 2, y / 2, level + 1);
			}
		}

		public Element Child1
		{
			get
			{
				if (IsLeaf)
				{
					throw new Exception("Element is a leaf and therefore has no children.");
				}
				return new Element(source, x * 2, y * 2, level - 1);
			}
		}

		public Element Child2
		{
			get
			{
				if (IsLeaf)
				{
					throw new Exception("Element is a leaf and therefore has no children.");
				}
				return new Element(source, x * 2 + 1, y * 2, level - 1);
			}
		}

		public Element Child3
		{
			get
			{
				if (IsLeaf)
				{
					throw new Exception("Element is a leaf and therefore has no children.");
				}
				return new Element(source, x * 2, y * 2 + 1, level - 1);
			}
		}

		public Element Child4
		{
			get
			{
				if (IsLeaf)
				{
					throw new Exception("Element is a leaf and therefore has no children.");
				}
				return new Element(source, x * 2 + 1, y * 2 + 1, level - 1);
			}
		}

		public Element MaxChild
		{
			get
			{
				Element child = Child1;
				Element child2 = Child2;
				Element child3 = Child3;
				Element child4 = Child4;
				uint value = child.Value;
				uint value2 = child2.Value;
				uint value3 = child3.Value;
				uint value4 = child4.Value;
				if (value >= value2 && value >= value3 && value >= value4)
				{
					return child;
				}
				if (value2 >= value3 && value2 >= value4)
				{
					return child2;
				}
				if (value3 >= value4)
				{
					return child3;
				}
				return child4;
			}
		}

		public Element RandChild
		{
			get
			{
				Element child = Child1;
				Element child2 = Child2;
				Element child3 = Child3;
				Element child4 = Child4;
				uint value = child.Value;
				uint value2 = child2.Value;
				uint value3 = child3.Value;
				uint value4 = child4.Value;
				float num = value + value2 + value3 + value4;
				float value5 = Random.value;
				if ((float)value / num >= value5)
				{
					return child;
				}
				if ((float)(value + value2) / num >= value5)
				{
					return child2;
				}
				if ((float)(value + value2 + value3) / num >= value5)
				{
					return child3;
				}
				return child4;
			}
		}

		public Element(ByteQuadtree source, int x, int y, int level)
		{
			this.source = source;
			this.x = x;
			this.y = y;
			this.level = level;
		}
	}

	[SerializeField]
	private int size;

	[SerializeField]
	private int levels;

	[SerializeField]
	private ByteMap[] values;

	public int Size => size;

	public Element Root => new Element(this, 0, 0, levels - 1);

	public void UpdateValues(byte[] baseValues)
	{
		size = Mathf.RoundToInt(Mathf.Sqrt((float)baseValues.Length));
		levels = Mathf.RoundToInt(Mathf.Max(Mathf.Log((float)size, 2f), 0f)) + 1;
		values = new ByteMap[levels];
		values[0] = new ByteMap(size, baseValues);
		for (int i = 1; i < levels; i++)
		{
			ByteMap byteMap = values[i - 1];
			ByteMap byteMap2 = (values[i] = CreateLevel(i));
			for (int j = 0; j < byteMap2.Size; j++)
			{
				for (int k = 0; k < byteMap2.Size; k++)
				{
					byteMap2[k, j] = byteMap[2 * k, 2 * j] + byteMap[2 * k + 1, 2 * j] + byteMap[2 * k, 2 * j + 1] + byteMap[2 * k + 1, 2 * j + 1];
				}
			}
		}
	}

	private ByteMap CreateLevel(int level)
	{
		int num = 1 << levels - level - 1;
		int bytes = 1 + (level + 3) / 4;
		return new ByteMap(num, bytes);
	}
}


using System;
using UnityEngine;

public struct Element
{
	private ByteQuadtree source;

	private int x;

	private int y;

	private int level;

	public bool IsLeaf => level == 0;

	public bool IsRoot => level == source.levels - 1;

	public int ByteMap => level;

	public uint Value => source.values[level][x, y];

	public Vector2 Coords => new Vector2((float)x, (float)y);

	public int Depth => source.levels - level - 1;

	public Element Parent
	{
		get
		{
			if (IsRoot)
			{
				throw new Exception("Element is the root and therefore has no parent.");
			}
			return new Element(source, x / 2, y / 2, level + 1);
		}
	}

	public Element Child1
	{
		get
		{
			if (IsLeaf)
			{
				throw new Exception("Element is a leaf and therefore has no children.");
			}
			return new Element(source, x * 2, y * 2, level - 1);
		}
	}

	public Element Child2
	{
		get
		{
			if (IsLeaf)
			{
				throw new Exception("Element is a leaf and therefore has no children.");
			}
			return new Element(source, x * 2 + 1, y * 2, level - 1);
		}
	}

	public Element Child3
	{
		get
		{
			if (IsLeaf)
			{
				throw new Exception("Element is a leaf and therefore has no children.");
			}
			return new Element(source, x * 2, y * 2 + 1, level - 1);
		}
	}

	public Element Child4
	{
		get
		{
			if (IsLeaf)
			{
				throw new Exception("Element is a leaf and therefore has no children.");
			}
			return new Element(source, x * 2 + 1, y * 2 + 1, level - 1);
		}
	}

	public Element MaxChild
	{
		get
		{
			Element child = Child1;
			Element child2 = Child2;
			Element child3 = Child3;
			Element child4 = Child4;
			uint value = child.Value;
			uint value2 = child2.Value;
			uint value3 = child3.Value;
			uint value4 = child4.Value;
			if (value >= value2 && value >= value3 && value >= value4)
			{
				return child;
			}
			if (value2 >= value3 && value2 >= value4)
			{
				return child2;
			}
			if (value3 >= value4)
			{
				return child3;
			}
			return child4;
		}
	}

	public Element RandChild
	{
		get
		{
			Element child = Child1;
			Element child2 = Child2;
			Element child3 = Child3;
			Element child4 = Child4;
			uint value = child.Value;
			uint value2 = child2.Value;
			uint value3 = child3.Value;
			uint value4 = child4.Value;
			float num = value + value2 + value3 + value4;
			float value5 = Random.value;
			if ((float)value / num >= value5)
			{
				return child;
			}
			if ((float)(value + value2) / num >= value5)
			{
				return child2;
			}
			if ((float)(value + value2 + value3) / num >= value5)
			{
				return child3;
			}
			return child4;
		}
	}

	public Element(ByteQuadtree source, int x, int y, int level)
	{
		this.source = source;
		this.x = x;
		this.y = y;
		this.level = level;
	}
}


using System;
using System.Collections.Generic;
using Unity.Collections;
using UnityEngine;

public static class ImageProcessing
{
	private static byte[] signaturePNG = new byte[8] { 137, 80, 78, 71, 13, 10, 26, 10 };

	private static byte[] signatureIHDR = new byte[8] { 0, 0, 0, 13, 73, 72, 68, 82 };

	public static void GaussianBlur2D(float[] data, int len1, int len2, int iterations = 1)
	{
		float[] array = data;
		float[] array2 = new float[len1 * len2];
		for (int i = 0; i < iterations; i++)
		{
			for (int j = 0; j < len1; j++)
			{
				int num = Mathf.Max(0, j - 1);
				int num2 = Mathf.Min(len1 - 1, j + 1);
				for (int k = 0; k < len2; k++)
				{
					int num3 = Mathf.Max(0, k - 1);
					int num4 = Mathf.Min(len2 - 1, k + 1);
					float num5 = array[j * len2 + k] * 4f + array[j * len2 + num3] + array[j * len2 + num4] + array[num * len2 + k] + array[num2 * len2 + k];
					array2[j * len2 + k] = num5 * 0.125f;
				}
			}
			GenericsUtil.Swap<float[]>(ref array, ref array2);
		}
		if (array != data)
		{
			Buffer.BlockCopy(array, 0, data, 0, data.Length * 4);
		}
	}

	public static void GaussianBlur2D(float[] data, int len1, int len2, int len3, int iterations = 1)
	{
		float[] src = data;
		float[] dst = new float[len1 * len2 * len3];
		for (int i = 0; i < iterations; i++)
		{
			Parallel.For(0, len1, (Action<int>)delegate(int x)
			{
				int num = Mathf.Max(0, x - 1);
				int num2 = Mathf.Min(len1 - 1, x + 1);
				for (int j = 0; j < len2; j++)
				{
					int num3 = Mathf.Max(0, j - 1);
					int num4 = Mathf.Min(len2 - 1, j + 1);
					for (int k = 0; k < len3; k++)
					{
						float num5 = src[(x * len2 + j) * len3 + k] * 4f + src[(x * len2 + num3) * len3 + k] + src[(x * len2 + num4) * len3 + k] + src[(num * len2 + j) * len3 + k] + src[(num2 * len2 + j) * len3 + k];
						dst[(x * len2 + j) * len3 + k] = num5 * 0.125f;
					}
				}
			});
			GenericsUtil.Swap<float[]>(ref src, ref dst);
		}
		if (src != data)
		{
			Buffer.BlockCopy(src, 0, data, 0, data.Length * 4);
		}
	}

	public static void Average2D(float[] data, int len1, int len2, int iterations = 1)
	{
		float[] src = data;
		float[] dst = new float[len1 * len2];
		for (int i = 0; i < iterations; i++)
		{
			Parallel.For(0, len1, (Action<int>)delegate(int x)
			{
				int num = Mathf.Max(0, x - 1);
				int num2 = Mathf.Min(len1 - 1, x + 1);
				for (int j = 0; j < len2; j++)
				{
					int num3 = Mathf.Max(0, j - 1);
					int num4 = Mathf.Min(len2 - 1, j + 1);
					float num5 = src[x * len2 + j] + src[x * len2 + num3] + src[x * len2 + num4] + src[num * len2 + j] + src[num2 * len2 + j];
					dst[x * len2 + j] = num5 * 0.2f;
				}
			});
			GenericsUtil.Swap<float[]>(ref src, ref dst);
		}
		if (src != data)
		{
			Buffer.BlockCopy(src, 0, data, 0, data.Length * 4);
		}
	}

	public static void Average2D(float[] data, int len1, int len2, int len3, int iterations = 1)
	{
		float[] src = data;
		float[] dst = new float[len1 * len2 * len3];
		for (int i = 0; i < iterations; i++)
		{
			Parallel.For(0, len1, (Action<int>)delegate(int x)
			{
				int num = Mathf.Max(0, x - 1);
				int num2 = Mathf.Min(len1 - 1, x + 1);
				for (int j = 0; j < len2; j++)
				{
					int num3 = Mathf.Max(0, j - 1);
					int num4 = Mathf.Min(len2 - 1, j + 1);
					for (int k = 0; k < len3; k++)
					{
						float num5 = src[(x * len2 + j) * len3 + k] + src[(x * len2 + num3) * len3 + k] + src[(x * len2 + num4) * len3 + k] + src[(num * len2 + j) * len3 + k] + src[(num2 * len2 + j) * len3 + k];
						dst[(x * len2 + j) * len3 + k] = num5 * 0.2f;
					}
				}
			});
			GenericsUtil.Swap<float[]>(ref src, ref dst);
		}
		if (src != data)
		{
			Buffer.BlockCopy(src, 0, data, 0, data.Length * 4);
		}
	}

	public static void Upsample2D(float[] src, int srclen1, int srclen2, float[] dst, int dstlen1, int dstlen2)
	{
		if (2 * srclen1 != dstlen1 || 2 * srclen2 != dstlen2)
		{
			return;
		}
		Parallel.For(0, srclen1, (Action<int>)delegate(int x)
		{
			int num = Mathf.Max(0, x - 1);
			int num2 = Mathf.Min(srclen1 - 1, x + 1);
			for (int i = 0; i < srclen2; i++)
			{
				int num3 = Mathf.Max(0, i - 1);
				int num4 = Mathf.Min(srclen2 - 1, i + 1);
				float num5 = src[x * srclen2 + i] * 6f;
				float num6 = num5 + src[num * srclen2 + i] + src[x * srclen2 + num3];
				dst[2 * x * dstlen2 + 2 * i] = num6 * 0.125f;
				float num7 = num5 + src[num2 * srclen2 + i] + src[x * srclen2 + num3];
				dst[(2 * x + 1) * dstlen2 + 2 * i] = num7 * 0.125f;
				float num8 = num5 + src[num * srclen2 + i] + src[x * srclen2 + num4];
				dst[2 * x * dstlen2 + (2 * i + 1)] = num8 * 0.125f;
				float num9 = num5 + src[num2 * srclen2 + i] + src[x * srclen2 + num4];
				dst[(2 * x + 1) * dstlen2 + (2 * i + 1)] = num9 * 0.125f;
			}
		});
	}

	public static void Upsample2D(float[] src, int srclen1, int srclen2, int srclen3, float[] dst, int dstlen1, int dstlen2, int dstlen3)
	{
		if (2 * srclen1 != dstlen1 || 2 * srclen2 != dstlen2 || srclen3 != dstlen3)
		{
			return;
		}
		Parallel.For(0, srclen1, (Action<int>)delegate(int x)
		{
			int num = Mathf.Max(0, x - 1);
			int num2 = Mathf.Min(srclen1 - 1, x + 1);
			for (int i = 0; i < srclen2; i++)
			{
				int num3 = Mathf.Max(0, i - 1);
				int num4 = Mathf.Min(srclen2 - 1, i + 1);
				for (int j = 0; j < srclen3; j++)
				{
					float num5 = src[(x * srclen2 + i) * srclen3 + j] * 6f;
					float num6 = num5 + src[(num * srclen2 + i) * srclen3 + j] + src[(x * srclen2 + num3) * srclen3 + j];
					dst[(2 * x * dstlen2 + 2 * i) * dstlen3 + j] = num6 * 0.125f;
					float num7 = num5 + src[(num2 * srclen2 + i) * srclen3 + j] + src[(x * srclen2 + num3) * srclen3 + j];
					dst[((2 * x + 1) * dstlen2 + 2 * i) * dstlen3 + j] = num7 * 0.125f;
					float num8 = num5 + src[(num * srclen2 + i) * srclen3 + j] + src[(x * srclen2 + num4) * srclen3 + j];
					dst[(2 * x * dstlen2 + (2 * i + 1)) * dstlen3 + j] = num8 * 0.125f;
					float num9 = num5 + src[(num2 * srclen2 + i) * srclen3 + j] + src[(x * srclen2 + num4) * srclen3 + j];
					dst[((2 * x + 1) * dstlen2 + (2 * i + 1)) * dstlen3 + j] = num9 * 0.125f;
				}
			}
		});
	}

	public static void Dilate2D(NativeArray<int> src, int len1, int len2, int srcmask, int radius, Action<int, int> action)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Parallel.For(0, len1, (Action<int>)delegate(int x)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Expected O, but got Unknown
			MaxQueue val = new MaxQueue(radius * 2 + 1);
			for (int i = 0; i < radius; i++)
			{
				val.Push(src[x * len2 + i] & srcmask);
			}
			for (int j = 0; j < len2; j++)
			{
				if (j > radius)
				{
					val.Pop();
				}
				if (j < len2 - radius)
				{
					val.Push(src[x * len2 + j + radius] & srcmask);
				}
				if (val.Max != 0)
				{
					action(x, j);
				}
			}
		});
		Parallel.For(0, len2, (Action<int>)delegate(int y)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Expected O, but got Unknown
			MaxQueue val2 = new MaxQueue(radius * 2 + 1);
			for (int k = 0; k < radius; k++)
			{
				val2.Push(src[k * len2 + y] & srcmask);
			}
			for (int l = 0; l < len1; l++)
			{
				if (l > radius)
				{
					val2.Pop();
				}
				if (l < len1 - radius)
				{
					val2.Push(src[(l + radius) * len2 + y] & srcmask);
				}
				if (val2.Max != 0)
				{
					action(l, y);
				}
			}
		});
	}

	public static void Dilate2D(int[] src, int len1, int len2, int srcmask, int radius, Action<int, int> action)
	{
		Parallel.For(0, len1, (Action<int>)delegate(int x)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Expected O, but got Unknown
			MaxQueue val = new MaxQueue(radius * 2 + 1);
			for (int i = 0; i < radius; i++)
			{
				val.Push(src[x * len2 + i] & srcmask);
			}
			for (int j = 0; j < len2; j++)
			{
				if (j > radius)
				{
					val.Pop();
				}
				if (j < len2 - radius)
				{
					val.Push(src[x * len2 + j + radius] & srcmask);
				}
				if (val.Max != 0)
				{
					action(x, j);
				}
			}
		});
		Parallel.For(0, len2, (Action<int>)delegate(int y)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Expected O, but got Unknown
			MaxQueue val2 = new MaxQueue(radius * 2 + 1);
			for (int k = 0; k < radius; k++)
			{
				val2.Push(src[k * len2 + y] & srcmask);
			}
			for (int l = 0; l < len1; l++)
			{
				if (l > radius)
				{
					val2.Pop();
				}
				if (l < len1 - radius)
				{
					val2.Push(src[(l + radius) * len2 + y] & srcmask);
				}
				if (val2.Max != 0)
				{
					action(l, y);
				}
			}
		});
	}

	public static void FloodFill2D(int x, int y, int[] data, int len1, int len2, int mask_any, int mask_not, Func<int, int> action)
	{
		Stack<KeyValuePair<int, int>> stack = new Stack<KeyValuePair<int, int>>();
		stack.Push(new KeyValuePair<int, int>(x, y));
		while (stack.Count > 0)
		{
			KeyValuePair<int, int> keyValuePair = stack.Pop();
			x = keyValuePair.Key;
			y = keyValuePair.Value;
			int num;
			for (num = y; num >= 0; num--)
			{
				int num2 = data[x * len2 + num];
				if ((num2 & mask_any) == 0 || (num2 & mask_not) != 0)
				{
					break;
				}
			}
			num++;
			bool flag;
			bool flag2 = (flag = false);
			for (; num < len2; num++)
			{
				int num3 = data[x * len2 + num];
				if ((num3 & mask_any) == 0 || (num3 & mask_not) != 0)
				{
					break;
				}
				data[x * len2 + num] = action(num3);
				if (x > 0)
				{
					int num4 = data[(x - 1) * len2 + num];
					bool flag3 = (num4 & mask_any) != 0 && (num4 & mask_not) == 0;
					if (!flag2 && flag3)
					{
						stack.Push(new KeyValuePair<int, int>(x - 1, num));
						flag2 = true;
					}
					else if (flag2 && !flag3)
					{
						flag2 = false;
					}
				}
				if (x < len1 - 1)
				{
					int num5 = data[(x + 1) * len2 + num];
					bool flag4 = (num5 & mask_any) != 0 && (num5 & mask_not) == 0;
					if (!flag && flag4)
					{
						stack.Push(new KeyValuePair<int, int>(x + 1, num));
						flag = true;
					}
					else if (flag && !flag4)
					{
						flag = false;
					}
				}
			}
		}
	}

	public static bool IsValidPNG(byte[] data, int maxSizeSquare)
	{
		return IsValidPNG(data, maxSizeSquare, maxSizeSquare);
	}

	public static bool IsValidPNG(byte[] data, int maxWidth, int maxHeight)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		if (data == null || data.Length < 29)
		{
			return false;
		}
		if (data.Length > 29 + maxWidth * maxHeight * 4)
		{
			return false;
		}
		for (int i = 0; i < signaturePNG.Length; i++)
		{
			if (data[i] != signaturePNG[i])
			{
				return false;
			}
		}
		for (int j = 0; j < signatureIHDR.Length; j++)
		{
			if (data[8 + j] != signatureIHDR[j])
			{
				return false;
			}
		}
		Union32 val = default(Union32);
		val.b4 = data[16];
		val.b3 = data[17];
		val.b2 = data[18];
		val.b1 = data[19];
		if (val.i < 1 || val.i > maxWidth)
		{
			return false;
		}
		Union32 val2 = default(Union32);
		val2.b4 = data[20];
		val2.b3 = data[21];
		val2.b2 = data[22];
		val2.b1 = data[23];
		if (val2.i < 1 || val2.i > maxHeight)
		{
			return false;
		}
		byte b = data[24];
		if (b != 8 && b != 16)
		{
			return false;
		}
		byte b2 = data[25];
		if (b2 != 2 && b2 != 6)
		{
			return false;
		}
		if (data[26] != 0)
		{
			return false;
		}
		if (data[27] != 0)
		{
			return false;
		}
		if (data[28] != 0)
		{
			return false;
		}
		return true;
	}

	public static bool IsValidJPG(byte[] data, int maxSizeSquare)
	{
		return IsValidJPG(data, maxSizeSquare, maxSizeSquare);
	}

	public static bool IsValidJPG(byte[] data, int maxWidth, int maxHeight)
	{
		if (data.Length < 30)
		{
			return false;
		}
		if (data.Length > 30 + maxWidth * maxHeight)
		{
			return false;
		}
		try
		{
			if (data[0] != byte.MaxValue || data[1] != 216)
			{
				return false;
			}
			if (data[2] != byte.MaxValue || data[3] != 224)
			{
				return false;
			}
			if (data[6] != 74 || data[7] != 70 || data[8] != 73 || data[9] != 70 || data[10] != 0)
			{
				return false;
			}
			if (data[13] != 0)
			{
				return false;
			}
			if (data[14] != data[16] || data[15] != data[17])
			{
				return false;
			}
			int num = 4;
			int num2 = (data[num] << 8) | data[num + 1];
			while (num < data.Length)
			{
				num += num2;
				if (num >= data.Length)
				{
					return false;
				}
				if (data[num] != byte.MaxValue)
				{
					return false;
				}
				if (data[num + 1] == 192 || data[num + 1] == 193 || data[num + 1] == 194)
				{
					int num3 = (data[num + 5] << 8) | data[num + 6];
					return ((data[num + 7] << 8) | data[num + 8]) <= maxWidth && num3 <= maxHeight;
				}
				num += 2;
				num2 = (data[num] << 8) | data[num + 1];
			}
			return false;
		}
		catch
		{
			return false;
		}
	}

	public static bool IsClear(Color32[] data)
	{
		for (int i = 0; i < data.Length; i++)
		{
			if (data[i].a > 5)
			{
				return false;
			}
		}
		return true;
	}
}


public static class ManagedNoise
{
	private static readonly int[] hash = new int[512]
	{
		151, 160, 137, 91, 90, 15, 131, 13, 201, 95,
		96, 53, 194, 233, 7, 225, 140, 36, 103, 30,
		69, 142, 8, 99, 37, 240, 21, 10, 23, 190,
		6, 148, 247, 120, 234, 75, 0, 26, 197, 62,
		94, 252, 219, 203, 117, 35, 11, 32, 57, 177,
		33, 88, 237, 149, 56, 87, 174, 20, 125, 136,
		171, 168, 68, 175, 74, 165, 71, 134, 139, 48,
		27, 166, 77, 146, 158, 231, 83, 111, 229, 122,
		60, 211, 133, 230, 220, 105, 92, 41, 55, 46,
		245, 40, 244, 102, 143, 54, 65, 25, 63, 161,
		1, 216, 80, 73, 209, 76, 132, 187, 208, 89,
		18, 169, 200, 196, 135, 130, 116, 188, 159, 86,
		164, 100, 109, 198, 173, 186, 3, 64, 52, 217,
		226, 250, 124, 123, 5, 202, 38, 147, 118, 126,
		255, 82, 85, 212, 207, 206, 59, 227, 47, 16,
		58, 17, 182, 189, 28, 42, 223, 183, 170, 213,
		119, 248, 152, 2, 44, 154, 163, 70, 221, 153,
		101, 155, 167, 43, 172, 9, 129, 22, 39, 253,
		19, 98, 108, 110, 79, 113, 224, 232, 178, 185,
		112, 104, 218, 246, 97, 228, 251, 34, 242, 193,
		238, 210, 144, 12, 191, 179, 162, 241, 81, 51,
		145, 235, 249, 14, 239, 107, 49, 192, 214, 31,
		181, 199, 106, 157, 184, 84, 204, 176, 115, 121,
		50, 45, 127, 4, 150, 254, 138, 236, 205, 93,
		222, 114, 67, 29, 24, 72, 243, 141, 128, 195,
		78, 66, 215, 61, 156, 180, 151, 160, 137, 91,
		90, 15, 131, 13, 201, 95, 96, 53, 194, 233,
		7, 225, 140, 36, 103, 30, 69, 142, 8, 99,
		37, 240, 21, 10, 23, 190, 6, 148, 247, 120,
		234, 75, 0, 26, 197, 62, 94, 252, 219, 203,
		117, 35, 11, 32, 57, 177, 33, 88, 237, 149,
		56, 87, 174, 20, 125, 136, 171, 168, 68, 175,
		74, 165, 71, 134, 139, 48, 27, 166, 77, 146,
		158, 231, 83, 111, 229, 122, 60, 211, 133, 230,
		220, 105, 92, 41, 55, 46, 245, 40, 244, 102,
		143, 54, 65, 25, 63, 161, 1, 216, 80, 73,
		209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
		135, 130, 116, 188, 159, 86, 164, 100, 109, 198,
		173, 186, 3, 64, 52, 217, 226, 250, 124, 123,
		5, 202, 38, 147, 118, 126, 255, 82, 85, 212,
		207, 206, 59, 227, 47, 16, 58, 17, 182, 189,
		28, 42, 223, 183, 170, 213, 119, 248, 152, 2,
		44, 154, 163, 70, 221, 153, 101, 155, 167, 43,
		172, 9, 129, 22, 39, 253, 19, 98, 108, 110,
		79, 113, 224, 232, 178, 185, 112, 104, 218, 246,
		97, 228, 251, 34, 242, 193, 238, 210, 144, 12,
		191, 179, 162, 241, 81, 51, 145, 235, 249, 14,
		239, 107, 49, 192, 214, 31, 181, 199, 106, 157,
		184, 84, 204, 176, 115, 121, 50, 45, 127, 4,
		150, 254, 138, 236, 205, 93, 222, 114, 67, 29,
		24, 72, 243, 141, 128, 195, 78, 66, 215, 61,
		156, 180
	};

	private const int hashMask = 255;

	private const double sqrt2 = 1.4142135623730951;

	private const double rsqrt2 = 0.7071067811865476;

	private const double squaresToTriangles = 0.2113248654051871;

	private const double trianglesToSquares = 0.36602540378443865;

	private const double simplexScale1D = 2.4074074074074074;

	private const double simplexScale2D = 32.99077398303956;

	private const double gradientScale2D = 4.0;

	private static double[] gradients1D = new double[2] { 1.0, -1.0 };

	private const int gradientsMask1D = 1;

	private static double[] gradients2Dx = new double[8] { 1.0, -1.0, 0.0, 0.0, 0.7071067811865476, -0.7071067811865476, 0.7071067811865476, -0.7071067811865476 };

	private static double[] gradients2Dy = new double[8] { 0.0, 0.0, 1.0, -1.0, 0.7071067811865476, 0.7071067811865476, -0.7071067811865476, -0.7071067811865476 };

	private const int gradientsMask2D = 7;

	public static double Simplex1D(double x)
	{
		double num = 0.0;
		int num2;
		int num3 = (num2 = Floor(x));
		double num4 = x - (double)num2;
		double num5 = 1.0 - num4 * num4;
		if (num5 > 0.0)
		{
			double num6 = num5 * num5;
			double num7 = num5 * num6;
			int num8 = hash[num2 & 0xFF] & 1;
			double num9 = gradients1D[num8] * num4;
			num += num9 * num7;
		}
		int num10 = num3 + 1;
		double num11 = x - (double)num10;
		double num12 = 1.0 - num11 * num11;
		if (num12 > 0.0)
		{
			double num13 = num12 * num12;
			double num14 = num12 * num13;
			int num15 = hash[num10 & 0xFF] & 1;
			double num16 = gradients1D[num15] * num11;
			num += num16 * num14;
		}
		return num * 2.4074074074074074;
	}

	public static double Simplex1D(double x, out double dx)
	{
		double num = 0.0;
		dx = 0.0;
		int num2;
		int num3 = (num2 = Floor(x));
		double num4 = x - (double)num2;
		double num5 = 1.0 - num4 * num4;
		if (num5 > 0.0)
		{
			double num6 = num5 * num5;
			double num7 = num5 * num6;
			int num8 = hash[num2 & 0xFF] & 1;
			double num9 = gradients1D[num8];
			double num10 = num9 * num4;
			double num11 = num10 * 6.0 * num6;
			dx += num9 * num7 - num11 * num4;
			num += num10 * num7;
		}
		int num12 = num3 + 1;
		double num13 = x - (double)num12;
		double num14 = 1.0 - num13 * num13;
		if (num14 > 0.0)
		{
			double num15 = num14 * num14;
			double num16 = num14 * num15;
			int num17 = hash[num12 & 0xFF] & 1;
			double num18 = gradients1D[num17];
			double num19 = num18 * num13;
			double num20 = num19 * 6.0 * num15;
			dx += num18 * num16 - num20 * num13;
			num += num19 * num16;
		}
		return num * 2.4074074074074074;
	}

	public static double Simplex2D(double x, double y)
	{
		double num = 0.0;
		double num2 = (x + y) * 0.36602540378443865;
		double num3 = x + num2;
		double num4 = y + num2;
		int num5 = Floor(num3);
		int num6 = Floor(num4);
		int num7 = num5;
		int num8 = num6;
		double num9 = (double)(num7 + num8) * 0.2113248654051871;
		double num10 = x - (double)num7 + num9;
		double num11 = y - (double)num8 + num9;
		double num12 = 0.5 - num10 * num10 - num11 * num11;
		if (num12 > 0.0)
		{
			double num13 = num12 * num12;
			double num14 = num12 * num13;
			int num15 = hash[(hash[num7 & 0xFF] + num8) & 0xFF] & 7;
			double num16 = gradients2Dx[num15];
			double num17 = gradients2Dy[num15];
			double num18 = num16 * num10 + num17 * num11;
			num += num18 * num14;
		}
		int num19 = num5 + 1;
		int num20 = num6 + 1;
		double num21 = (double)(num19 + num20) * 0.2113248654051871;
		double num22 = x - (double)num19 + num21;
		double num23 = y - (double)num20 + num21;
		double num24 = 0.5 - num22 * num22 - num23 * num23;
		if (num24 > 0.0)
		{
			double num25 = num24 * num24;
			double num26 = num24 * num25;
			int num27 = hash[(hash[num19 & 0xFF] + num20) & 0xFF] & 7;
			double num28 = gradients2Dx[num27];
			double num29 = gradients2Dy[num27];
			double num30 = num28 * num22 + num29 * num23;
			num += num30 * num26;
		}
		if (num3 - (double)num5 >= num4 - (double)num6)
		{
			int num31 = num5 + 1;
			int num32 = num6;
			double num33 = (double)(num31 + num32) * 0.2113248654051871;
			double num34 = x - (double)num31 + num33;
			double num35 = y - (double)num32 + num33;
			double num36 = 0.5 - num34 * num34 - num35 * num35;
			if (num36 > 0.0)
			{
				double num37 = num36 * num36;
				double num38 = num36 * num37;
				int num39 = hash[(hash[num31 & 0xFF] + num32) & 0xFF] & 7;
				double num40 = gradients2Dx[num39];
				double num41 = gradients2Dy[num39];
				double num42 = num40 * num34 + num41 * num35;
				num += num42 * num38;
			}
		}
		else
		{
			int num43 = num5;
			int num44 = num6 + 1;
			double num45 = (double)(num43 + num44) * 0.2113248654051871;
			double num46 = x - (double)num43 + num45;
			double num47 = y - (double)num44 + num45;
			double num48 = 0.5 - num46 * num46 - num47 * num47;
			if (num48 > 0.0)
			{
				double num49 = num48 * num48;
				double num50 = num48 * num49;
				int num51 = hash[(hash[num43 & 0xFF] + num44) & 0xFF] & 7;
				double num52 = gradients2Dx[num51];
				double num53 = gradients2Dy[num51];
				double num54 = num52 * num46 + num53 * num47;
				num += num54 * num50;
			}
		}
		return num * 32.99077398303956;
	}

	public static double Simplex2D(double x, double y, out double dx, out double dy)
	{
		double num = 0.0;
		dx = 0.0;
		dy = 0.0;
		double num2 = (x + y) * 0.36602540378443865;
		double num3 = x + num2;
		double num4 = y + num2;
		int num5 = Floor(num3);
		int num6 = Floor(num4);
		int num7 = num5;
		int num8 = num6;
		double num9 = (double)(num7 + num8) * 0.2113248654051871;
		double num10 = x - (double)num7 + num9;
		double num11 = y - (double)num8 + num9;
		double num12 = 0.5 - num10 * num10 - num11 * num11;
		if (num12 > 0.0)
		{
			double num13 = num12 * num12;
			double num14 = num12 * num13;
			int num15 = hash[(hash[num7 & 0xFF] + num8) & 0xFF] & 7;
			double num16 = gradients2Dx[num15];
			double num17 = gradients2Dy[num15];
			double num18 = num16 * num10 + num17 * num11;
			double num19 = num18 * 6.0 * num13;
			dx += num16 * num14 - num19 * num10;
			dy += num17 * num14 - num19 * num11;
			num += num18 * num14;
		}
		int num20 = num5 + 1;
		int num21 = num6 + 1;
		double num22 = (double)(num20 + num21) * 0.2113248654051871;
		double num23 = x - (double)num20 + num22;
		double num24 = y - (double)num21 + num22;
		double num25 = 0.5 - num23 * num23 - num24 * num24;
		if (num25 > 0.0)
		{
			double num26 = num25 * num25;
			double num27 = num25 * num26;
			int num28 = hash[(hash[num20 & 0xFF] + num21) & 0xFF] & 7;
			double num29 = gradients2Dx[num28];
			double num30 = gradients2Dy[num28];
			double num31 = num29 * num23 + num30 * num24;
			double num32 = num31 * 6.0 * num26;
			dx += num29 * num27 - num32 * num23;
			dy += num30 * num27 - num32 * num24;
			num += num31 * num27;
		}
		if (num3 - (double)num5 >= num4 - (double)num6)
		{
			int num33 = num5 + 1;
			int num34 = num6;
			double num35 = (double)(num33 + num34) * 0.2113248654051871;
			double num36 = x - (double)num33 + num35;
			double num37 = y - (double)num34 + num35;
			double num38 = 0.5 - num36 * num36 - num37 * num37;
			if (num38 > 0.0)
			{
				double num39 = num38 * num38;
				double num40 = num38 * num39;
				int num41 = hash[(hash[num33 & 0xFF] + num34) & 0xFF] & 7;
				double num42 = gradients2Dx[num41];
				double num43 = gradients2Dy[num41];
				double num44 = num42 * num36 + num43 * num37;
				double num45 = num44 * 6.0 * num39;
				dx += num42 * num40 - num45 * num36;
				dy += num43 * num40 - num45 * num37;
				num += num44 * num40;
			}
		}
		else
		{
			int num46 = num5;
			int num47 = num6 + 1;
			double num48 = (double)(num46 + num47) * 0.2113248654051871;
			double num49 = x - (double)num46 + num48;
			double num50 = y - (double)num47 + num48;
			double num51 = 0.5 - num49 * num49 - num50 * num50;
			if (num51 > 0.0)
			{
				double num52 = num51 * num51;
				double num53 = num51 * num52;
				int num54 = hash[(hash[num46 & 0xFF] + num47) & 0xFF] & 7;
				double num55 = gradients2Dx[num54];
				double num56 = gradients2Dy[num54];
				double num57 = num55 * num49 + num56 * num50;
				double num58 = num57 * 6.0 * num52;
				dx += num55 * num53 - num58 * num49;
				dy += num56 * num53 - num58 * num50;
				num += num57 * num53;
			}
		}
		dx *= 4.0;
		dy *= 4.0;
		return num * 32.99077398303956;
	}

	public static double Turbulence(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		for (int i = 0; i < octaves; i++)
		{
			double num4 = Simplex2D(x * num2, y * num2);
			num += num3 * num4;
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double Billow(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		for (int i = 0; i < octaves; i++)
		{
			double x2 = Simplex2D(x * num2, y * num2);
			num += num3 * Abs(x2);
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double Ridge(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		for (int i = 0; i < octaves; i++)
		{
			double x2 = Simplex2D(x * num2, y * num2);
			num += num3 * (1.0 - Abs(x2));
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double Sharp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		for (int i = 0; i < octaves; i++)
		{
			double num4 = Simplex2D(x * num2, y * num2);
			num += num3 * (num4 * num4);
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double TurbulenceIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D(x * num2, y * num2, out dx, out dy);
			num4 += dx;
			num5 += dy;
			num += num3 * num6 / (1.0 + (num4 * num4 + num5 * num5));
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double BillowIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double x2 = Simplex2D(x * num2, y * num2, out dx, out dy);
			num4 += dx;
			num5 += dy;
			num += num3 * Abs(x2) / (1.0 + (num4 * num4 + num5 * num5));
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double RidgeIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double x2 = Simplex2D(x * num2, y * num2, out dx, out dy);
			num4 += dx;
			num5 += dy;
			num += num3 * (1.0 - Abs(x2)) / (1.0 + (num4 * num4 + num5 * num5));
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double SharpIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D(x * num2, y * num2, out dx, out dy);
			num4 += dx;
			num5 += dy;
			num += num3 * (num6 * num6) / (1.0 + (num4 * num4 + num5 * num5));
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double TurbulenceWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D((x + warp * num4) * num2, (y + warp * num5) * num2, out dx, out dy);
			num += num3 * num6;
			num4 += num3 * dx * (0.0 - num6);
			num5 += num3 * dy * (0.0 - num6);
			num2 *= lacunarity;
			num3 *= gain * Saturate(num);
		}
		return num * amplitude;
	}

	public static double BillowWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D((x + warp * num4) * num2, (y + warp * num5) * num2, out dx, out dy);
			num += num3 * Abs(num6);
			num4 += num3 * dx * (0.0 - num6);
			num5 += num3 * dy * (0.0 - num6);
			num2 *= lacunarity;
			num3 *= gain * Saturate(num);
		}
		return num * amplitude;
	}

	public static double RidgeWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D((x + warp * num4) * num2, (y + warp * num5) * num2, out dx, out dy);
			num += num3 * (1.0 - Abs(num6));
			num4 += num3 * dx * (0.0 - num6);
			num5 += num3 * dy * (0.0 - num6);
			num2 *= lacunarity;
			num3 *= gain * Saturate(num);
		}
		return num * amplitude;
	}

	public static double SharpWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D((x + warp * num4) * num2, (y + warp * num5) * num2, out dx, out dy);
			num += num3 * (num6 * num6);
			num4 += num3 * dx * (0.0 - num6);
			num5 += num3 * dy * (0.0 - num6);
			num2 *= lacunarity;
			num3 *= gain * Saturate(num);
		}
		return num * amplitude;
	}

	public static double Jordan(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp, double damp, double damp_scale)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		double num6 = 0.0;
		double num7 = 0.0;
		double num8 = num2 * gain;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num9 = Simplex2D(x * num3 + num4, y * num3 + num5, out dx, out dy);
			double num10 = num9 * num9;
			double num11 = dx * num9;
			double num12 = dy * num9;
			num += num8 * num10;
			num4 += warp * num11;
			num5 += warp * num12;
			num6 += damp * num11;
			num7 += damp * num12;
			num3 *= lacunarity;
			num2 *= gain;
			num8 = num2 * (1.0 - damp_scale / (1.0 + (num6 * num6 + num7 * num7)));
		}
		return num * amplitude;
	}

	private static int Floor(double x)
	{
		if (!(x >= 0.0))
		{
			return (int)x - 1;
		}
		return (int)x;
	}

	private static double Abs(double x)
	{
		if (!(x >= 0.0))
		{
			return 0.0 - x;
		}
		return x;
	}

	private static double Saturate(double x)
	{
		if (!(x > 1.0))
		{
			if (!(x < 0.0))
			{
				return x;
			}
			return 0.0;
		}
		return 1.0;
	}
}


using System.Runtime.InteropServices;
using System.Security;

[SuppressUnmanagedCodeSecurity]
public static class NativeNoise
{
	[DllImport("RustNative", EntryPoint = "snoise1_32")]
	public static extern float Simplex1D(float x);

	[DllImport("RustNative", EntryPoint = "sdnoise1_32")]
	public static extern float Simplex1D(float x, out float dx);

	[DllImport("RustNative", EntryPoint = "snoise2_32")]
	public static extern float Simplex2D(float x, float y);

	[DllImport("RustNative", EntryPoint = "sdnoise2_32")]
	public static extern float Simplex2D(float x, float y, out float dx, out float dy);

	[DllImport("RustNative", EntryPoint = "turbulence_32")]
	public static extern float Turbulence(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "billow_32")]
	public static extern float Billow(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "ridge_32")]
	public static extern float Ridge(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "sharp_32")]
	public static extern float Sharp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "turbulence_iq_32")]
	public static extern float TurbulenceIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "billow_iq_32")]
	public static extern float BillowIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "ridge_iq_32")]
	public static extern float RidgeIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "sharp_iq_32")]
	public static extern float SharpIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "turbulence_warp_32")]
	public static extern float TurbulenceWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);

	[DllImport("RustNative", EntryPoint = "billow_warp_32")]
	public static extern float BillowWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);

	[DllImport("RustNative", EntryPoint = "ridge_warp_32")]
	public static extern float RidgeWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);

	[DllImport("RustNative", EntryPoint = "sharp_warp_32")]
	public static extern float SharpWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);

	[DllImport("RustNative", EntryPoint = "jordan_32")]
	public static extern float Jordan(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp, float damp, float damp_scale);
}


public static class Noise
{
	public const float MIN = -1000000f;

	public const float MAX = 1000000f;

	public static float SimplexSigned(float x)
	{
		return NativeNoise.Simplex1D(x);
	}

	public static float SimplexSigned(float x, float y)
	{
		return NativeNoise.Simplex2D(x, y);
	}

	public static float SimplexUnsigned(float x)
	{
		return NativeNoise.Simplex1D(x) * 0.5f + 1f;
	}

	public static float SimplexUnsigned(float x, float y)
	{
		return NativeNoise.Simplex2D(x, y) * 0.5f + 1f;
	}

	public static float Turbulence(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.Turbulence(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float Billow(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.Billow(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float Ridge(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.Ridge(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float Sharp(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.Sharp(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float TurbulenceIQ(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.TurbulenceIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float BillowIQ(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.BillowIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float RidgeIQ(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.RidgeIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float SharpIQ(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.SharpIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float TurbulenceWarp(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f, float warp = 0.25f)
	{
		return NativeNoise.TurbulenceWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
	}

	public static float BillowWarp(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f, float warp = 0.25f)
	{
		return NativeNoise.BillowWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
	}

	public static float RidgeWarp(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f, float warp = 0.25f)
	{
		return NativeNoise.RidgeWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
	}

	public static float SharpWarp(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f, float warp = 0.25f)
	{
		return NativeNoise.SharpWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
	}

	public static float Jordan(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f, float warp = 1f, float damp = 1f, float damp_scale = 1f)
	{
		return NativeNoise.Jordan(x, y, octaves, frequency, amplitude, lacunarity, gain, warp, damp, damp_scale);
	}
}


using System;

[Serializable]
public struct NoiseParameters
{
	public int Octaves;

	public float Frequency;

	public float Amplitude;

	public float Offset;

	public NoiseParameters(int octaves, float frequency, float amplitude, float offset)
	{
		Octaves = octaves;
		Frequency = frequency;
		Amplitude = amplitude;
		Offset = offset;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class PathList
{
	public enum Side
	{
		Both,
		Left,
		Right,
		Any
	}

	public enum Placement
	{
		Center,
		Side
	}

	public enum Alignment
	{
		None,
		Neighbor,
		Forward,
		Inward
	}

	[Serializable]
	public class BasicObject
	{
		public string Folder;

		public SpawnFilter Filter;

		public Placement Placement;

		public bool AlignToNormal = true;

		public bool HeightToTerrain = true;

		public float Offset;
	}

	[Serializable]
	public class SideObject
	{
		public string Folder;

		public SpawnFilter Filter;

		public Side Side;

		public Alignment Alignment;

		public float Density = 1f;

		public float Distance = 25f;

		public float Offset = 2f;
	}

	[Serializable]
	public class PathObject
	{
		public string Folder;

		public SpawnFilter Filter;

		public Alignment Alignment;

		public float Density = 1f;

		public float Distance = 5f;

		public float Dithering = 5f;
	}

	[Serializable]
	public class BridgeObject
	{
		public string Folder;

		public float Distance = 10f;
	}

	public class MeshObject
	{
		public Vector3 Position;

		public Mesh[] Meshes;

		public MeshObject(Vector3 meshPivot, MeshData[] meshData)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Expected O, but got Unknown
			//IL_0031: Expected O, but got Unknown
			Position = meshPivot;
			Meshes = (Mesh[])(object)new Mesh[meshData.Length];
			for (int i = 0; i < Meshes.Length; i++)
			{
				MeshData obj = meshData[i];
				Mesh[] meshes = Meshes;
				int num = i;
				Mesh val = new Mesh();
				Mesh val2 = val;
				meshes[num] = val;
				Mesh mesh = val2;
				obj.Apply(mesh);
			}
		}
	}

	private struct WeldVertex : IEquatable<WeldVertex>
	{
		private const float EPSILON = 0.001f;

		private const float INV_EPSILON = 999.99994f;

		public float x;

		public float y;

		public float z;

		public float alwaysUnderwater;

		public float topSurface;

		public override bool Equals(object other)
		{
			if (other is WeldVertex)
			{
				return Equals((WeldVertex)other);
			}
			return false;
		}

		public bool Equals(WeldVertex other)
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			if (Vector3.Distance(new Vector3(x, y, z), new Vector3(other.x, other.y, other.z)) < 0.001f && alwaysUnderwater == other.alwaysUnderwater)
			{
				return topSurface == other.topSurface;
			}
			return false;
		}

		public override int GetHashCode()
		{
			int value = Mathf.RoundToInt(x * 999.99994f);
			int value2 = Mathf.RoundToInt(y * 999.99994f);
			int value3 = Mathf.RoundToInt(z * 999.99994f);
			return HashCode.Combine(value, value2, value3, alwaysUnderwater, topSurface);
		}
	}

	private static Quaternion rot90 = Quaternion.Euler(0f, 90f, 0f);

	private static Quaternion rot180 = Quaternion.Euler(0f, 180f, 0f);

	private static Quaternion rot270 = Quaternion.Euler(0f, 270f, 0f);

	public const float EndWidthScale = 3f;

	public const float EndScaleDistance = 100f;

	public const float LengthWidthScale = 8f;

	public const float LengthDepthScale = 3f;

	public const float LengthScaleDistance = 1000f;

	public string Name;

	public PathInterpolator Path;

	public bool Spline;

	public bool Start;

	public bool End;

	public float Width;

	public float InnerPadding;

	public float OuterPadding;

	public float InnerFade;

	public float OuterFade;

	public float RandomScale;

	public float MeshOffset;

	public float TerrainOffset;

	public int Topology;

	public int Splat;

	public int Hierarchy;

	public PathFinder.Node ProcgenStartNode;

	public PathFinder.Node ProcgenEndNode;

	public const float StepSize = 1f;

	private static float[] placements = new float[3] { 0f, -1f, 1f };

	public PathList(string name, Vector3[] points)
	{
		Name = name;
		Path = new PathInterpolator(points);
	}

	private void SpawnObjectsNeighborAligned(ref uint seed, Prefab[] prefabs, List<Vector3> positions, SpawnFilter filter = null)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (positions.Count < 2)
		{
			return;
		}
		List<Prefab> list = Pool.Get<List<Prefab>>();
		for (int i = 0; i < positions.Count; i++)
		{
			int index = Mathf.Max(i - 1, 0);
			int index2 = Mathf.Min(i + 1, positions.Count - 1);
			Vector3 position = positions[i];
			Quaternion rotation = Quaternion.LookRotation(Vector3Ex.XZ3D(positions[index2] - positions[index]));
			SpawnObject(ref seed, prefabs, position, rotation, list, out var spawned, positions.Count, i, filter);
			if (spawned != null)
			{
				list.Add(spawned);
			}
		}
		Pool.FreeUnmanaged<Prefab>(ref list);
	}

	private bool SpawnObject(ref uint seed, Prefab[] prefabs, Vector3 position, Quaternion rotation, SpawnFilter filter = null)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		Prefab random = prefabs.GetRandom(ref seed);
		Vector3 pos = position;
		Quaternion rot = rotation;
		Vector3 scale = random.Object.transform.localScale;
		random.ApplyDecorComponents(ref pos, ref rot, ref scale);
		if (!random.ApplyTerrainAnchors(ref pos, rot, scale, filter))
		{
			return false;
		}
		World.AddPrefab(Name, random, pos, rot, scale);
		return true;
	}

	private bool SpawnObject(ref uint seed, Prefab[] prefabs, Vector3 position, Quaternion rotation, List<Prefab> previousSpawns, out Prefab spawned, int pathLength, int index, SpawnFilter filter = null)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		spawned = null;
		Prefab replacement = prefabs.GetRandom(ref seed);
		replacement.ApplySequenceReplacement(previousSpawns, ref replacement, prefabs, pathLength, index, position);
		Vector3 pos = position;
		Quaternion rot = rotation;
		Vector3 scale = replacement.Object.transform.localScale;
		replacement.ApplyDecorComponents(ref pos, ref rot, ref scale);
		if (!replacement.ApplyTerrainAnchors(ref pos, rot, scale, filter))
		{
			return false;
		}
		World.AddPrefab(Name, replacement, pos, rot, scale);
		spawned = replacement;
		return true;
	}

	private bool CheckObjects(Prefab[] prefabs, Vector3 position, Quaternion rotation, SpawnFilter filter = null)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		foreach (Prefab obj in prefabs)
		{
			Vector3 pos = position;
			Vector3 localScale = obj.Object.transform.localScale;
			if (!obj.ApplyTerrainAnchors(ref pos, rotation, localScale, filter))
			{
				return false;
			}
		}
		return true;
	}

	private void SpawnObject(ref uint seed, Prefab[] prefabs, Vector3 pos, Vector3 dir, BasicObject obj)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		if (!obj.AlignToNormal)
		{
			Vector3 val = Vector3Ex.XZ3D(dir);
			dir = ((Vector3)(ref val)).normalized;
		}
		SpawnFilter filter = obj.Filter;
		Vector3 val2 = (Width * 0.5f + obj.Offset) * (rot90 * dir);
		for (int i = 0; i < placements.Length; i++)
		{
			if ((obj.Placement == Placement.Center && i != 0) || (obj.Placement == Placement.Side && i == 0))
			{
				continue;
			}
			Vector3 val3 = pos + placements[i] * val2;
			if (obj.HeightToTerrain)
			{
				val3.y = TerrainMeta.HeightMap.GetHeight(val3);
			}
			if (filter.Test(val3))
			{
				Quaternion rotation = ((i == 2) ? Quaternion.LookRotation(rot180 * dir) : Quaternion.LookRotation(dir));
				if (SpawnObject(ref seed, prefabs, val3, rotation, filter))
				{
					break;
				}
			}
		}
	}

	private bool CheckObjects(Prefab[] prefabs, Vector3 pos, Vector3 dir, BasicObject obj)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		if (!obj.AlignToNormal)
		{
			Vector3 val = Vector3Ex.XZ3D(dir);
			dir = ((Vector3)(ref val)).normalized;
		}
		SpawnFilter filter = obj.Filter;
		Vector3 val2 = (Width * 0.5f + obj.Offset) * (rot90 * dir);
		for (int i = 0; i < placements.Length; i++)
		{
			if ((obj.Placement == Placement.Center && i != 0) || (obj.Placement == Placement.Side && i == 0))
			{
				continue;
			}
			Vector3 val3 = pos + placements[i] * val2;
			if (obj.HeightToTerrain)
			{
				val3.y = TerrainMeta.HeightMap.GetHeight(val3);
			}
			if (filter.Test(val3))
			{
				Quaternion rotation = ((i == 2) ? Quaternion.LookRotation(rot180 * dir) : Quaternion.LookRotation(dir));
				if (CheckObjects(prefabs, val3, rotation, filter))
				{
					return true;
				}
			}
		}
		return false;
	}

	public void SpawnSide(ref uint seed, SideObject obj)
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		if (string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError((object)("Empty decor folder: " + obj.Folder));
			return;
		}
		Side side = obj.Side;
		SpawnFilter filter = obj.Filter;
		float density = obj.Density;
		float distance = obj.Distance;
		float num = Width * 0.5f + obj.Offset;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		float[] array2 = new float[2]
		{
			0f - num,
			num
		};
		int num2 = 0;
		Vector3 val = Path.GetStartPoint();
		List<Vector3> list = new List<Vector3>();
		float num3 = distance * 0.25f;
		float num4 = distance * 0.5f;
		float num5 = Path.StartOffset + num4;
		float num6 = Path.Length - Path.EndOffset - num4;
		for (float num7 = num5; num7 <= num6; num7 += num3)
		{
			Vector3 val2 = (Spline ? Path.GetPointCubicHermite(num7) : Path.GetPoint(num7));
			Vector3 val3 = val2 - val;
			if (((Vector3)(ref val3)).magnitude < distance)
			{
				continue;
			}
			Vector3 tangent = Path.GetTangent(num7);
			Vector3 val4 = rot90 * tangent;
			for (int i = 0; i < array2.Length; i++)
			{
				int num8 = (num2 + i) % array2.Length;
				if ((side == Side.Left && num8 != 0) || (side == Side.Right && num8 != 1))
				{
					continue;
				}
				float num9 = array2[num8];
				Vector3 val5 = val2;
				val5.x += val4.x * num9;
				val5.z += val4.z * num9;
				float normX = TerrainMeta.NormalizeX(val5.x);
				float normZ = TerrainMeta.NormalizeZ(val5.z);
				if (filter.GetFactor(normX, normZ) < SeedRandom.Value(ref seed))
				{
					continue;
				}
				if (density >= SeedRandom.Value(ref seed))
				{
					val5.y = heightMap.GetHeight(normX, normZ);
					if (obj.Alignment == Alignment.None)
					{
						if (!SpawnObject(ref seed, array, val5, Quaternion.LookRotation(Vector3.zero), filter))
						{
							continue;
						}
					}
					else if (obj.Alignment == Alignment.Forward)
					{
						if (!SpawnObject(ref seed, array, val5, Quaternion.LookRotation(tangent * num9), filter))
						{
							continue;
						}
					}
					else if (obj.Alignment == Alignment.Inward)
					{
						if (!SpawnObject(ref seed, array, val5, Quaternion.LookRotation(tangent * num9) * rot270, filter))
						{
							continue;
						}
					}
					else
					{
						list.Add(val5);
					}
				}
				num2 = num8;
				val = val2;
				if (side == Side.Any)
				{
					break;
				}
			}
		}
		if (list.Count > 0)
		{
			SpawnObjectsNeighborAligned(ref seed, array, list, filter);
		}
	}

	public void SpawnAlong(ref uint seed, PathObject obj)
	{
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		if (string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError((object)("Empty decor folder: " + obj.Folder));
			return;
		}
		SpawnFilter filter = obj.Filter;
		float density = obj.Density;
		float distance = obj.Distance;
		float dithering = obj.Dithering;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Vector3 val = Path.GetStartPoint();
		List<Vector3> list = new List<Vector3>();
		float num = distance * 0.25f;
		float num2 = distance * 0.5f;
		float num3 = Path.StartOffset + num2;
		float num4 = Path.Length - Path.EndOffset - num2;
		for (float num5 = num3; num5 <= num4; num5 += num)
		{
			Vector3 val2 = (Spline ? Path.GetPointCubicHermite(num5) : Path.GetPoint(num5));
			Vector3 val3 = val2 - val;
			if (((Vector3)(ref val3)).magnitude < distance)
			{
				continue;
			}
			Vector3 tangent = Path.GetTangent(num5);
			Vector3 val4 = rot90 * tangent;
			Vector3 val5 = val2;
			val5.x += SeedRandom.Range(ref seed, 0f - dithering, dithering);
			val5.z += SeedRandom.Range(ref seed, 0f - dithering, dithering);
			float normX = TerrainMeta.NormalizeX(val5.x);
			float normZ = TerrainMeta.NormalizeZ(val5.z);
			if (filter.GetFactor(normX, normZ) < SeedRandom.Value(ref seed))
			{
				continue;
			}
			if (density >= SeedRandom.Value(ref seed))
			{
				val5.y = heightMap.GetHeight(normX, normZ);
				if (obj.Alignment == Alignment.None)
				{
					if (!SpawnObject(ref seed, array, val5, Quaternion.identity, filter))
					{
						continue;
					}
				}
				else if (obj.Alignment == Alignment.Forward)
				{
					if (!SpawnObject(ref seed, array, val5, Quaternion.LookRotation(tangent), filter))
					{
						continue;
					}
				}
				else if (obj.Alignment == Alignment.Inward)
				{
					if (!SpawnObject(ref seed, array, val5, Quaternion.LookRotation(val4), filter))
					{
						continue;
					}
				}
				else
				{
					list.Add(val5);
				}
			}
			val = val2;
		}
		if (list.Count > 0)
		{
			SpawnObjectsNeighborAligned(ref seed, array, list, filter);
		}
	}

	public void SpawnBridge(ref uint seed, BridgeObject obj)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		if (string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError((object)("Empty decor folder: " + obj.Folder));
			return;
		}
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 val = Path.GetEndPoint() - startPoint;
		float magnitude = ((Vector3)(ref val)).magnitude;
		Vector3 val2 = val / magnitude;
		float num = magnitude / obj.Distance;
		int num2 = Mathf.RoundToInt(num);
		float num3 = 0.5f * (num - (float)num2);
		Vector3 val3 = obj.Distance * val2;
		Vector3 val4 = startPoint + (0.5f + num3) * val3;
		Quaternion rotation = Quaternion.LookRotation(val2);
		for (int i = 0; i < num2; i++)
		{
			float num4 = WaterLevel.GetWaterOrTerrainSurface(val4, waves: false, volumes: false) - 1f;
			if (val4.y > num4)
			{
				SpawnObject(ref seed, array, val4, rotation);
			}
			val4 += val3;
		}
	}

	public void SpawnStart(ref uint seed, BasicObject obj)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (Start && !string.IsNullOrEmpty(obj.Folder))
		{
			Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
			if (array == null || array.Length == 0)
			{
				Debug.LogError((object)("Empty decor folder: " + obj.Folder));
				return;
			}
			Vector3 startPoint = Path.GetStartPoint();
			Vector3 startTangent = Path.GetStartTangent();
			SpawnObject(ref seed, array, startPoint, startTangent, obj);
		}
	}

	public void SpawnEnd(ref uint seed, BasicObject obj)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		if (End && !string.IsNullOrEmpty(obj.Folder))
		{
			Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
			if (array == null || array.Length == 0)
			{
				Debug.LogError((object)("Empty decor folder: " + obj.Folder));
				return;
			}
			Vector3 endPoint = Path.GetEndPoint();
			Vector3 dir = -Path.GetEndTangent();
			SpawnObject(ref seed, array, endPoint, dir, obj);
		}
	}

	public void TrimStart(BasicObject obj)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		if (!Start || string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError((object)("Empty decor folder: " + obj.Folder));
			return;
		}
		Vector3[] points = Path.Points;
		Vector3[] tangents = Path.Tangents;
		int num = points.Length / 4;
		for (int i = 0; i < num; i++)
		{
			Vector3 pos = points[Path.MinIndex + i];
			Vector3 dir = tangents[Path.MinIndex + i];
			if (CheckObjects(array, pos, dir, obj))
			{
				Path.MinIndex += i;
				break;
			}
		}
	}

	public void TrimEnd(BasicObject obj)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		if (!End || string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError((object)("Empty decor folder: " + obj.Folder));
			return;
		}
		Vector3[] points = Path.Points;
		Vector3[] tangents = Path.Tangents;
		int num = points.Length / 4;
		for (int i = 0; i < num; i++)
		{
			Vector3 pos = points[Path.MaxIndex - i];
			Vector3 dir = -tangents[Path.MaxIndex - i];
			if (CheckObjects(array, pos, dir, obj))
			{
				Path.MaxIndex -= i;
				break;
			}
		}
	}

	public void TrimTopology(int topology)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] points = Path.Points;
		int num = points.Length / 4;
		for (int i = 0; i < num; i++)
		{
			Vector3 worldPos = points[Path.MinIndex + i];
			if (!TerrainMeta.TopologyMap.GetTopology(worldPos, topology))
			{
				Path.MinIndex += i;
				break;
			}
		}
		for (int j = 0; j < num; j++)
		{
			Vector3 worldPos2 = points[Path.MaxIndex - j];
			if (!TerrainMeta.TopologyMap.GetTopology(worldPos2, topology))
			{
				Path.MaxIndex -= j;
				break;
			}
		}
	}

	public void ResetTrims()
	{
		Path.MinIndex = Path.DefaultMinIndex;
		Path.MaxIndex = Path.DefaultMaxIndex;
	}

	public void AdjustTerrainHeight(float intensity = 1f, float fade = 1f, bool scaleWidthWithLength = false)
	{
		AdjustTerrainHeight((float xn, float zn) => intensity, (float xn, float zn) => fade, scaleWidthWithLength);
	}

	public void AdjustTerrainHeight(Func<float, float, float> intensity, Func<float, float, float> fade, bool scaleWidthWithLength = false)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_035f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0361: Unknown result type (might be due to invalid IL or missing references)
		//IL_0375: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_037d: Unknown result type (might be due to invalid IL or missing references)
		//IL_037f: Unknown result type (might be due to invalid IL or missing references)
		//IL_038f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_0399: Unknown result type (might be due to invalid IL or missing references)
		//IL_039b: Unknown result type (might be due to invalid IL or missing references)
		//IL_039d: Unknown result type (might be due to invalid IL or missing references)
		//IL_039f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		_ = TerrainMeta.TopologyMap;
		float num = 1f;
		float randomScale = RandomScale;
		float outerPadding = OuterPadding;
		float innerPadding = InnerPadding;
		float outerFade = OuterFade;
		float innerFade = InnerFade;
		float terrainOffset = TerrainOffset;
		float num2 = Width * 0.5f;
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 endPoint = Path.GetEndPoint();
		Vector3 startTangent = Path.GetStartTangent();
		Vector3 val = Vector3Ex.XZ3D(startTangent);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = rot90 * normalized;
		Vector3 val3 = startPoint;
		Line prev_line = new Line(startPoint, startPoint + startTangent * num);
		Vector3 val4 = startPoint - val2 * (num2 + outerPadding + outerFade);
		Vector3 val5 = startPoint + val2 * (num2 + outerPadding + outerFade);
		Vector3 val6 = val3;
		Vector3 val7 = startTangent;
		Line cur_line = prev_line;
		Vector3 val8 = val4;
		Vector3 val9 = val5;
		float num3 = Path.Length + num;
		for (float d = 0f; d < num3; d += num)
		{
			Vector3 val10 = (Spline ? Path.GetPointCubicHermite(d + num) : Path.GetPoint(d + num));
			Vector3 tangent = Path.GetTangent(d + num);
			Line next_line = new Line(val10, val10 + tangent * num);
			float opacity = 1f;
			float radius = GetRadius(d, Path.Length, num2, randomScale, scaleWidthWithLength);
			float depth = GetDepth(d, Path.Length, terrainOffset, randomScale, scaleWidthWithLength);
			float offset01 = depth * TerrainMeta.OneOverSize.y;
			if (!Path.Circular)
			{
				float num4 = Vector3Ex.Magnitude2D(startPoint - val6);
				float num5 = Vector3Ex.Magnitude2D(endPoint - val6);
				opacity = Mathf.InverseLerp(0f, num2, Mathf.Min(num4, num5));
			}
			val = Vector3Ex.XZ3D(val7);
			normalized = ((Vector3)(ref val)).normalized;
			val2 = rot90 * normalized;
			val8 = val6 - val2 * (radius + outerPadding + outerFade);
			val9 = val6 + val2 * (radius + outerPadding + outerFade);
			float yn = TerrainMeta.NormalizeY((val6.y + val3.y) * 0.5f);
			heightmap.ForEach(val4, val5, val8, val9, delegate(int x, int z)
			{
				//IL_002c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0031: Unknown result type (might be due to invalid IL or missing references)
				//IL_0036: Unknown result type (might be due to invalid IL or missing references)
				//IL_0042: Unknown result type (might be due to invalid IL or missing references)
				//IL_0043: Unknown result type (might be due to invalid IL or missing references)
				//IL_0048: Unknown result type (might be due to invalid IL or missing references)
				//IL_0054: Unknown result type (might be due to invalid IL or missing references)
				//IL_0055: Unknown result type (might be due to invalid IL or missing references)
				//IL_005a: Unknown result type (might be due to invalid IL or missing references)
				//IL_0062: Unknown result type (might be due to invalid IL or missing references)
				//IL_0063: Unknown result type (might be due to invalid IL or missing references)
				//IL_0068: Unknown result type (might be due to invalid IL or missing references)
				//IL_006a: Unknown result type (might be due to invalid IL or missing references)
				//IL_006b: Unknown result type (might be due to invalid IL or missing references)
				//IL_006c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0078: Unknown result type (might be due to invalid IL or missing references)
				//IL_0079: Unknown result type (might be due to invalid IL or missing references)
				//IL_007b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0087: Unknown result type (might be due to invalid IL or missing references)
				//IL_0088: Unknown result type (might be due to invalid IL or missing references)
				//IL_008a: Unknown result type (might be due to invalid IL or missing references)
				//IL_009a: Unknown result type (might be due to invalid IL or missing references)
				//IL_009c: Unknown result type (might be due to invalid IL or missing references)
				//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
				//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
				//IL_01af: Unknown result type (might be due to invalid IL or missing references)
				float num6 = heightmap.Coordinate(x);
				float num7 = heightmap.Coordinate(z);
				Vector3 val11 = TerrainMeta.Denormalize(new Vector3(num6, yn, num7));
				Vector3 val12 = ((Line)(ref prev_line)).ClosestPoint2D(val11);
				Vector3 val13 = ((Line)(ref cur_line)).ClosestPoint2D(val11);
				Vector3 val14 = ((Line)(ref next_line)).ClosestPoint2D(val11);
				float num8 = Vector3Ex.Magnitude2D(val11 - val12);
				float num9 = Vector3Ex.Magnitude2D(val11 - val13);
				float num10 = Vector3Ex.Magnitude2D(val11 - val14);
				float num11 = num9;
				Vector3 val15 = val13;
				if (!(num9 <= num8) || !(num9 <= num10))
				{
					if (num8 <= num10)
					{
						num11 = num8;
						val15 = val12;
					}
					else
					{
						num11 = num10;
						val15 = val14;
					}
				}
				float num12 = Mathf.InverseLerp(radius + outerPadding + outerFade * fade(num6, num7), radius + outerPadding, num11);
				float num13 = intensity(num6, num7) * opacity * num12;
				if (num13 > 0f)
				{
					float num14 = (scaleWidthWithLength ? Mathf.Lerp(0.3f, 1f, d / 1000f) : 1f);
					float num15 = Mathf.InverseLerp(radius - innerPadding * num14, radius - innerPadding * num14 - innerFade * num14, num11);
					float num16 = TerrainMeta.NormalizeY(val15.y);
					float num17 = Mathf.SmoothStep(0f, offset01, num15);
					heightmap.SetHeight(x, z, num16 + num17, num13);
				}
			});
			val3 = val6;
			val4 = val8;
			val5 = val9;
			prev_line = cur_line;
			val6 = val10;
			val7 = tangent;
			cur_line = next_line;
		}
	}

	public void AdjustTerrainTexture(bool scaleWidthWithLength = false)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		if (Splat == 0)
		{
			return;
		}
		TerrainSplatMap splatmap = TerrainMeta.SplatMap;
		float num = 1f;
		float randomScale = RandomScale;
		float outerPadding = OuterPadding;
		float innerPadding = InnerPadding;
		float num2 = Width * 0.5f;
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 endPoint = Path.GetEndPoint();
		Vector3 startTangent = Path.GetStartTangent();
		Vector3 val = Vector3Ex.XZ3D(startTangent);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = rot90 * normalized;
		Vector3 v = startPoint - val2 * (num2 + outerPadding);
		Vector3 v2 = startPoint + val2 * (num2 + outerPadding);
		float num3 = Path.Length + num;
		for (float num4 = 0f; num4 < num3; num4 += num)
		{
			Vector3 val3 = (Spline ? Path.GetPointCubicHermite(num4) : Path.GetPoint(num4));
			float opacity = 1f;
			float radius = GetRadius(num4, Path.Length, num2, randomScale, scaleWidthWithLength);
			if (!Path.Circular)
			{
				float num5 = Vector3Ex.Magnitude2D(startPoint - val3);
				float num6 = Vector3Ex.Magnitude2D(endPoint - val3);
				opacity = Mathf.InverseLerp(0f, num2, Mathf.Min(num5, num6));
			}
			startTangent = Path.GetTangent(num4);
			val = Vector3Ex.XZ3D(startTangent);
			normalized = ((Vector3)(ref val)).normalized;
			val2 = rot90 * normalized;
			Ray ray = new Ray(val3, startTangent);
			Vector3 val4 = val3 - val2 * (radius + outerPadding);
			Vector3 val5 = val3 + val2 * (radius + outerPadding);
			float yn = TerrainMeta.NormalizeY(val3.y);
			splatmap.ForEach(v, v2, val4, val5, delegate(int x, int z)
			{
				//IL_002a: Unknown result type (might be due to invalid IL or missing references)
				//IL_002f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0034: Unknown result type (might be due to invalid IL or missing references)
				//IL_0036: Unknown result type (might be due to invalid IL or missing references)
				//IL_003b: Unknown result type (might be due to invalid IL or missing references)
				//IL_003c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0041: Unknown result type (might be due to invalid IL or missing references)
				//IL_0042: Unknown result type (might be due to invalid IL or missing references)
				//IL_0043: Unknown result type (might be due to invalid IL or missing references)
				//IL_0044: Unknown result type (might be due to invalid IL or missing references)
				float num7 = splatmap.Coordinate(x);
				float num8 = splatmap.Coordinate(z);
				Vector3 val6 = TerrainMeta.Denormalize(new Vector3(num7, yn, num8));
				Vector3 val7 = ray.ClosestPoint(val6);
				float num9 = Vector3Ex.Magnitude2D(val6 - val7);
				float num10 = Mathf.InverseLerp(radius + outerPadding, radius - innerPadding, num9);
				splatmap.SetSplat(x, z, Splat, num10 * opacity);
			});
			v = val4;
			v2 = val5;
		}
	}

	public void AdjustTerrainWaterFlow(bool scaleWidthWithLength = false)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		TerrainWaterFlowMap flowMap = TerrainMeta.WaterFlowMap;
		float num = 1f;
		float randomScale = RandomScale;
		float outerPadding = OuterPadding;
		float num2 = Width * 0.5f;
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 dir = Path.GetStartTangent();
		Vector3 val = Vector3Ex.XZ3D(dir);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = rot90 * normalized;
		Vector3 v = startPoint - val2 * (num2 + outerPadding);
		Vector3 v2 = startPoint + val2 * (num2 + outerPadding);
		float num3 = Path.Length + num;
		for (float num4 = 0f; num4 < num3; num4 += num)
		{
			Vector3 val3 = (Spline ? Path.GetPointCubicHermite(num4) : Path.GetPoint(num4));
			float radius = GetRadius(num4, Path.Length, num2, randomScale, scaleWidthWithLength);
			dir = Path.GetTangent(num4);
			val = Vector3Ex.XZ3D(dir);
			normalized = ((Vector3)(ref val)).normalized;
			val2 = rot90 * normalized;
			Vector3 val4 = val3 - val2 * (radius + outerPadding);
			Vector3 val5 = val3 + val2 * (radius + outerPadding);
			flowMap.ForEach(v, v2, val4, val5, delegate(int x, int z)
			{
				//IL_0023: Unknown result type (might be due to invalid IL or missing references)
				float normX = flowMap.Coordinate(x);
				float normZ = flowMap.Coordinate(z);
				flowMap.SetFlowDirection(normX, normZ, dir);
			});
			v = val4;
			v2 = val5;
		}
	}

	public void AdjustTerrainTopology(bool scaleWidthWithLength = false)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		if (Topology == 0)
		{
			return;
		}
		TerrainTopologyMap topomap = TerrainMeta.TopologyMap;
		float num = 1f;
		float randomScale = RandomScale;
		float outerPadding = OuterPadding;
		float innerPadding = InnerPadding;
		float num2 = Width * 0.5f;
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 endPoint = Path.GetEndPoint();
		Vector3 startTangent = Path.GetStartTangent();
		Vector3 val = Vector3Ex.XZ3D(startTangent);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = rot90 * normalized;
		Vector3 v = startPoint - val2 * (num2 + outerPadding);
		Vector3 v2 = startPoint + val2 * (num2 + outerPadding);
		float num3 = Path.Length + num;
		for (float num4 = 0f; num4 < num3; num4 += num)
		{
			Vector3 val3 = (Spline ? Path.GetPointCubicHermite(num4) : Path.GetPoint(num4));
			float opacity = 1f;
			float radius = GetRadius(num4, Path.Length, num2, randomScale, scaleWidthWithLength);
			if (!Path.Circular)
			{
				float num5 = Vector3Ex.Magnitude2D(startPoint - val3);
				float num6 = Vector3Ex.Magnitude2D(endPoint - val3);
				opacity = Mathf.InverseLerp(0f, num2, Mathf.Min(num5, num6));
			}
			startTangent = Path.GetTangent(num4);
			val = Vector3Ex.XZ3D(startTangent);
			normalized = ((Vector3)(ref val)).normalized;
			val2 = rot90 * normalized;
			Ray ray = new Ray(val3, startTangent);
			Vector3 val4 = val3 - val2 * (radius + outerPadding);
			Vector3 val5 = val3 + val2 * (radius + outerPadding);
			float yn = TerrainMeta.NormalizeY(val3.y);
			topomap.ForEach(v, v2, val4, val5, delegate(int x, int z)
			{
				//IL_002a: Unknown result type (might be due to invalid IL or missing references)
				//IL_002f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0034: Unknown result type (might be due to invalid IL or missing references)
				//IL_0036: Unknown result type (might be due to invalid IL or missing references)
				//IL_003b: Unknown result type (might be due to invalid IL or missing references)
				//IL_003c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0041: Unknown result type (might be due to invalid IL or missing references)
				//IL_0042: Unknown result type (might be due to invalid IL or missing references)
				//IL_0043: Unknown result type (might be due to invalid IL or missing references)
				//IL_0044: Unknown result type (might be due to invalid IL or missing references)
				float num7 = topomap.Coordinate(x);
				float num8 = topomap.Coordinate(z);
				Vector3 val6 = TerrainMeta.Denormalize(new Vector3(num7, yn, num8));
				Vector3 val7 = ray.ClosestPoint(val6);
				float num9 = Vector3Ex.Magnitude2D(val6 - val7);
				if (Mathf.InverseLerp(radius + outerPadding, radius - innerPadding, num9) * opacity > 0.3f)
				{
					topomap.AddTopology(x, z, Topology);
				}
			});
			v = val4;
			v2 = val5;
		}
	}

	public void AdjustPlacementMap(float width)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		TerrainPlacementMap placementmap = TerrainMeta.PlacementMap;
		float num = 1f;
		float radius = width * 0.5f;
		Vector3 startPoint = Path.GetStartPoint();
		Path.GetEndPoint();
		Vector3 startTangent = Path.GetStartTangent();
		Vector3 val = Vector3Ex.XZ3D(startTangent);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = rot90 * normalized;
		Vector3 v = startPoint - val2 * radius;
		Vector3 v2 = startPoint + val2 * radius;
		float num2 = Path.Length + num;
		for (float num3 = 0f; num3 < num2; num3 += num)
		{
			Vector3 val3 = (Spline ? Path.GetPointCubicHermite(num3) : Path.GetPoint(num3));
			startTangent = Path.GetTangent(num3);
			val = Vector3Ex.XZ3D(startTangent);
			normalized = ((Vector3)(ref val)).normalized;
			val2 = rot90 * normalized;
			Ray ray = new Ray(val3, startTangent);
			Vector3 val4 = val3 - val2 * radius;
			Vector3 val5 = val3 + val2 * radius;
			float yn = TerrainMeta.NormalizeY(val3.y);
			placementmap.ForEach(v, v2, val4, val5, delegate(int x, int z)
			{
				//IL_002a: Unknown result type (might be due to invalid IL or missing references)
				//IL_002f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0034: Unknown result type (might be due to invalid IL or missing references)
				//IL_0036: Unknown result type (might be due to invalid IL or missing references)
				//IL_003b: Unknown result type (might be due to invalid IL or missing references)
				//IL_003c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0041: Unknown result type (might be due to invalid IL or missing references)
				//IL_0042: Unknown result type (might be due to invalid IL or missing references)
				//IL_0043: Unknown result type (might be due to invalid IL or missing references)
				//IL_0044: Unknown result type (might be due to invalid IL or missing references)
				float num4 = placementmap.Coordinate(x);
				float num5 = placementmap.Coordinate(z);
				Vector3 val6 = TerrainMeta.Denormalize(new Vector3(num4, yn, num5));
				Vector3 val7 = ray.ClosestPoint(val6);
				if (Vector3Ex.Magnitude2D(val6 - val7) <= radius)
				{
					placementmap.SetBlocked(x, z);
				}
			});
			v = val4;
			v2 = val5;
		}
	}

	public List<MeshObject> CreateMesh(Mesh[] meshes, float normalSmoothing, bool snapToTerrain, bool snapStartToTerrain, bool snapEndToTerrain, bool scaleWidthWithLength = false, bool topAligned = false, int roundVertices = 0)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0301: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_030c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0338: Unknown result type (might be due to invalid IL or missing references)
		//IL_0353: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_0357: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_0362: Unknown result type (might be due to invalid IL or missing references)
		//IL_0367: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_0385: Unknown result type (might be due to invalid IL or missing references)
		//IL_0387: Unknown result type (might be due to invalid IL or missing references)
		//IL_0389: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_0399: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_041b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0429: Unknown result type (might be due to invalid IL or missing references)
		//IL_0437: Unknown result type (might be due to invalid IL or missing references)
		//IL_0445: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ff: Unknown result type (might be due to invalid IL or missing references)
		MeshCache.Data[] array = new MeshCache.Data[meshes.Length];
		MeshData[] array2 = new MeshData[meshes.Length];
		for (int i = 0; i < meshes.Length; i++)
		{
			array[i] = MeshCache.Get(meshes[i]);
			array2[i] = new MeshData();
		}
		MeshData[] array3 = array2;
		for (int j = 0; j < array3.Length; j++)
		{
			array3[j].AllocMinimal();
		}
		Bounds bounds = meshes[^1].bounds;
		Vector3 min = ((Bounds)(ref bounds)).min;
		Vector3 size = ((Bounds)(ref bounds)).size;
		float num = Width / ((Bounds)(ref bounds)).size.x;
		List<MeshObject> list = new List<MeshObject>();
		int num2 = (int)(Path.Length / (num * ((Bounds)(ref bounds)).size.z));
		int num3 = 5;
		float num4 = Path.Length / (float)num2;
		float randomScale = RandomScale;
		float meshOffset = MeshOffset;
		float baseRadius = Width * 0.5f;
		_ = array[0].vertices.Length;
		_ = array[0].triangles.Length;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Vector3 val12 = default(Vector3);
		for (int k = 0; k < num2; k += num3)
		{
			float distance = (float)k * num4 + 0.5f * (float)num3 * num4;
			Vector3 val = (Spline ? Path.GetPointCubicHermite(distance) : Path.GetPoint(distance));
			for (int l = 0; l < num3 && k + l < num2; l++)
			{
				float num5 = (float)(k + l) * num4;
				for (int m = 0; m < meshes.Length; m++)
				{
					MeshCache.Data data = array[m];
					MeshData meshData = array2[m];
					int count = meshData.vertices.Count;
					for (int n = 0; n < data.vertices.Length; n++)
					{
						Vector2 item = data.uv[n];
						Vector3 val2 = data.vertices[n];
						Vector3 val3 = data.normals[n];
						Vector4 val4 = data.tangents[n];
						float num6 = (val2.x - min.x) / size.x;
						float num7 = val2.y - min.y;
						if (topAligned)
						{
							num7 -= size.y;
						}
						float num8 = (val2.z - min.z) / size.z;
						float num9 = num5 + num8 * num4;
						Vector3 val5 = (Spline ? Path.GetPointCubicHermite(num9) : Path.GetPoint(num9));
						Vector3 tangent = Path.GetTangent(num9);
						Vector3 val6 = Vector3Ex.XZ3D(tangent);
						Vector3 normalized = ((Vector3)(ref val6)).normalized;
						Vector3 val7 = rot90 * normalized;
						Vector3 val8 = Vector3.Cross(tangent, val7);
						Quaternion val9 = Quaternion.LookRotation(normalized, val8);
						float radius = GetRadius(num9, Path.Length, baseRadius, randomScale, scaleWidthWithLength);
						Vector3 val10 = val5 - val7 * radius;
						Vector3 val11 = val5 + val7 * radius;
						if (snapToTerrain)
						{
							val10.y = heightMap.GetHeight(val10);
							val11.y = heightMap.GetHeight(val11);
						}
						val10 += val8 * meshOffset;
						val11 += val8 * meshOffset;
						val2 = Vector3.Lerp(val10, val11, num6);
						if ((snapStartToTerrain && num9 < 0.1f) || (snapEndToTerrain && num9 > Path.Length - 0.1f))
						{
							val2.y = heightMap.GetHeight(val2);
						}
						else
						{
							val2.y += num7;
						}
						val2 -= val;
						val3 = val9 * val3;
						((Vector3)(ref val12))..ctor(val4.x, val4.y, val4.z);
						val12 = val9 * val12;
						((Vector4)(ref val4)).Set(val12.x, val12.y, val12.z, val4.w);
						if (normalSmoothing > 0f)
						{
							val3 = Vector3.Slerp(val3, Vector3.up, normalSmoothing);
						}
						if (roundVertices > 0)
						{
							val2.x = (float)Math.Round(val2.x, roundVertices);
							val2.y = (float)Math.Round(val2.y, roundVertices);
							val2.z = (float)Math.Round(val2.z, roundVertices);
						}
						meshData.vertices.Add(val2);
						meshData.normals.Add(val3);
						meshData.tangents.Add(val4);
						meshData.uv.Add(item);
					}
					for (int num10 = 0; num10 < data.triangles.Length; num10++)
					{
						int num11 = data.triangles[num10];
						meshData.triangles.Add(count + num11);
					}
				}
			}
			list.Add(new MeshObject(val, array2));
			array3 = array2;
			for (int j = 0; j < array3.Length; j++)
			{
				array3[j].Clear();
			}
		}
		array3 = array2;
		for (int j = 0; j < array3.Length; j++)
		{
			array3[j].Free();
		}
		return list;
	}

	public List<MeshObject> CreateMeshRiverInterior(Mesh[] meshes, bool snapToTerrain, bool snapStartToTerrain, bool snapEndToTerrain, Bounds bounds, bool scaleWidthWithLength = false, int roundVertices = 0)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0493: Unknown result type (might be due to invalid IL or missing references)
		//IL_0498: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0571: Unknown result type (might be due to invalid IL or missing references)
		//IL_0536: Unknown result type (might be due to invalid IL or missing references)
		//IL_0543: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0315: Unknown result type (might be due to invalid IL or missing references)
		//IL_0317: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0325: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_0329: Unknown result type (might be due to invalid IL or missing references)
		//IL_032d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_038c: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ca: Unknown result type (might be due to invalid IL or missing references)
		MeshCache.Data[] array = new MeshCache.Data[meshes.Length];
		for (int i = 0; i < meshes.Length; i++)
		{
			array[i] = MeshCache.Get(meshes[i]);
		}
		MeshData meshData = new MeshData();
		meshData.vertices = Pool.Get<List<Vector3>>();
		meshData.triangles = Pool.Get<List<int>>();
		meshData.uv = Pool.Get<List<Vector2>>();
		MeshData meshData2 = new MeshData();
		meshData2.vertices = Pool.Get<List<Vector3>>();
		meshData2.triangles = Pool.Get<List<int>>();
		meshData2.uv = Pool.Get<List<Vector2>>();
		Dictionary<WeldVertex, int> dictionary = new Dictionary<WeldVertex, int>();
		Vector3 min = ((Bounds)(ref bounds)).min;
		Vector3 size = ((Bounds)(ref bounds)).size;
		float num = Width / ((Bounds)(ref bounds)).size.x;
		int num2 = (int)(Path.Length / (num * ((Bounds)(ref bounds)).size.z));
		int num3 = 5;
		float num4 = Path.Length / (float)num2;
		float randomScale = RandomScale;
		float meshOffset = MeshOffset;
		float baseRadius = Width * 0.5f;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		List<MeshObject> list = new List<MeshObject>();
		for (int j = 0; j < num2; j += num3)
		{
			float distance = (float)j * num4 + 0.5f * (float)num3 * num4;
			Vector3 val = (Spline ? Path.GetPointCubicHermite(distance) : Path.GetPoint(distance));
			for (int k = 0; k < num3 && j + k < num2; k++)
			{
				float num5 = (float)(j + k) * num4;
				bool flag = j == 0;
				bool flag2 = k == 0;
				bool flag3 = j == num2 - 1;
				bool flag4 = k == num3 - 1 || j + k == num2 - 1;
				int num6 = (flag2 ? 4 : 3);
				for (int l = 0; l < num6; l++)
				{
					int num7 = l;
					MeshCache.Data data = array[num7];
					MeshData meshData3 = meshData;
					int count = meshData3.vertices.Count;
					float num8 = ((num7 == 2 && !(flag4 && flag3)) ? 1f : ((!(num7 == 3 && flag2) || flag) ? 0f : 1f));
					float num9 = ((num7 == 0) ? 1f : 0f);
					for (int m = 0; m < data.vertices.Length; m++)
					{
						Vector3 val2 = data.vertices[m];
						float num10 = (val2.x - min.x) / size.x;
						float num11 = val2.y - min.y;
						float num12 = (val2.z - min.z) / size.z;
						float num13 = num5 + num12 * num4;
						Vector3 val3 = (Spline ? Path.GetPointCubicHermite(num13) : Path.GetPoint(num13));
						Vector3 tangent = Path.GetTangent(num13);
						Vector3 val4 = Vector3Ex.XZ3D(tangent);
						Vector3 normalized = ((Vector3)(ref val4)).normalized;
						Vector3 val5 = rot90 * normalized;
						Vector3 val6 = Vector3.Cross(tangent, val5);
						float radius = GetRadius(num13, Path.Length, baseRadius, randomScale, scaleWidthWithLength);
						Vector3 val7 = val3 - val5 * radius;
						Vector3 val8 = val3 + val5 * radius;
						if (snapToTerrain)
						{
							val7.y = heightMap.GetHeight(val7);
							val8.y = heightMap.GetHeight(val8);
						}
						val7 += val6 * meshOffset;
						val8 += val6 * meshOffset;
						val2 = Vector3.Lerp(val7, val8, num10);
						if ((snapStartToTerrain && num13 < 0.1f) || (snapEndToTerrain && num13 > Path.Length - 0.1f))
						{
							val2.y = heightMap.GetHeight(val2);
						}
						else
						{
							val2.y += num11;
						}
						val2 -= val;
						if (roundVertices > 0)
						{
							val2.x = (float)Math.Round(val2.x, roundVertices);
							val2.y = (float)Math.Round(val2.y, roundVertices);
							val2.z = (float)Math.Round(val2.z, roundVertices);
						}
						meshData3.vertices.Add(val2);
						meshData3.uv.Add(new Vector2(num8, num9));
					}
					for (int n = 0; n < data.triangles.Length; n++)
					{
						int num14 = data.triangles[n];
						meshData3.triangles.Add(count + num14);
					}
				}
			}
			for (int num15 = 0; num15 < meshData.triangles.Count; num15++)
			{
				int index = meshData.triangles[num15];
				Vector3 val9 = meshData.vertices[index];
				Vector2 item = meshData.uv[index];
				WeldVertex key = default(WeldVertex);
				key.x = val9.x;
				key.y = val9.y;
				key.z = val9.z;
				key.alwaysUnderwater = meshData.uv[index].x;
				key.topSurface = meshData.uv[index].y;
				if (!dictionary.TryGetValue(key, out var value))
				{
					value = meshData2.vertices.Count;
					dictionary.Add(key, value);
					meshData2.vertices.Add(val9);
					meshData2.uv.Add(item);
				}
				meshData2.triangles.Add(value);
			}
			list.Add(new MeshObject(val, new MeshData[1] { meshData2 }));
			meshData.Clear();
			meshData2.Clear();
			dictionary.Clear();
		}
		meshData.Free();
		meshData2.Free();
		return list;
	}

	public static float GetRadius(float distance, float length, float baseRadius, float randomScale, bool scaleWidthWithLength)
	{
		if (scaleWidthWithLength)
		{
			float num = Mathf.Sqrt(Mathf.Max(0f, length - distance) / 100f);
			float num2 = ((length > 0f) ? Mathf.Lerp(3f, 1f, num) : 1f);
			float num3 = distance / 1000f;
			float num4 = Mathf.Lerp(1f, 8f, num3);
			baseRadius = baseRadius * num4 * num2;
		}
		return Mathf.Lerp(baseRadius, baseRadius * randomScale, Noise.SimplexUnsigned(distance * 0.005f));
	}

	public static float GetDepth(float distance, float length, float baseDepth, float randomScale, bool scaleWidthWithLength)
	{
		if (scaleWidthWithLength)
		{
			float num = distance / 1000f;
			float num2 = Mathf.Lerp(1f, 3f, num);
			baseDepth *= num2;
		}
		return Mathf.Lerp(baseDepth, baseDepth * randomScale, Noise.SimplexUnsigned(distance * 0.005f));
	}
}


public enum Side
{
	Both,
	Left,
	Right,
	Any
}


public enum Placement
{
	Center,
	Side
}


public enum Alignment
{
	None,
	Neighbor,
	Forward,
	Inward
}


using System;

[Serializable]
public class BasicObject
{
	public string Folder;

	public SpawnFilter Filter;

	public Placement Placement;

	public bool AlignToNormal = true;

	public bool HeightToTerrain = true;

	public float Offset;
}


using System;

[Serializable]
public class SideObject
{
	public string Folder;

	public SpawnFilter Filter;

	public Side Side;

	public Alignment Alignment;

	public float Density = 1f;

	public float Distance = 25f;

	public float Offset = 2f;
}


using System;

[Serializable]
public class PathObject
{
	public string Folder;

	public SpawnFilter Filter;

	public Alignment Alignment;

	public float Density = 1f;

	public float Distance = 5f;

	public float Dithering = 5f;
}


using System;

[Serializable]
public class BridgeObject
{
	public string Folder;

	public float Distance = 10f;
}


using UnityEngine;

public class MeshObject
{
	public Vector3 Position;

	public Mesh[] Meshes;

	public MeshObject(Vector3 meshPivot, MeshData[] meshData)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Expected O, but got Unknown
		//IL_0031: Expected O, but got Unknown
		Position = meshPivot;
		Meshes = (Mesh[])(object)new Mesh[meshData.Length];
		for (int i = 0; i < Meshes.Length; i++)
		{
			MeshData obj = meshData[i];
			Mesh[] meshes = Meshes;
			int num = i;
			Mesh val = new Mesh();
			Mesh val2 = val;
			meshes[num] = val;
			Mesh mesh = val2;
			obj.Apply(mesh);
		}
	}
}


using System;
using UnityEngine;

private struct WeldVertex : IEquatable<WeldVertex>
{
	private const float EPSILON = 0.001f;

	private const float INV_EPSILON = 999.99994f;

	public float x;

	public float y;

	public float z;

	public float alwaysUnderwater;

	public float topSurface;

	public override bool Equals(object other)
	{
		if (other is WeldVertex)
		{
			return Equals((WeldVertex)other);
		}
		return false;
	}

	public bool Equals(WeldVertex other)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3.Distance(new Vector3(x, y, z), new Vector3(other.x, other.y, other.z)) < 0.001f && alwaysUnderwater == other.alwaysUnderwater)
		{
			return topSurface == other.topSurface;
		}
		return false;
	}

	public override int GetHashCode()
	{
		int value = Mathf.RoundToInt(x * 999.99994f);
		int value2 = Mathf.RoundToInt(y * 999.99994f);
		int value3 = Mathf.RoundToInt(z * 999.99994f);
		return HashCode.Combine(value, value2, value3, alwaysUnderwater, topSurface);
	}
}


using System;
using UnityEngine;

[Serializable]
public class SpawnFilter
{
	[InspectorFlags]
	public Enum SplatType = (Enum)(-1);

	[InspectorFlags]
	public Enum BiomeType = (Enum)(-1);

	[InspectorFlags]
	public Enum TopologyAny = (Enum)(-1);

	[InspectorFlags]
	public Enum TopologyAll;

	[InspectorFlags]
	public Enum TopologyNot;

	public bool Test(Vector3 worldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GetFactor(worldPos) > 0.5f;
	}

	public bool Test(float normX, float normZ)
	{
		return GetFactor(normX, normZ) > 0.5f;
	}

	public float GetFactor(Vector3 worldPos, bool checkPlacementMap = true, float checkTopologyRadius = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetFactor(normX, normZ, checkPlacementMap, checkTopologyRadius);
	}

	public float GetFactor(float normX, float normZ, bool checkPlacementMap = true, float checkTopologyRadius = 0f)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Expected I4, but got Unknown
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Expected I4, but got Unknown
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Expected I4, but got Unknown
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Expected I4, but got Unknown
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Expected I4, but got Unknown
		if ((Object)(object)TerrainMeta.TopologyMap == (Object)null)
		{
			return 0f;
		}
		if (checkPlacementMap && (Object)(object)TerrainMeta.PlacementMap != (Object)null && TerrainMeta.PlacementMap.GetBlocked(normX, normZ))
		{
			return 0f;
		}
		int num = (int)SplatType;
		int num2 = (int)BiomeType;
		int num3 = (int)TopologyAny;
		int num4 = (int)TopologyAll;
		int num5 = (int)TopologyNot;
		if (num3 == 0)
		{
			Debug.LogError((object)"Empty topology filter is invalid.");
		}
		else if (num3 != -1 || num4 != 0 || num5 != 0)
		{
			int num6 = ((checkTopologyRadius > 0f) ? TerrainMeta.TopologyMap.GetTopology(normX, normZ, checkTopologyRadius) : TerrainMeta.TopologyMap.GetTopology(normX, normZ));
			if (num3 != -1 && (num6 & num3) == 0)
			{
				return 0f;
			}
			if (num5 != 0 && (num6 & num5) != 0)
			{
				return 0f;
			}
			if (num4 != 0 && (num6 & num4) != num4)
			{
				return 0f;
			}
		}
		switch (num2)
		{
		case 0:
			Debug.LogError((object)"Empty biome filter is invalid.");
			break;
		default:
			if ((TerrainMeta.BiomeMap.GetBiomeMaxType(normX, normZ) & num2) == 0)
			{
				return 0f;
			}
			break;
		case -1:
			break;
		}
		switch (num)
		{
		case 0:
			Debug.LogError((object)"Empty splat filter is invalid.");
			break;
		default:
			return TerrainMeta.SplatMap.GetSplat(normX, normZ, num);
		case -1:
			break;
		}
		return 1f;
	}
}


public enum SpawnFilterMode
{
	PivotPoint = 1,
	TerrainAnchorPoints = 2,
	TerrainCheckPoints = 4
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(menuName = "Rust/Terrain Config")]
public class TerrainConfig : ScriptableObject
{
	[Serializable]
	public class SplatOverlay
	{
		public Color Color = new Color(1f, 1f, 1f, 0f);

		[Range(0f, 1f)]
		public float Smoothness;

		[Range(0f, 1f)]
		public float NormalIntensity = 1f;

		[Range(0f, 8f)]
		public float BlendFactor = 0.5f;

		[Range(0.01f, 32f)]
		public float BlendFalloff = 0.5f;
	}

	[Serializable]
	public class SplatType
	{
		public string Name = "";

		[FormerlySerializedAs("WarmColor")]
		public Color AridColor = Color.white;

		public SplatOverlay AridOverlay = new SplatOverlay();

		[FormerlySerializedAs("Color")]
		public Color TemperateColor = Color.white;

		public SplatOverlay TemperateOverlay = new SplatOverlay();

		[FormerlySerializedAs("ColdColor")]
		public Color TundraColor = Color.white;

		public SplatOverlay TundraOverlay = new SplatOverlay();

		[FormerlySerializedAs("ColdColor")]
		public Color ArcticColor = Color.white;

		public SplatOverlay ArcticOverlay = new SplatOverlay();

		public Color JungleColor = Color.white;

		public SplatOverlay JungleOverlay = new SplatOverlay();

		public PhysicMaterial Material;

		public float SplatTiling = 5f;

		[Range(0f, 1f)]
		public float UVMIXMult = 0.15f;

		public float UVMIXStart;

		public float UVMIXDist = 100f;
	}

	public enum GroundType
	{
		None,
		HardSurface,
		Grass,
		Sand,
		Snow,
		Dirt,
		Gravel
	}

	public bool CastShadows = true;

	public LayerMask GroundMask = LayerMask.op_Implicit(0);

	public LayerMask WaterMask = LayerMask.op_Implicit(0);

	public PhysicMaterial GenericMaterial;

	public PhysicMaterial WaterMaterial;

	public Material Material;

	public Material MarginMaterial;

	public Texture[] AlbedoArrays = (Texture[])(object)new Texture[3];

	public Texture[] NormalArrays = (Texture[])(object)new Texture[3];

	public float HeightMapErrorMin = 5f;

	public float HeightMapErrorMax = 100f;

	public float BaseMapDistanceMin = 100f;

	public float BaseMapDistanceMax = 500f;

	public float ShaderLodMin = 100f;

	public float ShaderLodMax = 600f;

	public SplatType[] Splats = new SplatType[8];

	private string snowMatName;

	private string grassMatName;

	private string sandMatName;

	private List<string> dirtMatNames;

	private List<string> stoneyMatNames;

	private int snowMatID;

	private int grassMatID;

	private int sandMatID;

	private List<int> dirtMatIds;

	private List<int> stoneyMatIds;

	public Texture AlbedoArray => AlbedoArrays[Mathf.Clamp(QualitySettings.globalTextureMipmapLimit, 0, 2)];

	public Texture NormalArray => NormalArrays[Mathf.Clamp(QualitySettings.globalTextureMipmapLimit, 0, 2)];

	public PhysicMaterial[] GetPhysicMaterials()
	{
		PhysicMaterial[] array = (PhysicMaterial[])(object)new PhysicMaterial[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].Material;
		}
		return array;
	}

	public Color[] GetAridColors()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].AridColor;
		}
		return array;
	}

	public void GetAridOverlayConstants(out Color[] color, out Vector4[] param)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		color = (Color[])(object)new Color[Splats.Length];
		param = (Vector4[])(object)new Vector4[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			SplatOverlay aridOverlay = Splats[i].AridOverlay;
			color[i] = ((Color)(ref aridOverlay.Color)).linear;
			param[i] = new Vector4(aridOverlay.Smoothness, aridOverlay.NormalIntensity, aridOverlay.BlendFactor, aridOverlay.BlendFalloff);
		}
	}

	public Color[] GetTemperateColors()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].TemperateColor;
		}
		return array;
	}

	public void GetTemperateOverlayConstants(out Color[] color, out Vector4[] param)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		color = (Color[])(object)new Color[Splats.Length];
		param = (Vector4[])(object)new Vector4[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			SplatOverlay temperateOverlay = Splats[i].TemperateOverlay;
			color[i] = ((Color)(ref temperateOverlay.Color)).linear;
			param[i] = new Vector4(temperateOverlay.Smoothness, temperateOverlay.NormalIntensity, temperateOverlay.BlendFactor, temperateOverlay.BlendFalloff);
		}
	}

	public Color[] GetTundraColors()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].TundraColor;
		}
		return array;
	}

	public void GetTundraOverlayConstants(out Color[] color, out Vector4[] param)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		color = (Color[])(object)new Color[Splats.Length];
		param = (Vector4[])(object)new Vector4[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			SplatOverlay tundraOverlay = Splats[i].TundraOverlay;
			color[i] = ((Color)(ref tundraOverlay.Color)).linear;
			param[i] = new Vector4(tundraOverlay.Smoothness, tundraOverlay.NormalIntensity, tundraOverlay.BlendFactor, tundraOverlay.BlendFalloff);
		}
	}

	public Color[] GetArcticColors()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].ArcticColor;
		}
		return array;
	}

	public void GetArcticOverlayConstants(out Color[] color, out Vector4[] param)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		color = (Color[])(object)new Color[Splats.Length];
		param = (Vector4[])(object)new Vector4[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			SplatOverlay arcticOverlay = Splats[i].ArcticOverlay;
			color[i] = ((Color)(ref arcticOverlay.Color)).linear;
			param[i] = new Vector4(arcticOverlay.Smoothness, arcticOverlay.NormalIntensity, arcticOverlay.BlendFactor, arcticOverlay.BlendFalloff);
		}
	}

	public Color[] GetJungleColors()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].JungleColor;
		}
		return array;
	}

	public void GetJungleOverlayConstants(out Color[] color, out Vector4[] param)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		color = (Color[])(object)new Color[Splats.Length];
		param = (Vector4[])(object)new Vector4[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			SplatOverlay jungleOverlay = Splats[i].JungleOverlay;
			color[i] = ((Color)(ref jungleOverlay.Color)).linear;
			param[i] = new Vector4(jungleOverlay.Smoothness, jungleOverlay.NormalIntensity, jungleOverlay.BlendFactor, jungleOverlay.BlendFalloff);
		}
	}

	public float[] GetSplatTiling()
	{
		float[] array = new float[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].SplatTiling;
		}
		return array;
	}

	public float GetMaxSplatTiling()
	{
		float num = float.MinValue;
		for (int i = 0; i < Splats.Length; i++)
		{
			if (Splats[i].SplatTiling > num)
			{
				num = Splats[i].SplatTiling;
			}
		}
		return num;
	}

	public float GetMinSplatTiling()
	{
		float num = float.MaxValue;
		for (int i = 0; i < Splats.Length; i++)
		{
			if (Splats[i].SplatTiling < num)
			{
				num = Splats[i].SplatTiling;
			}
		}
		return num;
	}

	public Vector3[] GetPackedUVMIX()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = (Vector3[])(object)new Vector3[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = new Vector3(Splats[i].UVMIXMult, Splats[i].UVMIXStart, Splats[i].UVMIXDist);
		}
		return array;
	}

	[Obsolete("Use GetCurrentGroundTypeNoAlloc instead")]
	public GroundType GetCurrentGroundType(bool isGrounded, RaycastHit hit)
	{
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerrainConfig.GetCurrentGroundType", 0);
		try
		{
			if (string.IsNullOrEmpty(grassMatName))
			{
				dirtMatNames = new List<string>();
				stoneyMatNames = new List<string>();
				SplatType[] splats = Splats;
				foreach (SplatType obj in splats)
				{
					string text = obj.Name.ToLower();
					string name = ((Object)obj.Material).name;
					switch (text)
					{
					case "grass":
						grassMatName = name;
						break;
					case "snow":
						snowMatName = name;
						break;
					case "sand":
						sandMatName = name;
						break;
					case "dirt":
					case "forest":
					case "tundra":
						dirtMatNames.Add(name);
						break;
					case "stones":
					case "gravel":
						stoneyMatNames.Add(name);
						break;
					}
				}
			}
			if (!isGrounded)
			{
				return GroundType.None;
			}
			if ((Object)(object)((RaycastHit)(ref hit)).collider == (Object)null)
			{
				return GroundType.HardSurface;
			}
			PhysicMaterial materialAt = ((RaycastHit)(ref hit)).collider.GetMaterialAt(((RaycastHit)(ref hit)).point);
			if ((Object)(object)materialAt == (Object)null)
			{
				return GroundType.HardSurface;
			}
			string name2 = ((Object)materialAt).name;
			if (name2 == grassMatName)
			{
				return GroundType.Grass;
			}
			if (name2 == sandMatName)
			{
				return GroundType.Sand;
			}
			if (name2 == snowMatName)
			{
				return GroundType.Snow;
			}
			for (int j = 0; j < dirtMatNames.Count; j++)
			{
				if (dirtMatNames[j] == name2)
				{
					return GroundType.Dirt;
				}
			}
			for (int k = 0; k < stoneyMatNames.Count; k++)
			{
				if (stoneyMatNames[k] == name2)
				{
					return GroundType.Gravel;
				}
			}
			return GroundType.HardSurface;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public GroundType GetCurrentGroundTypeNoAlloc(bool isGrounded, RaycastHit hit)
	{
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerrainConfig.GetCurrentGroundTypeNoAlloc", 0);
		try
		{
			if (grassMatID == 0)
			{
				dirtMatIds = new List<int>();
				stoneyMatIds = new List<int>();
				SplatType[] splats = Splats;
				foreach (SplatType obj in splats)
				{
					int instanceID = ((Object)obj.Material).GetInstanceID();
					switch (obj.Name.ToLower())
					{
					case "grass":
						grassMatID = instanceID;
						break;
					case "snow":
						snowMatID = instanceID;
						break;
					case "sand":
						sandMatID = instanceID;
						break;
					case "dirt":
					case "forest":
					case "tundra":
						dirtMatIds.Add(instanceID);
						break;
					case "stones":
					case "gravel":
						stoneyMatIds.Add(instanceID);
						break;
					}
				}
			}
			if (!isGrounded)
			{
				return GroundType.None;
			}
			if ((Object)(object)((RaycastHit)(ref hit)).collider == (Object)null)
			{
				return GroundType.HardSurface;
			}
			PhysicMaterial materialAt = ((RaycastHit)(ref hit)).collider.GetMaterialAt(((RaycastHit)(ref hit)).point);
			if ((Object)(object)materialAt == (Object)null)
			{
				return GroundType.HardSurface;
			}
			int instanceID2 = ((Object)materialAt).GetInstanceID();
			if (instanceID2 == grassMatID)
			{
				return GroundType.Grass;
			}
			if (instanceID2 == sandMatID)
			{
				return GroundType.Sand;
			}
			if (instanceID2 == snowMatID)
			{
				return GroundType.Snow;
			}
			if (dirtMatIds.Contains(instanceID2))
			{
				return GroundType.Dirt;
			}
			if (stoneyMatIds.Contains(instanceID2))
			{
				return GroundType.Gravel;
			}
			return GroundType.HardSurface;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class SplatOverlay
{
	public Color Color = new Color(1f, 1f, 1f, 0f);

	[Range(0f, 1f)]
	public float Smoothness;

	[Range(0f, 1f)]
	public float NormalIntensity = 1f;

	[Range(0f, 8f)]
	public float BlendFactor = 0.5f;

	[Range(0.01f, 32f)]
	public float BlendFalloff = 0.5f;
}


using System;
using UnityEngine;
using UnityEngine.Serialization;

[Serializable]
public class SplatType
{
	public string Name = "";

	[FormerlySerializedAs("WarmColor")]
	public Color AridColor = Color.white;

	public SplatOverlay AridOverlay = new SplatOverlay();

	[FormerlySerializedAs("Color")]
	public Color TemperateColor = Color.white;

	public SplatOverlay TemperateOverlay = new SplatOverlay();

	[FormerlySerializedAs("ColdColor")]
	public Color TundraColor = Color.white;

	public SplatOverlay TundraOverlay = new SplatOverlay();

	[FormerlySerializedAs("ColdColor")]
	public Color ArcticColor = Color.white;

	public SplatOverlay ArcticOverlay = new SplatOverlay();

	public Color JungleColor = Color.white;

	public SplatOverlay JungleOverlay = new SplatOverlay();

	public PhysicMaterial Material;

	public float SplatTiling = 5f;

	[Range(0f, 1f)]
	public float UVMIXMult = 0.15f;

	public float UVMIXStart;

	public float UVMIXDist = 100f;
}


public enum GroundType
{
	None,
	HardSurface,
	Grass,
	Sand,
	Snow,
	Dirt,
	Gravel
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;
using UnityEngine.AI;

public class AsyncTerrainNavMeshBake : CustomYieldInstruction
{
	private List<int> indices;

	private List<Vector3> vertices;

	private List<Vector3> normals;

	private List<int> triangles;

	private Vector3 pivot;

	private int width;

	private int height;

	private bool normal;

	private bool alpha;

	private Action worker;

	public override bool keepWaiting => worker != null;

	public bool isDone => worker == null;

	public Mesh mesh
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected O, but got Unknown
			Mesh val = new Mesh();
			if (vertices != null)
			{
				val.SetVertices(vertices);
				Pool.FreeUnmanaged<Vector3>(ref vertices);
			}
			if (normals != null)
			{
				val.SetNormals(normals);
				Pool.FreeUnmanaged<Vector3>(ref normals);
			}
			if (triangles != null)
			{
				val.SetTriangles(triangles, 0);
				Pool.FreeUnmanaged<int>(ref triangles);
			}
			if (indices != null)
			{
				Pool.FreeUnmanaged<int>(ref indices);
			}
			return val;
		}
	}

	public NavMeshBuildSource CreateNavMeshBuildSource()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		NavMeshBuildSource result = default(NavMeshBuildSource);
		((NavMeshBuildSource)(ref result)).transform = Matrix4x4.TRS(pivot, Quaternion.identity, Vector3.one);
		((NavMeshBuildSource)(ref result)).shape = (NavMeshBuildSourceShape)0;
		((NavMeshBuildSource)(ref result)).sourceObject = (Object)(object)mesh;
		return result;
	}

	public NavMeshBuildSource CreateNavMeshBuildSource(int area)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		NavMeshBuildSource result = CreateNavMeshBuildSource();
		((NavMeshBuildSource)(ref result)).area = area;
		return result;
	}

	public AsyncTerrainNavMeshBake(Vector3 pivot, int width, int height, bool normal, bool alpha)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		this.pivot = pivot;
		this.width = width;
		this.height = height;
		this.normal = normal;
		this.alpha = alpha;
		indices = Pool.Get<List<int>>();
		vertices = Pool.Get<List<Vector3>>();
		normals = (normal ? Pool.Get<List<Vector3>>() : null);
		triangles = Pool.Get<List<int>>();
		Invoke();
	}

	private void DoWork()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor((float)(width / 2), 0f, (float)(height / 2));
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(pivot.x - val.x, 0f, pivot.z - val.z);
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainAlphaMap alphaMap = TerrainMeta.AlphaMap;
		int num = 0;
		for (int i = 0; i <= height; i++)
		{
			int num2 = 0;
			while (num2 <= width)
			{
				Vector3 worldPos = new Vector3((float)num2, 0f, (float)i) + val2;
				Vector3 item = new Vector3((float)num2, 0f, (float)i) - val;
				float num3 = heightMap.GetHeight(worldPos);
				if (num3 < -1f)
				{
					indices.Add(-1);
				}
				else if (alpha && alphaMap.GetAlpha(worldPos) < 0.1f)
				{
					indices.Add(-1);
				}
				else
				{
					if (normal)
					{
						Vector3 item2 = heightMap.GetNormal(worldPos);
						normals.Add(item2);
					}
					worldPos.y = (item.y = num3 - pivot.y);
					indices.Add(vertices.Count);
					vertices.Add(item);
				}
				num2++;
				num++;
			}
		}
		int num4 = 0;
		int num5 = 0;
		while (num5 < height)
		{
			int num6 = 0;
			while (num6 < width)
			{
				int num7 = indices[num4];
				int num8 = indices[num4 + width + 1];
				int num9 = indices[num4 + 1];
				int num10 = indices[num4 + 1];
				int num11 = indices[num4 + width + 1];
				int num12 = indices[num4 + width + 2];
				if (num7 != -1 && num8 != -1 && num9 != -1)
				{
					triangles.Add(num7);
					triangles.Add(num8);
					triangles.Add(num9);
				}
				if (num10 != -1 && num11 != -1 && num12 != -1)
				{
					triangles.Add(num10);
					triangles.Add(num11);
					triangles.Add(num12);
				}
				num6++;
				num4++;
			}
			num5++;
			num4++;
		}
	}

	private void Invoke()
	{
		worker = DoWork;
		worker.BeginInvoke(Callback, null);
	}

	private void Callback(IAsyncResult result)
	{
		worker.EndInvoke(result);
		worker = null;
	}
}


using UnityEngine;

public struct TextureData
{
	public int width;

	public int height;

	public Color32[] colors;

	public TextureData(Texture2D tex)
	{
		if ((Object)(object)tex != (Object)null)
		{
			width = ((Texture)tex).width;
			height = ((Texture)tex).height;
			colors = tex.GetPixels32();
		}
		else
		{
			width = 0;
			height = 0;
			colors = null;
		}
	}

	public Color32 GetColor(int x, int y)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return colors[y * width + x];
	}

	public int GetShort(int x, int y)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return BitUtility.DecodeShort(GetColor(x, y));
	}

	public int GetInt(int x, int y)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return BitUtility.DecodeInt(GetColor(x, y));
	}

	public float GetFloat(int x, int y)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return BitUtility.DecodeFloat(GetColor(x, y));
	}

	public float GetHalf(int x, int y)
	{
		return BitUtility.Short2Float(GetShort(x, y));
	}

	public Vector4 GetVector(int x, int y)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return BitUtility.DecodeVector(GetColor(x, y));
	}

	public Vector3 GetNormal(int x, int y)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return BitUtility.DecodeNormal(Color32.op_Implicit(GetColor(x, y)));
	}

	public Color32 GetInterpolatedColor(float x, float y)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int num3 = Mathf.Clamp((int)num, 1, width - 2);
		int num4 = Mathf.Clamp((int)num2, 1, height - 2);
		int x2 = Mathf.Min(num3 + 1, width - 2);
		int y2 = Mathf.Min(num4 + 1, height - 2);
		Color val = Color32.op_Implicit(GetColor(num3, num4));
		Color val2 = Color32.op_Implicit(GetColor(x2, num4));
		Color val3 = Color32.op_Implicit(GetColor(num3, y2));
		Color val4 = Color32.op_Implicit(GetColor(x2, y2));
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		Color val5 = Color.Lerp(val, val2, num5);
		Color val6 = Color.Lerp(val3, val4, num5);
		return Color32.op_Implicit(Color.Lerp(val5, val6, num6));
	}

	public int GetInterpolatedInt(float x, float y)
	{
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int x2 = Mathf.Clamp(Mathf.RoundToInt(num), 1, width - 2);
		int y2 = Mathf.Clamp(Mathf.RoundToInt(num2), 1, height - 2);
		return GetInt(x2, y2);
	}

	public int GetInterpolatedShort(float x, float y)
	{
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int x2 = Mathf.Clamp(Mathf.RoundToInt(num), 1, width - 2);
		int y2 = Mathf.Clamp(Mathf.RoundToInt(num2), 1, height - 2);
		return GetShort(x2, y2);
	}

	public float GetInterpolatedFloat(float x, float y)
	{
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int num3 = Mathf.Clamp((int)num, 1, width - 2);
		int num4 = Mathf.Clamp((int)num2, 1, height - 2);
		int x2 = Mathf.Min(num3 + 1, width - 2);
		int y2 = Mathf.Min(num4 + 1, height - 2);
		float @float = GetFloat(num3, num4);
		float float2 = GetFloat(x2, num4);
		float float3 = GetFloat(num3, y2);
		float float4 = GetFloat(x2, y2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		float num7 = Mathf.Lerp(@float, float2, num5);
		float num8 = Mathf.Lerp(float3, float4, num5);
		return Mathf.Lerp(num7, num8, num6);
	}

	public float GetInterpolatedHalf(float x, float y)
	{
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int num3 = Mathf.Clamp((int)num, 1, width - 2);
		int num4 = Mathf.Clamp((int)num2, 1, height - 2);
		int x2 = Mathf.Min(num3 + 1, width - 2);
		int y2 = Mathf.Min(num4 + 1, height - 2);
		float half = GetHalf(num3, num4);
		float half2 = GetHalf(x2, num4);
		float half3 = GetHalf(num3, y2);
		float half4 = GetHalf(x2, y2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		float num7 = Mathf.Lerp(half, half2, num5);
		float num8 = Mathf.Lerp(half3, half4, num5);
		return Mathf.Lerp(num7, num8, num6);
	}

	public Vector4 GetInterpolatedVector(float x, float y)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int num3 = Mathf.Clamp((int)num, 1, width - 2);
		int num4 = Mathf.Clamp((int)num2, 1, height - 2);
		int x2 = Mathf.Min(num3 + 1, width - 2);
		int y2 = Mathf.Min(num4 + 1, height - 2);
		Vector4 vector = GetVector(num3, num4);
		Vector4 vector2 = GetVector(x2, num4);
		Vector4 vector3 = GetVector(num3, y2);
		Vector4 vector4 = GetVector(x2, y2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		Vector4 val = Vector4.Lerp(vector, vector2, num5);
		Vector4 val2 = Vector4.Lerp(vector3, vector4, num5);
		return Vector4.Lerp(val, val2, num6);
	}

	public Vector3 GetInterpolatedNormal(float x, float y)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int num3 = Mathf.Clamp((int)num, 1, width - 2);
		int num4 = Mathf.Clamp((int)num2, 1, height - 2);
		int x2 = Mathf.Min(num3 + 1, width - 2);
		int y2 = Mathf.Min(num4 + 1, height - 2);
		Vector3 normal = GetNormal(num3, num4);
		Vector3 normal2 = GetNormal(x2, num4);
		Vector3 normal3 = GetNormal(num3, y2);
		Vector3 normal4 = GetNormal(x2, y2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		Vector3 val = Vector3.Lerp(normal, normal2, num5);
		Vector3 val2 = Vector3.Lerp(normal3, normal4, num5);
		return Vector3.Lerp(val, val2, num6);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;
using ConVar;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public static class World
{
	public struct SpawnTiming
	{
		public string category;

		public Prefab prefab;

		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;

		public TimeSpan time;
	}

	private static uint _size;

	private static Stopwatch spawnTimer = new Stopwatch();

	private static List<SpawnTiming> spawnTimings = new List<SpawnTiming>();

	public static uint Seed { get; set; }

	public static uint Salt { get; set; }

	public static uint Size
	{
		get
		{
			return _size;
		}
		set
		{
			_size = value;
		}
	}

	public static string Checksum { get; set; }

	public static long Timestamp { get; set; }

	public static string Url { get; set; }

	public static bool Procedural { get; set; }

	public static bool Cached { get; set; }

	public static bool Networked { get; set; }

	public static bool Receiving { get; set; }

	public static bool Transfer { get; set; }

	public static bool Nexus => NexusServer.Started;

	public static bool LoadedFromSave { get; set; }

	public static int SpawnIndex { get; set; }

	public static WorldSerialization Serialization { get; set; }

	public static WorldConfig Config { get; set; }

	public static string Name
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			if (MapUploader.IsUploaded)
			{
				return MapUploader.OriginalName;
			}
			if (CanLoadFromUrl())
			{
				return Path.GetFileNameWithoutExtension(WWW.UnEscapeURL(Url));
			}
			return Application.loadedLevelName;
		}
	}

	public static string MapFileName
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			if (MapUploader.IsUploaded)
			{
				return MapUploader.OriginalMapFileName;
			}
			if (CanLoadFromUrl())
			{
				return Name + ".map";
			}
			return Name.Replace(" ", "").ToLower() + "." + Size + "." + Seed + "." + 268 + ".map";
		}
	}

	public static string MapFolderName
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			return Server.rootFolder;
		}
	}

	public static string SaveFileName
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			if (MapUploader.IsUploaded)
			{
				return MapUploader.OriginalSaveFileName;
			}
			if (CanLoadFromUrl())
			{
				return Name + "." + 268 + ".sav";
			}
			return Name.Replace(" ", "").ToLower() + "." + Size + "." + Seed + "." + 268 + ".sav";
		}
	}

	public static string SaveFolderName
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			return Server.rootFolder;
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	public static string GetServerBrowserMapName()
	{
		if (MapUploader.IsUploaded)
		{
			return Name;
		}
		if (!CanLoadFromUrl())
		{
			return Name;
		}
		if (Name.StartsWith("proceduralmap."))
		{
			return "Procedural Map";
		}
		return "Custom Map";
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	public static bool CanLoadFromUrl()
	{
		return !string.IsNullOrEmpty(Url);
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	public static bool CanLoadFromDisk()
	{
		return File.Exists(MapFolderName + "/" + MapFileName);
	}

	public static void CleanupOldFiles()
	{
		if (!Directory.Exists(MapFolderName))
		{
			return;
		}
		Regex regex1 = new Regex("proceduralmap\\.[0-9]+\\.[0-9]+\\.[0-9]+(_occlusion)*\\.(map|dat)");
		Regex regex2 = new Regex("\\.[0-9]+\\.[0-9]+\\." + 268 + "+(_occlusion)*\\.(map|dat)");
		foreach (string item in new string[2] { "*.map", "*.dat" }.SelectMany((string ext) => from path in Directory.GetFiles(MapFolderName, ext)
			where regex1.IsMatch(path) && !regex2.IsMatch(path)
			select path))
		{
			try
			{
				File.Delete(item);
			}
			catch (Exception ex)
			{
				Debug.LogError((object)ex.Message);
			}
		}
	}

	public static void InitSeed(int seed)
	{
		InitSeed((uint)seed);
	}

	public static void InitSeed(uint seed)
	{
		if (seed == 0)
		{
			seed = MurmurHashEx.MurmurHashUnsigned(SeedIdentifier()) % int.MaxValue;
		}
		if (seed == 0)
		{
			seed = 123456u;
		}
		Seed = seed;
		Server.seed = (int)seed;
	}

	private static string SeedIdentifier()
	{
		return SystemInfo.deviceUniqueIdentifier + "_" + 268 + "_" + Server.identity;
	}

	public static void InitSalt(int salt)
	{
		InitSalt((uint)salt);
	}

	public static void InitSalt(uint salt)
	{
		if (salt == 0)
		{
			salt = MurmurHashEx.MurmurHashUnsigned(SaltIdentifier()) % int.MaxValue;
		}
		if (salt == 0)
		{
			salt = 654321u;
		}
		Salt = salt;
		Server.salt = (int)salt;
	}

	private static string SaltIdentifier()
	{
		return SystemInfo.deviceUniqueIdentifier + "_salt";
	}

	public static void InitSize(int size)
	{
		InitSize((uint)size);
	}

	public static void InitSize(uint size)
	{
		if (size == 0)
		{
			size = 4500u;
		}
		if (size < 1000)
		{
			size = 1000u;
		}
		if (size > 6000)
		{
			size = 6000u;
		}
		Size = size;
		Server.worldsize = (int)size;
	}

	public static byte[] GetMap(string name)
	{
		return Serialization.GetMap(name)?.data;
	}

	public static int GetCachedHeightMapResolution()
	{
		return Mathf.RoundToInt(Mathf.Sqrt((float)(GetMap("height").Length / 2)));
	}

	public static int GetCachedSplatMapResolution()
	{
		return Mathf.RoundToInt(Mathf.Sqrt((float)(GetMap("splat").Length / 8)));
	}

	public static void AddMap(string name, byte[] data)
	{
		Serialization.AddMap(name, data);
	}

	public static void AddPrefab(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		Serialization.AddPrefab(category, prefab.ID, position, rotation, scale);
		if (!Cached)
		{
			rotation = Quaternion.Euler(((Quaternion)(ref rotation)).eulerAngles);
			SpawnPrefab(category, prefab, position, rotation, scale);
		}
	}

	public static PathData PathListToPathData(PathList src)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Expected O, but got Unknown
		return new PathData
		{
			name = src.Name,
			spline = src.Spline,
			start = src.Start,
			end = src.End,
			width = src.Width,
			innerPadding = src.InnerPadding,
			outerPadding = src.OuterPadding,
			innerFade = src.InnerFade,
			outerFade = src.OuterFade,
			randomScale = src.RandomScale,
			meshOffset = src.MeshOffset,
			terrainOffset = src.TerrainOffset,
			splat = src.Splat,
			topology = src.Topology,
			hierarchy = src.Hierarchy,
			nodes = VectorArrayToList(src.Path.Points)
		};
	}

	public static PathList PathDataToPathList(PathData src)
	{
		PathList pathList = new PathList(src.name, VectorListToArray(src.nodes));
		pathList.Spline = src.spline;
		pathList.Start = src.start;
		pathList.End = src.end;
		pathList.Width = src.width;
		pathList.InnerPadding = src.innerPadding;
		pathList.OuterPadding = src.outerPadding;
		pathList.InnerFade = src.innerFade;
		pathList.OuterFade = src.outerFade;
		pathList.RandomScale = src.randomScale;
		pathList.MeshOffset = src.meshOffset;
		pathList.TerrainOffset = src.terrainOffset;
		pathList.Splat = src.splat;
		pathList.Topology = src.topology;
		pathList.Hierarchy = src.hierarchy;
		pathList.Path.RecalculateTangents();
		return pathList;
	}

	public static Vector3[] VectorListToArray(List<VectorData> src)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = (Vector3[])(object)new Vector3[src.Count];
		for (int i = 0; i < array.Length; i++)
		{
			VectorData val = src[i];
			Vector3 val2 = default(Vector3);
			val2.x = val.x;
			val2.y = val.y;
			val2.z = val.z;
			array[i] = val2;
		}
		return array;
	}

	public static List<VectorData> VectorArrayToList(Vector3[] src)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		List<VectorData> list = new List<VectorData>(src.Length);
		foreach (Vector3 val in src)
		{
			VectorData item = default(VectorData);
			item.x = val.x;
			item.y = val.y;
			item.z = val.z;
			list.Add(item);
		}
		return list;
	}

	public static IEnumerable<PathList> GetPaths(string name)
	{
		return from p in Serialization.GetPaths(name)
			select PathDataToPathList(p);
	}

	public static void AddPaths(IEnumerable<PathList> paths)
	{
		foreach (PathList path in paths)
		{
			AddPath(path);
		}
	}

	public static void AddPath(PathList path)
	{
		Serialization.AddPath(PathListToPathData(path));
	}

	public static IEnumerator SpawnAsync(float deltaTime, Action<string> statusFunction = null)
	{
		int totalCount = 0;
		Dictionary<string, List<PrefabData>> assetGroups = new Dictionary<string, List<PrefabData>>(StringComparer.InvariantCultureIgnoreCase);
		foreach (PrefabData prefab2 in Serialization.world.prefabs)
		{
			string text = StringPool.Get(prefab2.id);
			if (string.IsNullOrWhiteSpace(text))
			{
				Debug.LogWarning((object)$"Could not find path for prefab ID {prefab2.id}, skipping spawn");
				continue;
			}
			if (!assetGroups.TryGetValue(text, out var value))
			{
				value = new List<PrefabData>();
				assetGroups.Add(text, value);
			}
			value.Add(prefab2);
			totalCount++;
		}
		int spawnedCount = 0;
		int resultIndex = 0;
		Stopwatch sw = Stopwatch.StartNew();
		AssetPreloadResult load = FileSystem.PreloadAssets((IEnumerable<string>)assetGroups.Keys, Global.preloadConcurrency, 10);
		while (load != null && (((CustomYieldInstruction)load).MoveNext() || assetGroups.Count > 0))
		{
			while (resultIndex < load.Results.Count && sw.Elapsed.TotalSeconds < (double)deltaTime)
			{
				string item = load.Results[resultIndex].Item1;
				if (!assetGroups.TryGetValue(item, out var value2))
				{
					resultIndex++;
					continue;
				}
				if (value2.Count == 0)
				{
					assetGroups.Remove(item);
					resultIndex++;
					continue;
				}
				int index = value2.Count - 1;
				PrefabData prefab = value2[index];
				value2.RemoveAt(index);
				SpawnPrefabData(prefab);
				spawnedCount++;
			}
			Status(statusFunction, "Spawning World ({0}/{1})", spawnedCount, totalCount);
			yield return CoroutineEx.waitForEndOfFrame;
			sw.Restart();
		}
	}

	public static IEnumerator Spawn(float deltaTime, Action<string> statusFunction = null)
	{
		Stopwatch sw = Stopwatch.StartNew();
		for (int i = 0; i < Serialization.world.prefabs.Count; i++)
		{
			if (sw.Elapsed.TotalSeconds > (double)deltaTime || i == 0 || i == Serialization.world.prefabs.Count - 1)
			{
				Status(statusFunction, "Spawning World ({0}/{1})", i + 1, Serialization.world.prefabs.Count);
				yield return CoroutineEx.waitForEndOfFrame;
				sw.Reset();
				sw.Start();
			}
			SpawnPrefabData(Serialization.world.prefabs[i]);
		}
	}

	public static void Spawn()
	{
		for (int i = 0; i < Serialization.world.prefabs.Count; i++)
		{
			SpawnPrefabData(Serialization.world.prefabs[i]);
		}
	}

	public static void Spawn(string category, string folder = null)
	{
		for (int i = SpawnIndex; i < Serialization.world.prefabs.Count; i++)
		{
			PrefabData val = Serialization.world.prefabs[i];
			if (!(val.category != category))
			{
				string text = StringPool.Get(val.id);
				if (string.IsNullOrEmpty(folder) || text.StartsWith(folder))
				{
					SpawnPrefabData(val);
					SpawnIndex++;
					continue;
				}
				break;
			}
			break;
		}
	}

	public static void Spawn(string category, string[] folders)
	{
		for (int i = SpawnIndex; i < Serialization.world.prefabs.Count; i++)
		{
			PrefabData val = Serialization.world.prefabs[i];
			if (!(val.category != category))
			{
				string text = StringPool.Get(val.id);
				if (folders == null || StringEx.StartsWithAny(text, folders))
				{
					SpawnPrefabData(val);
					SpawnIndex++;
					continue;
				}
				break;
			}
			break;
		}
	}

	private static void SpawnPrefabData(PrefabData prefab)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		string autospawnPath = StringPool.Get(prefab.id);
		uint id = prefab.id;
		if (SceneToPrefab.monument_scenes_enabled && Cached && SceneToPrefab.TryRemapAutospawnToSceneSpawner(autospawnPath, out var spawnerPath))
		{
			autospawnPath = spawnerPath;
			id = StringPool.Get(autospawnPath);
		}
		SpawnPrefab(prefab.category, Prefab.Load(id), VectorData.op_Implicit(prefab.position), VectorData.op_Implicit(prefab.rotation), VectorData.op_Implicit(prefab.scale));
	}

	private static void SpawnPrefab(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		if (prefab != null && Object.op_Implicit((Object)(object)prefab.Object))
		{
			spawnTimer.Restart();
			if (!Cached)
			{
				prefab.ApplyTerrainPlacements(position, rotation, scale);
				prefab.ApplyTerrainModifiers(position, rotation, scale);
			}
			GameObject val = prefab.Spawn(position, rotation, scale);
			if (Object.op_Implicit((Object)(object)val))
			{
				Interface.CallHook("OnWorldPrefabSpawned", (object)val, (object)category);
				val.SetHierarchyGroup(category);
			}
			spawnTimer.Stop();
			spawnTimings.Add(new SpawnTiming
			{
				category = category,
				prefab = prefab,
				position = position,
				rotation = rotation,
				scale = scale,
				time = spawnTimer.Elapsed
			});
		}
	}

	private static void Status(Action<string> statusFunction, string status, object obj1)
	{
		statusFunction?.Invoke(string.Format(status, obj1));
	}

	private static void Status(Action<string> statusFunction, string status, object obj1, object obj2)
	{
		statusFunction?.Invoke(string.Format(status, obj1, obj2));
	}

	private static void Status(Action<string> statusFunction, string status, object obj1, object obj2, object obj3)
	{
		statusFunction?.Invoke(string.Format(status, obj1, obj2, obj3));
	}

	private static void Status(Action<string> statusFunction, string status, params object[] objs)
	{
		statusFunction?.Invoke(string.Format(status, objs));
	}

	public static IEnumerable<SpawnTiming> GetSpawnTimings()
	{
		return spawnTimings;
	}

	public static void ResetTiming()
	{
		spawnTimings.Clear();
	}
}


using System;
using UnityEngine;

public struct SpawnTiming
{
	public string category;

	public Prefab prefab;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public TimeSpan time;
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using ConVar;
using Newtonsoft.Json;
using UnityEngine;

[JsonModel]
public class WorldConfig
{
	public string JsonString = string.Empty;

	public float PercentageTier0 = 0.3f;

	public float PercentageTier1 = 0.3f;

	public float PercentageTier2 = 0.4f;

	public float PercentageBiomeArid = 0.4f;

	public float PercentageBiomeTemperate = 0.15f;

	public float PercentageBiomeTundra = 0.15f;

	public float PercentageBiomeArctic = 0.3f;

	public float PercentageBiomeJungle = 0.5f;

	public bool MainRoads = true;

	public bool SideRoads = true;

	public bool Trails = true;

	public bool Rivers = true;

	public bool Powerlines = true;

	public bool AboveGroundRails = true;

	public bool BelowGroundRails = true;

	public bool UnderwaterLabs = true;

	public List<string> PrefabBlacklist = new List<string>();

	public List<string> PrefabWhitelist = new List<string>();

	public bool IsPrefabAllowed(string name)
	{
		if (PrefabBlacklist.Count > 0)
		{
			foreach (string item in PrefabBlacklist)
			{
				if (name.Contains(item))
				{
					return false;
				}
			}
		}
		if (PrefabWhitelist.Count > 0)
		{
			foreach (string item2 in PrefabWhitelist)
			{
				if (name.Contains(item2))
				{
					return true;
				}
			}
			return false;
		}
		return true;
	}

	public void LoadFromJsonFile(string fileName)
	{
		try
		{
			LoadFromJsonString(File.ReadAllText(fileName));
		}
		catch (Exception ex)
		{
			Debug.LogError((object)ex.Message);
		}
	}

	public void LoadFromJsonString(string data)
	{
		try
		{
			LoadFromWorldConfig(JsonConvert.DeserializeObject<WorldConfig>(JsonString = data));
		}
		catch (Exception ex)
		{
			Debug.LogError((object)ex.Message);
		}
	}

	public void LoadFromWorldConfig(WorldConfig data)
	{
		float num = data.PercentageTier0 + data.PercentageTier1 + data.PercentageTier2;
		if (num > 0f)
		{
			PercentageTier0 = data.PercentageTier0 / num;
			PercentageTier1 = data.PercentageTier1 / num;
			PercentageTier2 = data.PercentageTier2 / num;
		}
		else
		{
			PercentageTier0 = 0f;
			PercentageTier1 = 1f;
			PercentageTier2 = 0f;
		}
		float num2 = data.PercentageBiomeArid + data.PercentageBiomeTemperate + data.PercentageBiomeTundra + data.PercentageBiomeArctic;
		if (num2 > 0f)
		{
			PercentageBiomeArid = data.PercentageBiomeArid / num2;
			PercentageBiomeTemperate = data.PercentageBiomeTemperate / num2;
			PercentageBiomeTundra = data.PercentageBiomeTundra / num2;
			PercentageBiomeArctic = data.PercentageBiomeArctic / num2;
		}
		else
		{
			PercentageBiomeArid = 0f;
			PercentageBiomeTemperate = 1f;
			PercentageBiomeTundra = 0f;
			PercentageBiomeArctic = 0f;
		}
		MainRoads = data.MainRoads;
		SideRoads = data.SideRoads;
		Trails = data.Trails;
		Rivers = data.Rivers;
		Powerlines = data.Powerlines;
		AboveGroundRails = data.AboveGroundRails;
		BelowGroundRails = data.BelowGroundRails;
		UnderwaterLabs = data.UnderwaterLabs;
		PrefabBlacklist.Clear();
		if (data.PrefabBlacklist != null && data.PrefabBlacklist.Count > 0)
		{
			PrefabBlacklist.AddRange(data.PrefabBlacklist);
		}
		PrefabWhitelist.Clear();
		if (data.PrefabWhitelist != null && data.PrefabWhitelist.Count > 0)
		{
			PrefabWhitelist.AddRange(data.PrefabWhitelist);
		}
	}

	public void LoadScriptableConfigs()
	{
		ScriptableWorldConfig[] array = Resources.LoadAll<ScriptableWorldConfig>("");
		bool flag = false;
		ScriptableWorldConfig[] array2 = array;
		foreach (ScriptableWorldConfig scriptableWorldConfig in array2)
		{
			if (scriptableWorldConfig.GameModes != null && scriptableWorldConfig.GameModes.Contains(Server.gamemode))
			{
				MergeScriptableConfig(scriptableWorldConfig);
				flag = true;
			}
		}
		if (flag)
		{
			JsonString = JsonConvert.SerializeObject((object)this);
		}
	}

	private void MergeScriptableConfig(ScriptableWorldConfig config)
	{
		UnderwaterLabs &= config.UnderwaterLabs;
		BelowGroundRails &= config.UndergroundTrains;
		if (PrefabBlacklist == null)
		{
			PrefabBlacklist = new List<string>();
		}
		if (config.BlacklistedPrefabs != null)
		{
			PrefabBlacklist.AddRange(config.BlacklistedPrefabs);
		}
	}
}


using System;
using UnityEngine;

public abstract class DecorComponent : PrefabAttribute
{
	internal bool isRoot;

	public abstract void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale);

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		isRoot = (Object)(object)rootObj == (Object)(object)((Component)this).gameObject;
	}

	protected override Type GetIndexedType()
	{
		return typeof(DecorComponent);
	}
}


using UnityEngine;

public static class DecorComponentEx
{
	public static void ApplyDecorComponents(this Transform transform, DecorComponent[] components, ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		foreach (DecorComponent decorComponent in components)
		{
			if (!decorComponent.isRoot)
			{
				break;
			}
			decorComponent.Apply(ref pos, ref rot, ref scale);
		}
	}

	public static void ApplyDecorComponents(this Transform transform, DecorComponent[] components)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pos = transform.position;
		Quaternion rot = transform.rotation;
		Vector3 scale = transform.localScale;
		transform.ApplyDecorComponents(components, ref pos, ref rot, ref scale);
		transform.position = pos;
		transform.rotation = rot;
		transform.localScale = scale;
	}

	public static void ApplyDecorComponentsScaleOnly(this Transform transform, DecorComponent[] components)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pos = transform.position;
		Quaternion rot = transform.rotation;
		Vector3 scale = transform.localScale;
		transform.ApplyDecorComponents(components, ref pos, ref rot, ref scale);
		transform.localScale = scale;
	}
}


using UnityEngine;

public class DecorAlign : DecorComponent
{
	public float NormalAlignment = 1f;

	public float GradientAlignment = 1f;

	public Vector3 SlopeOffset = Vector3.zero;

	public Vector3 SlopeScale = Vector3.one;

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normal = TerrainMeta.HeightMap.GetNormal(pos);
		Vector3 val = ((normal == Vector3.up) ? Vector3.forward : Vector3.Cross(normal, Vector3.up));
		Vector3 val2 = Vector3.Cross(normal, val);
		if (SlopeOffset != Vector3.zero || SlopeScale != Vector3.one)
		{
			float slope = TerrainMeta.HeightMap.GetSlope01(pos);
			if (SlopeOffset != Vector3.zero)
			{
				Vector3 val3 = SlopeOffset * slope;
				pos += val3.x * val;
				pos += val3.y * normal;
				pos -= val3.z * val2;
			}
			if (SlopeScale != Vector3.one)
			{
				Vector3 val4 = Vector3.Lerp(Vector3.one, Vector3.one + Quaternion.Inverse(rot) * (SlopeScale - Vector3.one), slope);
				scale.x *= val4.x;
				scale.y *= val4.y;
				scale.z *= val4.z;
			}
		}
		Vector3 up = Vector3.Lerp(rot * Vector3.up, normal, NormalAlignment);
		Vector3 forward = Vector3.Lerp(rot * Vector3.forward, val2, GradientAlignment);
		rot = QuaternionEx.LookRotationForcedUp(forward, up);
	}
}


using UnityEngine;

public class DecorFlip : DecorComponent
{
	public enum AxisType
	{
		X,
		Y,
		Z
	}

	public AxisType FlipAxis = AxisType.Y;

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(pos, World.Seed) + 4;
		if (!(SeedRandom.Value(ref num) > 0.5f))
		{
			switch (FlipAxis)
			{
			case AxisType.X:
			case AxisType.Z:
				rot = Quaternion.AngleAxis(180f, rot * Vector3.up) * rot;
				break;
			case AxisType.Y:
				rot = Quaternion.AngleAxis(180f, rot * Vector3.forward) * rot;
				break;
			}
		}
	}
}


public enum AxisType
{
	X,
	Y,
	Z
}


using UnityEngine;

public class DecorOffset : DecorComponent
{
	public Vector3 MinOffset = new Vector3(0f, 0f, 0f);

	public Vector3 MaxOffset = new Vector3(0f, 0f, 0f);

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(pos, World.Seed) + 1;
		pos.x += scale.x * SeedRandom.Range(ref num, MinOffset.x, MaxOffset.x);
		pos.y += scale.y * SeedRandom.Range(ref num, MinOffset.y, MaxOffset.y);
		pos.z += scale.z * SeedRandom.Range(ref num, MinOffset.z, MaxOffset.z);
	}
}


using UnityEngine;

public class DecorRotate : DecorComponent
{
	public Vector3 MinRotation = new Vector3(0f, -180f, 0f);

	public Vector3 MaxRotation = new Vector3(0f, 180f, 0f);

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(pos, World.Seed) + 2;
		float num2 = SeedRandom.Range(ref num, MinRotation.x, MaxRotation.x);
		float num3 = SeedRandom.Range(ref num, MinRotation.y, MaxRotation.y);
		float num4 = SeedRandom.Range(ref num, MinRotation.z, MaxRotation.z);
		rot = Quaternion.Euler(num2, num3, num4) * rot;
	}
}


using UnityEngine;

public class DecorScale : DecorComponent
{
	public Vector3 MinScale = new Vector3(1f, 1f, 1f);

	public Vector3 MaxScale = new Vector3(2f, 2f, 2f);

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(pos, World.Seed) + 3;
		float num2 = SeedRandom.Value(ref num);
		scale.x *= Mathf.Lerp(MinScale.x, MaxScale.x, num2);
		scale.y *= Mathf.Lerp(MinScale.y, MaxScale.y, num2);
		scale.z *= Mathf.Lerp(MinScale.z, MaxScale.z, num2);
	}
}


using System;
using UnityEngine;

public class DecorSocketFemale : PrefabAttribute
{
	protected override Type GetIndexedType()
	{
		return typeof(DecorSocketFemale);
	}

	protected void OnDrawGizmosSelected()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = new Color(1f, 0.5f, 0.5f, 1f);
		Gizmos.DrawSphere(((Component)this).transform.position, 1f);
	}
}


using System;
using UnityEngine;

public class DecorSocketMale : PrefabAttribute
{
	protected override Type GetIndexedType()
	{
		return typeof(DecorSocketMale);
	}

	protected void OnDrawGizmosSelected()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = new Color(0.5f, 0.5f, 1f, 1f);
		Gizmos.DrawSphere(((Component)this).transform.position, 1f);
	}
}


using UnityEngine;

public class DecorSwim : DecorComponent
{
	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		pos.y = WaterLevel.GetWaterSurface(pos, waves: false, volumes: false);
		if (pos.y <= TerrainMeta.Position.y + 1f)
		{
			pos.y = 0f;
		}
	}
}


using UnityEngine;

public class DecorTransform : DecorComponent
{
	public Vector3 Position = new Vector3(0f, 0f, 0f);

	public Vector3 Rotation = new Vector3(0f, 0f, 0f);

	public Vector3 Scale = new Vector3(1f, 1f, 1f);

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		pos += rot * Vector3.Scale(scale, Position);
		rot = Quaternion.Euler(Rotation) * rot;
		scale = Vector3.Scale(scale, Scale);
	}
}


public class DecorPatch
{
}


using UnityEngine;

public class DecorSpawn : MonoBehaviour, IClientComponent
{
	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public uint Seed;

	public float ObjectCutoff = 0.2f;

	public float ObjectTapering = 0.2f;

	public int ObjectsPerPatch = 10;

	public float ClusterRadius = 2f;

	public int ClusterSizeMin = 1;

	public int ClusterSizeMax = 10;

	public int PatchCount = 8;

	public int PatchSize = 100;

	public bool LOD = true;
}


using System.Collections.Generic;
using UnityEngine;

public class DungeonBaseInfo : LandmarkInfo
{
	public List<GameObject> Links = new List<GameObject>();

	public List<DungeonBaseFloor> Floors = new List<DungeonBaseFloor>();

	public float Distance(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position - position;
		return ((Vector3)(ref val)).magnitude;
	}

	public float SqrDistance(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position - position;
		return ((Vector3)(ref val)).sqrMagnitude;
	}

	public void Add(DungeonBaseLink link)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		Links.Add(((Component)link).gameObject);
		if (link.Type == DungeonBaseLinkType.End)
		{
			return;
		}
		DungeonBaseFloor dungeonBaseFloor = null;
		float num = float.MaxValue;
		for (int i = 0; i < Floors.Count; i++)
		{
			DungeonBaseFloor dungeonBaseFloor2 = Floors[i];
			float num2 = dungeonBaseFloor2.Distance(((Component)link).transform.position);
			if (!(num2 >= 1f) && !(num2 >= num))
			{
				dungeonBaseFloor = dungeonBaseFloor2;
				num = num2;
			}
		}
		if (dungeonBaseFloor == null)
		{
			dungeonBaseFloor = new DungeonBaseFloor();
			dungeonBaseFloor.Links.Add(link);
			Floors.Add(dungeonBaseFloor);
			Floors.Sort((DungeonBaseFloor l, DungeonBaseFloor r) => l.SignedDistance(((Component)this).transform.position).CompareTo(r.SignedDistance(((Component)this).transform.position)));
		}
		else
		{
			dungeonBaseFloor.Links.Add(link);
		}
	}

	protected override void Awake()
	{
		base.Awake();
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.DungeonBaseEntrances.Add(this);
		}
	}

	protected void Start()
	{
		((Component)this).transform.SetHierarchyGroup("DungeonBase");
	}
}


