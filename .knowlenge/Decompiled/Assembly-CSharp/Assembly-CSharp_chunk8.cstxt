using System.Collections.Generic;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;

public class Drone : RemoteControlEntity, IRemoteControllableClientCallbacks, IRemoteControllable
{
	public struct DroneInputState
	{
		public Vector3 movement;

		public float throttle;

		public float pitch;

		public float yaw;

		public void Reset()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			movement = Vector3.zero;
			pitch = 0f;
			yaw = 0f;
		}
	}

	[ReplicatedVar(Help = "How far drones can be flown away from the controlling computer station", ShowInAdminUI = true, Default = "600")]
	public static float maxControlRange = 750f;

	[ServerVar(Help = "If greater than zero, overrides the drone's planar movement speed")]
	public static float movementSpeedOverride = 0f;

	[ServerVar(Help = "If greater than zero, overrides the drone's vertical movement speed")]
	public static float altitudeSpeedOverride = 0f;

	[ClientVar(ClientAdmin = true)]
	public static float windTimeDivisor = 10f;

	[ClientVar(ClientAdmin = true)]
	public static float windPositionDivisor = 100f;

	[ClientVar(ClientAdmin = true)]
	public static float windPositionScale = 1f;

	[ClientVar(ClientAdmin = true)]
	public static float windRotationMultiplier = 45f;

	[ClientVar(ClientAdmin = true)]
	public static float windLerpSpeed = 0.1f;

	public const Flags Flag_ThrottleUp = Flags.Reserved1;

	public const Flags Flag_Flying = Flags.Reserved2;

	[Header("Drone")]
	public Rigidbody body;

	public Transform modelRoot;

	public bool killInWater = true;

	public bool killInTerrain = true;

	public bool enableGrounding = true;

	public bool keepAboveTerrain = true;

	public float groundTraceDist = 0.1f;

	public float groundCheckInterval = 0.05f;

	public float altitudeAcceleration = 10f;

	public float movementAcceleration = 10f;

	public float yawSpeed = 2f;

	public float uprightSpeed = 2f;

	public float uprightPrediction = 0.15f;

	public float uprightDot = 0.5f;

	public float leanWeight = 0.1f;

	public float leanMaxVelocity = 5f;

	public float hurtVelocityThreshold = 3f;

	public float hurtDamagePower = 3f;

	public float collisionDisableTime = 0.25f;

	public float pitchMin = -60f;

	public float pitchMax = 60f;

	public float pitchSensitivity = -5f;

	public bool disableWhenHurt;

	[Range(0f, 1f)]
	public float disableWhenHurtChance = 0.25f;

	public float playerCheckInterval = 0.1f;

	public float playerCheckRadius;

	public float deployYOffset = 0.1f;

	[Header("Sound")]
	public SoundDefinition movementLoopSoundDef;

	public SoundDefinition movementStartSoundDef;

	public SoundDefinition movementStopSoundDef;

	public AnimationCurve movementLoopPitchCurve;

	public float movementSpeedReference = 50f;

	[Header("Animation")]
	public float propellerMaxSpeed = 1000f;

	public float propellerAcceleration = 3f;

	public Transform propellerA;

	public Transform propellerB;

	public Transform propellerC;

	public Transform propellerD;

	public float pitch;

	public Vector3? targetPosition;

	public DroneInputState currentInput;

	public float lastInputTime;

	public double lastCollision = -1000.0;

	public TimeSince lastGroundCheck;

	public bool isGrounded;

	public RealTimeSinceEx lastPlayerCheck;

	public override bool RequiresMouse => true;

	public override float MaxRange => maxControlRange;

	public override bool CanAcceptInput => true;

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	public override void Spawn()
	{
		base.Spawn();
		isGrounded = true;
	}

	public override void StopControl(CameraViewerId viewerID)
	{
		CameraViewerId? controllingViewerId = base.ControllingViewerId;
		if (viewerID == controllingViewerId)
		{
			SetFlag(Flags.Reserved1, b: false, recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
			pitch = 0f;
			SendNetworkUpdate();
		}
		base.StopControl(viewerID);
	}

	public override void UserInput(InputState inputState, CameraViewerId viewerID)
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		CameraViewerId? controllingViewerId = base.ControllingViewerId;
		if (!(viewerID != controllingViewerId))
		{
			currentInput.Reset();
			int num = (inputState.IsDown(BUTTON.FORWARD) ? 1 : 0) + (inputState.IsDown(BUTTON.BACKWARD) ? (-1) : 0);
			int num2 = (inputState.IsDown(BUTTON.RIGHT) ? 1 : 0) + (inputState.IsDown(BUTTON.LEFT) ? (-1) : 0);
			ref DroneInputState reference = ref currentInput;
			Vector3 val = new Vector3((float)num2, 0f, (float)num);
			reference.movement = ((Vector3)(ref val)).normalized;
			currentInput.throttle = (inputState.IsDown(BUTTON.SPRINT) ? 1 : 0) + (inputState.IsDown(BUTTON.DUCK) ? (-1) : 0);
			currentInput.yaw = inputState.current.mouseDelta.x;
			currentInput.pitch = inputState.current.mouseDelta.y;
			lastInputTime = Time.time;
			bool flag = false;
			bool flag2 = false;
			bool flag3 = currentInput.throttle > 0f;
			if (flag3 != HasFlag(Flags.Reserved1))
			{
				SetFlag(Flags.Reserved1, flag3, recursive: false, networkupdate: false);
				flag = true;
			}
			float num3 = pitch;
			pitch += currentInput.pitch * pitchSensitivity;
			pitch = Mathf.Clamp(pitch, pitchMin, pitchMax);
			if (!Mathf.Approximately(pitch, num3))
			{
				flag2 = true;
			}
			if (flag2)
			{
				SendNetworkUpdateImmediate();
			}
			else if (flag)
			{
				SendNetworkUpdate_Flags();
			}
		}
	}

	public virtual void Update_Server()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isServer || IsDead() || base.IsBeingControlled || !targetPosition.HasValue)
		{
			return;
		}
		Vector3 position = ((Component)this).transform.position;
		float height = TerrainMeta.HeightMap.GetHeight(position);
		Vector3 val = targetPosition.Value - body.velocity * 0.5f;
		if (keepAboveTerrain)
		{
			val.y = Mathf.Max(val.y, height + 1f);
		}
		Vector2 val2 = Vector3Ex.XZ2D(val);
		Vector2 val3 = Vector3Ex.XZ2D(position);
		Vector3 val4 = default(Vector3);
		float num = default(float);
		Vector3Ex.ToDirectionAndMagnitude(Vector3Ex.XZ3D(val2 - val3), ref val4, ref num);
		currentInput.Reset();
		lastInputTime = Time.time;
		if (position.y - height > 1f)
		{
			float num2 = Mathf.Clamp01(num);
			currentInput.movement = ((Component)this).transform.InverseTransformVector(val4) * num2;
			if (num > 0.5f)
			{
				Quaternion val5 = ((Component)this).transform.rotation;
				float y = ((Quaternion)(ref val5)).eulerAngles.y;
				val5 = Quaternion.FromToRotation(Vector3.forward, val4);
				float y2 = ((Quaternion)(ref val5)).eulerAngles.y;
				currentInput.yaw = Mathf.Clamp(Mathf.LerpAngle(y, y2, Time.deltaTime) - y, -2f, 2f);
			}
		}
		currentInput.throttle = Mathf.Clamp(val.y - position.y, -1f, 1f);
	}

	public void FixedUpdate()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0395: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03be: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_030d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_032b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		//IL_0334: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0340: Unknown result type (might be due to invalid IL or missing references)
		//IL_0348: Unknown result type (might be due to invalid IL or missing references)
		//IL_034c: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isServer || IsDead())
		{
			return;
		}
		if (killInTerrain && AntiHack.TestInsideTerrain(((Component)this).transform.position))
		{
			Kill();
			return;
		}
		if (killInWater)
		{
			float num = WaterFactor();
			if (num > 0f)
			{
				if (num > 0.99f)
				{
					Kill();
				}
				return;
			}
		}
		if ((!base.IsBeingControlled && !targetPosition.HasValue) || (isGrounded && currentInput.throttle <= 0f))
		{
			if (HasFlag(Flags.Reserved2))
			{
				SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
				SendNetworkUpdate_Flags();
			}
			return;
		}
		if (playerCheckRadius > 0f && (double)lastPlayerCheck > (double)playerCheckInterval)
		{
			lastPlayerCheck = 0.0;
			List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
			Vis.Entities(((Component)this).transform.position, playerCheckRadius, list, 131072, (QueryTriggerInteraction)2);
			if (list.Count > 0)
			{
				lastCollision = TimeEx.currentTimestamp;
			}
			Pool.FreeUnmanaged<BasePlayer>(ref list);
		}
		double currentTimestamp = TimeEx.currentTimestamp;
		bool num2 = lastCollision > 0.0 && currentTimestamp - lastCollision < (double)collisionDisableTime;
		if (enableGrounding)
		{
			if (TimeSince.op_Implicit(lastGroundCheck) >= groundCheckInterval)
			{
				lastGroundCheck = TimeSince.op_Implicit(0f);
				RaycastHit val = default(RaycastHit);
				bool flag = body.SweepTest(Vector3.down, ref val, groundTraceDist, (QueryTriggerInteraction)1);
				if (!flag && isGrounded)
				{
					lastPlayerCheck = playerCheckInterval;
				}
				isGrounded = flag;
			}
		}
		else
		{
			isGrounded = false;
		}
		Vector3 val2 = ((Component)this).transform.TransformDirection(currentInput.movement);
		Vector3 val3 = default(Vector3);
		float num3 = default(float);
		Vector3Ex.ToDirectionAndMagnitude(Vector3Ex.WithY(body.velocity, 0f), ref val3, ref num3);
		float num4 = Mathf.Clamp01(num3 / leanMaxVelocity);
		Vector3 val4 = (Mathf.Approximately(((Vector3)(ref val2)).sqrMagnitude, 0f) ? ((0f - num4) * val3) : val2);
		Vector3 val5 = Vector3.up + val4 * leanWeight * num4;
		Vector3 normalized = ((Vector3)(ref val5)).normalized;
		Vector3 up = ((Component)this).transform.up;
		float num5 = Mathf.Max(Vector3.Dot(normalized, up), 0f);
		if (!num2 || isGrounded)
		{
			Vector3 val6 = ((isGrounded && currentInput.throttle <= 0f) ? Vector3.zero : (-1f * ((Component)this).transform.up * Physics.gravity.y));
			Vector3 val7 = (isGrounded ? Vector3.zero : (val2 * ((movementSpeedOverride > 0f) ? movementSpeedOverride : movementAcceleration)));
			Vector3 val8 = ((Component)this).transform.up * currentInput.throttle * ((altitudeSpeedOverride > 0f) ? altitudeSpeedOverride : altitudeAcceleration);
			Vector3 val9 = val6 + val7 + val8;
			body.AddForce(val9 * num5, (ForceMode)5);
		}
		if (!num2 && !isGrounded)
		{
			Vector3 val10 = ((Component)this).transform.TransformVector(0f, currentInput.yaw * yawSpeed, 0f);
			Vector3 val11 = Vector3.Cross(Quaternion.Euler(body.angularVelocity * uprightPrediction) * up, normalized) * uprightSpeed;
			float num6 = ((num5 < uprightDot) ? 0f : num5);
			Vector3 val12 = val10 * num5 + val11 * num6;
			body.AddTorque(val12 * num5, (ForceMode)5);
		}
		bool flag2 = !num2;
		if (flag2 != HasFlag(Flags.Reserved2))
		{
			SetFlag(Flags.Reserved2, flag2, recursive: false, networkupdate: false);
			SendNetworkUpdate_Flags();
		}
	}

	public void OnCollisionEnter(Collision collision)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			lastCollision = TimeEx.currentTimestamp;
			Vector3 relativeVelocity = collision.relativeVelocity;
			float magnitude = ((Vector3)(ref relativeVelocity)).magnitude;
			if (magnitude > hurtVelocityThreshold)
			{
				Hurt(Mathf.Pow(magnitude, hurtDamagePower), DamageType.Fall, null, useProtection: false);
			}
		}
	}

	public void OnCollisionStay()
	{
		if (base.isServer)
		{
			lastCollision = TimeEx.currentTimestamp;
		}
	}

	public override void Hurt(HitInfo info)
	{
		base.Hurt(info);
		if (base.isServer && disableWhenHurt && info.damageTypes.GetMajorityDamageType() != DamageType.Fall && Random.value < disableWhenHurtChance)
		{
			lastCollision = TimeEx.currentTimestamp;
		}
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override Vector3 GetLocalVelocityServer()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)body == (Object)null)
		{
			return Vector3.zero;
		}
		return body.velocity;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk)
		{
			info.msg.drone = Pool.Get<Drone>();
			info.msg.drone.pitch = pitch;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.drone != null)
		{
			pitch = info.msg.drone.pitch;
		}
	}

	public virtual void Update()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		Update_Server();
		if (HasFlag(Flags.Reserved2))
		{
			Quaternion localRotation = viewEyes.localRotation;
			Vector3 eulerAngles = ((Quaternion)(ref localRotation)).eulerAngles;
			eulerAngles.x = Mathf.LerpAngle(eulerAngles.x, pitch, 0.1f);
			viewEyes.localRotation = Quaternion.Euler(eulerAngles);
		}
	}

	public override bool CanChangeID(BasePlayer player)
	{
		if ((Object)(object)player != (Object)null && base.OwnerID == (ulong)player.userID)
		{
			return !HasFlag(Flags.Reserved2);
		}
		return false;
	}

	public override bool CanPickup(BasePlayer player)
	{
		if (base.CanPickup(player))
		{
			return !HasFlag(Flags.Reserved2);
		}
		return false;
	}

	public override void OnPickedUpPreItemMove(Item createdItem, BasePlayer player)
	{
		base.OnPickedUpPreItemMove(createdItem, player);
		if ((Object)(object)player != (Object)null && (ulong)player.userID == base.OwnerID)
		{
			createdItem.text = GetIdentifier();
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		base.OnDeployed(parent, deployedBy, fromItem);
		Transform transform = ((Component)this).transform;
		transform.position += ((Component)this).transform.up * deployYOffset;
		if ((Object)(object)body != (Object)null)
		{
			body.velocity = Vector3.zero;
			body.angularVelocity = Vector3.zero;
		}
		if (fromItem != null && !string.IsNullOrEmpty(fromItem.text) && ComputerStation.IsValidIdentifier(fromItem.text))
		{
			UpdateIdentifier(fromItem.text);
		}
	}

	public override bool ShouldNetworkOwnerInfo()
	{
		return true;
	}

	public override bool ShouldInheritNetworkGroup()
	{
		return false;
	}

	public override float MaxVelocity()
	{
		return 30f;
	}
}


using UnityEngine;

public struct DroneInputState
{
	public Vector3 movement;

	public float throttle;

	public float pitch;

	public float yaw;

	public void Reset()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		movement = Vector3.zero;
		pitch = 0f;
		yaw = 0f;
	}
}


using UnityEngine;

public class DropBox : Mailbox
{
	public Transform EyePoint;

	public override bool PlayerIsOwner(BasePlayer player)
	{
		return PlayerBehind(player);
	}

	public bool PlayerBehind(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 val = ((Component)player).transform.position - ((Component)this).transform.position;
		if (Vector3.Dot(forward, ((Vector3)(ref val)).normalized) <= -0.3f)
		{
			return GamePhysics.LineOfSight(player.eyes.position, EyePoint.position, 2162688);
		}
		return false;
	}

	public bool PlayerInfront(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 val = ((Component)player).transform.position - ((Component)this).transform.position;
		return Vector3.Dot(forward, ((Vector3)(ref val)).normalized) >= 0.7f;
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}
}


using System;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class Elevator : IOEntity, IFlagNotify
{
	public enum Direction
	{
		Up,
		Down
	}

	public Transform LiftRoot;

	public GameObjectRef LiftEntityPrefab;

	public GameObjectRef IoEntityPrefab;

	public Transform IoEntitySpawnPoint;

	public GameObject FloorBlockerVolume;

	public float LiftSpeedPerMetre = 1f;

	public GameObject[] PoweredObjects;

	public MeshRenderer PoweredMesh;

	[ColorUsage(true, true)]
	public Color PoweredLightColour;

	[ColorUsage(true, true)]
	public Color UnpoweredLightColour;

	public float LiftMoveDelay;

	protected const Flags TopFloorFlag = Flags.Reserved1;

	public const Flags ElevatorPowered = Flags.Reserved2;

	public EntityRef<ElevatorLift> liftEntity;

	public IOEntity ioEntity;

	public int[] previousPowerAmount = new int[2];

	public virtual bool IsStatic => false;

	public int Floor { get; set; }

	public bool IsTop => HasFlag(Flags.Reserved1);

	public virtual float FloorHeight => 3f;

	public override void Load(LoadInfo info)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.elevator != null)
		{
			Floor = info.msg.elevator.floor;
			liftEntity.uid = info.msg.elevator.spawnedLift;
		}
		if ((Object)(object)FloorBlockerVolume != (Object)null)
		{
			FloorBlockerVolume.SetActive(Floor > 0);
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		Elevator elevatorInDirection = GetElevatorInDirection(Direction.Down);
		if ((Object)(object)elevatorInDirection != (Object)null)
		{
			elevatorInDirection.SetFlag(Flags.Reserved1, b: false);
			Floor = elevatorInDirection.Floor + 1;
		}
		SetFlag(Flags.Reserved1, b: true);
		UpdateChildEntities(isTop: true);
		SendNetworkUpdate();
	}

	public virtual void CallElevator()
	{
		EntityLinkBroadcast(delegate(Elevator elevatorEnt)
		{
			if (elevatorEnt.IsTop && Interface.CallHook("OnElevatorCall", (object)this, (object)elevatorEnt) == null)
			{
				elevatorEnt.RequestMoveLiftTo(Floor, out var _, this);
			}
		}, (ConstructionSocket socket) => socket.socketType == ConstructionSocket.Type.Elevator);
	}

	public void Server_RaiseLowerElevator(Direction dir, bool goTopBottom)
	{
		if (IsBusy())
		{
			return;
		}
		int num = LiftPositionToFloor();
		switch (dir)
		{
		case Direction.Up:
			num++;
			if (goTopBottom)
			{
				num = Floor;
			}
			break;
		case Direction.Down:
			num--;
			if (goTopBottom)
			{
				num = 0;
			}
			break;
		}
		RequestMoveLiftTo(num, out var _, this);
	}

	public bool RequestMoveLiftTo(int targetFloor, out float timeToTravel, Elevator fromElevator)
	{
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		timeToTravel = 0f;
		if (Interface.CallHook("OnElevatorMove", (object)this, (object)targetFloor) != null)
		{
			return false;
		}
		if (IsBusy())
		{
			return false;
		}
		if (!IsStatic && (Object)(object)ioEntity != (Object)null && !ioEntity.IsPowered())
		{
			return false;
		}
		if (!IsValidFloor(targetFloor))
		{
			return false;
		}
		int num = LiftPositionToFloor();
		if (num == targetFloor)
		{
			OpenDoorsAtFloor(num);
			return false;
		}
		if (!liftEntity.IsValid(base.isServer))
		{
			return false;
		}
		ElevatorLift elevatorLift = liftEntity.Get(base.isServer);
		if (!elevatorLift.CanMove())
		{
			return false;
		}
		Vector3 worldSpaceFloorPosition = GetWorldSpaceFloorPosition(targetFloor);
		if (!GamePhysics.LineOfSight(((Component)elevatorLift).transform.position, worldSpaceFloorPosition, 2097152))
		{
			return false;
		}
		OnMoveBegin();
		timeToTravel = TimeToTravelDistance(Mathf.Abs(((Component)elevatorLift).transform.position.y - worldSpaceFloorPosition.y));
		LeanTween.moveY(((Component)elevatorLift).gameObject, worldSpaceFloorPosition.y, timeToTravel).delay = LiftMoveDelay;
		timeToTravel += LiftMoveDelay;
		SetFlag(Flags.Busy, b: true);
		if (targetFloor < Floor)
		{
			elevatorLift.ToggleHurtTrigger(state: true);
		}
		elevatorLift.SetFlag(Flags.Busy, b: true);
		((FacepunchBehaviour)this).Invoke((Action)ClearBusy, timeToTravel + 1f);
		elevatorLift.NotifyNewFloor(targetFloor, Floor);
		EntityLinkBroadcast(delegate(Elevator elevatorEnt)
		{
			elevatorEnt.SetFlag(Flags.Busy, b: true);
		}, (ConstructionSocket socket) => socket.socketType == ConstructionSocket.Type.Elevator);
		if ((Object)(object)ioEntity != (Object)null)
		{
			ioEntity.SetFlag(Flags.Busy, b: true);
			ioEntity.SendChangedToRoot(forceUpdate: true);
		}
		return true;
	}

	protected virtual void OpenLiftDoors()
	{
		NotifyLiftEntityDoorsOpen(state: true);
	}

	public virtual void OnMoveBegin()
	{
	}

	public float TimeToTravelDistance(float distance)
	{
		return distance / LiftSpeedPerMetre;
	}

	public virtual Vector3 GetWorldSpaceFloorPosition(int targetFloor)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		int num = Floor - targetFloor;
		Vector3 val = Vector3.up * ((float)num * FloorHeight);
		val.y -= 1f;
		return ((Component)this).transform.position - val;
	}

	public virtual void ClearBusy()
	{
		SetFlag(Flags.Busy, b: false);
		if (liftEntity.IsValid(base.isServer))
		{
			liftEntity.Get(base.isServer).ToggleHurtTrigger(state: false);
			liftEntity.Get(base.isServer).SetFlag(Flags.Busy, b: false);
		}
		if ((Object)(object)ioEntity != (Object)null)
		{
			ioEntity.SetFlag(Flags.Busy, b: false);
			ioEntity.SendChangedToRoot(forceUpdate: true);
		}
		EntityLinkBroadcast(delegate(Elevator elevatorEnt)
		{
			elevatorEnt.SetFlag(Flags.Busy, b: false);
		}, (ConstructionSocket socket) => socket.socketType == ConstructionSocket.Type.Elevator);
	}

	public virtual bool IsValidFloor(int targetFloor)
	{
		if (targetFloor <= Floor)
		{
			return targetFloor >= 0;
		}
		return false;
	}

	public Elevator GetElevatorInDirection(Direction dir)
	{
		EntityLink entityLink = FindLink((dir == Direction.Down) ? "elevator/sockets/elevator-male" : "elevator/sockets/elevator-female");
		if (entityLink != null && !entityLink.IsEmpty())
		{
			BaseEntity owner = entityLink.connections[0].owner;
			if ((Object)(object)owner != (Object)null && owner.isServer && owner is Elevator elevator && (Object)(object)elevator != (Object)(object)this)
			{
				return elevator;
			}
		}
		return null;
	}

	public void UpdateChildEntities(bool isTop)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		if (isTop)
		{
			if (!liftEntity.IsValid(base.isServer))
			{
				FindExistingLiftChild();
			}
			if (!liftEntity.IsValid(base.isServer))
			{
				ElevatorLift elevatorLift = GameManager.server.CreateEntity(LiftEntityPrefab.resourcePath, GetWorldSpaceFloorPosition(Floor), LiftRoot.rotation) as ElevatorLift;
				elevatorLift.SetOwnerElevator(this);
				elevatorLift.Spawn();
				liftEntity.Set(elevatorLift);
			}
			if (liftEntity.IsValid(base.isServer))
			{
				if ((Object)(object)liftEntity.Get(base.isServer).GetParentEntity() == (Object)(object)this)
				{
					liftEntity.Get(base.isServer).SetParent(null, worldPositionStays: true);
				}
				liftEntity.Get(base.isServer).SetOwnerElevator(this);
				liftEntity.Get(base.isServer).SetFlag(Flags.Reserved5, HasFlag(Flags.Reserved2) || IsStatic);
			}
			if ((Object)(object)ioEntity == (Object)null)
			{
				FindExistingIOChild();
			}
			if ((Object)(object)ioEntity == (Object)null && IoEntityPrefab.isValid)
			{
				ioEntity = GameManager.server.CreateEntity(IoEntityPrefab.resourcePath, IoEntitySpawnPoint.position, IoEntitySpawnPoint.rotation) as IOEntity;
				ioEntity.SetParent(this, worldPositionStays: true);
				ioEntity.Spawn();
			}
		}
		else
		{
			if (liftEntity.IsValid(base.isServer))
			{
				liftEntity.Get(base.isServer).Kill();
				liftEntity.Set(null);
			}
			if ((Object)(object)ioEntity != (Object)null)
			{
				ioEntity.Kill();
			}
		}
	}

	public void FindExistingIOChild()
	{
		foreach (BaseEntity child in children)
		{
			if (child is IOEntity iOEntity)
			{
				ioEntity = iOEntity;
				break;
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.elevator == null)
		{
			info.msg.elevator = Pool.Get<Elevator>();
		}
		info.msg.elevator.floor = Floor;
		info.msg.elevator.spawnedLift = liftEntity.uid;
	}

	public int LiftPositionToFloor()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (!liftEntity.IsValid(base.isServer))
		{
			return 0;
		}
		Vector3 position = ((Component)liftEntity.Get(base.isServer)).transform.position;
		int result = -1;
		float num = float.MaxValue;
		for (int i = 0; i <= Floor; i++)
		{
			float num2 = Vector3.Distance(GetWorldSpaceFloorPosition(i), position);
			if (num2 < num)
			{
				num = num2;
				result = i;
			}
		}
		return result;
	}

	public override void DestroyShared()
	{
		Cleanup();
		base.DestroyShared();
	}

	private void Cleanup()
	{
		Elevator elevatorInDirection = GetElevatorInDirection(Direction.Down);
		if ((Object)(object)elevatorInDirection != (Object)null)
		{
			elevatorInDirection.SetFlag(Flags.Reserved1, b: true);
		}
		Elevator elevatorInDirection2 = GetElevatorInDirection(Direction.Up);
		if ((Object)(object)elevatorInDirection2 != (Object)null)
		{
			elevatorInDirection2.Kill(DestroyMode.Gib);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.Busy, b: false);
		UpdateChildEntities(IsTop);
		if ((Object)(object)ioEntity != (Object)null)
		{
			ioEntity.SetFlag(Flags.Busy, b: false);
		}
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		base.UpdateHasPower(inputAmount, inputSlot);
		if (inputAmount > 0 && previousPowerAmount[inputSlot] == 0)
		{
			CallElevator();
		}
		previousPowerAmount[inputSlot] = inputAmount;
	}

	private void OnPhysicsNeighbourChanged()
	{
		if (!IsStatic && (Object)(object)GetElevatorInDirection(Direction.Down) == (Object)null && !HasFloorSocketConnection())
		{
			Kill(DestroyMode.Gib);
		}
	}

	public bool HasFloorSocketConnection()
	{
		EntityLink entityLink = FindLink("elevator/sockets/block-male");
		if (entityLink != null && !entityLink.IsEmpty())
		{
			return true;
		}
		return false;
	}

	public void NotifyLiftEntityDoorsOpen(bool state)
	{
		if (!liftEntity.IsValid(base.isServer))
		{
			return;
		}
		foreach (BaseEntity child in liftEntity.Get(base.isServer).children)
		{
			if (child is Door door)
			{
				door.SetOpen(state);
			}
		}
	}

	protected virtual void OpenDoorsAtFloor(int floor)
	{
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if ((Object)(object)liftEntity.Get(base.isServer) != (Object)null)
		{
			liftEntity.Get(base.isServer).Kill();
		}
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if ((Object)(object)liftEntity.Get(base.isServer) != (Object)null)
		{
			liftEntity.Get(base.isServer).Kill(DestroyMode.Gib);
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!Application.isLoading && base.isServer && old.HasFlag(Flags.Reserved1) != next.HasFlag(Flags.Reserved1))
		{
			UpdateChildEntities(next.HasFlag(Flags.Reserved1));
			SendNetworkUpdate();
		}
		if (base.isServer)
		{
			ElevatorLift elevatorLift = liftEntity.Get(base.isServer);
			if ((Object)(object)elevatorLift != (Object)null)
			{
				elevatorLift.SetFlag(Flags.Reserved5, HasFlag(Flags.Reserved2) || IsStatic);
			}
		}
		if (old.HasFlag(Flags.Reserved1) != next.HasFlag(Flags.Reserved1) && (Object)(object)FloorBlockerVolume != (Object)null)
		{
			FloorBlockerVolume.SetActive(next.HasFlag(Flags.Reserved1));
		}
	}

	public void FindExistingLiftChild()
	{
		foreach (BaseEntity child in children)
		{
			if (child is ElevatorLift entity)
			{
				liftEntity.Set(entity);
				break;
			}
		}
	}

	public void OnFlagToggled(bool state)
	{
		if (base.isServer)
		{
			SetFlag(Flags.Reserved2, state);
			ElevatorLift elevatorLift = liftEntity.Get(base.isServer);
			if ((Object)(object)elevatorLift != (Object)null)
			{
				elevatorLift.SetFlag(Flags.Reserved5, HasFlag(Flags.Reserved2) || IsStatic);
			}
		}
	}
}


public enum Direction
{
	Up,
	Down
}


using System;
using UnityEngine;

public class ElevatorButton : MonoBehaviour, IClientComponent
{
	[Flags]
	public enum ElevatorOption
	{
		GoUp = 1,
		GoUpExpress = 2,
		GoDown = 4,
		GoDownExpress = 8
	}

	public ElevatorOption AvailableActions;

	public Collider AttachedCollider;
}


using System;

[Flags]
public enum ElevatorOption
{
	GoUp = 1,
	GoUpExpress = 2,
	GoDown = 4,
	GoDownExpress = 8
}


using UnityEngine;

public class ElevatorLiftPlayer : ElevatorLift
{
	public Transform CableRoot;

	public Transform CableRootTop;

	public float CableRootOffset;

	public float CableRootTopOffset;
}


using Rust;
using UnityEngine;

public class ElevatorLiftStatic : ElevatorLift
{
	public GameObjectRef ElevatorDoorRef;

	public Transform ElevatorDoorLocation;

	public bool BlockPerFloorMovement;

	private const Flags CanGoUp = Flags.Reserved3;

	private const Flags CanGoDown = Flags.Reserved4;

	public override void ServerInit()
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (ElevatorDoorRef.isValid && (Object)(object)ElevatorDoorLocation != (Object)null && !Application.isLoadingSave)
		{
			foreach (BaseEntity child in children)
			{
				if (child is Door)
				{
					return;
				}
			}
			BaseEntity baseEntity = GameManager.server.CreateEntity(ElevatorDoorRef.resourcePath, ElevatorDoorLocation.localPosition, ElevatorDoorLocation.localRotation);
			baseEntity.SetParent(this);
			baseEntity.Spawn();
		}
		SetFlag(Flags.Reserved3, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved4, b: true);
	}

	public override void NotifyNewFloor(int newFloor, int totalFloors)
	{
		base.NotifyNewFloor(newFloor, totalFloors);
		SetFlag(Flags.Reserved3, newFloor < totalFloors);
		SetFlag(Flags.Reserved4, newFloor > 0);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

public class ElevatorStatic : Elevator
{
	public bool StaticTop;

	public const Flags LiftRecentlyArrived = Flags.Reserved3;

	public List<ElevatorStatic> floorPositions = new List<ElevatorStatic>();

	public ElevatorStatic ownerElevator;

	public override bool IsStatic => true;

	public override void Spawn()
	{
		base.Spawn();
		SetFlag(Flags.Reserved2, b: true);
		SetFlag(Flags.Reserved1, StaticTop);
		if (!Application.isLoadingSave)
		{
			UpdateFloorPositions();
		}
	}

	private void UpdateFloorPositions()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (!base.IsTop)
		{
			return;
		}
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAll(new Ray(((Component)this).transform.position, -Vector3.up), 0f, list, 200f, 262144, (QueryTriggerInteraction)2);
		foreach (RaycastHit item in list)
		{
			RaycastHit current = item;
			if ((Object)(object)((RaycastHit)(ref current)).transform.parent != (Object)null)
			{
				ElevatorStatic component = ((Component)((RaycastHit)(ref current)).transform.parent).GetComponent<ElevatorStatic>();
				if (!((Object)(object)component == (Object)null) && !((Object)(object)component == (Object)(object)this) && !component.isClient && !component.IsDestroyed)
				{
					floorPositions.Add(component);
				}
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		floorPositions.Reverse();
		base.Floor = floorPositions.Count;
		for (int i = 0; i < floorPositions.Count; i++)
		{
			floorPositions[i].SetFloorDetails(i, this);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		UpdateFloorPositions();
	}

	public override void PostMapEntitySpawn()
	{
		base.PostMapEntitySpawn();
		UpdateChildEntities(base.IsTop);
	}

	public override bool IsValidFloor(int targetFloor)
	{
		if (targetFloor >= 0)
		{
			return targetFloor <= base.Floor;
		}
		return false;
	}

	public override Vector3 GetWorldSpaceFloorPosition(int targetFloor)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if (targetFloor == base.Floor)
		{
			return ((Component)this).transform.position + Vector3.up * 1f;
		}
		Vector3 position = ((Component)this).transform.position;
		position.y = ((Component)floorPositions[targetFloor]).transform.position.y + 1f;
		return position;
	}

	public void SetFloorDetails(int floor, ElevatorStatic owner)
	{
		ownerElevator = owner;
		base.Floor = floor;
	}

	public override void CallElevator()
	{
		if ((Object)(object)ownerElevator != (Object)null)
		{
			ownerElevator.RequestMoveLiftTo(base.Floor, out var _, this);
		}
		else if (base.IsTop)
		{
			RequestMoveLiftTo(base.Floor, out var _, this);
		}
	}

	public ElevatorStatic ElevatorAtFloor(int floor)
	{
		if (floor == base.Floor)
		{
			return this;
		}
		if (floor >= 0 && floor < floorPositions.Count)
		{
			return floorPositions[floor];
		}
		return null;
	}

	protected override void OpenDoorsAtFloor(int floor)
	{
		base.OpenDoorsAtFloor(floor);
		if (floor == floorPositions.Count)
		{
			OpenLiftDoors();
		}
		else
		{
			floorPositions[floor].OpenLiftDoors();
		}
	}

	public override void OnMoveBegin()
	{
		base.OnMoveBegin();
		ElevatorStatic elevatorStatic = ElevatorAtFloor(LiftPositionToFloor());
		if ((Object)(object)elevatorStatic != (Object)null)
		{
			elevatorStatic.OnLiftLeavingFloor();
		}
		NotifyLiftEntityDoorsOpen(state: false);
	}

	public void OnLiftLeavingFloor()
	{
		ClearPowerOutput();
		if (((FacepunchBehaviour)this).IsInvoking((Action)ClearPowerOutput))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)ClearPowerOutput);
		}
	}

	public override void ClearBusy()
	{
		base.ClearBusy();
		ElevatorStatic elevatorStatic = ElevatorAtFloor(LiftPositionToFloor());
		if ((Object)(object)elevatorStatic != (Object)null)
		{
			elevatorStatic.OnLiftArrivedAtFloor();
		}
		NotifyLiftEntityDoorsOpen(state: true);
	}

	protected override void OpenLiftDoors()
	{
		base.OpenLiftDoors();
		OnLiftArrivedAtFloor();
	}

	public void OnLiftArrivedAtFloor()
	{
		SetFlag(Flags.Reserved3, b: true);
		MarkDirty();
		((FacepunchBehaviour)this).Invoke((Action)ClearPowerOutput, 10f);
	}

	public void ClearPowerOutput()
	{
		SetFlag(Flags.Reserved3, b: false);
		MarkDirty();
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!HasFlag(Flags.Reserved3))
		{
			return 0;
		}
		return 1;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk)
		{
			SetFlag(Flags.Reserved3, b: false);
		}
	}
}


using UnityEngine;

public class FrankensteinTableVisuals : MonoBehaviour
{
	public GameObject FXReady;

	public GameObject FXNotReady;

	public GameObject FXWake;

	public Transform HeadVisualAnchor;

	public Transform TorsoVisualAnchor;

	public Transform LegsVisualAnchor;

	public Animator Animator;
}


using System;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class HitchTrough : StorageContainer
{
	[Serializable]
	public class HitchSpot
	{
		public HitchTrough owner;

		public Transform tr;

		public EntityRef hitchableEntRef;

		public IHitchable GetHitchable(bool isServer = true)
		{
			return hitchableEntRef.Get(isServer) as IHitchable;
		}

		public bool IsOccupied(bool isServer = true)
		{
			return hitchableEntRef.IsValid(isServer);
		}

		public void SetOccupiedBy(IHitchable hitchable)
		{
			if (hitchable == null)
			{
				hitchableEntRef.Set(null);
				return;
			}
			BaseEntity baseEntity = hitchable as BaseEntity;
			if ((Object)(object)baseEntity != (Object)null)
			{
				hitchableEntRef.Set(baseEntity);
			}
		}
	}

	public interface IHitchable
	{
		void SetHitch(HitchTrough hitch, HitchSpot spot);
	}

	public HitchSpot[] hitchSpots;

	public float caloriesToDecaySeconds = 36f;

	public override void PostServerLoad()
	{
		HitchSpot[] array = hitchSpots;
		foreach (HitchSpot hitchSpot in array)
		{
			AttemptToHitch(hitchSpot.GetHitchable(), hitchSpot);
		}
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			UnHitchAll();
		}
		base.DestroyShared();
	}

	public Item GetFoodItem()
	{
		foreach (Item item in base.inventory.itemList)
		{
			if (item.info.category == ItemCategory.Food && Object.op_Implicit((Object)(object)((Component)item.info).GetComponent<ItemModConsumable>()))
			{
				return item;
			}
		}
		return null;
	}

	public bool HasSpace()
	{
		HitchSpot[] array = hitchSpots;
		for (int i = 0; i < array.Length; i++)
		{
			if (!array[i].IsOccupied())
			{
				return true;
			}
		}
		return false;
	}

	public bool IsValidHitchPosition(Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GetClosestSpot(pos, includeOccupied: false, 1f) != null;
	}

	public bool AttemptToHitch(IHitchable hitchable, HitchSpot spot = null)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (hitchable == null)
		{
			return false;
		}
		if (spot == null)
		{
			BaseEntity baseEntity = hitchable as BaseEntity;
			if ((Object)(object)baseEntity != (Object)null)
			{
				spot = GetClosestSpot(((Component)baseEntity).transform.position);
			}
		}
		if (spot != null)
		{
			object obj = Interface.CallHook("OnHorseHitch", (object)hitchable, (object)spot);
			if (obj is bool)
			{
				return (bool)obj;
			}
			spot.SetOccupiedBy(hitchable);
			hitchable.SetHitch(this, spot);
			return true;
		}
		return false;
	}

	public HitchSpot GetClosestSpot(Vector3 testPos, bool includeOccupied = false, float maxRadius = -1f)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		float num = 10000f;
		HitchSpot result = null;
		for (int i = 0; i < hitchSpots.Length; i++)
		{
			float num2 = Vector3.Distance(testPos, hitchSpots[i].tr.position);
			if (num2 < num && (maxRadius == -1f || num2 <= maxRadius) && (includeOccupied || !hitchSpots[i].IsOccupied()))
			{
				num = num2;
				result = hitchSpots[i];
			}
		}
		return result;
	}

	public void UnHitch(IHitchable hitchable)
	{
		HitchSpot[] array = hitchSpots;
		foreach (HitchSpot hitchSpot in array)
		{
			if (hitchSpot.GetHitchable(base.isServer) == hitchable)
			{
				if (Interface.CallHook("OnHorseUnhitch", (object)hitchable, (object)hitchSpot) != null)
				{
					break;
				}
				hitchSpot.SetOccupiedBy(null);
				hitchable.SetHitch(null, null);
			}
		}
	}

	public void UnHitchAll()
	{
		HitchSpot[] array = hitchSpots;
		for (int i = 0; i < array.Length; i++)
		{
			IHitchable hitchable = array[i].GetHitchable();
			if (hitchable != null)
			{
				UnHitch(hitchable);
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.ioEntity = Pool.Get<IOEntity>();
		info.msg.ioEntity.genericEntRef1 = hitchSpots[0].hitchableEntRef.uid;
		info.msg.ioEntity.genericEntRef2 = hitchSpots[1].hitchableEntRef.uid;
	}

	public override void Load(LoadInfo info)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			hitchSpots[0].hitchableEntRef.uid = info.msg.ioEntity.genericEntRef1;
			hitchSpots[1].hitchableEntRef.uid = info.msg.ioEntity.genericEntRef2;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class HitchSpot
{
	public HitchTrough owner;

	public Transform tr;

	public EntityRef hitchableEntRef;

	public IHitchable GetHitchable(bool isServer = true)
	{
		return hitchableEntRef.Get(isServer) as IHitchable;
	}

	public bool IsOccupied(bool isServer = true)
	{
		return hitchableEntRef.IsValid(isServer);
	}

	public void SetOccupiedBy(IHitchable hitchable)
	{
		if (hitchable == null)
		{
			hitchableEntRef.Set(null);
			return;
		}
		BaseEntity baseEntity = hitchable as BaseEntity;
		if ((Object)(object)baseEntity != (Object)null)
		{
			hitchableEntRef.Set(baseEntity);
		}
	}
}


public interface IHitchable
{
	void SetHitch(HitchTrough hitch, HitchSpot spot);
}


public class HotAirBalloonArmor : HotAirBalloonEquipment
{
	public float AdditionalHealth = 100f;

	public override void Added(HotAirBalloon hab, bool fromSave)
	{
		base.Added(hab, fromSave);
		hab.SetMaxHealth(hab.MaxHealth() + AdditionalHealth);
		if (!fromSave)
		{
			hab.health += AdditionalHealth;
		}
		SendNetworkUpdate();
	}

	public override void Removed(HotAirBalloon hab)
	{
		base.Removed(hab);
		hab.DelayNextUpgrade(DelayNextUpgradeOnRemoveDuration);
	}

	public override void Hurt(HitInfo info)
	{
		if (HasParent() && GetParentEntity() is HotAirBalloon { baseProtection: var protectionProperties } hotAirBalloon)
		{
			hotAirBalloon.baseProtection = baseProtection;
			hotAirBalloon.Hurt(info);
			hotAirBalloon.baseProtection = protectionProperties;
		}
	}
}


using UnityEngine;

public class HotAirBalloonEquipment : BaseCombatEntity
{
	[SerializeField]
	private DamageRenderer damageRenderer;

	[HideInInspector]
	public float DelayNextUpgradeOnRemoveDuration;

	private EntityRef<HotAirBalloon> hotAirBalloon;

	public virtual void Added(HotAirBalloon hab, bool fromSave)
	{
		hotAirBalloon.Set(hab);
	}

	public virtual void Removed(HotAirBalloon hab)
	{
		hotAirBalloon.Set(null);
	}

	public override void DoRepair(BasePlayer player)
	{
		HotAirBalloon hotAirBalloon = this.hotAirBalloon.Get(serverside: true);
		if (hotAirBalloon.IsValid())
		{
			hotAirBalloon.DoRepair(player);
		}
	}
}


public class AudioAlarm : IOEntity
{
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ElectricBattery : IOEntity, IInstanceDataReceiver
{
	public int maxOutput;

	public float maxCapactiySeconds;

	public float rustWattSeconds;

	[Tooltip("How much energy we can request from power sources for charging is this value multiplied by our maxOutput")]
	public float maximumInboundEnergyRatio = 4f;

	public bool rechargable;

	public float chargeRatio = 0.25f;

	private int activeDrain;

	private float lastChargeIn;

	private const float tickRateSeconds = 1f;

	public const Flags Flag_HalfFull = Flags.Reserved5;

	public const Flags Flag_VeryFull = Flags.Reserved6;

	public const Flags Flag_Full = Flags.Reserved9;

	private bool wasLoaded;

	private HashSet<(IOEntity entity, int inputIndex)> connectedList = new HashSet<(IOEntity, int)>();

	private HashSet<(IOEntity entity, int inputIndex)> auxConnectedList = new HashSet<(IOEntity, int)>();

	private Queue<int> inputHistory = new Queue<int>();

	private const int inputHistorySize = 5;

	public override bool IsRootEntity()
	{
		return true;
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override int MaximalPowerOutput()
	{
		return maxOutput;
	}

	public int GetActiveDrain()
	{
		if (!IsOn())
		{
			return 0;
		}
		return activeDrain;
	}

	public void ReceiveInstanceData(InstanceData data)
	{
		rustWattSeconds = data.dataInt;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)CheckDischarge, Random.Range(0f, 1f), 1f, 0.1f);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		wasLoaded = true;
	}

	public override void OnPickedUp(Item createdItem, BasePlayer player)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Expected O, but got Unknown
		base.OnPickedUp(createdItem, player);
		if (createdItem.instanceData == null)
		{
			createdItem.instanceData = new InstanceData();
		}
		createdItem.instanceData.ShouldPool = false;
		createdItem.instanceData.dataInt = Mathf.FloorToInt(rustWattSeconds);
	}

	public override int GetCurrentEnergy()
	{
		return currentEnergy;
	}

	public int GetDrain()
	{
		connectedList.Clear();
		auxConnectedList.Clear();
		IOEntity iOEntity = outputs[0].connectedTo.Get();
		if ((Object)(object)iOEntity != (Object)null)
		{
			int connectedToSlot = outputs[0].connectedToSlot;
			if (iOEntity.WantsPower(connectedToSlot))
			{
				AddConnectedRecursive(iOEntity, connectedToSlot, ref connectedList);
			}
			else
			{
				connectedList.Add((iOEntity, connectedToSlot));
			}
		}
		int num = 0;
		if (HasFlag(Flags.Reserved9))
		{
			IOEntity iOEntity2 = outputs[1].connectedTo.Get();
			if ((Object)(object)iOEntity2 != (Object)null)
			{
				int connectedToSlot2 = outputs[1].connectedToSlot;
				if (iOEntity2.WantsPower(connectedToSlot2))
				{
					AddConnectedRecursive(iOEntity2, connectedToSlot2, ref auxConnectedList);
				}
				else
				{
					auxConnectedList.Add((iOEntity2, connectedToSlot2));
				}
			}
			foreach (var auxConnected in auxConnectedList)
			{
				if (auxConnected.entity.ShouldDrainBattery(this))
				{
					num += auxConnected.entity.DesiredPower(auxConnected.inputIndex);
					if (num >= 1)
					{
						num = 1;
						break;
					}
				}
			}
		}
		int num2 = num;
		foreach (var connected in connectedList)
		{
			if (connected.entity.ShouldDrainBattery(this))
			{
				num2 += connected.entity.DesiredPower(connected.inputIndex);
				if (num2 >= maxOutput)
				{
					num2 = maxOutput;
					break;
				}
			}
		}
		return num2;
	}

	public void AddConnectedRecursive(IOEntity root, int inputIndex, ref HashSet<(IOEntity, int)> listToUse)
	{
		listToUse.Add((root, inputIndex));
		if (!root.WantsPassthroughPower())
		{
			return;
		}
		for (int i = 0; i < root.outputs.Length; i++)
		{
			if (!root.AllowDrainFrom(i))
			{
				continue;
			}
			IOSlot iOSlot = root.outputs[i];
			if (iOSlot.type == IOType.Electric)
			{
				IOEntity iOEntity = iOSlot.connectedTo.Get();
				if ((Object)(object)iOEntity != (Object)null && !listToUse.Contains((iOEntity, iOSlot.connectedToSlot)) && iOEntity.WantsPower(iOSlot.connectedToSlot))
				{
					AddConnectedRecursive(iOEntity, iOSlot.connectedToSlot, ref listToUse);
				}
			}
		}
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		if (rustWattSeconds >= maxCapactiySeconds)
		{
			return 0;
		}
		if (!IsFlickering())
		{
			return Mathf.Min(currentEnergy, Mathf.FloorToInt((float)maxOutput * maximumInboundEnergyRatio));
		}
		return GetHighestInputFromHistory();
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		if (IsFlickering())
		{
			if (inputHistory.Count >= 5)
			{
				inputHistory.Dequeue();
			}
			inputHistory.Enqueue(inputAmount);
		}
		if (inputSlot == 0 && rechargable)
		{
			if (!IsPowered() && !IsFlickering())
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)AddCharge);
				lastChargeIn = 0f;
			}
			else if (!((FacepunchBehaviour)this).IsInvoking((Action)AddCharge))
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)AddCharge, 1f, 1f, 0.1f);
			}
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		switch (outputSlot)
		{
		case 0:
			if (IsOn())
			{
				return Mathf.FloorToInt((float)maxOutput * ((rustWattSeconds >= 1f) ? 1f : 0f));
			}
			return 0;
		case 1:
			if (!HasFlag(Flags.Reserved9))
			{
				return 0;
			}
			return 1;
		default:
			return 0;
		}
	}

	public override bool WantsPower(int inputIndex)
	{
		return rustWattSeconds < maxCapactiySeconds;
	}

	public override void SendAdditionalData(BasePlayer player, int slot, bool input)
	{
		int passthroughAmountForAnySlot = GetPassthroughAmountForAnySlot(slot, input);
		ClientRPC(RpcTarget.Player("Client_ReceiveAdditionalData", player), currentEnergy, passthroughAmountForAnySlot, rustWattSeconds, (float)activeDrain);
	}

	public override void OnCircuitChanged(bool forceUpdate)
	{
		base.OnCircuitChanged(forceUpdate);
		int drain = GetDrain();
		activeDrain = drain;
	}

	public void CheckDischarge()
	{
		if (rustWattSeconds < 5f)
		{
			SetDischarging(wantsOn: false);
			return;
		}
		IOEntity iOEntity = outputs[0].connectedTo.Get();
		IOEntity iOEntity2 = outputs[1].connectedTo.Get();
		int drain = GetDrain();
		activeDrain = drain;
		SetDischarging((Object)(object)iOEntity != (Object)null || (Object)(object)iOEntity2 != (Object)null);
	}

	public void SetDischarging(bool wantsOn)
	{
		SetPassthroughOn(wantsOn);
	}

	private int GetHighestInputFromHistory()
	{
		int num = 0;
		foreach (int item in inputHistory)
		{
			if (item > num)
			{
				num = item;
			}
		}
		return num;
	}

	public void TickUsage()
	{
		float oldCharge = rustWattSeconds;
		bool num = rustWattSeconds > 0f;
		if (rustWattSeconds >= 1f)
		{
			float num2 = 1f * (float)activeDrain;
			rustWattSeconds -= num2;
		}
		if (rustWattSeconds <= 0f)
		{
			rustWattSeconds = 0f;
		}
		bool flag = rustWattSeconds > 0f;
		ChargeChanged(oldCharge);
		if (num != flag)
		{
			MarkDirty();
			SendNetworkUpdate();
		}
	}

	public virtual void ChargeChanged(float oldCharge)
	{
		bool flag = rustWattSeconds > maxCapactiySeconds * 0.25f;
		bool flag2 = rustWattSeconds > maxCapactiySeconds * 0.75f;
		if (HasFlag(Flags.Reserved5) != flag || HasFlag(Flags.Reserved6) != flag2)
		{
			SetFlag(Flags.Reserved5, flag);
			SetFlag(Flags.Reserved6, flag2);
			SendNetworkUpdate_Flags();
		}
		RefreshFullChargeFlag();
	}

	private void RefreshFullChargeFlag()
	{
		bool flag = (float)Mathf.RoundToInt(rustWattSeconds / 60f) >= maxCapactiySeconds / 60f;
		bool flag2 = HasFlag(Flags.Reserved9);
		if (flag && !flag2)
		{
			SetFlag(Flags.Reserved9, b: true);
			MarkDirtyForceUpdateOutputs();
		}
		else if (!flag && flag2 && ((float)activeDrain > lastChargeIn || lastChargeIn == 0f))
		{
			SetFlag(Flags.Reserved9, b: false);
			MarkDirtyForceUpdateOutputs();
		}
	}

	public void SetCharge(float charge)
	{
		float oldCharge = rustWattSeconds;
		rustWattSeconds = charge;
		ChargeChanged(oldCharge);
	}

	public void AddCharge()
	{
		float oldCharge = rustWattSeconds;
		float num = (lastChargeIn = (float)Mathf.Min(IsFlickering() ? GetHighestInputFromHistory() : currentEnergy, DesiredPower()) * 1f * chargeRatio);
		if (num > 0f)
		{
			rustWattSeconds += num;
			rustWattSeconds = Mathf.Clamp(rustWattSeconds, 0f, maxCapactiySeconds);
			ChargeChanged(oldCharge);
		}
	}

	public void SetPassthroughOn(bool wantsOn)
	{
		if (wantsOn == IsOn() && !wasLoaded)
		{
			return;
		}
		wasLoaded = false;
		SetFlag(Flags.On, wantsOn);
		if (IsOn())
		{
			if (!((FacepunchBehaviour)this).IsInvoking((Action)TickUsage))
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)TickUsage, 1f, 1f, 0.1f);
			}
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)TickUsage);
		}
		MarkDirty();
	}

	public void UnBusy()
	{
		SetFlag(Flags.Busy, b: false);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.ioEntity == null)
		{
			info.msg.ioEntity = Pool.Get<IOEntity>();
		}
		info.msg.ioEntity.genericFloat1 = rustWattSeconds;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			rustWattSeconds = info.msg.ioEntity.genericFloat1;
		}
	}

	[ServerVar]
	public static void batteryid(Arg arg)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		ElectricBattery electricBattery = BaseNetworkable.serverEntities.Find(arg.GetEntityID(1)) as ElectricBattery;
		if ((Object)(object)electricBattery == (Object)null)
		{
			arg.ReplyWith("Not a battery");
			return;
		}
		string @string = arg.GetString(0, "");
		if (!(@string == "charge"))
		{
			if (@string == "deplete")
			{
				float oldCharge = electricBattery.rustWattSeconds;
				electricBattery.rustWattSeconds = 0f;
				electricBattery.ChargeChanged(oldCharge);
				arg.ReplyWith("Depleted " + electricBattery.GetDisplayName().english);
			}
			else
			{
				arg.ReplyWith("Unknown command");
			}
		}
		else
		{
			float oldCharge2 = electricBattery.rustWattSeconds;
			float num = arg.GetInt(2, (int)electricBattery.maxCapactiySeconds / 60);
			electricBattery.rustWattSeconds = Mathf.Clamp(electricBattery.rustWattSeconds + num * 60f, 0f, electricBattery.maxCapactiySeconds);
			electricBattery.ChargeChanged(oldCharge2);
			arg.ReplyWith("Charged " + electricBattery.GetDisplayName().english);
		}
	}
}


using UnityEngine;

public class BaseDetector : IOEntity, IDetector
{
	public PlayerDetectionTrigger myTrigger;

	public const Flags Flag_HasContents = Flags.Reserved1;

	public override int ConsumptionAmount()
	{
		return base.ConsumptionAmount();
	}

	public virtual bool ShouldTrigger()
	{
		return IsPowered();
	}

	public virtual void OnObjects()
	{
		SetFlag(Flags.Reserved1, b: true);
		if (ShouldTrigger())
		{
			OnDetectorTriggered();
			MarkDirty();
		}
	}

	public void OnObjectAdded(GameObject obj, Collider col)
	{
	}

	public virtual void OnEmpty()
	{
		SetFlag(Flags.Reserved1, b: false);
		if (ShouldTrigger())
		{
			OnDetectorReleased();
			MarkDirty();
		}
	}

	public virtual void OnDetectorTriggered()
	{
	}

	public virtual void OnDetectorReleased()
	{
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!HasFlag(Flags.Reserved1))
		{
			return 0;
		}
		return base.GetPassthroughAmount();
	}
}


using UnityEngine;

public interface IDetector
{
	bool ShouldTrigger();

	void OnObjects();

	void OnObjectAdded(GameObject obj, Collider col);

	void OnEmpty();
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class LaserDetector : BaseDetector
{
	public const Flags Flag_Triggered = Flags.Reserved12;

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!HasFlag(Flags.Reserved12))
		{
			return 0;
		}
		return currentEnergy;
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (IsPowered() && next.HasFlag(Flags.Reserved1))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)VisibilityCheck, 0f, 1f);
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)VisibilityCheck);
		}
	}

	private void VisibilityCheck()
	{
		if (myTrigger.entityContents == null)
		{
			return;
		}
		bool b = false;
		foreach (BaseEntity entityContent in myTrigger.entityContents)
		{
			if (!entityContent.isClient && CanSee(entityContent))
			{
				b = true;
				break;
			}
		}
		SetFlag(Flags.Reserved12, b);
		MarkDirty();
	}

	public override void OnEmpty()
	{
		base.OnEmpty();
		SetFlag(Flags.Reserved12, b: false);
		MarkDirty();
	}

	public bool CanSee(BaseEntity ent)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		PooledList<RaycastHit> val = Pool.Get<PooledList<RaycastHit>>();
		try
		{
			GamePhysics.TraceAll(new Ray(((Component)this).transform.position + ((Component)this).transform.forward * 0.25f, ((Component)this).transform.forward), 0.12f, (List<RaycastHit>)(object)val, 12f, 0x48A12101 | LayerMask.op_Implicit(myTrigger.InterestLayers), (QueryTriggerInteraction)1, this);
			foreach (RaycastHit item in (List<RaycastHit>)(object)val)
			{
				BaseEntity entity = item.GetEntity();
				if (!((Object)(object)entity == (Object)null) && !entity.isClient)
				{
					return (Object)(object)entity == (Object)(object)ent;
				}
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using UnityEngine;

public class PlayerDetectionTrigger : TriggerBase
{
	public GameObject detector;

	public IDetector _detector;

	private IDetector myDetector
	{
		get
		{
			if (_detector == null && (Object)(object)detector != (Object)null)
			{
				_detector = detector.GetComponent<IDetector>();
			}
			return _detector;
		}
	}

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public override void OnObjects()
	{
		base.OnObjects();
		if (myDetector != null)
		{
			myDetector.OnObjects();
		}
	}

	internal override void OnObjectAdded(GameObject obj, Collider col)
	{
		base.OnObjectAdded(obj, col);
		if (myDetector != null)
		{
			myDetector.OnObjectAdded(obj, col);
		}
	}

	public override void OnEmpty()
	{
		base.OnEmpty();
		if (myDetector != null)
		{
			myDetector.OnEmpty();
		}
	}
}


using System;
using UnityEngine;

public class PressurePad : BaseDetector
{
	public float pressPowerTime = 0.5f;

	public int pressPowerAmount = 2;

	public const Flags Flag_EmittingPower = Flags.Reserved3;

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override bool IsRootEntity()
	{
		return true;
	}

	public override bool ShouldTrigger()
	{
		return true;
	}

	public override void OnDetectorTriggered()
	{
		base.OnDetectorTriggered();
		((FacepunchBehaviour)this).Invoke((Action)UnpowerTime, pressPowerTime);
		SetFlag(Flags.Reserved3, b: true);
	}

	public override void OnDetectorReleased()
	{
		base.OnDetectorReleased();
		SetFlag(Flags.Reserved3, b: false);
	}

	public void UnpowerTime()
	{
		SetFlag(Flags.Reserved3, b: false);
		MarkDirty();
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (HasFlag(Flags.Reserved1))
		{
			int passthroughAmount = base.GetPassthroughAmount(0);
			if (HasFlag(Flags.Reserved3))
			{
				return Mathf.Max(pressPowerAmount, passthroughAmount);
			}
			if (IsPowered())
			{
				return passthroughAmount;
			}
		}
		return 0;
	}
}


using UnityEngine;

public class ElectricalHeater : IOEntity
{
	public float fadeDuration = 1f;

	public Light sourceLight;

	public Light secondaryLight;

	public GrowableHeatSource growableHeatSource;

	public override int ConsumptionAmount()
	{
		return 3;
	}

	public override void ResetState()
	{
		base.ResetState();
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		bool flag = next.HasFlag(Flags.Reserved8);
		if (old.HasFlag(Flags.Reserved8) != flag && (Object)(object)growableHeatSource != (Object)null)
		{
			growableHeatSource.ForceUpdateGrowablesInRange();
		}
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if ((Object)(object)growableHeatSource != (Object)null)
		{
			growableHeatSource.ForceUpdateGrowablesInRange();
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public class GrowableHeatSource : EntityComponent<BaseEntity>, IServerComponent
{
	public float heatAmount = 5f;

	public AnimationCurve HeatFalloff = AnimationCurve.Linear(0f, 1f, 1f, 0f);

	public float ApplyHeat(Vector3 forPosition)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)base.baseEntity == (Object)null)
		{
			return 0f;
		}
		if (base.baseEntity.IsOn() || (base.baseEntity is IOEntity iOEntity && iOEntity.IsPowered()))
		{
			float num = Vector3.Distance(forPosition, ((Component)this).transform.position);
			float num2 = HeatFalloff.Evaluate(num / Server.artificialTemperatureGrowableRange);
			return heatAmount * num2;
		}
		return 0f;
	}

	public void ForceUpdateGrowablesInRange()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		List<IHeatSourceListener> list = Pool.Get<List<IHeatSourceListener>>();
		int layerMask = 524544;
		Vis.Entities(((Component)this).transform.position, Server.artificialTemperatureGrowableRange, list, layerMask, (QueryTriggerInteraction)2);
		List<PlanterBox> list2 = Pool.Get<List<PlanterBox>>();
		foreach (IHeatSourceListener item in list)
		{
			if (item is GrowableEntity growableEntity)
			{
				if (!growableEntity.isServer)
				{
					continue;
				}
				PlanterBox planter = growableEntity.GetPlanter();
				if ((Object)(object)planter != (Object)null && !list2.Contains(planter))
				{
					list2.Add(planter);
					planter.ForceTemperatureUpdate();
				}
			}
			item.OnHeatSourceChanged();
		}
		Pool.FreeUnmanaged<PlanterBox>(ref list2);
		Pool.FreeUnmanaged<IHeatSourceListener>(ref list);
	}
}


public interface IHeatSourceListener
{
	void OnHeatSourceChanged();
}


public class ElectricalBlocker : IOEntity
{
	protected int input1Amount;

	protected int input2Amount;

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		return base.GetPassthroughAmount(outputSlot) * ((!IsOn()) ? 1 : 0);
	}

	public override bool WantsPower(int inputIndex)
	{
		if (inputIndex != 0 || !IsFlickering())
		{
			return !IsOn();
		}
		return true;
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		SetFlag(Flags.Reserved8, input2Amount > 0, recursive: false, networkupdate: false);
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
	}

	public virtual void UpdateBlocked()
	{
		bool num = IsOn();
		SetFlag(Flags.On, input1Amount > 0, recursive: false, networkupdate: false);
		if (num != IsOn())
		{
			MarkDirty();
		}
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		switch (inputSlot)
		{
		case 1:
			input1Amount = inputAmount;
			UpdateBlocked();
			break;
		case 0:
			input2Amount = inputAmount;
			base.UpdateFromInput(inputAmount, inputSlot);
			break;
		}
	}
}


using UnityEngine;

public class ElectricalCombiner : IOEntity
{
	public int input1Amount;

	public int input2Amount;

	public int input3Amount;

	public override bool BlockFluidDraining => true;

	public override bool IsRootEntity()
	{
		return true;
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		int num = input1Amount + input2Amount + input3Amount;
		Mathf.Clamp(num, 0, num);
		return num;
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		SetFlag(Flags.Reserved8, input1Amount > 0 || input2Amount > 0, recursive: false, networkupdate: false);
	}

	public override void UpdateFromInput(int inputAmount, int slot)
	{
		if (inputAmount > 0 && IsConnectedTo(this, slot, IOEntity.backtracking * 2, defaultReturn: true))
		{
			inputAmount = 0;
			SetFlag(Flags.Reserved7, b: true);
		}
		else
		{
			SetFlag(Flags.Reserved7, b: false);
		}
		switch (slot)
		{
		case 0:
			input1Amount = inputAmount;
			break;
		case 1:
			input2Amount = inputAmount;
			break;
		case 2:
			input3Amount = inputAmount;
			break;
		}
		int num = input1Amount + input2Amount + input3Amount;
		bool b = num > 0;
		Flags num2 = flags;
		SetFlag(Flags.Reserved1, input1Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved2, input2Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved3, b, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved4, input1Amount > 0 || input2Amount > 0 || input3Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.On, num > 0, recursive: false, networkupdate: false);
		if (num2 != flags)
		{
			SendNetworkUpdate_Flags();
		}
		base.UpdateFromInput(num, slot);
	}
}


using System;
using UnityEngine;

public class ElectricalDFlipFlop : IOEntity
{
	[NonSerialized]
	private int setAmount;

	[NonSerialized]
	private int resetAmount;

	[NonSerialized]
	private int toggleAmount;

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		if (inputSlot == 0)
		{
			base.UpdateHasPower(inputAmount, inputSlot);
		}
	}

	public bool GetDesiredState()
	{
		if (setAmount > 0 && resetAmount == 0)
		{
			return true;
		}
		if (setAmount > 0 && resetAmount > 0)
		{
			return true;
		}
		if (setAmount == 0 && resetAmount > 0)
		{
			return false;
		}
		if (toggleAmount > 0)
		{
			return !IsOn();
		}
		if (setAmount == 0 && resetAmount == 0)
		{
			return IsOn();
		}
		return false;
	}

	public void UpdateState()
	{
		if (IsPowered())
		{
			bool num = IsOn();
			bool desiredState = GetDesiredState();
			SetFlag(Flags.On, desiredState);
			if (num != IsOn())
			{
				MarkDirtyForceUpdateOutputs();
			}
		}
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		bool flag = false;
		switch (inputSlot)
		{
		case 1:
			flag = inputAmount != setAmount;
			setAmount = inputAmount;
			break;
		case 2:
			flag = inputAmount != resetAmount;
			resetAmount = inputAmount;
			break;
		case 3:
			flag = inputAmount != toggleAmount;
			toggleAmount = inputAmount;
			break;
		case 0:
			base.UpdateFromInput(inputAmount, inputSlot);
			UpdateState();
			break;
		}
		if (flag)
		{
			UpdateState();
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		int result = Mathf.Max(0, currentEnergy);
		if (outputSlot == -1)
		{
			return result;
		}
		if (!AllowDrainFrom(outputSlot))
		{
			return 0;
		}
		return result;
	}

	public override void UpdateOutputs()
	{
		if (ShouldUpdateOutputs() && ensureOutputsUpdated)
		{
			int passthroughAmount = GetPassthroughAmount(-1);
			if ((Object)(object)outputs[0].connectedTo.Get() != (Object)null)
			{
				outputs[0].connectedTo.Get().UpdateFromInput(IsOn() ? passthroughAmount : 0, outputs[0].connectedToSlot);
			}
			if ((Object)(object)outputs[1].connectedTo.Get() != (Object)null)
			{
				outputs[1].connectedTo.Get().UpdateFromInput((!IsOn()) ? passthroughAmount : 0, outputs[1].connectedToSlot);
			}
		}
	}

	public override bool AllowDrainFrom(int outputSlot)
	{
		if (outputSlot == -1)
		{
			return true;
		}
		if (!IsOn())
		{
			return outputSlot == 1;
		}
		return outputSlot == 0;
	}

	public override bool WantsPower(int inputIndex)
	{
		return inputIndex == 0;
	}
}


using UnityEngine;

public class RANDSwitch : ElectricalBlocker
{
	private bool rand;

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		return GetCurrentEnergy() * (IsOn() ? 1 : 0);
	}

	public override bool WantsPower(int inputIndex)
	{
		if (inputIndex == 0)
		{
			return IsOn();
		}
		return false;
	}

	public override void UpdateBlocked()
	{
		bool num = IsOn();
		SetFlag(Flags.On, rand, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved8, rand, recursive: false, networkupdate: false);
		UpdateHasPower(input1Amount + input2Amount, 1);
		if (num != IsOn())
		{
			MarkDirty();
		}
	}

	public bool RandomRoll()
	{
		return Random.Range(0, 2) == 1;
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		if (inputSlot == 1 && inputAmount > 0)
		{
			input1Amount = inputAmount;
			rand = RandomRoll();
			UpdateBlocked();
		}
		if (inputSlot == 2)
		{
			if (inputAmount > 0)
			{
				rand = false;
				UpdateBlocked();
			}
		}
		else
		{
			base.UpdateFromInput(inputAmount, inputSlot);
		}
	}
}


public class FuelElectricGenerator : IOEntity
{
	public float electricAmount = 8f;
}


using System;
using Oxide.Core;
using UnityEngine;

public class SolarPanel : IOEntity
{
	public Transform sunSampler;

	private const int tickrateSeconds = 60;

	public int maximalPowerOutput = 10;

	public float dot_minimum = 0.1f;

	public float dot_maximum = 0.6f;

	public override bool IsRootEntity()
	{
		return true;
	}

	public override int MaximalPowerOutput()
	{
		return maximalPowerOutput;
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)SunUpdate, 1f, 5f, 2f);
	}

	public void SunUpdate()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		int num = currentEnergy;
		if (TOD_Sky.Instance.IsNight)
		{
			num = 0;
		}
		else
		{
			Vector3 sunDirection = TOD_Sky.Instance.SunDirection;
			float num2 = Vector3.Dot(sunSampler.forward, sunDirection);
			float num3 = Mathf.InverseLerp(dot_minimum, dot_maximum, num2);
			if (num3 > 0f && !IsVisible(sunSampler.position + sunDirection * 100f, 101f))
			{
				num3 = 0f;
			}
			num = Mathf.FloorToInt((float)maximalPowerOutput * num3 * base.healthFraction);
		}
		bool num4 = currentEnergy != num;
		currentEnergy = num;
		if (num4 && Interface.CallHook("OnSolarPanelSunUpdate", (object)this, (object)num) == null)
		{
			MarkDirty();
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (outputSlot != 0)
		{
			return 0;
		}
		return currentEnergy;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

public class Igniter : IOEntity
{
	public float IgniteRange = 5f;

	public float IgniteFrequency = 1f;

	public float IgniteStartDelay;

	public Transform LineOfSightEyes;

	public float SelfDamagePerIgnite = 0.5f;

	public int PowerConsumption = 2;

	public override int ConsumptionAmount()
	{
		return PowerConsumption;
	}

	public bool CanIgnite()
	{
		return base.healthFraction >= 0.1f;
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		base.UpdateFromInput(inputAmount, inputSlot);
		if (inputAmount > 0 && CanIgnite())
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)IgniteInRange, IgniteStartDelay, IgniteFrequency);
			SetFlag(Flags.On, b: true);
			return;
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)IgniteInRange))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)IgniteInRange);
		}
		SetFlag(Flags.On, b: false);
	}

	private void IgniteInRange()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(LineOfSightEyes.position, IgniteRange, list, 1237019409, (QueryTriggerInteraction)2);
		int num = 0;
		foreach (BaseEntity item in list)
		{
			if (item.HasFlag(Flags.On) || !item.IsVisible(LineOfSightEyes.position))
			{
				continue;
			}
			if (item.isServer && item is BaseOven)
			{
				(item as BaseOven).StartCooking();
				if (item.HasFlag(Flags.On))
				{
					num++;
				}
			}
			else if (item.isServer && item is IIgniteable igniteable && igniteable.CanIgnite())
			{
				igniteable.Ignite(((Component)this).transform.position);
				num++;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		Hurt(SelfDamagePerIgnite, DamageType.ElectricShock, this, useProtection: false);
		if (!CanIgnite())
		{
			SendChangedToRoot(forceUpdate: true);
		}
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		if (!CanIgnite())
		{
			return 0;
		}
		return base.DesiredPower(inputIndex);
	}

	public override void OnRepair()
	{
		base.OnRepair();
		if (CanIgnite())
		{
			SendChangedToRoot(forceUpdate: true);
		}
	}
}


using UnityEngine;

public class FlasherLight : IOEntity
{
	public EmissionToggle toggler;

	public Light myLight;

	public float flashSpacing = 0.2f;

	public float flashBurstSpacing = 0.5f;

	public float flashOnTime = 0.1f;

	public int numFlashesPerBurst = 5;

	public float maximumLightRenderDistance = 25f;

	public override void ResetState()
	{
		base.ResetState();
	}
}


using UnityEngine;

public class SirenLight : IOEntity
{
	public EmissionToggle toggler;

	public GameObject lightObj;

	public float speed;

	public override void ResetState()
	{
		base.ResetState();
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using UnityEngine;

public class Sprinkler : IOEntity
{
	public float SplashFrequency = 1f;

	public Transform Eyes;

	public int WaterPerSplash = 1;

	public float DecayPerSplash = 0.8f;

	public const Flags Flag_Radiation = Flags.Reserved3;

	public ItemDefinition currentFuelType;

	private IOEntity currentFuelSource;

	private HashSet<ISplashable> cachedSplashables = new HashSet<ISplashable>();

	private TimeSince updateSplashableCache;

	private bool forceUpdateSplashables;

	public override bool BlockFluidDraining => (Object)(object)currentFuelSource != (Object)null;

	public override int ConsumptionAmount()
	{
		return 2;
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		return Mathf.Clamp(currentEnergy, 0, ConsumptionAmount());
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		base.UpdateHasPower(inputAmount, inputSlot);
		SetSprinklerState(inputAmount > 0);
	}

	public override int CalculateCurrentEnergy(int inputAmount, int inputSlot)
	{
		return inputAmount;
	}

	private void DoSplash()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SprinklerSplash", 0);
		try
		{
			int num = WaterPerSplash;
			if (TimeSince.op_Implicit(updateSplashableCache) > SplashFrequency * 4f || forceUpdateSplashables)
			{
				cachedSplashables.Clear();
				forceUpdateSplashables = false;
				updateSplashableCache = TimeSince.op_Implicit(0f);
				Vector3 position = Eyes.position;
				Vector3 up = ((Component)this).transform.up;
				float sprinklerEyeHeightOffset = Server.sprinklerEyeHeightOffset;
				float num2 = Vector3.Angle(up, Vector3.up) / 180f;
				num2 = Mathf.Clamp(num2, 0.2f, 1f);
				sprinklerEyeHeightOffset *= num2;
				Vector3 startPosition = position + up * (Server.sprinklerRadius * 0.5f);
				Vector3 endPosition = position + up * sprinklerEyeHeightOffset;
				List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
				Vis.Entities(startPosition, endPosition, Server.sprinklerRadius, list, 1237003025, (QueryTriggerInteraction)2);
				if (list.Count > 0)
				{
					foreach (BaseEntity item in list)
					{
						if (!item.isClient && item is ISplashable splashable && !cachedSplashables.Contains(splashable) && splashable.WantsSplash(currentFuelType, num) && item.IsVisible(position) && (!(item is IOEntity entity) || !IsConnectedTo(entity, IOEntity.backtracking)) && (!(item is BasePlayer) || !(currentFuelType.baseRadioactivity > 0f)))
						{
							cachedSplashables.Add(splashable);
						}
					}
				}
				Pool.FreeUnmanaged<BaseEntity>(ref list);
			}
			if (cachedSplashables.Count > 0)
			{
				int num3 = num / cachedSplashables.Count;
				float num4 = (float)(num % cachedSplashables.Count) / (float)cachedSplashables.Count;
				foreach (ISplashable cachedSplashable in cachedSplashables)
				{
					int amount = num3 + ((Random.value < num4) ? 1 : 0);
					if (!cachedSplashable.IsUnityNull() && cachedSplashable.WantsSplash(currentFuelType, amount))
					{
						int num5 = cachedSplashable.DoSplash(currentFuelType, amount);
						num -= num5;
						if (num <= 0)
						{
							break;
						}
					}
				}
			}
			if (DecayPerSplash > 0f)
			{
				Hurt(DecayPerSplash);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		Interface.CallHook("OnSprinklerSplashed", (object)this);
	}

	public void SetSprinklerState(bool wantsOn)
	{
		if (wantsOn)
		{
			TurnOn();
		}
		else
		{
			TurnOff();
		}
	}

	public void TurnOn()
	{
		if (!IsOn())
		{
			SetFlag(Flags.On, b: true);
			if ((Object)(object)currentFuelType != (Object)null)
			{
				SetFlag(Flags.Reserved3, currentFuelType.baseRadioactivity > 0f);
			}
			forceUpdateSplashables = true;
			if (!((FacepunchBehaviour)this).IsInvoking((Action)DoSplash))
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)DoSplash, SplashFrequency * 0.5f, SplashFrequency, SplashFrequency * 0.2f);
			}
		}
	}

	public void TurnOff()
	{
		if (IsOn())
		{
			SetFlag(Flags.On, b: false);
			SetFlag(Flags.Reserved3, b: false);
			if (((FacepunchBehaviour)this).IsInvoking((Action)DoSplash))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)DoSplash);
			}
			currentFuelSource = null;
			currentFuelType = null;
		}
	}

	public override void SetFuelType(ItemDefinition def, IOEntity source)
	{
		base.SetFuelType(def, source);
		currentFuelType = def;
		currentFuelSource = source;
		if ((Object)(object)currentFuelType != (Object)null)
		{
			SetFlag(Flags.Reserved3, currentFuelType.baseRadioactivity > 0f && IsOn());
		}
		else
		{
			SetFlag(Flags.Reserved3, b: false);
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk)
		{
			if (Server.useLegacySprinklerLoadProcess)
			{
				SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
			}
			else if (HasFlag(Flags.On) && !((FacepunchBehaviour)this).IsInvoking((Action)DoSplash))
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)DoSplash, SplashFrequency * 0.5f, SplashFrequency, SplashFrequency * 0.2f);
			}
		}
	}
}


using System;
using System.Linq;
using Rust;
using UnityEngine;

public class TeslaCoil : IOEntity
{
	public TargetTrigger targetTrigger;

	public TriggerMovement movementTrigger;

	public float powerToDamageRatio = 2f;

	public float dischargeTickRate = 0.25f;

	public float maxDischargeSelfDamageSeconds = 120f;

	public float maxDamageOutput = 35f;

	public Transform damageEyes;

	public const Flags Flag_WeakShorting = Flags.Reserved1;

	public const Flags Flag_StrongShorting = Flags.Reserved2;

	public int powerForHeavyShorting = 10;

	private float lastDischargeTime;

	public override int ConsumptionAmount()
	{
		return Mathf.CeilToInt(maxDamageOutput / powerToDamageRatio);
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		if (!CanDischarge())
		{
			return 0;
		}
		return Mathf.Clamp(currentEnergy, 0, ConsumptionAmount());
	}

	public bool CanDischarge()
	{
		return base.healthFraction >= 0.1f;
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		base.UpdateFromInput(inputAmount, inputSlot);
		if (inputAmount > 0 && CanDischarge())
		{
			float num = Time.time - lastDischargeTime;
			if (num < 0f)
			{
				num = 0f;
			}
			float num2 = Mathf.Min(dischargeTickRate - num, dischargeTickRate);
			((FacepunchBehaviour)this).InvokeRepeating((Action)Discharge, num2, dischargeTickRate);
			SetFlag(Flags.Reserved1, inputAmount < powerForHeavyShorting, recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved2, inputAmount >= powerForHeavyShorting, recursive: false, networkupdate: false);
			SetFlag(Flags.On, b: true);
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)Discharge);
			SetFlag(Flags.Reserved1, b: false, recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
			SetFlag(Flags.On, b: false);
		}
	}

	public void Discharge()
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		float damageAmount = Mathf.Clamp((float)currentEnergy * powerToDamageRatio, 0f, maxDamageOutput) * dischargeTickRate;
		lastDischargeTime = Time.time;
		if (targetTrigger.entityContents != null)
		{
			BaseEntity[] array = targetTrigger.entityContents.ToArray();
			if (array != null)
			{
				BaseEntity[] array2 = array;
				for (int i = 0; i < array2.Length; i++)
				{
					BaseCombatEntity component = ((Component)array2[i]).GetComponent<BaseCombatEntity>();
					if (Object.op_Implicit((Object)(object)component) && component.IsVisible(((Component)damageEyes).transform.position, component.CenterPoint()))
					{
						component.OnAttacked(new HitInfo(this, component, DamageType.ElectricShock, damageAmount));
					}
				}
			}
		}
		float amount = dischargeTickRate / maxDischargeSelfDamageSeconds * MaxHealth();
		Hurt(amount, DamageType.ElectricShock, this, useProtection: false);
		if (!CanDischarge())
		{
			SendChangedToRoot(forceUpdate: true);
		}
	}

	public override void OnRepair()
	{
		base.OnRepair();
		if (CanDischarge())
		{
			SendChangedToRoot(forceUpdate: true);
		}
	}
}


using UnityEngine;

public class CableTunnel : IOEntity
{
	private const int numChannels = 4;

	private int[] inputAmounts = new int[4];

	public override bool WantsPower(int inputIndex)
	{
		return true;
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		int num = inputAmounts[inputSlot];
		inputAmounts[inputSlot] = inputAmount;
		if (inputAmount != num)
		{
			ensureOutputsUpdated = true;
		}
		base.IOStateChanged(inputAmount, inputSlot);
	}

	public override void UpdateOutputs()
	{
		if (!ShouldUpdateOutputs() || !ensureOutputsUpdated)
		{
			return;
		}
		for (int i = 0; i < 4; i++)
		{
			IOSlot iOSlot = outputs[i];
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				iOSlot.connectedTo.Get().UpdateFromInput(inputAmounts[i], iOSlot.connectedToSlot);
			}
		}
	}
}


public class BranchConfig : IOConfig<ElectricalBranch>
{
}


public class CommandBlockConfig : IOConfig<CommandBlock>
{
	private string _currentCommand;
}


public class CounterConfig : IOConfig<PowerCounter>
{
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class DigitalClockConfig : IOConfig<DigitalClock>
{
	public DigitalClockConfigAlarm alarmPrefab;

	public Transform alarmParent;

	public GameObject placeHolder;

	public Button addButton;

	public RustButton muteButton;
}


using Rust.UI;
using UnityEngine;

public class DigitalClockConfigAlarm : MonoBehaviour
{
	public CanvasGroup canvasGroup;

	public ClockSlider slider;

	public RustButton toggleButton;

	[Space]
	public GameObject deleteButton;

	private DigitalClockConfig owner;

	private bool deleteButtonHovered;

	public bool Active { get; private set; }
}


using Rust.UI;

public class HBHFConfig : IOConfig<HBHFSensor>
{
	public RustButton authButton;

	public RustButton nonAuthButton;
}


using Rust.UI;
using UnityEngine;

public abstract class IOConfig<T> : UIDialog
{
	[Space]
	public RustInput input;

	public float minValue;

	public float maxValue = 100f;
}


public class SeismicSensorConfig : IOConfig<SeismicSensor>
{
}


public class TimerConfig : IOConfig<CustomTimerSwitch>
{
}


using UnityEngine;

public class DynamicDirtLayerController : MonoBehaviour, IClientComponent, ICustomMaterialReplacer
{
	[Range(0f, 1f)]
	public float Amount = 0.5f;

	public Texture DirtTexture;
}


using System.Collections.Generic;
using Rust.UI;
using UnityEngine;

public class LootPanelToolCupboard : LootPanel
{
	public List<VirtualItemIcon> costIcons;

	public RustText protectedText;

	public GameObject baseNotProtectedObj;

	public GameObject baseProtectedObj;

	public Phrase protectedPrefix;

	public Tooltip costToolTip;

	public Phrase blocksPhrase;

	public Phrase blocksAndDoorsPhrase;

	public GameObject toolsRow;
}


using System;
using ConVar;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class InvisibleVendingMachine : NPCVendingMachine
{
	public GameObjectRef buyEffect;

	public NPCVendingOrderManifest vmoManifest;

	public bool canRefreshOrders;

	public EntityRef<NPCShopKeeper> cachedShopKeeper;

	public const Flags HasAttachedShopkeeper = Flags.Reserved7;

	private static ListHashSet<InvisibleVendingMachine> allMachines = new ListHashSet<InvisibleVendingMachine>();

	public TimeUntil nextOrderRefresh;

	protected override bool BlockOrderRefreshOnLoad => canRefreshOrders;

	public static InvisibleVendingMachine GetMachineAtPosition(float tolerance, Vector3 position)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<InvisibleVendingMachine> enumerator = allMachines.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				InvisibleVendingMachine current = enumerator.Current;
				if ((Object)(object)current != (Object)null && current.Distance(position) < tolerance)
				{
					return current;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return null;
	}

	public void KeeperLookAt(Vector3 pos)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		NPCShopKeeper nPCShopKeeper = cachedShopKeeper.Get(base.isServer);
		if (!((Object)(object)nPCShopKeeper == (Object)null))
		{
			nPCShopKeeper.SetAimDirection(Vector3Ex.Direction2D(pos, ((Component)nPCShopKeeper).transform.position));
		}
	}

	public override bool HasVendingSounds()
	{
		return false;
	}

	public override float GetBuyDuration()
	{
		return 0.5f;
	}

	public override void CompletePendingOrder()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(buyEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
		NPCShopKeeper nPCShopKeeper = cachedShopKeeper.Get(base.isServer);
		if (Object.op_Implicit((Object)(object)nPCShopKeeper))
		{
			nPCShopKeeper.SignalBroadcast(Signal.Gesture, "victory");
			if ((Object)(object)vend_Player != (Object)null)
			{
				nPCShopKeeper.SetAimDirection(Vector3Ex.Direction2D(((Component)vend_Player).transform.position, ((Component)nPCShopKeeper).transform.position));
			}
		}
		base.CompletePendingOrder();
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		KeeperLookAt(((Component)player).transform.position);
		return base.PlayerOpenLoot(player, panelToOpen);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if ((Object)(object)vmoManifest != (Object)null && info.msg.vendingMachine != null)
		{
			info.msg.vendingMachine.vmoIndex = vmoManifest.GetIndex(vendingOrders);
		}
		info.msg.npcVendingMachine = Pool.Get<NPCVendingMachine>();
		info.msg.npcVendingMachine.attachedNpc = cachedShopKeeper.uid;
		info.msg.npcVendingMachine.nextRefresh = TimeUntil.op_Implicit(nextOrderRefresh);
	}

	public override void ServerInit()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (vmoManifest.GetIndex(vendingOrders) == -1)
		{
			Debug.LogError((object)"VENDING ORDERS NOT FOUND! Did you forget to add these orders to the VMOManifest?");
		}
		if (canRefreshOrders)
		{
			nextOrderRefresh = TimeUntil.op_Implicit(Server.waterWellNpcSalesRefreshFrequency * 60f * 60f);
			((FacepunchBehaviour)this).InvokeRepeating((Action)CheckSellOrderRefresh, 30f, 30f);
		}
		allMachines.TryAdd(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		allMachines.Remove(this);
	}

	public void CheckSellOrderRefresh()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (TimeUntil.op_Implicit(nextOrderRefresh) < 0f)
		{
			nextOrderRefresh = TimeUntil.op_Implicit(Server.waterWellNpcSalesRefreshFrequency * 60f * 60f);
			InstallFromVendingOrders();
		}
	}

	public void SetAttachedNPC(NPCShopKeeper shopkeeper)
	{
		cachedShopKeeper.Set(shopkeeper);
		SetFlag(Flags.Reserved7, (Object)(object)shopkeeper != (Object)null);
		SendNetworkUpdate();
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if ((Object)(object)cachedShopKeeper.Get(base.isServer) == (Object)null)
		{
			return false;
		}
		return base.CanBeLooted(player);
	}

	protected override bool CanShop(BasePlayer bp)
	{
		if (base.CanShop(bp))
		{
			return (Object)(object)cachedShopKeeper.Get(base.isServer) != (Object)null;
		}
		return false;
	}

	public override void Load(LoadInfo info)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.fromDisk && (Object)(object)vmoManifest != (Object)null && info.msg.vendingMachine != null)
		{
			NPCVendingOrder fromIndex = vmoManifest.GetFromIndex(info.msg.vendingMachine.vmoIndex);
			vendingOrders = fromIndex;
		}
		if (info.msg.npcVendingMachine != null)
		{
			cachedShopKeeper.uid = info.msg.npcVendingMachine.attachedNpc;
			if (base.isServer)
			{
				nextOrderRefresh = TimeUntil.op_Implicit(info.msg.npcVendingMachine.nextRefresh);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/NPC Vending Order")]
public class NPCVendingOrder : ScriptableObject
{
	[Serializable]
	public class Entry
	{
		public ItemDefinition sellItem;

		public int sellItemAmount;

		public bool sellItemAsBP;

		public ItemDefinition currencyItem;

		public int currencyAmount;

		public bool currencyAsBP;

		public int initialStock = -1;

		public int refillAmount = 1;

		public float refillDelay = 10f;

		public EntryRandom randomDetails;
	}

	[Serializable]
	public struct EntryRandom
	{
		public bool useRandom;

		[Tooltip("The higher this number, the more likely this will be chosen")]
		[Range(0f, 1f)]
		public float weight;

		[Tooltip("Minimum price for the currency item")]
		public int minPrice;

		[Tooltip("Maximum price for the currency item")]
		public int maxPrice;

		[Range(0f, 1f)]
		[Tooltip("Chance for a very low price to occur (0 to 1)")]
		public float veryLowPriceChance;

		[Tooltip("Minimum very low price")]
		public int veryLowPriceMin;

		[Tooltip("Maximum very low price")]
		public int veryLowPriceMax;

		public int GetRandomPrice()
		{
			int num = ((!(Random.value < veryLowPriceChance)) ? Random.Range(minPrice, maxPrice + 1) : Random.Range(veryLowPriceMin, veryLowPriceMax + 1));
			return Mathf.RoundToInt(((float)num + 2.5f) / 5f) * 5;
		}
	}

	public Era[] AllowedEras;

	public Entry[] orders;

	public void GetRandomEntries(int count, List<Entry> selectedEntries)
	{
		if (orders == null || orders.Length == 0 || count <= 0)
		{
			return;
		}
		List<bool> list = Pool.Get<List<bool>>();
		for (int i = 0; i < orders.Length; i++)
		{
			list.Add(item: false);
		}
		float num = 0f;
		count = Mathf.Min(count, orders.Length);
		Entry[] array = orders;
		foreach (Entry entry in array)
		{
			num += entry.randomDetails.weight;
		}
		for (int k = 0; k < count; k++)
		{
			if (num == 0f)
			{
				break;
			}
			float num2 = Random.Range(0f, num);
			for (int l = 0; l < orders.Length; l++)
			{
				Entry entry2 = orders[l];
				if (!list[l])
				{
					if (num2 < entry2.randomDetails.weight)
					{
						selectedEntries.Add(entry2);
						list[l] = true;
						num -= entry2.randomDetails.weight;
						break;
					}
					num2 -= entry2.randomDetails.weight;
				}
			}
		}
		Pool.FreeUnmanaged<bool>(ref list);
	}

	[ContextMenu("Print All Orders Info")]
	private void PrintOrdersInfo()
	{
		if (orders == null || orders.Length == 0)
		{
			Debug.Log((object)"No orders available.");
			return;
		}
		string text = "NPC Vending Orders Info:\n";
		Entry[] array = orders;
		foreach (Entry entry in array)
		{
			string arg = (((Object)(object)entry.sellItem != (Object)null) ? ((Object)entry.sellItem).name : "None");
			string arg2 = (((Object)(object)entry.currencyItem != (Object)null) ? ((Object)entry.currencyItem).name : "None");
			text = text + $"Sell Item: {arg}, Amount: {entry.sellItemAmount}, As Blueprint: {entry.sellItemAsBP}\n" + $"Currency Item: {arg2}, Amount: {entry.currencyAmount}, As Blueprint: {entry.currencyAsBP}\n" + $"Refill Amount: {entry.refillAmount}, Refill Delay: {entry.refillDelay}\n" + $"Random Details - Use Random: {entry.randomDetails.useRandom}, Weight: {entry.randomDetails.weight}\n" + $"Min Price: {entry.randomDetails.minPrice}, Max Price: {entry.randomDetails.maxPrice}\n" + $"Very Low Price Chance: {entry.randomDetails.veryLowPriceChance}, " + $"Very Low Price Min: {entry.randomDetails.veryLowPriceMin}, Very Low Price Max: {entry.randomDetails.veryLowPriceMax}\n\n";
			text += " ";
		}
		Debug.Log((object)text);
	}
}


using System;

[Serializable]
public class Entry
{
	public ItemDefinition sellItem;

	public int sellItemAmount;

	public bool sellItemAsBP;

	public ItemDefinition currencyItem;

	public int currencyAmount;

	public bool currencyAsBP;

	public int initialStock = -1;

	public int refillAmount = 1;

	public float refillDelay = 10f;

	public EntryRandom randomDetails;
}


using System;
using UnityEngine;

[Serializable]
public struct EntryRandom
{
	public bool useRandom;

	[Tooltip("The higher this number, the more likely this will be chosen")]
	[Range(0f, 1f)]
	public float weight;

	[Tooltip("Minimum price for the currency item")]
	public int minPrice;

	[Tooltip("Maximum price for the currency item")]
	public int maxPrice;

	[Range(0f, 1f)]
	[Tooltip("Chance for a very low price to occur (0 to 1)")]
	public float veryLowPriceChance;

	[Tooltip("Minimum very low price")]
	public int veryLowPriceMin;

	[Tooltip("Maximum very low price")]
	public int veryLowPriceMax;

	public int GetRandomPrice()
	{
		int num = ((!(Random.value < veryLowPriceChance)) ? Random.Range(minPrice, maxPrice + 1) : Random.Range(veryLowPriceMin, veryLowPriceMax + 1));
		return Mathf.RoundToInt(((float)num + 2.5f) / 5f) * 5;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/NPCVendingOrderManifest")]
public class NPCVendingOrderManifest : ScriptableObject
{
	public NPCVendingOrder[] orderList;

	public int GetIndex(NPCVendingOrder sample)
	{
		if ((Object)(object)sample == (Object)null)
		{
			return -1;
		}
		for (int i = 0; i < orderList.Length; i++)
		{
			NPCVendingOrder nPCVendingOrder = orderList[i];
			if ((Object)(object)sample == (Object)(object)nPCVendingOrder)
			{
				return i;
			}
		}
		return -1;
	}

	public NPCVendingOrder GetFromIndex(int index)
	{
		if (orderList == null)
		{
			return null;
		}
		if (index < 0)
		{
			return null;
		}
		if (index >= orderList.Length)
		{
			return null;
		}
		return orderList[index];
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class NPCVendingMachine : VendingMachine
{
	public class SalesData
	{
		public ulong TotalSales;

		public ulong TotalIntervals;

		public ulong SoldThisInterval;

		public float CurrentMultiplier;

		public bool IsForReceivedCurrency;

		public double GetAverageSalesPerInterval()
		{
			if (TotalSales == 0L || TotalIntervals == 0L)
			{
				return 0.0;
			}
			return (double)TotalSales / (double)TotalIntervals;
		}

		public void RecordSale(int count)
		{
			SoldThisInterval += (ulong)count;
		}

		public void ProcessEndOfInterval()
		{
			double averageSalesPerInterval = GetAverageSalesPerInterval();
			bool flag = TotalIntervals == 0;
			TotalSales += SoldThisInterval;
			TotalIntervals++;
			SoldThisInterval = 0uL;
			float num = 0f;
			num = ((!(GetAverageSalesPerInterval() <= averageSalesPerInterval || flag)) ? PriceIncreaseAmount : (0f - PriceDecreaseAmount));
			if (IsForReceivedCurrency)
			{
				CurrentMultiplier -= num;
			}
			else
			{
				CurrentMultiplier += num;
			}
			CurrentMultiplier = Mathf.Clamp(CurrentMultiplier, MinimumPriceMultiplier, MaximumPriceMultiplier);
		}
	}

	public NPCVendingOrder vendingOrders;

	public Phrase Phrase;

	public NPCVendingOrder[] alternativeVendingOrders;

	public float RefillTime = 1f;

	public int StartingStock = 10;

	public bool BypassDynamicPricing;

	public const int MaxVendingEntries = 7;

	public const int Capacity = 128;

	private static ListHashSet<NPCVendingMachine> allNpcVendingMachines = new ListHashSet<NPCVendingMachine>();

	private float[] refillTimes;

	[ServerVar(Saved = true, Help = "Whether to run the the dynamic pricing system")]
	public static bool DynamicPricingEnabled = true;

	[ServerVar(Saved = true, Help = "How many realtime hours are checked when looking for price increases. Max 72 (10 days), min 0.5 (half an hour)", ShowInAdminUI = true)]
	public static float PriceUpdateFrequencyDefault = 3f;

	[ServerVar(Saved = true, Help = "How many realtime hours are checked when looking for price increases. Max 72 (10 days), min 0.5 (half an hour)", ShowInAdminUI = true)]
	public static float PriceUpdateFrequencyBiWeekly = 2f;

	[ServerVar(Saved = true, Help = "How many realtime hours are checked when looking for price increases. Max 72 (10 days), min 0.5 (half an hour)", ShowInAdminUI = true)]
	public static float PriceUpdateFrequencyWeekly = 1f;

	private static bool hasCachedTags = false;

	private static bool cachedBiWeekly;

	private static bool cachedWeekly;

	[ServerVar(Saved = true, Help = "The maximum point that a price can increase to (2 = 200%)")]
	public static float MaximumPriceMultiplier = 2f;

	[ServerVar(Saved = true, Help = "The Minimum point that the price can drop to (0.5 = 50% off)")]
	public static float MinimumPriceMultiplier = 0.5f;

	[ServerVar(Saved = true, Help = "What discount surcharge should be applied to items when the server starts")]
	public static float StartingPriceMultiplier = 2f;

	[ServerVar(Saved = true, Help = "How much to increase the price by if it is selling a lot (0.05 = 5%)")]
	public static float PriceIncreaseAmount = 0.1f;

	[ServerVar(Saved = true, Help = "How much to decrease the price for if it is underselling (0.05 = 5%)")]
	public static float PriceDecreaseAmount = 0.05f;

	private SalesData[] allSalesData;

	private float timeToNextSalesUpdate;

	private bool preserveSalesData;

	private static ItemDefinition _scrapItem = null;

	private TimeSince lastHourCheck;

	public override EraRestriction CurrentEraRestriction => (EraRestriction)1;

	protected virtual bool BlockOrderRefreshOnLoad => false;

	public override bool ShouldRecordStats => false;

	private static float ScaledByWipeUpdateFrequency
	{
		get
		{
			if (!hasCachedTags)
			{
				cachedBiWeekly = StringEx.Contains(ConVar.Server.tags, "biweekly", CompareOptions.IgnoreCase);
				cachedWeekly = StringEx.Contains(ConVar.Server.tags, "weekly", CompareOptions.IgnoreCase);
				hasCachedTags = true;
			}
			if (cachedBiWeekly)
			{
				return PriceUpdateFrequencyBiWeekly;
			}
			if (cachedWeekly)
			{
				return PriceUpdateFrequencyWeekly;
			}
			return PriceUpdateFrequencyDefault;
		}
	}

	public static float IntervalSeconds => Mathf.Clamp(ScaledByWipeUpdateFrequency, 0.5f, 72f) * 60f * 60f;

	public static ItemDefinition ScrapItem
	{
		get
		{
			if ((Object)(object)_scrapItem == (Object)null)
			{
				_scrapItem = ItemManager.FindItemDefinition("scrap");
			}
			return _scrapItem;
		}
	}

	private bool CanApplyDynamicPricing
	{
		get
		{
			if (!BypassDynamicPricing)
			{
				return DynamicPricingEnabled;
			}
			return false;
		}
	}

	public byte GetBPState(bool sellItemAsBP, bool currencyItemAsBP)
	{
		byte result = 0;
		if (sellItemAsBP)
		{
			result = 1;
		}
		if (currencyItemAsBP)
		{
			result = 2;
		}
		if (sellItemAsBP && currencyItemAsBP)
		{
			result = 3;
		}
		return result;
	}

	public override void TakeCurrencyItem(Item takenCurrencyItem)
	{
		if (Interface.CallHook("OnTakeCurrencyItem", (object)this, (object)takenCurrencyItem) == null)
		{
			takenCurrencyItem.MoveToContainer(base.inventory);
			takenCurrencyItem.RemoveFromContainer();
			takenCurrencyItem.Remove();
		}
	}

	public override void GiveSoldItem(Item soldItem, BasePlayer buyer)
	{
		if (Interface.CallHook("OnNpcGiveSoldItem", (object)this, (object)soldItem, (object)buyer) == null)
		{
			soldItem.SetItemOwnership(buyer, ItemOwnershipPhrases.VendorSale);
			base.GiveSoldItem(soldItem, buyer);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (!BlockOrderRefreshOnLoad)
		{
			((FacepunchBehaviour)this).Invoke((Action)InstallFromVendingOrders, 1f);
		}
	}

	public void ChangeRefillTime(float newRefillTime)
	{
		RefillTime = newRefillTime;
		if (((FacepunchBehaviour)this).IsInvoking((Action)Refill))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)Refill);
		}
		((FacepunchBehaviour)this).InvokeRandomized((Action)Refill, 1f, RefillTime, 0.1f);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		skinID = 861142659uL;
		SendNetworkUpdate();
		if (!BlockOrderRefreshOnLoad || !Application.isLoadingSave)
		{
			((FacepunchBehaviour)this).Invoke((Action)InstallFromVendingOrders, 1f);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)Refill))
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)Refill, 1f, RefillTime, 0.1f);
		}
		DynamicPricingServerInit();
		allNpcVendingMachines.TryAdd(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		allNpcVendingMachines.Remove(this);
	}

	public virtual void InstallFromVendingOrders()
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Invalid comparison between I4 and Unknown
		if (alternativeVendingOrders != null && alternativeVendingOrders.Length != 0)
		{
			NPCVendingOrder[] array = alternativeVendingOrders;
			foreach (NPCVendingOrder nPCVendingOrder in array)
			{
				if (nPCVendingOrder.AllowedEras == null || nPCVendingOrder.AllowedEras.Length == 0)
				{
					vendingOrders = nPCVendingOrder;
					break;
				}
				Era[] allowedEras = nPCVendingOrder.AllowedEras;
				for (int j = 0; j < allowedEras.Length; j++)
				{
					if ((int)allowedEras[j] == (int)ConVar.Server.Era)
					{
						vendingOrders = nPCVendingOrder;
						break;
					}
				}
			}
		}
		if ((Object)(object)vendingOrders == (Object)null)
		{
			Debug.LogError((object)"No vending orders!");
			return;
		}
		int count = sellOrders.sellOrders.Count;
		ClearSellOrders();
		base.inventory.Clear();
		ItemManager.DoRemoves();
		if (numSlots == 0)
		{
			base.inventory.capacity = 128;
		}
		if (vendingOrders.orders.Length <= 7)
		{
			if (count == vendingOrders.orders.Length)
			{
				preserveSalesData = true;
			}
			try
			{
				NPCVendingOrder.Entry[] orders = vendingOrders.orders;
				foreach (NPCVendingOrder.Entry ent in orders)
				{
					SmartAddItemForSale(ent);
				}
				return;
			}
			finally
			{
				preserveSalesData = false;
			}
		}
		List<NPCVendingOrder.Entry> list = Pool.Get<List<NPCVendingOrder.Entry>>();
		vendingOrders.GetRandomEntries(7, list);
		foreach (NPCVendingOrder.Entry item in list)
		{
			SmartAddItemForSale(item);
		}
		Pool.FreeUnmanaged<NPCVendingOrder.Entry>(ref list);
	}

	private void SmartAddItemForSale(NPCVendingOrder.Entry ent)
	{
		int currencyPerTransaction = ent.currencyAmount;
		if (ent.randomDetails.useRandom)
		{
			currencyPerTransaction = ent.randomDetails.GetRandomPrice();
		}
		AddItemForSale(ent.sellItem.itemid, ent.sellItemAmount, ent.currencyItem.itemid, currencyPerTransaction, GetBPState(ent.sellItemAsBP, ent.currencyAsBP), ent.initialStock);
	}

	public override void InstallDefaultSellOrders()
	{
		base.InstallDefaultSellOrders();
	}

	public void Refill()
	{
		if ((Object)(object)vendingOrders == (Object)null || vendingOrders.orders == null || base.inventory == null)
		{
			return;
		}
		if (refillTimes == null)
		{
			refillTimes = new float[vendingOrders.orders.Length];
		}
		for (int i = 0; i < vendingOrders.orders.Length; i++)
		{
			NPCVendingOrder.Entry entry = vendingOrders.orders[i];
			if (!(Time.realtimeSinceStartup > refillTimes[i]))
			{
				continue;
			}
			int num = 0;
			num = ((!entry.sellItemAsBP) ? Mathf.FloorToInt((float)(base.inventory.GetAmount(entry.sellItem.itemid, onlyUsableAmounts: false) / entry.sellItemAmount)) : Mathf.FloorToInt((float)(base.inventory.GetAmount(base.blueprintBaseDef.itemid, entry.sellItem.itemid, onlyUsableAmounts: false) / entry.sellItemAmount)));
			int num2 = Mathf.Min(StartingStock - num, entry.refillAmount) * entry.sellItemAmount;
			if (num2 > 0)
			{
				transactionActive = true;
				Item item = null;
				if (entry.sellItemAsBP)
				{
					item = ItemManager.Create(base.blueprintBaseDef, num2, 0uL);
					item.blueprintTarget = entry.sellItem.itemid;
				}
				else
				{
					item = ItemManager.Create(entry.sellItem, num2, 0uL);
				}
				if (!item.MoveToContainer(base.inventory))
				{
					item.Remove();
				}
				transactionActive = false;
			}
			refillTimes[i] = Time.realtimeSinceStartup + entry.refillDelay;
		}
	}

	public void ClearSellOrders()
	{
		sellOrders.sellOrders.Clear();
	}

	public void AddItemForSale(int itemID, int amountToSell, int currencyID, int currencyPerTransaction, byte bpState, int initialStockOverride)
	{
		AddSellOrder(itemID, amountToSell, currencyID, currencyPerTransaction, bpState);
		transactionActive = true;
		int num = StartingStock;
		if (initialStockOverride >= 0)
		{
			num = Mathf.Min(initialStockOverride, StartingStock);
		}
		if (bpState == 1 || bpState == 3)
		{
			for (int i = 0; i < num; i++)
			{
				Item item = ItemManager.CreateByItemID(base.blueprintBaseDef.itemid, 1, 0uL);
				item.blueprintTarget = itemID;
				base.inventory.Insert(item);
			}
		}
		else
		{
			base.inventory.AddItem(ItemManager.FindItemDefinition(itemID), amountToSell * num, 0uL);
		}
		transactionActive = false;
		RefreshSellOrderStockLevel();
	}

	public void RefreshStock()
	{
	}

	protected override void RecordSaleAnalytics(Item itemSold, int orderId, int currencyUsed)
	{
		RecordSale(orderId, itemSold.amount, currencyUsed);
	}

	public override string GetTranslationToken()
	{
		return Phrase.token;
	}

	protected override bool CanRotate()
	{
		return false;
	}

	public override bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return false;
	}

	[ServerVar]
	public static void ResetFrequencyTags(Arg arg)
	{
		hasCachedTags = false;
		arg.ReplyWith($"Reset frequency tags. Scaled frequency is now:{ScaledByWipeUpdateFrequency} hours");
	}

	[ServerVar(Help = "Resets the state of all discounts and surcharges from NPC vending machines")]
	public static void resetDynamicPricing()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<NPCVendingMachine> enumerator = allNpcVendingMachines.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.ResetDynamicPricing();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar(Help = "Print out all current price changes on the server")]
	public static void printAllPriceChanges(Arg arg)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Expected O, but got Unknown
		StringBuilder stringBuilder = new StringBuilder();
		Enumerator<NPCVendingMachine> enumerator = allNpcVendingMachines.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				NPCVendingMachine current = enumerator.Current;
				TextTable val = new TextTable();
				val.AddColumns(new string[8] { "Item Name", "Original Price", "Discount/Surcharge", "Final Price", "Avg Sales/Interval", "Current Sales/Interval", "Total Sales", "Intervals" });
				int num = 0;
				int num2 = 0;
				foreach (SellOrder sellOrder in current.sellOrders.sellOrders)
				{
					if (sellOrder.priceMultiplier != 1f)
					{
						num++;
						ItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellOrder.itemToSellID);
						int totalPriceForOrder = VendingMachine.GetTotalPriceForOrder(sellOrder);
						SalesData salesData = current.allSalesData[num2];
						val.AddRow(new string[8]
						{
							itemDefinition.shortname,
							sellOrder.currencyAmountPerItem.ToString(),
							$"{Mathf.RoundToInt(sellOrder.priceMultiplier * 100f)}%",
							$"{totalPriceForOrder}",
							salesData.GetAverageSalesPerInterval().ToString(),
							salesData.SoldThisInterval.ToString(),
							salesData.TotalSales.ToString(),
							salesData.TotalIntervals.ToString()
						});
					}
					num2++;
				}
				if (num > 0)
				{
					stringBuilder.AppendLine(current.shopName);
					stringBuilder.AppendLine("==============");
					stringBuilder.AppendLine(((object)val).ToString());
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar(Help = "Simulates the provided number of hours passing in the vending machine system")]
	public static void addHours(Arg arg)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		float num = (float)arg.GetInt(0, 0) * 60f * 60f;
		Enumerator<NPCVendingMachine> enumerator = allNpcVendingMachines.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				NPCVendingMachine current = enumerator.Current;
				current.lastHourCheck = TimeSince.op_Implicit(TimeSince.op_Implicit(current.lastHourCheck) + num);
				current.HourCheck();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public void RecordSale(int index, int countReceived, int currencyUsed)
	{
		if (CanApplyDynamicPricing)
		{
			CheckSalesDataLength();
			SalesData obj = allSalesData[index];
			obj.RecordSale(obj.IsForReceivedCurrency ? currencyUsed : countReceived);
		}
	}

	private void CheckSalesDataLength(bool reset = false)
	{
		if (reset)
		{
			allSalesData = null;
		}
		int count = sellOrders.sellOrders.Count;
		if (allSalesData == null || allSalesData.Length != count)
		{
			allSalesData = new SalesData[count];
			for (int i = 0; i < count; i++)
			{
				bool flag = sellOrders.sellOrders[i].itemToSellID == ScrapItem.itemid;
				allSalesData[i] = new SalesData
				{
					IsForReceivedCurrency = flag,
					CurrentMultiplier = (flag ? MinimumPriceMultiplier : StartingPriceMultiplier)
				};
			}
		}
	}

	protected override float GetDiscountForSlot(int sellOrderSlot, SellOrder forOrder)
	{
		if (!CanApplyDynamicPricing)
		{
			return 1f;
		}
		if (!preserveSalesData)
		{
			CheckSalesDataLength();
		}
		if (sellOrderSlot < 0 || sellOrderSlot >= allSalesData.Length)
		{
			return 1f;
		}
		if (forOrder.currencyID != ScrapItem.itemid)
		{
			return 1f;
		}
		return allSalesData[sellOrderSlot].CurrentMultiplier;
	}

	protected override float GetReceivedQuantityMultiplier(int sellOrderSlot, SellOrder forOrder)
	{
		if (!CanApplyDynamicPricing)
		{
			return 1f;
		}
		if (!preserveSalesData)
		{
			CheckSalesDataLength();
		}
		if (sellOrderSlot < 0 || sellOrderSlot >= allSalesData.Length)
		{
			return 1f;
		}
		if (forOrder.itemToSellID != ScrapItem.itemid)
		{
			return 1f;
		}
		return allSalesData[sellOrderSlot].CurrentMultiplier;
	}

	private void DynamicPricingServerInit()
	{
		timeToNextSalesUpdate = IntervalSeconds;
		((FacepunchBehaviour)this).InvokeRandomized((Action)HourCheck, 1f, 15f, 0.1f);
	}

	private void ResetDynamicPricing()
	{
		CheckSalesDataLength(reset: true);
		timeToNextSalesUpdate = IntervalSeconds;
		HourCheck();
	}

	private void HourCheck()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (!CanApplyDynamicPricing)
		{
			return;
		}
		float num = TimeSince.op_Implicit(lastHourCheck);
		lastHourCheck = TimeSince.op_Implicit(0f);
		timeToNextSalesUpdate -= num;
		while (timeToNextSalesUpdate < 0f)
		{
			timeToNextSalesUpdate += IntervalSeconds;
			SalesData[] array = allSalesData;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].ProcessEndOfInterval();
			}
			UpdateMapMarker();
			RefreshAndSendNetworkUpdate();
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (allSalesData != null && info.forDisk)
		{
			info.msg.vendingDynamicPricing = Pool.Get<VendingDynamicPricing>();
			info.msg.vendingDynamicPricing.allSalesData = Pool.Get<List<SalesData>>();
			info.msg.vendingDynamicPricing.timeToNextSalesUpdate = timeToNextSalesUpdate;
			SalesData[] array = allSalesData;
			foreach (SalesData salesData in array)
			{
				SalesData val = Pool.Get<SalesData>();
				val.totalSales = salesData.TotalSales;
				val.totalIntervals = salesData.TotalIntervals;
				val.soldThisInterval = salesData.SoldThisInterval;
				val.currentMultiplier = salesData.CurrentMultiplier;
				val.isForReceivedQuantity = salesData.IsForReceivedCurrency;
				info.msg.vendingDynamicPricing.allSalesData.Add(val);
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		if (info.msg.vendingDynamicPricing != null)
		{
			allSalesData = new SalesData[info.msg.vendingDynamicPricing.allSalesData.Count];
			int num = 0;
			timeToNextSalesUpdate = info.msg.vendingDynamicPricing.timeToNextSalesUpdate;
			foreach (SalesData allSalesDatum in info.msg.vendingDynamicPricing.allSalesData)
			{
				SalesData salesData = new SalesData
				{
					TotalSales = allSalesDatum.totalSales,
					TotalIntervals = allSalesDatum.totalIntervals,
					SoldThisInterval = allSalesDatum.soldThisInterval,
					CurrentMultiplier = allSalesDatum.currentMultiplier,
					IsForReceivedCurrency = allSalesDatum.isForReceivedQuantity
				};
				allSalesData[num] = salesData;
				num++;
			}
		}
		base.Load(info);
	}
}


using UnityEngine;

public class SalesData
{
	public ulong TotalSales;

	public ulong TotalIntervals;

	public ulong SoldThisInterval;

	public float CurrentMultiplier;

	public bool IsForReceivedCurrency;

	public double GetAverageSalesPerInterval()
	{
		if (TotalSales == 0L || TotalIntervals == 0L)
		{
			return 0.0;
		}
		return (double)TotalSales / (double)TotalIntervals;
	}

	public void RecordSale(int count)
	{
		SoldThisInterval += (ulong)count;
	}

	public void ProcessEndOfInterval()
	{
		double averageSalesPerInterval = GetAverageSalesPerInterval();
		bool flag = TotalIntervals == 0;
		TotalSales += SoldThisInterval;
		TotalIntervals++;
		SoldThisInterval = 0uL;
		float num = 0f;
		num = ((!(GetAverageSalesPerInterval() <= averageSalesPerInterval || flag)) ? PriceIncreaseAmount : (0f - PriceDecreaseAmount));
		if (IsForReceivedCurrency)
		{
			CurrentMultiplier -= num;
		}
		else
		{
			CurrentMultiplier += num;
		}
		CurrentMultiplier = Mathf.Clamp(CurrentMultiplier, MinimumPriceMultiplier, MaximumPriceMultiplier);
	}
}


using UnityEngine;
using UnityEngine.UI;

public class AddSellOrderManager : MonoBehaviour
{
	public VirtualItemIcon sellItemIcon;

	public VirtualItemIcon currencyItemIcon;

	public GameObject itemSearchParent;

	public ItemSearchEntry itemSearchEntryPrefab;

	public InputField sellItemInput;

	public InputField sellItemAmount;

	public InputField currencyItemInput;

	public InputField currencyItemAmount;

	public VendingPanelAdmin adminPanel;
}


using UnityEngine;

public class AdminExistingSellOrder : MonoBehaviour
{
	public VirtualItemIcon MerchandiseIcon;

	public VirtualItemIcon CurrencyIcon;

	private VendingPanelAdmin adminPanel;

	private int index;
}


using UnityEngine;
using UnityEngine.UI;

public class ItemSearchEntry : MonoBehaviour
{
	public Button button;

	public Text text;

	public RawImage image;

	public RawImage bpImage;
}


using UnityEngine;

public class LootPanelVendingMachine : LootPanel, IVendingMachineInterface
{
	public GameObjectRef sellOrderPrefab;

	public GameObject sellOrderContainer;

	public GameObject busyOverlayPrefab;

	private GameObject busyOverlayInstance;
}


public interface IVendingMachineInterface
{
}


using UnityEngine;

public class SellOrderEntry : MonoBehaviour, IInventoryChanged
{
	public VirtualItemIcon MerchandiseIcon;

	public VirtualItemIcon CurrencyIcon;

	private ItemDefinition merchandiseInfo;

	private ItemDefinition currencyInfo;

	public GameObject buyButton;

	public GameObject cantaffordNotification;

	public GameObject outOfStockNotification;

	private IVendingMachineInterface vendingPanel;

	public UIIntegerEntry intEntry;

	public VendingPriceMultiplierWidget priceMultiplier;

	public VendingPriceMultiplierWidget receivedCurrencyMultiplier;
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class FeedEntry : FacepunchBehaviour
{
	[Header("References")]
	public FlexElement Element;

	[SerializeField]
	private FlexTransition transition;

	public RectTransform TimeElement;

	[Header("Text")]
	public RustText IndexText;

	public RustText SoldText;

	public RustText EarnedText;

	[Header("Icons")]
	public Image IndexBacking;

	public VirtualItemIcon SoldIcon;

	public VirtualItemIcon EarnedIcon;

	[Header("Tooltips")]
	public Tooltip SoldIconTooltip;

	public Tooltip EarnedIconTooltip;

	public Tooltip TimeTooltip;
}


using TMPro;
using UnityEngine;

public class VendingPanelAdmin : UIDialog
{
	public GameObjectRef statsPanelRef;

	public AddSellOrderManager sellOrderManager;

	public EmojiGallery emojiGallery;

	public GameObject sellOrderAdminContainer;

	public GameObject sellOrderAdminPrefab;

	public TMP_InputField storeNameInputField;

	[Header("Drone Prediction")]
	public DeliveryDroneConfig predictionConfig;

	public GameObject droneAccessible;

	public GameObject droneInaccessible;
}


using Rust.UI;
using UnityEngine;

public class VendingPanelAdminStats : UIDialog
{
	[Header("References")]
	public Transform Feed;

	public TmProEmojiRedirector ShopName;

	public Dropdown TimeDropdown;

	public RustButton[] CategoryButtons;

	public RustText TotalSalesLabel;

	public RustText TotalSalesValue;

	public RustText PeakSaleHourLabel;

	public RustText PeakSaleHourValue;

	public RustText UniqueCustomersLabel;

	public RustText UniqueCustomersValue;

	public RustText RepeatCustomersLabel;

	public RustText RepeatCustomersValue;

	public RustText BestCustomerLabel;

	public RustText BestCustomerValue;

	[Header("Prefabs")]
	public GameObjectRef FeedEntryPrefab;

	public GameObjectRef SingleEntryPrefab;

	public GameObjectRef EmptyFeedEntryPrefab;
}


using Rust.UI;
using UnityEngine;

public class VendingPriceMultiplierWidget : MonoBehaviour
{
	public GameObject SurchargeRoot;

	public RustText SurchargeText;

	public GameObject DiscountRoot;

	public RustText DiscountText;

	public Tooltip SurchargeTooltip;

	public Tooltip DiscountTooltip;

	public GameObject RegularTooltip;

	public GameObject AlwaysOnTopTooltip;

	public bool Invert;
}


public class VendingMachineFront : BaseEntity
{
	public VendingMachine vendingMachine;
}


using UnityEngine;
using UnityEngine.UI;

public class VendingMachineScreen : MonoBehaviour, INotifyLOD, IClientComponent
{
	public enum vmScreenState
	{
		ItemScroll,
		Vending,
		Message,
		ShopName,
		OutOfStock
	}

	public RawImage largeIcon;

	public RawImage blueprintIcon;

	public Text mainText;

	public Text lowerText;

	public Text centerText;

	public RawImage smallIcon;

	public VendingMachine vendingMachine;

	public Sprite outOfStockSprite;

	public Renderer fadeoutMesh;

	public CanvasGroup screenCanvas;

	public Renderer light1;

	public Renderer light2;

	public bool isUpdatedWithNotifySystem;
}


public enum vmScreenState
{
	ItemScroll,
	Vending,
	Message,
	ShopName,
	OutOfStock
}


using System;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class ElectricWindmill : IOEntity
{
	public Animator animator;

	public int maxPowerGeneration = 100;

	public Transform vaneRot;

	public SoundDefinition wooshSound;

	public Transform wooshOrigin;

	private float cachedHeight;

	public float serverWindSpeed;

	public override int MaximalPowerOutput()
	{
		return maxPowerGeneration;
	}

	public override bool IsRootEntity()
	{
		return true;
	}

	public Vector3 GetWindAimDir(float time)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		float num = time / 3600f * 360f;
		int num2 = 10;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(Mathf.Sin(num * (MathF.PI / 180f)) * (float)num2, 0f, Mathf.Cos(num * (MathF.PI / 180f)) * (float)num2);
		return ((Vector3)(ref val)).normalized;
	}

	public override void ServerInit()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)WindUpdate, 1f, 20f, 2f);
		if (GamePhysics.Trace(new Ray(((Component)this).transform.position, Vector3.down), 0f, out var hitInfo, 10f, 8454144, (QueryTriggerInteraction)1, this))
		{
			cachedHeight = ((Component)this).transform.position.y - ((RaycastHit)(ref hitInfo)).point.y;
		}
		else
		{
			cachedHeight = ((Component)this).transform.position.y - TerrainMeta.HeightMap.GetHeight(((Component)this).transform.position);
		}
	}

	public bool AmIVisible()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		int num = 15;
		Vector3 val = ((Component)this).transform.position + Vector3.up * 6f;
		if (!IsVisible(val + ((Component)this).transform.up * (float)num, (float)(num + 1)))
		{
			return false;
		}
		Vector3 windAimDir = GetWindAimDir(Time.time);
		if (!IsVisible(val + windAimDir * (float)num, (float)(num + 1)))
		{
			return false;
		}
		return true;
	}

	public void WindUpdate()
	{
		if (Interface.CallHook("OnWindmillUpdate", (object)this) == null)
		{
			serverWindSpeed = GetWindSpeedScale();
			if (!AmIVisible())
			{
				serverWindSpeed = 0f;
			}
			int num = Mathf.FloorToInt((float)maxPowerGeneration * serverWindSpeed);
			bool num2 = currentEnergy != num;
			currentEnergy = num;
			if (num2)
			{
				MarkDirty();
			}
			SendNetworkUpdate();
			Interface.CallHook("OnWindmillUpdated", (object)this);
		}
	}

	public float GetWindSpeedScale()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.time / 600f;
		float num2 = ((Component)this).transform.position.x / 512f;
		float num3 = ((Component)this).transform.position.z / 512f;
		float num4 = Mathf.PerlinNoise(num2 + num, num3 + num * 0.1f);
		float num5 = cachedHeight;
		if (num5 < 0f)
		{
			num5 = 0f;
		}
		return Mathf.Clamp01(Mathf.InverseLerp(0f, 50f, num5) * 0.5f + num4);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (outputSlot != 0)
		{
			return 0;
		}
		return currentEnergy;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk)
		{
			if (info.msg.ioEntity == null)
			{
				info.msg.ioEntity = Pool.Get<IOEntity>();
			}
			info.msg.ioEntity.genericFloat1 = Time.time;
			info.msg.ioEntity.genericFloat2 = serverWindSpeed;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}
}


using ProtoBuf;

public class ItemModBeehiveNucleus : ItemMod
{
	public override void OnVirginItem(Item item, BasePlayer creatingPlayer)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Expected O, but got Unknown
		base.OnVirginItem(item, creatingPlayer);
		item.instanceData = new InstanceData
		{
			ShouldPool = false,
			dataInt = 0
		};
	}
}


using ProtoBuf;
using UnityEngine;

public class NucleusGradeItemSwap : ItemModSwap
{
	public ItemDefinition NucleusItem;

	protected override void AugmentItem(Item item)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Expected O, but got Unknown
		if ((Object)(object)item.info == (Object)(object)NucleusItem)
		{
			item.instanceData = new InstanceData
			{
				ShouldPool = false,
				dataInt = 0
			};
		}
	}
}


using System.Collections.Generic;

public static class NucleusGrading
{
	public enum NucleusGrade
	{
		Grade3,
		Grade2,
		Grade1
	}

	private static readonly Dictionary<NucleusGrade, float> NucleusXpThresholds = new Dictionary<NucleusGrade, float>
	{
		{
			NucleusGrade.Grade3,
			0f
		},
		{
			NucleusGrade.Grade2,
			200f
		},
		{
			NucleusGrade.Grade1,
			600f
		}
	};

	public static float GetXpThreshold(NucleusGrade grade)
	{
		return NucleusXpThresholds[grade];
	}

	public static string GetGradeAsString(NucleusGrade grade)
	{
		return grade switch
		{
			NucleusGrade.Grade3 => "3", 
			NucleusGrade.Grade2 => "2", 
			NucleusGrade.Grade1 => "1", 
			_ => "0", 
		};
	}

	public static NucleusGrade XpToGrade(float xp)
	{
		if (xp >= NucleusXpThresholds[NucleusGrade.Grade1])
		{
			return NucleusGrade.Grade1;
		}
		if (xp >= NucleusXpThresholds[NucleusGrade.Grade2])
		{
			return NucleusGrade.Grade2;
		}
		return NucleusGrade.Grade3;
	}

	public static float XpToNextGrade(float currentXp)
	{
		NucleusGrade key;
		switch (XpToGrade(currentXp))
		{
		case NucleusGrade.Grade3:
			key = NucleusGrade.Grade2;
			break;
		case NucleusGrade.Grade2:
			key = NucleusGrade.Grade1;
			break;
		default:
			return 0f;
		}
		return NucleusXpThresholds[key] - currentXp;
	}
}


public enum NucleusGrade
{
	Grade3,
	Grade2,
	Grade1
}


using System.Text;
using Rust.UI;

public class NucleusInformationPanel : ItemInformationPanel
{
	public InfoBar xpDisplay;

	public RustText gradeLabel;

	public RustText nextLevelLabel;

	public static readonly Phrase GradePhrase = new Phrase("nucleus.grade", "GRADE");

	public static readonly Phrase XPPhrase = new Phrase("nucleus.xp", "XP");

	public static readonly Phrase RequiredPhrase = new Phrase("nucleus.required", "REQUIRED");

	public static readonly Phrase MaxPhrase = new Phrase("nucleus.max", "MAX LEVEL");

	private static StringBuilder builder;
}


using UnityEngine;

public class FoodIcon : MonoBehaviour, IEditorComponent
{
	public ItemDefinition FoodItem;
}


using UnityEngine;

public class InstrumentStateBehaviour : StateMachineBehaviour
{
}


using UnityEngine;

public class InstrumentViewmodel : MonoBehaviour
{
	public Animator ViewAnimator;

	public bool UpdateA = true;

	public bool UpdateB = true;

	public bool UpdateC = true;

	public bool UpdateD = true;

	public bool UpdateE = true;

	public bool UpdateF = true;

	public bool UpdateG = true;

	public bool UpdateRecentlyPlayed = true;

	public bool UpdatePlayedNoteTrigger;

	public bool UseTriggers;

	private readonly int note_a = Animator.StringToHash("play_A");

	private readonly int note_b = Animator.StringToHash("play_B");

	private readonly int note_c = Animator.StringToHash("play_C");

	private readonly int note_d = Animator.StringToHash("play_D");

	private readonly int note_e = Animator.StringToHash("play_E");

	private readonly int note_f = Animator.StringToHash("play_F");

	private readonly int note_g = Animator.StringToHash("play_G");

	private readonly int recentlyPlayedHash = Animator.StringToHash("recentlyPlayed");

	private readonly int playedNoteHash = Animator.StringToHash("playedNote");

	public void UpdateSlots(InstrumentKeyController.AnimationSlot currentSlot, bool recentlyPlayed, bool playedNoteThisFrame)
	{
		if (!((Object)(object)ViewAnimator == (Object)null))
		{
			if (UpdateA)
			{
				UpdateState(note_a, currentSlot == InstrumentKeyController.AnimationSlot.One);
			}
			if (UpdateB)
			{
				UpdateState(note_b, currentSlot == InstrumentKeyController.AnimationSlot.Two);
			}
			if (UpdateC)
			{
				UpdateState(note_c, currentSlot == InstrumentKeyController.AnimationSlot.Three);
			}
			if (UpdateD)
			{
				UpdateState(note_d, currentSlot == InstrumentKeyController.AnimationSlot.Four);
			}
			if (UpdateE)
			{
				UpdateState(note_e, currentSlot == InstrumentKeyController.AnimationSlot.Five);
			}
			if (UpdateF)
			{
				UpdateState(note_f, currentSlot == InstrumentKeyController.AnimationSlot.Six);
			}
			if (UpdateG)
			{
				UpdateState(note_g, currentSlot == InstrumentKeyController.AnimationSlot.Seven);
			}
			if (UpdateRecentlyPlayed)
			{
				ViewAnimator.SetBool(recentlyPlayedHash, recentlyPlayed);
			}
			if (UpdatePlayedNoteTrigger && playedNoteThisFrame)
			{
				ViewAnimator.SetTrigger(playedNoteHash);
			}
		}
	}

	private void UpdateState(int param, bool state)
	{
		if (!UseTriggers)
		{
			ViewAnimator.SetBool(param, state);
		}
		else if (state)
		{
			ViewAnimator.SetTrigger(param);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Rust;
using Oxide.Core;
using UnityEngine;

public class BigWheelGame : SpinnerWheel
{
	public float baseSpeed = 180f;

	public float offset = 3.852f;

	public AnimationCurve decelerationCurve;

	public AnimationCurve speedCurve;

	public HitNumber[] hitNumbers;

	private float targetAngle;

	private float minimumSpinTime;

	private bool isSpinning;

	private bool decelerating;

	private float elapsedTime;

	private Random random;

	[ServerVar]
	public static float spinFrequencySeconds = 45f;

	public int spinNumber;

	protected int targetNumber;

	public int lastPaidSpinNumber = -1;

	public List<BigWheelBettingTerminal> terminals = new List<BigWheelBettingTerminal>();

	public override bool AllowPlayerSpins()
	{
		return false;
	}

	public override bool CanUpdateSign(BasePlayer player)
	{
		return false;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)InitBettingTerminals, 3f);
		((FacepunchBehaviour)this).Invoke((Action)DoSpin, 10f);
	}

	public void DoSpin()
	{
		int seed = Random.Range(int.MinValue, int.MaxValue);
		random = new Random(seed);
		targetNumber = random.Next(0, hitNumbers.Length);
		targetAngle = 0f - 360f / (float)hitNumbers.Length * (float)targetNumber + offset;
		targetAngle += (float)(random.NextDouble() * 12.0 - 6.0);
		minimumSpinTime = (float)(random.NextDouble() * 5.0 + 13.0);
		elapsedTime = 0f;
		isSpinning = true;
		decelerating = false;
		spinNumber++;
		SetTerminalsLocked(isLocked: true);
	}

	public void SetTerminalsLocked(bool isLocked)
	{
		foreach (BigWheelBettingTerminal terminal in terminals)
		{
			terminal.inventory.SetLocked(isLocked);
		}
	}

	public void RemoveTerminal(BigWheelBettingTerminal terminal)
	{
		terminals.Remove(terminal);
	}

	public void InitBettingTerminals()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		terminals.Clear();
		Vis.Entities(((Component)this).transform.position, 30f, terminals, 256, (QueryTriggerInteraction)2);
		terminals = terminals.Distinct().ToList();
	}

	public float GetMaxSpinSpeed(float time)
	{
		return baseSpeed * speedCurve.Evaluate(time / minimumSpinTime);
	}

	public override void Update_Server()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		if (!isSpinning)
		{
			return;
		}
		float deltaTime = Time.deltaTime;
		elapsedTime += deltaTime;
		float num = NormalizeAngle(wheel.localEulerAngles.y);
		float num2 = NormalizeAngle(targetAngle);
		float num3 = (num2 - num + 360f) % 360f;
		if (!decelerating && (elapsedTime < minimumSpinTime || num3 < 120f))
		{
			float maxSpinSpeed = GetMaxSpinSpeed(elapsedTime);
			wheel.Rotate(((Component)this).transform.up, maxSpinSpeed * deltaTime, (Space)0);
		}
		else
		{
			decelerating = true;
			float num4 = decelerationCurve.Evaluate(num3 / 180f);
			float num5 = GetMaxSpinSpeed(elapsedTime) * num4 * deltaTime;
			if (num5 > num3)
			{
				num5 = num3;
			}
			wheel.Rotate(((Component)this).transform.up, num5, (Space)0);
			if (num3 < 0.1f)
			{
				wheel.localRotation = Quaternion.Euler(0f, num2, 0f);
				isSpinning = false;
				if (spinNumber > lastPaidSpinNumber)
				{
					Payout();
					lastPaidSpinNumber = spinNumber;
					QueueSpin();
				}
			}
		}
		SendNetworkUpdate();
	}

	private float NormalizeAngle(float angle)
	{
		angle %= 360f;
		if (angle < 0f)
		{
			angle += 360f;
		}
		return angle;
	}

	public float SpinSpacing()
	{
		return spinFrequencySeconds;
	}

	public void QueueSpin()
	{
		foreach (BigWheelBettingTerminal terminal in terminals)
		{
			terminal.ClientRPC(RpcTarget.NetworkGroup("SetTimeUntilNextSpin"), SpinSpacing());
		}
		((FacepunchBehaviour)this).Invoke((Action)DoSpin, SpinSpacing());
	}

	public void Payout()
	{
		HitNumber currentHitType = GetCurrentHitType();
		Guid value = Guid.NewGuid();
		foreach (BigWheelBettingTerminal terminal in terminals)
		{
			if (terminal.isClient)
			{
				continue;
			}
			bool flag = false;
			bool flag2 = false;
			Item slot = terminal.inventory.GetSlot((int)currentHitType.hitType);
			if (slot != null)
			{
				int num = currentHitType.ColorToMultiplier(currentHitType.hitType);
				int amount = slot.amount;
				if (Interface.CallHook("OnBigWheelWin", (object)this, (object)slot, (object)terminal, (object)num) == null)
				{
					slot.amount += slot.amount * num;
					slot.RemoveFromContainer();
					slot.MoveToContainer(terminal.inventory, 5);
					flag = true;
					Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, amount, slot.amount, value);
				}
			}
			for (int i = 0; i < 5; i++)
			{
				Item slot2 = terminal.inventory.GetSlot(i);
				if (slot2 != null && Interface.CallHook("OnBigWheelLoss", (object)this, (object)slot2, (object)terminal) == null)
				{
					Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, slot2.amount, 0, value);
					slot2.Remove();
					flag2 = true;
				}
			}
			if (flag || flag2)
			{
				terminal.ClientRPC(RpcTarget.NetworkGroup("WinOrLoseSound"), flag);
			}
		}
		ItemManager.DoRemoves();
		SetTerminalsLocked(isLocked: false);
	}

	public HitNumber GetCurrentHitType()
	{
		return hitNumbers[targetNumber];
	}
}


using UnityEngine;

public class HitNumber : MonoBehaviour
{
	public enum HitType
	{
		Yellow,
		Green,
		Blue,
		Purple,
		Red
	}

	public HitType hitType;

	public int ColorToMultiplier(HitType type)
	{
		return type switch
		{
			HitType.Yellow => 1, 
			HitType.Green => 3, 
			HitType.Blue => 5, 
			HitType.Purple => 10, 
			HitType.Red => 20, 
			_ => 0, 
		};
	}

	public void OnDrawGizmosSelected()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.white;
		Gizmos.DrawSphere(((Component)this).transform.position, 0.025f);
	}
}


public enum HitType
{
	Yellow,
	Green,
	Blue,
	Purple,
	Red
}


using Rust.UI;

public class LootPanelBigWheelTerminal : LootPanel
{
	public RustText timeRemainingText;
}


using UnityEngine.UI;

public class SlotMachineLootPanel : LootPanel
{
	public Text spinsRemainingText;

	public Text multiplierText;

	public LocalizeText ScrapCostText;
}


using UnityEngine;

public class SlotMachinePayoutDisplay : MonoBehaviour
{
	public GameObjectRef PayoutWidget;

	public RectTransform WidgetRoot;

	public Sprite[] FaceSprites;
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Slot Machine Payouts")]
public class SlotMachinePayoutSettings : ScriptableObject
{
	[Serializable]
	public struct PayoutInfo
	{
		public ItemAmount Item;

		[Range(0f, 15f)]
		public int Result1;

		[Range(0f, 15f)]
		public int Result2;

		[Range(0f, 15f)]
		public int Result3;

		public GameObjectRef OverrideWinEffect;
	}

	[Serializable]
	public struct IndividualPayouts
	{
		public ItemAmount Item;

		[Range(0f, 15f)]
		public int Result;
	}

	public ItemAmount SpinCost;

	public PayoutInfo[] Payouts;

	public int[] VirtualFaces = new int[16];

	public IndividualPayouts[] FacePayouts = new IndividualPayouts[0];

	public int TotalStops;

	public GameObjectRef DefaultWinEffect;
}


using System;
using UnityEngine;

[Serializable]
public struct PayoutInfo
{
	public ItemAmount Item;

	[Range(0f, 15f)]
	public int Result1;

	[Range(0f, 15f)]
	public int Result2;

	[Range(0f, 15f)]
	public int Result3;

	public GameObjectRef OverrideWinEffect;
}


using System;
using UnityEngine;

[Serializable]
public struct IndividualPayouts
{
	public ItemAmount Item;

	[Range(0f, 15f)]
	public int Result;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class SlotMachinePayoutWidget : MonoBehaviour
{
	public RustText PayoutAmount;

	public GameObject AnyText;

	public Image[] Faces;
}


using UnityEngine;

public class ChineseLantern : BaseFuelLightSource
{
	public Transform pivotRotator;

	public float swaySpeed = 1f;

	public float swayDistance = 0.25f;

	public float lerpSpeed = 2f;
}


using System;
using Rust;
using UnityEngine;

public class SkyLantern : StorageContainer, IIgniteable
{
	public float gravityScale = -0.1f;

	public float travelSpeed = 2f;

	public float collisionRadius = 0.5f;

	public float rotationSpeed = 5f;

	public float randOffset = 1f;

	public float lifeTime = 120f;

	public float hoverHeight = 14f;

	public Transform collisionCheckPoint;

	private float idealAltitude;

	private Vector3 travelVec = Vector3.forward;

	private float takeOffY;

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override void ServerInit()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		randOffset = ((Random.Range(0.5f, 1f) * (float)Random.Range(0, 2) == 1f) ? (-1f) : 1f);
		Vector3 val = Vector3.forward + Vector3.right * randOffset;
		travelVec = ((Vector3)(ref val)).normalized;
		((FacepunchBehaviour)this).Invoke((Action)StartSinking, lifeTime - 15f);
		((FacepunchBehaviour)this).Invoke((Action)SelfDestroy, lifeTime);
		travelSpeed = Random.Range(1.75f, 2.25f);
		gravityScale *= Random.Range(1f, 1.25f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateIdealAltitude, 0f, 1f);
	}

	public void Ignite(Vector3 fromPos)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).gameObject.transform.RemoveComponent<GroundWatch>();
		((Component)this).gameObject.transform.RemoveComponent<DestroyOnGroundMissing>();
		((Component)this).gameObject.layer = 14;
		takeOffY = ((Component)this).transform.position.y;
		travelVec = Vector3Ex.Direction2D(((Component)this).transform.position, fromPos);
		SetFlag(Flags.On, b: true);
		UpdateIdealAltitude();
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.OnAttacked(info);
		if (base.isServer)
		{
			if (info.damageTypes.Has(DamageType.Heat) && CanIgnite())
			{
				Ignite(info.PointStart);
			}
			else if (IsOn() && !IsBroken())
			{
				StartSinking();
			}
		}
	}

	public void SelfDestroy()
	{
		Kill();
	}

	public bool CanIgnite()
	{
		if (!IsOn())
		{
			return !IsBroken();
		}
		return false;
	}

	public void UpdateIdealAltitude()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (IsOn())
		{
			idealAltitude = WaterLevel.GetWaterOrTerrainSurface(((Component)this).transform.position, waves: false, volumes: false) + hoverHeight;
			if (takeOffY > idealAltitude)
			{
				idealAltitude = takeOffY + hoverHeight;
			}
			if (hoverHeight != 0f)
			{
				idealAltitude -= 2f * Mathf.Abs(randOffset);
			}
		}
	}

	public void StartSinking()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (!IsBroken())
		{
			hoverHeight = 0f;
			travelVec = Vector3.zero;
			UpdateIdealAltitude();
			SetFlag(Flags.Broken, b: true);
		}
	}

	public void FixedUpdate()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient && IsOn())
		{
			float num = Mathf.Abs(((Component)this).transform.position.y - idealAltitude);
			float num2 = ((((Component)this).transform.position.y < idealAltitude) ? (-1f) : 1f);
			float num3 = Mathf.InverseLerp(0f, 10f, num) * num2;
			if (IsBroken())
			{
				travelVec = Vector3.Lerp(travelVec, Vector3.zero, Time.fixedDeltaTime * 0.5f);
				num3 = 0.7f;
			}
			Vector3 zero = Vector3.zero;
			zero = Vector3.up * gravityScale * Physics.gravity.y * num3;
			zero += travelVec * travelSpeed;
			Vector3 val = ((Component)this).transform.position + zero * Time.fixedDeltaTime;
			Vector3 val2 = Vector3Ex.Direction(val, ((Component)this).transform.position);
			float num4 = Vector3.Distance(val, ((Component)this).transform.position);
			RaycastHit val3 = default(RaycastHit);
			if (!Physics.SphereCast(collisionCheckPoint.position, collisionRadius, val2, ref val3, num4, 1218519297))
			{
				((Component)this).transform.position = val;
				((Component)this).transform.Rotate(Vector3.up, rotationSpeed * randOffset * Time.deltaTime, (Space)1);
			}
			else
			{
				StartSinking();
			}
		}
	}
}


using UnityEngine;

public class FirecrackerRepeater : BaseMonoBehaviour, IClientComponent
{
	public GameObjectRef singleExplosionEffect;

	public Transform[] parts;

	public float partWidth = 0.2f;

	public float partLength = 0.1f;

	public Quaternion[] targetRotations;

	public Quaternion[] initialRotations;

	public Renderer[] renderers;

	public Material materialSource;

	public float explodeRepeatMin = 0.05f;

	public float explodeRepeatMax = 0.15f;

	public float explodeLerpSpeed = 30f;

	public Vector3 twistAmount;

	public float fuseLength = 3f;

	public float explodeStrength = 10f;

	public float explodeDirBlend = 0.5f;

	public float duration = 10f;

	public ParticleSystemContainer smokeParticle;
}


using UnityEngine;

public class StringFirecracker : TimedExplosive
{
	public Rigidbody serverRigidBody;

	public Rigidbody clientMiddleBody;

	public Rigidbody[] clientParts;

	public SpringJoint serverClientJoint;

	public Transform clientFirecrackerTransform;

	public override void InitShared()
	{
		base.InitShared();
		if (!base.isServer)
		{
			return;
		}
		Rigidbody[] array = clientParts;
		foreach (Rigidbody val in array)
		{
			if ((Object)(object)val != (Object)null)
			{
				val.isKinematic = true;
			}
		}
	}

	public void CreatePinJoint()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)serverClientJoint != (Object)null))
		{
			serverClientJoint = ((Component)this).gameObject.AddComponent<SpringJoint>();
			((Joint)serverClientJoint).connectedBody = clientMiddleBody;
			((Joint)serverClientJoint).autoConfigureConnectedAnchor = false;
			((Joint)serverClientJoint).anchor = Vector3.zero;
			((Joint)serverClientJoint).connectedAnchor = Vector3.zero;
			serverClientJoint.minDistance = 0f;
			serverClientJoint.maxDistance = 1f;
			serverClientJoint.damper = 1000f;
			serverClientJoint.spring = 5000f;
			((Joint)serverClientJoint).enableCollision = false;
			((Joint)serverClientJoint).enablePreprocessing = false;
		}
	}
}


public class ArcadeClientAuthTest : ArcadeEntityController
{
	public float speed = 0.2f;

	public float maxSpeed = 1f;

	public BaseArcadeGame myGame;

	public ArcadeEntity myEntity;
}


using System;
using UnityEngine;

public class ArcadeEntity : BaseMonoBehaviour
{
	public uint id;

	public uint spriteID;

	public uint soundID;

	public bool visible;

	public Vector3 heading = new Vector3(0f, 1f, 0f);

	public bool isEnabled;

	public bool dirty;

	public float alpha = 1f;

	public BoxCollider boxCollider;

	public bool host;

	public bool localAuthorativeOverride;

	public ArcadeEntity arcadeEntityParent;

	public uint prefabID;

	[Header("Health")]
	public bool takesDamage;

	public float health = 1f;

	public float maxHealth = 1f;

	[NonSerialized]
	public bool mapLoadedEntiy;
}


using UnityEngine;

public class ArcadeEntityController : BaseMonoBehaviour
{
	public BaseArcadeGame parentGame;

	public ArcadeEntity arcadeEntity;

	public ArcadeEntity sourceEntity;

	public Vector3 heading
	{
		get
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return arcadeEntity.heading;
		}
		set
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			arcadeEntity.heading = value;
		}
	}

	public Vector3 positionLocal
	{
		get
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			return ((Component)arcadeEntity).transform.localPosition;
		}
		set
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			((Component)arcadeEntity).transform.localPosition = value;
		}
	}

	public Vector3 positionWorld
	{
		get
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			return ((Component)arcadeEntity).transform.position;
		}
		set
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			((Component)arcadeEntity).transform.position = value;
		}
	}
}


using UnityEngine;

public class ArcadeNetworkTrigger : TriggerBase
{
	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class BaseArcadeGame : BaseMonoBehaviour
{
	public static List<BaseArcadeGame> globalActiveGames = new List<BaseArcadeGame>();

	public Camera cameraToRender;

	public RenderTexture renderTexture;

	public Texture2D distantTexture;

	public Transform center;

	public int frameRate = 30;

	public Dictionary<uint, ArcadeEntity> activeArcadeEntities = new Dictionary<uint, ArcadeEntity>();

	public Sprite[] spriteManifest;

	public ArcadeEntity[] entityManifest;

	public bool clientside;

	public bool clientsideInput = true;

	public const int spriteIndexInvisible = 1555;

	public GameObject arcadeEntityPrefab;

	public BaseArcadeMachine ownerMachine;

	public static int gameOffsetIndex = 0;

	private bool isAuthorative;

	public Canvas canvas;

	public BasePlayer GetHostPlayer()
	{
		if (Object.op_Implicit((Object)(object)ownerMachine))
		{
			return ownerMachine.GetDriver();
		}
		return null;
	}
}


using System;
using UnityEngine;

public class BossFormController : ArcadeEntityController
{
	[Serializable]
	public class BossDamagePoint
	{
		public BoxCollider hitBox;

		public float health;

		public ArcadeEntityController damagePrefab;

		public ArcadeEntityController damageInstance;

		public bool destroyed;
	}

	public float animationSpeed = 0.5f;

	public Sprite[] animationFrames;

	public Vector2 roamDistance;

	public Transform colliderParent;

	public BossDamagePoint[] damagePoints;

	public ArcadeEntityController flashController;

	public float health = 50f;
}


using System;
using UnityEngine;

[Serializable]
public class BossDamagePoint
{
	public BoxCollider hitBox;

	public float health;

	public ArcadeEntityController damagePrefab;

	public ArcadeEntityController damageInstance;

	public bool destroyed;
}


using UnityEngine;

public class ChippyArcadeGame : BaseArcadeGame
{
	public ChippyMainCharacter mainChar;

	public SpriteArcadeEntity mainCharAim;

	public ChippyBoss currentBoss;

	public ChippyBoss[] bossPrefabs;

	public SpriteArcadeEntity mainMenuLogo;

	public Transform respawnPoint;

	public Vector2 mouseAim = new Vector2(0f, 1f);

	public TextArcadeEntity levelIndicator;

	public TextArcadeEntity gameOverIndicator;

	public TextArcadeEntity playGameButton;

	public TextArcadeEntity highScoresButton;

	public bool OnMainMenu;

	public bool GameActive;

	public int level;

	public TextArcadeEntity[] scoreDisplays;

	public MenuButtonArcadeEntity[] mainMenuButtons;

	public int selectedButtonIndex;

	public bool OnHighScores;
}


using System;
using UnityEngine;

public class ChippyBoss : SpriteArcadeEntity
{
	[Serializable]
	public class BossDamagePoint
	{
		public BoxCollider hitBox;

		public float health;

		public ArcadeEntityController damagePrefab;

		public ArcadeEntityController damageInstance;

		public bool destroyed;
	}

	public Vector2 roamDistance;

	public float animationSpeed = 0.5f;

	public Sprite[] animationFrames;

	public ArcadeEntity bulletTest;

	public SpriteRenderer flashRenderer;

	public BossDamagePoint[] damagePoints;
}


using System;
using UnityEngine;

[Serializable]
public class BossDamagePoint
{
	public BoxCollider hitBox;

	public float health;

	public ArcadeEntityController damagePrefab;

	public ArcadeEntityController damageInstance;

	public bool destroyed;
}


public class ChippyBulletEntity : SpriteArcadeEntity
{
	public float speed = 4f;

	public float maxSpeed = 4f;

	public float radius;

	public float damage = 1f;

	public ArcadeEntity bulletImpact;
}


using UnityEngine;

public class ChippyMainCharacter : SpriteArcadeEntity
{
	public float speed;

	public float maxSpeed = 0.25f;

	public ChippyBulletEntity bulletPrefab;

	public float fireRate = 0.1f;

	public Vector3 aimDir = Vector3.up;
}


using UnityEngine;

public class ChippyMoveTest : MonoBehaviour
{
	public Vector3 heading = new Vector3(0f, 1f, 0f);

	public float speed = 0.2f;

	public float maxSpeed = 1f;

	private void FixedUpdate()
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		float num = ((Mathf.Abs(((Vector3)(ref heading)).magnitude) > 0f) ? 1f : 0f);
		speed = Mathf.MoveTowards(speed, maxSpeed * num, Time.fixedDeltaTime * ((num == 0f) ? 2f : 2f));
		Vector3 position = ((Component)this).transform.position;
		Vector3 val = new Vector3(heading.x, heading.y, 0f);
		Ray val2 = default(Ray);
		((Ray)(ref val2))..ctor(position, ((Vector3)(ref val)).normalized);
		if (!Physics.Raycast(val2, speed * Time.fixedDeltaTime, 16777216))
		{
			Transform transform = ((Component)this).transform;
			transform.position += ((Ray)(ref val2)).direction * Time.fixedDeltaTime * speed;
			if (Mathf.Abs(((Vector3)(ref heading)).magnitude) > 0f)
			{
				Transform transform2 = ((Component)this).transform;
				Vector3 forward = ((Component)this).transform.forward;
				val = new Vector3(heading.x, heading.y, 0f);
				transform2.rotation = QuaternionEx.LookRotationForcedUp(forward, ((Vector3)(ref val)).normalized);
			}
		}
	}
}


using System;
using UnityEngine;

public class DestroyArcadeEntity : BaseMonoBehaviour
{
	public ArcadeEntity ent;

	public float TimeToDie = 1f;

	public float TimeToDieVariance;

	private void Start()
	{
		((FacepunchBehaviour)this).Invoke((Action)DestroyAction, TimeToDie, TimeToDieVariance * 0.5f);
	}

	private void DestroyAction()
	{
		if (((Object)(object)ent != (Object)null) & ent.host)
		{
			Object.Destroy((Object)(object)((Component)ent).gameObject);
		}
	}
}


public class MenuButtonArcadeEntity : TextArcadeEntity
{
	public string titleText = "";

	public string selectionSuffix = " - ";

	public string clickMessage = "";

	public bool IsHighlighted()
	{
		return alpha == 1f;
	}
}


using UnityEngine;

public class SpriteArcadeEntity : ArcadeEntity
{
	public SpriteRenderer spriteRenderer;
}


public class ArcadeTennisPaddle : ArcadeEntity
{
}


using UnityEngine;

public class TennisArcadeGame : BaseArcadeGame
{
	public ArcadeEntity paddle1;

	public ArcadeEntity paddle2;

	public ArcadeEntity ball;

	public Transform paddle1Origin;

	public Transform paddle2Origin;

	public Transform paddle1Goal;

	public Transform paddle2Goal;

	public Transform ballSpawn;

	public float maxScore = 5f;

	public ArcadeEntity[] paddle1ScoreNodes;

	public ArcadeEntity[] paddle2ScoreNodes;

	public int paddle1Score;

	public int paddle2Score;

	public float sensitivity = 1f;

	public ArcadeEntity logo;

	public bool OnMainMenu;

	public bool GameActive;
}


public class TennisBall : SpriteArcadeEntity
{
	public float speed = 2f;

	public float maxSpeed = 2f;
}


using TMPro;

public class TextArcadeEntity : ArcadeEntity
{
	public TextMeshProUGUI text;
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class HeadEntity : BaseEntity
{
	public HeadData CurrentTrophyData;

	private const Wearable.OccupationSlots HeadMask = Wearable.OccupationSlots.HeadTop | Wearable.OccupationSlots.Face | Wearable.OccupationSlots.HeadBack | Wearable.OccupationSlots.Mouth | Wearable.OccupationSlots.Eyes;

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.headData == null && CurrentTrophyData != null)
		{
			info.msg.headData = Pool.Get<HeadData>();
			CurrentTrophyData.CopyTo(info.msg.headData);
		}
	}

	public void SetupSourceId(uint sourceID)
	{
		InitTrophyData();
		CurrentTrophyData.entitySource = sourceID;
		CurrentTrophyData.horseBreed = 0;
		CurrentTrophyData.playerId = 0uL;
		CurrentTrophyData.playerName = string.Empty;
		CurrentTrophyData.clothing?.Clear();
	}

	public void SetupPlayerId(string playerName, ulong playerId)
	{
		InitTrophyData();
		CurrentTrophyData.playerName = playerName;
		CurrentTrophyData.playerId = playerId;
	}

	public void AssignClothing(ItemContainer container)
	{
		InitTrophyData();
		if (CurrentTrophyData.clothing == null)
		{
			CurrentTrophyData.clothing = Pool.Get<List<int>>();
		}
		ItemModWearable itemModWearable = default(ItemModWearable);
		foreach (Item item in container.itemList)
		{
			if (((Component)item.info).TryGetComponent<ItemModWearable>(ref itemModWearable) && itemModWearable.entityPrefab.isValid)
			{
				Wearable component = itemModWearable.entityPrefab.Get().GetComponent<Wearable>();
				if ((component.occupationOver & (Wearable.OccupationSlots.HeadTop | Wearable.OccupationSlots.Face | Wearable.OccupationSlots.HeadBack | Wearable.OccupationSlots.Mouth | Wearable.OccupationSlots.Eyes)) != 0 || component.occupationOver == (Wearable.OccupationSlots)0)
				{
					CurrentTrophyData.clothing.Add(item.info.itemid);
				}
			}
		}
	}

	public void AssignHorseBreed(int breed)
	{
		InitTrophyData();
		CurrentTrophyData.horseBreed = breed;
	}

	private void InitTrophyData()
	{
		if (CurrentTrophyData == null)
		{
			CurrentTrophyData = Pool.Get<HeadData>();
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.headData != null)
		{
			InitTrophyData();
			info.msg.headData.CopyTo(CurrentTrophyData);
		}
		else if (CurrentTrophyData != null)
		{
			Pool.Free<HeadData>(ref CurrentTrophyData);
		}
	}

	public GameObject GetHeadSource()
	{
		if (CurrentTrophyData == null)
		{
			return null;
		}
		return GameManager.server.FindPrefab(CurrentTrophyData.entitySource);
	}
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class RockingChair : BaseChair
{
	[Header("Rocking Settings")]
	public float Acceleration = 0.8f;

	public float MaxRockingAngle = 9f;

	public float MaxRockVelocity = 4f;

	[Tooltip("Preserve and apply some existing velocity when swinging back and forth.")]
	public bool ApplyVelocityBetweenSwings = true;

	[Range(0f, 2f)]
	public float AppliedVelocity = 1f;

	[Range(0f, 2f)]
	public float WeaponFireImpact = 3f;

	[Header("Audio")]
	public SoundDefinition creakForwardSoundDef;

	public SoundDefinition creakBackwardSoundDef;

	public float creakForwardAngle = 0.1f;

	public float creakBackwardAngle = -0.1f;

	public float creakVelocityThreshold = 0.02f;

	public AnimationCurve creakGainCurve;

	private float initLocalY;

	private Vector3 initLocalRot;

	private float velocity;

	private float oppositePotentialVelocity;

	private TimeSince timeSinceInput;

	private float sineTime;

	private float timeUntilStartSine = 0.4f;

	private float t;

	private float angle;

	private Quaternion max;

	private Quaternion min;

	public override void ServerInit()
	{
		base.ServerInit();
		SaveBaseLocalPos();
		ResetChair();
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		((FacepunchBehaviour)this).Invoke((Action)SaveBaseLocalPos, 0f);
	}

	private void SaveBaseLocalPos()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		Quaternion localRotation = ((Component)this).transform.localRotation;
		initLocalRot = ((Quaternion)(ref localRotation)).eulerAngles;
		initLocalY = ((Component)this).transform.localPosition.y;
		max = Quaternion.Euler(initLocalRot) * Quaternion.AngleAxis(MaxRockingAngle, Vector3.right);
		min = Quaternion.Euler(initLocalRot) * Quaternion.AngleAxis(0f - MaxRockingAngle, Vector3.right);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.rockingChair = Pool.Get<RockingChair>();
		info.msg.rockingChair.initEuler = initLocalRot;
		info.msg.rockingChair.initY = initLocalY;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.rockingChair != null && base.isServer)
		{
			initLocalRot = info.msg.rockingChair.initEuler;
			((Component)this).transform.localRotation = Quaternion.Euler(initLocalRot);
			initLocalY = info.msg.rockingChair.initY;
			if (initLocalY == 0f)
			{
				initLocalY = ((Component)this).transform.localPosition.y;
			}
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		float timeSinceLastTick = player.timeSinceLastTick;
		Vector2 inputVector = GetInputVector(inputState);
		CalculateVelocity(inputVector);
		bool flag = !Mathf.Approximately(inputVector.y, 0f);
		if (flag)
		{
			timeSinceInput = TimeSince.op_Implicit(0f);
			sineTime = 0f;
		}
		else if (TimeSince.op_Implicit(timeSinceInput) > timeUntilStartSine)
		{
			angle = Mathf.Lerp(0f - MaxRockingAngle, MaxRockingAngle, t);
		}
		sineTime += player.timeSinceLastTick * 180f;
		PreventClipping(flag);
		ApplyVelocity(timeSinceLastTick, flag);
	}

	public override void OnWeaponFired(BaseProjectile weapon)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)weapon == (Object)null))
		{
			if ((Object)(object)weapon.recoil != (Object)null)
			{
				velocity += weapon.recoil.recoilPitchMax * WeaponFireImpact;
			}
			timeSinceInput = TimeSince.op_Implicit(0f);
			sineTime = 0f;
		}
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		base.OnPlayerDismounted(player);
		ResetChair();
	}

	private void PreventClipping(bool hasInput)
	{
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		float num = initLocalY + 0.06f;
		float num2 = Mathx.RemapValClamped(Mathf.Abs(angle), 0f, MaxRockingAngle, 0f, 1f);
		if (num2 > 0.7f)
		{
			((Component)this).transform.localPosition = Mathx.Lerp(new Vector3(((Component)this).transform.localPosition.x, initLocalY, ((Component)this).transform.localPosition.z), new Vector3(((Component)this).transform.localPosition.x, num, ((Component)this).transform.localPosition.z), 1.5f, num2);
		}
		else
		{
			((Component)this).transform.localPosition = Mathx.Lerp(((Component)this).transform.localPosition, new Vector3(((Component)this).transform.localPosition.x, initLocalY, ((Component)this).transform.localPosition.z), 1.5f, Time.deltaTime);
		}
	}

	private void CalculateVelocity(Vector2 currentInput)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		velocity += currentInput.y * Acceleration;
		velocity = Mathf.Clamp(velocity, 0f - MaxRockVelocity, MaxRockVelocity);
		oppositePotentialVelocity = (0f - velocity) * AppliedVelocity;
		int signZero = Mathx.GetSignZero(currentInput.y, true);
		int signZero2 = Mathx.GetSignZero(velocity, true);
		if (ApplyVelocityBetweenSwings && Mathf.Abs(velocity) > 0.3f && Mathx.HasSignFlipped(signZero, signZero2))
		{
			velocity += oppositePotentialVelocity;
		}
	}

	private void ApplyVelocity(float delta, bool hasInput)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		t = Mathf.Sin(sineTime * (MathF.PI / 180f));
		t = Mathx.RemapValClamped(t, -1f, 1f, 0f, 1f);
		t = EaseOutCubicOvershoot(t, 0.2f);
		t = Mathf.Lerp(t, 0.5f, Mathf.Clamp01(TimeSince.op_Implicit(timeSinceInput) / 10f));
		angle += velocity;
		angle = Mathf.Clamp(angle, 0f - MaxRockingAngle, MaxRockingAngle);
		Quaternion val = Quaternion.Euler(initLocalRot) * Quaternion.AngleAxis(angle, Vector3.right);
		Quaternion val2 = Quaternion.Slerp(min, max, t);
		float num = ((!hasInput && TimeSince.op_Implicit(timeSinceInput) > timeUntilStartSine) ? 1 : 0);
		Quaternion val3 = Quaternion.Slerp(val, val2, num);
		((Component)this).transform.localRotation = Quaternion.Slerp(((Component)this).transform.localRotation, val3, delta * 3f);
	}

	private void ResetChair()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.localRotation = Quaternion.Euler(initLocalRot);
		((Component)this).transform.localPosition = new Vector3(((Component)this).transform.localPosition.x, initLocalY, ((Component)this).transform.localPosition.z);
	}

	private Vector2 GetInputVector(InputState inputState)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		bool rightDown = false;
		bool forwardDown = inputState.IsDown(BUTTON.FORWARD);
		bool backDown = inputState.IsDown(BUTTON.BACKWARD);
		return ProcessInputVector(leftDown: false, rightDown, forwardDown, backDown);
	}

	private static Vector2 ProcessInputVector(bool leftDown, bool rightDown, bool forwardDown, bool backDown)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		Vector2 zero = Vector2.zero;
		if (leftDown && rightDown)
		{
			leftDown = (rightDown = false);
		}
		if (forwardDown && backDown)
		{
			forwardDown = (backDown = false);
		}
		if (forwardDown)
		{
			zero.y = 1f;
		}
		else if (backDown)
		{
			zero.y = -1f;
		}
		if (rightDown)
		{
			zero.x = 1f;
		}
		else if (leftDown)
		{
			zero.x = -1f;
		}
		return zero;
	}

	private float EaseOutCubic(float value)
	{
		return 1f - Mathf.Pow(1f - Mathf.Clamp01(value), 3f);
	}

	private float EaseOutCubicOvershoot(float value, float overshoot)
	{
		return 1f - Mathf.Pow(1f - Mathf.Clamp01(value), 3f) * (1f + overshoot * (Mathf.Clamp01(value) - 1f));
	}
}


using UnityEngine;

public class DiveSite : JunkPile
{
	public Transform bobber;

	public override bool DespawnIfAnyLootTaken => false;

	public override float TimeoutPlayerCheckRadius()
	{
		return 80f;
	}
}


using System;
using UnityEngine;

public class DiveSiteBuoy : BaseEntity
{
	public float UpdateCullRange = 128f;

	public Vector3 RotationRate;

	public float InitialSpawnRange = 32f;

	private Action _updateAction;

	private Action updateAction => _updateAction ?? new Action(UpdateMovement);

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (!BaseNetworkable.HasCloseConnections(((Component)this).transform.position, InitialSpawnRange))
		{
			UpdateMovement();
		}
		((FacepunchBehaviour)this).InvokeRandomized((Action)CheckForNearbyPlayers, 0f, 10f, 5f);
	}

	private void CheckForNearbyPlayers()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		bool flag = BaseNetworkable.HasCloseConnections(((Component)this).transform.position, UpdateCullRange);
		if (flag && !((FacepunchBehaviour)this).IsInvoking(updateAction))
		{
			((FacepunchBehaviour)this).InvokeRepeating(updateAction, 0f, 0f);
		}
		else if (!flag && ((FacepunchBehaviour)this).IsInvoking(updateAction))
		{
			((FacepunchBehaviour)this).CancelInvoke(updateAction);
		}
	}

	private void UpdateMovement()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		Quaternion rotation = ((Component)this).transform.rotation;
		position.y = WaterLevel.GetWaterSurface(position, waves: true, volumes: false) + Mathf.Sin(Time.time * 3f) * 0.075f;
		rotation *= Quaternion.Euler(RotationRate * Time.deltaTime);
		((Component)this).transform.SetPositionAndRotation(position, rotation);
	}
}


using UnityEngine;

public class EggAmmoRepresentation : MonoBehaviour, IInventoryChanged, IClientComponent
{
	public GameObject[] eggAmmo;
}


using UnityEngine;

public class EggSwap : MonoBehaviour
{
	public Renderer[] eggRenderers;

	public void Show(int index)
	{
		HideAll();
		eggRenderers[index].enabled = true;
	}

	public void HideAll()
	{
		Renderer[] array = eggRenderers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = false;
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class EggHuntEvent : BaseHuntEvent
{
	public class EggHunter
	{
		public ulong userid;

		public string displayName;

		public int numEggs;
	}

	public float warmupTime = 10f;

	public float warnTime = 20f;

	public float timeAlive;

	public static EggHuntEvent serverEvent = null;

	public static EggHuntEvent clientEvent = null;

	public const int CAST_LAYERS = 10551297;

	[NonSerialized]
	public static float durationSeconds = 180f;

	public Dictionary<ulong, EggHunter> _eggHunters = new Dictionary<ulong, EggHunter>();

	public ItemAmount[] placementAwards;

	private Dictionary<ulong, List<CollectableEasterEgg>> _spawnedEggs = new Dictionary<ulong, List<CollectableEasterEgg>>();

	private readonly int maxEggPerPlayer = 25;

	private int initialSpawnIndex;

	private readonly Stopwatch stopwatch = new Stopwatch();

	private const int maxBatchSize = 1024;

	private const int initialMinEggPerPlayer = 4;

	private const int initialMaxEggPerPlayer = 6;

	private float eggSpawningFrameBudget = 1.5f;

	[ServerVar(Help = "Will spawn eggs for bots, only for debug purposes - don't enable it!")]
	public static bool includeBots = false;

	public static Phrase topBunnyPhrase = new Phrase("egghunt.result.topbunny", "{0} is the top bunny with {1} eggs collected.");

	public static Phrase noPlayersPhrase = new Phrase("egghunt.result.noplayers", "Wow, no one played so no one won.");

	public static Phrase placePhrase = new Phrase("egghunt.result.place", "You placed {0} of {1} with {2} eggs collected.");

	public static Phrase rewardPhrase = new Phrase("egghunt.result.reward", "You received {0}x {1} as an award!.");

	public bool IsEventActive()
	{
		if (timeAlive > warmupTime)
		{
			return timeAlive - warmupTime < durationSeconds;
		}
		return false;
	}

	public void Update()
	{
		timeAlive += Time.deltaTime;
		if (base.isServer && !base.IsDestroyed)
		{
			if (timeAlive - warmupTime > durationSeconds - warnTime)
			{
				SetFlag(Flags.Reserved1, b: true);
			}
			if (timeAlive - warmupTime > durationSeconds && !((FacepunchBehaviour)this).IsInvoking((Action)Cooldown) && Interface.CallHook("OnHuntEventEnd", (object)this) == null)
			{
				SetFlag(Flags.Reserved2, b: true);
				CleanupEggs();
				PrintWinnersAndAward();
				((FacepunchBehaviour)this).Invoke((Action)Cooldown, 10f);
			}
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer)
		{
			serverEvent = null;
		}
		else
		{
			clientEvent = null;
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (Object.op_Implicit((Object)(object)serverEvent) && base.isServer)
		{
			serverEvent.Kill();
			serverEvent = null;
		}
		serverEvent = this;
		SpawnEggs();
		((FacepunchBehaviour)this).Invoke((Action)StartEvent, warmupTime);
	}

	private void StartEvent()
	{
		if (Interface.CallHook("OnHuntEventStart", (object)this) == null)
		{
			int count = BasePlayer.activePlayerList.Count;
			if (includeBots)
			{
				count = GetCombinedPlayerList(wantBots: true).Count;
			}
			if (initialSpawnIndex <= count)
			{
				eggSpawningFrameBudget = float.PositiveInfinity;
			}
			EnableEggs();
		}
	}

	private void EnableEggs()
	{
		foreach (KeyValuePair<ulong, List<CollectableEasterEgg>> spawnedEgg in _spawnedEggs)
		{
			foreach (CollectableEasterEgg item in spawnedEgg.Value)
			{
				((Component)item).gameObject.SetActive(true);
				item.SetFlag(Flags.Disabled, b: false);
			}
		}
	}

	[ContextMenu("SpawnDebug")]
	public void SpawnEggs()
	{
		initialSpawnIndex = 0;
		((MonoBehaviour)this).StartCoroutine(SpawnInitialEggs());
	}

	private IEnumerator SpawnInitialEggs()
	{
		NativeArray<RaycastCommand> raycastCommands = new NativeArray<RaycastCommand>(1024, (Allocator)4, (NativeArrayOptions)1);
		NativeArray<RaycastHit> hits = new NativeArray<RaycastHit>(1024, (Allocator)4, (NativeArrayOptions)1);
		NativeArray<ulong> ownerIDs = new NativeArray<ulong>(1024, (Allocator)4, (NativeArrayOptions)1);
		Queue<(Vector3 position, ulong ownerID)> pendingSpawns = new Queue<(Vector3, ulong)>();
		ListHashSet<BasePlayer> playerList = BasePlayer.activePlayerList;
		if (includeBots)
		{
			playerList = GetCombinedPlayerList(wantBots: true);
		}
		while (initialSpawnIndex != playerList.Count)
		{
			stopwatch.Reset();
			stopwatch.Start();
			int commandIndex = 0;
			for (int i = initialSpawnIndex; i < playerList.Count; i++)
			{
				BasePlayer basePlayer = playerList[i];
				int num = Random.Range(4, 6) + Mathf.RoundToInt(basePlayer.eggVision);
				Vector3 position = ((Component)basePlayer).transform.position;
				for (int j = 0; j < num; j++)
				{
					Vector3 randomSpawnPoint = GetRandomSpawnPoint(position, Vector3.zero, 15f, 25f);
					randomSpawnPoint += Vector3.up * 100f;
					raycastCommands[commandIndex] = new RaycastCommand(randomSpawnPoint, Vector3.down, 105f, 10551297, 1);
					ownerIDs[commandIndex] = basePlayer.userID;
					commandIndex++;
					if (commandIndex >= 1024)
					{
						break;
					}
				}
				initialSpawnIndex++;
				if (commandIndex >= 1024 || stopwatch.Elapsed.TotalMilliseconds >= (double)eggSpawningFrameBudget)
				{
					break;
				}
			}
			if (commandIndex > 0)
			{
				JobHandle handle = RaycastCommand.ScheduleBatch(raycastCommands, hits, 1, default(JobHandle));
				yield return (object)new WaitUntil((Func<bool>)(() => ((JobHandle)(ref handle)).IsCompleted));
				((JobHandle)(ref handle)).Complete();
				for (int k = 0; k < commandIndex; k++)
				{
					RaycastCommand val = raycastCommands[k];
					Vector3 val2 = ((RaycastCommand)(ref val)).from;
					RaycastHit val3 = hits[k];
					if ((Object)(object)((RaycastHit)(ref val3)).collider == (Object)null)
					{
						val2.y = TerrainMeta.HeightMap.GetHeight(val2);
					}
					else
					{
						val3 = hits[k];
						val2 = ((RaycastHit)(ref val3)).point;
					}
					pendingSpawns.Enqueue((val2, ownerIDs[k]));
				}
			}
			yield return CoroutineEx.waitForEndOfFrame;
		}
		while (pendingSpawns.Count > 0)
		{
			stopwatch.Reset();
			stopwatch.Start();
			while (pendingSpawns.Count > 0 && stopwatch.Elapsed.TotalMilliseconds < (double)eggSpawningFrameBudget)
			{
				(Vector3 position, ulong ownerID) tuple = pendingSpawns.Dequeue();
				Vector3 item = tuple.position;
				ulong item2 = tuple.ownerID;
				CollectableEasterEgg collectableEasterEgg = SpawnEggAtPoint(item, active: false);
				collectableEasterEgg.ownerUserID = item2;
				collectableEasterEgg.SetFlag(Flags.Disabled, b: true, recursive: false, networkupdate: false);
				collectableEasterEgg.Spawn();
				TryGetPlayerEggs(item2).Add(collectableEasterEgg);
			}
			yield return CoroutineEx.waitForEndOfFrame;
		}
		raycastCommands.Dispose();
		hits.Dispose();
		ownerIDs.Dispose();
	}

	private CollectableEasterEgg SpawnEggAtPoint(Vector3 pos, bool active)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if ((TerrainMeta.TopologyMap.GetTopology(pos) & 0x14080) != 0)
		{
			float waterLevel = WaterLevel.GetWaterLevel(pos, waves: false);
			if (waterLevel > TerrainMeta.HeightMap.GetHeight(pos) && pos.y < waterLevel)
			{
				pos.y = waterLevel;
			}
		}
		GameManager server = GameManager.server;
		string strPrefab = HuntableResourcePathCached[Random.Range(0, HuntableResourcePathCached.Count)];
		Vector3 pos2 = pos;
		bool startActive = active;
		return server.CreateEntity(strPrefab, pos2, default(Quaternion), startActive) as CollectableEasterEgg;
	}

	private Vector3 GetRandomSpawnPoint(Vector3 pos, Vector3 aimDir, float minDist = 1f, float maxDist = 2f, bool raycast = false)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		aimDir = ((aimDir == Vector3.zero) ? Random.onUnitSphere : AimConeUtil.GetModifiedAimConeDirection(90f, aimDir));
		Vector3 val = pos + Vector3Ex.Direction2D(pos + aimDir * 10f, pos) * Random.Range(minDist, maxDist);
		RaycastHit val2 = default(RaycastHit);
		if (raycast && Physics.Raycast(val + Vector3.up * 100f, Vector3.down, ref val2, 105f, 10551297))
		{
			val.y = ((RaycastHit)(ref val2)).point.y;
		}
		else
		{
			val.y = TerrainMeta.HeightMap.GetHeight(val);
		}
		return val;
	}

	public void OnEggCollected(BasePlayer player, CollectableEasterEgg collectedEgg)
	{
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		IncrementScore(player);
		if (_spawnedEggs.TryGetValue(collectedEgg.ownerUserID, out var value))
		{
			value.Remove(collectedEgg);
		}
		int num = ((!((float)Mathf.RoundToInt(player.eggVision) * 0.5f < 1f)) ? 1 : Random.Range(0, 2));
		int num2 = Random.Range(1 + num, 2 + num);
		List<CollectableEasterEgg> list = TryGetPlayerEggs(player.userID);
		for (int i = 0; i < num2; i++)
		{
			if (list.Count + 1 > maxEggPerPlayer)
			{
				list[0].Kill();
				list.Remove(list[0]);
			}
			Vector3 randomSpawnPoint = GetRandomSpawnPoint(((Component)player).transform.position, player.eyes.BodyForward(), 15f, 25f, raycast: true);
			CollectableEasterEgg collectableEasterEgg = SpawnEggAtPoint(randomSpawnPoint, active: true);
			collectableEasterEgg.ownerUserID = player.userID;
			collectableEasterEgg.Spawn();
			list.Add(collectableEasterEgg);
		}
	}

	private void IncrementScore(BasePlayer player)
	{
		if (!_eggHunters.TryGetValue(player.userID, out var value))
		{
			value = new EggHunter();
			value.displayName = player.displayName;
			value.userid = player.userID;
			_eggHunters.Add(player.userID, value);
		}
		value.numEggs++;
		QueueUpdate();
	}

	private void QueueUpdate()
	{
		if (!((FacepunchBehaviour)this).IsInvoking((Action)DoNetworkUpdate))
		{
			((FacepunchBehaviour)this).Invoke((Action)DoNetworkUpdate, 2f);
		}
	}

	private void DoNetworkUpdate()
	{
		SendNetworkUpdate();
	}

	private List<CollectableEasterEgg> TryGetPlayerEggs(ulong userID)
	{
		if (!_spawnedEggs.TryGetValue(userID, out var value))
		{
			value = new List<CollectableEasterEgg>();
			_spawnedEggs[userID] = value;
		}
		return value;
	}

	protected List<EggHunter> GetTopHunters()
	{
		List<EggHunter> list = Pool.Get<List<EggHunter>>();
		foreach (KeyValuePair<ulong, EggHunter> eggHunter in _eggHunters)
		{
			list.Add(eggHunter.Value);
		}
		list.Sort((EggHunter a, EggHunter b) => b.numEggs.CompareTo(a.numEggs));
		return list;
	}

	protected virtual Phrase GetTopBunnyPhrase()
	{
		return topBunnyPhrase;
	}

	protected virtual Phrase GetNoPlayersPhrase()
	{
		return noPlayersPhrase;
	}

	protected virtual Phrase GetPlacePhrase()
	{
		return placePhrase;
	}

	protected virtual Phrase GetRewardPhrase()
	{
		return rewardPhrase;
	}

	protected void PrintWinnersAndAward()
	{
		List<EggHunter> topHunters = GetTopHunters();
		if (topHunters.Count > 0)
		{
			EggHunter eggHunter = topHunters[0];
			Chat.Broadcast(string.Format(GetTopBunnyPhrase().translated, eggHunter.displayName, eggHunter.numEggs), "", "#eee", 0uL);
			for (int i = 0; i < topHunters.Count; i++)
			{
				EggHunter eggHunter2 = topHunters[i];
				BasePlayer basePlayer = BasePlayer.FindByID(eggHunter2.userid);
				if (Object.op_Implicit((Object)(object)basePlayer))
				{
					string translated = GetPlacePhrase().translated;
					translated = string.Format(translated, i + 1, topHunters.Count, topHunters[i].numEggs);
					basePlayer.ChatMessage(translated);
					ReportEggsCollected(topHunters[i].numEggs);
				}
				else
				{
					Debug.LogWarning((object)("EggHuntEvent PrintWinnersAndAward could not find player with id :" + eggHunter2.userid));
				}
			}
			ReportPlayerParticipated(topHunters.Count);
			for (int j = 0; j < placementAwards.Length && j < topHunters.Count; j++)
			{
				BasePlayer basePlayer2 = BasePlayer.FindByID(topHunters[j].userid);
				if (Object.op_Implicit((Object)(object)basePlayer2))
				{
					basePlayer2.inventory.GiveItem(ItemManager.Create(placementAwards[j].itemDef, (int)placementAwards[j].amount, 0uL), basePlayer2.inventory.containerMain);
					string translated2 = GetRewardPhrase().translated;
					translated2 = string.Format(translated2, (int)placementAwards[j].amount, placementAwards[j].itemDef.displayName.english);
					basePlayer2.ChatMessage(translated2);
				}
			}
		}
		else
		{
			Chat.Broadcast(GetNoPlayersPhrase().translated, "", "#eee", 0uL);
		}
	}

	protected virtual void ReportEggsCollected(int numEggs)
	{
	}

	protected virtual void ReportPlayerParticipated(int topCount)
	{
	}

	private void CleanupEggs()
	{
		foreach (KeyValuePair<ulong, List<CollectableEasterEgg>> spawnedEgg in _spawnedEggs)
		{
			if (spawnedEgg.Value == null)
			{
				continue;
			}
			foreach (CollectableEasterEgg item in spawnedEgg.Value)
			{
				if ((Object)(object)item != (Object)null)
				{
					item.Kill();
				}
			}
		}
	}

	private void Cooldown()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)Cooldown);
		Kill();
	}

	public static ListHashSet<BasePlayer> GetCombinedPlayerList(bool wantBots)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		ListHashSet<BasePlayer> val = new ListHashSet<BasePlayer>(BasePlayer.activePlayerList.Count + (wantBots ? BasePlayer.bots.Count : 0));
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				val.Add(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		if (wantBots)
		{
			enumerator = BasePlayer.bots.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current2 = enumerator.Current;
					val.Add(current2);
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		return val;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.eggHunt = Pool.Get<EggHunt>();
		List<EggHunter> topHunters = GetTopHunters();
		info.msg.eggHunt.hunters = Pool.Get<List<EggHunter>>();
		for (int i = 0; i < Mathf.Min(10, topHunters.Count); i++)
		{
			EggHunter val = Pool.Get<EggHunter>();
			val.displayName = topHunters[i].displayName;
			val.numEggs = topHunters[i].numEggs;
			val.playerID = topHunters[i].userid;
			info.msg.eggHunt.hunters.Add(val);
		}
	}
}


public class EggHunter
{
	public ulong userid;

	public string displayName;

	public int numEggs;
}


using System;
using UnityEngine;

public class AnimationFlagHandler : MonoBehaviour
{
	public Animator animator;

	public bool forceUpdateIfDisabled;

	public void SetBoolTrue(string name)
	{
		animator.SetBool(name, true);
		TryForceAnimation();
	}

	public void SetBoolFalse(string name)
	{
		animator.SetBool(name, false);
		TryForceAnimation();
	}

	private void TryForceAnimation()
	{
		if (forceUpdateIfDisabled && !((Behaviour)animator).isActiveAndEnabled)
		{
			((Behaviour)animator).enabled = true;
			animator.Update(10f);
			((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)DisableAnimator, 2f);
		}
	}

	private void DisableAnimator()
	{
		if (!((Object)(object)animator == (Object)null))
		{
			((Behaviour)animator).enabled = false;
		}
	}
}


using UnityEngine;

public class JiggleBone : BaseMonoBehaviour
{
	public bool debugMode = true;

	private Vector3 targetPos;

	private Vector3 dynamicPos;

	public Vector3 boneAxis = new Vector3(0f, 0f, 1f);

	public float targetDistance = 2f;

	public float bStiffness = 0.1f;

	public float bMass = 0.9f;

	public float bDamping = 0.75f;

	public float bGravity = 0.75f;

	private Vector3 force;

	private Vector3 acc;

	private Vector3 vel;

	public bool SquashAndStretch = true;

	public float sideStretch = 0.15f;

	public float frontStretch = 0.2f;

	public float disableDistance = 20f;

	private void Awake()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position + ((Component)this).transform.TransformDirection(new Vector3(boneAxis.x * targetDistance, boneAxis.y * targetDistance, boneAxis.z * targetDistance));
		dynamicPos = val;
	}

	private void LateUpdate()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_034a: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_035f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_036a: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0375: Unknown result type (might be due to invalid IL or missing references)
		//IL_037a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0385: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_0399: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.rotation = default(Quaternion);
		Vector3 val = ((Component)this).transform.TransformDirection(new Vector3(boneAxis.x * targetDistance, boneAxis.y * targetDistance, boneAxis.z * targetDistance));
		Vector3 val2 = ((Component)this).transform.TransformDirection(new Vector3(0f, 1f, 0f));
		Vector3 val3 = ((Component)this).transform.position + ((Component)this).transform.TransformDirection(new Vector3(boneAxis.x * targetDistance, boneAxis.y * targetDistance, boneAxis.z * targetDistance));
		force.x = (val3.x - dynamicPos.x) * bStiffness;
		acc.x = force.x / bMass;
		vel.x += acc.x * (1f - bDamping);
		force.y = (val3.y - dynamicPos.y) * bStiffness;
		force.y -= bGravity / 10f;
		acc.y = force.y / bMass;
		vel.y += acc.y * (1f - bDamping);
		force.z = (val3.z - dynamicPos.z) * bStiffness;
		acc.z = force.z / bMass;
		vel.z += acc.z * (1f - bDamping);
		dynamicPos += vel + force;
		((Component)this).transform.LookAt(dynamicPos, val2);
		if (SquashAndStretch)
		{
			Vector3 val4 = dynamicPos - val3;
			float magnitude = ((Vector3)(ref val4)).magnitude;
			float num = ((boneAxis.x != 0f) ? (1f + magnitude * frontStretch) : (1f + (0f - magnitude) * sideStretch));
			float num2 = ((boneAxis.y != 0f) ? (1f + magnitude * frontStretch) : (1f + (0f - magnitude) * sideStretch));
			float num3 = ((boneAxis.z != 0f) ? (1f + magnitude * frontStretch) : (1f + (0f - magnitude) * sideStretch));
			((Component)this).transform.localScale = new Vector3(num, num2, num3);
		}
		if (debugMode)
		{
			Debug.DrawRay(((Component)this).transform.position, val, Color.blue);
			Debug.DrawRay(((Component)this).transform.position, val2, Color.green);
			Debug.DrawRay(val3, Vector3.up * 0.2f, Color.yellow);
			Debug.DrawRay(dynamicPos, Vector3.up * 0.2f, Color.red);
		}
	}
}


using UnityEngine;

public class EggUpdater : MonoBehaviour
{
}


public class ItemModCrackOpen : ItemModUnwrap
{
	public static readonly Phrase CrackOpenTitle = new Phrase("crack_open", "Crack Open");

	public static readonly Phrase CrackOpenDesc = new Phrase("crack_open_desc", "Crack open the egg");
}


using UnityEngine;

public class RandomRendererEnable : MonoBehaviour
{
	public Renderer[] randoms;

	public int EnabledIndex { get; private set; }

	public void OnEnable()
	{
		int num2 = (EnabledIndex = Random.Range(0, randoms.Length));
		randoms[num2].enabled = true;
	}
}


using UnityEngine;
using UnityEngine.UI;

public class BunnyEntry : MonoBehaviour
{
	public Text nameText;

	public Text amountText;

	public RawImage starImage;

	public RawImage selfImage;
}


using Rust.UI;
using UnityEngine;

public class EggHuntNote : MonoBehaviour, IClientComponent
{
	public CanvasGroup mainGroup;

	public CanvasGroup timerGroup;

	public RustText timerText;

	public static readonly Phrase startsInPhrase = new Phrase("egghunt.start", "Starts in: {0}");
}


using UnityEngine;
using UnityEngine.UI;

public class TopBunnies : MonoBehaviour
{
	public BunnyEntry[] topBunnyEntries;

	public Text timerText;

	public CanvasGroup group;

	public Color endingColor;
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class GraveyardFence : SimpleBuildingBlock
{
	public BoxCollider[] pillars;

	public override void ServerInit()
	{
		base.ServerInit();
		UpdatePillars();
	}

	public override void DestroyShared()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.DestroyShared();
		List<GraveyardFence> list = Pool.Get<List<GraveyardFence>>();
		Vis.Entities(((Component)this).transform.position, 5f, list, 2097152, (QueryTriggerInteraction)2);
		foreach (GraveyardFence item in list)
		{
			item.UpdatePillars();
		}
		Pool.FreeUnmanaged<GraveyardFence>(ref list);
	}

	public virtual void UpdatePillars()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		BoxCollider[] array = pillars;
		foreach (BoxCollider val in array)
		{
			((Component)val).gameObject.SetActive(true);
			Collider[] array2 = Physics.OverlapBox(((Component)val).transform.TransformPoint(val.center), val.size * 0.5f, ((Component)val).transform.rotation, 2097152);
			foreach (Collider val2 in array2)
			{
				if (((Component)val2).CompareTag("Usable Auxiliary"))
				{
					BaseEntity baseEntity = ((Component)val2).gameObject.ToBaseEntity();
					if (!((Object)(object)baseEntity == (Object)null) && !EqualNetID((BaseNetworkable)baseEntity) && (Object)(object)val2 != (Object)(object)val)
					{
						((Component)val).gameObject.SetActive(false);
					}
				}
			}
		}
	}
}


public class HalloweenEventNote : EggHuntNote
{
}


public class HalloweenHunt : EggHuntEvent
{
	public static Phrase topCreepPhrase = new Phrase("candyhunt.result.topcreeps", "{0} is the top creep with {1} candies collected.");

	public static Phrase placeCreepPhrase = new Phrase("candyhunt.result.place", "You placed {0} of {1} with {2} candies collected.");

	protected override Phrase GetTopBunnyPhrase()
	{
		return topCreepPhrase;
	}

	protected override Phrase GetPlacePhrase()
	{
		return placeCreepPhrase;
	}

	protected override void ReportPlayerParticipated(int topCount)
	{
	}

	protected override void ReportEggsCollected(int numEggs)
	{
	}
}


public class ItemModOpenLootBag : ItemModUnwrap
{
	public static readonly Phrase OpenLootBagTitle = new Phrase("open_lootbag", "Open Bag");

	public static readonly Phrase OpenLootBagDesc = new Phrase("open_lootbag_desc", "");
}


using UnityEngine;

public class SpiderWeb : BaseCombatEntity
{
	public bool Fresh()
	{
		if (!HasFlag(Flags.Reserved1) && !HasFlag(Flags.Reserved2) && !HasFlag(Flags.Reserved3))
		{
			return !HasFlag(Flags.Reserved4);
		}
		return false;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (Fresh())
		{
			int num = Random.Range(0, 4);
			Flags f = Flags.Reserved1;
			switch (num)
			{
			case 0:
				f = Flags.Reserved1;
				break;
			case 1:
				f = Flags.Reserved2;
				break;
			case 2:
				f = Flags.Reserved3;
				break;
			case 3:
				f = Flags.Reserved4;
				break;
			}
			SetFlag(f, b: true);
		}
	}
}


using Facepunch;
using ntw.CurvedTextMeshPro;
using ProtoBuf;
using Rust.UI;
using UnityEngine;

public class SkullTrophy : StorageContainer
{
	public RustText NameText;

	public TextProOnACircle CircleModifier;

	public int AngleModifierMinCharCount = 3;

	public int AngleModifierMaxCharCount = 20;

	public int AngleModifierMinArcAngle = 20;

	public int AngleModifierMaxArcAngle = 45;

	public float SunsetTime = 18f;

	public float SunriseTime = 5f;

	public RendererLOD SkullRenderer;

	public Material[] DaySkull;

	public Material[] NightSkull;

	public Material[] NoSkull;

	public const Flags HasSkull = Flags.Reserved1;

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		SetFlag(Flags.Reserved1, base.inventory.GetSlot(0) != null);
		SendNetworkUpdate();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk)
		{
			if (base.inventory != null && base.inventory.itemList.Count == 1)
			{
				info.msg.skullTrophy = Pool.Get<SkullTrophy>();
				info.msg.skullTrophy.playerName = base.inventory.itemList[0].GetName(false);
				info.msg.skullTrophy.streamerName = base.inventory.itemList[0].GetName(true);
			}
			else if (info.msg.skullTrophy != null)
			{
				info.msg.skullTrophy.playerName = string.Empty;
				info.msg.skullTrophy.streamerName = string.Empty;
			}
		}
	}
}


using UnityEngine;

public class JunkPileBuoyancyPoint : MonoBehaviour
{
}


using UnityEngine;

public class JunkPileWater : JunkPile
{
	public class JunkpileWaterWorkQueue : ObjectWorkQueue<JunkPileWater>
	{
		protected override void RunJob(JunkPileWater entity)
		{
			if (((ObjectWorkQueue<JunkPileWater>)this).ShouldAdd(entity))
			{
				entity.UpdateNearbyPlayers();
			}
		}

		protected override bool ShouldAdd(JunkPileWater entity)
		{
			if (base.ShouldAdd(entity))
			{
				return entity.IsValid();
			}
			return false;
		}
	}

	public Transform[] buoyancyPoints;

	public bool debugDraw;

	public float updateCullRange = 16f;

	public float VehicleCheckRadius = 5f;

	private Quaternion baseRotation = Quaternion.identity;

	private bool first = true;

	private TimeUntil nextPlayerCheck;

	private bool hasPlayersNearby;

	public static JunkpileWaterWorkQueue junkpileWaterWorkQueue = new JunkpileWaterWorkQueue();

	[Help("How many milliseconds to budget for processing junk pile updates per frame")]
	[ServerVar]
	public static float framebudgetms = 0.25f;

	public override void Spawn()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		position.y = WaterLevel.GetWaterSurface(((Component)this).transform.position, waves: false, volumes: false);
		((Component)this).transform.position = position;
		base.Spawn();
		Quaternion rotation = ((Component)this).transform.rotation;
		baseRotation = Quaternion.Euler(0f, ((Quaternion)(ref rotation)).eulerAngles.y, 0f);
		if (Physics.CheckSphere(((Component)this).transform.position, VehicleCheckRadius, 134217728))
		{
			Kill();
		}
	}

	public void FixedUpdate()
	{
		if (!base.isClient)
		{
			UpdateMovement();
		}
	}

	public void UpdateMovement()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		if (TimeUntil.op_Implicit(nextPlayerCheck) <= 0f)
		{
			nextPlayerCheck = TimeUntil.op_Implicit(Random.Range(0.5f, 1f));
			((ObjectWorkQueue<JunkPileWater>)junkpileWaterWorkQueue).Add(this);
		}
		if (isSinking || !hasPlayersNearby)
		{
			return;
		}
		float waterSurface = WaterLevel.GetWaterSurface(((Component)this).transform.position, waves: true, volumes: false);
		((Component)this).transform.position = new Vector3(((Component)this).transform.position.x, waterSurface, ((Component)this).transform.position.z);
		if (buoyancyPoints != null && buoyancyPoints.Length >= 3)
		{
			Vector3 position = ((Component)this).transform.position;
			Vector3 localPosition = buoyancyPoints[0].localPosition;
			Vector3 localPosition2 = buoyancyPoints[1].localPosition;
			Vector3 localPosition3 = buoyancyPoints[2].localPosition;
			Vector3 val = localPosition + position;
			Vector3 val2 = localPosition2 + position;
			Vector3 val3 = localPosition3 + position;
			val.y = WaterLevel.GetWaterSurface(val, waves: true, volumes: false);
			val2.y = WaterLevel.GetWaterSurface(val2, waves: true, volumes: false);
			val3.y = WaterLevel.GetWaterSurface(val3, waves: true, volumes: false);
			Vector3 val4 = default(Vector3);
			((Vector3)(ref val4))..ctor(position.x, val.y - localPosition.y, position.z);
			Vector3 val5 = val2 - val;
			Vector3 val6 = Vector3.Cross(val3 - val, val5);
			Quaternion val7 = Quaternion.LookRotation(new Vector3(val6.x, val6.z, val6.y));
			Vector3 eulerAngles = ((Quaternion)(ref val7)).eulerAngles;
			val7 = Quaternion.Euler(0f - eulerAngles.x, 0f, 0f - eulerAngles.y);
			if (first)
			{
				Quaternion rotation = ((Component)this).transform.rotation;
				baseRotation = Quaternion.Euler(0f, ((Quaternion)(ref rotation)).eulerAngles.y, 0f);
				first = false;
			}
			((Component)this).transform.SetPositionAndRotation(val4, val7 * baseRotation);
		}
	}

	public void UpdateNearbyPlayers()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		hasPlayersNearby = BaseNetworkable.HasCloseConnections(((Component)this).transform.position, updateCullRange);
	}
}


public class JunkpileWaterWorkQueue : ObjectWorkQueue<JunkPileWater>
{
	protected override void RunJob(JunkPileWater entity)
	{
		if (((ObjectWorkQueue<JunkPileWater>)this).ShouldAdd(entity))
		{
			entity.UpdateNearbyPlayers();
		}
	}

	protected override bool ShouldAdd(JunkPileWater entity)
	{
		if (base.ShouldAdd(entity))
		{
			return entity.IsValid();
		}
		return false;
	}
}


using UnityEngine;

public class JunkPileWaterSpawner : SpawnGroup
{
	public BaseEntity attachToParent;

	protected override void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
	{
		base.PostSpawnProcess(entity, spawnPoint);
		if ((Object)(object)attachToParent != (Object)null)
		{
			entity.SetParent(attachToParent, worldPositionStays: true);
		}
	}
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class DeliveryDrone : Drone
{
	private enum State
	{
		Invalid,
		Takeoff,
		FlyToVendingMachine,
		DescendToVendingMachine,
		PickUpItems,
		AscendBeforeReturn,
		ReturnToTerminal,
		Landing
	}

	[Header("Delivery Drone")]
	public float stateTimeout = 300f;

	public float targetPositionTolerance = 1f;

	public float preferredCruiseHeight = 20f;

	public float preferredHeightAboveObstacle = 5f;

	public float marginAbovePreferredHeight = 3f;

	public float obstacleHeightLockDuration = 3f;

	public int pickUpDelayInTicks = 3;

	public DeliveryDroneConfig config;

	public GameObjectRef mapMarkerPrefab;

	public EntityRef<Marketplace> sourceMarketplace;

	public EntityRef<MarketTerminal> sourceTerminal;

	public EntityRef<VendingMachine> targetVendingMachine;

	public State _state;

	public RealTimeSince _sinceLastStateChange;

	public Vector3? _stateGoalPosition;

	public float? _goToY;

	public TimeSince _sinceLastObstacleBlock;

	public float? _minimumYLock;

	public int _pickUpTicks;

	public BaseEntity _mapMarkerInstance;

	public void Setup(Marketplace marketplace, MarketTerminal terminal, VendingMachine vendingMachine)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		sourceMarketplace.Set(marketplace);
		sourceTerminal.Set(terminal);
		targetVendingMachine.Set(vendingMachine);
		_state = State.Takeoff;
		_sinceLastStateChange = RealTimeSince.op_Implicit(0f);
		_pickUpTicks = 0;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)Think, 0f, 0.5f, 0.25f);
		CreateMapMarker();
	}

	public void CreateMapMarker()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)_mapMarkerInstance != (Object)null)
		{
			_mapMarkerInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(mapMarkerPrefab?.resourcePath, Vector3.zero, Quaternion.identity);
		baseEntity.OwnerID = base.OwnerID;
		baseEntity.Spawn();
		baseEntity.SetParent(this);
		_mapMarkerInstance = baseEntity;
	}

	public void Think()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0345: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02de: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0323: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e6: Unknown result type (might be due to invalid IL or missing references)
		if (RealTimeSince.op_Implicit(_sinceLastStateChange) > stateTimeout)
		{
			Debug.LogError((object)"Delivery drone hasn't change state in too long, killing", (Object)(object)this);
			ForceRemove();
			return;
		}
		if (!sourceMarketplace.TryGet(serverside: true, out var marketplace) || !sourceTerminal.TryGet(serverside: true, out var _))
		{
			Debug.LogError((object)"Delivery drone's marketplace or terminal was destroyed, killing", (Object)(object)this);
			ForceRemove();
			return;
		}
		if (!targetVendingMachine.TryGet(serverside: true, out var entity2) && _state <= State.AscendBeforeReturn)
		{
			SetState(State.ReturnToTerminal);
		}
		Vector3 currentPosition = ((Component)this).transform.position;
		float num = GetMinimumHeight(Vector3.zero);
		if (_goToY.HasValue)
		{
			if (!IsAtGoToY())
			{
				targetPosition = Vector3Ex.WithY(currentPosition, _goToY.Value);
				return;
			}
			_goToY = null;
			_sinceLastObstacleBlock = TimeSince.op_Implicit(0f);
			_minimumYLock = currentPosition.y;
		}
		Vector3 waitPosition;
		switch (_state)
		{
		case State.Takeoff:
			SetGoalPosition(marketplace.droneLaunchPoint.position + Vector3.up * 15f);
			if (IsAtGoalPosition())
			{
				SetState(State.FlyToVendingMachine);
			}
			break;
		case State.FlyToVendingMachine:
		{
			bool isBlocked2;
			float num2 = CalculatePreferredY(out isBlocked2);
			if (isBlocked2 && currentPosition.y < num2)
			{
				SetGoToY(num2 + marginAbovePreferredHeight);
				return;
			}
			config.FindDescentPoints(entity2, num2 + marginAbovePreferredHeight, out waitPosition, out var descendPosition);
			SetGoalPosition(descendPosition);
			if (IsAtGoalPosition())
			{
				SetState(State.DescendToVendingMachine);
			}
			break;
		}
		case State.DescendToVendingMachine:
		{
			config.FindDescentPoints(entity2, currentPosition.y, out var waitPosition2, out waitPosition);
			SetGoalPosition(waitPosition2);
			if (IsAtGoalPosition())
			{
				SetState(State.PickUpItems);
			}
			break;
		}
		case State.PickUpItems:
			_pickUpTicks++;
			if (_pickUpTicks >= pickUpDelayInTicks)
			{
				SetState(State.AscendBeforeReturn);
			}
			break;
		case State.AscendBeforeReturn:
		{
			config.FindDescentPoints(entity2, num + preferredCruiseHeight, out waitPosition, out var descendPosition2);
			SetGoalPosition(descendPosition2);
			if (IsAtGoalPosition())
			{
				SetState(State.ReturnToTerminal);
			}
			break;
		}
		case State.ReturnToTerminal:
		{
			bool isBlocked3;
			float num3 = CalculatePreferredY(out isBlocked3);
			if (isBlocked3 && currentPosition.y < num3)
			{
				SetGoToY(num3 + marginAbovePreferredHeight);
				return;
			}
			Vector3 val = LandingPosition();
			if (Vector3Ex.Distance2D(currentPosition, val) < 30f)
			{
				val.y = Mathf.Max(val.y, num3 + marginAbovePreferredHeight);
			}
			else
			{
				val.y = num3 + marginAbovePreferredHeight;
			}
			SetGoalPosition(val);
			if (IsAtGoalPosition())
			{
				SetState(State.Landing);
			}
			break;
		}
		case State.Landing:
			SetGoalPosition(LandingPosition());
			if (IsAtGoalPosition())
			{
				marketplace.ReturnDrone(this);
				SetState(State.Invalid);
			}
			break;
		default:
			ForceRemove();
			break;
		}
		if (_minimumYLock.HasValue)
		{
			if (TimeSince.op_Implicit(_sinceLastObstacleBlock) > obstacleHeightLockDuration)
			{
				_minimumYLock = null;
			}
			else if (targetPosition.HasValue && targetPosition.Value.y < _minimumYLock.Value)
			{
				targetPosition = Vector3Ex.WithY(targetPosition.Value, _minimumYLock.Value);
			}
		}
		float CalculatePreferredY(out bool isBlocked)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0101: Unknown result type (might be due to invalid IL or missing references)
			//IL_0106: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0114: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			//IL_0126: Unknown result type (might be due to invalid IL or missing references)
			//IL_0129: Unknown result type (might be due to invalid IL or missing references)
			//IL_0130: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_0141: Unknown result type (might be due to invalid IL or missing references)
			//IL_014e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0153: Unknown result type (might be due to invalid IL or missing references)
			//IL_0158: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_016a: Unknown result type (might be due to invalid IL or missing references)
			//IL_016d: Unknown result type (might be due to invalid IL or missing references)
			//IL_016f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0171: Unknown result type (might be due to invalid IL or missing references)
			//IL_0178: Unknown result type (might be due to invalid IL or missing references)
			//IL_0185: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_019b: Unknown result type (might be due to invalid IL or missing references)
			//IL_019d: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01be: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val2 = default(Vector3);
			float num4 = default(float);
			Vector3Ex.ToDirectionAndMagnitude(Vector3Ex.WithY(body.velocity, 0f), ref val2, ref num4);
			if (num4 < 0.5f)
			{
				float num5 = GetMinimumHeight(Vector3.zero) + preferredCruiseHeight;
				Vector3 val3 = Vector3Ex.WithY(currentPosition, num5 + 1000f);
				Vector3Ex.WithY(currentPosition, num5);
				RaycastHit val4 = default(RaycastHit);
				isBlocked = Physics.Raycast(val3, Vector3.down, ref val4, 1000f, LayerMask.op_Implicit(config.layerMask));
				if (!isBlocked)
				{
					return num5;
				}
				return num5 + (1000f - ((RaycastHit)(ref val4)).distance) + preferredHeightAboveObstacle;
			}
			float num6 = num4 * 2f;
			float num7 = GetMinimumHeight(Vector3.zero);
			float num8 = GetMinimumHeight(new Vector3(0f, 0f, num6 / 2f));
			float num9 = GetMinimumHeight(new Vector3(0f, 0f, num6));
			float num10 = Mathf.Max(Mathf.Max(num7, num8), num9) + preferredCruiseHeight;
			Quaternion val5 = Quaternion.FromToRotation(Vector3.forward, val2);
			Vector3 val6 = Vector3Ex.WithZ(config.halfExtents, num6 / 2f);
			Vector3 val7 = Vector3Ex.WithY(Vector3Ex.WithY(currentPosition, num10) + val5 * new Vector3(0f, 0f, val6.z / 2f), num10 + 1000f);
			RaycastHit val8 = default(RaycastHit);
			isBlocked = Physics.BoxCast(val7, val6, Vector3.down, ref val8, val5, 1000f, LayerMask.op_Implicit(config.layerMask));
			if (isBlocked)
			{
				Ray ray = default(Ray);
				((Ray)(ref ray))..ctor(val7, Vector3.down);
				Vector3 val9 = ray.ClosestPoint(((RaycastHit)(ref val8)).point);
				float num11 = Vector3.Distance(((Ray)(ref ray)).origin, val9);
				return num10 + (1000f - num11) + preferredHeightAboveObstacle;
			}
			return num10;
		}
		float GetMinimumHeight(Vector3 offset)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return WaterLevel.GetWaterOrTerrainSurface(((Component)this).transform.TransformPoint(offset), waves: true, volumes: true);
		}
		bool IsAtGoalPosition()
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			if (_stateGoalPosition.HasValue)
			{
				return Vector3.Distance(_stateGoalPosition.Value, currentPosition) < targetPositionTolerance;
			}
			return false;
		}
		bool IsAtGoToY()
		{
			if (_goToY.HasValue)
			{
				return Mathf.Abs(_goToY.Value - currentPosition.y) < targetPositionTolerance;
			}
			return false;
		}
		Vector3 LandingPosition()
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			return marketplace.droneLaunchPoint.position;
		}
		void SetGoalPosition(Vector3 position)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			_goToY = null;
			_stateGoalPosition = position;
			targetPosition = position;
		}
		void SetGoToY(float y)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			_goToY = y;
			targetPosition = Vector3Ex.WithY(currentPosition, y);
		}
		void SetState(State newState)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			_state = newState;
			_sinceLastStateChange = RealTimeSince.op_Implicit(0f);
			_pickUpTicks = 0;
			_stateGoalPosition = null;
			_goToY = null;
			SetFlag(Flags.Reserved1, _state >= State.AscendBeforeReturn);
		}
	}

	public void ForceRemove()
	{
		if (sourceMarketplace.TryGet(serverside: true, out var entity))
		{
			entity.ReturnDrone(this);
		}
		else
		{
			Kill();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.deliveryDrone = Pool.Get<DeliveryDrone>();
			info.msg.deliveryDrone.marketplaceId = sourceMarketplace.uid;
			info.msg.deliveryDrone.terminalId = sourceTerminal.uid;
			info.msg.deliveryDrone.vendingMachineId = targetVendingMachine.uid;
			info.msg.deliveryDrone.state = (int)_state;
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.deliveryDrone != null)
		{
			sourceMarketplace = new EntityRef<Marketplace>(info.msg.deliveryDrone.marketplaceId);
			sourceTerminal = new EntityRef<MarketTerminal>(info.msg.deliveryDrone.terminalId);
			targetVendingMachine = new EntityRef<VendingMachine>(info.msg.deliveryDrone.vendingMachineId);
			_state = (State)info.msg.deliveryDrone.state;
		}
	}

	public override bool CanControl(ulong playerID)
	{
		return false;
	}
}


private enum State
{
	Invalid,
	Takeoff,
	FlyToVendingMachine,
	DescendToVendingMachine,
	PickUpItems,
	AscendBeforeReturn,
	ReturnToTerminal,
	Landing
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Delivery Drone Config")]
public class DeliveryDroneConfig : BaseScriptableObject
{
	public Vector3 vendingMachineOffset = new Vector3(0f, 1f, 1f);

	public float maxDistanceFromVendingMachine = 1f;

	public Vector3 halfExtents = new Vector3(0.5f, 0.5f, 0.5f);

	public float testHeight = 200f;

	public LayerMask layerMask = LayerMask.op_Implicit(161546496);

	public void FindDescentPoints(VendingMachine vendingMachine, float currentY, out Vector3 waitPosition, out Vector3 descendPosition)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		float num = maxDistanceFromVendingMachine / 4f;
		RaycastHit val4 = default(RaycastHit);
		for (int i = 0; i <= 4; i++)
		{
			Vector3 val = Vector3.forward * (num * (float)i);
			Vector3 val2 = ((Component)vendingMachine).transform.TransformPoint(vendingMachineOffset + val);
			Vector3 val3 = val2 + Vector3.up * testHeight;
			if (!Physics.BoxCast(val3, halfExtents, Vector3.down, ref val4, ((Component)vendingMachine).transform.rotation, testHeight, LayerMask.op_Implicit(layerMask)))
			{
				waitPosition = val2;
				descendPosition = Vector3Ex.WithY(val3, currentY);
				return;
			}
			if (i == 4)
			{
				waitPosition = val3 + Vector3.down * (((RaycastHit)(ref val4)).distance - halfExtents.y * 2f);
				descendPosition = Vector3Ex.WithY(val3, currentY);
				return;
			}
		}
		throw new Exception("Bug: FindDescentPoint didn't return a fallback value");
	}

	public bool IsVendingMachineAccessible(VendingMachine vendingMachine, Vector3 offset, out RaycastHit hitInfo)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)vendingMachine).transform.TransformPoint(offset);
		if (Physics.BoxCast(val + Vector3.up * testHeight, halfExtents, Vector3.down, ref hitInfo, ((Component)vendingMachine).transform.rotation, testHeight, LayerMask.op_Implicit(layerMask)))
		{
			return false;
		}
		return vendingMachine.IsVisible(val, 2f);
	}
}


public class MapMarkerDeliveryDrone : MapMarker
{
	public override void ServerInit()
	{
		base.ServerInit();
		base.limitNetworking = true;
	}

	public override bool ShouldNetworkTo(BasePlayer player)
	{
		return (ulong)player.userID == base.OwnerID;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class Marketplace : BaseEntity
{
	[Header("Marketplace")]
	public GameObjectRef terminalPrefab;

	public Transform[] terminalPoints;

	public Transform droneLaunchPoint;

	public GameObjectRef deliveryDronePrefab;

	[NonSerialized]
	public EntityRef<MarketTerminal>[] terminalEntities;

	public NetworkableId SendDrone(BasePlayer player, MarketTerminal sourceTerminal, VendingMachine vendingMachine)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)sourceTerminal == (Object)null || (Object)(object)vendingMachine == (Object)null)
		{
			return default(NetworkableId);
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(deliveryDronePrefab?.resourcePath, droneLaunchPoint.position, droneLaunchPoint.rotation);
		if (!(baseEntity is DeliveryDrone deliveryDrone))
		{
			baseEntity.Kill();
			return default(NetworkableId);
		}
		deliveryDrone.OwnerID = player.userID;
		deliveryDrone.Spawn();
		deliveryDrone.Setup(this, sourceTerminal, vendingMachine);
		return deliveryDrone.net.ID;
	}

	public void ReturnDrone(DeliveryDrone deliveryDrone)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		if (deliveryDrone.sourceTerminal.TryGet(serverside: true, out var entity))
		{
			entity.CompleteOrder(deliveryDrone.targetVendingMachine.uid);
		}
		deliveryDrone.Kill();
	}

	public override void Spawn()
	{
		base.Spawn();
		if (!Application.isLoadingSave)
		{
			SpawnSubEntities();
		}
	}

	private void SpawnSubEntities()
	{
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isServer)
		{
			return;
		}
		if (terminalEntities != null && terminalEntities.Length > terminalPoints.Length)
		{
			for (int i = terminalPoints.Length; i < terminalEntities.Length; i++)
			{
				if (terminalEntities[i].TryGet(serverside: true, out var entity))
				{
					entity.Kill();
				}
			}
		}
		Array.Resize(ref terminalEntities, terminalPoints.Length);
		for (int j = 0; j < terminalPoints.Length; j++)
		{
			Transform val = terminalPoints[j];
			if (!terminalEntities[j].TryGet(serverside: true, out var _))
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(terminalPrefab?.resourcePath, val.position, val.rotation);
				baseEntity.SetParent(this, worldPositionStays: true);
				baseEntity.Spawn();
				if (!(baseEntity is MarketTerminal marketTerminal))
				{
					Debug.LogError((object)("Marketplace.terminalPrefab did not spawn a MarketTerminal (it spawned " + ((object)baseEntity).GetType().FullName + ")"));
					baseEntity.Kill();
				}
				else
				{
					marketTerminal.Setup(this);
					terminalEntities[j].Set(marketTerminal);
				}
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.subEntityList != null)
		{
			List<NetworkableId> subEntityIds = info.msg.subEntityList.subEntityIds;
			Array.Resize(ref terminalEntities, subEntityIds.Count);
			for (int i = 0; i < subEntityIds.Count; i++)
			{
				terminalEntities[i] = new EntityRef<MarketTerminal>(subEntityIds[i]);
			}
		}
		SpawnSubEntities();
	}

	public override void Save(SaveInfo info)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.subEntityList = Pool.Get<SubEntityList>();
		info.msg.subEntityList.subEntityIds = Pool.Get<List<NetworkableId>>();
		if (terminalEntities != null)
		{
			for (int i = 0; i < terminalEntities.Length; i++)
			{
				info.msg.subEntityList.subEntityIds.Add(terminalEntities[i].uid);
			}
		}
	}
}


using UnityEngine;

public class UIMarketSearch : MonoBehaviour
{
	public GameObjectRef StoreEntryRef;

	public RectTransform StoreRoot;

	public UIMarketTerminal Terminal;
}


using Rust.UI;
using UnityEngine;

public class UIMarketSearchOrderEntry : MonoBehaviour
{
	public RustText ItemName;

	public GameObject OutOfStockRoot;

	public GameObject BpRoot;
}


using System.Collections.Generic;
using Rust.UI;
using UnityEngine;

public class UIMarketSearchStore : MonoBehaviour
{
	public RustText StoreName;

	public List<UIMarketSearchOrderEntry> Entries;
}


using Rust.UI;
using UnityEngine;

public class UIMarketTerminal : UIDialog, IVendingMachineInterface
{
	public static readonly Phrase PendingDeliveryPluralPhrase = new Phrase("market.pending_delivery.plural", "Waiting for {n} deliveries...");

	public static readonly Phrase PendingDeliverySingularPhrase = new Phrase("market.pending_delivery.singular", "Waiting for delivery...");

	public Canvas canvas;

	public MapView mapView;

	public RectTransform shopDetailsPanel;

	public float shopDetailsMargin = 16f;

	public float easeDuration = 0.2f;

	public LeanTweenType easeType = (LeanTweenType)1;

	public TmProEmojiRedirector shopName;

	public GameObject shopOrderingPanel;

	public RectTransform sellOrderContainer;

	public GameObjectRef sellOrderPrefab;

	public VirtualItemIcon deliveryFeeIcon;

	public GameObject deliveryFeeCantAffordIndicator;

	public GameObject inventoryFullIndicator;

	public GameObject notEligiblePanel;

	public GameObject pendingDeliveryPanel;

	public RustText pendingDeliveryLabel;

	public RectTransform itemNoticesContainer;

	public GameObjectRef itemRemovedPrefab;

	public GameObjectRef itemPendingPrefab;

	public GameObjectRef itemAddedPrefab;

	public CanvasGroup gettingStartedTip;

	public SoundDefinition buyItemSoundDef;

	public SoundDefinition buttonPressSoundDef;
}


using System;
using System.Collections.Generic;
using ConVar;
using UnityEngine;

public class RadiationSphere : BaseEntity
{
	private struct RadiationLight
	{
		public IOEntity Light;

		public Color OriginalColor;
	}

	public AnimationCurve RadiationCurve;

	public float InvokeDelay = 5f;

	public List<IOEntity> RadiationLights = new List<IOEntity>();

	private float timeStarted;

	private TriggerRadiation[] radiationTriggers;

	public static List<RadiationSphere> All { get; private set; } = new List<RadiationSphere>();

	public override void ServerInit()
	{
		base.ServerInit();
		radiationTriggers = ((Component)this).GetComponentsInChildren<TriggerRadiation>();
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateRadiation, InvokeDelay, InvokeDelay, InvokeDelay / 10f);
		All.Add(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		All.Remove(this);
	}

	public void RestartRadiation()
	{
		timeStarted = Time.time;
	}

	public void StopRadation()
	{
		timeStarted = 0f;
	}

	public void UpdateRadiation()
	{
		float num = RadiationCurve.Evaluate((Time.time - timeStarted) / 60f * Server.oilrig_radiation_time_scale) * Server.oilrig_radiation_amount_scale;
		if (timeStarted == 0f)
		{
			num = 0f;
		}
		TriggerRadiation[] array = radiationTriggers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].RadiationAmountOverride = num;
		}
		SetLights(num > Server.oilrig_radiation_alarm_threshold);
	}

	private void SetLights(bool state)
	{
		foreach (IOEntity radiationLight in RadiationLights)
		{
			if (!((Object)(object)radiationLight == (Object)null))
			{
				radiationLight.SetFlag(Flags.Reserved8, state);
			}
		}
	}

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		if (msg == "HackingStarted")
		{
			RestartRadiation();
		}
	}

	public void OnPuzzleReset()
	{
		StopRadation();
	}
}


using UnityEngine;

private struct RadiationLight
{
	public IOEntity Light;

	public Color OriginalColor;
}


using Rust.UI;
using UnityEngine;

public class MonumentSign : LODComponent
{
	public float viewDistance = 30f;

	public GameObject uiRoot;

	public RustText signText;
}


using UnityEngine;
using UnityEngine.UI;

public class NotePanel : MonoBehaviour, IItemPanel
{
	public InputField input;

	private Item item;
}


using Facepunch.Extend;
using UnityEngine;

[Factory("note")]
public class note : ConsoleSystem
{
	[ServerUserVar]
	public static void update(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		ItemId itemID = arg.GetItemID(0);
		string @string = arg.GetString(1, "");
		Item item = arg.Player().inventory.FindItemByUID(itemID);
		if (item != null)
		{
			item.text = StringExtensions.Truncate(@string, 1024, (string)null);
			item.MarkDirty();
		}
	}
}


public class CoverageQueryFlare : BaseMonoBehaviour, IClientComponent
{
	public bool isDynamic;

	public bool timeShimmer;

	public bool positionalShimmer;

	public bool rotate;

	public float maxVisibleDistance = 30f;

	public bool lightScaled;

	public float dotMin = -1f;

	public float dotMax = -1f;

	public CoverageQueries.RadiusSpace coverageRadiusSpace;

	public float coverageRadius = 0.01f;

	public LODDistanceMode DistanceMode;
}


using UnityEngine;

public class OreHotSpot : BaseCombatEntity, ILOD
{
	public float visualDistance = 20f;

	public GameObjectRef visualEffect;

	public GameObjectRef finishEffect;

	public GameObjectRef damageEffect;

	public OreResourceEntity owner;

	public void OreOwner(OreResourceEntity newOwner)
	{
		owner = newOwner;
	}

	public override void ServerInit()
	{
		base.ServerInit();
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (!base.isClient && Object.op_Implicit((Object)(object)owner))
		{
			owner.OnAttacked(info);
		}
	}

	public override void OnDied(HitInfo info)
	{
		FireFinishEffect();
		base.OnDied(info);
	}

	public void FireFinishEffect()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (finishEffect.isValid)
		{
			Effect.server.Run(finishEffect.resourcePath, ((Component)this).transform.position, ((Component)this).transform.forward);
		}
	}
}


using UnityEngine;

public class PlacementTest : MonoBehaviour
{
	public MeshCollider myMeshCollider;

	public Transform testTransform;

	public Transform visualTest;

	public float hemisphere = 45f;

	public float clampTest = 45f;

	public float testDist = 2f;

	private float nextTest;

	public Vector3 RandomHemisphereDirection(Vector3 input, float degreesOffset)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		degreesOffset = Mathf.Clamp(degreesOffset / 180f, -180f, 180f);
		Vector2 insideUnitCircle = Random.insideUnitCircle;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(insideUnitCircle.x * degreesOffset, Random.Range(-1f, 1f) * degreesOffset, insideUnitCircle.y * degreesOffset);
		Vector3 val2 = input + val;
		return ((Vector3)(ref val2)).normalized;
	}

	public Vector3 RandomCylinderPointAroundVector(Vector3 input, float distance, float minHeight = 0f, float maxHeight = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Vector2 insideUnitCircle = Random.insideUnitCircle;
		Vector3 val = new Vector3(insideUnitCircle.x, 0f, insideUnitCircle.y);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		return new Vector3(normalized.x * distance, Random.Range(minHeight, maxHeight), normalized.z * distance);
	}

	public Vector3 ClampToHemisphere(Vector3 hemiInput, float degreesOffset, Vector3 inputVec)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		degreesOffset = Mathf.Clamp(degreesOffset / 180f, -180f, 180f);
		Vector3 val = hemiInput + Vector3.one * degreesOffset;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		val = hemiInput + Vector3.one * (0f - degreesOffset);
		Vector3 normalized2 = ((Vector3)(ref val)).normalized;
		for (int i = 0; i < 3; i++)
		{
			((Vector3)(ref inputVec))[i] = Mathf.Clamp(((Vector3)(ref inputVec))[i], ((Vector3)(ref normalized2))[i], ((Vector3)(ref normalized))[i]);
		}
		return ((Vector3)(ref inputVec)).normalized;
	}

	private void Update()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		if (Time.realtimeSinceStartup < nextTest)
		{
			return;
		}
		nextTest = Time.realtimeSinceStartup + 0f;
		Vector3 val = RandomCylinderPointAroundVector(Vector3.up, 0.5f, 0.25f, 0.5f);
		val = ((Component)this).transform.TransformPoint(val);
		((Component)testTransform).transform.position = val;
		if ((Object)(object)testTransform != (Object)null && (Object)(object)visualTest != (Object)null)
		{
			Vector3 position = ((Component)this).transform.position;
			MeshCollider obj = myMeshCollider;
			Vector3 position2 = testTransform.position;
			Vector3 val2 = ((Component)this).transform.position - testTransform.position;
			RaycastHit val3 = default(RaycastHit);
			if (((Collider)obj).Raycast(new Ray(position2, ((Vector3)(ref val2)).normalized), ref val3, 5f))
			{
				position = ((RaycastHit)(ref val3)).point;
			}
			else
			{
				Debug.LogError((object)"Missed");
			}
			((Component)visualTest).transform.position = position;
		}
	}

	public void OnDrawGizmos()
	{
	}
}


public class ItemModParachute : ItemModBackpack
{
	public GameObjectRef ParachuteVehiclePrefab;
}


using System;
using Facepunch.Rust;
using Rust;
using UnityEngine;

public class Parachute : BaseVehicle, SamSite.ISamSiteTarget
{
	public Collider ParachuteCollider;

	public ItemDefinition PackedParachute;

	public GameObjectRef DetachedParachute;

	public Transform DetachedSpawnPoint;

	public float ConditionLossPerUse = 0.2f;

	public float HurtDeployTime = 1f;

	public float HurtAmount = 80f;

	public Animator ColliderAnimator;

	public Animator ColliderWorldAnimator;

	public float UprightLerpForce = 5f;

	public float ConstantForwardForce = 2f;

	public ForceMode ForwardForceMode = (ForceMode)5;

	public float TurnForce = 2f;

	public ForceMode TurnForceMode = (ForceMode)5;

	public float ForwardTiltAcceleration = 2f;

	public float BackInputForceMultiplier = 0.2f;

	public float DeployAnimationLength = 3f;

	public float TargetDrag = 1f;

	public float TargetAngularDrag = 1f;

	public AnimationCurve DragCurve = new AnimationCurve();

	public AnimationCurve DragDamageCurve = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	public AnimationCurve MassDamageCurve = AnimationCurve.Linear(0f, 30f, 1f, 1f);

	public AnimationCurve DamageHorizontalVelocityCurve = AnimationCurve.Linear(0f, 5f, 1f, 20f);

	[Range(0f, 1f)]
	public float DamageTester = 1f;

	public float AnimationInputSmoothness = 1f;

	public Vector2 AnimationInputScale = new Vector2(0.5f, 0.5f);

	public ParachuteWearable FirstPersonCanopy;

	public GameObjectRef ParachuteLandScreenBounce;

	private static readonly int AnimatorInputXParameter = Animator.StringToHash("InputX");

	private static readonly int AnimatorInputYParameter = Animator.StringToHash("InputY");

	private TimeSince mountTime;

	public const Flags Flag_InputForward = Flags.Reserved1;

	public const Flags Flag_InputBack = Flags.Reserved2;

	public const Flags Flag_InputLeft = Flags.Reserved3;

	public const Flags Flag_InputRight = Flags.Reserved4;

	public SoundDefinition deploySoundDef;

	public SoundDefinition releaseSoundDef;

	public SoundDefinition flightLoopSoundDef;

	public SoundDefinition steerSoundDef;

	public AnimationCurve flightLoopPitchCurve;

	public AnimationCurve flightLoopGainCurve;

	[ServerVar(Saved = true)]
	public static bool BypassRepack = false;

	[ServerVar(Saved = true)]
	public static bool LandingAnimations = false;

	public bool collisionDeath;

	public Vector3 collisionImpulse = Vector3.zero;

	private float startHeight;

	private float distanceTravelled;

	private Vector3 lastPosition = Vector3.zero;

	private Vector2 lerpedInput = Vector2.zero;

	public Vector3 collisionLocalPos;

	public Vector3 collisionWorldNormal;

	protected override bool BypassClothingMountBlocks => true;

	public SamSite.SamTargetType SAMTargetType => SamSite.targetTypeVehicle;

	public override void PlayerMounted(BasePlayer player, BaseMountable seat)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		base.PlayerMounted(player, seat);
		rigidBody.velocity = player.estimatedVelocity;
		mountTime = TimeSince.op_Implicit(0f);
		startHeight = ((Component)this).transform.position.y;
		distanceTravelled = 0f;
		canTriggerParent = false;
	}

	public override bool GetDismountPosition(BasePlayer player, out Vector3 res, bool silent = false)
	{
		ParachuteCollider.enabled = false;
		bool dismountPosition = base.GetDismountPosition(player, out res, silent);
		ParachuteCollider.enabled = true;
		return dismountPosition;
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		base.PlayerServerInput(inputState, player);
		player.PlayHeavyLandingAnimation = true;
		Vector3 position = ((Component)this).transform.position;
		float num = Vector3.Distance(lastPosition, position);
		distanceTravelled += num;
		lastPosition = position;
		if (WaterLevel.Test(((Component)this).transform.position, waves: true, volumes: true, this))
		{
			DismountAllPlayers();
		}
		else if (!(TimeSince.op_Implicit(mountTime) < DeployAnimationLength))
		{
			Vector2 val = ProcessInputVector(inputState, player);
			lerpedInput = Vector2.Lerp(lerpedInput, val, Time.deltaTime * 5f);
			ColliderAnimator.SetFloat(AnimatorInputXParameter, lerpedInput.x);
			ColliderAnimator.SetFloat(AnimatorInputYParameter, lerpedInput.y);
			SetFlag(Flags.Reserved1, inputState.IsDown(BUTTON.FORWARD), recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved2, inputState.IsDown(BUTTON.BACKWARD), recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved3, inputState.IsDown(BUTTON.LEFT), recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved4, inputState.IsDown(BUTTON.RIGHT));
		}
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_030d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0312: Unknown result type (might be due to invalid IL or missing references)
		//IL_0316: Unknown result type (might be due to invalid IL or missing references)
		//IL_032e: Unknown result type (might be due to invalid IL or missing references)
		//IL_034a: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Parachute.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			float num = base.healthFraction * DamageTester;
			float num2 = DragCurve.Evaluate(TimeSince.op_Implicit(mountTime));
			float num3 = DragDamageCurve.Evaluate(num);
			float mass = MassDamageCurve.Evaluate(num);
			rigidBody.mass = mass;
			rigidBody.drag = Mathf.Lerp(0f, TargetDrag * num3, num2);
			rigidBody.angularDrag = Mathf.Lerp(0f, TargetAngularDrag * num3, num2);
			float num4 = Mathf.Clamp01(TimeSince.op_Implicit(mountTime) / 1f);
			Vector3 forward = ((Component)this).transform.forward;
			Vector3 val2 = (forward * ConstantForwardForce + forward * (ForwardTiltAcceleration * Mathf.Clamp(lerpedInput.y, 0f, 1f))) * Time.fixedDeltaTime * num4;
			if (lerpedInput.y < -0.1f)
			{
				val2 *= 1f - BackInputForceMultiplier * Mathf.Abs(lerpedInput.y);
			}
			val2 *= num;
			rigidBody.AddForce(val2, ForwardForceMode);
			Quaternion rotation;
			if (lerpedInput.x != 0f)
			{
				rotation = rigidBody.rotation;
				Quaternion val3 = Quaternion.Euler(Vector3Ex.WithZ(((Quaternion)(ref rotation)).eulerAngles, Mathx.RemapValClamped(lerpedInput.x, -1f, 1f, 40f, -40f)));
				rigidBody.MoveRotation(Quaternion.Lerp(rigidBody.rotation, val3, Time.fixedDeltaTime * 30f));
				rigidBody.AddTorque(((Component)this).transform.TransformDirection(Vector3.up * (TurnForce * num * 0.2f * lerpedInput.x)), TurnForceMode);
			}
			if (lerpedInput.y > 0f)
			{
				rotation = rigidBody.rotation;
				Quaternion val4 = Quaternion.Euler(Vector3Ex.WithX(((Quaternion)(ref rotation)).eulerAngles, Mathx.RemapValClamped(lerpedInput.y, -1f, 1f, -50f, 60f)));
				rigidBody.MoveRotation(Quaternion.Lerp(rigidBody.rotation, val4, Time.fixedDeltaTime * 60f));
			}
			rotation = rigidBody.rotation;
			Quaternion val5 = Quaternion.Euler(Vector3Ex.WithZ(Vector3Ex.WithX(((Quaternion)(ref rotation)).eulerAngles, 0f), 0f));
			rigidBody.rotation = Quaternion.Lerp(rigidBody.rotation, val5, Time.fixedDeltaTime * UprightLerpForce);
			float num5 = DamageHorizontalVelocityCurve.Evaluate(num);
			Vector3 velocity = rigidBody.velocity;
			velocity.x = Mathf.Clamp(velocity.x, 0f - num5, num5);
			velocity.z = Mathf.Clamp(velocity.z, 0f - num5, num5);
			rigidBody.velocity = velocity;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void PlayerDismounted(BasePlayer player, BaseMountable seat)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		base.PlayerDismounted(player, seat);
		if (collisionDeath)
		{
			if (TimeSince.op_Implicit(mountTime) < HurtDeployTime)
			{
				float num = 1f - Mathf.Clamp01(TimeSince.op_Implicit(mountTime) / HurtDeployTime);
				player.Hurt(HurtAmount * num, DamageType.Fall);
			}
			else
			{
				float magnitude = ((Vector3)(ref collisionImpulse)).magnitude;
				if (magnitude > 50f)
				{
					float amount = Mathx.RemapValClamped(magnitude, 50f, 400f, 5f, 50f);
					player.Hurt(amount, DamageType.Fall);
				}
			}
		}
		if (BypassRepack)
		{
			Item item = ItemManager.Create(PackedParachute, 1, skinID);
			item.RepairCondition(item.maxCondition);
			player.inventory.containerWear.GiveItem(item);
		}
		Analytics.Azure.OnParachuteUsed(player, distanceTravelled, startHeight, TimeSince.op_Implicit(mountTime));
		if (collisionDeath && LandingAnimations)
		{
			Effect.server.Run(ParachuteLandScreenBounce.resourcePath, player, 0u, Vector3.zero, Vector3.zero);
			if (collisionLocalPos.y < 0.15f)
			{
				player.Server_StartGesture(GestureCollection.HeavyLandingId);
				player.PlayHeavyLandingAnimation = false;
			}
		}
		ProcessDeath();
		collisionDeath = false;
	}

	public void ProcessDeath()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		float num = base.healthFraction;
		num -= ConditionLossPerUse;
		bool num2 = num > 0f;
		if (num2 && !BypassRepack)
		{
			ParachuteUnpacked parachuteUnpacked = GameManager.server.CreateEntity(DetachedParachute.resourcePath, DetachedSpawnPoint.position, DetachedSpawnPoint.rotation) as ParachuteUnpacked;
			if ((Object)(object)parachuteUnpacked != (Object)null)
			{
				parachuteUnpacked.skinID = skinID;
				parachuteUnpacked.Spawn();
				parachuteUnpacked.Hurt(parachuteUnpacked.MaxHealth() * (1f - num), DamageType.Generic, null, useProtection: false);
				Rigidbody val = default(Rigidbody);
				if (((Component)parachuteUnpacked).TryGetComponent<Rigidbody>(ref val))
				{
					val.velocity = rigidBody.velocity;
				}
			}
		}
		DestroyMode mode = DestroyMode.None;
		if (!num2)
		{
			mode = DestroyMode.Gib;
		}
		Kill(mode);
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)hitEntity == (Object)null)
		{
			hitEntity = collision.collider.ToBaseEntity();
		}
		if (!((Object)(object)hitEntity == (Object)(object)this) && (!((Object)(object)hitEntity != (Object)null) || hitEntity.isServer == base.isServer) && base.isServer && !(hitEntity is TimedExplosive) && !collisionDeath)
		{
			collisionImpulse = collision.impulse;
			Transform transform = ((Component)this).transform;
			ContactPoint contact = collision.GetContact(0);
			collisionLocalPos = transform.InverseTransformPoint(((ContactPoint)(ref contact)).point);
			contact = collision.GetContact(0);
			collisionWorldNormal = ((ContactPoint)(ref contact)).normal;
			collisionDeath = true;
			((FacepunchBehaviour)this).Invoke((Action)DelayedDismount, 0f);
		}
	}

	public void DelayedDismount()
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		if (collisionDeath && distanceTravelled > 0f && (!((Object)(object)mountPoints[0].mountable != (Object)null) || !GetDismountPosition(mountPoints[0].mountable.GetMounted(), out var _)))
		{
			Transform transform = ((Component)this).transform;
			transform.position += collisionWorldNormal * 0.35f;
		}
		DismountAllPlayers();
	}

	public override float MaxVelocity()
	{
		return 13.5f;
	}

	public override bool AllowPlayerInstigatedDismount(BasePlayer player)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		if (TimeSince.op_Implicit(mountTime) < 1.5f)
		{
			return false;
		}
		return base.AllowPlayerInstigatedDismount(player);
	}

	public bool IsValidSAMTarget(bool staticRespawn)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		if (TimeSince.op_Implicit(mountTime) > 1f)
		{
			return !InSafeZone();
		}
		return false;
	}

	private Vector2 ProcessInputVector(InputState inputState, BasePlayer player)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player.GetHeldEntity() != (Object)null)
		{
			return Vector2.zero;
		}
		bool leftDown = inputState.IsDown(BUTTON.LEFT);
		bool rightDown = inputState.IsDown(BUTTON.RIGHT);
		bool forwardDown = inputState.IsDown(BUTTON.FORWARD);
		bool backDown = inputState.IsDown(BUTTON.BACKWARD);
		return ProcessInputVector(leftDown, rightDown, forwardDown, backDown);
	}

	private Vector2 ProcessInputVectorFromFlags(BasePlayer player)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player.GetHeldEntity() != (Object)null)
		{
			return Vector2.zero;
		}
		bool leftDown = HasFlag(Flags.Reserved3);
		bool rightDown = HasFlag(Flags.Reserved4);
		bool forwardDown = HasFlag(Flags.Reserved1);
		bool backDown = HasFlag(Flags.Reserved2);
		return ProcessInputVector(leftDown, rightDown, forwardDown, backDown);
	}

	private static Vector2 ProcessInputVector(bool leftDown, bool rightDown, bool forwardDown, bool backDown)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		Vector2 zero = Vector2.zero;
		if (leftDown && rightDown)
		{
			leftDown = (rightDown = false);
		}
		if (forwardDown && backDown)
		{
			forwardDown = (backDown = false);
		}
		if (forwardDown)
		{
			zero.y = 1f;
		}
		else if (backDown)
		{
			zero.y = -1f;
		}
		if (rightDown)
		{
			zero.x = 1f;
		}
		else if (leftDown)
		{
			zero.x = -1f;
		}
		return zero;
	}
}


public class ParachuteSeat : SledSeat
{
	protected override bool BypassClothingMountBlocks => true;
}


using UnityEngine;

public class ParachuteUnpacked : DecayEntity
{
	public Rigidbody targetRigidbody;

	public Transform centreOfMassRoot;

	public override void ServerInit()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		targetRigidbody.centerOfMass = centreOfMassRoot.localPosition;
	}
}


using UnityEngine;

public class ParachuteWearable : MonoBehaviour
{
	public Animator TargetAnimator;

	public Transform LeftHandTarget;

	public Transform RightHandTarget;
}


using System;
using UnityEngine;

public class Pinata : BaseCombatEntity
{
	[Serializable]
	public struct VisualThreshold
	{
		public GameObject Root;

		public GameObjectRef DestroyEffect;

		[Range(0f, 1f)]
		public float HealthGreaterThan;
	}

	public Transform DropPoint;

	public float DropPointRadius;

	[Header("Hit Animation")]
	public float TotalSwingTime = 0.6f;

	public float SwingForce = 45f;

	public Transform SwingTransform;

	public AnimationCurve SwingCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[3]
	{
		new Keyframe(0f, 0f),
		new Keyframe(0.5f, 1f),
		new Keyframe(1f, 0f)
	});

	[Header("Visual")]
	public VisualThreshold[] Thresholds;

	public LineRenderer Line;

	public Transform DestroyEffectSpawnPos;

	public float HangLength = -1.863f;

	public GameObjectRef FinalDestroyEffect;

	public override void OnDied(HitInfo info)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		base.OnDied(info);
		ItemAmount[] reward = PrefabAttribute.server.Find<PinataPayouts>(prefabID).GetPayout().Reward;
		foreach (ItemAmount itemAmount in reward)
		{
			if ((Object)(object)itemAmount.itemDef != (Object)null)
			{
				ItemManager.Create(itemAmount.itemDef, (int)itemAmount.amount, 0uL).CreateWorldObject(DropPoint.position + Random.onUnitSphere * Random.Range(0f, DropPointRadius));
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public struct VisualThreshold
{
	public GameObject Root;

	public GameObjectRef DestroyEffect;

	[Range(0f, 1f)]
	public float HealthGreaterThan;
}


using System;
using UnityEngine;

public class PinataPayouts : PrefabAttribute, IServerComponent
{
	[Serializable]
	public struct Payout
	{
		public ItemAmount[] Reward;

		public int Chance;
	}

	public Payout[] AllPayouts;

	private int totalChance;

	public Payout GetPayout()
	{
		if (totalChance == 0)
		{
			Payout[] allPayouts = AllPayouts;
			for (int i = 0; i < allPayouts.Length; i++)
			{
				Payout payout = allPayouts[i];
				totalChance += payout.Chance;
			}
		}
		if (totalChance == 0)
		{
			return AllPayouts[0];
		}
		int num = Random.Range(0, totalChance);
		int num2 = 0;
		for (int j = 0; j < AllPayouts.Length; j++)
		{
			Payout result = AllPayouts[j];
			if (num <= num2 + result.Chance)
			{
				return result;
			}
			num2 += result.Chance;
		}
		return AllPayouts[0];
	}

	protected override Type GetIndexedType()
	{
		return typeof(PinataPayouts);
	}
}


using System;

[Serializable]
public struct Payout
{
	public ItemAmount[] Reward;

	public int Chance;
}


using System.Collections.Generic;
using UnityEngine;

public class InstantCameraFlashController : MonoBehaviour
{
	[SerializeField]
	private List<Light> Flash = new List<Light>();

	private void Awake()
	{
		DisableFlash();
	}

	public void EnableFlash()
	{
		foreach (Light item in Flash)
		{
			if ((Object)(object)item != (Object)null)
			{
				((Behaviour)item).enabled = true;
			}
		}
	}

	public void DisableFlash()
	{
		foreach (Light item in Flash)
		{
			if ((Object)(object)item != (Object)null)
			{
				((Behaviour)item).enabled = false;
			}
		}
	}
}


public enum CameraFocusMode
{
	Off,
	Auto,
	Manual
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class PaddlingPool : LiquidContainer, ISplashable
{
	public const Flags FilledUp = Flags.Reserved4;

	public Transform poolWaterVolume;

	public GameObject poolWaterVisual;

	public float minimumWaterHeight;

	public float maximumWaterHeight = 1f;

	public WaterVolume waterVolume;

	public bool alignWaterUp = true;

	public GameObjectRef destroyedWithWaterEffect;

	public Transform destroyedWithWaterEffectPos;

	public Collider requireLookAt;

	private float lastFillAmount = -1f;

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		float normalisedFillLevel = GetNormalisedFillLevel();
		SetFlag(Flags.Reserved4, normalisedFillLevel >= 1f);
		UpdatePoolFillAmount(normalisedFillLevel);
		SendNetworkUpdate();
	}

	protected override void OnInventoryDirty()
	{
		base.OnInventoryDirty();
		float normalisedFillLevel = GetNormalisedFillLevel();
		UpdatePoolFillAmount(normalisedFillLevel);
		SendNetworkUpdate();
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		if (base.IsDestroyed)
		{
			return false;
		}
		if (!HasFlag(Flags.Reserved4) && (Object)(object)splashType != (Object)null)
		{
			for (int i = 0; i < ValidItems.Length; i++)
			{
				if ((Object)(object)ValidItems[i] != (Object)null && ValidItems[i].itemid == splashType.itemid)
				{
					return true;
				}
			}
		}
		return false;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		int amount2 = Mathf.Clamp(Mathf.RoundToInt((float)amount * 0.66f), 1, amount);
		base.inventory.AddItem(splashType, amount2, 0uL);
		return amount;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.WaterPool = Pool.Get<WaterPool>();
		info.msg.WaterPool.fillAmount = GetNormalisedFillLevel();
	}

	private float GetNormalisedFillLevel()
	{
		if (base.inventory.itemList.Count <= 0 || base.inventory.itemList[0] == null)
		{
			return 0f;
		}
		return (float)base.inventory.itemList[0].amount / (float)maxStackSize;
	}

	private void UpdatePoolFillAmount(float normalisedAmount)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		poolWaterVisual.gameObject.SetActive(normalisedAmount > 0f);
		waterVolume.waterEnabled = normalisedAmount > 0f;
		float y = Mathf.Lerp(minimumWaterHeight, maximumWaterHeight, normalisedAmount);
		Vector3 localPosition = poolWaterVolume.localPosition;
		localPosition.y = y;
		poolWaterVolume.localPosition = localPosition;
		if (alignWaterUp)
		{
			poolWaterVolume.up = Vector3.up;
		}
		if (normalisedAmount > 0f && lastFillAmount < normalisedAmount && waterVolume.entityContents != null)
		{
			foreach (BaseEntity entityContent in waterVolume.entityContents)
			{
				if (entityContent is IPoolVehicle poolVehicle)
				{
					poolVehicle.WakeUp();
				}
			}
		}
		lastFillAmount = normalisedAmount;
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (!base.isServer)
		{
			return;
		}
		List<IPoolVehicle> list = Pool.Get<List<IPoolVehicle>>();
		if (waterVolume.entityContents != null)
		{
			foreach (BaseEntity entityContent in waterVolume.entityContents)
			{
				if (entityContent is IPoolVehicle item)
				{
					list.Add(item);
				}
			}
		}
		foreach (IPoolVehicle item2 in list)
		{
			item2.OnPoolDestroyed();
		}
		Pool.FreeUnmanaged<IPoolVehicle>(ref list);
	}
}


public class ItemModPhoto : ItemModAssociatedEntity<PhotoEntity>
{
	protected override bool AllowNullParenting => true;
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using Rust;

public class PhotoEntity : ImageStorageEntity, IUGCBrowserEntity
{
	public ulong PhotographerSteamId { get; private set; }

	public uint ImageCrc { get; private set; }

	protected override uint CrcToLoad => ImageCrc;

	public override bool ShouldTransferAssociatedFiles => true;

	public uint[] GetContentCRCs
	{
		get
		{
			if (ImageCrc == 0)
			{
				return Array.Empty<uint>();
			}
			return new uint[1] { ImageCrc };
		}
	}

	public UGCType ContentType => UGCType.ImageJpg;

	public List<ulong> EditingHistory
	{
		get
		{
			if (PhotographerSteamId == 0)
			{
				return new List<ulong>();
			}
			return new List<ulong> { PhotographerSteamId };
		}
	}

	public BaseNetworkable UgcEntity => this;

	public string ContentString => string.Empty;

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.photo != null)
		{
			PhotographerSteamId = info.msg.photo.photographerSteamId;
			ImageCrc = info.msg.photo.imageCrc;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.photo = Pool.Get<Photo>();
		info.msg.photo.photographerSteamId = PhotographerSteamId;
		info.msg.photo.imageCrc = ImageCrc;
	}

	public void SetImageData(ulong steamId, byte[] data)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		ImageCrc = FileStorage.server.Store(data, FileStorage.Type.jpg, net.ID);
		PhotographerSteamId = steamId;
	}

	internal override void DoServerDestroy()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		base.DoServerDestroy();
		if (!Application.isQuitting && net != null)
		{
			FileStorage.server.RemoveAllByEntity(net.ID);
		}
	}

	public void ClearContent()
	{
		ImageCrc = 0u;
		SendNetworkUpdate();
	}
}


using UnityEngine;
using UnityEngine.UI;

public class PhotoPanel : MonoBehaviour, IImageReceiver, IItemPanel
{
	public RawImage Image;

	public InputField Message;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class SignPanel : MonoBehaviour, IImageReceiver, IItemPanel
{
	public RawImage Image;

	public RectTransform ImageContainer;

	public RustText DisabledSignsMessage;
}


using UnityEngine;

public class TwitchTrophy : BaseCombatEntity
{
	[Header("Trophy")]
	public GameObjectRef DialogPrefab;
}


using Rust.UI;
using UnityEngine;

public class UITwitchTrophy : UIDialog
{
	public HttpImage EventImage;

	public RustText EventName;

	public RustText WinningTeamName;

	public RectTransform TeamMembersRoot;

	public GameObject TeamMemberNamePrefab;

	public GameObject MissingDataOverlay;
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class NPCDwelling : BaseEntity
{
	public NPCSpawner npcSpawner;

	public float NPCSpawnChance = 1f;

	public SpawnGroup[] spawnGroups;

	public AIMovePoint[] movePoints;

	public AICoverPoint[] coverPoints;

	public override void ServerInit()
	{
		base.ServerInit();
		UpdateInformationZone(remove: false);
		if ((Object)(object)npcSpawner != (Object)null && Random.Range(0f, 1f) <= NPCSpawnChance)
		{
			npcSpawner.SpawnInitial();
		}
		SpawnGroup[] array = spawnGroups;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SpawnInitial();
		}
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			CleanupSpawned();
		}
		base.DestroyShared();
		if (base.isServer)
		{
			UpdateInformationZone(remove: true);
		}
	}

	public bool ValidateAIPoint(Vector3 pos)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).gameObject.SetActive(false);
		bool result = !GamePhysics.CheckSphere(pos + Vector3.up * 0.6f, 0.5f, 65537, (QueryTriggerInteraction)0);
		((Component)this).gameObject.SetActive(true);
		return result;
	}

	public void UpdateInformationZone(bool remove)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		AIInformationZone forPoint = AIInformationZone.GetForPoint(((Component)this).transform.position);
		if (!((Object)(object)forPoint == (Object)null))
		{
			if (remove)
			{
				forPoint.RemoveDynamicAIPoints(movePoints, coverPoints);
			}
			else
			{
				forPoint.AddDynamicAIPoints(movePoints, coverPoints, ValidateAIPoint);
			}
		}
	}

	public void CheckDespawn()
	{
		if (!PlayersNearby() && (!Object.op_Implicit((Object)(object)npcSpawner) || npcSpawner.currentPopulation <= 0))
		{
			CleanupSpawned();
			Kill();
		}
	}

	public void CleanupSpawned()
	{
		if (spawnGroups != null)
		{
			SpawnGroup[] array = spawnGroups;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Clear();
			}
		}
		if (Object.op_Implicit((Object)(object)npcSpawner))
		{
			npcSpawner.Clear();
		}
	}

	public bool PlayersNearby()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Vis.Entities(((Component)this).transform.position, TimeoutPlayerCheckRadius(), list, 131072, (QueryTriggerInteraction)2);
		bool result = false;
		foreach (BasePlayer item in list)
		{
			if (!item.IsSleeping() && item.IsAlive())
			{
				result = true;
				break;
			}
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
		return result;
	}

	public virtual float TimeoutPlayerCheckRadius()
	{
		return 10f;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class HexagonGridGenerator : BaseEntity
{
	public GameObjectRef[] hexTilePrefabs;

	[Space]
	public int gridRadius = 5;

	public float tileSpacing = 1.5f;

	[Space]
	public float levelCount = 5f;

	public float levelSpacing = 20f;

	private readonly List<HexagonTile> hexTiles = new List<HexagonTile>();

	public static HexagonGridGenerator Instance;

	public override void ServerInit()
	{
		base.ServerInit();
		Instance = this;
		GenerateHexGrid();
	}

	public void GenerateHexGrid()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		for (int num = hexTiles.Count; num > 0; num--)
		{
			hexTiles[num - 1].Kill();
		}
		hexTiles.Clear();
		for (int i = 0; (float)i < levelCount; i++)
		{
			GenerateLevel(((Component)this).transform.position + Vector3.up * (levelSpacing * (float)(i + 1)), i);
		}
	}

	private void GenerateLevel(Vector3 basePos, int level)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		float num = tileSpacing * 2f;
		float num2 = Mathf.Sqrt(3f) * tileSpacing;
		for (int i = -gridRadius; i <= gridRadius; i++)
		{
			int num3 = Mathf.Max(-gridRadius, -i - gridRadius);
			int num4 = Mathf.Min(gridRadius, -i + gridRadius);
			for (int j = num3; j <= num4; j++)
			{
				float num5 = ((float)i + (float)j / 2f) * num;
				float num6 = (float)j * num2;
				Vector3 pos = basePos + new Vector3(num5, 0f, num6);
				int num7 = Random.Range(-5, 6);
				float num8 = 30f + 180f * (float)num7;
				Quaternion rot = Quaternion.Euler(0f, num8, 0f);
				HexagonTile hexagonTile = GameManager.server.CreateEntity(hexTilePrefabs[level].resourcePath, pos, rot) as HexagonTile;
				hexagonTile.Spawn();
				hexTiles.Add(hexagonTile);
			}
		}
	}

	[ServerVar(Help = "<gridSize> 5 <tileSpacing> 1.35")]
	public static void generategrid(Arg args)
	{
		int @int = args.GetInt(0, 5);
		float @float = args.GetFloat(1, 1.35f);
		@int = Math.Clamp(@int, 1, 50);
		@float = Mathf.Clamp(@float, 1.35f, float.PositiveInfinity);
		Instance.gridRadius = @int;
		Instance.tileSpacing = @float;
		Instance.GenerateHexGrid();
	}
}


using System;
using UnityEngine;

public class HexagonTile : BaseCombatEntity, IDetector
{
	public GameObject[] variants;

	public AnimationCurve tweenCurve;

	private MeshRenderer mesh;

	public bool ShouldTrigger()
	{
		return true;
	}

	public void OnObjects()
	{
		SetFlag(Flags.Busy, b: true);
	}

	public void OnObjectAdded(GameObject obj, Collider col)
	{
	}

	public void OnEmpty()
	{
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		SetFlag(Flags.Busy, b: true);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (old.HasFlag(Flags.Busy) != next.HasFlag(Flags.Busy) && base.isServer)
		{
			((FacepunchBehaviour)this).Invoke((Action)delegate
			{
				Kill();
			}, 1.2f);
		}
	}
}


using UnityEngine;

public class RaceWaypointVisual : MonoBehaviour
{
	public GameObject RegularCheckpoint;

	public GameObject FinishCheckpoint;
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class WaypointRace : BaseEntity
{
	private class PendingRaceResults
	{
		private class Completion
		{
			public List<BasePlayer> players = new List<BasePlayer>();

			public float time;

			public bool valid;
		}

		private List<Completion> Completions = new List<Completion>();

		public int totalParticipants;

		public int RegisterCompletion(List<BasePlayer> forPlayers, float time, bool valid)
		{
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Expected O, but got Unknown
			Completion completion = new Completion();
			foreach (BasePlayer forPlayer in forPlayers)
			{
				completion.players.Add(forPlayer);
			}
			completion.time = time;
			completion.valid = valid;
			Completions.Add(completion);
			if (Completions.Count == totalParticipants)
			{
				TextTable val = new TextTable();
				val.AddColumns(new string[3] { "Place", "Players", "Time" });
				for (int i = 0; i < Completions.Count; i++)
				{
					Completion completion2 = Completions[i];
					if (!completion2.valid)
					{
						continue;
					}
					string text = "";
					foreach (BasePlayer player in completion2.players)
					{
						text = text + player.displayName + ",";
					}
					val.AddRow(new string[3]
					{
						$"P{i + 1}",
						text,
						MathEx.SnapTo(completion2.time, 0.1f).ToString()
					});
				}
				string msg = ((object)val).ToString();
				foreach (Completion completion3 in Completions)
				{
					foreach (BasePlayer player2 in completion3.players)
					{
						player2.ChatMessage(msg);
					}
				}
			}
			return Completions.Count;
		}
	}

	public float WaypointRadius = 10f;

	public RaceWaypointVisual TargetWaypointVisual;

	public RaceWaypointVisual NextWaypointVisual;

	private List<Vector3> racePoints = new List<Vector3>();

	private EntityRef<BaseVehicle> racingVehicle;

	private int currentWaypoint;

	public static Phrase stageNotifyPhrase = new Phrase("race_notify", "Reached checkpoint {0}/{1} : {2}s");

	public static Phrase raceCompletePhrase = new Phrase("race_complete", "Finished race {0}/{1} in {2}s");

	private PendingRaceResults raceResults;

	private TimeSince startTime;

	[ServerVar(Saved = true, Help = "How long a race can go until it times out (in seconds)")]
	public static float raceTimeout = 900f;

	[ServerVar]
	public static void startRace(Arg arg)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		string @string = arg.GetString(0, "");
		List<Transform> list = Pool.Get<List<Transform>>();
		WaypointRaceTarget.GetWaypoints(@string, list);
		if (list.Count == 0)
		{
			arg.ReplyWith("Couldn't find any waypoints for " + @string + ", is the name correct?");
			return;
		}
		Debug.Log((object)$"Starting race {@string} with {list.Count} waypoints");
		List<BasePlayer> list2 = Pool.Get<List<BasePlayer>>();
		Vis.Entities(list[0].position, 30f, list2, 131072, (QueryTriggerInteraction)2);
		List<BaseVehicle> list3 = Pool.Get<List<BaseVehicle>>();
		for (int i = 0; i < list2.Count; i++)
		{
			if (list2[i].isClient)
			{
				list2.RemoveAt(i);
				i--;
				continue;
			}
			if (!list2[i].isMounted)
			{
				Debug.Log((object)("Remove player " + list2[i].displayName + " from race, not mounted"));
				list2.RemoveAt(i);
				i--;
				continue;
			}
			BaseMountable mounted = list2[i].GetMounted();
			if ((Object)(object)mounted == (Object)null || (Object)(object)mounted.VehicleParent() == (Object)null)
			{
				Debug.Log((object)("Remove player " + list2[i].displayName + " from race, no vehicle"));
				list2.RemoveAt(i);
				i--;
				continue;
			}
			BaseVehicle baseVehicle = mounted.VehicleParent();
			if (!baseVehicle.IsDriver(list2[i]))
			{
				Debug.Log((object)("Remove player " + list2[i].displayName + " from race, not a driver"));
				list2.RemoveAt(i);
				i--;
			}
			else if (!list3.Contains(baseVehicle))
			{
				list3.Add(baseVehicle);
			}
		}
		PendingRaceResults results = new PendingRaceResults
		{
			totalParticipants = list3.Count
		};
		foreach (BaseVehicle item in list3)
		{
			WaypointRace obj = GameManager.server.CreateEntity("assets/prefabs/misc/waypointrace/waypointrace.prefab", ((Component)item).transform.position, Quaternion.identity) as WaypointRace;
			obj.Setup(list, item, results);
			obj.Spawn();
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list2);
		Pool.FreeUnmanaged<BaseVehicle>(ref list3);
		Pool.FreeUnmanaged<Transform>(ref list);
	}

	private void Setup(List<Transform> waypoints, BaseVehicle participant, PendingRaceResults results)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		racingVehicle.Set(participant);
		foreach (Transform waypoint in waypoints)
		{
			racePoints.Add(waypoint.position);
		}
		raceResults = results;
		startTime = TimeSince.op_Implicit(0f);
	}

	public override void Save(SaveInfo info)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.waypointRace == null)
		{
			info.msg.waypointRace = Pool.Get<WaypointRace>();
		}
		info.msg.waypointRace.positions = Pool.Get<List<Vector3>>();
		info.msg.waypointRace.positions.Clear();
		foreach (Vector3 racePoint in racePoints)
		{
			info.msg.waypointRace.positions.Add(racePoint);
		}
		info.msg.waypointRace.racingVehicle = racingVehicle.uid;
		info.msg.waypointRace.currentWaypoint = currentWaypoint;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}

	private void Update()
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isServer)
		{
			return;
		}
		BaseVehicle baseVehicle = racingVehicle.Get(base.isServer);
		if ((Object)(object)baseVehicle == (Object)null || baseVehicle.IsDestroyed || baseVehicle.IsDead() || TimeSince.op_Implicit(startTime) > raceTimeout)
		{
			raceResults.RegisterCompletion(new List<BasePlayer>(), TimeSince.op_Implicit(startTime), valid: false);
			Kill();
			return;
		}
		((Component)this).transform.position = ((Component)baseVehicle).transform.position;
		if (racePoints.Count <= currentWaypoint + 1)
		{
			return;
		}
		Vector3 val = racePoints[currentWaypoint + 1];
		Vector3 val2 = ((Component)baseVehicle).transform.position - val;
		if (!(((Vector3)(ref val2)).sqrMagnitude <= WaypointRadius * WaypointRadius))
		{
			return;
		}
		currentWaypoint++;
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		baseVehicle.GetMountedPlayers(list);
		if (currentWaypoint >= racePoints.Count - 1)
		{
			int num = raceResults.RegisterCompletion(list, TimeSince.op_Implicit(startTime), valid: true);
			foreach (BasePlayer item in list)
			{
				item.ShowToast(GameTip.Styles.Blue_Normal, raceCompletePhrase, false, num.ToString(), raceResults.totalParticipants.ToString(), MathEx.SnapTo(TimeSince.op_Implicit(startTime), 0.1f).ToString());
			}
			Kill();
		}
		else
		{
			foreach (BasePlayer item2 in list)
			{
				item2.ShowToast(GameTip.Styles.Blue_Normal, stageNotifyPhrase, false, currentWaypoint.ToString(), (racePoints.Count - 1).ToString(), MathEx.SnapTo(TimeSince.op_Implicit(startTime), 0.1f).ToString());
			}
			SendNetworkUpdate();
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}
}


using System.Collections.Generic;
using UnityEngine;

private class PendingRaceResults
{
	private class Completion
	{
		public List<BasePlayer> players = new List<BasePlayer>();

		public float time;

		public bool valid;
	}

	private List<Completion> Completions = new List<Completion>();

	public int totalParticipants;

	public int RegisterCompletion(List<BasePlayer> forPlayers, float time, bool valid)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Expected O, but got Unknown
		Completion completion = new Completion();
		foreach (BasePlayer forPlayer in forPlayers)
		{
			completion.players.Add(forPlayer);
		}
		completion.time = time;
		completion.valid = valid;
		Completions.Add(completion);
		if (Completions.Count == totalParticipants)
		{
			TextTable val = new TextTable();
			val.AddColumns(new string[3] { "Place", "Players", "Time" });
			for (int i = 0; i < Completions.Count; i++)
			{
				Completion completion2 = Completions[i];
				if (!completion2.valid)
				{
					continue;
				}
				string text = "";
				foreach (BasePlayer player in completion2.players)
				{
					text = text + player.displayName + ",";
				}
				val.AddRow(new string[3]
				{
					$"P{i + 1}",
					text,
					MathEx.SnapTo(completion2.time, 0.1f).ToString()
				});
			}
			string msg = ((object)val).ToString();
			foreach (Completion completion3 in Completions)
			{
				foreach (BasePlayer player2 in completion3.players)
				{
					player2.ChatMessage(msg);
				}
			}
		}
		return Completions.Count;
	}
}


using System.Collections.Generic;

private class Completion
{
	public List<BasePlayer> players = new List<BasePlayer>();

	public float time;

	public bool valid;
}


using System.Collections.Generic;
using UnityEngine;

public class WaypointRaceTarget : MonoBehaviour
{
	private static Dictionary<string, Transform> allPoints = new Dictionary<string, Transform>();

	private void Start()
	{
		string text = ((Object)((Component)this).gameObject).name.ToLower();
		if (!allPoints.TryAdd(text, ((Component)this).transform))
		{
			Debug.Log((object)("Unable to add waypoint marker " + text + ", needs a unique name"));
		}
	}

	public static void GetWaypoints(string filter, List<Transform> found, int max = 20)
	{
		string empty = string.Empty;
		for (int i = 0; i < max; i++)
		{
			empty = $"{filter.ToLower()}{i}";
			if (allPoints.TryGetValue(empty, out var value))
			{
				found.Add(value);
			}
		}
	}
}


using UnityEngine;

public class IceFence : GraveyardFence
{
	public GameObject[] styles;

	private bool init;

	public AdaptMeshToTerrain snowMesh;

	public int GetStyleFromID()
	{
		uint num = (uint)net.ID.Value;
		return SeedRandom.Range(ref num, 0, styles.Length);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		InitStyle();
		UpdatePillars();
	}

	public void InitStyle()
	{
		if (!init)
		{
			SetStyle(GetStyleFromID());
		}
	}

	public void SetStyle(int style)
	{
		GameObject[] array = styles;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].gameObject.SetActive(false);
		}
		styles[style].gameObject.SetActive(true);
	}

	public override void UpdatePillars()
	{
		base.UpdatePillars();
	}
}


using Oxide.Core;
using UnityEngine;

public class ItemModUnwrap : ItemMod
{
	public static readonly Phrase UnwrapGiftTitle = new Phrase("unwrap_gift", "Unwrap");

	public static readonly Phrase UnwrapGiftDesc = new Phrase("unwrap_gift_desc", "Unwrap the gift");

	public Phrase OwnershipPhrase;

	public LootSpawn revealList;

	public GameObjectRef successEffect;

	public int minTries = 1;

	public int maxTries = 1;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		if (command == "unwrap" && item.amount > 0 && Interface.CallHook("OnItemUnwrap", (object)item, (object)player, (object)this) == null)
		{
			item.UseItem();
			int num = Random.Range(minTries, maxTries + 1);
			ItemOwnershipShare ownership = default(ItemOwnershipShare);
			if (OwnershipPhrase != null && !string.IsNullOrEmpty(OwnershipPhrase.token))
			{
				ItemOwnershipShare itemOwnershipShare = default(ItemOwnershipShare);
				itemOwnershipShare.username = player.displayName;
				itemOwnershipShare.reason = OwnershipPhrase.token;
				ownership = itemOwnershipShare;
			}
			for (int i = 0; i < num; i++)
			{
				revealList.SpawnIntoContainer(player.inventory.containerMain, ownership, player.inventory.containerBelt);
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}
}


using System;
using UnityEngine;

public class NeonMeshPaintableSource : MeshPaintableSource
{
	public NeonSign neonSign;

	public float editorEmissionScale = 2f;

	public AnimationCurve lightingCurve;

	[NonSerialized]
	public Color topLeft;

	[NonSerialized]
	public Color topRight;

	[NonSerialized]
	public Color bottomLeft;

	[NonSerialized]
	public Color bottomRight;

	public override void UpdateMaterials(MaterialPropertyBlock block, Texture2D textureOverride = null, bool forEditing = false, bool isSelected = false)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		base.UpdateMaterials(block, textureOverride, forEditing);
		if (forEditing)
		{
			block.SetFloat("_EmissionScale", editorEmissionScale);
			block.SetFloat("_Power", (float)(isSelected ? 1 : 0));
			if (!isSelected)
			{
				block.SetColor("_TubeInner", Color.clear);
				block.SetColor("_TubeOuter", Color.clear);
			}
		}
		else if ((Object)(object)neonSign != (Object)null)
		{
			block.SetFloat("_Power", (float)((isSelected && (neonSign.HasFlag(BaseEntity.Flags.Reserved8) || neonSign.HasFlag(BaseEntity.Flags.Reserved9))) ? 1 : 0));
		}
	}

	public override Color32[] UpdateFrom(Texture2D input)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		Init();
		Color32[] pixels = input.GetPixels32();
		texture.SetPixels32(pixels);
		texture.Apply(true, false);
		int width = ((Texture)input).width;
		int height = ((Texture)input).height;
		int num = width / 2;
		int num2 = height / 2;
		topLeft = GetColorForRegion(0, num2, num, num2);
		topRight = GetColorForRegion(num, num2, num, num2);
		bottomLeft = GetColorForRegion(0, 0, num, num2);
		bottomRight = GetColorForRegion(num, 0, num, num2);
		return pixels;
		Color GetColorForRegion(int x, int y, int regionWidth, int regionHeight)
		{
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			float num3 = 0f;
			float num4 = 0f;
			float num5 = 0f;
			int num6 = y + regionHeight;
			for (int i = y; i < num6; i++)
			{
				int num7 = i * width + x;
				int num8 = num7 + regionWidth;
				for (int j = num7; j < num8; j++)
				{
					Color32 val = pixels[j];
					float num9 = (float)(int)val.a / 255f;
					num3 += (float)(int)val.r * num9;
					num4 += (float)(int)val.g * num9;
					num5 += (float)(int)val.b * num9;
				}
			}
			int num10 = regionWidth * regionHeight * 255;
			return new Color(lightingCurve.Evaluate(num3 / (float)num10), lightingCurve.Evaluate(num4 / (float)num10), lightingCurve.Evaluate(num5 / (float)num10), 1f);
		}
	}
}


using UnityEngine;

public class BaseBulb : MonoBehaviour
{
	public Renderer bulbRenderer;
}


public class Bulb : BaseBulb
{
	public MaterialSwap swap;
}


using System;
using UnityEngine;

public class Sled : BaseVehicle, INotifyTrigger
{
	public const Flags BrakeOn = Flags.Reserved1;

	public const Flags OnSnow = Flags.Reserved2;

	public const Flags IsGrounded = Flags.Reserved3;

	public const Flags OnSand = Flags.Reserved4;

	public PhysicMaterial BrakeMaterial;

	public PhysicMaterial SnowMaterial;

	public PhysicMaterial NonSnowMaterial;

	public Transform CentreOfMassTransform;

	public Collider[] PhysicsMaterialTargets;

	public float InitialForceCutoff = 3f;

	public float InitialForceIncreaseRate = 0.05f;

	public float TurnForce = 1f;

	public float DirectionMatchForce = 1f;

	public float VerticalAdjustmentForce = 1f;

	public float VerticalAdjustmentAngleThreshold = 15f;

	public float NudgeCooldown = 3f;

	public float NudgeForce = 2f;

	public float MaxNudgeVelocity = 2f;

	public const float DecayFrequency = 60f;

	public float DecayAmount = 10f;

	public ParticleSystemContainer TrailEffects;

	public SoundDefinition enterSnowSoundDef;

	public SoundDefinition snowSlideLoopSoundDef;

	public SoundDefinition dirtSlideLoopSoundDef;

	public AnimationCurve movementLoopGainCurve;

	public AnimationCurve movementLoopPitchCurve;

	public VehicleTerrainHandler terrainHandler;

	public PhysicMaterial cachedMaterial;

	public float initialForceScale;

	public TimeSince leftIce;

	public TimeSince lastNudge;

	public override bool BlocksDoors => false;

	public override void ServerInit()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		terrainHandler = new VehicleTerrainHandler(this);
		terrainHandler.RayLength = 0.6f;
		rigidBody.centerOfMass = CentreOfMassTransform.localPosition;
		((FacepunchBehaviour)this).InvokeRandomized((Action)DecayOverTime, Random.Range(30f, 60f), 60f, 6f);
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		SetFlag(Flags.Reserved1, b: true);
		UpdateGroundedFlag();
		UpdatePhysicsMaterial();
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Sled.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (!AnyMounted())
			{
				return;
			}
			terrainHandler.FixedUpdate();
			if (!terrainHandler.IsGrounded)
			{
				Quaternion val2 = Quaternion.FromToRotation(((Component)this).transform.up, Vector3.up) * rigidBody.rotation;
				if (Quaternion.Angle(rigidBody.rotation, val2) > VerticalAdjustmentAngleThreshold)
				{
					rigidBody.MoveRotation(Quaternion.Slerp(rigidBody.rotation, val2, Time.fixedDeltaTime * VerticalAdjustmentForce));
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void UpdatePhysicsMaterial()
	{
		cachedMaterial = GetPhysicMaterial();
		Collider[] physicsMaterialTargets = PhysicsMaterialTargets;
		for (int i = 0; i < physicsMaterialTargets.Length; i++)
		{
			physicsMaterialTargets[i].sharedMaterial = cachedMaterial;
		}
		if (!AnyMounted() && rigidBody.IsSleeping())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)UpdatePhysicsMaterial);
		}
		SetFlag(Flags.Reserved2, terrainHandler.IsOnSnowOrIce);
		SetFlag(Flags.Reserved4, terrainHandler.OnSurface == VehicleTerrainHandler.Surface.Sand);
	}

	public void UpdateGroundedFlag()
	{
		if (!AnyMounted() && rigidBody.IsSleeping())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)UpdateGroundedFlag);
		}
		SetFlag(Flags.Reserved3, terrainHandler.IsGrounded);
	}

	public PhysicMaterial GetPhysicMaterial()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		if (HasFlag(Flags.Reserved1) || !AnyMounted())
		{
			return BrakeMaterial;
		}
		bool flag = terrainHandler.IsOnSnowOrIce || terrainHandler.OnSurface == VehicleTerrainHandler.Surface.Sand;
		if (flag)
		{
			leftIce = TimeSince.op_Implicit(0f);
		}
		else if (TimeSince.op_Implicit(leftIce) < 2f)
		{
			flag = true;
		}
		if (!flag)
		{
			return NonSnowMaterial;
		}
		return SnowMaterial;
	}

	public override void PlayerMounted(BasePlayer player, BaseMountable seat)
	{
		base.PlayerMounted(player, seat);
		if (HasFlag(Flags.Reserved1))
		{
			initialForceScale = 0f;
			((FacepunchBehaviour)this).InvokeRepeating((Action)ApplyInitialForce, 0f, 0.1f);
			SetFlag(Flags.Reserved1, b: false);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)UpdatePhysicsMaterial))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdatePhysicsMaterial, 0f, 0.5f);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)UpdateGroundedFlag))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateGroundedFlag, 0f, 0.1f);
		}
		if (rigidBody.IsSleeping())
		{
			rigidBody.WakeUp();
		}
	}

	public void ApplyInitialForce()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 val = ((Vector3.Dot(forward, -Vector3.up) > Vector3.Dot(-forward, -Vector3.up)) ? forward : (-forward));
		rigidBody.AddForce(val * initialForceScale * (terrainHandler.IsOnSnowOrIce ? 1f : 0.25f), (ForceMode)5);
		initialForceScale += InitialForceIncreaseRate;
		if (initialForceScale >= InitialForceCutoff)
		{
			Vector3 velocity = rigidBody.velocity;
			if (((Vector3)(ref velocity)).magnitude > 1f || !terrainHandler.IsOnSnowOrIce)
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)ApplyInitialForce);
			}
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		base.PlayerServerInput(inputState, player);
		if (Vector3.Dot(((Component)this).transform.up, Vector3.up) < 0.1f || WaterFactor() > 0.25f)
		{
			DismountAllPlayers();
			return;
		}
		float num = (inputState.IsDown(BUTTON.LEFT) ? (-1f) : 0f);
		num += (inputState.IsDown(BUTTON.RIGHT) ? 1f : 0f);
		Vector3 velocity;
		if (inputState.IsDown(BUTTON.FORWARD) && TimeSince.op_Implicit(lastNudge) > NudgeCooldown)
		{
			velocity = rigidBody.velocity;
			if (((Vector3)(ref velocity)).magnitude < MaxNudgeVelocity)
			{
				rigidBody.WakeUp();
				rigidBody.AddForce(((Component)this).transform.forward * NudgeForce, (ForceMode)1);
				rigidBody.AddForce(((Component)this).transform.up * NudgeForce * 0.5f, (ForceMode)1);
				lastNudge = TimeSince.op_Implicit(0f);
			}
		}
		num *= TurnForce;
		Vector3 velocity2 = rigidBody.velocity;
		if (num != 0f)
		{
			((Component)this).transform.Rotate(Vector3.up * num * Time.deltaTime * ((Vector3)(ref velocity2)).magnitude, (Space)1);
		}
		if (terrainHandler.IsGrounded)
		{
			velocity = rigidBody.velocity;
			if (Vector3.Dot(((Vector3)(ref velocity)).normalized, ((Component)this).transform.forward) >= 0.5f)
			{
				rigidBody.velocity = Vector3.Lerp(rigidBody.velocity, ((Component)this).transform.forward * ((Vector3)(ref velocity2)).magnitude, Time.deltaTime * DirectionMatchForce);
			}
		}
	}

	public void DecayOverTime()
	{
		if (!AnyMounted())
		{
			Hurt(DecayAmount);
		}
	}

	public override bool CanPickup(BasePlayer player)
	{
		if (base.CanPickup(player))
		{
			return !player.isMounted;
		}
		return false;
	}

	public void OnObjects(TriggerNotify trigger)
	{
		foreach (BaseEntity entityContent in trigger.entityContents)
		{
			if (!(entityContent is Sled))
			{
				if (entityContent is BaseVehicleModule baseVehicleModule && (Object)(object)baseVehicleModule.Vehicle != (Object)null && (baseVehicleModule.Vehicle.IsOn() || !baseVehicleModule.Vehicle.IsStationary()))
				{
					Kill(DestroyMode.Gib);
					break;
				}
				if (entityContent is BaseVehicle baseVehicle && baseVehicle.HasDriver() && (baseVehicle.IsMoving() || baseVehicle.HasFlag(Flags.On)))
				{
					Kill(DestroyMode.Gib);
					break;
				}
			}
		}
	}

	public void OnEmpty()
	{
	}
}


using UnityEngine;

public class SledSeat : BaseVehicleSeat
{
	public Transform LeftHand;

	public Transform RightHand;

	public Transform LeftFoot;

	public Transform RightFoot;

	public float MountedAnimationSpeed;
}


public class HandSnowball : BaseMelee
{
}


using UnityEngine;

public class SnowballGun : BaseProjectile
{
	public ItemDefinition OverrideProjectile;

	private static ItemDefinition _snowballInventoryItem;

	private static ItemDefinition _snowballAmmoItem;

	public static ItemDefinition SnowballInventoryItem
	{
		get
		{
			if ((Object)(object)_snowballInventoryItem == (Object)null)
			{
				_snowballInventoryItem = ItemManager.FindItemDefinition("snowball");
			}
			return _snowballInventoryItem;
		}
	}

	public static ItemDefinition SnowballAmmoItem
	{
		get
		{
			if ((Object)(object)_snowballAmmoItem == (Object)null)
			{
				_snowballAmmoItem = ItemManager.FindItemDefinition("ammo.snowballgun");
			}
			return _snowballAmmoItem;
		}
	}

	protected override ItemDefinition PrimaryMagazineAmmo
	{
		get
		{
			if (!((Object)(object)OverrideProjectile != (Object)null))
			{
				return base.PrimaryMagazineAmmo;
			}
			return OverrideProjectile;
		}
	}

	protected override bool CanRefundAmmo => false;

	public override bool TryReloadMagazine(IAmmoContainer ammoSource, int desiredAmount = -1)
	{
		desiredAmount = 1;
		if (!TryReload(ammoSource, desiredAmount, CanRefundAmmo))
		{
			return false;
		}
		SetAmmoCount(primaryMagazine.capacity);
		primaryMagazine.ammoType = OverrideProjectile;
		SendNetworkUpdateImmediate();
		ItemManager.DoRemoves();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null)
		{
			ownerPlayer.inventory.ServerUpdate(0f);
		}
		return true;
	}
}


public class SnowballGunProjectile : Projectile
{
	public float OverrideEffectScale = 0.5f;

	public GameObjectRef SnowballImpactEffect;
}


using UnityEngine;

public class SnowMachine : FogMachine
{
	public AdaptMeshToTerrain snowMesh;

	public TriggerTemperature tempTrigger;

	public override bool MotionModeEnabled()
	{
		return false;
	}

	public override void EnableFogField()
	{
		base.EnableFogField();
		((Component)tempTrigger).gameObject.SetActive(true);
	}

	public override void FinishFogging()
	{
		base.FinishFogging();
		((Component)tempTrigger).gameObject.SetActive(false);
	}
}


using Oxide.Core;
using Rust;
using UnityEngine;

public class Stocking : LootContainer
{
	public static ListHashSet<Stocking> stockings;

	public override void ServerInit()
	{
		base.ServerInit();
		if (stockings == null)
		{
			stockings = new ListHashSet<Stocking>();
		}
		stockings.Add(this);
	}

	internal override void DoServerDestroy()
	{
		stockings.Remove(this);
		base.DoServerDestroy();
	}

	public bool IsEmpty()
	{
		if (base.inventory == null)
		{
			return false;
		}
		for (int num = base.inventory.itemList.Count - 1; num >= 0; num--)
		{
			if (base.inventory.itemList[num] != null)
			{
				return false;
			}
		}
		return true;
	}

	public override void SpawnLoot()
	{
		if (base.inventory == null)
		{
			Debug.Log((object)("CONTACT DEVELOPERS! Stocking::PopulateLoot has null inventory!!! " + ((Object)this).name));
		}
		else if (IsEmpty() && Interface.CallHook("OnXmasStockingFill", (object)this) == null)
		{
			base.SpawnLoot();
			SetFlag(Flags.On, b: true);
			Hurt(MaxHealth() * 0.1f, DamageType.Generic, null, useProtection: false);
		}
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		base.PlayerStoppedLooting(player);
		SetFlag(Flags.On, b: false);
		if (IsEmpty() && base.healthFraction <= 0.1f)
		{
			Hurt(base.health, DamageType.Generic, this, useProtection: false);
		}
	}
}


public class ItemModOpenWrapped : ItemMod
{
	public GameObjectRef successEffect;

	public static Phrase open_wrapped_gift = new Phrase("open_wrapped_gift", "Unwrap");

	public static Phrase open_wrapped_gift_desc = new Phrase("open_wrapped_gift_desc", "Unwrap the gift and reveal its contents");

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (!(command == "open") || item.amount <= 0)
		{
			return;
		}
		Item slot = item.contents.GetSlot(0);
		if (slot != null)
		{
			int position = item.position;
			ItemContainer rootContainer = item.GetRootContainer();
			item.RemoveFromContainer();
			if (!slot.MoveToContainer(rootContainer, position))
			{
				player.GiveItem(slot);
			}
			item.Remove();
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}
}


public class ItemModWrap : ItemMod
{
	public GameObjectRef successEffect;

	public ItemDefinition wrappedDefinition;

	public static Phrase wrap_gift = new Phrase("wrap_gift", "Wrap Gift");

	public static Phrase wrap_gift_desc = new Phrase("wrap_gift_desc", "Wrap this item and turn it in to an openable gift");

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		if (!(command == "wrap") || item.amount <= 0)
		{
			return;
		}
		Item slot = item.contents.GetSlot(0);
		if (slot != null)
		{
			int position = item.position;
			ItemContainer parent = item.parent;
			item.RemoveFromContainer();
			Item item2 = ItemManager.Create(wrappedDefinition, 1, 0uL);
			item2.SetItemOwnership(player, ItemOwnershipPhrases.Wrap);
			slot.MoveToContainer(item2.contents);
			item2.MoveToContainer(parent, position);
			item.Remove();
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}
}


using UnityEngine;

public class ChristmasTree : StorageContainer
{
	public GameObject[] decorations;

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if ((Object)(object)((Component)item.info).GetComponent<ItemModXMasTreeDecoration>() == (Object)null)
		{
			return false;
		}
		foreach (Item item2 in base.inventory.itemList)
		{
			if ((Object)(object)item2.info == (Object)(object)item.info)
			{
				return false;
			}
		}
		return base.ItemFilter(item, targetSlot);
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		ItemModXMasTreeDecoration component = ((Component)item.info).GetComponent<ItemModXMasTreeDecoration>();
		if ((Object)(object)component != (Object)null)
		{
			SetFlag((Flags)component.flagsToChange, added);
		}
		base.OnItemAddedOrRemoved(item, added);
	}
}


public class ItemModXMasTreeDecoration : ItemMod
{
	public enum xmasFlags
	{
		pineCones = 0x80,
		candyCanes = 0x100,
		gingerbreadMen = 0x200,
		Tinsel = 0x400,
		Balls = 0x800,
		Star = 0x4000,
		Lights = 0x8000
	}

	public xmasFlags flagsToChange;
}


public enum xmasFlags
{
	pineCones = 0x80,
	candyCanes = 0x100,
	gingerbreadMen = 0x200,
	Tinsel = 0x400,
	Balls = 0x800,
	Star = 0x4000,
	Lights = 0x8000
}


using UnityEngine;

public class BunkerEntrance : BaseEntity, IMissionEntityListener
{
	public GameObjectRef portalPrefab;

	public GameObjectRef doorPrefab;

	public Transform portalSpawnPoint;

	public Transform doorSpawnPoint;

	public Door doorInstance;

	public BasePortal portalInstance;

	public override void ServerInit()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (portalPrefab.isValid)
		{
			portalInstance = ((Component)GameManager.server.CreateEntity(portalPrefab.resourcePath, portalSpawnPoint.position, portalSpawnPoint.rotation)).GetComponent<BasePortal>();
			portalInstance.SetParent(this, worldPositionStays: true);
			portalInstance.Spawn();
		}
		if (doorPrefab.isValid)
		{
			doorInstance = ((Component)GameManager.server.CreateEntity(doorPrefab.resourcePath, doorSpawnPoint.position, doorSpawnPoint.rotation)).GetComponent<Door>();
			doorInstance.SetParent(this, worldPositionStays: true);
			doorInstance.Spawn();
		}
	}

	public void MissionStarted(BasePlayer assignee, BaseMission.MissionInstance instance)
	{
	}

	public void MissionEnded(BasePlayer assignee, BaseMission.MissionInstance instance)
	{
	}
}


using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class DynamicDungeon : BaseEntity, IMissionEntityListener
{
	public Transform exitEntitySpawn;

	public GameObjectRef exitEntity;

	public string exitString;

	public MonumentNavMesh monumentNavMesh;

	private static List<DynamicDungeon> _dungeons = new List<DynamicDungeon>();

	public GameObjectRef portalPrefab;

	public Transform portalSpawnPoint;

	public BasePortal exitPortal;

	public GameObjectRef doorPrefab;

	public Transform doorSpawnPoint;

	public Door doorInstance;

	public static Vector3 nextDungeonPos = Vector3.zero;

	public static Vector3 dungeonStartPoint = Vector3.zero;

	public static float dungeonSpacing = 50f;

	public SpawnGroup[] spawnGroups;

	public bool AutoMergeAIZones = true;

	public static void AddDungeon(DynamicDungeon newDungeon)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		_dungeons.Add(newDungeon);
		Vector3 position = ((Component)newDungeon).transform.position;
		if (position.y >= nextDungeonPos.y)
		{
			nextDungeonPos = position + Vector3.up * dungeonSpacing;
		}
	}

	public static void RemoveDungeon(DynamicDungeon dungeon)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)dungeon).transform.position;
		if (_dungeons.Contains(dungeon))
		{
			_dungeons.Remove(dungeon);
		}
		nextDungeonPos = position;
	}

	public static Vector3 GetNextDungeonPoint()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (nextDungeonPos == Vector3.zero)
		{
			nextDungeonPos = Vector3.one * 700f;
		}
		return nextDungeonPos;
	}

	public IEnumerator UpdateNavMesh()
	{
		Debug.Log((object)"Dungeon Building navmesh");
		yield return ((MonoBehaviour)this).StartCoroutine(monumentNavMesh.UpdateNavMeshAndWait());
		Debug.Log((object)"Dunngeon done!");
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			SpawnGroup[] array = spawnGroups;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Clear();
			}
			if ((Object)(object)exitPortal != (Object)null)
			{
				exitPortal.Kill();
			}
			RemoveDungeon(this);
		}
		base.DestroyShared();
	}

	public override void ServerInit()
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		AddDungeon(this);
		if (portalPrefab.isValid)
		{
			exitPortal = ((Component)GameManager.server.CreateEntity(portalPrefab.resourcePath, portalSpawnPoint.position, portalSpawnPoint.rotation)).GetComponent<BasePortal>();
			exitPortal.SetParent(this, worldPositionStays: true);
			exitPortal.Spawn();
		}
		if (doorPrefab.isValid)
		{
			doorInstance = ((Component)GameManager.server.CreateEntity(doorPrefab.resourcePath, doorSpawnPoint.position, doorSpawnPoint.rotation)).GetComponent<Door>();
			doorInstance.SetParent(this, worldPositionStays: true);
			doorInstance.Spawn();
		}
		MergeAIZones();
		((MonoBehaviour)this).StartCoroutine(UpdateNavMesh());
	}

	private void MergeAIZones()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Expected O, but got Unknown
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (!AutoMergeAIZones)
		{
			return;
		}
		List<AIInformationZone> list = ((Component)this).GetComponentsInChildren<AIInformationZone>().ToList();
		foreach (AIInformationZone item in list)
		{
			item.AddInitialPoints();
		}
		GameObject val = new GameObject("AIZ");
		val.transform.position = ((Component)this).transform.position;
		AIInformationZone.Merge(list, val).ShouldSleepAI = false;
		val.transform.SetParent(((Component)this).transform);
	}

	public void MissionStarted(BasePlayer assignee, BaseMission.MissionInstance instance)
	{
		foreach (MissionEntity value in instance.missionEntities.Values)
		{
			BunkerEntrance component = ((Component)value).GetComponent<BunkerEntrance>();
			if ((Object)(object)component != (Object)null)
			{
				BasePortal portalInstance = component.portalInstance;
				if (Object.op_Implicit((Object)(object)portalInstance))
				{
					portalInstance.targetPortal = exitPortal;
					exitPortal.targetPortal = portalInstance;
					Debug.Log((object)"Dungeon portal linked...");
				}
			}
		}
	}

	public void MissionEnded(BasePlayer assignee, BaseMission.MissionInstance instance)
	{
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class HalloweenDungeon : BasePortal
{
	public GameObjectRef dungeonPrefab;

	public EntityRef<ProceduralDynamicDungeon> dungeonInstance;

	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float population = 0f;

	[ServerVar(Help = "How long each active dungeon should last before dying", ShowInAdminUI = true)]
	public static float lifetime = 600f;

	private float secondsUsed;

	private float timeAlive;

	public AnimationCurve radiationCurve;

	public Phrase collapsePhrase;

	public Phrase mountPhrase;

	private bool anyplayers_cached;

	private float nextPlayerCheckTime = float.NegativeInfinity;

	public virtual float GetLifetime()
	{
		return lifetime;
	}

	public override void Load(LoadInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.fromDisk && info.msg.ioEntity != null)
		{
			dungeonInstance.uid = info.msg.ioEntity.genericEntRef3;
			secondsUsed = info.msg.ioEntity.genericFloat1;
			timeAlive = info.msg.ioEntity.genericFloat2;
		}
	}

	public float GetLifeFraction()
	{
		return Mathf.Clamp01(secondsUsed / GetLifetime());
	}

	public void Update()
	{
		if (!base.isClient)
		{
			if (secondsUsed > 0f)
			{
				secondsUsed += Time.deltaTime;
			}
			timeAlive += Time.deltaTime;
			float lifeFraction = GetLifeFraction();
			if (dungeonInstance.IsValid(serverside: true))
			{
				ProceduralDynamicDungeon proceduralDynamicDungeon = dungeonInstance.Get(serverside: true);
				float num = radiationCurve.Evaluate(lifeFraction) * 80f;
				proceduralDynamicDungeon.exitRadiation.RadiationAmountOverride = Mathf.Clamp(num, 0f, float.PositiveInfinity);
			}
			if (lifeFraction >= 1f)
			{
				KillIfNoPlayers();
			}
			else if (timeAlive > 3600f && secondsUsed == 0f)
			{
				ClearAllEntitiesInRadius(80f);
				Kill();
			}
		}
	}

	public void KillIfNoPlayers()
	{
		if (!AnyPlayersInside())
		{
			ClearAllEntitiesInRadius(80f);
			Kill();
		}
	}

	public bool AnyPlayersInside()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		ProceduralDynamicDungeon proceduralDynamicDungeon = dungeonInstance.Get(serverside: true);
		if ((Object)(object)proceduralDynamicDungeon == (Object)null)
		{
			anyplayers_cached = false;
		}
		else if (Time.time > nextPlayerCheckTime)
		{
			nextPlayerCheckTime = Time.time + 10f;
			anyplayers_cached = BaseNetworkable.HasCloseConnections(((Component)proceduralDynamicDungeon).transform.position, 80f);
		}
		return anyplayers_cached;
	}

	private void ClearAllEntitiesInRadius(float radius)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		ProceduralDynamicDungeon proceduralDynamicDungeon = dungeonInstance.Get(serverside: true);
		if ((Object)(object)proceduralDynamicDungeon == (Object)null)
		{
			return;
		}
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(((Component)proceduralDynamicDungeon).transform.position, radius, list, -1, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (item.IsValid() && !item.IsDestroyed)
			{
				if (item is LootableCorpse lootableCorpse)
				{
					lootableCorpse.blockBagDrop = true;
				}
				item.Kill();
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.ioEntity == null)
		{
			info.msg.ioEntity = Pool.Get<IOEntity>();
		}
		info.msg.ioEntity.genericEntRef3 = dungeonInstance.uid;
		info.msg.ioEntity.genericFloat1 = secondsUsed;
		info.msg.ioEntity.genericFloat2 = timeAlive;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		timeAlive += Random.Range(0f, 60f);
	}

	public override void UsePortal(BasePlayer player)
	{
		if (GetLifeFraction() > 0.8f)
		{
			player.ShowToast(GameTip.Styles.Blue_Normal, collapsePhrase, false);
			return;
		}
		if (player.isMounted)
		{
			player.ShowToast(GameTip.Styles.Blue_Normal, mountPhrase, false);
			return;
		}
		if (secondsUsed == 0f)
		{
			secondsUsed = 1f;
		}
		base.UsePortal(player);
	}

	public override void Spawn()
	{
		base.Spawn();
	}

	public override void ServerInit()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			timeAlive = Random.Range(0f, 60f);
			SpawnSubEntities();
		}
		localEntryExitPos.DropToGround(alignToNormal: false, 10f);
		Transform transform = ((Component)localEntryExitPos).transform;
		transform.position += Vector3.up * 0.05f;
		((FacepunchBehaviour)this).Invoke((Action)CheckBlocked, 0.25f);
	}

	public void CheckBlocked()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		float num = 0.5f;
		float num2 = 1.8f;
		Vector3 position = localEntryExitPos.position;
		Vector3 val = position + new Vector3(0f, num, 0f);
		Vector3 val2 = position + new Vector3(0f, num2 - num, 0f);
		if (Physics.CheckCapsule(val, val2, num, 1537286401))
		{
			Kill();
		}
	}

	public static Vector3 GetDungeonSpawnPoint()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Floor(TerrainMeta.Size.x / 200f);
		float num2 = 1000f;
		Vector3 zero = Vector3.zero;
		zero.x = 0f - Mathf.Min(TerrainMeta.Size.x * 0.5f, 4000f) + 200f;
		zero.y = 1025f;
		zero.z = 0f - Mathf.Min(TerrainMeta.Size.z * 0.5f, 4000f) + 200f;
		_ = Vector3.zero;
		for (int i = 0; (float)i < num2; i++)
		{
			for (int j = 0; (float)j < num; j++)
			{
				Vector3 val = zero + new Vector3((float)j * 200f, (float)i * 100f, 0f);
				bool flag = false;
				foreach (ProceduralDynamicDungeon dungeon in ProceduralDynamicDungeon.dungeons)
				{
					if ((Object)(object)dungeon != (Object)null && dungeon.isServer && Vector3.Distance(((Component)dungeon).transform.position, val) < 10f)
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					return val;
				}
			}
		}
		return Vector3.zero;
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (dungeonInstance.IsValid(serverside: true))
		{
			dungeonInstance.Get(serverside: true).Kill();
		}
	}

	public void DelayedDestroy()
	{
		Kill();
	}

	public void SpawnSubEntities()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 dungeonSpawnPoint = GetDungeonSpawnPoint();
		if (dungeonSpawnPoint == Vector3.zero)
		{
			Debug.LogError((object)"No dungeon spawn point");
			((FacepunchBehaviour)this).Invoke((Action)DelayedDestroy, 5f);
			return;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(dungeonPrefab.resourcePath, dungeonSpawnPoint, Quaternion.identity);
		ProceduralDynamicDungeon component = ((Component)baseEntity).GetComponent<ProceduralDynamicDungeon>();
		component.mapOffset = ((Component)this).transform.position - dungeonSpawnPoint;
		baseEntity.Spawn();
		dungeonInstance.Set(component);
		BasePortal basePortal = (targetPortal = component.GetExitPortal());
		basePortal.targetPortal = this;
		LinkPortal();
		basePortal.LinkPortal();
	}
}


using System;
using UnityEngine;

public class XmasDungeon : HalloweenDungeon
{
	public const Flags HasPlayerOutside = Flags.Reserved7;

	public const Flags HasPlayerInside = Flags.Reserved8;

	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float xmaspopulation = 0f;

	[ServerVar(Help = "How long each active dungeon should last before dying", ShowInAdminUI = true)]
	public static float xmaslifetime = 1200f;

	[ServerVar(Help = "How far we detect players from our inside/outside", ShowInAdminUI = true)]
	public static float playerdetectrange = 30f;

	public override float GetLifetime()
	{
		return xmaslifetime;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)PlayerChecks, 1f, 1f);
	}

	public void PlayerChecks()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		ProceduralDynamicDungeon proceduralDynamicDungeon = dungeonInstance.Get(serverside: true);
		if ((Object)(object)proceduralDynamicDungeon == (Object)null)
		{
			return;
		}
		bool b = false;
		bool b2 = false;
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				float num = Vector3.Distance(((Component)current).transform.position, ((Component)this).transform.position);
				float num2 = Vector3.Distance(((Component)current).transform.position, ((Component)proceduralDynamicDungeon.GetExitPortal(serverSide: true)).transform.position);
				if (num < playerdetectrange)
				{
					b = true;
				}
				if (num2 < playerdetectrange * 2f)
				{
					b2 = true;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		SetFlag(Flags.Reserved8, b2);
		SetFlag(Flags.Reserved7, b);
		proceduralDynamicDungeon.SetFlag(Flags.Reserved7, b);
		proceduralDynamicDungeon.SetFlag(Flags.Reserved8, b2);
	}
}


using UnityEngine;

public class ProceduralDungeonCell : BaseMonoBehaviour
{
	public bool north;

	public bool east;

	public bool south;

	public bool west;

	public bool entrance;

	public bool hasSpawn;

	public Transform exitPointHack;

	public SpawnGroup[] spawnGroups;

	public RendererLOD[] mapRendererLods;

	public void Awake()
	{
		spawnGroups = ((Component)this).GetComponentsInChildren<SpawnGroup>();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class ProceduralDynamicDungeon : BaseEntity
{
	public int gridResolution = 6;

	public float gridSpacing = 12f;

	public bool[] grid;

	public List<GameObjectRef> cellPrefabReferences = new List<GameObjectRef>();

	public List<ProceduralDungeonCell> spawnedCells = new List<ProceduralDungeonCell>();

	public EnvironmentVolume envVolume;

	public MonumentNavMesh monumentNavMesh;

	public GameObjectRef exitPortalPrefab;

	private EntityRef<BasePortal> exitPortal;

	public TriggerRadiation exitRadiation;

	public uint seed;

	public uint baseseed;

	public Vector3 mapOffset = Vector3.zero;

	public static readonly List<ProceduralDynamicDungeon> dungeons = new List<ProceduralDynamicDungeon>();

	public ProceduralDungeonCell entranceHack;

	public override void InitShared()
	{
		base.InitShared();
		dungeons.Add(this);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		foreach (ProceduralDungeonCell spawnedCell in spawnedCells)
		{
			EntityFlag_Toggle[] componentsInChildren = ((Component)spawnedCell).GetComponentsInChildren<EntityFlag_Toggle>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].DoUpdate(this);
			}
		}
	}

	public BaseEntity GetExitPortal(bool serverSide)
	{
		return exitPortal.Get(serverSide);
	}

	public override void DestroyShared()
	{
		dungeons.Remove(this);
		RetireAllCells();
		base.DestroyShared();
	}

	public bool ContainsAnyPlayers()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		Bounds val = default(Bounds);
		((Bounds)(ref val))..ctor(((Component)this).transform.position, new Vector3((float)gridResolution * gridSpacing, 20f, (float)gridResolution * gridSpacing));
		for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
		{
			BasePlayer basePlayer = BasePlayer.activePlayerList[i];
			if (((Bounds)(ref val)).Contains(((Component)basePlayer).transform.position))
			{
				return true;
			}
		}
		for (int j = 0; j < BasePlayer.sleepingPlayerList.Count; j++)
		{
			BasePlayer basePlayer2 = BasePlayer.sleepingPlayerList[j];
			if (((Bounds)(ref val)).Contains(((Component)basePlayer2).transform.position))
			{
				return true;
			}
		}
		return false;
	}

	public void KillPlayers()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		Bounds val = default(Bounds);
		((Bounds)(ref val))..ctor(((Component)this).transform.position, new Vector3((float)gridResolution * gridSpacing, 20f, (float)gridResolution * gridSpacing));
		for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
		{
			BasePlayer basePlayer = BasePlayer.activePlayerList[i];
			if (((Bounds)(ref val)).Contains(((Component)basePlayer).transform.position))
			{
				basePlayer.Hurt(10000f, DamageType.Suicide, null, useProtection: false);
			}
		}
		for (int j = 0; j < BasePlayer.sleepingPlayerList.Count; j++)
		{
			BasePlayer basePlayer2 = BasePlayer.sleepingPlayerList[j];
			if (((Bounds)(ref val)).Contains(((Component)basePlayer2).transform.position))
			{
				basePlayer2.Hurt(10000f, DamageType.Suicide, null, useProtection: false);
			}
		}
	}

	internal override void DoServerDestroy()
	{
		KillPlayers();
		if (exitPortal.IsValid(serverside: true))
		{
			exitPortal.Get(serverside: true).Kill();
		}
		base.DoServerDestroy();
	}

	public override void ServerInit()
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		if (!Application.isLoadingSave)
		{
			baseseed = (seed = (uint)Random.Range(0, 12345567));
			int num = (int)seed;
			Debug.Log((object)("Spawning dungeon with seed :" + num));
		}
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			DoGeneration();
			BasePortal component = ((Component)GameManager.server.CreateEntity(exitPortalPrefab.resourcePath, entranceHack.exitPointHack.position, entranceHack.exitPointHack.rotation)).GetComponent<BasePortal>();
			component.Spawn();
			exitPortal.Set(component);
		}
	}

	public void DoGeneration()
	{
		GenerateGrid();
		CreateAIZ();
		if (base.isServer)
		{
			Debug.Log((object)"Server DoGeneration,calling routine update nav mesh");
			((MonoBehaviour)this).StartCoroutine(UpdateNavMesh());
		}
		((FacepunchBehaviour)this).Invoke((Action)InitSpawnGroups, 1f);
	}

	private void CreateAIZ()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		AIInformationZone aIInformationZone = ((Component)this).gameObject.AddComponent<AIInformationZone>();
		aIInformationZone.UseCalculatedCoverDistances = false;
		((Bounds)(ref aIInformationZone.bounds)).extents = new Vector3((float)gridResolution * gridSpacing * 0.75f, 10f, (float)gridResolution * gridSpacing * 0.75f);
		aIInformationZone.Init();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		DoGeneration();
	}

	public IEnumerator UpdateNavMesh()
	{
		Debug.Log((object)"Dungeon Building navmesh");
		yield return ((MonoBehaviour)this).StartCoroutine(monumentNavMesh.UpdateNavMeshAndWait());
		Debug.Log((object)"Dungeon done!");
	}

	public override void Save(SaveInfo info)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.proceduralDungeon == null)
		{
			info.msg.proceduralDungeon = Pool.Get<ProceduralDungeon>();
		}
		info.msg.proceduralDungeon.seed = baseseed;
		info.msg.proceduralDungeon.exitPortalID = exitPortal.uid;
		info.msg.proceduralDungeon.mapOffset = mapOffset;
	}

	public BasePortal GetExitPortal()
	{
		return exitPortal.Get(serverside: true);
	}

	public void InitSpawnGroups()
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		foreach (ProceduralDungeonCell spawnedCell in spawnedCells)
		{
			if (!((Object)(object)entranceHack != (Object)null) || !(Vector3.Distance(((Component)entranceHack).transform.position, ((Component)spawnedCell).transform.position) < 20f))
			{
				SpawnGroup[] spawnGroups = spawnedCell.spawnGroups;
				for (int i = 0; i < spawnGroups.Length; i++)
				{
					spawnGroups[i].Spawn();
				}
			}
		}
	}

	public void CleanupSpawnGroups()
	{
		foreach (ProceduralDungeonCell spawnedCell in spawnedCells)
		{
			SpawnGroup[] spawnGroups = spawnedCell.spawnGroups;
			for (int i = 0; i < spawnGroups.Length; i++)
			{
				spawnGroups[i].Clear();
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.proceduralDungeon != null)
		{
			baseseed = (seed = info.msg.proceduralDungeon.seed);
			exitPortal.uid = info.msg.proceduralDungeon.exitPortalID;
			mapOffset = info.msg.proceduralDungeon.mapOffset;
		}
	}

	[ContextMenu("Test Grid")]
	[ExecuteInEditMode]
	public void GenerateGrid()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position - new Vector3((float)gridResolution * gridSpacing * 0.5f, 0f, (float)gridResolution * gridSpacing * 0.5f);
		RetireAllCells();
		grid = new bool[gridResolution * gridResolution];
		for (int i = 0; i < grid.Length; i++)
		{
			grid[i] = SeedRandom.Range(ref seed, 0, 2) == 0;
		}
		SetEntrance(3, 0);
		for (int j = 0; j < gridResolution; j++)
		{
			for (int k = 0; k < gridResolution; k++)
			{
				if (GetGridState(j, k) && !HasPathToEntrance(j, k))
				{
					SetGridState(j, k, state: false);
				}
			}
		}
		for (int l = 0; l < gridResolution; l++)
		{
			for (int m = 0; m < gridResolution; m++)
			{
				if (!GetGridState(l, m))
				{
					continue;
				}
				bool gridState = GetGridState(l, m + 1);
				bool gridState2 = GetGridState(l, m - 1);
				bool gridState3 = GetGridState(l - 1, m);
				bool gridState4 = GetGridState(l + 1, m);
				bool flag = IsEntrance(l, m);
				GameObjectRef gameObjectRef = null;
				ProceduralDungeonCell proceduralDungeonCell = null;
				if ((Object)(object)proceduralDungeonCell == (Object)null)
				{
					foreach (GameObjectRef cellPrefabReference in cellPrefabReferences)
					{
						ProceduralDungeonCell component = cellPrefabReference.Get().GetComponent<ProceduralDungeonCell>();
						if (component.north == gridState && component.south == gridState2 && component.west == gridState3 && component.east == gridState4 && component.entrance == flag)
						{
							proceduralDungeonCell = component;
							gameObjectRef = cellPrefabReference;
							break;
						}
					}
				}
				if ((Object)(object)proceduralDungeonCell != (Object)null)
				{
					ProceduralDungeonCell proceduralDungeonCell2 = CellInstantiate(gameObjectRef.resourcePath);
					((Component)proceduralDungeonCell2).transform.position = val + new Vector3((float)l * gridSpacing, 0f, (float)m * gridSpacing);
					spawnedCells.Add(proceduralDungeonCell2);
					((Component)proceduralDungeonCell2).transform.SetParent(((Component)this).transform);
					if (proceduralDungeonCell2.entrance && (Object)(object)entranceHack == (Object)null)
					{
						entranceHack = proceduralDungeonCell2;
					}
				}
			}
		}
	}

	public ProceduralDungeonCell CellInstantiate(string path)
	{
		if (base.isServer)
		{
			return GameManager.server.CreatePrefab(path).GetComponent<ProceduralDungeonCell>();
		}
		return null;
	}

	public void RetireCell(GameObject cell)
	{
		if (!((Object)(object)cell == (Object)null) && base.isServer)
		{
			GameManager.server.Retire(cell);
		}
	}

	public void RetireAllCells()
	{
		if (base.isServer)
		{
			CleanupSpawnGroups();
		}
		for (int num = spawnedCells.Count - 1; num >= 0; num--)
		{
			ProceduralDungeonCell proceduralDungeonCell = spawnedCells[num];
			if (Object.op_Implicit((Object)(object)proceduralDungeonCell))
			{
				RetireCell(((Component)proceduralDungeonCell).gameObject);
			}
		}
		spawnedCells.Clear();
	}

	public bool CanSeeEntrance(int x, int y, ref List<int> checkedCells)
	{
		int gridIndex = GetGridIndex(x, y);
		if (checkedCells.Contains(gridIndex))
		{
			return false;
		}
		checkedCells.Add(gridIndex);
		if (!GetGridState(x, y))
		{
			return false;
		}
		if (IsEntrance(x, y))
		{
			return true;
		}
		bool num = CanSeeEntrance(x, y + 1, ref checkedCells);
		bool flag = CanSeeEntrance(x, y - 1, ref checkedCells);
		bool flag2 = CanSeeEntrance(x - 1, y, ref checkedCells);
		bool flag3 = CanSeeEntrance(x + 1, y, ref checkedCells);
		return num || flag3 || flag2 || flag;
	}

	public bool HasPathToEntrance(int x, int y)
	{
		List<int> checkedCells = new List<int>();
		bool result = CanSeeEntrance(x, y, ref checkedCells);
		checkedCells.Clear();
		return result;
	}

	public bool CanFindEntrance(int x, int y)
	{
		new List<int>();
		GetGridState(x, y + 1);
		GetGridState(x, y - 1);
		GetGridState(x - 1, y);
		GetGridState(x + 1, y);
		return true;
	}

	public bool IsEntrance(int x, int y)
	{
		return GetGridIndex(x, y) == GetEntranceIndex();
	}

	public int GetEntranceIndex()
	{
		return GetGridIndex(3, 0);
	}

	public void SetEntrance(int x, int y)
	{
		grid[GetGridIndex(x, y)] = true;
		grid[GetGridIndex(x, y + 1)] = true;
		grid[GetGridIndex(x - 1, y)] = false;
		grid[GetGridIndex(x + 1, y)] = false;
		grid[GetGridIndex(x, y + 2)] = true;
		grid[GetGridIndex(x + 1, y + 2)] = SeedRandom.Range(ref seed, 0, 1) == 1;
		grid[GetGridIndex(x + 2, y + 2)] = SeedRandom.Range(ref seed, 0, 1) == 1;
		grid[GetGridIndex(x, y + 3)] = true;
		grid[GetGridIndex(x, y + 4)] = true;
		grid[GetGridIndex(x - 1, y + 4)] = SeedRandom.Range(ref seed, 0, 1) == 1;
		grid[GetGridIndex(x - 2, y + 4)] = SeedRandom.Range(ref seed, 0, 1) == 1;
	}

	public void SetGridState(int x, int y, bool state)
	{
		int gridIndex = GetGridIndex(x, y);
		grid[gridIndex] = state;
	}

	public bool GetGridState(int x, int y)
	{
		if (GetGridIndex(x, y) >= grid.Length)
		{
			return false;
		}
		if (x < 0 || x >= gridResolution)
		{
			return false;
		}
		if (y < 0 || y >= gridResolution)
		{
			return false;
		}
		return grid[GetGridIndex(x, y)];
	}

	public int GetGridX(int index)
	{
		return index % gridResolution;
	}

	public int GetGridY(int index)
	{
		return Mathf.FloorToInt((float)index / (float)gridResolution);
	}

	public int GetGridIndex(int x, int y)
	{
		return y * gridResolution + x;
	}
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class CinematicScenePlaybackEntity : BaseEntity
{
	public Animator RootAnimator;

	public GameObjectRef CinematicUI;

	public float Duration = 10f;

	public GameObject DebugRoot;

	public bool ShowDebugRoot;

	public Transform LookPosition;

	public bool UseCinemachineBrain = true;

	public bool HidePlayerLegs = true;

	public float FadeToBlackTime = 0.5f;

	private EntityRef<BasePlayer> currentPlayer;

	public void SignalKillPlayer()
	{
		if (!base.isServer)
		{
			return;
		}
		BasePlayer basePlayer = currentPlayer.Get(serverside: true);
		if ((Object)(object)basePlayer != (Object)null)
		{
			TutorialIsland currentTutorialIsland = basePlayer.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				currentTutorialIsland.OnPlayerCompletedTutorial(basePlayer, isQuit: false, triggerAnalytics: true);
			}
		}
	}

	public void SignalFadeToBlack()
	{
	}

	public void AssignPlayer(BasePlayer bp)
	{
		currentPlayer.Set(bp);
		SendNetworkUpdate();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)Timeout, Duration);
	}

	private void Timeout()
	{
		BasePlayer basePlayer = currentPlayer.Get(serverside: true);
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.Respawn();
		}
		Kill();
	}

	public override void Save(SaveInfo info)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		BasePlayer basePlayer = currentPlayer.Get(serverside: true);
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (info.msg.cinematicEntity == null)
			{
				info.msg.cinematicEntity = Pool.Get<CinematicEntity>();
			}
			info.msg.cinematicEntity.targetPlayer = basePlayer.net.ID;
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		currentPlayer.Set(null);
		if (info.msg.cinematicEntity != null)
		{
			currentPlayer.uid = info.msg.cinematicEntity.targetPlayer;
		}
	}
}


using UnityEngine;

public class MenuHelp : MonoBehaviour
{
	public TutorialFullScreenHelpInfo[] AllHelp;

	public RectTransform CategoriesParent;

	public RectTransform ContentParent;

	public GameObjectRef CategoryWidget;

	public GameObjectRef HelpWidget;

	public TutorialFullScreenHelpInfo.MenuCategory StartingCategory;
}


using Rust.UI;
using UnityEngine;

public class MenuHelpCategory : MonoBehaviour
{
	public RustText CategoryText;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Video;

public class MenuHelpWidget : MonoBehaviour
{
	public RustText HelpText;

	public Image HelpImage;

	public VideoPlayer HelpVideo;

	public RawImage HelpVideoTexture;
}


using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Video;

[CreateAssetMenu(menuName = "Rust/Tutorials/Full Screen Help Info")]
public class TutorialFullScreenHelpInfo : ScriptableObject
{
	public enum MenuCategory
	{
		Movement,
		Crafting,
		Combat,
		Building
	}

	public static Phrase MovementPhrase = new Phrase("help_cat_movement", "MOVEMENT");

	public static Phrase CraftingPhrase = new Phrase("help_cat_crafting", "CRAFTING");

	public static Phrase CombatPhrase = new Phrase("help_cat_combat", "COMBAT");

	public static Phrase BuildingPhrase = new Phrase("help_cat_building", "BUILDING");

	public static Dictionary<MenuCategory, Phrase> CategoryPhraseLookup = new Dictionary<MenuCategory, Phrase>
	{
		{
			MenuCategory.Movement,
			MovementPhrase
		},
		{
			MenuCategory.Crafting,
			CraftingPhrase
		},
		{
			MenuCategory.Combat,
			CombatPhrase
		},
		{
			MenuCategory.Building,
			BuildingPhrase
		}
	};

	public MenuCategory Category;

	public int Priority;

	public TokenisedPhrase TextToDisplay;

	public Sprite StaticImage;

	public VideoClip VideoClip;
}


public enum MenuCategory
{
	Movement,
	Crafting,
	Combat,
	Building
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Tutorials/Help Set")]
public class TutorialMissionHelpSet : ScriptableObject
{
	public TutorialFullScreenHelpInfo[] Infos;
}


public class TriggerTutorialPrompt : TriggerBase
{
	public enum CustomCloseAction
	{
		None,
		OpenInventory,
		Sprint,
		Crouch
	}

	public TutorialFullScreenHelpInfo ToDisplay;

	public BaseMission RequiredMission;

	public int RequiredMissionStageActive = -1;

	public bool OnlyShowOnce;

	public CustomCloseAction CloseAction;

	public bool DebugConditions;

	public bool DeathDisplay;
}


public enum CustomCloseAction
{
	None,
	OpenInventory,
	Sprint,
	Crouch
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class TutorialBuildTarget : MonoBehaviour
{
	public BaseEntityRef TargetPrefab;

	public ItemDefinition TargetItemDef;

	public GameObject VisualObject;

	public Vector3 PhysCheckOffset = Vector3.zero;

	public bool Snap = true;

	public float MaxDistance = 0.5f;

	public BaseMission RequiredMission;

	public int RequiredMissionStage = -1;

	public float MaxValidAngle = 180f;

	public bool IsValid(Construction toConstruct, Construction.Target target, ref Construction.Placement placement)
	{
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		UpdateActive(target.player);
		if (!((Component)this).gameObject.activeInHierarchy)
		{
			return false;
		}
		if (!TargetPrefab.isValid || toConstruct.prefabID != TargetPrefab.Get().prefabID)
		{
			bool flag = false;
			if ((Object)(object)TargetItemDef != (Object)null && (Object)(object)target.player != (Object)null && (Object)(object)target.player.GetHeldEntity() != (Object)null && target.player.GetHeldEntity().GetItem() != null)
			{
				Item item = target.player.GetHeldEntity().GetItem();
				if ((Object)(object)item.info != (Object)null && (Object)(object)item.info.isRedirectOf == (Object)(object)TargetItemDef)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return false;
			}
		}
		if (Vector3.Distance(placement.position, ((Component)this).transform.position) < MaxDistance)
		{
			if (target.socket != null && MaxValidAngle < 180f && Vector3.Angle(((Component)this).transform.forward, placement.rotation * Vector3.forward) > MaxValidAngle)
			{
				return false;
			}
			if (Snap)
			{
				placement.position = ((Component)this).transform.position;
				placement.rotation = ((Component)this).transform.rotation;
			}
			return true;
		}
		return false;
	}

	public bool IsValid(BasePlayer player, Deployable deployable, Vector3 worldPosition, Quaternion worldRotation)
	{
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		UpdateActive(player);
		if (!((Component)this).gameObject.activeInHierarchy)
		{
			return false;
		}
		if (!TargetPrefab.isValid || deployable.prefabID != TargetPrefab.Get().prefabID)
		{
			bool flag = false;
			if ((Object)(object)TargetItemDef != (Object)null && (Object)(object)player != (Object)null && (Object)(object)player.GetHeldEntity() != (Object)null && player.GetHeldEntity().GetItem() != null)
			{
				Item item = player.GetHeldEntity().GetItem();
				if ((Object)(object)item.info != (Object)null && (Object)(object)item.info.isRedirectOf == (Object)(object)TargetItemDef)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return false;
			}
		}
		if (Vector3.Distance(worldPosition, ((Component)this).transform.position) < MaxDistance)
		{
			return true;
		}
		return false;
	}

	public void UpdateActive(BasePlayer p)
	{
		if ((Object)(object)p == (Object)null || !p.HasActiveMission())
		{
			((Component)this).gameObject.SetActive(false);
			return;
		}
		BaseMission.MissionInstance activeMissionInstance = p.GetActiveMissionInstance();
		bool flag = activeMissionInstance != null && activeMissionInstance.GetMission() == RequiredMission;
		if (flag && RequiredMissionStage >= 0 && !activeMissionInstance.objectiveStatuses[RequiredMissionStage].started)
		{
			flag = false;
		}
		((Component)this).gameObject.SetActive(flag && !HasTargetBeenBuilt());
	}

	private bool HasTargetBeenBuilt()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (!TargetPrefab.isValid)
		{
			return false;
		}
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(((Component)this).transform.position + PhysCheckOffset, 0.5f + MaxDistance, list, 1218652417, (QueryTriggerInteraction)2);
		bool flag = false;
		uint prefabID = TargetPrefab.Get().prefabID;
		foreach (BaseEntity item in list)
		{
			if (item.prefabID == prefabID)
			{
				flag = true;
				break;
			}
			if (item is Door)
			{
				foreach (BaseEntity child in item.children)
				{
					if (child.prefabID == prefabID)
					{
						flag = true;
						break;
					}
				}
			}
			if (flag)
			{
				break;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return flag;
	}
}


using System.Collections.Generic;
using UnityEngine;

public static class TutorialIslandSpawner
{
	public static List<Vector3> GetEdgeSpawnPoints(Vector3 start, Vector3 bounds, Vector3 cellSize, int loopCount, out Bounds worldBoundsMinusTutorialIslands)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < loopCount; i++)
		{
			list.AddRange(GetEdgeSpawnPoints(start, bounds, cellSize, i));
		}
		worldBoundsMinusTutorialIslands = new Bounds(start + bounds / 2f, bounds - cellSize * 2f * (float)loopCount);
		((Bounds)(ref worldBoundsMinusTutorialIslands)).size = new Vector3(((Bounds)(ref worldBoundsMinusTutorialIslands)).size.x, 1000f, ((Bounds)(ref worldBoundsMinusTutorialIslands)).size.z);
		return list;
	}

	public static List<Vector3> GetEdgeSpawnPoints(Vector3 start, Vector3 bounds, Vector3 cellSize, int curLoop)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		List<Vector3> list = new List<Vector3>();
		bounds -= cellSize * 2f * (float)curLoop;
		start += cellSize * (float)curLoop;
		Vector3 val = start + bounds - cellSize / 2f;
		int num = (int)(bounds.x / cellSize.x);
		int num2 = (int)(bounds.z / cellSize.z);
		Vector3 val2 = start + cellSize / 2f;
		for (int i = 0; i < num; i++)
		{
			list.Add(val2);
			list.Add(new Vector3(val2.x, 0f, val.z));
			val2 += new Vector3(cellSize.x, 0f, 0f);
		}
		val2 = start + cellSize / 2f + new Vector3(0f, 0f, cellSize.z);
		for (int j = 1; j < num2 - 1; j++)
		{
			list.Add(val2);
			list.Add(new Vector3(val.x, 0f, val2.z));
			val2 += new Vector3(0f, 0f, cellSize.z);
		}
		return list;
	}
}


public class TutorialIsland_MapMarker : MapMarker
{
}


using System;
using System.Collections.Generic;
using ConVar;
using UnityEngine;

[CreateAssetMenu(fileName = "NewConversation", menuName = "Rust/ConversationData", order = 1)]
public class ConversationData : ScriptableObject
{
	[Serializable]
	public class ConversationCondition
	{
		public enum ConditionType
		{
			None,
			HasHealth,
			HasScrap,
			ProviderBusy,
			MissionComplete,
			MissionAttempted,
			CanAccept,
			ConVar
		}

		public ConditionType conditionType;

		public uint conditionAmount;

		public string conditionString = "";

		public BaseMission conditionMission;

		public bool inverse;

		public string failedSpeechNode;

		public bool Passes(BasePlayer player, IConversationProvider provider)
		{
			bool flag = false;
			if (conditionType == ConditionType.HasScrap)
			{
				flag = player.inventory.GetAmount(ItemManager.FindItemDefinition("scrap").itemid) >= conditionAmount;
			}
			else if (conditionType == ConditionType.HasHealth)
			{
				flag = player.health >= (float)conditionAmount;
			}
			else if (conditionType == ConditionType.ProviderBusy)
			{
				flag = provider.ProviderBusy();
			}
			else if (conditionType == ConditionType.MissionComplete)
			{
				flag = player.HasCompletedMission(MissionID());
			}
			else if (conditionType == ConditionType.MissionAttempted)
			{
				flag = player.HasAttemptedMission(MissionID());
			}
			else if (conditionType == ConditionType.CanAccept)
			{
				flag = player.CanAcceptMission(MissionID());
			}
			else if (conditionType == ConditionType.ConVar)
			{
				flag = GetNPCConvar(conditionString);
			}
			if (!inverse)
			{
				return flag;
			}
			return !flag;
		}

		private static bool GetNPCConvar(string convarString)
		{
			return convarString switch
			{
				"vendor_minicopter_enabled" => NPC_ConVars.vendor_minicopter_enabled, 
				"vendor_attack_heli_enabled" => NPC_ConVars.vendor_attack_heli_enabled, 
				"vendor_scrap_heli_enabled" => NPC_ConVars.vendor_scrap_heli_enabled, 
				"vendor_hab_enabled" => NPC_ConVars.vendor_hab_enabled, 
				"vendor_rowboat_enabled" => NPC_ConVars.vendor_rowboat_enabled, 
				"vendor_rhib_enabled" => NPC_ConVars.vendor_rhib_enabled, 
				"vendor_sub_solo_enabled" => NPC_ConVars.vendor_sub_solo_enabled, 
				"vendor_sub_duo_enabled" => NPC_ConVars.vendor_sub_duo_enabled, 
				_ => false, 
			};
		}

		private uint MissionID()
		{
			if (!(conditionMission != null))
			{
				return conditionAmount;
			}
			return conditionMission.id;
		}
	}

	[Serializable]
	public class ResponseNode
	{
		public enum ActionType
		{
			Custom,
			None,
			AssignMission
		}

		public Phrase responseTextLocalized;

		public ConversationCondition[] conditions;

		public ActionType actionType;

		public string actionString;

		public BaseMission actionMission;

		public string resultingSpeechNode;

		public string responseText => responseTextLocalized.translated;

		public bool PassesConditions(BasePlayer player, IConversationProvider provider)
		{
			ConversationCondition[] array = conditions;
			for (int i = 0; i < array.Length; i++)
			{
				if (!array[i].Passes(player, provider))
				{
					return false;
				}
			}
			return true;
		}

		public string GetFailedSpeechNode(BasePlayer player, IConversationProvider provider)
		{
			ConversationCondition[] array = conditions;
			foreach (ConversationCondition conversationCondition in array)
			{
				if (!conversationCondition.Passes(player, provider))
				{
					return conversationCondition.failedSpeechNode;
				}
			}
			return "";
		}

		public string GetActionString()
		{
			switch (actionType)
			{
			case ActionType.None:
				return "";
			case ActionType.Custom:
				return actionString ?? "";
			case ActionType.AssignMission:
				if (!(actionMission != null) || string.IsNullOrWhiteSpace(actionMission.shortname))
				{
					return "";
				}
				return "assignmission " + actionMission.shortname;
			default:
				Debug.LogWarning((object)$"Cannot get conversation action string! Unhandled action type: {actionType}");
				return "";
			}
		}
	}

	[Serializable]
	public class SpeechNode
	{
		public string shortname;

		public Phrase statementLocalized;

		public ResponseNode[] responses;

		public Vector2 nodePosition;

		public string statement => statementLocalized.translated;
	}

	public string shortname;

	public Phrase providerNameTranslated;

	public Sprite providerIcon;

	public bool canBeCancelled = true;

	public SpeechNode[] speeches;

	public string providerName => providerNameTranslated.translated;

	public int GetSpeechNodeIndex(string speechShortName)
	{
		for (int i = 0; i < speeches.Length; i++)
		{
			if (speeches[i].shortname == speechShortName)
			{
				return i;
			}
		}
		return -1;
	}

	public void FindAllMissionAssignments(List<BaseMission> results)
	{
		SpeechNode[] array = speeches;
		for (int i = 0; i < array.Length; i++)
		{
			ResponseNode[] responses = array[i].responses;
			foreach (ResponseNode responseNode in responses)
			{
				if (responseNode.actionType == ResponseNode.ActionType.AssignMission && responseNode.actionMission != null)
				{
					results.Add(responseNode.actionMission);
				}
			}
		}
	}
}


using System;
using ConVar;

[Serializable]
public class ConversationCondition
{
	public enum ConditionType
	{
		None,
		HasHealth,
		HasScrap,
		ProviderBusy,
		MissionComplete,
		MissionAttempted,
		CanAccept,
		ConVar
	}

	public ConditionType conditionType;

	public uint conditionAmount;

	public string conditionString = "";

	public BaseMission conditionMission;

	public bool inverse;

	public string failedSpeechNode;

	public bool Passes(BasePlayer player, IConversationProvider provider)
	{
		bool flag = false;
		if (conditionType == ConditionType.HasScrap)
		{
			flag = player.inventory.GetAmount(ItemManager.FindItemDefinition("scrap").itemid) >= conditionAmount;
		}
		else if (conditionType == ConditionType.HasHealth)
		{
			flag = player.health >= (float)conditionAmount;
		}
		else if (conditionType == ConditionType.ProviderBusy)
		{
			flag = provider.ProviderBusy();
		}
		else if (conditionType == ConditionType.MissionComplete)
		{
			flag = player.HasCompletedMission(MissionID());
		}
		else if (conditionType == ConditionType.MissionAttempted)
		{
			flag = player.HasAttemptedMission(MissionID());
		}
		else if (conditionType == ConditionType.CanAccept)
		{
			flag = player.CanAcceptMission(MissionID());
		}
		else if (conditionType == ConditionType.ConVar)
		{
			flag = GetNPCConvar(conditionString);
		}
		if (!inverse)
		{
			return flag;
		}
		return !flag;
	}

	private static bool GetNPCConvar(string convarString)
	{
		return convarString switch
		{
			"vendor_minicopter_enabled" => NPC_ConVars.vendor_minicopter_enabled, 
			"vendor_attack_heli_enabled" => NPC_ConVars.vendor_attack_heli_enabled, 
			"vendor_scrap_heli_enabled" => NPC_ConVars.vendor_scrap_heli_enabled, 
			"vendor_hab_enabled" => NPC_ConVars.vendor_hab_enabled, 
			"vendor_rowboat_enabled" => NPC_ConVars.vendor_rowboat_enabled, 
			"vendor_rhib_enabled" => NPC_ConVars.vendor_rhib_enabled, 
			"vendor_sub_solo_enabled" => NPC_ConVars.vendor_sub_solo_enabled, 
			"vendor_sub_duo_enabled" => NPC_ConVars.vendor_sub_duo_enabled, 
			_ => false, 
		};
	}

	private uint MissionID()
	{
		if (!(conditionMission != null))
		{
			return conditionAmount;
		}
		return conditionMission.id;
	}
}


public enum ConditionType
{
	None,
	HasHealth,
	HasScrap,
	ProviderBusy,
	MissionComplete,
	MissionAttempted,
	CanAccept,
	ConVar
}


using System;
using UnityEngine;

[Serializable]
public class ResponseNode
{
	public enum ActionType
	{
		Custom,
		None,
		AssignMission
	}

	public Phrase responseTextLocalized;

	public ConversationCondition[] conditions;

	public ActionType actionType;

	public string actionString;

	public BaseMission actionMission;

	public string resultingSpeechNode;

	public string responseText => responseTextLocalized.translated;

	public bool PassesConditions(BasePlayer player, IConversationProvider provider)
	{
		ConversationCondition[] array = conditions;
		for (int i = 0; i < array.Length; i++)
		{
			if (!array[i].Passes(player, provider))
			{
				return false;
			}
		}
		return true;
	}

	public string GetFailedSpeechNode(BasePlayer player, IConversationProvider provider)
	{
		ConversationCondition[] array = conditions;
		foreach (ConversationCondition conversationCondition in array)
		{
			if (!conversationCondition.Passes(player, provider))
			{
				return conversationCondition.failedSpeechNode;
			}
		}
		return "";
	}

	public string GetActionString()
	{
		switch (actionType)
		{
		case ActionType.None:
			return "";
		case ActionType.Custom:
			return actionString ?? "";
		case ActionType.AssignMission:
			if (!(actionMission != null) || string.IsNullOrWhiteSpace(actionMission.shortname))
			{
				return "";
			}
			return "assignmission " + actionMission.shortname;
		default:
			Debug.LogWarning((object)$"Cannot get conversation action string! Unhandled action type: {actionType}");
			return "";
		}
	}
}


public enum ActionType
{
	Custom,
	None,
	AssignMission
}


using System;
using UnityEngine;

[Serializable]
public class SpeechNode
{
	public string shortname;

	public Phrase statementLocalized;

	public ResponseNode[] responses;

	public Vector2 nodePosition;

	public string statement => statementLocalized.translated;
}


using System;
using UnityEngine;

public class HorseSpawner : VehicleSpawner
{
	public float respawnDelay = 10f;

	public float respawnDelayVariance = 5f;

	public bool spawnForSale = true;

	protected override bool LogAnalytics => false;

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)RespawnHorse, Random.Range(0f, 4f), respawnDelay, respawnDelayVariance);
	}

	public override int GetOccupyLayer()
	{
		return 2048;
	}

	public void RespawnHorse()
	{
		if (GetVehicleOccupying() != null)
		{
			return;
		}
		IVehicleSpawnUser vehicleSpawnUser = SpawnVehicle(objectsToSpawn[0].prefabToSpawn.resourcePath, null);
		if (spawnForSale)
		{
			RidableHorse ridableHorse = vehicleSpawnUser as RidableHorse;
			if ((Object)(object)ridableHorse != (Object)null)
			{
				ridableHorse.SetForSale();
			}
		}
	}
}


public static class ConversationManager
{
}


using System.Collections.Generic;

public interface IConversationProvider
{
	void GetGenericMissionList(List<BaseMission> foundMissions);

	bool ProviderBusy();
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class NPCMissionProvider : NPCTalking, IMissionProvider
{
	public MissionManifest manifest;

	public GameObjectRef MarkerPrefab;

	public BaseMission[] FallbackMissions = new BaseMission[0];

	public NetworkableId ProviderID()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return net.ID;
	}

	public Vector3 ProviderPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public BaseEntity Entity()
	{
		return this;
	}

	public override void ServerInit()
	{
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (MarkerPrefab != null && MarkerPrefab.isValid)
		{
			List<BaseMission> list = Pool.Get<List<BaseMission>>();
			ConversationData[] array = conversations;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].FindAllMissionAssignments(list);
			}
			BaseMission[] fallbackMissions = FallbackMissions;
			foreach (BaseMission item in fallbackMissions)
			{
				list.Add(item);
			}
			if (list.Count > 0)
			{
				MapMarkerMissionProvider obj = GameManager.server.CreateEntity(MarkerPrefab.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation) as MapMarkerMissionProvider;
				obj.AssignMissions(list, GetProviderToken());
				obj.Spawn();
			}
			Pool.FreeUnmanaged<BaseMission.MissionInstance>(ref missions);
		}
	}

	private string GetProviderToken()
	{
		ConversationData[] array = conversations;
		int num = 0;
		if (num < array.Length)
		{
			return array[num].providerNameTranslated.token;
		}
		return string.Empty;
	}

	public override void OnConversationEnded(BasePlayer player)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		player.ProcessMissionEvent(BaseMission.MissionEventType.CONVERSATION, ProviderID(), 0f);
		base.OnConversationEnded(player);
	}

	public override void OnConversationStarted(BasePlayer speakingTo)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		speakingTo.ProcessMissionEvent(BaseMission.MissionEventType.CONVERSATION, ProviderID(), 1f);
		base.OnConversationStarted(speakingTo);
	}

	public bool ContainsSpeech(string speech)
	{
		ConversationData[] array = conversations;
		for (int i = 0; i < array.Length; i++)
		{
			ConversationData.SpeechNode[] speeches = array[i].speeches;
			for (int j = 0; j < speeches.Length; j++)
			{
				if (speeches[j].shortname == speech)
				{
					return true;
				}
			}
		}
		return false;
	}

	public string IntroOverride(string overrideSpeech)
	{
		if (!ContainsSpeech(overrideSpeech))
		{
			return "intro";
		}
		return overrideSpeech;
	}

	public override string GetConversationStartSpeech(BasePlayer player)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		string text = "";
		foreach (BaseMission.MissionInstance mission in player.missions)
		{
			if (mission.status == BaseMission.MissionStatus.Active)
			{
				text = IntroOverride("missionactive");
			}
			if (mission.status == BaseMission.MissionStatus.Completed && mission.providerID == ProviderID() && Time.time - mission.endTime < 5f)
			{
				text = IntroOverride("missionreturn");
			}
		}
		if (string.IsNullOrEmpty(text))
		{
			text = base.GetConversationStartSpeech(player);
		}
		return text;
	}

	public override void OnConversationAction(BasePlayer player, string action)
	{
		if (action.StartsWith("assignmission "))
		{
			int num = action.IndexOf(" ");
			BaseMission fromShortName = MissionManifest.GetFromShortName(action.Substring(num + 1));
			if (Object.op_Implicit((Object)(object)fromShortName))
			{
				BaseMission.AssignMission(player, this, fromShortName);
			}
		}
		base.OnConversationAction(player, action);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class NPCShopKeeper : NPCPlayer
{
	public EntityRef invisibleVendingMachineRef;

	public InvisibleVendingMachine machine;

	public bool canBeHurt;

	public float greetDir;

	public Vector3 initialFacingDir;

	public BasePlayer lastWavedAtPlayer;

	protected override string OverrideCorpseName => "Shopkeeper";

	public InvisibleVendingMachine GetVendingMachine()
	{
		if (!invisibleVendingMachineRef.IsValid(base.isServer))
		{
			return null;
		}
		return ((Component)invisibleVendingMachineRef.Get(base.isServer)).GetComponent<InvisibleVendingMachine>();
	}

	public override void UpdateProtectionFromClothing()
	{
	}

	protected override bool AllowRagdoll()
	{
		return canBeHurt;
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if ((Object)(object)invisibleVendingMachineRef.Get(base.isServer) != (Object)null && invisibleVendingMachineRef.Get(base.isServer) is InvisibleVendingMachine invisibleVendingMachine)
		{
			invisibleVendingMachine.SetAttachedNPC(null);
		}
	}

	public override void Hurt(HitInfo info)
	{
		if (canBeHurt)
		{
			base.Hurt(info);
		}
	}

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		Quaternion rotation = ((Component)this).transform.rotation;
		initialFacingDir = rotation * Vector3.forward;
		((FacepunchBehaviour)this).Invoke((Action)DelayedSleepEnd, 3f);
		SetAimDirection(rotation * Vector3.forward);
		((FacepunchBehaviour)this).InvokeRandomized((Action)Greeting, Random.Range(5f, 10f), 5f, Random.Range(0f, 2f));
	}

	public override void PostInitShared()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		base.PostInitShared();
		if (base.isServer)
		{
			if ((Object)(object)machine == (Object)null)
			{
				machine = InvisibleVendingMachine.GetMachineAtPosition(1f, ((Component)this).transform.position);
			}
			if (invisibleVendingMachineRef.IsValid(serverside: true) && (Object)(object)machine == (Object)null)
			{
				machine = GetVendingMachine();
				machine.SetAttachedNPC(this);
			}
			else if ((Object)(object)machine != (Object)null && !invisibleVendingMachineRef.IsValid(serverside: true))
			{
				invisibleVendingMachineRef.Set(machine);
				machine.SetAttachedNPC(this);
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.shopKeeper = Pool.Get<ShopKeeper>();
		info.msg.shopKeeper.vendingRef = invisibleVendingMachineRef.uid;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.shopKeeper != null)
		{
			invisibleVendingMachineRef.uid = info.msg.shopKeeper.vendingRef;
		}
	}

	public void DelayedSleepEnd()
	{
		EndSleeping();
	}

	public virtual void GreetPlayer(BasePlayer player)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player != (Object)null)
		{
			SignalBroadcast(Signal.Gesture, "wave");
			SetAimDirection(Vector3Ex.Direction2D(player.eyes.position, base.eyes.position));
			lastWavedAtPlayer = player;
		}
		else
		{
			SetAimDirection(initialFacingDir);
		}
	}

	public virtual void Greeting()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Vis.Entities(((Component)this).transform.position, 10f, list, 131072, (QueryTriggerInteraction)2);
		BasePlayer basePlayer = null;
		foreach (BasePlayer item in list)
		{
			if (!item.isClient && !item.IsNpc && !((Object)(object)item == (Object)(object)this) && item.IsVisible(base.eyes.position) && !((Object)(object)item == (Object)(object)lastWavedAtPlayer) && !(Vector3.Dot(Vector3Ex.Direction2D(item.eyes.position, base.eyes.position), initialFacingDir) < 0.2f))
			{
				basePlayer = item;
				break;
			}
		}
		if ((Object)(object)basePlayer == (Object)null && !list.Contains(lastWavedAtPlayer))
		{
			lastWavedAtPlayer = null;
		}
		if ((Object)(object)basePlayer != (Object)null)
		{
			SignalBroadcast(Signal.Gesture, "wave");
			SetAimDirection(Vector3Ex.Direction2D(basePlayer.eyes.position, base.eyes.position));
			lastWavedAtPlayer = basePlayer;
		}
		else
		{
			SetAimDirection(initialFacingDir);
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class NPCSimpleMissionProvider : NPCTalking, IMissionProvider
{
	public GameObjectRef MarkerPrefab;

	public Phrase NPCName = new Phrase("", "");

	public override void ServerInit()
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (MarkerPrefab != null && MarkerPrefab.isValid)
		{
			List<BaseMission> list = Pool.Get<List<BaseMission>>();
			GetAvailableMissions(list);
			if (list.Count > 0)
			{
				MapMarkerMissionProvider obj = GameManager.server.CreateEntity(MarkerPrefab.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation) as MapMarkerMissionProvider;
				obj.AssignMissions(list, NPCName.token);
				obj.Spawn();
			}
			Pool.FreeUnmanaged<BaseMission.MissionInstance>(ref missions);
		}
	}

	public override void OnConversationEnded(BasePlayer player)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		player.ProcessMissionEvent(BaseMission.MissionEventType.CONVERSATION, ProviderID(), 0f);
		base.OnConversationEnded(player);
	}

	public override void OnConversationStarted(BasePlayer speakingTo)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		speakingTo.ProcessMissionEvent(BaseMission.MissionEventType.CONVERSATION, ProviderID(), 1f);
		base.OnConversationStarted(speakingTo);
	}

	protected override void TryAssignMissionToPlayer(BaseMission mission, BasePlayer player)
	{
		base.TryAssignMissionToPlayer(mission, player);
		BaseMission.AssignMission(player, this, mission);
	}

	public override string GetConversationStartSpeech(BasePlayer player)
	{
		PooledList<BaseMission> val = Pool.Get<PooledList<BaseMission>>();
		try
		{
			GetAvailableMissions((List<BaseMission>)(object)val);
			bool flag = false;
			foreach (BaseMission item in (List<BaseMission>)(object)val)
			{
				if (player.CanAcceptMission(item))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return "intro_no_missions";
			}
			return base.GetConversationStartSpeech(player);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void GetGenericMissionList(List<BaseMission> foundMissions)
	{
		base.GetGenericMissionList(foundMissions);
		GetAvailableMissions(foundMissions);
	}

	private void GetAvailableMissions(List<BaseMission> foundMissions)
	{
		ScriptableObjectRef[] missionList = MissionManifest.Get().missionList;
		NPCSimpleMissionProvider nPCSimpleMissionProvider = default(NPCSimpleMissionProvider);
		for (int i = 0; i < missionList.Length; i++)
		{
			BaseMission baseMission = missionList[i].Get() as BaseMission;
			if (baseMission != null && baseMission.genericMissionProvider.isValid && baseMission.genericMissionProvider.Get().TryGetComponent<NPCSimpleMissionProvider>(ref nPCSimpleMissionProvider) && nPCSimpleMissionProvider.prefabID == prefabID)
			{
				foundMissions.Add(baseMission);
			}
		}
	}

	public NetworkableId ProviderID()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return net.ID;
	}

	public Vector3 ProviderPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public BaseEntity Entity()
	{
		return this;
	}
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public class VehicleVendor : NPCTalking
{
	public EntityRef spawnerRef;

	public VehicleSpawner vehicleSpawner;

	public override string GetConversationStartSpeech(BasePlayer player)
	{
		if (ProviderBusy())
		{
			return "startbusy";
		}
		return "intro";
	}

	public VehicleSpawner GetVehicleSpawner()
	{
		if (!spawnerRef.IsValid(base.isServer))
		{
			return null;
		}
		return ((Component)spawnerRef.Get(base.isServer)).GetComponent<VehicleSpawner>();
	}

	public override void UpdateFlags()
	{
		base.UpdateFlags();
		VehicleSpawner vehicleSpawner = GetVehicleSpawner();
		bool b = (Object)(object)vehicleSpawner != (Object)null && vehicleSpawner.IsPadOccupied();
		SetFlag(Flags.Reserved1, b);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (spawnerRef.IsValid(serverside: true) && (Object)(object)vehicleSpawner == (Object)null)
		{
			vehicleSpawner = GetVehicleSpawner();
		}
		else if ((Object)(object)vehicleSpawner != (Object)null && !spawnerRef.IsValid(serverside: true))
		{
			spawnerRef.Set(vehicleSpawner);
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.vehicleVendor = Pool.Get<VehicleVendor>();
		info.msg.vehicleVendor.spawnerRef = spawnerRef.uid;
	}

	public override ConversationData GetConversationFor(BasePlayer player)
	{
		return conversations[0];
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.vehicleVendor != null)
		{
			spawnerRef.id_cached = info.msg.vehicleVendor.spawnerRef;
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.Rust;
using UnityEngine;

public class VehicleSpawner : BaseEntity
{
	public interface IVehicleSpawnUser
	{
		string ShortPrefabName { get; }

		bool IsClient { get; }

		bool IsDestroyed { get; }

		void SetupOwner(BasePlayer owner, Vector3 newSafeAreaOrigin, float newSafeAreaRadius);

		bool IsDespawnEligable();

		IFuelSystem GetFuelSystem();

		int StartingFuelUnits();

		void Kill(DestroyMode mode);
	}

	[Serializable]
	public class SpawnPair
	{
		public string message;

		public GameObjectRef prefabToSpawn;
	}

	public float spawnNudgeRadius = 6f;

	public float cleanupRadius = 10f;

	public float occupyRadius = 5f;

	public SpawnPair[] objectsToSpawn;

	public Transform spawnOffset;

	public float safeRadius = 10f;

	protected virtual bool LogAnalytics => true;

	public virtual int GetOccupyLayer()
	{
		return 32768;
	}

	public IVehicleSpawnUser GetVehicleOccupying()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		IVehicleSpawnUser result = null;
		List<IVehicleSpawnUser> list = Pool.Get<List<IVehicleSpawnUser>>();
		Vis.Entities(((Component)spawnOffset).transform.position, occupyRadius, list, GetOccupyLayer(), (QueryTriggerInteraction)1);
		if (list.Count > 0)
		{
			result = list[0];
		}
		Pool.FreeUnmanaged<IVehicleSpawnUser>(ref list);
		return result;
	}

	public bool IsPadOccupied()
	{
		IVehicleSpawnUser vehicleOccupying = GetVehicleOccupying();
		if (vehicleOccupying != null)
		{
			return !vehicleOccupying.IsDespawnEligable();
		}
		return false;
	}

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		BasePlayer newOwner = null;
		NPCTalking component = ((Component)from).GetComponent<NPCTalking>();
		if (Object.op_Implicit((Object)(object)component))
		{
			newOwner = component.GetActionPlayer();
		}
		SpawnPair[] array = objectsToSpawn;
		foreach (SpawnPair spawnPair in array)
		{
			if (msg == spawnPair.message)
			{
				SpawnVehicle(spawnPair.prefabToSpawn.resourcePath, newOwner);
				break;
			}
		}
	}

	public IVehicleSpawnUser SpawnVehicle(string prefabToSpawn, BasePlayer newOwner)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		CleanupArea(cleanupRadius);
		NudgePlayersInRadius(spawnNudgeRadius);
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefabToSpawn, ((Component)spawnOffset).transform.position, ((Component)spawnOffset).transform.rotation);
		baseEntity.Spawn();
		IVehicleSpawnUser component = ((Component)baseEntity).GetComponent<IVehicleSpawnUser>();
		if ((Object)(object)newOwner != (Object)null)
		{
			component.SetupOwner(newOwner, ((Component)spawnOffset).transform.position, safeRadius);
		}
		VehicleSpawnPoint.AddStartingFuel(component);
		if ((Object)(object)newOwner != (Object)null)
		{
			Analytics.Azure.OnVehiclePurchased(newOwner, baseEntity);
		}
		return component;
	}

	public void CleanupArea(float radius)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		List<IVehicleSpawnUser> list = Pool.Get<List<IVehicleSpawnUser>>();
		Vis.Entities(((Component)spawnOffset).transform.position, radius, list, 32768, (QueryTriggerInteraction)2);
		foreach (IVehicleSpawnUser item in list)
		{
			if (!item.IsClient && !item.IsDestroyed)
			{
				item.Kill(DestroyMode.None);
			}
		}
		List<ServerGib> list2 = Pool.Get<List<ServerGib>>();
		Vis.Entities(((Component)spawnOffset).transform.position, radius, list2, -2147483647, (QueryTriggerInteraction)2);
		foreach (ServerGib item2 in list2)
		{
			if (!item2.isClient)
			{
				item2.Kill();
			}
		}
		Pool.FreeUnmanaged<IVehicleSpawnUser>(ref list);
		Pool.FreeUnmanaged<ServerGib>(ref list2);
	}

	public void NudgePlayersInRadius(float radius)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Vis.Entities(((Component)spawnOffset).transform.position, radius, list, 131072, (QueryTriggerInteraction)2);
		foreach (BasePlayer item in list)
		{
			if (!item.IsNpc && !item.isMounted && item.IsConnected)
			{
				Vector3 position = ((Component)spawnOffset).transform.position;
				position += Vector3Ex.Direction2D(((Component)item).transform.position, ((Component)spawnOffset).transform.position) * radius;
				position += Vector3.up * 0.1f;
				item.MovePosition(position);
				item.ClientRPC(RpcTarget.Player("ForcePositionTo", item), position);
			}
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}
}


using UnityEngine;

public interface IVehicleSpawnUser
{
	string ShortPrefabName { get; }

	bool IsClient { get; }

	bool IsDestroyed { get; }

	void SetupOwner(BasePlayer owner, Vector3 newSafeAreaOrigin, float newSafeAreaRadius);

	bool IsDespawnEligable();

	IFuelSystem GetFuelSystem();

	int StartingFuelUnits();

	void Kill(DestroyMode mode);
}


using System;

[Serializable]
public class SpawnPair
{
	public string message;

	public GameObjectRef prefabToSpawn;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust.Ai;
using UnityEngine;

public class BeeSwarmAI : BaseCombatEntity, ISplashable
{
	[Header("Settings")]
	public float moveSpeed = 2f;

	public float stopThreshold = 0.2f;

	[Header("Animation")]
	public float ReductionAmount;

	public float ReductionDuration;

	public float Frequency;

	public ParticleSystem PSystem;

	public Light OnFireLight;

	public ParticleSystemForceField AngerForceField;

	private Vector3 pastPosition = Vector3.one;

	private Vector3 velocity = Vector3.zero;

	public const Flags IsAngry = Flags.Reserved12;

	public const Flags IsDying = Flags.Reserved13;

	public const Flags HasTarget = Flags.Reserved14;

	[ServerVar(Help = "How long a swarm will stick around without a target")]
	public static float killWithoutTargetTime = 150f;

	[ServerVar(Help = "How far away fire has to be to set the swarm on fire")]
	public static float flameSettingDistance = 5.5f;

	[ServerVar(Help = "How much water a player needs to be in to be ignored")]
	public static float waterThreshold = 0.6f;

	[ServerVar(Help = "Range to find new targets")]
	public static float searchRange = 10f;

	[ServerVar(Help = "Range to leave current target alone (should be higher than search)")]
	public static float breakRange = 15f;

	[ServerVar]
	public static bool disable = false;

	public static Phrase BeeHelpPhrase = (Phrase)(object)new TokenisedPhrase("bee.tip.help", "Throw water, light a fire, or put on a hazmat suit to deal with the bees.");

	private BasePlayer targetPlayer;

	private TimeSince timeSinceHadTarget;

	private float targetPlayerLastWaterLevel;

	private bool hasCameFromAHive;

	private TimeSince timeSinceEgress;

	private Vector3 egressDirection = Vector3.one;

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
	}

	private void Update()
	{
		DoAI();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk)
		{
			Die();
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (base.isServer)
		{
			SetFlag(Flags.Reserved12, b: true);
		}
	}

	public override void ServerInit()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		SetFlag(Flags.Reserved12, b: true);
		timeSinceHadTarget = TimeSince.op_Implicit(0f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)ThinkAI, 0f, 0.25f);
	}

	public void SetHasCameFromAHive(bool cameFromHive)
	{
		hasCameFromAHive = cameFromHive;
	}

	public void SetTarget(BasePlayer ply)
	{
		targetPlayer = ply;
	}

	private void ThinkAI()
	{
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BeeSwarmAI.ThinkAI", 0);
		try
		{
			if (!HasFlag(Flags.Reserved12) || disable)
			{
				return;
			}
			if (hasCameFromAHive)
			{
				if (AI.ignoreplayers || !AI.think)
				{
					return;
				}
			}
			else if (AI.effectaiweapons && (AI.ignoreplayers || !AI.think))
			{
				return;
			}
			if ((Object)(object)targetPlayer == (Object)null)
			{
				targetPlayer = FindTarget(((Component)this).transform);
				if ((Object)(object)targetPlayer != (Object)null)
				{
					targetPlayerLastWaterLevel = targetPlayer.metabolism.wetness.value;
					timeSinceHadTarget = TimeSince.op_Implicit(0f);
					SetFlag(Flags.Reserved14, b: true);
				}
			}
			ValidateTarget();
			if (IsSmoke())
			{
				StartDie();
			}
			if (TimeSince.op_Implicit(timeSinceHadTarget) > killWithoutTargetTime)
			{
				StartDie();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool IsSmoke()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			SingletonComponent<SmokeGrenadeManager>.Instance.GetSmokeAround(((Component)this).transform.position, 5f, (List<BaseEntity>)(object)val);
			return val != null && ((List<BaseEntity>)(object)val).Count > 0;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void DoAI()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BeeSwarmAI.DoAI", 0);
		try
		{
			if (HasFlag(Flags.Reserved12) && !disable && !((Object)(object)targetPlayer == (Object)null))
			{
				SteerToPlayer();
				Quaternion val2 = Quaternion.LookRotation(((Component)targetPlayer).transform.position - ((Component)this).transform.position);
				((Component)this).transform.rotation = Quaternion.Slerp(((Component)this).transform.rotation, val2, Time.deltaTime * 2f);
				if ((Object)(object)targetPlayer != (Object)null)
				{
					targetPlayerLastWaterLevel = targetPlayer.metabolism.wetness.value;
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool IsFire(out Vector3 firePosition)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			SingletonComponent<NpcFireManager>.Instance.GetFiresAround(GetTargetEyesPosition(), 2f, (List<BaseEntity>)(object)val);
			firePosition = Vector3.zero;
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				if (!((Object)(object)item == (Object)null) && !item.IsDestroyed)
				{
					if (item is FlameThrower && Vector3.Distance(((Component)this).transform.position, ((Component)item).transform.position) < flameSettingDistance)
					{
						SetOnFire();
					}
					firePosition = ((Component)item).transform.position;
				}
			}
			return ((List<BaseEntity>)(object)val).Count > 0;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public Vector3 GetTargetEyesPosition()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		Vector3 zero = Vector3.zero;
		if ((Object)(object)targetPlayer.eyes == (Object)null)
		{
			return ((Component)targetPlayer).transform.position + new Vector3(0f, 1f, 0f);
		}
		return targetPlayer.eyes.position;
	}

	private void ValidateTarget()
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)targetPlayer == (Object)null || targetPlayer.InSafeZone() || targetPlayer.IsDead())
		{
			targetPlayer = null;
			SetFlag(Flags.Reserved14, b: false);
			return;
		}
		if (targetPlayer.metabolism.wetness.value > waterThreshold || TimeSince.op_Implicit(targetPlayer.TimeSinceLastWaterSplash) < 1f || targetPlayer.WaterFactor() > 0.5f)
		{
			targetPlayer = null;
			SetFlag(Flags.Reserved14, b: false);
			return;
		}
		if (Vector3.Distance(((Component)this).transform.position, ((Component)targetPlayer).transform.position) > breakRange)
		{
			targetPlayer = null;
			SetFlag(Flags.Reserved14, b: false);
			return;
		}
		Vector3 p = ((Component)targetPlayer).transform.position + new Vector3(0f, 1f, 0f);
		if (!GamePhysics.LineOfSight(((Component)this).transform.position, p, 1218519041))
		{
			targetPlayer = null;
			SetFlag(Flags.Reserved14, b: false);
		}
	}

	private void SetOnFire()
	{
		SetFlag(Flags.Reserved14, b: false);
		SetFlag(Flags.OnFire, b: true);
		((FacepunchBehaviour)this).Invoke((Action)StartDie, 1f);
	}

	private void SteerToPlayer()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 targetEyesPosition = GetTargetEyesPosition();
		Vector3 localTarget = ((Component)this).transform.InverseTransformPoint(targetEyesPosition);
		if (IsFire(out var firePosition))
		{
			float num = 5f;
			Vector3 val = ((Component)this).transform.position - firePosition;
			if (((Vector3)(ref val)).magnitude < num)
			{
				((Vector3)(ref val)).Normalize();
				Transform transform = ((Component)this).transform;
				transform.position += val * moveSpeed * Time.deltaTime;
				return;
			}
		}
		if (!(Mathf.Abs(((Vector3)(ref localTarget)).magnitude) <= stopThreshold))
		{
			SteerToTarget(localTarget);
		}
	}

	private void SteerToTarget(Vector3 localTarget)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Clamp(localTarget.y, -1f, 1f);
		float num2 = Mathf.Clamp(localTarget.x, -1f, 1f);
		Vector3 val = ((Component)this).transform.forward + ((Component)this).transform.right * num2 + ((Component)this).transform.up * num;
		((Vector3)(ref val)).Normalize();
		Transform transform = ((Component)this).transform;
		transform.position += val * moveSpeed * Time.deltaTime;
	}

	private void StartDie()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		SetFlag(Flags.Reserved12, b: false);
		SetFlag(Flags.Reserved13, b: true);
		timeSinceEgress = TimeSince.op_Implicit(0f);
		int num = ((Random.Range(0, 2) != 0) ? 1 : (-1));
		int num2 = ((Random.Range(0, 2) != 0) ? 1 : (-1));
		egressDirection = Vector3.right * (float)num + Vector3.forward * (float)num2;
		((FacepunchBehaviour)this).InvokeRepeating((Action)Egress, 0f, 0f);
	}

	public static BasePlayer FindTarget(Transform transform)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BeeSwarmAI.FindTarget", 0);
		try
		{
			PooledList<BasePlayer> val2 = Pool.Get<PooledList<BasePlayer>>();
			try
			{
				Query.Server.GetPlayersInSphere(transform.position, searchRange, (List<BasePlayer>)(object)val2, Query.DistanceCheckType.None, includeHumanoidNpcs: true);
				BasePlayer result = null;
				float num = float.MaxValue;
				foreach (BasePlayer item in (List<BasePlayer>)(object)val2)
				{
					if (SimpleAIMemory.PlayerIgnoreList.Contains(item) || item.InSafeZone() || item.IsInTutorial || item.IsDead() || item.metabolism.wetness.value > waterThreshold)
					{
						continue;
					}
					Vector3 p = ((Component)item).transform.position + new Vector3(0f, 1f, 0f);
					if (GamePhysics.LineOfSight(transform.position, p, 1218519041))
					{
						Vector3 val3 = ((Component)item).transform.position - transform.position;
						float sqrMagnitude = ((Vector3)(ref val3)).sqrMagnitude;
						if (sqrMagnitude < num)
						{
							num = sqrMagnitude;
							result = item;
						}
					}
				}
				return result;
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool IsUnderWater(BasePlayer ply)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Mathf.Abs(WaterSystem.OceanLevel - GetTargetEyesPosition().y) > 1f;
	}

	private void Egress()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.rotation = Quaternion.LookRotation(egressDirection);
		SteerToTarget(egressDirection);
		if (TimeSince.op_Implicit(timeSinceEgress) > 10f)
		{
			Die();
		}
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		if ((Object)(object)splashType == (Object)null || splashType.shortname == null)
		{
			return false;
		}
		if (HasFlag(Flags.Reserved13))
		{
			return false;
		}
		if (amount > 0)
		{
			return true;
		}
		return false;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		float num = base.health - 10f;
		if (num > 0f)
		{
			Hurt(num);
		}
		if (base.health <= 10f)
		{
			StartDie();
		}
		return amount;
	}
}


using UnityEngine;

public class ch47Animator : MonoBehaviour
{
	public Animator animator;

	public bool bottomDoorOpen;

	public bool landingGearDown;

	public bool leftDoorOpen;

	public bool rightDoorOpen;

	public bool rearDoorOpen;

	public bool rearDoorExtensionOpen;

	public Transform rearRotorBlade;

	public Transform frontRotorBlade;

	public float rotorBladeSpeed;

	public float wheelTurnSpeed;

	public float wheelTurnAngle;

	public SkinnedMeshRenderer[] blurredRotorBlades;

	public SkinnedMeshRenderer[] RotorBlades;

	private bool blurredRotorBladesEnabled;

	public float blurSpeedThreshold = 100f;

	private void Start()
	{
		EnableBlurredRotorBlades(enabled: false);
		animator.SetBool("rotorblade_stop", false);
	}

	public void SetDropDoorOpen(bool isOpen)
	{
		bottomDoorOpen = isOpen;
	}

	private void Update()
	{
		animator.SetBool("bottomdoor", bottomDoorOpen);
		animator.SetBool("landinggear", landingGearDown);
		animator.SetBool("leftdoor", leftDoorOpen);
		animator.SetBool("rightdoor", rightDoorOpen);
		animator.SetBool("reardoor", rearDoorOpen);
		animator.SetBool("reardoor_extension", rearDoorExtensionOpen);
		if (rotorBladeSpeed >= blurSpeedThreshold && !blurredRotorBladesEnabled)
		{
			EnableBlurredRotorBlades(enabled: true);
		}
		else if (rotorBladeSpeed < blurSpeedThreshold && blurredRotorBladesEnabled)
		{
			EnableBlurredRotorBlades(enabled: false);
		}
		if (rotorBladeSpeed <= 0f)
		{
			animator.SetBool("rotorblade_stop", true);
		}
		else
		{
			animator.SetBool("rotorblade_stop", false);
		}
	}

	private void LateUpdate()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.deltaTime * rotorBladeSpeed * 15f;
		Vector3 localEulerAngles = frontRotorBlade.localEulerAngles;
		frontRotorBlade.localEulerAngles = new Vector3(localEulerAngles.x, localEulerAngles.y + num, localEulerAngles.z);
		localEulerAngles = rearRotorBlade.localEulerAngles;
		rearRotorBlade.localEulerAngles = new Vector3(localEulerAngles.x, localEulerAngles.y - num, localEulerAngles.z);
	}

	private void EnableBlurredRotorBlades(bool enabled)
	{
		blurredRotorBladesEnabled = enabled;
		SkinnedMeshRenderer[] array = blurredRotorBlades;
		for (int i = 0; i < array.Length; i++)
		{
			((Renderer)array[i]).enabled = enabled;
		}
		array = RotorBlades;
		for (int i = 0; i < array.Length; i++)
		{
			((Renderer)array[i]).enabled = !enabled;
		}
	}
}


using Development.Attributes;
using UnityEngine;

[ResetStaticFields]
public class CH47FlightTest : MonoBehaviour
{
	public struct HelicopterInputState_t
	{
		public float throttle;

		public float roll;

		public float yaw;

		public float pitch;
	}

	public Rigidbody rigidBody;

	public float engineThrustMax;

	public Vector3 torqueScale;

	public Transform com;

	public Transform[] GroundPoints;

	public Transform[] GroundEffects;

	public float currentThrottle;

	public float avgThrust;

	public float liftDotMax = 0.75f;

	public Transform AIMoveTarget;

	private static float altitudeTolerance = 1f;

	public void Awake()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		rigidBody.centerOfMass = com.localPosition;
	}

	public HelicopterInputState_t GetHelicopterInputState()
	{
		HelicopterInputState_t result = default(HelicopterInputState_t);
		result.throttle = (Input.GetKey((KeyCode)119) ? 1f : 0f);
		result.throttle -= (Input.GetKey((KeyCode)115) ? 1f : 0f);
		result.pitch = Input.GetAxis("Mouse Y");
		result.roll = 0f - Input.GetAxis("Mouse X");
		result.yaw = (Input.GetKey((KeyCode)100) ? 1f : 0f);
		result.yaw -= (Input.GetKey((KeyCode)97) ? 1f : 0f);
		result.pitch = Mathf.RoundToInt(result.pitch);
		result.roll = Mathf.RoundToInt(result.roll);
		return result;
	}

	public HelicopterInputState_t GetAIInputState()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		HelicopterInputState_t result = default(HelicopterInputState_t);
		Vector3 val = Vector3.Cross(Vector3.up, ((Component)this).transform.right);
		float num = Vector3.Dot(Vector3.Cross(Vector3.up, val), Vector3Ex.Direction2D(AIMoveTarget.position, ((Component)this).transform.position));
		result.yaw = ((num < 0f) ? 1f : 0f);
		result.yaw -= ((num > 0f) ? 1f : 0f);
		float num2 = Vector3.Dot(Vector3.up, ((Component)this).transform.right);
		result.roll = ((num2 < 0f) ? 1f : 0f);
		result.roll -= ((num2 > 0f) ? 1f : 0f);
		float num3 = Vector3Ex.Distance2D(((Component)this).transform.position, AIMoveTarget.position);
		float num4 = Vector3.Dot(val, Vector3Ex.Direction2D(AIMoveTarget.position, ((Component)this).transform.position));
		float num5 = Vector3.Dot(Vector3.up, ((Component)this).transform.forward);
		if (num3 > 10f)
		{
			result.pitch = ((num4 > 0.8f) ? (-0.25f) : 0f);
			result.pitch -= ((num4 < -0.8f) ? (-0.25f) : 0f);
			if (num5 < -0.35f)
			{
				result.pitch = -1f;
			}
			else if (num5 > 0.35f)
			{
				result.pitch = 1f;
			}
		}
		else if (num5 < -0f)
		{
			result.pitch = -1f;
		}
		else if (num5 > 0f)
		{
			result.pitch = 1f;
		}
		float idealAltitude = GetIdealAltitude();
		float y = ((Component)this).transform.position.y;
		float num6 = 0f;
		num6 = ((y > idealAltitude + altitudeTolerance) ? (-1f) : ((y < idealAltitude - altitudeTolerance) ? 1f : ((!(num3 > 20f)) ? 0f : Mathf.Lerp(0f, 1f, num3 / 20f))));
		Debug.Log((object)("desiredThrottle : " + num6));
		result.throttle = num6 * 1f;
		return result;
	}

	public float GetIdealAltitude()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)AIMoveTarget).transform.position.y;
	}

	public void FixedUpdate()
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		HelicopterInputState_t aIInputState = GetAIInputState();
		currentThrottle = Mathf.Lerp(currentThrottle, aIInputState.throttle, 2f * Time.fixedDeltaTime);
		currentThrottle = Mathf.Clamp(currentThrottle, -0.2f, 1f);
		rigidBody.AddRelativeTorque(new Vector3(aIInputState.pitch * torqueScale.x, aIInputState.yaw * torqueScale.y, aIInputState.roll * torqueScale.z) * Time.fixedDeltaTime, (ForceMode)0);
		avgThrust = Mathf.Lerp(avgThrust, engineThrustMax * currentThrottle, Time.fixedDeltaTime);
		float num = Mathf.Clamp01(Vector3.Dot(((Component)this).transform.up, Vector3.up));
		float num2 = Mathf.InverseLerp(liftDotMax, 1f, num);
		Vector3 val = Vector3.up * engineThrustMax * 0.5f * currentThrottle * num2;
		Vector3 val2 = ((Component)this).transform.up - Vector3.up;
		Vector3 val3 = ((Vector3)(ref val2)).normalized * engineThrustMax * currentThrottle * (1f - num2);
		float num3 = rigidBody.mass * (0f - Physics.gravity.y);
		rigidBody.AddForce(((Component)this).transform.up * num3 * num2 * 0.99f, (ForceMode)0);
		rigidBody.AddForce(val, (ForceMode)0);
		rigidBody.AddForce(val3, (ForceMode)0);
		RaycastHit val5 = default(RaycastHit);
		for (int i = 0; i < GroundEffects.Length; i++)
		{
			Transform obj = GroundPoints[i];
			Transform val4 = GroundEffects[i];
			if (Physics.Raycast(((Component)obj).transform.position, Vector3.down, ref val5, 50f, 8388608))
			{
				((Component)val4).gameObject.SetActive(true);
				((Component)val4).transform.position = ((RaycastHit)(ref val5)).point + new Vector3(0f, 1f, 0f);
			}
			else
			{
				((Component)val4).gameObject.SetActive(false);
			}
		}
	}

	public void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.yellow;
		Gizmos.DrawSphere(((Component)AIMoveTarget).transform.position, 1f);
		Vector3 val = Vector3.Cross(((Component)this).transform.right, Vector3.up);
		Vector3 val2 = Vector3.Cross(val, Vector3.up);
		Gizmos.color = Color.blue;
		Gizmos.DrawLine(((Component)this).transform.position, ((Component)this).transform.position + val * 10f);
		Gizmos.color = Color.red;
		Gizmos.DrawLine(((Component)this).transform.position, ((Component)this).transform.position + val2 * 10f);
	}
}


public struct HelicopterInputState_t
{
	public float throttle;

	public float roll;

	public float yaw;

	public float pitch;
}


using UnityEngine;

public class rottest : MonoBehaviour
{
	public Transform turretBase;

	public Vector3 aimDir;

	private void Start()
	{
	}

	private void Update()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		aimDir = new Vector3(0f, 45f * Mathf.Sin(Time.time * 6f), 0f);
		UpdateAiming();
	}

	public void UpdateAiming()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		if (!(aimDir == Vector3.zero))
		{
			Quaternion val = Quaternion.Euler(0f, aimDir.y, 0f);
			if (((Component)this).transform.localRotation != val)
			{
				((Component)this).transform.localRotation = Quaternion.Lerp(((Component)this).transform.localRotation, val, Time.deltaTime * 8f);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class BasePath : MonoBehaviour, IAIPath
{
	public List<BasePathNode> nodes;

	public List<PathInterestNode> interestZones;

	public List<PathSpeedZone> speedZones;

	private float? cachedLength;

	public IEnumerable<IAIPathInterestNode> InterestNodes => interestZones;

	public IEnumerable<IAIPathSpeedZone> SpeedZones => speedZones;

	private void AddChildren()
	{
		if (nodes != null)
		{
			nodes.Clear();
			nodes.AddRange(((Component)this).GetComponentsInChildren<BasePathNode>());
			foreach (BasePathNode node in nodes)
			{
				node.Path = this;
			}
		}
		if (interestZones != null)
		{
			interestZones.Clear();
			interestZones.AddRange(((Component)this).GetComponentsInChildren<PathInterestNode>());
		}
		if (speedZones != null)
		{
			speedZones.Clear();
			speedZones.AddRange(((Component)this).GetComponentsInChildren<PathSpeedZone>());
		}
	}

	private void ClearChildren()
	{
		if (nodes != null)
		{
			foreach (BasePathNode node in nodes)
			{
				node.linked.Clear();
			}
		}
		nodes.Clear();
	}

	public static void AutoGenerateLinks(BasePath path, float maxRange = -1f)
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		path.AddChildren();
		foreach (BasePathNode node in path.nodes)
		{
			if (node.linked == null)
			{
				node.linked = new List<BasePathNode>();
			}
			else
			{
				node.linked.Clear();
			}
			foreach (BasePathNode node2 in path.nodes)
			{
				if (!((Object)(object)node == (Object)(object)node2) && (maxRange == -1f || !(Vector3.Distance(node.Position, node2.Position) > maxRange)) && GamePhysics.LineOfSight(node.Position, node2.Position, 1503731969) && GamePhysics.LineOfSight(node2.Position, node.Position, 1503731969))
				{
					node.linked.Add(node2);
				}
			}
		}
	}

	public void GetNodesNear(Vector3 point, ref List<IAIPathNode> nearNodes, float dist = 10f)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		foreach (BasePathNode node in nodes)
		{
			Vector3 val = Vector3Ex.XZ(point) - Vector3Ex.XZ(node.Position);
			if (((Vector3)(ref val)).sqrMagnitude <= dist * dist)
			{
				nearNodes.Add(node);
			}
		}
	}

	public IAIPathNode GetClosestToPoint(Vector3 point)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		IAIPathNode result = nodes[0];
		float num = float.PositiveInfinity;
		foreach (BasePathNode node in nodes)
		{
			if (!((Object)(object)node == (Object)null) && !((Object)(object)((Component)node).transform == (Object)null))
			{
				Vector3 val = point - node.Position;
				float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
				if (sqrMagnitude < num)
				{
					num = sqrMagnitude;
					result = node;
				}
			}
		}
		return result;
	}

	public IAIPathInterestNode GetRandomInterestNodeAwayFrom(Vector3 from, float dist = 10f)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		PathInterestNode pathInterestNode = null;
		int num = 0;
		while ((Object)(object)pathInterestNode == (Object)null && num < 20)
		{
			pathInterestNode = interestZones[Random.Range(0, interestZones.Count)];
			Vector3 val = ((Component)pathInterestNode).transform.position - from;
			if (!(((Vector3)(ref val)).sqrMagnitude < dist * dist))
			{
				break;
			}
			pathInterestNode = null;
			num++;
		}
		if ((Object)(object)pathInterestNode == (Object)null)
		{
			Debug.LogError((object)"REturning default interest zone");
			pathInterestNode = interestZones[0];
		}
		return pathInterestNode;
	}

	public void AddInterestNode(IAIPathInterestNode interestZone)
	{
		throw new NotImplementedException();
	}

	public void AddSpeedZone(IAIPathSpeedZone speedZone)
	{
		throw new NotImplementedException();
	}

	public float GetPathLength()
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (cachedLength.HasValue)
		{
			return cachedLength.Value;
		}
		if (nodes.Count < 2)
		{
			return 0f;
		}
		cachedLength = 0f;
		for (int i = 0; i < nodes.Count - 1; i++)
		{
			cachedLength += Vector3.Distance(nodes[i].Position, nodes[i + 1].Position);
		}
		return cachedLength.Value;
	}

	public float GetPathProgress(Vector3 position)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		for (int i = 0; i < nodes.Count - 1; i++)
		{
			Vector3 position2 = nodes[i].Position;
			Vector3 position3 = nodes[i + 1].Position;
			Vector3 val = position2 - position3;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			val = position2 - position;
			Vector3 normalized2 = ((Vector3)(ref val)).normalized;
			val = position3 - position;
			Vector3 normalized3 = ((Vector3)(ref val)).normalized;
			float num2 = Vector3.Distance(position2, position3);
			float num3 = Vector3.Dot(normalized, normalized2);
			float num4 = Vector3.Dot(-normalized, normalized3);
			if (i == 0 && num3 < 0f)
			{
				return 0f;
			}
			if (num3 > -0.1f && num4 > -0.1f)
			{
				float num5 = Vector3.Distance(position2, position);
				return num + num5;
			}
			num += num2;
		}
		return GetPathLength();
	}

	public void GetPointInPath(float normalisedTime, out Vector3 pos, out Vector3 rotation)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		normalisedTime = Mathf.Clamp01(normalisedTime);
		pos = Vector3.zero;
		rotation = Vector3.zero;
		if (normalisedTime >= 1f)
		{
			List<BasePathNode> list = nodes;
			pos = list[list.Count - 1].Position;
			return;
		}
		float num = GetPathLength() * normalisedTime;
		float num2 = 0f;
		for (int i = 0; i < nodes.Count - 1; i++)
		{
			float num3 = Vector3.Distance(nodes[i].Position, nodes[i + 1].Position);
			if (num2 + num3 > num)
			{
				float num4 = (num - num2) / num3;
				pos = Vector3.Lerp(nodes[i].Position, nodes[i + 1].Position, num4);
				Vector3 val = nodes[i + 1].Position - nodes[i].Position;
				rotation = ((Vector3)(ref val)).normalized;
				break;
			}
			num2 += num3;
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class BasePathNode : MonoBehaviour, IAIPathNode
{
	public BasePath Path;

	public List<BasePathNode> linked;

	public float maxVelocityOnApproach = -1f;

	public bool straightaway;

	public Vector3 Position => ((Component)this).transform.position;

	public bool Straightaway => straightaway;

	public IEnumerable<IAIPathNode> Linked => linked;

	public bool IsValid()
	{
		return (Object)(object)((Component)this).transform != (Object)null;
	}

	public void AddLink(IAIPathNode link)
	{
		throw new NotImplementedException();
	}

	public void OnDrawGizmosSelected()
	{
	}
}


using UnityEngine;

public class BradleyMoveTest : MonoBehaviour
{
	public WheelCollider[] leftWheels;

	public WheelCollider[] rightWheels;

	public float moveForceMax = 2000f;

	public float brakeForce = 100f;

	public float throttle = 1f;

	public float turnForce = 2000f;

	public float sideStiffnessMax = 1f;

	public float sideStiffnessMin = 0.5f;

	public Transform centerOfMass;

	public float turning;

	public bool brake;

	public Rigidbody myRigidBody;

	public Vector3 destination;

	public float stoppingDist = 5f;

	public GameObject followTest;

	public void Awake()
	{
		Initialize();
	}

	public void Initialize()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		myRigidBody.centerOfMass = centerOfMass.localPosition;
		destination = ((Component)this).transform.position;
	}

	public void SetDestination(Vector3 dest)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		destination = dest;
	}

	public void FixedUpdate()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		Vector3 velocity = myRigidBody.velocity;
		SetDestination(followTest.transform.position);
		float num = Vector3.Distance(((Component)this).transform.position, destination);
		if (num > stoppingDist)
		{
			Vector3 zero = Vector3.zero;
			float num2 = Vector3.Dot(zero, ((Component)this).transform.right);
			float num3 = Vector3.Dot(zero, -((Component)this).transform.right);
			float num4 = Vector3.Dot(zero, ((Component)this).transform.right);
			if (Vector3.Dot(zero, -((Component)this).transform.forward) > num4)
			{
				if (num2 >= num3)
				{
					turning = 1f;
				}
				else
				{
					turning = -1f;
				}
			}
			else
			{
				turning = num4;
			}
			throttle = Mathf.InverseLerp(stoppingDist, 30f, num);
		}
		throttle = Mathf.Clamp(throttle, -1f, 1f);
		float num5 = throttle;
		float num6 = throttle;
		if (turning > 0f)
		{
			num6 = 0f - turning;
			num5 = turning;
		}
		else if (turning < 0f)
		{
			num5 = turning;
			num6 = turning * -1f;
		}
		ApplyBrakes(brake ? 1f : 0f);
		float num7 = throttle;
		num5 = Mathf.Clamp(num5 + num7, -1f, 1f);
		num6 = Mathf.Clamp(num6 + num7, -1f, 1f);
		AdjustFriction();
		float num8 = Mathf.InverseLerp(3f, 1f, ((Vector3)(ref velocity)).magnitude * Mathf.Abs(Vector3.Dot(((Vector3)(ref velocity)).normalized, ((Component)this).transform.forward)));
		float torqueAmount = Mathf.Lerp(moveForceMax, turnForce, num8);
		SetMotorTorque(num5, rightSide: false, torqueAmount);
		SetMotorTorque(num6, rightSide: true, torqueAmount);
	}

	public void ApplyBrakes(float amount)
	{
		ApplyBrakeTorque(amount, rightSide: true);
		ApplyBrakeTorque(amount, rightSide: false);
	}

	public float GetMotorTorque(bool rightSide)
	{
		float num = 0f;
		WheelCollider[] array = (rightSide ? rightWheels : leftWheels);
		foreach (WheelCollider val in array)
		{
			num += val.motorTorque;
		}
		return num / (float)rightWheels.Length;
	}

	public void SetMotorTorque(float newThrottle, bool rightSide, float torqueAmount)
	{
		newThrottle = Mathf.Clamp(newThrottle, -1f, 1f);
		float motorTorque = torqueAmount * newThrottle;
		WheelCollider[] array = (rightSide ? rightWheels : leftWheels);
		for (int i = 0; i < array.Length; i++)
		{
			array[i].motorTorque = motorTorque;
		}
	}

	public void ApplyBrakeTorque(float amount, bool rightSide)
	{
		WheelCollider[] array = (rightSide ? rightWheels : leftWheels);
		for (int i = 0; i < array.Length; i++)
		{
			array[i].brakeTorque = brakeForce * amount;
		}
	}

	public void AdjustFriction()
	{
	}
}


using System;
using ConVar;
using Rust;
using UnityEngine;

public class BradleySpawner : MonoBehaviour, IServerComponent
{
	public BasePath path;

	public GameObjectRef bradleyPrefab;

	[NonSerialized]
	public BradleyAPC spawned;

	public bool initialSpawn;

	public float minRespawnTimeMinutes = 5f;

	public float maxRespawnTimeMinutes = 5f;

	public static BradleySpawner singleton;

	private bool pendingRespawn;

	public void Start()
	{
		singleton = this;
		((MonoBehaviour)this).Invoke("DelayedStart", 3f);
	}

	public void DelayedStart()
	{
		if (initialSpawn)
		{
			DoRespawn();
		}
		((MonoBehaviour)this).InvokeRepeating("CheckIfRespawnNeeded", 0f, 5f);
	}

	public void CheckIfRespawnNeeded()
	{
		if (!pendingRespawn && ((Object)(object)spawned == (Object)null || !spawned.IsAlive()))
		{
			ScheduleRespawn();
		}
	}

	public void ScheduleRespawn()
	{
		((MonoBehaviour)this).CancelInvoke("DoRespawn");
		((MonoBehaviour)this).Invoke("DoRespawn", Random.Range(Bradley.respawnDelayMinutes - Bradley.respawnDelayVariance, Bradley.respawnDelayMinutes + Bradley.respawnDelayVariance) * 60f);
		pendingRespawn = true;
	}

	public void DoRespawn()
	{
		if (!Application.isLoading && !Application.isLoadingSave)
		{
			SpawnBradley();
		}
		pendingRespawn = false;
	}

	public void SpawnBradley()
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)spawned != (Object)null)
		{
			Debug.LogWarning((object)"Bradley attempting to spawn but one already exists!");
		}
		else if (Bradley.enabled)
		{
			Vector3 position = ((Component)path.interestZones[Random.Range(0, path.interestZones.Count)]).transform.position;
			BaseEntity baseEntity = GameManager.server.CreateEntity(bradleyPrefab.resourcePath, position);
			BradleyAPC component = ((Component)baseEntity).GetComponent<BradleyAPC>();
			component.RoadSpawned = false;
			if (Object.op_Implicit((Object)(object)component))
			{
				baseEntity.Spawn();
				component.InstallPatrolPath(path);
			}
			else
			{
				baseEntity.Kill();
			}
			Vector3 val = position;
			Debug.Log((object)("BradleyAPC Spawned at :" + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString()));
			spawned = component;
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public interface IAIPath
{
	IEnumerable<IAIPathSpeedZone> SpeedZones { get; }

	IEnumerable<IAIPathInterestNode> InterestNodes { get; }

	void GetNodesNear(Vector3 point, ref List<IAIPathNode> nearNodes, float dist = 10f);

	IAIPathInterestNode GetRandomInterestNodeAwayFrom(Vector3 from, float dist = 10f);

	IAIPathNode GetClosestToPoint(Vector3 point);

	void AddInterestNode(IAIPathInterestNode interestNode);

	void AddSpeedZone(IAIPathSpeedZone speedZone);
}


using System.Collections.Generic;
using UnityEngine;

public interface IAIPathNode
{
	Vector3 Position { get; }

	bool Straightaway { get; }

	IEnumerable<IAIPathNode> Linked { get; }

	bool IsValid();

	void AddLink(IAIPathNode link);
}


public interface IAIPathSpeedZone
{
	OBB WorldSpaceBounds();

	float GetMaxSpeed();
}


using UnityEngine;

public interface IAIPathInterestNode
{
	Vector3 Position { get; }

	float NextVisitTime { get; set; }
}


using UnityEngine;

public class PathInterestNode : MonoBehaviour, IAIPathInterestNode
{
	public Vector3 Position => ((Component)this).transform.position;

	public float NextVisitTime { get; set; }

	public void OnDrawGizmos()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = new Color(0f, 1f, 1f, 0.5f);
		Gizmos.DrawSphere(((Component)this).transform.position, 0.5f);
	}
}


using UnityEngine;

public class PathSpeedZone : MonoBehaviour, IAIPathSpeedZone
{
	public Bounds bounds;

	public OBB obbBounds;

	public float maxVelocityPerSec = 5f;

	public OBB WorldSpaceBounds()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		return new OBB(((Component)this).transform.position, ((Component)this).transform.lossyScale, ((Component)this).transform.rotation, bounds);
	}

	public float GetMaxSpeed()
	{
		return maxVelocityPerSec;
	}
}


using UnityEngine;

public class RuntimeInterestNode : IAIPathInterestNode
{
	public Vector3 Position { get; set; }

	public float NextVisitTime { get; set; }

	public RuntimeInterestNode(Vector3 position)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		Position = position;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class RuntimePath : IAIPath
{
	private List<IAIPathSpeedZone> speedZones = new List<IAIPathSpeedZone>();

	private List<IAIPathInterestNode> interestNodes = new List<IAIPathInterestNode>();

	public IAIPathNode[] Nodes { get; set; } = new IAIPathNode[0];

	public IEnumerable<IAIPathSpeedZone> SpeedZones => speedZones;

	public IEnumerable<IAIPathInterestNode> InterestNodes => interestNodes;

	public IAIPathNode GetClosestToPoint(Vector3 point)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		IAIPathNode result = Nodes[0];
		float num = float.PositiveInfinity;
		IAIPathNode[] nodes = Nodes;
		foreach (IAIPathNode iAIPathNode in nodes)
		{
			Vector3 val = point - iAIPathNode.Position;
			float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
			if (sqrMagnitude < num)
			{
				num = sqrMagnitude;
				result = iAIPathNode;
			}
		}
		return result;
	}

	public void GetNodesNear(Vector3 point, ref List<IAIPathNode> nearNodes, float dist = 10f)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		IAIPathNode[] nodes = Nodes;
		foreach (IAIPathNode iAIPathNode in nodes)
		{
			Vector3 val = Vector3Ex.XZ(point) - Vector3Ex.XZ(iAIPathNode.Position);
			if (((Vector3)(ref val)).sqrMagnitude <= dist * dist)
			{
				nearNodes.Add(iAIPathNode);
			}
		}
	}

	public IAIPathInterestNode GetRandomInterestNodeAwayFrom(Vector3 from, float dist = 10f)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		IAIPathInterestNode iAIPathInterestNode = null;
		int num = 0;
		while (iAIPathInterestNode == null && num < 20)
		{
			iAIPathInterestNode = interestNodes[Random.Range(0, interestNodes.Count)];
			Vector3 val = iAIPathInterestNode.Position - from;
			if (!(((Vector3)(ref val)).sqrMagnitude < dist * dist))
			{
				break;
			}
			iAIPathInterestNode = null;
			num++;
		}
		if (iAIPathInterestNode == null)
		{
			Debug.LogError((object)"Returning default interest zone");
			iAIPathInterestNode = interestNodes[0];
		}
		return iAIPathInterestNode;
	}

	public void AddInterestNode(IAIPathInterestNode interestNode)
	{
		if (!interestNodes.Contains(interestNode))
		{
			interestNodes.Add(interestNode);
		}
	}

	public void AddSpeedZone(IAIPathSpeedZone speedZone)
	{
		if (!speedZones.Contains(speedZone))
		{
			speedZones.Add(speedZone);
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class RuntimePathNode : IAIPathNode
{
	private HashSet<IAIPathNode> linked = new HashSet<IAIPathNode>();

	public Vector3 Position { get; set; }

	public bool Straightaway { get; set; }

	public IEnumerable<IAIPathNode> Linked => linked;

	public RuntimePathNode(Vector3 position)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		Position = position;
	}

	public bool IsValid()
	{
		return true;
	}

	public void AddLink(IAIPathNode link)
	{
		linked.Add(link);
	}
}


public class RuntimeSpeedZone : IAIPathSpeedZone
{
	public OBB worldOBBBounds;

	public float maxVelocityPerSec = 5f;

	public float GetMaxSpeed()
	{
		return maxVelocityPerSec;
	}

	public OBB WorldSpaceBounds()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return worldOBBBounds;
	}
}


using System;
using UnityEngine;

public class TreadAnimator : MonoBehaviour, IClientComponent
{
	[Serializable]
	public struct TreadRenderer
	{
		public Renderer Renderer;

		public int leftMaterialIndex;

		public int rightMaterialIndex;
	}

	public Animator mainBodyAnimator;

	public Transform[] wheelBones;

	public Vector3[] vecShocksOffsetPosition;

	public Vector3[] wheelBoneOrigin;

	public float wheelBoneDistMax = 0.26f;

	public TreadRenderer[] treadRenderers;

	public TreadEffects treadEffects;

	public float traceThickness = 0.25f;

	public float heightFudge = 0.13f;

	public bool useWheelYOrigin;

	public Vector2 treadTextureDirection = new Vector2(1f, 0f);

	public bool isMetallic;

	public float angularTreadConstant = 0.05f;

	public float treadConstant = 0.14f;

	public float wheelSpinConstant = 80f;

	public float traceLineMin = 0.55f;

	public float traceLineMax = 0.79f;

	public float maxShockDist = 0.26f;
}


using System;
using UnityEngine;

[Serializable]
public struct TreadRenderer
{
	public Renderer Renderer;

	public int leftMaterialIndex;

	public int rightMaterialIndex;
}


using UnityEngine;

public class TreadEffects : MonoBehaviour
{
	public ParticleSystem[] rearTreadDirt;

	public ParticleSystem[] rearTreadSmoke;

	public ParticleSystem[] middleTreadSmoke;
}


using System;

public class NPCPlayerCorpse : PlayerCorpse
{
	private bool lootEnabled;

	public override float GetRemovalTime()
	{
		return 600f;
	}

	public override bool CanLoot()
	{
		return lootEnabled;
	}

	public void SetLootableIn(float when)
	{
		((FacepunchBehaviour)this).Invoke((Action)EnableLooting, when);
	}

	public void EnableLooting()
	{
		lootEnabled = true;
	}

	protected override bool CanLootContainer(ItemContainer c, int index)
	{
		if (index == 1 || index == 2)
		{
			return false;
		}
		return base.CanLootContainer(c, index);
	}

	protected override void PreDropItems()
	{
		base.PreDropItems();
		if (containers != null && containers.Length >= 2)
		{
			containers[1].Clear();
			ItemManager.DoRemoves();
		}
	}
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class TutorialNPC : NPCMissionProvider
{
	public ConversationData StartConversation;

	public ConversationData MissionInProgressConversation;

	public ConversationData ForageCompleteConversation;

	public ConversationData FirstBuildCompleteConversation;

	public ConversationData SecondBuildCompleteConversation;

	public ConversationData PrepareForCombatConversation;

	public ConversationData BuildKayakConversation;

	public ConversationData SetSailConversation;

	public ConversationData PostBearAttackConversation;

	public BaseMission PostBearAttackMission;

	public GameObjectRef BearRoarSfx;

	public Transform BearRoarSpawnPos;

	[Range(0f, 1f)]
	public float TalkingHeadIkWeight = 0.7f;

	public RuntimeAnimatorController CustomAnimator;

	private static readonly int IsTalking = Animator.StringToHash("IsTalking");

	private const uint FORAGE_MISSION = 2265941643u;

	private const uint BUILD1_MISSION = 1726435040u;

	private const uint BUILD2_MISSION = 1928576498u;

	private const uint COOK_MISSION = 3432877204u;

	private const uint KILL_BEAR_MISSION = 3396482113u;

	private const uint CRAFT_KAYAK_MISSION = 3197637569u;

	public const uint BEAR_ATTACK_RESPAWN_MISSION = 3156134108u;

	private BasePlayer playerToKill;

	protected override bool CanTalkTo(BasePlayer bp)
	{
		if (base.CanTalkTo(bp))
		{
			return !bp.HasPendingFollowupMission;
		}
		return false;
	}

	public override ConversationData GetConversationFor(BasePlayer player)
	{
		if (player.HasActiveMission())
		{
			return MissionInProgressConversation;
		}
		if (player.HasCompletedMission(3197637569u))
		{
			return SetSailConversation;
		}
		if (player.HasCompletedMission(3396482113u))
		{
			return BuildKayakConversation;
		}
		if (player.HasCompletedMission(3156134108u))
		{
			return PostBearAttackConversation;
		}
		if (player.HasCompletedMission(3432877204u))
		{
			return PrepareForCombatConversation;
		}
		if (player.HasCompletedMission(1928576498u))
		{
			return SecondBuildCompleteConversation;
		}
		if (player.HasCompletedMission(1726435040u))
		{
			return FirstBuildCompleteConversation;
		}
		if (player.HasCompletedMission(2265941643u))
		{
			return ForageCompleteConversation;
		}
		return StartConversation;
	}

	public override void OnConversationAction(BasePlayer player, string action)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		base.OnConversationAction(player, action);
		if (action == "playbearsfx")
		{
			Effect.server.Run(BearRoarSfx.resourcePath, BearRoarSpawnPos.position);
			playerToKill = player;
			((FacepunchBehaviour)this).Invoke((Action)WaitAndKill, 2f);
		}
		else if (action == "cleardeathmarker")
		{
			player.ClearDeathMarker(sendToClient: true);
		}
	}

	private void WaitAndKill()
	{
		if ((Object)(object)playerToKill != (Object)null)
		{
			DeathInfo val = Pool.Get<DeathInfo>();
			val.attackerName = "bear";
			if (playerToKill.IsGod())
			{
				playerToKill.net.connection.info.Set("global.god", "0");
			}
			playerToKill.SetOverrideDeathBlow(val);
			playerToKill.Hurt(9999f);
			if (PostBearAttackMission != null)
			{
				BaseMission.AssignMission(playerToKill, this, PostBearAttackMission);
			}
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		EndSleeping();
	}

	public override void GreetPlayer(BasePlayer player)
	{
	}

	public override void Greeting()
	{
	}

	public override void OnConversationStarted(BasePlayer speakingTo)
	{
		base.OnConversationStarted(speakingTo);
		SetFlag(Flags.Busy, b: true);
	}

	public override void OnConversationEnded(BasePlayer player)
	{
		base.OnConversationEnded(player);
		SetFlag(Flags.Busy, b: false);
	}
}


using UnityEngine;

public class NaturalBeehive : LootContainer
{
	public GameObjectRef beeSwarmPrefab;

	public override void OnDied(HitInfo info)
	{
		SpawnSwarm();
		base.OnDied(info);
	}

	private void SpawnSwarm()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity(beeSwarmPrefab.resourcePath, ((Component)this).transform.position, Quaternion.identity);
		BeeSwarmAI beeSwarmAI = baseEntity as BeeSwarmAI;
		if (Object.op_Implicit((Object)(object)beeSwarmAI))
		{
			beeSwarmAI.SetHasCameFromAHive(cameFromHive: true);
		}
		baseEntity.Spawn();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk && base.isServer)
		{
			Kill();
		}
	}

	public override float BoundsPadding()
	{
		return 1f;
	}
}


using System.Collections.Generic;
using ProtoBuf;
using UnityEngine;

public class ItemModSetFrequency : ItemMod
{
	private struct ItemTime
	{
		public Item TargetItem;

		public TimeSince TimeSinceEdit;
	}

	public static readonly Phrase RfOffTitle = new Phrase("rf_off", "Disable RF");

	public static readonly Phrase RfOffDesc = new Phrase("rf_off_desc", " Disable detonation via RF");

	public static readonly Phrase RfOnTitle = new Phrase("rf_on", "Enable RF");

	public static readonly Phrase RfOnDesc = new Phrase("rf_on_desc", " Enable detonation via RF");

	public GameObjectRef frequencyPanelPrefab;

	public bool allowArmDisarm;

	public bool onlyFrequency;

	public int defaultFrequency = -1;

	public bool loseConditionOnChange;

	private static List<ItemTime> itemsOnCooldown = new List<ItemTime>();

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		base.ServerCommand(item, command, player);
		if (command.Contains("SetFrequency"))
		{
			if (itemsOnCooldown.Count > 0 && onlyFrequency)
			{
				for (int num = itemsOnCooldown.Count - 1; num >= 0; num--)
				{
					if (itemsOnCooldown[num].TargetItem == item && TimeSince.op_Implicit(itemsOnCooldown[num].TimeSinceEdit) < 2f)
					{
						return;
					}
					if (TimeSince.op_Implicit(itemsOnCooldown[num].TimeSinceEdit) > 2f)
					{
						itemsOnCooldown.RemoveAt(num);
					}
				}
			}
			int result = 0;
			if (int.TryParse(command.Substring(command.IndexOf(":") + 1), out result))
			{
				BaseEntity heldEntity = item.GetHeldEntity();
				if ((Object)(object)heldEntity != (Object)null && heldEntity is Detonator detonator)
				{
					detonator.ServerSetFrequency(player, result);
				}
				else
				{
					item.instanceData.dataInt = result;
					if (loseConditionOnChange)
					{
						item.LoseCondition(item.maxCondition * 0.01f);
					}
					item.MarkDirty();
				}
				if (onlyFrequency)
				{
					itemsOnCooldown.Add(new ItemTime
					{
						TargetItem = item,
						TimeSinceEdit = TimeSince.op_Implicit(0f)
					});
				}
			}
			else
			{
				Debug.Log((object)"Parse fuckup");
			}
		}
		if (!onlyFrequency)
		{
			if (command == "rf_on")
			{
				item.SetFlag(Item.Flag.IsOn, b: true);
				item.MarkDirty();
			}
			else if (command == "rf_off")
			{
				item.SetFlag(Item.Flag.IsOn, b: false);
				item.MarkDirty();
			}
		}
	}

	public override void OnItemCreated(Item item)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Expected O, but got Unknown
		if (item.instanceData == null)
		{
			item.instanceData = new InstanceData();
			item.instanceData.ShouldPool = false;
			item.instanceData.dataInt = defaultFrequency;
		}
	}
}


private struct ItemTime
{
	public Item TargetItem;

	public TimeSince TimeSinceEdit;
}


public class ItemModCompass : ItemMod
{
}


using System;
using UnityEngine;

public class FishingBobber : BaseCombatEntity
{
	public Transform centerOfMass;

	public Rigidbody myRigidBody;

	public Transform lineAttachPoint;

	public Transform bobberRoot;

	public const Flags CaughtFish = Flags.Reserved1;

	public float HorizontalMoveSpeed = 1f;

	public float PullAwayMoveSpeed = 1f;

	public float SidewaysInputForce = 1f;

	public float ReelInMoveSpeed = 1f;

	private float bobberForcePingPong;

	private Vector3 initialDirection;

	private Vector3 initialTargetPosition;

	private Vector3 spawnPosition;

	private TimeSince initialCastTime;

	private float initialDistance;

	public float TireAmount { get; private set; }

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		myRigidBody.centerOfMass = centerOfMass.localPosition;
		base.ServerInit();
	}

	public void InitialiseBobber(BasePlayer forPlayer, WaterBody forBody, Vector3 targetPos, float maxDuration)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		initialDirection = Vector3Ex.WithY(forPlayer.eyes.HeadForward(), 0f);
		spawnPosition = ((Component)this).transform.position;
		initialTargetPosition = targetPos;
		initialCastTime = TimeSince.op_Implicit(0f);
		initialDistance = Vector3.Distance(targetPos, Vector3Ex.WithY(((Component)forPlayer).transform.position, targetPos.y));
		((FacepunchBehaviour)this).InvokeRepeating((Action)ProcessInitialCast, 0f, 0f);
		((FacepunchBehaviour)this).Invoke((Action)TimeOutBobber, maxDuration);
	}

	private void ProcessInitialCast()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float num = 0.8f;
		if (TimeSince.op_Implicit(initialCastTime) > num)
		{
			((Component)this).transform.position = initialTargetPosition;
			((FacepunchBehaviour)this).CancelInvoke((Action)ProcessInitialCast);
			return;
		}
		float num2 = TimeSince.op_Implicit(initialCastTime) / num;
		Vector3 val = Vector3.Lerp(spawnPosition, initialTargetPosition, 0.5f);
		val.y += 1.5f;
		Vector3 position = Vector3.Lerp(Vector3.Lerp(spawnPosition, val, num2), Vector3.Lerp(val, initialTargetPosition, num2), num2);
		((Component)this).transform.position = position;
	}

	public void ServerMovementUpdate(bool inputLeft, bool inputRight, bool inputBack, ref BaseFishingRod.FishState state, Vector3 playerPos, ItemModFishable fishableModifier, float playerStrengthModifier)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = playerPos - ((Component)this).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = Vector3.zero;
		bobberForcePingPong = Mathf.Clamp(Mathf.PingPong(Time.time, 2f), 0.2f, 2f);
		if (state.Contains(BaseFishingRod.FishState.PullingLeft))
		{
			val2 = ((Component)this).transform.right * (Time.deltaTime * HorizontalMoveSpeed * bobberForcePingPong * fishableModifier.MoveMultiplier * (inputRight ? 0.5f : 1f));
		}
		if (state.Contains(BaseFishingRod.FishState.PullingRight))
		{
			val2 = -((Component)this).transform.right * (Time.deltaTime * HorizontalMoveSpeed * bobberForcePingPong * fishableModifier.MoveMultiplier * (inputLeft ? 0.5f : 1f));
		}
		if (state.Contains(BaseFishingRod.FishState.PullingBack))
		{
			val2 += -((Component)this).transform.forward * (Time.deltaTime * PullAwayMoveSpeed * bobberForcePingPong * fishableModifier.MoveMultiplier * (inputBack ? 0.5f : 1f));
		}
		if (inputLeft || inputRight)
		{
			float num = 0.8f;
			if ((inputLeft && state == BaseFishingRod.FishState.PullingRight) || (inputRight && state == BaseFishingRod.FishState.PullingLeft))
			{
				num = 1.25f;
			}
			TireAmount += Time.deltaTime * num;
		}
		else
		{
			TireAmount -= Time.deltaTime * 0.1f;
		}
		if (inputLeft && !state.Contains(BaseFishingRod.FishState.PullingLeft))
		{
			val2 += ((Component)this).transform.right * (Time.deltaTime * SidewaysInputForce * playerStrengthModifier);
		}
		else if (inputRight && !state.Contains(BaseFishingRod.FishState.PullingRight))
		{
			val2 += -((Component)this).transform.right * (Time.deltaTime * SidewaysInputForce * playerStrengthModifier);
		}
		if (inputBack)
		{
			float num2 = Mathx.RemapValClamped(TireAmount, 0f, 5f, 1f, 3f);
			val2 += normalized * (ReelInMoveSpeed * fishableModifier.ReelInSpeedMultiplier * num2 * Time.deltaTime * playerStrengthModifier);
		}
		((Component)this).transform.LookAt(Vector3Ex.WithY(playerPos, ((Component)this).transform.position.y));
		Vector3 val3 = ((Component)this).transform.position + val2;
		if (!IsDirectionValid(val3, ((Vector3)(ref val2)).magnitude, playerPos))
		{
			state = state.FlipHorizontal();
		}
		else
		{
			((Component)this).transform.position = val3;
		}
	}

	private bool IsDirectionValid(Vector3 pos, float checkLength, Vector3 playerPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - playerPos;
		if (Vector3.Angle(Vector3Ex.WithY(((Vector3)(ref val)).normalized, 0f), initialDirection) > 60f)
		{
			return false;
		}
		Vector3 position = ((Component)this).transform.position;
		val = pos - position;
		if (GamePhysics.Trace(new Ray(position, ((Vector3)(ref val)).normalized), 0.1f, out var _, checkLength, 1084293377, (QueryTriggerInteraction)0))
		{
			return false;
		}
		return true;
	}

	private void TimeOutBobber()
	{
		Kill();
	}
}


using UnityEngine;

public class BobberPreview : MonoBehaviour
{
	public Material ValidMaterial;

	public Material InvalidMaterial;

	public MeshRenderer TargetRenderer;
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Fishing Lookup")]
public class FishLookup : BaseScriptableObject
{
	public ItemModFishable FallbackFish;

	private static FishLookup _instance;

	private static ItemModFishable[] AvailableFish;

	public static ItemDefinition[] BaitItems;

	private static TimeSince lastShuffle;

	public const int ALL_FISH_COUNT = 9;

	public const string ALL_FISH_ACHIEVEMENT_NAME = "PRO_ANGLER";

	public static FishLookup Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = FileSystem.Load<FishLookup>("assets/prefabs/tools/fishing rod/fishlookup.asset", true);
			}
			return _instance;
		}
	}

	public static void LoadFish()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		if (AvailableFish != null)
		{
			if (TimeSince.op_Implicit(lastShuffle) > 5f)
			{
				AvailableFish.Shuffle((uint)Random.Range(0, 10000));
			}
			return;
		}
		List<ItemModFishable> list = Pool.Get<List<ItemModFishable>>();
		List<ItemDefinition> list2 = Pool.Get<List<ItemDefinition>>();
		ItemModFishable item = default(ItemModFishable);
		ItemModCompostable itemModCompostable = default(ItemModCompostable);
		foreach (ItemDefinition item2 in ItemManager.itemList)
		{
			if (((Component)item2).TryGetComponent<ItemModFishable>(ref item))
			{
				list.Add(item);
			}
			if (((Component)item2).TryGetComponent<ItemModCompostable>(ref itemModCompostable) && itemModCompostable.BaitValue > 0f)
			{
				list2.Add(item2);
			}
		}
		AvailableFish = list.ToArray();
		BaitItems = list2.ToArray();
		Pool.FreeUnmanaged<ItemModFishable>(ref list);
		Pool.FreeUnmanaged<ItemDefinition>(ref list2);
	}

	public ItemDefinition GetFish(Vector3 worldPos, WaterBody bodyType, Item lure, out ItemModFishable fishable, ItemModFishable ignoreFish, out int usedLureAmount, float overrideDepth = 0f)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		LoadFish();
		usedLureAmount = 1;
		ItemModCompostable itemModCompostable = default(ItemModCompostable);
		float num = (((Component)lure.info).TryGetComponent<ItemModCompostable>(ref itemModCompostable) ? itemModCompostable.BaitValue : 0f);
		if ((Object)(object)itemModCompostable != (Object)null && itemModCompostable.MaxBaitStack > 0)
		{
			usedLureAmount = Mathf.Min(lure.amount, itemModCompostable.MaxBaitStack);
			num *= (float)usedLureAmount;
		}
		WaterBody.FishingTag fishingTag = (((Object)(object)bodyType != (Object)null) ? bodyType.FishingType : WaterBody.FishingTag.Ocean);
		if (WaterResource.IsFreshWater(worldPos))
		{
			fishingTag |= WaterBody.FishingTag.River;
		}
		float num2 = WaterLevel.GetOverallWaterDepth(worldPos, waves: true, volumes: false);
		if (worldPos.y < -10f)
		{
			num2 = 10f;
		}
		if (overrideDepth != 0f)
		{
			num2 = overrideDepth;
		}
		int num3 = Random.Range(0, AvailableFish.Length);
		for (int i = 0; i < AvailableFish.Length; i++)
		{
			num3++;
			if (num3 >= AvailableFish.Length)
			{
				num3 = 0;
			}
			ItemModFishable itemModFishable = AvailableFish[num3];
			if (itemModFishable.CanBeFished && !(itemModFishable.MinimumBaitLevel > num) && (!(itemModFishable.MaximumBaitLevel > 0f) || !(num > itemModFishable.MaximumBaitLevel)) && !((Object)(object)itemModFishable == (Object)(object)ignoreFish) && (itemModFishable.RequiredTag == (WaterBody.FishingTag)(-1) || (itemModFishable.RequiredTag & fishingTag) != 0) && ((fishingTag & WaterBody.FishingTag.Ocean) != WaterBody.FishingTag.Ocean || ((!(itemModFishable.MinimumWaterDepth > 0f) || !(num2 < itemModFishable.MinimumWaterDepth)) && (!(itemModFishable.MaximumWaterDepth > 0f) || !(num2 > itemModFishable.MaximumWaterDepth)))) && !(Random.Range(0f, 1f) - num * 3f * 0.01f > itemModFishable.Chance))
			{
				fishable = itemModFishable;
				return ((Component)itemModFishable).GetComponent<ItemDefinition>();
			}
		}
		fishable = FallbackFish;
		return ((Component)FallbackFish).GetComponent<ItemDefinition>();
	}

	public void CheckCatchAllAchievement(BasePlayer player)
	{
		LoadFish();
		int num = 0;
		ItemModFishable[] availableFish = AvailableFish;
		foreach (ItemModFishable itemModFishable in availableFish)
		{
			if (!string.IsNullOrEmpty(itemModFishable.SteamStatName) && player.stats.steam.Get(itemModFishable.SteamStatName) > 0)
			{
				num++;
			}
		}
		if (num == 9)
		{
			player.GiveAchievement("PRO_ANGLER");
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class MapMarkerCH47 : MapMarker
{
	public bool IsCargoShip;

	public bool AutomaticallySetRotationToParent = true;

	public bool UseEntityRotation;

	private float GetRotation(BaseEntity forEntity)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)forEntity == (Object)null)
		{
			return 0f;
		}
		Vector3 forward = ((Component)forEntity).transform.forward;
		forward.y = 0f;
		((Vector3)(ref forward)).Normalize();
		return Mathf.Atan2(forward.x, 0f - forward.z) * 57.29578f + 180f;
	}

	public override AppMarker GetAppMarkerData()
	{
		AppMarker appMarkerData = base.GetAppMarkerData();
		appMarkerData.rotation = GetRotation(GetParentEntity());
		return appMarkerData;
	}
}


using System;
using UnityEngine;

public class MapMarkerExplosion : MapMarker
{
	private float duration = 10f;

	public void SetDuration(float newDuration)
	{
		duration = newDuration;
		if (((FacepunchBehaviour)this).IsInvoking((Action)DelayedDestroy))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)DelayedDestroy);
		}
		((FacepunchBehaviour)this).Invoke((Action)DelayedDestroy, duration * 60f);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk)
		{
			Debug.LogWarning((object)"Loaded explosion marker from disk, cleaning up");
			((FacepunchBehaviour)this).Invoke((Action)DelayedDestroy, 3f);
		}
	}

	public void DelayedDestroy()
	{
		Kill();
	}
}


public class MapMarkerHelicopterFlee : MapMarker
{
}


using UnityEngine;

public class MobileMapMarker : MapMarker
{
	private GameObject createdMarker;
}


using UnityEngine;

public class StaticMapMarker : MapMarker
{
	private GameObject createdMarker;
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class BuriedItem : IPooled
{
	public int? ItemId { get; private set; }

	public ulong UID { get; private set; }

	public ItemOwnershipShare? OwnershipShare { get; private set; }

	public ulong? SkinId { get; private set; }

	public long ExpiryTime { get; set; }

	public Vector2 Location { get; private set; }

	public float? Condition { get; private set; }

	public static BuriedItem Create(Item item, Vector3 worldPosition, long expiryTime)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		BuriedItem buriedItem = Pool.Get<BuriedItem>();
		buriedItem.ItemId = item.info.itemid;
		buriedItem.ExpiryTime = expiryTime;
		buriedItem.Location = new Vector2(worldPosition.x, worldPosition.z);
		buriedItem.Condition = (item.hasCondition ? new float?(item.condition) : ((float?)null));
		buriedItem.UID = item.uid.Value;
		if (item.ownershipShares.Count > 0)
		{
			buriedItem.OwnershipShare = item.ownershipShares[0];
		}
		if (item.skin != 0L)
		{
			buriedItem.SkinId = item.skin;
		}
		return buriedItem;
	}

	public static BuriedItem Create(StoredBuriedItem storedBuriedItem)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		BuriedItem buriedItem = Pool.Get<BuriedItem>();
		buriedItem.ItemId = storedBuriedItem.itemId;
		buriedItem.SkinId = storedBuriedItem.skinId;
		buriedItem.Location = storedBuriedItem.location;
		buriedItem.ExpiryTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() + storedBuriedItem.expiryTimeDiff;
		buriedItem.Condition = ((storedBuriedItem.condition < 0f) ? ((float?)null) : new float?(storedBuriedItem.condition));
		buriedItem.UID = storedBuriedItem.uid;
		if (storedBuriedItem.ownership != null)
		{
			buriedItem.OwnershipShare = new ItemOwnershipShare
			{
				amount = storedBuriedItem.ownership.amount,
				reason = storedBuriedItem.ownership.reason,
				username = storedBuriedItem.ownership.username
			};
		}
		return buriedItem;
	}

	public void EnterPool()
	{
		ItemId = null;
		OwnershipShare = null;
		SkinId = null;
	}

	public void LeavePool()
	{
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using Spatial;
using UnityEngine;

public class BuriedItems : PointEntity
{
	[ServerVar(Help = "Time in seconds before an item expires.")]
	public static float expiryTime = 86400f;

	private const int CellSize = 128;

	private const float WorldSize = 8096f;

	private const float QuerySize = 64f;

	[ServerVar]
	public static int maxBuriedItems = 32;

	[ServerVar(Help = "Metal detector loot weight is 100.")]
	public static int buriedItemWeight = 100;

	[ServerVar(Help = "[0.0 to 1.0]")]
	public static float buryItemChance = 0.85f;

	private Grid<BuriedItem> grid = new Grid<BuriedItem>(128, 8096f);

	private readonly SortedList<long, BuriedItem> itemExpiryTracking = new SortedList<long, BuriedItem>(128);

	private readonly Dictionary<ulong, BuriedItem> uidItemMapping = new Dictionary<ulong, BuriedItem>(128);

	private static readonly Random Random = new Random();

	private (long lastExpiryTime, long modifiedExpiryTime)? lastExpiryTime;

	public static BuriedItems Instance { get; private set; }

	public override void ServerInit()
	{
		base.ServerInit();
		Clear();
		Instance = this;
	}

	public void Register(Item item, Vector3 worldPosition)
	{
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		if (item != null && ((ItemId)(ref item.uid)).IsValid && item.info.allowBurying && Random.NextDouble() <= (double)buryItemChance && itemExpiryTracking.Count < maxBuriedItems)
		{
			TimeSpan timeSpan = TimeSpan.FromSeconds(expiryTime);
			long num = DateTimeOffset.UtcNow.Add(timeSpan).ToUnixTimeMilliseconds();
			BuriedItem buriedItem = BuriedItem.Create(item, worldPosition, num);
			Add(buriedItem);
		}
	}

	private void Add(BuriedItem buriedItem)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		HandleDuplicateExpiryTimes(buriedItem);
		grid.Add(buriedItem, buriedItem.Location.x, buriedItem.Location.y);
		itemExpiryTracking.Add(buriedItem.ExpiryTime, buriedItem);
		uidItemMapping.Add(buriedItem.UID, buriedItem);
	}

	private void HandleDuplicateExpiryTimes(BuriedItem buriedItem)
	{
		long num = buriedItem.ExpiryTime;
		if (lastExpiryTime.HasValue && lastExpiryTime.Value.lastExpiryTime == num)
		{
			long num2;
			for (num2 = lastExpiryTime.Value.modifiedExpiryTime + 1; itemExpiryTracking.ContainsKey(num2); num2++)
			{
			}
			lastExpiryTime = (num, num2);
			buriedItem.ExpiryTime = num2;
		}
		else
		{
			lastExpiryTime = (num, num);
		}
	}

	private void PruneExpiredItems()
	{
		if (itemExpiryTracking.Count == 0)
		{
			return;
		}
		long num = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
		if (itemExpiryTracking.Values[0].ExpiryTime > num)
		{
			return;
		}
		PooledList<BuriedItem> val = Pool.Get<PooledList<BuriedItem>>();
		try
		{
			foreach (var (num3, item) in itemExpiryTracking)
			{
				if (num3 <= num)
				{
					((List<BuriedItem>)(object)val).Add(item);
					continue;
				}
				break;
			}
			if (((List<BuriedItem>)(object)val).Count <= 0)
			{
				return;
			}
			if (((List<BuriedItem>)(object)val).Count == itemExpiryTracking.Count)
			{
				itemExpiryTracking.Clear();
			}
			foreach (BuriedItem item2 in (List<BuriedItem>)(object)val)
			{
				UnregisterItem(item2);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void UnregisterItem(BuriedItem buriedItem)
	{
		grid.Remove(buriedItem);
		itemExpiryTracking.Remove(buriedItem.ExpiryTime);
		uidItemMapping.Remove(buriedItem.UID);
		Pool.Free<BuriedItem>(ref buriedItem);
	}

	public void UnregisterItem(ulong itemUid)
	{
		if (itemUid == 0L || !uidItemMapping.TryGetValue(itemUid, out var value))
		{
			Debug.LogError((object)$"Couldn't find buried item with ID {itemUid}");
		}
		else
		{
			UnregisterItem(value);
		}
	}

	public void Clear()
	{
		uidItemMapping.Clear();
		foreach (BuriedItem value in itemExpiryTracking.Values)
		{
			BuriedItem current = value;
			Pool.Free<BuriedItem>(ref current);
		}
		itemExpiryTracking.Clear();
		grid = new Grid<BuriedItem>(128, 8096f);
		lastExpiryTime = null;
	}

	public void DoUpdate()
	{
		PruneExpiredItems();
	}

	public void AddItems(List<DiggableEntityLoot.ItemEntry> items, Vector3 digWorldPos)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		List<BuriedItem> list = Pool.Get<List<BuriedItem>>();
		grid.Query<BuriedItem>(digWorldPos.x, digWorldPos.z, 64f, list);
		foreach (BuriedItem item in list)
		{
			if (item.ItemId.HasValue)
			{
				items.Add(new DiggableEntityLoot.ItemEntry
				{
					Item = ItemManager.FindItemDefinition(item.ItemId.Value),
					Skin = item.SkinId.GetValueOrDefault(),
					Min = 1,
					Max = 1,
					Weight = buriedItemWeight,
					Condition = item.Condition,
					UID = item.UID,
					Owner = item.OwnershipShare
				});
			}
		}
		Pool.Free<BuriedItem>(ref list, false);
	}

	public override void Save(SaveInfo info)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (!info.forDisk)
		{
			return;
		}
		BuriedItems val = Pool.Get<BuriedItems>();
		val.buriedItems = Pool.Get<List<StoredBuriedItem>>();
		foreach (BuriedItem value in itemExpiryTracking.Values)
		{
			if (value.ItemId.HasValue)
			{
				StoredBuriedItem val2 = Pool.Get<StoredBuriedItem>();
				val2.itemId = value.ItemId.Value;
				val2.skinId = value.SkinId.GetValueOrDefault();
				val2.expiryTimeDiff = value.ExpiryTime - DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
				val2.location = value.Location;
				val2.condition = (value.Condition.HasValue ? value.Condition.Value : (-1f));
				val2.uid = value.UID;
				if (value.OwnershipShare.HasValue)
				{
					ItemOwnershipAmount val3 = Pool.Get<ItemOwnershipAmount>();
					val3.amount = value.OwnershipShare.Value.amount;
					val3.username = value.OwnershipShare.Value.username;
					val3.reason = value.OwnershipShare.Value.reason;
					val2.ownership = val3;
				}
				val.buriedItems.Add(val2);
			}
		}
		info.msg.buriedItemStorage = val;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (!info.fromDisk || info.msg.buriedItemStorage == null)
		{
			return;
		}
		Clear();
		foreach (StoredBuriedItem buriedItem2 in info.msg.buriedItemStorage.buriedItems)
		{
			if (buriedItem2.uid != 0L)
			{
				BuriedItem buriedItem = BuriedItem.Create(buriedItem2);
				Add(buriedItem);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Rust;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/DiggableLoot Spawn")]
public class DiggableEntityLoot : ScriptableObject
{
	[Serializable]
	public struct ItemEntry
	{
		public ItemDefinition Item;

		public int Weight;

		public int Min;

		public int Max;

		public ulong Skin;

		public float? Condition;

		public ItemOwnershipShare? Owner;

		public ulong? UID;
	}

	public List<ItemEntry> Items = new List<ItemEntry>();

	private List<ItemEntry> allowedItems;

	private Era cachedEra;

	[InspectorFlags]
	public Enum Biomes = (Enum)(-1);

	[InspectorFlags]
	public Enum Topology = (Enum)(-1);

	public IList<ItemEntry> GetItems()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (cachedEra != ConVar.Server.Era)
		{
			allowedItems = null;
			cachedEra = ConVar.Server.Era;
		}
		if (allowedItems == null)
		{
			allowedItems = new List<ItemEntry>();
			foreach (ItemEntry item in Items)
			{
				if (item.Item.IsAllowed((EraRestriction)32))
				{
					allowedItems.Add(item);
				}
			}
		}
		return allowedItems;
	}

	public bool VerifyLootListForWorldPosition(Vector3 worldPos)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		int num = (Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap) ? TerrainMeta.BiomeMap.GetBiomeMaxType(worldPos) : 2);
		int num2 = ((!Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap)) ? 1 : TerrainMeta.TopologyMap.GetTopology(worldPos));
		if ((num & Biomes) == 0)
		{
			return false;
		}
		if ((num2 & Topology) == 0)
		{
			return false;
		}
		return true;
	}
}


using System;

[Serializable]
public struct ItemEntry
{
	public ItemDefinition Item;

	public int Weight;

	public int Min;

	public int Max;

	public ulong Skin;

	public float? Condition;

	public ItemOwnershipShare? Owner;

	public ulong? UID;
}


using System.Collections.Generic;
using UnityEngine;

public interface IMetalDetectable
{
	List<Vector3> GetScanLocations();

	Vector3 GetNearestPosition(Vector3 pos);

	bool VerifyScanPosition(Vector3 playerPos, Vector3 pos, out Vector3 spotPos);

	void Detected(Vector3 pos);

	float GetRadius();
}


using System;
using UnityEngine;

public class MetalDetectorFlag : BaseDiggableEntity
{
	public Collider Collision;

	public GameObject FlagModel;

	public float MoveUpBy = 0.2f;

	[ServerVar]
	public static float TimeoutDuration = 10800f;

	public override void ServerInit()
	{
		base.ServerInit();
		ResetTimeout();
	}

	private void ResetTimeout()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)Timeout);
		((FacepunchBehaviour)this).Invoke((Action)Timeout, TimeoutDuration * Random.Range(0.8f, 1.2f));
	}

	private void Timeout()
	{
		Kill();
	}

	public override void OnFullyDug(BasePlayer player)
	{
		if ((Object)(object)Collision != (Object)null)
		{
			Collision.enabled = false;
		}
		player.ProcessMissionEvent(BaseMission.MissionEventType.METAL_DETECTOR_FIND, 0, 1f);
		base.OnFullyDug(player);
	}

	public override void OnSingleDig(BasePlayer player)
	{
		base.OnSingleDig(player);
	}

	public override void OnFirstDig(BasePlayer player)
	{
		base.OnFirstDig(player);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class MetalDetectorSource : BaseEntity, IMetalDetectable
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 1200f;

	[ServerVar]
	public static int AttemptsPerSubSourceSpawn = 5;

	[ServerVar]
	public static float MinDistanceBetweenSubSources = 1.5f;

	[ServerVar]
	public static float TimeoutDuration = 7200f;

	public static int ServerCount = 0;

	[ClientVar(Saved = true)]
	public static bool DrawEditorGizmos = false;

	public int MinSources = 2;

	public int MaxSources = 5;

	public float SpawnRadiusMin = 4f;

	public float SpawnRadiusMax = 6f;

	public float SpawnRadiusBuffer = 1f;

	public GameObjectRef FlagPrefab;

	public GameObjectRef EffectPrefab;

	public const int placementMask = 8388608;

	public const int blockMask = 1075904769;

	public float SpawnRadius { get; private set; }

	public List<Vector3> SpawnLocations { get; private set; } = new List<Vector3>();

	[ServerVar]
	public static void ServerCountSources()
	{
		Debug.Log((object)("Server sources: " + ServerCount));
	}

	public override void ServerInit()
	{
		base.ServerInit();
		base.limitNetworking = true;
		ServerCount++;
		SpawnRadius = Random.Range(SpawnRadiusMin, SpawnRadiusMax);
		ResetTimeout();
		((FacepunchBehaviour)this).Invoke((Action)SpawnSources, Random.Range(0.1f, 1.5f));
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		ServerCount--;
	}

	private void SpawnSources()
	{
		SpawnLocations.Clear();
		int num = Random.Range(MinSources, MaxSources);
		for (int i = 0; i < num; i++)
		{
			TrySpawnSource();
		}
		KillIfNoSources();
		SendNetworkUpdate();
	}

	private void TrySpawnSource()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		bool flag = true;
		int num = 0;
		while (flag)
		{
			Vector3 val = Vector2.op_Implicit(Random.insideUnitCircle);
			Vector3 pos = ((Component)this).transform.position + new Vector3(val.x, 0f, val.y) * (SpawnRadius - SpawnRadiusBuffer);
			bool num2 = ValidateSourcePosition(ref pos);
			if (num2)
			{
				AddSource(pos);
			}
			flag = !num2 && ++num < AttemptsPerSubSourceSpawn;
		}
	}

	private bool ValidateSourcePosition(ref Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(pos + Vector3.up, Vector3.down, ref val, 4f, 8388608))
		{
			foreach (Vector3 spawnLocation in SpawnLocations)
			{
				if (Vector3.SqrMagnitude(((RaycastHit)(ref val)).point - spawnLocation) < MinDistanceBetweenSubSources * MinDistanceBetweenSubSources)
				{
					return false;
				}
			}
			if (!GamePhysics.LineOfSight(((RaycastHit)(ref val)).point, ((RaycastHit)(ref val)).point + Vector3.up * 4f, 1075904769))
			{
				return false;
			}
			if (!GamePhysics.LineOfSight(((Component)this).transform.position, ((RaycastHit)(ref val)).point, 1075904769))
			{
				return false;
			}
			pos = ((RaycastHit)(ref val)).point;
			return true;
		}
		return false;
	}

	private void ResetTimeout()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)Timeout);
		((FacepunchBehaviour)this).Invoke((Action)Timeout, TimeoutDuration * Random.Range(0.8f, 1.2f));
	}

	private void Timeout()
	{
		Kill();
	}

	private void KillIfNoSources()
	{
		if (SpawnLocations.Count == 0)
		{
			Kill();
		}
	}

	private void AddSource(Vector3 pos)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		SpawnLocations.Add(pos);
	}

	private void RemoveSource(Vector3 pos)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		SpawnLocations.Remove(pos);
		KillIfNoSources();
	}

	public Vector3 FindNearestSubSource(Vector3 scanPosition)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		float num = float.PositiveInfinity;
		Vector3 result = scanPosition;
		foreach (Vector3 spawnLocation in SpawnLocations)
		{
			float num2 = Vector3.SqrMagnitude(scanPosition - spawnLocation);
			if (num2 < num)
			{
				num = num2;
				result = spawnLocation;
			}
		}
		return result;
	}

	public void RemoveSweetSpotAndCreateFlag(Vector3 position)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		for (int num = SpawnLocations.Count - 1; num >= 0; num--)
		{
			Vector3 val = SpawnLocations[num];
			if (Vector3.SqrMagnitude(position - val) <= 0.040000003f)
			{
				RemoveSource(val);
				CreateFlag(val);
				flag = true;
			}
		}
		if (flag)
		{
			SendNetworkUpdateImmediate();
		}
	}

	private void CreateFlag(Vector3 pos)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		GameManager.server.CreateEntity(FlagPrefab.resourcePath, pos, Quaternion.Euler(0f, (float)Random.Range(0, 360), 0f)).Spawn();
		Effect.server.Run(EffectPrefab.resourcePath, pos + Vector3.up * 0.1f, Vector3.up);
	}

	public bool VerifySweetSpotPosition(Vector3 playerPos, Vector3 pos, out Vector3 spotPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		spotPos = playerPos;
		if (Vector3.SqrMagnitude(playerPos - pos) >= 4f)
		{
			return false;
		}
		foreach (Vector3 spawnLocation in SpawnLocations)
		{
			if (Vector3.SqrMagnitude(pos - spawnLocation) <= 0.25f)
			{
				spotPos = spawnLocation;
				return true;
			}
		}
		return false;
	}

	public List<Vector3> GetScanLocations()
	{
		return SpawnLocations;
	}

	public Vector3 GetNearestPosition(Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return FindNearestSubSource(pos);
	}

	public bool VerifyScanPosition(Vector3 playerPos, Vector3 pos, out Vector3 spotPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return VerifySweetSpotPosition(playerPos, pos, out spotPos);
	}

	public void Detected(Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		RemoveSweetSpotAndCreateFlag(pos);
	}

	public float GetRadius()
	{
		return SpawnRadius;
	}
}


using UnityEngine;

public class ItemModPager : ItemModRFListener
{
	public static readonly Phrase SilentOffTitle = new Phrase("silent_off", "Silent OFF");

	public static readonly Phrase SilentOffDesc = new Phrase("silent_off_desc", "Emits a small buzzing sound at short distance");

	public static readonly Phrase SilentOnTitle = new Phrase("silent_on", "Silent ON");

	public static readonly Phrase SilentOnDesc = new Phrase("silent_on_desc", "Emits an audible sound at a distance");

	public static readonly Phrase StopTitle = new Phrase("stop", "Stop");

	public static readonly Phrase StopDesc = new Phrase("stop_desc", "Stop the alert");

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		base.ServerCommand(item, command, player);
		PagerEntity component = ((Component)ItemModAssociatedEntity<BaseEntity>.GetAssociatedEntity(item)).GetComponent<PagerEntity>();
		if (Object.op_Implicit((Object)(object)component))
		{
			switch (command)
			{
			case "stop":
				component.SetOff();
				break;
			case "silenton":
				component.SetSilentMode(wantsSilent: true);
				break;
			case "silentoff":
				component.SetSilentMode(wantsSilent: false);
				break;
			}
		}
	}
}


public class ItemModRFListener : ItemModAssociatedEntity<BaseEntity>
{
	public static readonly Phrase SetFreqTitle = new Phrase("setfreq", "Set Frequency");

	public static readonly Phrase SetFreqDesc = new Phrase("setfreq_desc", "Set the frequency on which to listen");

	public GameObjectRef frequencyPanelPrefab;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		base.ServerCommand(item, command, player);
	}
}


public class ClientIOLine_Pipe : ClientIOLine, INotifyLOD
{
	public NotifyLOD NotifyLod;

	public PipeMesh PipeRenderer;
}


using UnityEngine;

public class PipeMesh : MonoBehaviour
{
	public float PipeRadius = 0.04f;

	public Material PipeMaterial;

	public float StraightLength = 0.3f;

	public int PipeSubdivisions = 8;

	public int BendTesselation = 6;

	public float RidgeHeight = 0.05f;

	public float UvScaleMultiplier = 2f;

	public float RidgeIncrements = 0.5f;

	public float RidgeLength = 0.05f;

	public Vector2 HorizontalUvRange = new Vector2(0f, 0.2f);
}


using System.Collections.Generic;
using UnityEngine;

[ExecuteInEditMode]
public class PipeMeshTester : MonoBehaviour
{
	public List<Vector3> positions;

	public Vector3 startDir;

	public Vector3 endDir;

	public Transform startGuide;

	public Transform endGuide;
}


public class Shovel : BaseMelee
{
}


using System;
using UnityEngine;

public class AlignedLineDrawer : MonoBehaviour, IClientComponent
{
	[Serializable]
	public struct LinePoint
	{
		public Vector3 LocalPosition;

		public Vector3 WorldNormal;
	}

	public MeshFilter Filter;

	public MeshRenderer Renderer;

	public float LineWidth = 1f;

	public float SurfaceOffset = 0.001f;

	public float SprayThickness = 0.4f;

	public float uvTilingFactor = 1f;

	public bool DrawEndCaps;

	public bool DrawSideMesh;

	public bool DrawBackMesh;

	public SprayCanSpray_Freehand Spray;
}


using System;
using UnityEngine;

[Serializable]
public struct LinePoint
{
	public Vector3 LocalPosition;

	public Vector3 WorldNormal;
}


public class AlignedLineDrawerDecal : AlignedLineDrawer, INotifyLOD
{
	public DeferredDecal decalComponent;
}


using UnityEngine;

public class ReskinEffect : MonoBehaviour
{
	public ParticleSystem TargetSystem;
}


public interface ISprayCallback
{
	void OnReskinned(BasePlayer byPlayer);
}


using UnityEngine;

public class SprayCanViewmodel : MonoBehaviour, IAnimationEventReceiver
{
	public ParticleSystem Particles;

	public SoundDefinition sprayLoopDef;
}


using Rust.Workshop;
using UnityEngine;

public class SprayCanSpray_Decal : SprayCanSpray, ICustomMaterialReplacer, IPropRenderNotify, INotifyLOD, IWorkshopPreview
{
	public DeferredDecal DecalComponent;

	public GameObject IconPreviewRoot;

	public Material DefaultMaterial;
}


using System.Collections.Generic;
using UnityEngine;

public class ClientIOLine : BaseMonoBehaviour, INotifyLOD
{
	public LineRenderer _line;

	public NotifyLOD lod;

	public Material directionalMaterial;

	public Material defaultMaterial;

	public IOEntity.IOType lineType;

	public WireTool.WireColour colour;

	public static List<ClientIOLine> allLines = new List<ClientIOLine>();

	public IOEntity ownerIOEnt;
}


using System;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/IO/Wire Color Settings")]
public class WireColorSettings : BaseScriptableObject
{
	[Serializable]
	public struct WireColor
	{
		public WireTool.WireColour type;

		public Color color;

		public GameObjectRef prefab;

		public Phrase name;

		public Phrase desc;

		public bool requireCreativeMode;
	}

	private static readonly List<WireColorSettings> settings = new List<WireColorSettings>();

	public IOEntity.IOType ioType;

	public WireColor[] WireColors;

	public static WireColorSettings Get(IOEntity.IOType type)
	{
		foreach (WireColorSettings setting in settings)
		{
			if (setting.ioType == type)
			{
				return setting;
			}
		}
		WireColorSettings wireColorSettings = FileSystem.Load<WireColorSettings>($"Assets/Prefabs/Tools/Wire/{type} Color Settings.asset", true);
		settings.Add(wireColorSettings);
		return wireColorSettings;
	}

	public GameObjectRef GetPrefabRef(WireTool.WireColour wireColor)
	{
		WireColor[] wireColors = WireColors;
		for (int i = 0; i < wireColors.Length; i++)
		{
			WireColor wireColor2 = wireColors[i];
			if (wireColor2.type == wireColor)
			{
				return wireColor2.prefab;
			}
		}
		return null;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct WireColor
{
	public WireTool.WireColour type;

	public Color color;

	public GameObjectRef prefab;

	public Phrase name;

	public Phrase desc;

	public bool requireCreativeMode;
}


using UnityEngine;

public class CassettePanel : NotePanel
{
	public GameObject[] CassetteSprites;
}


using UnityEngine;

public class EffectMount : EntityComponent<BaseEntity>, IClientComponent
{
	public bool firstPerson;

	public GameObject effectPrefab;

	public GameObject spawnedEffect;

	public GameObject mountBone;

	public SoundDefinition onSoundDef;

	public SoundDefinition offSoundDef;

	public bool blockOffSoundWhenGettingDisabled;
}


using UnityEngine;

public class EffectParent : EntityComponent<BaseEntity>, IClientComponent
{
	public GameObject effect;

	[Tooltip("If true the effect isn't our direct child and is in another hierarchy - USE WITH CAUTION")]
	public bool separatedEffect;

	[Tooltip("If true the effect will be forced to the safe layer that doesn't interact with player colliders")]
	[Header("USING COLLIDERS? - COLLIDER SAFETY")]
	public bool forceSafePlayerCollisionLayer;
}


using UnityEngine;

public class FlashlightBeam : MonoBehaviour, IClientComponent
{
	public Vector2 scrollDir;

	public Vector3 localEndPoint = new Vector3(0f, 0f, 2f);

	public LineRenderer beamRenderer;
}


using UnityEngine;

public class LineRendererActivate : MonoBehaviour, IClientComponent
{
	private void OnEnable()
	{
		((Renderer)((Component)this).GetComponent<LineRenderer>()).enabled = true;
	}
}


using UnityEngine;

public class HolosightReticlePositioning : MonoBehaviour
{
	public IronsightAimPoint aimPoint;

	public RectTransform rectTransform
	{
		get
		{
			Transform transform = ((Component)this).transform;
			return (RectTransform)(object)((transform is RectTransform) ? transform : null);
		}
	}

	private void Update()
	{
		if (MainCamera.isValid)
		{
			UpdatePosition(MainCamera.mainCamera);
		}
	}

	private void UpdatePosition(Camera cam)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)aimPoint.targetPoint).transform.position;
		Vector2 val = RectTransformUtility.WorldToScreenPoint(cam, position);
		Transform parent = ((Transform)rectTransform).parent;
		RectTransformUtility.ScreenPointToLocalPointInRectangle((RectTransform)(object)((parent is RectTransform) ? parent : null), val, cam, ref val);
		ref float x = ref val.x;
		float num = x;
		Transform parent2 = ((Transform)rectTransform).parent;
		Rect rect = ((RectTransform)((parent2 is RectTransform) ? parent2 : null)).rect;
		x = num / (((Rect)(ref rect)).width * 0.5f);
		ref float y = ref val.y;
		float num2 = y;
		Transform parent3 = ((Transform)rectTransform).parent;
		rect = ((RectTransform)((parent3 is RectTransform) ? parent3 : null)).rect;
		y = num2 / (((Rect)(ref rect)).height * 0.5f);
		rectTransform.anchoredPosition = val;
	}
}


using UnityEngine;

public class LaserBeam : MonoBehaviour
{
	public float scrollSpeed = 0.5f;

	public LineRenderer beamRenderer;

	public GameObject dotObject;

	public Renderer dotRenderer;

	public GameObject dotSpotlight;

	public Vector2 scrollDir;

	public float maxDistance = 100f;

	public float stillBlendFactor = 0.1f;

	public float movementBlendFactor = 0.5f;

	public float movementThreshhold = 0.15f;

	public bool isFirstPerson;

	public Transform emissionOverride;
}


using UnityEngine;

public class HideIfScoped : MonoBehaviour
{
	public Renderer[] renderers;

	public void SetVisible(bool vis)
	{
		Renderer[] array = renderers;
		foreach (Renderer val in array)
		{
			if ((Object)(object)val != (Object)null)
			{
				val.enabled = vis;
			}
		}
	}
}


using UnityEngine;

public class ViewmodelScope : MonoBehaviour
{
	public float smoothSpeed = 0.05f;

	public Material scopeMaterialOverride;
}


using UnityEngine;

public class HideIfAiming : MonoBehaviour, IEffect
{
	public ParticleSystem[] systems;
}


using UnityEngine;

public class BeeGrenade : TimedExplosive
{
	public GameObjectRef beeSwarmPrefab;

	[Header("Spawning Settings")]
	public int beeSwarmAmount = 1;

	public float spawnRadius = 2f;

	private const int mask = -928830719;

	public override void Explode()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		if (beeSwarmPrefab.isValid && !WaterLevel.Test(((Component)this).transform.position, waves: true, volumes: true, this))
		{
			RaycastHit val4 = default(RaycastHit);
			RaycastHit val6 = default(RaycastHit);
			RaycastHit val7 = default(RaycastHit);
			for (int i = 0; i < Mathf.Max(1, beeSwarmAmount); i++)
			{
				Vector3 val = ((Component)this).transform.position;
				Vector3 val5;
				if (beeSwarmAmount > 1)
				{
					Vector2 val2 = Random.insideUnitCircle * spawnRadius;
					Vector3 val3 = ((Component)this).transform.position + new Vector3(val2.x, 0f, val2.y);
					if (Physics.Linecast(((Component)this).transform.position, val3, ref val4, -928830719))
					{
						Vector3 point = ((RaycastHit)(ref val4)).point;
						val5 = ((Component)this).transform.position - point;
						Vector3 normalized = ((Vector3)(ref val5)).normalized;
						val = point + normalized * 1.5f;
					}
					else
					{
						val5 = ((Component)this).transform.position - ((Component)this).transform.position;
						Vector3 normalized2 = ((Vector3)(ref val5)).normalized;
						val = val3;
						val += normalized2 * 0.5f;
					}
				}
				if (Physics.Raycast(new Ray(val + Vector3.up * 0.5f, Vector3.down), ref val6, 2f, -928830719))
				{
					val.y = ((RaycastHit)(ref val6)).point.y;
				}
				val += Vector3.up * 1.5f;
				if (Physics.Linecast(((Component)this).transform.position, val, ref val7, -928830719))
				{
					val = ((RaycastHit)(ref val7)).point;
				}
				if ((Object)(object)creatorPlayer != (Object)null)
				{
					val5 = ((Component)creatorPlayer).transform.position - ((Component)this).transform.position;
					Vector3 normalized3 = ((Vector3)(ref val5)).normalized;
					val += normalized3;
				}
				BaseEntity baseEntity = GameManager.server.CreateEntity(beeSwarmPrefab.resourcePath, val, Quaternion.identity);
				if ((Object)(object)creatorPlayer != (Object)null)
				{
					baseEntity.OwnerID = creatorPlayer.userID;
					baseEntity.creatorEntity = creatorPlayer;
				}
				baseEntity.Spawn();
			}
		}
		base.Explode();
	}

	public void DelayedDestroy()
	{
		Kill(DestroyMode.Gib);
	}
}


using UnityEngine;

public class BeeTriggerHurt : TriggerHurtEx
{
	public GameObjectRef BeeGrenadePrefab;

	protected override void ModifyHit(HitInfo info)
	{
		base.ModifyHit(info);
		if ((Object)(object)info.Initiator != (Object)null && info.Initiator.OwnerID != 0L)
		{
			info.Initiator = BasePlayer.FindByID(info.Initiator.OwnerID);
			info.WeaponPrefab = GameManager.server.FindPrefab(BeeGrenadePrefab.resourcePath).GetComponent<BaseEntity>();
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust;
using UnityEngine;

public class ThrownBoomerangServerProjectile : ServerProjectile
{
	public DamageProperties damageProperties;

	public List<DamageTypeEntry> damageTypes = new List<DamageTypeEntry>();

	public float worldAttackRadius;

	private Vector3 startPosition;

	private bool willKill;

	public void ProjectileHandleMovement(bool state)
	{
		shouldMoveProjectile = state;
	}

	public void SetStartPosition(Vector3 position)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		startPosition = position;
	}

	public void CalculateDamage(HitInfo info, float scale)
	{
		foreach (DamageTypeEntry damageType in damageTypes)
		{
			info.damageTypes.Add(damageType.type, damageType.amount * scale);
		}
		if (Global.developer > 0)
		{
			Debug.Log((object)(" Projectile damage: " + info.damageTypes.Total() + " (scalar=" + scale + ")"));
		}
	}

	protected override bool AutomaticallyRotate()
	{
		return false;
	}

	protected override void OnHit(RaycastHit rayHit, BaseEntity hitEntity)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		base.OnHit(rayHit, hitEntity);
		willKill = true;
		HitInfo hitInfo = new HitInfo();
		hitInfo.Initiator = base.baseEntity.creatorEntity;
		hitInfo.WeaponPrefab = base.baseEntity;
		hitInfo.IsPredicting = false;
		hitInfo.DoDecals = true;
		hitInfo.DoHitEffects = true;
		hitInfo.DidHit = true;
		hitInfo.HitPositionWorld = ((RaycastHit)(ref rayHit)).point;
		hitInfo.HitNormalWorld = ((RaycastHit)(ref rayHit)).normal;
		hitInfo.ProjectileVelocity = base.CurrentVelocity;
		hitInfo.PointStart = startPosition;
		hitInfo.PointEnd = ((RaycastHit)(ref rayHit)).point;
		hitInfo.damageProperties = damageProperties;
		CalculateDamage(hitInfo, 1f);
		hitInfo.HitMaterial = StringPool.Get(GetMaterialName(rayHit));
		ThrownBoomerang obj = base.baseEntity as ThrownBoomerang;
		obj.OnHit();
		if (hitEntity.IsValid())
		{
			hitInfo.HitEntity = hitEntity;
			hitInfo.HitPositionLocal = ((Component)hitInfo.HitEntity).transform.InverseTransformPoint(hitInfo.HitPositionWorld);
			hitInfo.HitNormalLocal = ((Component)hitInfo.HitEntity).transform.InverseTransformDirection(hitInfo.HitNormalWorld);
			Shield shield = hitInfo.HitEntity as Shield;
			if (hitInfo.HitEntity is BasePlayer || hitInfo.HitEntity is BaseNpc || (Object)(object)shield != (Object)null)
			{
				hitInfo.HitMaterial = StringPool.Get(((Object)(object)shield != (Object)null) ? shield.GetHitMaterialString() : "Flesh");
			}
			if (!(hitInfo.HitEntity is BasePlayer) && !(hitInfo.HitEntity is BaseNpc))
			{
				hitInfo.damageTypes.ScaleAll(0.03f);
			}
			hitInfo.HitEntity.OnAttacked(hitInfo);
		}
		Vector3 currentVelocity = base.CurrentVelocity;
		obj.CreateWorldModel(hitInfo, ((Vector3)(ref currentVelocity)).normalized);
		Effect.server.ImpactEffect(hitInfo);
	}

	protected override bool DoHitDetection(Vector3 velocityToUse, float distance)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		List<RaycastHit> list2 = Pool.Get<List<RaycastHit>>();
		Vector3 position = ((Component)this).transform.position;
		GamePhysics.TraceAll(new Ray(position, ((Vector3)(ref velocityToUse)).normalized), radius, list, distance + scanRange, mask, (QueryTriggerInteraction)1);
		GamePhysics.TraceAll(new Ray(position, ((Vector3)(ref velocityToUse)).normalized), worldAttackRadius, list2, distance + scanRange, mask, (QueryTriggerInteraction)1);
		foreach (RaycastHit item in list)
		{
			RaycastHit current = item;
			BaseEntity entity = current.GetEntity();
			if ((!((Object)(object)entity != (Object)null) || !entity.isClient) && (!IgnoreAI || !IsAnIgnoredAI(entity)) && (entity is BasePlayer || entity is BaseNpc) && IsAValidHit(entity) && GamePhysics.LineOfSight(((Component)this).transform.position, ((RaycastHit)(ref current)).point, mask, 0f))
			{
				ProcessHit(current, entity, position);
				Pool.FreeUnmanaged<RaycastHit>(ref list);
				Pool.FreeUnmanaged<RaycastHit>(ref list2);
				return true;
			}
		}
		foreach (RaycastHit item2 in list2)
		{
			BaseEntity entity2 = item2.GetEntity();
			if ((!((Object)(object)entity2 != (Object)null) || !entity2.isClient) && (!IgnoreAI || !IsAnIgnoredAI(entity2)) && IsAValidHit(entity2) && IsShootable(item2))
			{
				ProcessHit(item2, entity2, position);
				Pool.FreeUnmanaged<RaycastHit>(ref list);
				Pool.FreeUnmanaged<RaycastHit>(ref list2);
				return true;
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		Pool.FreeUnmanaged<RaycastHit>(ref list2);
		return false;
	}

	protected override void PostDoMove()
	{
		if (willKill)
		{
			base.baseEntity.Kill();
		}
	}

	protected override bool IsAValidHit(BaseEntity hitEnt)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)hitEnt != (Object)null)
		{
			if (base.baseEntity.creatorEntity.IsValid() && hitEnt.net.ID == base.baseEntity.creatorEntity.net.ID)
			{
				return false;
			}
			if (ignoreEntity.IsValid() && hitEnt.net.ID == ignoreEntity.net.ID)
			{
				return false;
			}
		}
		return true;
	}

	private string GetMaterialName(RaycastHit rayHit)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		string result = "generic";
		if ((Object)(object)rayHit.GetCollider() != (Object)null && (Object)(object)rayHit.GetCollider().sharedMaterial != (Object)null)
		{
			result = ((Object)rayHit.GetCollider().sharedMaterial).name;
		}
		if (rayHit.IsWaterHit())
		{
			result = "Water";
		}
		return result;
	}
}


using UnityEngine;

public class v_chainsaw : MonoBehaviour
{
	public bool bAttacking;

	public bool bHitMetal;

	public bool bHitWood;

	public bool bHitFlesh;

	public bool bEngineOn;

	public ParticleSystem[] hitMetalFX;

	public ParticleSystem[] hitWoodFX;

	public ParticleSystem[] hitFleshFX;

	public SoundDefinition hitMetalSoundDef;

	public SoundDefinition hitWoodSoundDef;

	public SoundDefinition hitFleshSoundDef;

	public Sound hitSound;

	public GameObject hitSoundTarget;

	public float hitSoundFadeTime = 0.1f;

	public ParticleSystem smokeEffect;

	public Animator chainsawAnimator;

	public Renderer chainRenderer;

	public Material chainlink;

	private MaterialPropertyBlock block;

	private Vector2 saveST;

	private float chainSpeed;

	private float chainAmount;

	public float temp1;

	public float temp2;

	public void OnEnable()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Expected O, but got Unknown
		if (block == null)
		{
			block = new MaterialPropertyBlock();
		}
		saveST = Vector4.op_Implicit(chainRenderer.sharedMaterial.GetVector("_MainTex_ST"));
	}

	private void Awake()
	{
		chainlink = chainRenderer.sharedMaterial;
	}

	private void Start()
	{
	}

	private void ScrollChainTexture()
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		float num = (chainAmount = (chainAmount + Time.deltaTime * chainSpeed) % 1f);
		block.Clear();
		block.SetVector("_MainTex_ST", new Vector4(saveST.x, saveST.y, num, 0f));
		chainRenderer.SetPropertyBlock(block);
	}

	private void Update()
	{
		chainsawAnimator.SetBool("attacking", bAttacking);
		smokeEffect.enableEmission = bEngineOn;
		if (bHitMetal)
		{
			chainsawAnimator.SetBool("attackHit", true);
			ParticleSystem[] array = hitMetalFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = true;
			}
			array = hitWoodFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = false;
			}
			array = hitFleshFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = false;
			}
			DoHitSound(hitMetalSoundDef);
		}
		else if (bHitWood)
		{
			chainsawAnimator.SetBool("attackHit", true);
			ParticleSystem[] array = hitMetalFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = false;
			}
			array = hitWoodFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = true;
			}
			array = hitFleshFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = false;
			}
			DoHitSound(hitWoodSoundDef);
		}
		else if (bHitFlesh)
		{
			chainsawAnimator.SetBool("attackHit", true);
			ParticleSystem[] array = hitMetalFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = false;
			}
			array = hitWoodFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = false;
			}
			array = hitFleshFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = true;
			}
			DoHitSound(hitFleshSoundDef);
		}
		else
		{
			chainsawAnimator.SetBool("attackHit", false);
			ParticleSystem[] array = hitMetalFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = false;
			}
			array = hitWoodFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = false;
			}
			array = hitFleshFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = false;
			}
		}
	}

	private void DoHitSound(SoundDefinition soundDef)
	{
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

public class DeployableSiegeExplosive : BaseCombatEntity, IIgniteable, ISplashable
{
	public GameObjectRef ExplosionEffect;

	public GameObjectRef ExplosionImpact;

	public Vector3 EffectOffset;

	public Transform ExplosionSpawnPoint;

	public const Flags Lit = Flags.Reserved1;

	public float MinimumFuseTime = 3f;

	public float MaximumFuseTime = 10f;

	public float NeighbourExplodeRadius = 2f;

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		creatorEntity = deployedBy;
	}

	public override void Hurt(HitInfo info)
	{
		if (!base.isClient && !HasFlag(Flags.Reserved1))
		{
			info.damageTypes.ScaleAll(0f);
			base.Hurt(info);
			SetFlag(Flags.Reserved1, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ActuallyExplode, Random.Range(MinimumFuseTime, MaximumFuseTime));
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (HasFlag(Flags.Reserved1))
		{
			((FacepunchBehaviour)this).Invoke((Action)ActuallyExplode, Random.Range(MinimumFuseTime, MaximumFuseTime));
		}
	}

	private void ActuallyExplode()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		if (ExplosionEffect.isValid)
		{
			Vector3 position = ExplosionSpawnPoint.position;
			BaseEntity baseEntity = GameManager.server.CreateEntity(ExplosionEffect.resourcePath, position);
			ServerProjectile component = ((Component)baseEntity).GetComponent<ServerProjectile>();
			component.InitializeVelocity(Vector3.up);
			baseEntity.Spawn();
			TimedExplosive timedExplosive = default(TimedExplosive);
			if (((Component)component).TryGetComponent<TimedExplosive>(ref timedExplosive))
			{
				timedExplosive.creatorEntity = creatorEntity;
				timedExplosive.Explode();
			}
			if (ExplosionImpact.isValid)
			{
				Effect.server.Run(ExplosionImpact.resourcePath, position + EffectOffset);
			}
			PooledList<DeployableSiegeExplosive> val = Pool.Get<PooledList<DeployableSiegeExplosive>>();
			try
			{
				Vis.Entities(position, NeighbourExplodeRadius, (List<DeployableSiegeExplosive>)(object)val, 256, (QueryTriggerInteraction)2);
				foreach (DeployableSiegeExplosive item in (List<DeployableSiegeExplosive>)(object)val)
				{
					if (item.isServer && !item.HasFlag(Flags.Reserved1) && CanSee(position, item.ExplosionSpawnPoint.position))
					{
						item.Hurt(3f, DamageType.Heat, this);
					}
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		Kill();
	}

	public void Ignite(Vector3 fromPos)
	{
		SetFlag(Flags.Reserved1, b: true);
		((FacepunchBehaviour)this).Invoke((Action)ActuallyExplode, Random.Range(MinimumFuseTime, MaximumFuseTime));
	}

	public bool CanIgnite()
	{
		return !HasFlag(Flags.Reserved1);
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		return HasFlag(Flags.Reserved1);
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		SetFlag(Flags.Reserved1, b: false);
		((FacepunchBehaviour)this).CancelInvoke((Action)ActuallyExplode);
		return 0;
	}

	private void OnGroundMissing()
	{
		ActuallyExplode();
	}

	public override bool CanPickup(BasePlayer player)
	{
		if (!HasFlag(Flags.Reserved1))
		{
			return base.CanPickup(player);
		}
		return false;
	}
}


using UnityEngine;

public class DoubleShotgunViewModel : BaseViewModel
{
	public GameObject NoSkinRoot;
}


using UnityEngine;

public class FlameJet : MonoBehaviour
{
	public LineRenderer line;

	public float tesselation = 0.025f;

	private float length;

	public float maxLength = 2f;

	public float drag;

	private int numSegments;

	private float spacing;

	public bool on;

	public bool autoDisable;

	private Vector3[] lastWorldSegments;

	private Vector3[] currentSegments = (Vector3[])(object)new Vector3[0];

	public Color startColor;

	public Color endColor;

	public Color currentColor;

	public bool externalUpdate;

	private void Initialize()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		currentColor = startColor;
		tesselation = 0.1f;
		numSegments = Mathf.CeilToInt(maxLength / tesselation);
		spacing = maxLength / (float)numSegments;
		if (currentSegments.Length != numSegments)
		{
			currentSegments = (Vector3[])(object)new Vector3[numSegments];
		}
	}

	private void Awake()
	{
		Initialize();
	}

	public void LateUpdate()
	{
		if (!externalUpdate)
		{
			UpdateLine();
		}
	}

	public void SetOn(bool isOn)
	{
		on = isOn;
	}

	private float curve(float x)
	{
		return x * x;
	}

	public void UpdateLine()
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		currentColor.a = Mathf.Lerp(currentColor.a, on ? 1f : 0f, Time.deltaTime * 40f);
		line.SetColors(currentColor, endColor);
		if (lastWorldSegments == null)
		{
			lastWorldSegments = (Vector3[])(object)new Vector3[numSegments];
		}
		int num = currentSegments.Length;
		Vector3 val3 = default(Vector3);
		for (int i = 0; i < num; i++)
		{
			float num2 = 0f;
			float num3 = 0f;
			if (lastWorldSegments != null && lastWorldSegments[i] != Vector3.zero && i > 0)
			{
				Vector3 val = ((Component)this).transform.InverseTransformPoint(lastWorldSegments[i]);
				float num4 = (float)i / (float)currentSegments.Length;
				Vector3 val2 = Vector3.Lerp(val, Vector3.zero, Time.deltaTime * drag);
				val2 = Vector3.Lerp(Vector3.zero, val2, Mathf.Sqrt(num4));
				num2 = val2.x;
				num3 = val2.y;
			}
			if (i == 0)
			{
				num2 = (num3 = 0f);
			}
			((Vector3)(ref val3))..ctor(num2, num3, (float)i * spacing);
			currentSegments[i] = val3;
			lastWorldSegments[i] = ((Component)this).transform.TransformPoint(val3);
		}
		line.positionCount = numSegments;
		line.SetPositions(currentSegments);
		if (autoDisable && !on && currentColor.a < 0.01f)
		{
			currentColor.a = 0f;
			line.SetColors(currentColor, endColor);
			((Behaviour)this).enabled = false;
		}
	}
}


using UnityEngine;
using UnityEngine.UI;

public class HomingLauncherUIDialog : UIDialog
{
	[Header("Homing Launcher")]
	[SerializeField]
	private Canvas canvas;

	[SerializeField]
	private GameObject mainUI;

	[SerializeField]
	private GameObject scopeCircle;

	[SerializeField]
	private RawImage blackScreen;

	[SerializeField]
	private AnimationCurve fadeEffectCurve;

	[SerializeField]
	private float visualSwapTime = 0.5f;

	[SerializeField]
	private Image lockPercentImage;

	[SerializeField]
	private Image trackingImage;

	[SerializeField]
	private GameObject armedObj;

	[SerializeField]
	private GameObject lockedObj;

	[SerializeField]
	private GameObject noAmmoObj;
}


public class HomingLauncherViewModel : BaseViewModel
{
}


using System;
using UnityEngine;

public class SeekerTest : BaseEntity, SeekerTarget.ISeekerTargetOwner
{
	public GameObjectRef roadFlare;

	public bool useRoadFlares;

	public int numFlares = 3;

	public int maxFlares = 3;

	public float flareRegenTime = 10f;

	public float timeBetweenFlares = 10f;

	public Transform flareSpawnPoint;

	public float flareDuration = 5f;

	private float nextFlareRegenTime;

	public override void ServerInit()
	{
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.MEDIUM);
		base.ServerInit();
	}

	public void Update()
	{
		if (Time.time > nextFlareRegenTime)
		{
			numFlares = Mathf.Clamp(numFlares + 1, 0, maxFlares);
			nextFlareRegenTime = Time.time + timeBetweenFlares;
		}
	}

	public void DoFlare()
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (numFlares != 0)
		{
			numFlares--;
			if (useRoadFlares)
			{
				GameManager.server.CreateEntity(roadFlare.resourcePath, flareSpawnPoint.position).Spawn();
				return;
			}
			SetFlag(Flags.OnFire, b: true);
			SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
			((FacepunchBehaviour)this).Invoke((Action)ClearFlares, flareDuration);
		}
	}

	public void ClearFlares()
	{
		SetFlag(Flags.OnFire, b: false);
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.MEDIUM);
	}

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		if (msg == "RadarLock")
		{
			if (!((FacepunchBehaviour)this).IsInvoking((Action)DoFlare))
			{
				((FacepunchBehaviour)this).Invoke((Action)DoFlare, Random.Range(0.5f, 1f));
			}
		}
		else if (msg == "RadarWarning")
		{
			SetFlag(Flags.Reserved1, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ClearWarning, 1f);
		}
		else
		{
			base.OnEntityMessage(from, msg);
		}
	}

	public void ClearWarning()
	{
		SetFlag(Flags.Reserved1, b: false);
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
		}
		base.DestroyShared();
	}

	public bool IsValidHomingTarget()
	{
		return true;
	}
}


public class ItemModShield : ItemMod
{
}


using System;
using UnityEngine;

public class ShieldHeldEntityOffset : PrefabAttribute, IClientComponent
{
	public enum BoneType
	{
		r_prop,
		l_prop
	}

	public BoneType Type;

	public Vector3 LocalSpaceHoldOffsetPos;

	public Quaternion LocalSpaceHoldOffsetRot;

	protected override Type GetIndexedType()
	{
		return typeof(ShieldHeldEntityOffset);
	}
}


public enum BoneType
{
	r_prop,
	l_prop
}


using UnityEngine;

public class ShieldViewmodel : MonoBehaviour, IViewmodelComponent
{
	public Animator TargetAnimator;

	public Transform RightArmBone;
}


using System.Collections.Generic;

public class MiniCrossbow : BaseProjectile
{
	public List<LODGroupRenderers> ArrowRenderers;

	public override bool ForceSendMagazine(SaveInfo saveInfo)
	{
		return true;
	}

	public override void DidAttackServerside()
	{
		base.DidAttackServerside();
		SendNetworkUpdateImmediate();
	}
}


using UnityEngine;

public class MiniCrossbowViewmodel : FacepunchBehaviour, IViewmodelComponent, IAnimationEventReceiver
{
	public Renderer[] ArrowRenderers;

	public Animator TargetAnimator;

	public Transform BarrelJoint;

	public float RotateDuration = 0.6f;

	public AnimationCurve RotateCurve;

	public AnimationCurve RotateCurveReload;
}


using UnityEngine;

public class ViewmodelIgniteToggle : MonoBehaviour
{
	public void Start()
	{
	}
}


using UnityEngine;

public class ToolgunBeam : MonoBehaviour
{
	public LineRenderer electricalBeam;

	public float scrollSpeed = -8f;

	private Color fadeColor = new Color(1f, 1f, 1f, 1f);

	public float fadeSpeed = 4f;

	public void Update()
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		if (fadeColor.a <= 0f)
		{
			Object.Destroy((Object)(object)((Component)this).gameObject);
			return;
		}
		((Renderer)electricalBeam).sharedMaterial.SetTextureOffset("_MainTex", new Vector2(Time.time * scrollSpeed, 0f));
		fadeColor.a -= Time.deltaTime * fadeSpeed;
		electricalBeam.startColor = fadeColor;
		electricalBeam.endColor = fadeColor;
	}
}


using UnityEngine;
using UnityEngine.UI;

public class ToolgunScreen : MonoBehaviour
{
	public Text blockInfoText;

	public Text noBlockText;

	public void SetScreenText(string newText)
	{
		bool flag = string.IsNullOrEmpty(newText);
		((Component)blockInfoText).gameObject.SetActive(!flag);
		((Component)noBlockText).gameObject.SetActive(flag);
		blockInfoText.text = newText;
	}
}


using UnityEngine;

public class AnimalBrain : BaseAIBrain
{
	public class AttackState : BasicAIState
	{
		private IAIAttack attack;

		public AttackState()
			: base(AIState.Attack)
		{
			base.AgrresiveState = true;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			attack = entity as IAIAttack;
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			BasePlayer basePlayer = baseEntity as BasePlayer;
			if ((Object)(object)basePlayer != (Object)null && basePlayer.IsDead())
			{
				StopAttacking();
			}
			else if ((Object)(object)baseEntity != (Object)null && baseEntity.Health() > 0f)
			{
				BaseCombatEntity target = baseEntity as BaseCombatEntity;
				Vector3 aimDirection = GetAimDirection(entity as BaseCombatEntity, target);
				brain.Navigator.SetFacingDirectionOverride(aimDirection);
				if (attack.CanAttack(baseEntity))
				{
					StartAttacking(baseEntity);
				}
				brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
			}
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			brain.Navigator.ClearFacingDirectionOverride();
			brain.Navigator.Stop();
			StopAttacking();
		}

		private void StopAttacking()
		{
			attack.StopAttacking();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_00de: Unknown result type (might be due to invalid IL or missing references)
			//IL_0122: Unknown result type (might be due to invalid IL or missing references)
			//IL_0127: Unknown result type (might be due to invalid IL or missing references)
			//IL_012f: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if (attack == null)
			{
				return StateStatus.Error;
			}
			if ((Object)(object)baseEntity == (Object)null)
			{
				brain.Navigator.ClearFacingDirectionOverride();
				StopAttacking();
				return StateStatus.Finished;
			}
			if (baseEntity.Health() <= 0f)
			{
				StopAttacking();
				return StateStatus.Finished;
			}
			BasePlayer basePlayer = baseEntity as BasePlayer;
			if ((Object)(object)basePlayer != (Object)null && basePlayer.IsDead())
			{
				StopAttacking();
				return StateStatus.Finished;
			}
			BaseVehicle baseVehicle = (((Object)(object)basePlayer != (Object)null) ? basePlayer.GetMountedVehicle() : null);
			if ((Object)(object)baseVehicle != (Object)null && baseVehicle is BaseModularVehicle)
			{
				StopAttacking();
				return StateStatus.Error;
			}
			if (brain.Senses.ignoreSafeZonePlayers && (Object)(object)basePlayer != (Object)null && basePlayer.InSafeZone())
			{
				return StateStatus.Error;
			}
			if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast, 0.25f, (baseEntity is BasePlayer && attack != null) ? attack.EngagementRange() : 0f))
			{
				return StateStatus.Error;
			}
			BaseCombatEntity target = baseEntity as BaseCombatEntity;
			Vector3 aimDirection = GetAimDirection(entity as BaseCombatEntity, target);
			brain.Navigator.SetFacingDirectionOverride(aimDirection);
			if (attack.CanAttack(baseEntity))
			{
				StartAttacking(baseEntity);
			}
			else
			{
				StopAttacking();
			}
			return StateStatus.Running;
		}

		private static Vector3 GetAimDirection(BaseCombatEntity from, BaseCombatEntity target)
		{
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)from == (Object)null || (Object)(object)target == (Object)null)
			{
				if (!((Object)(object)from != (Object)null))
				{
					return Vector3.forward;
				}
				return ((Component)from).transform.forward;
			}
			return Vector3Ex.Direction2D(((Component)target).transform.position, ((Component)from).transform.position);
		}

		private void StartAttacking(BaseEntity entity)
		{
			attack.StartAttacking(entity);
		}
	}

	public class ChaseState : BasicAIState
	{
		private IAIAttack attack;

		public ChaseState()
			: base(AIState.Chase)
		{
			base.AgrresiveState = true;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			attack = entity as IAIAttack;
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity != (Object)null)
			{
				brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
			}
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity == (Object)null)
			{
				Stop();
				return StateStatus.Error;
			}
			if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast, 0.25f, (baseEntity is BasePlayer && attack != null) ? attack.EngagementRange() : 0f))
			{
				return StateStatus.Error;
			}
			if (!brain.Navigator.Moving)
			{
				return StateStatus.Finished;
			}
			return StateStatus.Running;
		}
	}

	public class FleeState : BasicAIState
	{
		private float nextInterval = 2f;

		private float stopFleeDistance;

		public FleeState()
			: base(AIState.Flee)
		{
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity != (Object)null)
			{
				stopFleeDistance = Random.Range(80f, 100f) + Mathf.Clamp(Vector3Ex.Distance2D(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position), 0f, 50f);
			}
			FleeFrom(brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot), entity);
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity == (Object)null)
			{
				return StateStatus.Finished;
			}
			if (Vector3Ex.Distance2D(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position) >= stopFleeDistance)
			{
				return StateStatus.Finished;
			}
			if ((brain.Navigator.UpdateIntervalElapsed(nextInterval) || !brain.Navigator.Moving) && !FleeFrom(baseEntity, entity))
			{
				return StateStatus.Error;
			}
			return StateStatus.Running;
		}

		private bool FleeFrom(BaseEntity fleeFromEntity, BaseEntity thisEntity)
		{
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)thisEntity == (Object)null || (Object)(object)fleeFromEntity == (Object)null)
			{
				return false;
			}
			nextInterval = Random.Range(3f, 6f);
			if (!brain.PathFinder.GetBestFleePosition(brain.Navigator, brain.Senses, fleeFromEntity, brain.Events.Memory.Position.Get(4), 50f, 100f, out var result))
			{
				return false;
			}
			bool num = brain.Navigator.SetDestination(result, BaseNavigator.NavigationSpeed.Fast);
			if (!num)
			{
				Stop();
			}
			return num;
		}
	}

	public class IdleState : BaseIdleState
	{
		private float nextTurnTime;

		private float minTurnTime = 10f;

		private float maxTurnTime = 20f;

		private int turnChance = 33;

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateEnter(brain, entity);
			FaceNewDirection(entity);
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			brain.Navigator.ClearFacingDirectionOverride();
		}

		private void FaceNewDirection(BaseEntity entity)
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			if (Random.Range(0, 100) <= turnChance)
			{
				Vector3 position = ((Component)entity).transform.position;
				Vector3 val = BasePathFinder.GetPointOnCircle(position, 1f, Random.Range(0f, 594f)) - position;
				Vector3 normalized = ((Vector3)(ref val)).normalized;
				brain.Navigator.SetFacingDirectionOverride(normalized);
			}
			nextTurnTime = Time.realtimeSinceStartup + Random.Range(minTurnTime, maxTurnTime);
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			base.StateThink(delta, brain, entity);
			if (Time.realtimeSinceStartup >= nextTurnTime)
			{
				FaceNewDirection(entity);
			}
			return StateStatus.Running;
		}
	}

	public class MoveToPointState : BasicAIState
	{
		private float originalStopDistance;

		public MoveToPointState()
			: base(AIState.MoveToPoint)
		{
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateEnter(brain, entity);
			BaseNavigator navigator = brain.Navigator;
			originalStopDistance = navigator.StoppingDistance;
			navigator.StoppingDistance = 0.5f;
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			brain.Navigator.StoppingDistance = originalStopDistance;
			Stop();
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			Vector3 pos = brain.Events.Memory.Position.Get(6);
			if (!brain.Navigator.SetDestination(pos, ControlTestAnimalSpeed))
			{
				return StateStatus.Error;
			}
			if (!brain.Navigator.Moving)
			{
				return StateStatus.Finished;
			}
			return StateStatus.Running;
		}
	}

	public class MoveTowardsState : BaseMoveTorwardsState
	{
	}

	public class RoamState : BasicAIState
	{
		private StateStatus status = StateStatus.Error;

		public RoamState()
			: base(AIState.Roam)
		{
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			status = StateStatus.Error;
			if (brain.PathFinder == null)
			{
				return;
			}
			Vector3 center;
			if (brain.InGroup() && !brain.IsGroupLeader)
			{
				center = brain.Events.Memory.Position.Get(5);
				center = BasePathFinder.GetPointOnCircle(center, Random.Range(2f, 7f), Random.Range(0f, 359f));
			}
			else
			{
				center = brain.PathFinder.GetBestRoamPosition(brain.Navigator, GetRoamAnchorPosition(), brain.Events.Memory.Position.Get(4), GetRoamPointMinDistance(), GetRoamPointMaxDistance());
			}
			if (brain.Navigator.SetDestination(center, BaseNavigator.NavigationSpeed.Slow))
			{
				if (brain.InGroup() && brain.IsGroupLeader)
				{
					brain.SetGroupRoamRootPosition(center);
				}
				status = StateStatus.Running;
			}
			else
			{
				status = StateStatus.Error;
			}
		}

		public virtual Vector3 GetRoamAnchorPosition()
		{
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			if (brain.Navigator.MaxRoamDistanceFromHome > -1f)
			{
				return brain.Events.Memory.Position.Get(4);
			}
			return ((Component)brain.Navigator).transform.position;
		}

		public virtual float GetRoamPointMinDistance()
		{
			if (brain.Navigator.MaxRoamDistanceFromHome > -1f)
			{
				return 5f;
			}
			return 20f;
		}

		public virtual float GetRoamPointMaxDistance()
		{
			if (brain.Navigator.MaxRoamDistanceFromHome > -1f)
			{
				return brain.Navigator.MaxRoamDistanceFromHome;
			}
			return brain.Navigator.BestRoamPointMaxDistance;
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			base.StateThink(delta, brain, entity);
			if (status == StateStatus.Error)
			{
				return status;
			}
			if (brain.Navigator.Moving)
			{
				return StateStatus.Running;
			}
			return StateStatus.Finished;
		}
	}

	public static int Count;

	public static BaseNavigator.NavigationSpeed ControlTestAnimalSpeed = BaseNavigator.NavigationSpeed.Fast;

	public override void AddStates()
	{
		base.AddStates();
		AddState(new IdleState());
		AddState(new MoveTowardsState());
		AddState(new FleeState());
		AddState(new RoamState());
		AddState(new AttackState());
		AddState(new BaseSleepState());
		AddState(new ChaseState());
		AddState(new BaseCooldownState());
		AddState(new MoveToPointState());
	}

	public override void InitializeAI()
	{
		base.InitializeAI();
		base.ThinkMode = AIThinkMode.Interval;
		thinkRate = 0.25f;
		base.PathFinder = new BasePathFinder();
		Count++;
	}

	public override void OnDestroy()
	{
		base.OnDestroy();
		Count--;
	}

	public BaseAnimalNPC GetEntity()
	{
		return GetBaseEntity() as BaseAnimalNPC;
	}
}


using UnityEngine;

public class AttackState : BasicAIState
{
	private IAIAttack attack;

	public AttackState()
		: base(AIState.Attack)
	{
		base.AgrresiveState = true;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		attack = entity as IAIAttack;
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		BasePlayer basePlayer = baseEntity as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null && basePlayer.IsDead())
		{
			StopAttacking();
		}
		else if ((Object)(object)baseEntity != (Object)null && baseEntity.Health() > 0f)
		{
			BaseCombatEntity target = baseEntity as BaseCombatEntity;
			Vector3 aimDirection = GetAimDirection(entity as BaseCombatEntity, target);
			brain.Navigator.SetFacingDirectionOverride(aimDirection);
			if (attack.CanAttack(baseEntity))
			{
				StartAttacking(baseEntity);
			}
			brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
		}
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		brain.Navigator.ClearFacingDirectionOverride();
		brain.Navigator.Stop();
		StopAttacking();
	}

	private void StopAttacking()
	{
		attack.StopAttacking();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if (attack == null)
		{
			return StateStatus.Error;
		}
		if ((Object)(object)baseEntity == (Object)null)
		{
			brain.Navigator.ClearFacingDirectionOverride();
			StopAttacking();
			return StateStatus.Finished;
		}
		if (baseEntity.Health() <= 0f)
		{
			StopAttacking();
			return StateStatus.Finished;
		}
		BasePlayer basePlayer = baseEntity as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null && basePlayer.IsDead())
		{
			StopAttacking();
			return StateStatus.Finished;
		}
		BaseVehicle baseVehicle = (((Object)(object)basePlayer != (Object)null) ? basePlayer.GetMountedVehicle() : null);
		if ((Object)(object)baseVehicle != (Object)null && baseVehicle is BaseModularVehicle)
		{
			StopAttacking();
			return StateStatus.Error;
		}
		if (brain.Senses.ignoreSafeZonePlayers && (Object)(object)basePlayer != (Object)null && basePlayer.InSafeZone())
		{
			return StateStatus.Error;
		}
		if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast, 0.25f, (baseEntity is BasePlayer && attack != null) ? attack.EngagementRange() : 0f))
		{
			return StateStatus.Error;
		}
		BaseCombatEntity target = baseEntity as BaseCombatEntity;
		Vector3 aimDirection = GetAimDirection(entity as BaseCombatEntity, target);
		brain.Navigator.SetFacingDirectionOverride(aimDirection);
		if (attack.CanAttack(baseEntity))
		{
			StartAttacking(baseEntity);
		}
		else
		{
			StopAttacking();
		}
		return StateStatus.Running;
	}

	private static Vector3 GetAimDirection(BaseCombatEntity from, BaseCombatEntity target)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)from == (Object)null || (Object)(object)target == (Object)null)
		{
			if (!((Object)(object)from != (Object)null))
			{
				return Vector3.forward;
			}
			return ((Component)from).transform.forward;
		}
		return Vector3Ex.Direction2D(((Component)target).transform.position, ((Component)from).transform.position);
	}

	private void StartAttacking(BaseEntity entity)
	{
		attack.StartAttacking(entity);
	}
}


using UnityEngine;

public class ChaseState : BasicAIState
{
	private IAIAttack attack;

	public ChaseState()
		: base(AIState.Chase)
	{
		base.AgrresiveState = true;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		attack = entity as IAIAttack;
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity != (Object)null)
		{
			brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
		}
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			Stop();
			return StateStatus.Error;
		}
		if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast, 0.25f, (baseEntity is BasePlayer && attack != null) ? attack.EngagementRange() : 0f))
		{
			return StateStatus.Error;
		}
		if (!brain.Navigator.Moving)
		{
			return StateStatus.Finished;
		}
		return StateStatus.Running;
	}
}


using UnityEngine;

public class FleeState : BasicAIState
{
	private float nextInterval = 2f;

	private float stopFleeDistance;

	public FleeState()
		: base(AIState.Flee)
	{
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity != (Object)null)
		{
			stopFleeDistance = Random.Range(80f, 100f) + Mathf.Clamp(Vector3Ex.Distance2D(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position), 0f, 50f);
		}
		FleeFrom(brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot), entity);
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			return StateStatus.Finished;
		}
		if (Vector3Ex.Distance2D(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position) >= stopFleeDistance)
		{
			return StateStatus.Finished;
		}
		if ((brain.Navigator.UpdateIntervalElapsed(nextInterval) || !brain.Navigator.Moving) && !FleeFrom(baseEntity, entity))
		{
			return StateStatus.Error;
		}
		return StateStatus.Running;
	}

	private bool FleeFrom(BaseEntity fleeFromEntity, BaseEntity thisEntity)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)thisEntity == (Object)null || (Object)(object)fleeFromEntity == (Object)null)
		{
			return false;
		}
		nextInterval = Random.Range(3f, 6f);
		if (!brain.PathFinder.GetBestFleePosition(brain.Navigator, brain.Senses, fleeFromEntity, brain.Events.Memory.Position.Get(4), 50f, 100f, out var result))
		{
			return false;
		}
		bool num = brain.Navigator.SetDestination(result, BaseNavigator.NavigationSpeed.Fast);
		if (!num)
		{
			Stop();
		}
		return num;
	}
}


using UnityEngine;

public class IdleState : BaseIdleState
{
	private float nextTurnTime;

	private float minTurnTime = 10f;

	private float maxTurnTime = 20f;

	private int turnChance = 33;

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateEnter(brain, entity);
		FaceNewDirection(entity);
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		brain.Navigator.ClearFacingDirectionOverride();
	}

	private void FaceNewDirection(BaseEntity entity)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (Random.Range(0, 100) <= turnChance)
		{
			Vector3 position = ((Component)entity).transform.position;
			Vector3 val = BasePathFinder.GetPointOnCircle(position, 1f, Random.Range(0f, 594f)) - position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			brain.Navigator.SetFacingDirectionOverride(normalized);
		}
		nextTurnTime = Time.realtimeSinceStartup + Random.Range(minTurnTime, maxTurnTime);
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		if (Time.realtimeSinceStartup >= nextTurnTime)
		{
			FaceNewDirection(entity);
		}
		return StateStatus.Running;
	}
}


using UnityEngine;

public class MoveToPointState : BasicAIState
{
	private float originalStopDistance;

	public MoveToPointState()
		: base(AIState.MoveToPoint)
	{
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateEnter(brain, entity);
		BaseNavigator navigator = brain.Navigator;
		originalStopDistance = navigator.StoppingDistance;
		navigator.StoppingDistance = 0.5f;
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		brain.Navigator.StoppingDistance = originalStopDistance;
		Stop();
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		Vector3 pos = brain.Events.Memory.Position.Get(6);
		if (!brain.Navigator.SetDestination(pos, ControlTestAnimalSpeed))
		{
			return StateStatus.Error;
		}
		if (!brain.Navigator.Moving)
		{
			return StateStatus.Finished;
		}
		return StateStatus.Running;
	}
}


public class MoveTowardsState : BaseMoveTorwardsState
{
}


using UnityEngine;

public class RoamState : BasicAIState
{
	private StateStatus status = StateStatus.Error;

	public RoamState()
		: base(AIState.Roam)
	{
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		status = StateStatus.Error;
		if (brain.PathFinder == null)
		{
			return;
		}
		Vector3 center;
		if (brain.InGroup() && !brain.IsGroupLeader)
		{
			center = brain.Events.Memory.Position.Get(5);
			center = BasePathFinder.GetPointOnCircle(center, Random.Range(2f, 7f), Random.Range(0f, 359f));
		}
		else
		{
			center = brain.PathFinder.GetBestRoamPosition(brain.Navigator, GetRoamAnchorPosition(), brain.Events.Memory.Position.Get(4), GetRoamPointMinDistance(), GetRoamPointMaxDistance());
		}
		if (brain.Navigator.SetDestination(center, BaseNavigator.NavigationSpeed.Slow))
		{
			if (brain.InGroup() && brain.IsGroupLeader)
			{
				brain.SetGroupRoamRootPosition(center);
			}
			status = StateStatus.Running;
		}
		else
		{
			status = StateStatus.Error;
		}
	}

	public virtual Vector3 GetRoamAnchorPosition()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if (brain.Navigator.MaxRoamDistanceFromHome > -1f)
		{
			return brain.Events.Memory.Position.Get(4);
		}
		return ((Component)brain.Navigator).transform.position;
	}

	public virtual float GetRoamPointMinDistance()
	{
		if (brain.Navigator.MaxRoamDistanceFromHome > -1f)
		{
			return 5f;
		}
		return 20f;
	}

	public virtual float GetRoamPointMaxDistance()
	{
		if (brain.Navigator.MaxRoamDistanceFromHome > -1f)
		{
			return brain.Navigator.MaxRoamDistanceFromHome;
		}
		return brain.Navigator.BestRoamPointMaxDistance;
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		if (status == StateStatus.Error)
		{
			return status;
		}
		if (brain.Navigator.Moving)
		{
			return StateStatus.Running;
		}
		return StateStatus.Finished;
	}
}


public class Bear : BaseAnimalNPC
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 2f;

	public override float RealisticMass => 150f;

	public override TraitFlag Traits => TraitFlag.Alive | TraitFlag.Animal | TraitFlag.Food | TraitFlag.Meat;

	public override bool WantsToEat(BaseEntity best)
	{
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		return base.WantsToEat(best);
	}

	public override string Categorize()
	{
		return "Bear";
	}
}


public class Polarbear : BaseAnimalNPC
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 1f;

	public override float RealisticMass => 150f;

	public override TraitFlag Traits => TraitFlag.Alive | TraitFlag.Animal | TraitFlag.Food | TraitFlag.Meat;

	public override bool WantsToEat(BaseEntity best)
	{
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		return base.WantsToEat(best);
	}

	public override string Categorize()
	{
		return "Polarbear";
	}
}


using UnityEngine;

public class Boar : BaseAnimalNPC
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 5f;

	public override float RealisticMass => 85f;

	public override TraitFlag Traits => TraitFlag.Alive | TraitFlag.Animal | TraitFlag.Food | TraitFlag.Meat;

	public override bool WantsToEat(BaseEntity best)
	{
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		if (best.HasTrait(TraitFlag.Meat))
		{
			return false;
		}
		CollectibleEntity collectibleEntity = best as CollectibleEntity;
		if ((Object)(object)collectibleEntity != (Object)null)
		{
			ItemAmount[] itemList = collectibleEntity.itemList;
			for (int i = 0; i < itemList.Length; i++)
			{
				if (itemList[i].itemDef.category == ItemCategory.Food)
				{
					return true;
				}
			}
		}
		return base.WantsToEat(best);
	}

	public override string Categorize()
	{
		return "Boar";
	}
}


using System;
using UnityEngine;

public class Chicken : BaseAnimalNPC
{
	public class EggDropWorkQueue : ObjectWorkQueue<Chicken>
	{
		protected override void RunJob(Chicken entity)
		{
			if (((ObjectWorkQueue<Chicken>)this).ShouldAdd(entity))
			{
				entity.CheckEggDrop();
			}
		}

		protected override bool ShouldAdd(Chicken entity)
		{
			if (base.ShouldAdd(entity))
			{
				return entity.IsValid();
			}
			return false;
		}
	}

	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 3f;

	public ItemDefinition EggDefinition;

	public float EggDropFrequency = 30f;

	public Vector3 EggDropLocalPos;

	public static EggDropWorkQueue EggWorkQueue = new EggDropWorkQueue();

	public override float RealisticMass => 3f;

	public override TraitFlag Traits => TraitFlag.Alive | TraitFlag.Animal | TraitFlag.Food | TraitFlag.Meat;

	public override void ServerInit()
	{
		base.ServerInit();
		if ((Object)(object)EggDefinition != (Object)null)
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)QueueEggDropCheck, EggDropFrequency, EggDropFrequency, EggDropFrequency * 0.5f);
		}
	}

	private void QueueEggDropCheck()
	{
		((ObjectWorkQueue<Chicken>)EggWorkQueue).Add(this);
	}

	public override bool WantsToEat(BaseEntity best)
	{
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		if (best.HasTrait(TraitFlag.Meat))
		{
			return false;
		}
		CollectibleEntity collectibleEntity = best as CollectibleEntity;
		if ((Object)(object)collectibleEntity != (Object)null)
		{
			ItemAmount[] itemList = collectibleEntity.itemList;
			for (int i = 0; i < itemList.Length; i++)
			{
				if (itemList[i].itemDef.category == ItemCategory.Food)
				{
					return true;
				}
			}
		}
		return base.WantsToEat(best);
	}

	private void CheckEggDrop()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer && Random.Range(0, 100) > 50 && (Object)(object)((Component)this).transform != (Object)null && BaseNetworkable.HasCloseConnections(((Component)this).transform.position, 100f))
		{
			SpawnEgg();
		}
	}

	public void SpawnEgg()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)EggDefinition != (Object)null)
		{
			ItemManager.Create(EggDefinition, 1, 0uL).Drop(((Component)this).transform.TransformPoint(EggDropLocalPos), -((Component)this).transform.forward);
		}
	}

	public override string Categorize()
	{
		return "Chicken";
	}
}


public class EggDropWorkQueue : ObjectWorkQueue<Chicken>
{
	protected override void RunJob(Chicken entity)
	{
		if (((ObjectWorkQueue<Chicken>)this).ShouldAdd(entity))
		{
			entity.CheckEggDrop();
		}
	}

	protected override bool ShouldAdd(Chicken entity)
	{
		if (base.ShouldAdd(entity))
		{
			return entity.IsValid();
		}
		return false;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class FishBrain : BaseAIBrain
{
	public class IdleState : BaseIdleState
	{
		private StateStatus status = StateStatus.Error;

		private List<Vector3> idlePoints;

		private int currentPointIndex;

		private Vector3 idleRootPos;

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			idleRootPos = ((Component)brain.Navigator).transform.position;
			GenerateIdlePoints(20f, 0f);
			currentPointIndex = 0;
			status = StateStatus.Error;
			if (brain.PathFinder != null)
			{
				if (brain.Navigator.SetDestination(idleRootPos + idlePoints[0], BaseNavigator.NavigationSpeed.Normal))
				{
					status = StateStatus.Running;
				}
				else
				{
					status = StateStatus.Error;
				}
			}
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			if (Vector3.Distance(((Component)brain.Navigator).transform.position, idleRootPos + idlePoints[currentPointIndex]) < 4f)
			{
				currentPointIndex++;
			}
			if (currentPointIndex >= idlePoints.Count)
			{
				currentPointIndex = 0;
			}
			if (brain.Navigator.SetDestination(idleRootPos + idlePoints[currentPointIndex], BaseNavigator.NavigationSpeed.Normal))
			{
				status = StateStatus.Running;
			}
			else
			{
				status = StateStatus.Error;
			}
			return status;
		}

		private void GenerateIdlePoints(float radius, float heightOffset)
		{
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			if (idlePoints == null)
			{
				idlePoints = new List<Vector3>();
				float num = 0f;
				int num2 = 32;
				(float, float) waterAndTerrainSurface = WaterLevel.GetWaterAndTerrainSurface(((Component)brain.Navigator).transform.position, waves: false, volumes: false);
				float item = waterAndTerrainSurface.Item1;
				float item2 = waterAndTerrainSurface.Item2;
				for (int i = 0; i < num2; i++)
				{
					num += 360f / (float)num2;
					Vector3 pointOnCircle = BasePathFinder.GetPointOnCircle(Vector3.zero, radius, num);
					pointOnCircle.y += Random.Range(0f - heightOffset, heightOffset);
					pointOnCircle.y = Mathf.Clamp(pointOnCircle.y, item2, item);
					idlePoints.Add(pointOnCircle);
				}
			}
		}
	}

	public class RoamState : BasicAIState
	{
		private StateStatus status = StateStatus.Error;

		public RoamState()
			: base(AIState.Roam)
		{
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			status = StateStatus.Error;
			if (brain.PathFinder != null)
			{
				Vector3 fallbackPos = brain.Events.Memory.Position.Get(4);
				Vector3 bestRoamPosition = brain.PathFinder.GetBestRoamPosition(brain.Navigator, ((Component)brain.Navigator).transform.position, fallbackPos, 5f, brain.Navigator.MaxRoamDistanceFromHome);
				if (brain.Navigator.SetDestination(bestRoamPosition, BaseNavigator.NavigationSpeed.Normal))
				{
					status = StateStatus.Running;
				}
				else
				{
					status = StateStatus.Error;
				}
			}
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			base.StateThink(delta, brain, entity);
			if (status == StateStatus.Error)
			{
				return status;
			}
			if (brain.Navigator.Moving)
			{
				return StateStatus.Running;
			}
			return StateStatus.Finished;
		}
	}

	public static int Count;

	public override void AddStates()
	{
		base.AddStates();
		AddState(new IdleState());
		AddState(new RoamState());
		AddState(new BaseFleeState());
		AddState(new BaseChaseState());
		AddState(new BaseMoveTorwardsState());
		AddState(new BaseAttackState());
		AddState(new BaseCooldownState());
	}

	public override void InitializeAI()
	{
		base.InitializeAI();
		base.ThinkMode = AIThinkMode.Interval;
		thinkRate = 0.25f;
		base.PathFinder = new UnderwaterPathFinder();
		((UnderwaterPathFinder)base.PathFinder).Init(GetBaseEntity());
		Count++;
	}

	public override void OnDestroy()
	{
		base.OnDestroy();
		Count--;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class IdleState : BaseIdleState
{
	private StateStatus status = StateStatus.Error;

	private List<Vector3> idlePoints;

	private int currentPointIndex;

	private Vector3 idleRootPos;

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		idleRootPos = ((Component)brain.Navigator).transform.position;
		GenerateIdlePoints(20f, 0f);
		currentPointIndex = 0;
		status = StateStatus.Error;
		if (brain.PathFinder != null)
		{
			if (brain.Navigator.SetDestination(idleRootPos + idlePoints[0], BaseNavigator.NavigationSpeed.Normal))
			{
				status = StateStatus.Running;
			}
			else
			{
				status = StateStatus.Error;
			}
		}
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		if (Vector3.Distance(((Component)brain.Navigator).transform.position, idleRootPos + idlePoints[currentPointIndex]) < 4f)
		{
			currentPointIndex++;
		}
		if (currentPointIndex >= idlePoints.Count)
		{
			currentPointIndex = 0;
		}
		if (brain.Navigator.SetDestination(idleRootPos + idlePoints[currentPointIndex], BaseNavigator.NavigationSpeed.Normal))
		{
			status = StateStatus.Running;
		}
		else
		{
			status = StateStatus.Error;
		}
		return status;
	}

	private void GenerateIdlePoints(float radius, float heightOffset)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		if (idlePoints == null)
		{
			idlePoints = new List<Vector3>();
			float num = 0f;
			int num2 = 32;
			(float, float) waterAndTerrainSurface = WaterLevel.GetWaterAndTerrainSurface(((Component)brain.Navigator).transform.position, waves: false, volumes: false);
			float item = waterAndTerrainSurface.Item1;
			float item2 = waterAndTerrainSurface.Item2;
			for (int i = 0; i < num2; i++)
			{
				num += 360f / (float)num2;
				Vector3 pointOnCircle = BasePathFinder.GetPointOnCircle(Vector3.zero, radius, num);
				pointOnCircle.y += Random.Range(0f - heightOffset, heightOffset);
				pointOnCircle.y = Mathf.Clamp(pointOnCircle.y, item2, item);
				idlePoints.Add(pointOnCircle);
			}
		}
	}
}


using UnityEngine;

public class RoamState : BasicAIState
{
	private StateStatus status = StateStatus.Error;

	public RoamState()
		: base(AIState.Roam)
	{
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		status = StateStatus.Error;
		if (brain.PathFinder != null)
		{
			Vector3 fallbackPos = brain.Events.Memory.Position.Get(4);
			Vector3 bestRoamPosition = brain.PathFinder.GetBestRoamPosition(brain.Navigator, ((Component)brain.Navigator).transform.position, fallbackPos, 5f, brain.Navigator.MaxRoamDistanceFromHome);
			if (brain.Navigator.SetDestination(bestRoamPosition, BaseNavigator.NavigationSpeed.Normal))
			{
				status = StateStatus.Running;
			}
			else
			{
				status = StateStatus.Error;
			}
		}
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		if (status == StateStatus.Error)
		{
			return status;
		}
		if (brain.Navigator.Moving)
		{
			return StateStatus.Running;
		}
		return StateStatus.Finished;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Rust;
using Rust.Ai;
using UnityEngine;

public class SimpleShark : BaseCombatEntity
{
	public class SimpleState
	{
		public SimpleShark entity;

		private float stateEnterTime;

		public SimpleState(SimpleShark owner)
		{
			entity = owner;
		}

		public virtual float State_Weight()
		{
			return 0f;
		}

		public virtual void State_Enter()
		{
			stateEnterTime = Time.realtimeSinceStartup;
		}

		public virtual void State_Think(float delta)
		{
		}

		public virtual void State_Exit()
		{
		}

		public virtual bool CanInterrupt()
		{
			return true;
		}

		public virtual float TimeInState()
		{
			return Time.realtimeSinceStartup - stateEnterTime;
		}
	}

	public class IdleState : SimpleState
	{
		private int patrolTargetIndex;

		public IdleState(SimpleShark owner)
			: base(owner)
		{
		}

		public Vector3 GetTargetPatrolPosition()
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			return entity.patrolPath[patrolTargetIndex];
		}

		public override float State_Weight()
		{
			return 1f;
		}

		public override void State_Enter()
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			float num = float.PositiveInfinity;
			int num2 = 0;
			for (int i = 0; i < entity.patrolPath.Count; i++)
			{
				float num3 = Vector3.Distance(entity.patrolPath[i], ((Component)entity).transform.position);
				if (num3 < num)
				{
					num2 = i;
					num = num3;
				}
			}
			patrolTargetIndex = num2;
			base.State_Enter();
		}

		public override void State_Think(float delta)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			if (Vector3.Distance(GetTargetPatrolPosition(), ((Component)entity).transform.position) < entity.stoppingDistance)
			{
				patrolTargetIndex++;
				if (patrolTargetIndex >= entity.patrolPath.Count)
				{
					patrolTargetIndex = 0;
				}
			}
			if (entity.TimeSinceAttacked() >= 120f && entity.healthFraction < 1f)
			{
				entity.health = entity.MaxHealth();
			}
			entity.destination = entity.WaterClamp(GetTargetPatrolPosition());
		}

		public override void State_Exit()
		{
			base.State_Exit();
		}

		public override bool CanInterrupt()
		{
			return true;
		}
	}

	public class AttackState : SimpleState
	{
		public AttackState(SimpleShark owner)
			: base(owner)
		{
		}

		public override float State_Weight()
		{
			if (!entity.HasTarget() || !entity.CanAttack())
			{
				return 0f;
			}
			return 10f;
		}

		public override void State_Enter()
		{
			base.State_Enter();
		}

		public override void State_Think(float delta)
		{
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_0105: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			BasePlayer target = entity.GetTarget();
			if ((Object)(object)target == (Object)null)
			{
				return;
			}
			if (TimeInState() >= 10f)
			{
				entity.nextAttackTime = Time.realtimeSinceStartup + 4f;
				entity.Startle();
				return;
			}
			if (entity.CanAttack())
			{
				entity.Startle();
			}
			float num = Vector3.Distance(entity.GetTarget().eyes.position, ((Component)entity).transform.position);
			bool num2 = num < 4f;
			if (entity.CanAttack() && num <= 2f)
			{
				entity.DoAttack();
			}
			if (!num2)
			{
				Vector3 val = Vector3Ex.Direction(entity.GetTarget().eyes.position, ((Component)entity).transform.position);
				Vector3 point = target.eyes.position + val * 10f;
				point = entity.WaterClamp(point);
				entity.destination = point;
			}
		}

		public override void State_Exit()
		{
			base.State_Exit();
		}

		public override bool CanInterrupt()
		{
			return true;
		}
	}

	public Vector3 destination;

	public float minSpeed;

	public float maxSpeed;

	public float idealDepth;

	public float minTurnSpeed = 0.25f;

	public float maxTurnSpeed = 2f;

	public float attackCooldown = 7f;

	public float aggroRange = 15f;

	public float obstacleDetectionRadius = 1f;

	public Animator animator;

	public GameObjectRef bloodCloud;

	public GameObjectRef corpsePrefab;

	private const string SPEARGUN_KILL_STAT = "shark_speargun_kills";

	[ServerVar]
	public static float forceSurfaceAmount = 0f;

	[ServerVar]
	public static bool disable = false;

	private Vector3 spawnPos;

	private float stoppingDistance = 3f;

	private float currentSpeed;

	private float lastStartleTime;

	private float startleDuration = 1f;

	private SimpleState[] states;

	private SimpleState _currentState;

	private bool sleeping;

	private List<Vector3> patrolPath = new List<Vector3>();

	private BasePlayer target;

	private float lastSeenTargetTime;

	private float nextTargetSearchTime;

	private static BasePlayer[] playerQueryResults = new BasePlayer[64];

	private float minFloorDist = 2f;

	private float minSurfaceDist = 1f;

	private float lastTimeAttacked;

	public float nextAttackTime;

	private Vector3 cachedObstacleNormal;

	private float cachedObstacleDistance;

	private float obstacleAvoidanceScale;

	private float obstacleDetectionRange = 5f;

	private float timeSinceLastObstacleCheck;

	public override bool IsNpc => true;

	private void GenerateIdlePoints(Vector3 center, float radius, float heightOffset, float staggerOffset = 0f)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		patrolPath.Clear();
		float num = 0f;
		int num2 = 32;
		int num3 = 10551553;
		(float, float) waterAndTerrainSurface = WaterLevel.GetWaterAndTerrainSurface(center, waves: false, volumes: false);
		float item = waterAndTerrainSurface.Item1;
		float item2 = waterAndTerrainSurface.Item2;
		RaycastHit val2 = default(RaycastHit);
		for (int i = 0; i < num2; i++)
		{
			num += 360f / (float)num2;
			float radius2 = 1f;
			Vector3 pointOnCircle = BasePathFinder.GetPointOnCircle(center, radius2, num);
			Vector3 val = Vector3Ex.Direction(pointOnCircle, center);
			pointOnCircle = ((!Physics.SphereCast(center, obstacleDetectionRadius, val, ref val2, radius + staggerOffset, num3)) ? (center + val * radius) : (center + val * (((RaycastHit)(ref val2)).distance - 6f)));
			if (staggerOffset != 0f)
			{
				pointOnCircle += val * Random.Range(0f - staggerOffset, staggerOffset);
			}
			pointOnCircle.y += Random.Range(0f - heightOffset, heightOffset);
			pointOnCircle.y = Mathf.Clamp(pointOnCircle.y, item2 + 3f, item - 3f);
			patrolPath.Add(pointOnCircle);
		}
	}

	private void GenerateIdlePoints_Shrinkwrap(Vector3 center, float radius, float heightOffset, float staggerOffset = 0f)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		patrolPath.Clear();
		float num = 0f;
		int num2 = 32;
		int num3 = 10551553;
		(float, float) waterAndTerrainSurface = WaterLevel.GetWaterAndTerrainSurface(center, waves: false, volumes: false);
		float item = waterAndTerrainSurface.Item1;
		float item2 = waterAndTerrainSurface.Item2;
		RaycastHit val2 = default(RaycastHit);
		for (int i = 0; i < num2; i++)
		{
			num += 360f / (float)num2;
			float radius2 = radius * 2f;
			Vector3 pointOnCircle = BasePathFinder.GetPointOnCircle(center, radius2, num);
			Vector3 val = Vector3Ex.Direction(center, pointOnCircle);
			pointOnCircle = ((!Physics.SphereCast(pointOnCircle, obstacleDetectionRadius, val, ref val2, radius + staggerOffset, num3)) ? (pointOnCircle + val * radius) : (((RaycastHit)(ref val2)).point - val * 6f));
			if (staggerOffset != 0f)
			{
				pointOnCircle += val * Random.Range(0f - staggerOffset, staggerOffset);
			}
			pointOnCircle.y += Random.Range(0f - heightOffset, heightOffset);
			pointOnCircle.y = Mathf.Clamp(pointOnCircle.y, item2 + 3f, item - 3f);
			patrolPath.Add(pointOnCircle);
		}
	}

	public override void ServerInit()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (disable)
		{
			((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0.01f);
			return;
		}
		((Component)this).transform.position = WaterClamp(((Component)this).transform.position);
		Init();
		((FacepunchBehaviour)this).InvokeRandomized((Action)CheckSleepState, 0f, 1f, 0.5f);
	}

	public void CheckSleepState()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		bool flag = BaseNetworkable.HasCloseConnections(((Component)this).transform.position, 100f);
		sleeping = !flag;
	}

	public void Init()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		GenerateIdlePoints_Shrinkwrap(((Component)this).transform.position, 20f, 2f, 3f);
		states = new SimpleState[2];
		states[0] = new IdleState(this);
		states[1] = new AttackState(this);
		((Component)this).transform.position = patrolPath[0];
	}

	private void Think(float delta)
	{
		if (states == null)
		{
			return;
		}
		if (disable)
		{
			if (!((FacepunchBehaviour)this).IsInvoking((Action)base.KillMessage))
			{
				((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0.01f);
			}
		}
		else
		{
			if (sleeping)
			{
				return;
			}
			SimpleState simpleState = null;
			float num = -1f;
			SimpleState[] array = states;
			foreach (SimpleState simpleState2 in array)
			{
				float num2 = simpleState2.State_Weight();
				if (num2 > num)
				{
					simpleState = simpleState2;
					num = num2;
				}
			}
			if (simpleState != _currentState && (_currentState == null || _currentState.CanInterrupt()))
			{
				if (_currentState != null)
				{
					_currentState.State_Exit();
				}
				simpleState.State_Enter();
				_currentState = simpleState;
			}
			UpdateTarget(delta);
			_currentState.State_Think(delta);
			UpdateObstacleAvoidance(delta);
			UpdateDirection(delta);
			UpdateSpeed(delta);
			UpdatePosition(delta);
			SetFlag(Flags.Open, HasTarget() && CanAttack());
		}
	}

	public Vector3 WaterClamp(Vector3 point)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		(float, float) waterAndTerrainSurface = WaterLevel.GetWaterAndTerrainSurface(point, waves: false, volumes: false);
		float item = waterAndTerrainSurface.Item1;
		float num = waterAndTerrainSurface.Item2 + minFloorDist;
		float num2 = item - minSurfaceDist;
		if (forceSurfaceAmount != 0f)
		{
			item = WaterLevel.GetWaterSurface(point, waves: false, volumes: false);
			num = (num2 = item + forceSurfaceAmount);
		}
		point.y = Mathf.Clamp(point.y, num, num2);
		return point;
	}

	public bool ValidTarget(BasePlayer newTarget)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		if (AI.ignoreplayers || SimpleAIMemory.PlayerIgnoreList.Contains(newTarget))
		{
			return false;
		}
		float num = Vector3.Distance(newTarget.eyes.position, ((Component)this).transform.position);
		Vector3 val = Vector3Ex.Direction(newTarget.eyes.position, ((Component)this).transform.position);
		int num2 = 10551552;
		if (Physics.Raycast(((Component)this).transform.position, val, num, num2))
		{
			return false;
		}
		if (newTarget.isMounted)
		{
			if (Object.op_Implicit((Object)(object)newTarget.GetMountedVehicle()))
			{
				return false;
			}
			WaterInflatable component = ((Component)newTarget.GetMounted()).GetComponent<WaterInflatable>();
			if ((Object)(object)component != (Object)null && !((Behaviour)component.buoyancy).enabled)
			{
				return false;
			}
		}
		else if (!WaterLevel.Test(newTarget.CenterPoint(), waves: true, volumes: false, newTarget))
		{
			return false;
		}
		return true;
	}

	public void ClearTarget()
	{
		target = null;
		lastSeenTargetTime = 0f;
	}

	public override void OnDied(HitInfo hitInfo = null)
	{
		if (base.isServer)
		{
			if (GameInfo.HasAchievements && hitInfo != null && (Object)(object)hitInfo.InitiatorPlayer != (Object)null && !hitInfo.InitiatorPlayer.IsNpc && (Object)(object)hitInfo.Weapon != (Object)null && hitInfo.Weapon.ShortPrefabName.Contains("speargun"))
			{
				hitInfo.InitiatorPlayer.stats.Add("shark_speargun_kills", 1, Stats.All);
				hitInfo.InitiatorPlayer.stats.Save(forceSteamSave: true);
			}
			BaseCorpse baseCorpse = DropCorpse(corpsePrefab.resourcePath);
			if (Object.op_Implicit((Object)(object)baseCorpse))
			{
				baseCorpse.Spawn();
				baseCorpse.TakeChildren(this);
			}
			((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0.5f);
		}
		base.OnDied(hitInfo);
	}

	public void UpdateTarget(float delta)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)target != (Object)null)
		{
			bool flag = Vector3.Distance(target.eyes.position, ((Component)this).transform.position) > aggroRange * 2f;
			bool flag2 = Time.realtimeSinceStartup > lastSeenTargetTime + 4f;
			if (!ValidTarget(target) || flag || flag2)
			{
				ClearTarget();
			}
			else
			{
				lastSeenTargetTime = Time.realtimeSinceStartup;
			}
		}
		if (Time.realtimeSinceStartup < nextTargetSearchTime || !((Object)(object)target == (Object)null))
		{
			return;
		}
		nextTargetSearchTime = Time.realtimeSinceStartup + 1f;
		if (!BaseNetworkable.HasCloseConnections(((Component)this).transform.position, aggroRange))
		{
			return;
		}
		int playersInSphereFast = Query.Server.GetPlayersInSphereFast(((Component)this).transform.position, aggroRange, playerQueryResults);
		for (int i = 0; i < playersInSphereFast; i++)
		{
			BasePlayer basePlayer = playerQueryResults[i];
			if (!basePlayer.isClient && ValidTarget(basePlayer))
			{
				target = basePlayer;
				lastSeenTargetTime = Time.realtimeSinceStartup;
				break;
			}
		}
	}

	public float TimeSinceAttacked()
	{
		return Time.realtimeSinceStartup - lastTimeAttacked;
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		lastTimeAttacked = Time.realtimeSinceStartup;
		if (info.damageTypes.Total() > 20f)
		{
			Startle();
		}
		if ((Object)(object)info.InitiatorPlayer != (Object)null && (Object)(object)target == (Object)null && ValidTarget(info.InitiatorPlayer))
		{
			target = info.InitiatorPlayer;
			lastSeenTargetTime = Time.realtimeSinceStartup;
		}
	}

	public bool HasTarget()
	{
		return (Object)(object)target != (Object)null;
	}

	public BasePlayer GetTarget()
	{
		return target;
	}

	public override string Categorize()
	{
		return "Shark";
	}

	public bool CanAttack()
	{
		return Time.realtimeSinceStartup > nextAttackTime;
	}

	public void DoAttack()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if (HasTarget())
		{
			GetTarget().Hurt(Random.Range(30f, 70f), DamageType.Bite, this);
			Vector3 posWorld = WaterClamp(GetTarget().CenterPoint());
			Effect.server.Run(bloodCloud.resourcePath, posWorld, Vector3.forward);
			nextAttackTime = Time.realtimeSinceStartup + attackCooldown;
		}
	}

	public void Startle()
	{
		lastStartleTime = Time.realtimeSinceStartup;
	}

	public bool IsStartled()
	{
		return lastStartleTime + startleDuration > Time.realtimeSinceStartup;
	}

	private float GetDesiredSpeed()
	{
		if (!IsStartled())
		{
			return minSpeed;
		}
		return maxSpeed;
	}

	public float GetTurnSpeed()
	{
		if (IsStartled())
		{
			return maxTurnSpeed;
		}
		if (obstacleAvoidanceScale != 0f)
		{
			return Mathf.Lerp(minTurnSpeed, maxTurnSpeed, obstacleAvoidanceScale);
		}
		return minTurnSpeed;
	}

	private float GetCurrentSpeed()
	{
		return currentSpeed;
	}

	private void UpdateObstacleAvoidance(float delta)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		timeSinceLastObstacleCheck += delta;
		if (timeSinceLastObstacleCheck < 0.5f)
		{
			return;
		}
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 position = ((Component)this).transform.position;
		int num = 1503764737;
		RaycastHit val = default(RaycastHit);
		if (Physics.SphereCast(position, obstacleDetectionRadius, forward, ref val, obstacleDetectionRange, num))
		{
			Vector3 point = ((RaycastHit)(ref val)).point;
			Vector3 val2 = Vector3.zero;
			Vector3 val3 = Vector3.zero;
			RaycastHit val4 = default(RaycastHit);
			if (Physics.SphereCast(position + Vector3.down * 0.25f + ((Component)this).transform.right * 0.25f, obstacleDetectionRadius, forward, ref val4, obstacleDetectionRange, num))
			{
				val2 = ((RaycastHit)(ref val4)).point;
			}
			RaycastHit val5 = default(RaycastHit);
			if (Physics.SphereCast(position + Vector3.down * 0.25f - ((Component)this).transform.right * 0.25f, obstacleDetectionRadius, forward, ref val5, obstacleDetectionRange, num))
			{
				val3 = ((RaycastHit)(ref val5)).point;
			}
			if (val2 != Vector3.zero && val3 != Vector3.zero)
			{
				Plane val6 = default(Plane);
				((Plane)(ref val6))..ctor(point, val2, val3);
				Vector3 normal = ((Plane)(ref val6)).normal;
				if (normal != Vector3.zero)
				{
					((RaycastHit)(ref val)).normal = normal;
				}
			}
			cachedObstacleNormal = ((RaycastHit)(ref val)).normal;
			cachedObstacleDistance = ((RaycastHit)(ref val)).distance;
			obstacleAvoidanceScale = 1f - Mathf.InverseLerp(2f, obstacleDetectionRange * 0.75f, ((RaycastHit)(ref val)).distance);
		}
		else
		{
			obstacleAvoidanceScale = Mathf.MoveTowards(obstacleAvoidanceScale, 0f, timeSinceLastObstacleCheck * 2f);
			if (obstacleAvoidanceScale == 0f)
			{
				cachedObstacleDistance = 0f;
			}
		}
		timeSinceLastObstacleCheck = 0f;
	}

	private void UpdateDirection(float delta)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		_ = ((Component)this).transform.forward;
		Vector3 val = Vector3Ex.Direction(WaterClamp(destination), ((Component)this).transform.position);
		if (obstacleAvoidanceScale != 0f)
		{
			Vector3 val3;
			if (cachedObstacleNormal != Vector3.zero)
			{
				Vector3 val2 = QuaternionEx.LookRotationForcedUp(cachedObstacleNormal, Vector3.up) * Vector3.forward;
				val3 = ((!(Vector3.Dot(val2, ((Component)this).transform.right) > Vector3.Dot(val2, -((Component)this).transform.right))) ? (-((Component)this).transform.right) : ((Component)this).transform.right);
			}
			else
			{
				val3 = ((Component)this).transform.right;
			}
			val = val3 * obstacleAvoidanceScale;
			((Vector3)(ref val)).Normalize();
		}
		if (val != Vector3.zero)
		{
			Quaternion val4 = Quaternion.LookRotation(val, Vector3.up);
			((Component)this).transform.rotation = Quaternion.Lerp(((Component)this).transform.rotation, val4, delta * GetTurnSpeed());
		}
	}

	private void UpdatePosition(float delta)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 point = ((Component)this).transform.position + forward * GetCurrentSpeed() * delta;
		point = WaterClamp(point);
		((Component)this).transform.position = point;
	}

	private void UpdateSpeed(float delta)
	{
		currentSpeed = Mathf.Lerp(currentSpeed, GetDesiredSpeed(), delta * 4f);
	}

	public void Update()
	{
		if (base.isServer)
		{
			Think(Time.deltaTime);
		}
	}
}


using UnityEngine;

public class SimpleState
{
	public SimpleShark entity;

	private float stateEnterTime;

	public SimpleState(SimpleShark owner)
	{
		entity = owner;
	}

	public virtual float State_Weight()
	{
		return 0f;
	}

	public virtual void State_Enter()
	{
		stateEnterTime = Time.realtimeSinceStartup;
	}

	public virtual void State_Think(float delta)
	{
	}

	public virtual void State_Exit()
	{
	}

	public virtual bool CanInterrupt()
	{
		return true;
	}

	public virtual float TimeInState()
	{
		return Time.realtimeSinceStartup - stateEnterTime;
	}
}


using UnityEngine;

public class IdleState : SimpleState
{
	private int patrolTargetIndex;

	public IdleState(SimpleShark owner)
		: base(owner)
	{
	}

	public Vector3 GetTargetPatrolPosition()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return entity.patrolPath[patrolTargetIndex];
	}

	public override float State_Weight()
	{
		return 1f;
	}

	public override void State_Enter()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		float num = float.PositiveInfinity;
		int num2 = 0;
		for (int i = 0; i < entity.patrolPath.Count; i++)
		{
			float num3 = Vector3.Distance(entity.patrolPath[i], ((Component)entity).transform.position);
			if (num3 < num)
			{
				num2 = i;
				num = num3;
			}
		}
		patrolTargetIndex = num2;
		base.State_Enter();
	}

	public override void State_Think(float delta)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3.Distance(GetTargetPatrolPosition(), ((Component)entity).transform.position) < entity.stoppingDistance)
		{
			patrolTargetIndex++;
			if (patrolTargetIndex >= entity.patrolPath.Count)
			{
				patrolTargetIndex = 0;
			}
		}
		if (entity.TimeSinceAttacked() >= 120f && entity.healthFraction < 1f)
		{
			entity.health = entity.MaxHealth();
		}
		entity.destination = entity.WaterClamp(GetTargetPatrolPosition());
	}

	public override void State_Exit()
	{
		base.State_Exit();
	}

	public override bool CanInterrupt()
	{
		return true;
	}
}


using UnityEngine;

public class AttackState : SimpleState
{
	public AttackState(SimpleShark owner)
		: base(owner)
	{
	}

	public override float State_Weight()
	{
		if (!entity.HasTarget() || !entity.CanAttack())
		{
			return 0f;
		}
		return 10f;
	}

	public override void State_Enter()
	{
		base.State_Enter();
	}

	public override void State_Think(float delta)
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer target = entity.GetTarget();
		if ((Object)(object)target == (Object)null)
		{
			return;
		}
		if (TimeInState() >= 10f)
		{
			entity.nextAttackTime = Time.realtimeSinceStartup + 4f;
			entity.Startle();
			return;
		}
		if (entity.CanAttack())
		{
			entity.Startle();
		}
		float num = Vector3.Distance(entity.GetTarget().eyes.position, ((Component)entity).transform.position);
		bool num2 = num < 4f;
		if (entity.CanAttack() && num <= 2f)
		{
			entity.DoAttack();
		}
		if (!num2)
		{
			Vector3 val = Vector3Ex.Direction(entity.GetTarget().eyes.position, ((Component)entity).transform.position);
			Vector3 point = target.eyes.position + val * 10f;
			point = entity.WaterClamp(point);
			entity.destination = point;
		}
	}

	public override void State_Exit()
	{
		base.State_Exit();
	}

	public override bool CanInterrupt()
	{
		return true;
	}
}


using System;
using System.Collections.Generic;
using Rust;
using UnityEngine;

public class BasePet : NPCPlayer, IThinker
{
	public static Dictionary<ulong, BasePet> ActivePetByOwnerID = new Dictionary<ulong, BasePet>();

	[ServerVar]
	public static bool queuedMovementsAllowed = true;

	[ServerVar]
	public static bool onlyQueueBaseNavMovements = true;

	[Help("How many miliseconds to budget for processing pet movements per frame")]
	[ServerVar]
	public static float movementupdatebudgetms = 1f;

	public float BaseAttackRate = 2f;

	public float BaseAttackDamge = 20f;

	public DamageType AttackDamageType = DamageType.Slash;

	public GameObjectRef mapMarkerPrefab;

	private BaseEntity _mapMarkerInstance;

	[NonSerialized]
	[HideInInspector]
	public bool inQueue;

	public static Queue<BasePet> _movementProcessQueue = new Queue<BasePet>();

	public PetBrain Brain { get; protected set; }

	public override float StartHealth()
	{
		return startHealth;
	}

	public override float StartMaxHealth()
	{
		return startHealth;
	}

	public override float MaxHealth()
	{
		return _maxHealth;
	}

	public static void ProcessMovementQueue()
	{
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		float num = movementupdatebudgetms / 1000f;
		while (_movementProcessQueue.Count > 0 && Time.realtimeSinceStartup < realtimeSinceStartup + num)
		{
			BasePet basePet = _movementProcessQueue.Dequeue();
			if ((Object)(object)basePet != (Object)null)
			{
				basePet.DoBudgetedMoveUpdate();
				basePet.inQueue = false;
			}
		}
	}

	public void DoBudgetedMoveUpdate()
	{
		if ((Object)(object)Brain != (Object)null)
		{
			Brain.DoMovementTick();
		}
	}

	public override bool IsLoadBalanced()
	{
		return true;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		Brain = ((Component)this).GetComponent<PetBrain>();
		if (!base.isClient)
		{
			AIThinkManager.AddPet(this);
		}
	}

	public void CreateMapMarker()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)_mapMarkerInstance != (Object)null)
		{
			_mapMarkerInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(mapMarkerPrefab?.resourcePath, Vector3.zero, Quaternion.identity);
		baseEntity.OwnerID = base.OwnerID;
		baseEntity.Spawn();
		baseEntity.SetParent(this);
		_mapMarkerInstance = baseEntity;
	}

	internal override void DoServerDestroy()
	{
		if ((Object)(object)Brain.OwningPlayer != (Object)null)
		{
			Brain.OwningPlayer.ClearClientPetLink();
		}
		AIThinkManager.RemovePet(this);
		base.DoServerDestroy();
	}

	public virtual void TryThink()
	{
		ServerThink_Internal();
	}

	public override void ServerThink(float delta)
	{
		base.ServerThink(delta);
		if (Brain.ShouldServerThink())
		{
			Brain.DoThink();
		}
	}

	public void ApplyPetStatModifiers()
	{
		if ((Object)(object)base.inventory == (Object)null)
		{
			return;
		}
		for (int i = 0; i < base.inventory.containerWear.capacity; i++)
		{
			Item slot = base.inventory.containerWear.GetSlot(i);
			if (slot != null)
			{
				ItemModPetStats component = ((Component)slot.info).GetComponent<ItemModPetStats>();
				if ((Object)(object)component != (Object)null)
				{
					component.Apply(this);
				}
			}
		}
		Heal(MaxHealth());
	}

	private void OnPhysicsNeighbourChanged()
	{
		if ((Object)(object)Brain != (Object)null && (Object)(object)Brain.Navigator != (Object)null)
		{
			Brain.Navigator.ForceToGround();
		}
	}
}


using UnityEngine;

public class GingerbreadBrain : BaseAIBrain
{
	public class AttackState : BasicAIState
	{
		private IAIAttack attack;

		private float originalStoppingDistance;

		public AttackState()
			: base(AIState.Attack)
		{
			base.AgrresiveState = true;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			entity.SetFlag(BaseEntity.Flags.Reserved3, b: true);
			originalStoppingDistance = brain.Navigator.StoppingDistance;
			brain.Navigator.Agent.stoppingDistance = 1f;
			brain.Navigator.StoppingDistance = 1f;
			base.StateEnter(brain, entity);
			attack = entity as IAIAttack;
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity != (Object)null)
			{
				Vector3 aimDirection = GetAimDirection(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position);
				brain.Navigator.SetFacingDirectionOverride(aimDirection);
				if (attack.CanAttack(baseEntity))
				{
					StartAttacking(baseEntity);
				}
				brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
			}
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			entity.SetFlag(BaseEntity.Flags.Reserved3, b: false);
			brain.Navigator.Agent.stoppingDistance = originalStoppingDistance;
			brain.Navigator.StoppingDistance = originalStoppingDistance;
			brain.Navigator.ClearFacingDirectionOverride();
			brain.Navigator.Stop();
			StopAttacking();
		}

		private void StopAttacking()
		{
			attack.StopAttacking();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if (attack == null)
			{
				return StateStatus.Error;
			}
			if ((Object)(object)baseEntity == (Object)null)
			{
				brain.Navigator.ClearFacingDirectionOverride();
				StopAttacking();
				return StateStatus.Finished;
			}
			if (brain.Senses.ignoreSafeZonePlayers)
			{
				BasePlayer basePlayer = baseEntity as BasePlayer;
				if ((Object)(object)basePlayer != (Object)null && basePlayer.InSafeZone())
				{
					return StateStatus.Error;
				}
			}
			Vector3Ex.Direction2D(((Component)baseEntity).transform.position, ((Component)entity).transform.position);
			Vector3 position = ((Component)baseEntity).transform.position;
			if (!brain.Navigator.SetDestination(position, BaseNavigator.NavigationSpeed.Fast, 0.2f))
			{
				return StateStatus.Error;
			}
			Vector3 aimDirection = GetAimDirection(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position);
			brain.Navigator.SetFacingDirectionOverride(aimDirection);
			if (attack.CanAttack(baseEntity))
			{
				StartAttacking(baseEntity);
			}
			else
			{
				StopAttacking();
			}
			return StateStatus.Running;
		}

		private static Vector3 GetAimDirection(Vector3 from, Vector3 target)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			return Vector3Ex.Direction2D(target, from);
		}

		private void StartAttacking(BaseEntity entity)
		{
			attack.StartAttacking(entity);
		}
	}

	public class RoamState : BasicAIState
	{
		private StateStatus status = StateStatus.Error;

		public RoamState()
			: base(AIState.Roam)
		{
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			status = StateStatus.Error;
			if (brain.PathFinder == null)
			{
				return;
			}
			ScarecrowNPC scarecrowNPC = entity as ScarecrowNPC;
			if (!((Object)(object)scarecrowNPC == (Object)null))
			{
				Vector3 val = brain.Events.Memory.Position.Get(4);
				Vector3 val2 = val;
				val2 = ((!scarecrowNPC.RoamAroundHomePoint) ? brain.PathFinder.GetBestRoamPosition(brain.Navigator, ((Component)brain.Navigator).transform.position, brain.Events.Memory.Position.Get(4), 10f, brain.Navigator.BestRoamPointMaxDistance) : brain.PathFinder.GetBestRoamPositionFromAnchor(brain.Navigator, val, val, 1f, brain.Navigator.BestRoamPointMaxDistance));
				if (brain.Navigator.SetDestination(val2, BaseNavigator.NavigationSpeed.Slow))
				{
					status = StateStatus.Running;
				}
				else
				{
					status = StateStatus.Error;
				}
			}
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			base.StateThink(delta, brain, entity);
			if (status == StateStatus.Error)
			{
				return status;
			}
			if (brain.Navigator.Moving)
			{
				return StateStatus.Running;
			}
			return StateStatus.Finished;
		}
	}

	public override void AddStates()
	{
		base.AddStates();
		AddState(new BaseIdleState());
		AddState(new BaseChaseState());
		AddState(new AttackState());
		AddState(new RoamState());
		AddState(new BaseFleeState());
	}

	public override void InitializeAI()
	{
		base.InitializeAI();
		base.ThinkMode = AIThinkMode.Interval;
		thinkRate = 0.25f;
		base.PathFinder = new HumanPathFinder();
		((HumanPathFinder)base.PathFinder).Init(GetBaseEntity());
	}

	public override void OnDestroy()
	{
		base.OnDestroy();
	}
}


using UnityEngine;

public class AttackState : BasicAIState
{
	private IAIAttack attack;

	private float originalStoppingDistance;

	public AttackState()
		: base(AIState.Attack)
	{
		base.AgrresiveState = true;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		entity.SetFlag(BaseEntity.Flags.Reserved3, b: true);
		originalStoppingDistance = brain.Navigator.StoppingDistance;
		brain.Navigator.Agent.stoppingDistance = 1f;
		brain.Navigator.StoppingDistance = 1f;
		base.StateEnter(brain, entity);
		attack = entity as IAIAttack;
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity != (Object)null)
		{
			Vector3 aimDirection = GetAimDirection(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position);
			brain.Navigator.SetFacingDirectionOverride(aimDirection);
			if (attack.CanAttack(baseEntity))
			{
				StartAttacking(baseEntity);
			}
			brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
		}
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		entity.SetFlag(BaseEntity.Flags.Reserved3, b: false);
		brain.Navigator.Agent.stoppingDistance = originalStoppingDistance;
		brain.Navigator.StoppingDistance = originalStoppingDistance;
		brain.Navigator.ClearFacingDirectionOverride();
		brain.Navigator.Stop();
		StopAttacking();
	}

	private void StopAttacking()
	{
		attack.StopAttacking();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if (attack == null)
		{
			return StateStatus.Error;
		}
		if ((Object)(object)baseEntity == (Object)null)
		{
			brain.Navigator.ClearFacingDirectionOverride();
			StopAttacking();
			return StateStatus.Finished;
		}
		if (brain.Senses.ignoreSafeZonePlayers)
		{
			BasePlayer basePlayer = baseEntity as BasePlayer;
			if ((Object)(object)basePlayer != (Object)null && basePlayer.InSafeZone())
			{
				return StateStatus.Error;
			}
		}
		Vector3Ex.Direction2D(((Component)baseEntity).transform.position, ((Component)entity).transform.position);
		Vector3 position = ((Component)baseEntity).transform.position;
		if (!brain.Navigator.SetDestination(position, BaseNavigator.NavigationSpeed.Fast, 0.2f))
		{
			return StateStatus.Error;
		}
		Vector3 aimDirection = GetAimDirection(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position);
		brain.Navigator.SetFacingDirectionOverride(aimDirection);
		if (attack.CanAttack(baseEntity))
		{
			StartAttacking(baseEntity);
		}
		else
		{
			StopAttacking();
		}
		return StateStatus.Running;
	}

	private static Vector3 GetAimDirection(Vector3 from, Vector3 target)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.Direction2D(target, from);
	}

	private void StartAttacking(BaseEntity entity)
	{
		attack.StartAttacking(entity);
	}
}


using UnityEngine;

public class RoamState : BasicAIState
{
	private StateStatus status = StateStatus.Error;

	public RoamState()
		: base(AIState.Roam)
	{
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		status = StateStatus.Error;
		if (brain.PathFinder == null)
		{
			return;
		}
		ScarecrowNPC scarecrowNPC = entity as ScarecrowNPC;
		if (!((Object)(object)scarecrowNPC == (Object)null))
		{
			Vector3 val = brain.Events.Memory.Position.Get(4);
			Vector3 val2 = val;
			val2 = ((!scarecrowNPC.RoamAroundHomePoint) ? brain.PathFinder.GetBestRoamPosition(brain.Navigator, ((Component)brain.Navigator).transform.position, brain.Events.Memory.Position.Get(4), 10f, brain.Navigator.BestRoamPointMaxDistance) : brain.PathFinder.GetBestRoamPositionFromAnchor(brain.Navigator, val, val, 1f, brain.Navigator.BestRoamPointMaxDistance));
			if (brain.Navigator.SetDestination(val2, BaseNavigator.NavigationSpeed.Slow))
			{
				status = StateStatus.Running;
			}
			else
			{
				status = StateStatus.Error;
			}
		}
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		if (status == StateStatus.Error)
		{
			return status;
		}
		if (brain.Navigator.Moving)
		{
			return StateStatus.Running;
		}
		return StateStatus.Finished;
	}
}


using ConVar;
using ProtoBuf;
using UnityEngine;

public class GingerbreadNPC : HumanNPC, IClientBrainStateListener
{
	public GameObjectRef OverrideCorpseMale;

	public GameObjectRef OverrideCorpseFemale;

	public PhysicMaterial HitMaterial;

	public bool RoamAroundHomePoint;

	protected override string CorpsePath => CorpseResourcePath;

	protected override string OverrideCorpseName => "Gingerbread";

	protected override bool ShouldCorpseTakeChildren => false;

	protected override bool KeepCorpseClothingIntact => false;

	protected override bool CopyInventoryToCorpse => false;

	protected string CorpseResourcePath
	{
		get
		{
			bool flag = GetFloatBasedOnUserID(userID, 4332uL) > 0.5f;
			if (OverrideCorpseMale.isValid && !flag)
			{
				return OverrideCorpseMale.resourcePath;
			}
			if (OverrideCorpseFemale.isValid && flag)
			{
				return OverrideCorpseFemale.resourcePath;
			}
			return "assets/prefabs/npc/murderer/murderer_corpse.prefab";
			static float GetFloatBasedOnUserID(ulong steamid, ulong seed)
			{
				//IL_0000: Unknown result type (might be due to invalid IL or missing references)
				//IL_0005: Unknown result type (might be due to invalid IL or missing references)
				//IL_001e: Unknown result type (might be due to invalid IL or missing references)
				State state = Random.state;
				Random.InitState((int)(seed + steamid));
				float result = Random.Range(0f, 1f);
				Random.state = state;
				return result;
			}
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		info.HitMaterial = Global.GingerbreadMaterialID();
	}

	public override string Categorize()
	{
		return "Gingerbread";
	}

	public override bool ShouldDropActiveItem()
	{
		return false;
	}

	public override void AttackerInfo(DeathInfo info)
	{
		base.AttackerInfo(info);
		info.inflictorName = base.inventory.containerBelt.GetSlot(0).info.shortname;
		info.attackerName = base.ShortPrefabName;
	}

	public void OnClientStateChanged(AIState state)
	{
	}
}


using System;
using UnityEngine;

public class AIThinkManager : BaseMonoBehaviour, IServerComponent
{
	public enum QueueType
	{
		Human,
		Animal,
		Pets
	}

	public static ListHashSet<IThinker> _processQueue = new ListHashSet<IThinker>();

	public static ListHashSet<IThinker> _removalQueue = new ListHashSet<IThinker>();

	public static ListHashSet<IThinker> _animalProcessQueue = new ListHashSet<IThinker>();

	public static ListHashSet<IThinker> _animalremovalQueue = new ListHashSet<IThinker>();

	public static ListHashSet<IThinker> _petProcessQueue = new ListHashSet<IThinker>();

	public static ListHashSet<IThinker> _petRemovalQueue = new ListHashSet<IThinker>();

	[ServerVar]
	[Help("How many miliseconds to budget for processing AI entities per server frame")]
	public static float framebudgetms = 2.5f;

	[ServerVar]
	[Help("How many miliseconds to budget for processing animal AI entities per server frame")]
	public static float animalframebudgetms = 2.5f;

	[Help("How many miliseconds to budget for processing pet AI entities per server frame")]
	[ServerVar]
	public static float petframebudgetms = 1f;

	private static int lastIndex = 0;

	private static int lastAnimalIndex = 0;

	private static int lastPetIndex;

	public static void ProcessQueue(QueueType queueType)
	{
		if (queueType != 0)
		{
			_ = 2;
		}
		switch (queueType)
		{
		case QueueType.Human:
			DoRemoval(_removalQueue, _processQueue);
			AIInformationZone.BudgetedTick();
			break;
		case QueueType.Pets:
			DoRemoval(_petRemovalQueue, _petProcessQueue);
			break;
		default:
			DoRemoval(_animalremovalQueue, _animalProcessQueue);
			break;
		}
		switch (queueType)
		{
		case QueueType.Human:
			DoProcessing(_processQueue, framebudgetms / 1000f, ref lastIndex);
			break;
		case QueueType.Pets:
			DoProcessing(_petProcessQueue, petframebudgetms / 1000f, ref lastPetIndex);
			break;
		default:
			DoProcessing(_animalProcessQueue, animalframebudgetms / 1000f, ref lastAnimalIndex);
			break;
		}
	}

	private static void DoRemoval(ListHashSet<IThinker> removal, ListHashSet<IThinker> process)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		if (removal.Count <= 0)
		{
			return;
		}
		Enumerator<IThinker> enumerator = removal.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				IThinker current = enumerator.Current;
				process.Remove(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		removal.Clear();
	}

	private static void DoProcessing(ListHashSet<IThinker> process, float budgetSeconds, ref int last)
	{
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		while (last < process.Count && Time.realtimeSinceStartup < realtimeSinceStartup + budgetSeconds)
		{
			IThinker thinker = process[last];
			if (thinker != null)
			{
				try
				{
					thinker.TryThink();
				}
				catch (Exception ex)
				{
					Debug.LogWarning((object)ex);
				}
			}
			last++;
		}
		if (last >= process.Count)
		{
			last = 0;
		}
	}

	public static void Add(IThinker toAdd)
	{
		_processQueue.Add(toAdd);
	}

	public static void Remove(IThinker toRemove)
	{
		_removalQueue.Add(toRemove);
	}

	public static void AddAnimal(IThinker toAdd)
	{
		_animalProcessQueue.Add(toAdd);
	}

	public static void RemoveAnimal(IThinker toRemove)
	{
		_animalremovalQueue.Add(toRemove);
	}

	public static void AddPet(IThinker toAdd)
	{
		_petProcessQueue.Add(toAdd);
	}

	public static void RemovePet(IThinker toRemove)
	{
		_petRemovalQueue.Add(toRemove);
	}
}


public enum QueueType
{
	Human,
	Animal,
	Pets
}


public class BanditGuard : HumanNPC
{
}


using System;
using System.Collections;
using System.IO;
using ConVar;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class HumanNPC : NPCPlayer, IAISenses, IAIAttack, IThinker
{
	[Header("LOS")]
	public int AdditionalLosBlockingLayer;

	[Header("Loot")]
	public LootContainer.LootSpawnSlot[] LootSpawnSlots;

	[Header("Damage")]
	public float aimConeScale = 2f;

	public float lastDismountTime;

	[NonSerialized]
	public bool lightsOn;

	public float nextZoneSearchTime;

	public AIInformationZone cachedInfoZone;

	public float targetAimedDuration;

	private float lastAimSetTime;

	public Vector3 aimOverridePosition = Vector3.zero;

	public ScientistBrain Brain { get; set; }

	public override float StartHealth()
	{
		return startHealth;
	}

	public override float StartMaxHealth()
	{
		return startHealth;
	}

	public override float MaxHealth()
	{
		return startHealth;
	}

	public override bool IsLoadBalanced()
	{
		return true;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		Brain = ((Component)this).GetComponent<ScientistBrain>();
		if (!base.isClient)
		{
			AIThinkManager.Add(this);
		}
	}

	internal override void DoServerDestroy()
	{
		AIThinkManager.Remove(this);
		base.DoServerDestroy();
	}

	public void LightCheck()
	{
		if ((TOD_Sky.Instance.IsNight && !lightsOn) || (TOD_Sky.Instance.IsDay && lightsOn))
		{
			LightToggle();
			lightsOn = !lightsOn;
		}
	}

	public override float GetAimConeScale()
	{
		return aimConeScale;
	}

	public override void EquipWeapon(bool skipDeployDelay = false)
	{
		base.EquipWeapon(skipDeployDelay);
	}

	public override void DismountObject()
	{
		base.DismountObject();
		lastDismountTime = Time.time;
	}

	public bool RecentlyDismounted()
	{
		return Time.time < lastDismountTime + 10f;
	}

	public virtual float GetIdealDistanceFromTarget()
	{
		return Mathf.Max(5f, EngagementRange() * 0.75f);
	}

	public AIInformationZone GetInformationZone(Vector3 pos)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)VirtualInfoZone != (Object)null)
		{
			return VirtualInfoZone;
		}
		if ((Object)(object)cachedInfoZone == (Object)null || Time.time > nextZoneSearchTime)
		{
			cachedInfoZone = AIInformationZone.GetForPoint(pos);
			nextZoneSearchTime = Time.time + 5f;
		}
		return cachedInfoZone;
	}

	public float EngagementRange()
	{
		AttackEntity attackEntity = GetAttackEntity();
		if (Object.op_Implicit((Object)(object)attackEntity))
		{
			return attackEntity.effectiveRange * (attackEntity.aiOnlyInRange ? 1f : 2f) * Brain.AttackRangeMultiplier;
		}
		return Brain.SenseRange;
	}

	public void SetDucked(bool flag)
	{
		if (Interface.CallHook("OnNpcDuck", (object)this) == null)
		{
			modelState.ducked = flag;
			SendNetworkUpdate();
		}
	}

	public virtual void TryThink()
	{
		ServerThink_Internal();
	}

	public override void ServerThink(float delta)
	{
		base.ServerThink(delta);
		if (Brain.ShouldServerThink())
		{
			Brain.DoThink();
		}
	}

	public void TickAttack(float delta, BaseCombatEntity target, bool targetIsLOS)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)target == (Object)null)
		{
			return;
		}
		Vector3 val = base.eyes.BodyForward();
		Vector3 val2 = target.CenterPoint() - base.eyes.position;
		float num = Vector3.Dot(val, ((Vector3)(ref val2)).normalized);
		if (targetIsLOS)
		{
			if (num > 0.2f)
			{
				targetAimedDuration += delta;
			}
		}
		else
		{
			if (num < 0.5f)
			{
				targetAimedDuration = 0f;
			}
			CancelBurst();
		}
		if (targetAimedDuration >= 0.2f && targetIsLOS)
		{
			bool flag = false;
			float dist = 0f;
			if (this != null)
			{
				flag = ((IAIAttack)this).IsTargetInRange((BaseEntity)target, out dist);
			}
			else
			{
				AttackEntity attackEntity = GetAttackEntity();
				if (Object.op_Implicit((Object)(object)attackEntity))
				{
					dist = (((Object)(object)target != (Object)null) ? Vector3.Distance(((Component)this).transform.position, ((Component)target).transform.position) : (-1f));
					flag = dist < attackEntity.effectiveRange * (attackEntity.aiOnlyInRange ? 1f : 2f);
				}
			}
			if (flag)
			{
				ShotTest(dist);
			}
		}
		else
		{
			CancelBurst();
		}
	}

	public override void Hurt(HitInfo info)
	{
		if (base.isMounted)
		{
			info.damageTypes.ScaleAll(0.1f);
		}
		base.Hurt(info);
		BaseEntity initiator = info.Initiator;
		if ((Object)(object)initiator != (Object)null && !initiator.EqualNetID((BaseNetworkable)this))
		{
			Brain.Senses.Memory.SetKnown(initiator, this, null);
		}
	}

	public float GetAimSwayScalar()
	{
		return 1f - Mathf.InverseLerp(1f, 3f, Time.time - lastGunShotTime);
	}

	public override Vector3 GetAimDirection()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Brain != (Object)null && (Object)(object)Brain.Navigator != (Object)null && Brain.Navigator.IsOverridingFacingDirection)
		{
			return Brain.Navigator.FacingDirectionOverride;
		}
		return base.GetAimDirection();
	}

	public override void SetAimDirection(Vector3 newAim)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		if (newAim == Vector3.zero || base.eyes.IsUnityNull() || ((Component)this).transform.IsUnityNull<Transform>())
		{
			return;
		}
		float num = Time.time - lastAimSetTime;
		lastAimSetTime = Time.time;
		AttackEntity attackEntity = GetAttackEntity();
		if (Object.op_Implicit((Object)(object)attackEntity))
		{
			newAim = attackEntity.ModifyAIAim(newAim, GetAimSwayScalar());
		}
		Quaternion val;
		if (base.isMounted)
		{
			BaseMountable baseMountable = GetMounted();
			Vector3 eulerAngles = ((Component)baseMountable).transform.eulerAngles;
			val = Quaternion.LookRotation(newAim, ((Component)baseMountable).transform.up);
			Quaternion val2 = Quaternion.Euler(((Quaternion)(ref val)).eulerAngles);
			Quaternion val3 = Quaternion.LookRotation(((Component)this).transform.InverseTransformDirection(val2 * Vector3.forward), ((Component)this).transform.up);
			Vector3 eulerAngles2 = ((Quaternion)(ref val3)).eulerAngles;
			eulerAngles2 = BaseMountable.ConvertVector(eulerAngles2);
			Quaternion val4 = Quaternion.Euler(Mathf.Clamp(eulerAngles2.x, baseMountable.pitchClamp.x, baseMountable.pitchClamp.y), Mathf.Clamp(eulerAngles2.y, baseMountable.yawClamp.x, baseMountable.yawClamp.y), eulerAngles.z);
			Quaternion val5 = Quaternion.LookRotation(((Component)this).transform.TransformDirection(val4 * Vector3.forward), ((Component)this).transform.up);
			newAim = BaseMountable.ConvertVector(((Quaternion)(ref val5)).eulerAngles);
		}
		else
		{
			BaseEntity baseEntity = GetParentEntity();
			if (!baseEntity.IsUnityNull())
			{
				Vector3 val6 = ((Component)baseEntity).transform.InverseTransformDirection(newAim);
				Vector3 val7 = default(Vector3);
				((Vector3)(ref val7))..ctor(newAim.x, val6.y, newAim.z);
				base.eyes.rotation = Quaternion.Lerp(base.eyes.rotation, Quaternion.LookRotation(val7, ((Component)baseEntity).transform.up), num * 25f);
				val = base.eyes.bodyRotation;
				viewAngles = ((Quaternion)(ref val)).eulerAngles;
				ServerRotation = base.eyes.bodyRotation;
				return;
			}
		}
		base.eyes.rotation = (base.isMounted ? Quaternion.Slerp(base.eyes.rotation, Quaternion.Euler(newAim), num * 70f) : Quaternion.Lerp(base.eyes.rotation, Quaternion.LookRotation(newAim, ((Component)this).transform.up), num * 25f));
		val = base.eyes.rotation;
		viewAngles = ((Quaternion)(ref val)).eulerAngles;
		ServerRotation = base.eyes.rotation;
	}

	public void SetStationaryAimPoint(Vector3 aimAt)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		aimOverridePosition = aimAt;
	}

	public void ClearStationaryAimPoint()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		aimOverridePosition = Vector3.zero;
	}

	public override bool ShouldDropActiveItem()
	{
		return false;
	}

	public override void AttackerInfo(DeathInfo info)
	{
		base.AttackerInfo(info);
		info.inflictorName = base.inventory.containerBelt.GetSlot(0).info.shortname;
		if (DeathIconOverride != null && DeathIconOverride.isValid)
		{
			info.attackerName = Path.GetFileNameWithoutExtension(DeathIconOverride.resourcePath);
		}
		else
		{
			info.attackerName = base.ShortPrefabName;
		}
	}

	public bool IsThreat(BaseEntity entity)
	{
		return IsTarget(entity);
	}

	public bool IsTarget(BaseEntity entity)
	{
		if (entity is BasePlayer && !entity.IsNpc)
		{
			return true;
		}
		if (entity is BasePet)
		{
			return true;
		}
		if (entity is ScarecrowNPC)
		{
			return true;
		}
		return false;
	}

	public bool IsFriendly(BaseEntity entity)
	{
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		return entity.prefabID == prefabID;
	}

	public bool CanAttack(BaseEntity entity)
	{
		return true;
	}

	public bool IsTargetInRange(BaseEntity entity, out float dist)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		dist = Vector3.Distance(((Component)entity).transform.position, ((Component)this).transform.position);
		return dist <= EngagementRange();
	}

	public bool CanSeeTarget(BaseEntity entity)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return CanSeeTarget(entity, Vector3.zero);
	}

	public bool CanSeeTarget(BaseEntity entity, Vector3 fromOffset)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = entity as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null)
		{
			return true;
		}
		if (AdditionalLosBlockingLayer == 0)
		{
			return IsPlayerVisibleToUs(basePlayer, fromOffset, 1218519041);
		}
		return IsPlayerVisibleToUs(basePlayer, fromOffset, 0x48A12001 | (1 << AdditionalLosBlockingLayer));
	}

	public bool NeedsToReload()
	{
		return false;
	}

	public bool Reload()
	{
		return true;
	}

	public float CooldownDuration()
	{
		return 5f;
	}

	public bool IsOnCooldown()
	{
		return false;
	}

	public bool StartAttacking(BaseEntity entity)
	{
		return true;
	}

	public void StopAttacking()
	{
	}

	public float GetAmmoFraction()
	{
		return AmmoFractionRemaining();
	}

	public BaseEntity GetBestTarget()
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity result = null;
		float num = -1f;
		foreach (BaseEntity player in Brain.Senses.Players)
		{
			if (!((Object)(object)player == (Object)null) && !(player.Health() <= 0f) && Interface.CallHook("OnNpcTarget", (object)this, (object)player) == null)
			{
				float num2 = Vector3.Distance(((Component)player).transform.position, ((Component)this).transform.position);
				float num3 = 1f - Mathf.InverseLerp(1f, Brain.SenseRange, num2);
				Vector3 val = ((Component)player).transform.position - base.eyes.position;
				float num4 = Vector3.Dot(((Vector3)(ref val)).normalized, base.eyes.BodyForward());
				num3 += Mathf.InverseLerp(Brain.VisionCone, 1f, num4) / 2f;
				num3 += (Brain.Senses.Memory.IsLOS(player) ? 2f : 0f);
				if (num3 > num)
				{
					result = player;
					num = num3;
				}
			}
		}
		return result;
	}

	public void AttackTick(float delta, BaseEntity target, bool targetIsLOS)
	{
		BaseCombatEntity target2 = target as BaseCombatEntity;
		TickAttack(delta, target2, targetIsLOS);
	}

	public void UseHealingItem(Item item)
	{
		((MonoBehaviour)this).StartCoroutine(Heal(item));
	}

	private IEnumerator Heal(Item item)
	{
		UpdateActiveItem(item.uid);
		Item activeItem = GetActiveItem();
		MedicalTool heldItem = activeItem.GetHeldEntity() as MedicalTool;
		if (!((Object)(object)heldItem == (Object)null))
		{
			yield return (object)new WaitForSeconds(1f);
			heldItem.ServerUse(1f, 1f, null);
			Heal(MaxHealth());
			yield return (object)new WaitForSeconds(2f);
			EquipWeapon();
		}
	}

	public Item FindHealingItem()
	{
		if ((Object)(object)Brain == (Object)null)
		{
			return null;
		}
		if (!Brain.CanUseHealingItems)
		{
			return null;
		}
		if ((Object)(object)base.inventory == (Object)null || base.inventory.containerBelt == null)
		{
			return null;
		}
		for (int i = 0; i < base.inventory.containerBelt.capacity; i++)
		{
			Item slot = base.inventory.containerBelt.GetSlot(i);
			if (slot != null && slot.amount > 1 && (Object)(object)(slot.GetHeldEntity() as MedicalTool) != (Object)null)
			{
				return slot;
			}
		}
		return null;
	}

	protected override void ApplyLoot(NPCPlayerCorpse corpse)
	{
		base.ApplyLoot(corpse);
		if (LootSpawnSlots.Length != 0)
		{
			LootContainer.LootSpawnSlot[] lootSpawnSlots = LootSpawnSlots;
			for (int i = 0; i < lootSpawnSlots.Length; i++)
			{
				LootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[i];
				for (int j = 0; j < lootSpawnSlot.numberToSpawn; j++)
				{
					if ((string.IsNullOrEmpty(lootSpawnSlot.onlyWithLoadoutNamed) || lootSpawnSlot.onlyWithLoadoutNamed == GetLoadoutName()) && Random.Range(0f, 1f) <= lootSpawnSlot.probability)
					{
						lootSpawnSlot.definition.SpawnIntoContainer(corpse.containers[0]);
					}
				}
			}
		}
		if (Server.npcAmmoLootMultiplier == 1f)
		{
			return;
		}
		foreach (Item item in corpse.containers[0].itemList)
		{
			if ((item.info.lootDistributionType & ItemDefinition.LootDistributionModifierType.FirearmAmmunition) == ItemDefinition.LootDistributionModifierType.FirearmAmmunition)
			{
				item.amount = Mathf.Max(1, Mathf.RoundToInt((float)item.amount * Server.npcAmmoLootMultiplier));
			}
		}
	}

	public override bool IsOnGround()
	{
		return true;
	}
}


using UnityEngine;

public class HumanPathFinder : BasePathFinder
{
	private BaseEntity npc;

	public void Init(BaseEntity npc)
	{
		this.npc = npc;
	}

	public override AIMovePoint GetBestRoamPoint(Vector3 anchorPos, Vector3 currentPos, Vector3 currentDirection, float anchorClampDistance, float lookupMaxRange = 20f)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		AIInformationZone aIInformationZone = null;
		if (npc is HumanNPC humanNPC)
		{
			aIInformationZone = ((!((Object)(object)humanNPC.VirtualInfoZone != (Object)null)) ? humanNPC.GetInformationZone(currentPos) : humanNPC.VirtualInfoZone);
		}
		if ((Object)(object)aIInformationZone == (Object)null)
		{
			return null;
		}
		return GetBestRoamPoint(aIInformationZone, anchorPos, currentPos, currentDirection, anchorClampDistance, lookupMaxRange);
	}

	private AIMovePoint GetBestRoamPoint(AIInformationZone aiZone, Vector3 anchorPos, Vector3 currentPos, Vector3 currentDirection, float clampDistance, float lookupMaxRange)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)aiZone == (Object)null)
		{
			return null;
		}
		bool flag = clampDistance > -1f;
		float num = float.NegativeInfinity;
		AIPoint aIPoint = null;
		int pointCount;
		AIPoint[] movePointsInRange = aiZone.GetMovePointsInRange(anchorPos, lookupMaxRange, out pointCount);
		if (movePointsInRange == null || pointCount <= 0)
		{
			return null;
		}
		for (int i = 0; i < pointCount; i++)
		{
			AIPoint aIPoint2 = movePointsInRange[i];
			if (!((Component)((Component)aIPoint2).transform.parent).gameObject.activeSelf)
			{
				continue;
			}
			float num2 = Mathf.Abs(currentPos.y - ((Component)aIPoint2).transform.position.y);
			bool flag2 = currentPos.y < WaterSystem.OceanLevel;
			if (!flag2 && ((!flag2 && ((Component)aIPoint2).transform.position.y < WaterSystem.OceanLevel) || (currentPos.y >= WaterSystem.OceanLevel && num2 > 5f)))
			{
				continue;
			}
			float num3 = 0f;
			float num4 = Vector3.Dot(currentDirection, Vector3Ex.Direction2D(((Component)aIPoint2).transform.position, currentPos));
			num3 += Mathf.InverseLerp(-1f, 1f, num4) * 100f;
			if (!aIPoint2.InUse())
			{
				num3 += 1000f;
			}
			num3 += (1f - Mathf.InverseLerp(1f, 10f, num2)) * 100f;
			float num5 = Vector3.Distance(currentPos, ((Component)aIPoint2).transform.position);
			if (num5 <= 1f)
			{
				num3 -= 3000f;
			}
			if (flag)
			{
				float num6 = Vector3.Distance(anchorPos, ((Component)aIPoint2).transform.position);
				if (num6 <= clampDistance)
				{
					num3 += 1000f;
					num3 += (1f - Mathf.InverseLerp(0f, clampDistance, num6)) * 200f * Random.Range(0.8f, 1f);
				}
			}
			else if (num5 > 3f)
			{
				num3 += Mathf.InverseLerp(3f, lookupMaxRange, num5) * 50f;
			}
			if (num3 > num)
			{
				aIPoint = aIPoint2;
				num = num3;
			}
		}
		return aIPoint as AIMovePoint;
	}
}


public interface IThinker
{
	void TryThink();
}


using UnityEngine;

public class ScientistBrain : BaseAIBrain
{
	public class BlindedState : BaseBlindedState
	{
		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			HumanNPC obj = entity as HumanNPC;
			obj.SetDucked(flag: false);
			obj.Server_StartGesture(235662700u);
			brain.Navigator.SetDestination(brain.PathFinder.GetRandomPositionAround(((Component)entity).transform.position, 1f, 2.5f), BaseNavigator.NavigationSpeed.Slowest);
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			brain.Navigator.ClearFacingDirectionOverride();
			if ((Object)(object)entity.ToPlayer() != (Object)null)
			{
				entity.ToPlayer().Server_CancelGesture();
			}
		}
	}

	public class ChaseState : BasicAIState
	{
		private StateStatus status = StateStatus.Error;

		private float nextPositionUpdateTime;

		public ChaseState()
			: base(AIState.Chase)
		{
			base.AgrresiveState = true;
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateEnter(brain, entity);
			status = StateStatus.Error;
			if (brain.PathFinder != null)
			{
				status = StateStatus.Running;
				nextPositionUpdateTime = 0f;
			}
		}

		private void Stop()
		{
			brain.Navigator.Stop();
			brain.Navigator.ClearFacingDirectionOverride();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0101: Unknown result type (might be due to invalid IL or missing references)
			//IL_010e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0393: Unknown result type (might be due to invalid IL or missing references)
			//IL_0379: Unknown result type (might be due to invalid IL or missing references)
			//IL_018e: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0348: Unknown result type (might be due to invalid IL or missing references)
			//IL_035f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0364: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
			//IL_025d: Unknown result type (might be due to invalid IL or missing references)
			//IL_025f: Unknown result type (might be due to invalid IL or missing references)
			//IL_021c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0221: Unknown result type (might be due to invalid IL or missing references)
			//IL_0226: Unknown result type (might be due to invalid IL or missing references)
			//IL_022b: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			if (status == StateStatus.Error)
			{
				return status;
			}
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity == (Object)null)
			{
				return StateStatus.Error;
			}
			float num = Vector3.Distance(((Component)baseEntity).transform.position, ((Component)entity).transform.position);
			if (brain.Senses.Memory.IsLOS(baseEntity) || num <= brain.Navigator.FaceTargetChaseDistance || base.TimeInState <= 5f)
			{
				brain.Navigator.SetFacingDirectionEntity(baseEntity);
			}
			else
			{
				brain.Navigator.ClearFacingDirectionOverride();
			}
			if (num <= 10f)
			{
				brain.Navigator.SetCurrentSpeed(BaseNavigator.NavigationSpeed.Normal);
			}
			else
			{
				brain.Navigator.SetCurrentSpeed(BaseNavigator.NavigationSpeed.Fast);
			}
			if (Time.time > nextPositionUpdateTime)
			{
				nextPositionUpdateTime = Time.time + Random.Range(0.5f, 1f);
				Vector3 pos = ((Component)entity).transform.position;
				AIInformationZone informationZone = (entity as HumanNPC).GetInformationZone(((Component)baseEntity).transform.position);
				bool flag = false;
				if ((Object)(object)informationZone != (Object)null)
				{
					AIMovePoint aIMovePoint = informationZone.GetBestMovePointNear(baseEntity, entity, 0f, brain.Navigator.BestMovementPointMaxDistance, checkLOS: true, entity);
					flag = (Object)(object)aIMovePoint != (Object)null;
					if (!flag && brain.Navigator.CanPathFindToChaseTargetIfNoMovePoint)
					{
						float num2 = brain.Navigator.BestMovementPointMaxDistance * brain.Navigator.PathFindChaseLOSDistanceMultiplier;
						if (num <= num2 && Vector3.Distance(((Component)baseEntity).transform.position, brain.Events.Memory.Position.Get(4)) <= num2)
						{
							Vector3 val = ((Component)brain).transform.position;
							bool flag2 = false;
							for (int i = 0; i < brain.Navigator.PathFindChaseLOSAttemptCount; i++)
							{
								val = brain.PathFinder.GetRandomPositionAround(((Component)baseEntity).transform.position, 1.5f, 7f) + Vector3.up;
								BasePlayer obj = baseEntity as BasePlayer;
								HumanNPC humanNPC = entity as HumanNPC;
								if ((Object)(object)obj != (Object)null && (Object)(object)humanNPC != (Object)null)
								{
									flag2 = !Physics.Linecast(((Component)baseEntity).transform.position + Vector3.up, val, 1218519297, (QueryTriggerInteraction)1);
								}
								if (flag2)
								{
									break;
								}
							}
							if (flag2)
							{
								pos = val;
							}
							flag = flag2;
							nextPositionUpdateTime = Time.time + Random.Range(5f, 8f);
						}
					}
					if (!flag && brain.Navigator.CanUseRandomMovePointIfNonFound)
					{
						aIMovePoint = informationZone.GetBestMovePointNear(baseEntity, entity, 0f, brain.Navigator.BestMovementPointMaxDistance, checkLOS: true, entity, returnClosest: false, returnRandom: true);
						if ((Object)(object)aIMovePoint != (Object)null)
						{
							nextPositionUpdateTime = Time.time + 15f;
						}
						flag = true;
					}
					if (!flag)
					{
						aIMovePoint = ((!brain.Navigator.CanPathFindToChaseTargetIfNoMovePoint) ? informationZone.GetBestMovePointNear(baseEntity, entity, 0f, brain.Navigator.BestMovementPointMaxDistance, checkLOS: true, entity, returnClosest: true) : informationZone.GetBestMovePointNear(baseEntity, entity, 0f, brain.Navigator.BestMovementPointMaxDistance, checkLOS: true, entity, returnClosest: true, returnRandom: true));
						flag = (Object)(object)aIMovePoint != (Object)null;
					}
					if (Object.op_Implicit((Object)(object)aIMovePoint))
					{
						aIMovePoint.SetUsedBy(entity, 5f);
						pos = brain.PathFinder.GetRandomPositionAround(((Component)aIMovePoint).transform.position, 0f, aIMovePoint.radius - 0.3f);
					}
				}
				if (!flag)
				{
					return StateStatus.Error;
				}
				if (num < 10f)
				{
					brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Normal);
				}
				else
				{
					brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Fast);
				}
			}
			if (brain.Navigator.Moving)
			{
				return StateStatus.Running;
			}
			return StateStatus.Finished;
		}
	}

	public class CombatState : BasicAIState
	{
		private float nextActionTime;

		private Vector3 combatStartPosition;

		public CombatState()
			: base(AIState.Combat)
		{
			base.AgrresiveState = true;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			combatStartPosition = ((Component)entity).transform.position;
			FaceTarget();
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			(entity as HumanNPC).SetDucked(flag: false);
			brain.Navigator.ClearFacingDirectionOverride();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			HumanNPC humanNPC = entity as HumanNPC;
			FaceTarget();
			if (Time.time > nextActionTime)
			{
				if (Random.Range(0, 3) == 1)
				{
					nextActionTime = Time.time + Random.Range(1f, 2f);
					humanNPC.SetDucked(flag: true);
					brain.Navigator.Stop();
				}
				else
				{
					nextActionTime = Time.time + Random.Range(2f, 3f);
					humanNPC.SetDucked(flag: false);
					brain.Navigator.SetDestination(brain.PathFinder.GetRandomPositionAround(combatStartPosition, 1f), BaseNavigator.NavigationSpeed.Normal);
				}
			}
			return StateStatus.Running;
		}

		private void FaceTarget()
		{
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity == (Object)null)
			{
				brain.Navigator.ClearFacingDirectionOverride();
			}
			else
			{
				brain.Navigator.SetFacingDirectionEntity(baseEntity);
			}
		}
	}

	public class CombatStationaryState : BasicAIState
	{
		public CombatStationaryState()
			: base(AIState.CombatStationary)
		{
			base.AgrresiveState = true;
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			brain.Navigator.ClearFacingDirectionOverride();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			base.StateThink(delta, brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity != (Object)null)
			{
				brain.Navigator.SetFacingDirectionEntity(baseEntity);
			}
			else
			{
				brain.Navigator.ClearFacingDirectionOverride();
			}
			return StateStatus.Running;
		}
	}

	public class CoverState : BasicAIState
	{
		public CoverState()
			: base(AIState.Cover)
		{
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			HumanNPC humanNPC = entity as HumanNPC;
			humanNPC.SetDucked(flag: true);
			AIPoint aIPoint = brain.Events.Memory.AIPoint.Get(4);
			if ((Object)(object)aIPoint != (Object)null)
			{
				aIPoint.SetUsedBy(entity);
			}
			if (!(humanNPC.healthFraction <= brain.HealBelowHealthFraction) || !(Random.Range(0f, 1f) <= brain.HealChance))
			{
				return;
			}
			Item item = humanNPC.FindHealingItem();
			if (item != null)
			{
				BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
				if ((Object)(object)baseEntity == (Object)null || (!brain.Senses.Memory.IsLOS(baseEntity) && Vector3.Distance(((Component)entity).transform.position, ((Component)baseEntity).transform.position) >= 5f))
				{
					humanNPC.UseHealingItem(item);
				}
			}
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			(entity as HumanNPC).SetDucked(flag: false);
			brain.Navigator.ClearFacingDirectionOverride();
			AIPoint aIPoint = brain.Events.Memory.AIPoint.Get(4);
			if ((Object)(object)aIPoint != (Object)null)
			{
				aIPoint.ClearIfUsedBy(entity);
			}
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			base.StateThink(delta, brain, entity);
			HumanNPC humanNPC = entity as HumanNPC;
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			float num = humanNPC.AmmoFractionRemaining();
			if (num == 0f || ((Object)(object)baseEntity != (Object)null && !brain.Senses.Memory.IsLOS(baseEntity) && num < 0.25f))
			{
				humanNPC.AttemptReload();
			}
			if ((Object)(object)baseEntity != (Object)null)
			{
				brain.Navigator.SetFacingDirectionEntity(baseEntity);
			}
			return StateStatus.Running;
		}
	}

	public class DismountedState : BaseDismountedState
	{
		private StateStatus status = StateStatus.Error;

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			status = StateStatus.Error;
			if (brain.PathFinder == null)
			{
				return;
			}
			AIInformationZone informationZone = (entity as HumanNPC).GetInformationZone(((Component)entity).transform.position);
			if (!((Object)(object)informationZone == (Object)null))
			{
				AICoverPoint bestCoverPoint = informationZone.GetBestCoverPoint(((Component)entity).transform.position, ((Component)entity).transform.position, 25f, 50f, entity);
				if (Object.op_Implicit((Object)(object)bestCoverPoint))
				{
					bestCoverPoint.SetUsedBy(entity, 10f);
				}
				Vector3 pos = (((Object)(object)bestCoverPoint == (Object)null) ? ((Component)entity).transform.position : ((Component)bestCoverPoint).transform.position);
				if (brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Fast))
				{
					status = StateStatus.Running;
				}
			}
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			base.StateThink(delta, brain, entity);
			if (status == StateStatus.Error)
			{
				return status;
			}
			if (brain.Navigator.Moving)
			{
				return StateStatus.Running;
			}
			return StateStatus.Finished;
		}
	}

	public class IdleState : BaseIdleState
	{
	}

	public class KillSelfState : BasicAIState
	{
		public KillSelfState()
			: base(AIState.KillSelf)
		{
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateEnter(brain, entity);
			entity.Kill();
		}
	}

	public class MountAPC : BasicAIState
	{
		public MountAPC()
			: base(AIState.MountAPC)
		{
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateEnter(brain, entity);
			BradleyAPC bradleyAPC = brain.Events.Memory.Entity.Get(7) as BradleyAPC;
			if ((Object)(object)bradleyAPC != (Object)null)
			{
				bradleyAPC.OnScientistMounted(entity as ScientistNPC);
			}
			entity.Kill();
		}
	}

	public class MountedState : BaseMountedState
	{
	}

	public class MoveToVector3State : BasicAIState
	{
		public MoveToVector3State()
			: base(AIState.MoveToVector3)
		{
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		private void Stop()
		{
			brain.Navigator.Stop();
			brain.Navigator.ClearFacingDirectionOverride();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			Vector3 pos = brain.Events.Memory.Position.Get(7);
			if (!brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Fast, 0.5f))
			{
				return StateStatus.Error;
			}
			if (!brain.Navigator.Moving)
			{
				return StateStatus.Finished;
			}
			return StateStatus.Running;
		}
	}

	public class RoamState : BaseRoamState
	{
		private StateStatus status = StateStatus.Error;

		private AIMovePoint roamPoint;

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
			ClearRoamPointUsage(entity);
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			status = StateStatus.Error;
			ClearRoamPointUsage(entity);
			if (brain.PathFinder == null)
			{
				return;
			}
			status = StateStatus.Error;
			roamPoint = brain.PathFinder.GetBestRoamPoint(GetRoamAnchorPosition(), ((Component)entity).transform.position, (entity as HumanNPC).eyes.BodyForward(), brain.Navigator.MaxRoamDistanceFromHome, brain.Navigator.BestRoamPointMaxDistance);
			if ((Object)(object)roamPoint != (Object)null)
			{
				if (brain.Navigator.SetDestination(((Component)roamPoint).transform.position, BaseNavigator.NavigationSpeed.Slow))
				{
					roamPoint.SetUsedBy(entity);
					status = StateStatus.Running;
				}
				else
				{
					roamPoint.SetUsedBy(entity, 600f);
				}
			}
		}

		private void ClearRoamPointUsage(BaseEntity entity)
		{
			if ((Object)(object)roamPoint != (Object)null)
			{
				roamPoint.ClearIfUsedBy(entity);
				roamPoint = null;
			}
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			if (status == StateStatus.Error)
			{
				return status;
			}
			if (brain.Navigator.Moving)
			{
				return StateStatus.Running;
			}
			PickGoodLookDirection();
			return StateStatus.Finished;
		}

		private void PickGoodLookDirection()
		{
		}
	}

	public class TakeCoverState : BasicAIState
	{
		private StateStatus status = StateStatus.Error;

		private BaseEntity coverFromEntity;

		public TakeCoverState()
			: base(AIState.TakeCover)
		{
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateEnter(brain, entity);
			status = StateStatus.Running;
			if (!StartMovingToCover(entity as HumanNPC))
			{
				status = StateStatus.Error;
			}
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			brain.Navigator.ClearFacingDirectionOverride();
			ClearCoverPointUsage(entity);
		}

		private void ClearCoverPointUsage(BaseEntity entity)
		{
			AIPoint aIPoint = brain.Events.Memory.AIPoint.Get(4);
			if ((Object)(object)aIPoint != (Object)null)
			{
				aIPoint.ClearIfUsedBy(entity);
			}
		}

		private bool StartMovingToCover(HumanNPC entity)
		{
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
			coverFromEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			Vector3 hideFromPosition = (Object.op_Implicit((Object)(object)coverFromEntity) ? ((Component)coverFromEntity).transform.position : (((Component)entity).transform.position + entity.LastAttackedDir * 30f));
			AIInformationZone informationZone = entity.GetInformationZone(((Component)entity).transform.position);
			if ((Object)(object)informationZone == (Object)null)
			{
				return false;
			}
			float minRange = ((entity.SecondsSinceAttacked < 2f) ? 2f : 0f);
			float bestCoverPointMaxDistance = brain.Navigator.BestCoverPointMaxDistance;
			AICoverPoint bestCoverPoint = informationZone.GetBestCoverPoint(((Component)entity).transform.position, hideFromPosition, minRange, bestCoverPointMaxDistance, entity);
			if ((Object)(object)bestCoverPoint == (Object)null)
			{
				return false;
			}
			Vector3 position = ((Component)bestCoverPoint).transform.position;
			if (!brain.Navigator.SetDestination(position, BaseNavigator.NavigationSpeed.Normal))
			{
				return false;
			}
			FaceCoverFromEntity();
			brain.Events.Memory.AIPoint.Set(bestCoverPoint, 4);
			bestCoverPoint.SetUsedBy(entity);
			return true;
		}

		public override void DrawGizmos()
		{
			base.DrawGizmos();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			base.StateThink(delta, brain, entity);
			FaceCoverFromEntity();
			if (status == StateStatus.Error)
			{
				return status;
			}
			if (brain.Navigator.Moving)
			{
				return StateStatus.Running;
			}
			return StateStatus.Finished;
		}

		private void FaceCoverFromEntity()
		{
			coverFromEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if (!((Object)(object)coverFromEntity == (Object)null))
			{
				brain.Navigator.SetFacingDirectionEntity(coverFromEntity);
			}
		}
	}

	public static int Count;

	public override void AddStates()
	{
		base.AddStates();
		AddState(new IdleState());
		AddState(new RoamState());
		AddState(new ChaseState());
		AddState(new CombatState());
		AddState(new TakeCoverState());
		AddState(new CoverState());
		AddState(new MountedState());
		AddState(new DismountedState());
		AddState(new BaseFollowPathState());
		AddState(new BaseNavigateHomeState());
		AddState(new CombatStationaryState());
		AddState(new BaseMoveTorwardsState());
		AddState(new MoveToVector3State());
		AddState(new BlindedState());
		AddState(new KillSelfState());
		AddState(new MountAPC());
	}

	public override void InitializeAI()
	{
		base.InitializeAI();
		base.ThinkMode = AIThinkMode.Interval;
		thinkRate = 0.25f;
		base.PathFinder = new HumanPathFinder();
		((HumanPathFinder)base.PathFinder).Init(GetBaseEntity());
		Count++;
	}

	public override void OnDestroy()
	{
		base.OnDestroy();
		Count--;
	}

	public HumanNPC GetEntity()
	{
		return GetBaseEntity() as HumanNPC;
	}

	protected override void OnStateChanged()
	{
		base.OnStateChanged();
		if (base.CurrentState != null)
		{
			switch (base.CurrentState.StateType)
			{
			case AIState.Idle:
			case AIState.Roam:
			case AIState.Patrol:
			case AIState.FollowPath:
			case AIState.Cooldown:
				GetEntity().SetPlayerFlag(BasePlayer.PlayerFlags.Relaxed, b: true);
				break;
			default:
				GetEntity().SetPlayerFlag(BasePlayer.PlayerFlags.Relaxed, b: false);
				break;
			}
		}
	}
}


using UnityEngine;

public class BlindedState : BaseBlindedState
{
	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		HumanNPC obj = entity as HumanNPC;
		obj.SetDucked(flag: false);
		obj.Server_StartGesture(235662700u);
		brain.Navigator.SetDestination(brain.PathFinder.GetRandomPositionAround(((Component)entity).transform.position, 1f, 2.5f), BaseNavigator.NavigationSpeed.Slowest);
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		brain.Navigator.ClearFacingDirectionOverride();
		if ((Object)(object)entity.ToPlayer() != (Object)null)
		{
			entity.ToPlayer().Server_CancelGesture();
		}
	}
}


using UnityEngine;

public class ChaseState : BasicAIState
{
	private StateStatus status = StateStatus.Error;

	private float nextPositionUpdateTime;

	public ChaseState()
		: base(AIState.Chase)
	{
		base.AgrresiveState = true;
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateEnter(brain, entity);
		status = StateStatus.Error;
		if (brain.PathFinder != null)
		{
			status = StateStatus.Running;
			nextPositionUpdateTime = 0f;
		}
	}

	private void Stop()
	{
		brain.Navigator.Stop();
		brain.Navigator.ClearFacingDirectionOverride();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0348: Unknown result type (might be due to invalid IL or missing references)
		//IL_035f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0364: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		if (status == StateStatus.Error)
		{
			return status;
		}
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			return StateStatus.Error;
		}
		float num = Vector3.Distance(((Component)baseEntity).transform.position, ((Component)entity).transform.position);
		if (brain.Senses.Memory.IsLOS(baseEntity) || num <= brain.Navigator.FaceTargetChaseDistance || base.TimeInState <= 5f)
		{
			brain.Navigator.SetFacingDirectionEntity(baseEntity);
		}
		else
		{
			brain.Navigator.ClearFacingDirectionOverride();
		}
		if (num <= 10f)
		{
			brain.Navigator.SetCurrentSpeed(BaseNavigator.NavigationSpeed.Normal);
		}
		else
		{
			brain.Navigator.SetCurrentSpeed(BaseNavigator.NavigationSpeed.Fast);
		}
		if (Time.time > nextPositionUpdateTime)
		{
			nextPositionUpdateTime = Time.time + Random.Range(0.5f, 1f);
			Vector3 pos = ((Component)entity).transform.position;
			AIInformationZone informationZone = (entity as HumanNPC).GetInformationZone(((Component)baseEntity).transform.position);
			bool flag = false;
			if ((Object)(object)informationZone != (Object)null)
			{
				AIMovePoint aIMovePoint = informationZone.GetBestMovePointNear(baseEntity, entity, 0f, brain.Navigator.BestMovementPointMaxDistance, checkLOS: true, entity);
				flag = (Object)(object)aIMovePoint != (Object)null;
				if (!flag && brain.Navigator.CanPathFindToChaseTargetIfNoMovePoint)
				{
					float num2 = brain.Navigator.BestMovementPointMaxDistance * brain.Navigator.PathFindChaseLOSDistanceMultiplier;
					if (num <= num2 && Vector3.Distance(((Component)baseEntity).transform.position, brain.Events.Memory.Position.Get(4)) <= num2)
					{
						Vector3 val = ((Component)brain).transform.position;
						bool flag2 = false;
						for (int i = 0; i < brain.Navigator.PathFindChaseLOSAttemptCount; i++)
						{
							val = brain.PathFinder.GetRandomPositionAround(((Component)baseEntity).transform.position, 1.5f, 7f) + Vector3.up;
							BasePlayer obj = baseEntity as BasePlayer;
							HumanNPC humanNPC = entity as HumanNPC;
							if ((Object)(object)obj != (Object)null && (Object)(object)humanNPC != (Object)null)
							{
								flag2 = !Physics.Linecast(((Component)baseEntity).transform.position + Vector3.up, val, 1218519297, (QueryTriggerInteraction)1);
							}
							if (flag2)
							{
								break;
							}
						}
						if (flag2)
						{
							pos = val;
						}
						flag = flag2;
						nextPositionUpdateTime = Time.time + Random.Range(5f, 8f);
					}
				}
				if (!flag && brain.Navigator.CanUseRandomMovePointIfNonFound)
				{
					aIMovePoint = informationZone.GetBestMovePointNear(baseEntity, entity, 0f, brain.Navigator.BestMovementPointMaxDistance, checkLOS: true, entity, returnClosest: false, returnRandom: true);
					if ((Object)(object)aIMovePoint != (Object)null)
					{
						nextPositionUpdateTime = Time.time + 15f;
					}
					flag = true;
				}
				if (!flag)
				{
					aIMovePoint = ((!brain.Navigator.CanPathFindToChaseTargetIfNoMovePoint) ? informationZone.GetBestMovePointNear(baseEntity, entity, 0f, brain.Navigator.BestMovementPointMaxDistance, checkLOS: true, entity, returnClosest: true) : informationZone.GetBestMovePointNear(baseEntity, entity, 0f, brain.Navigator.BestMovementPointMaxDistance, checkLOS: true, entity, returnClosest: true, returnRandom: true));
					flag = (Object)(object)aIMovePoint != (Object)null;
				}
				if (Object.op_Implicit((Object)(object)aIMovePoint))
				{
					aIMovePoint.SetUsedBy(entity, 5f);
					pos = brain.PathFinder.GetRandomPositionAround(((Component)aIMovePoint).transform.position, 0f, aIMovePoint.radius - 0.3f);
				}
			}
			if (!flag)
			{
				return StateStatus.Error;
			}
			if (num < 10f)
			{
				brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Normal);
			}
			else
			{
				brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Fast);
			}
		}
		if (brain.Navigator.Moving)
		{
			return StateStatus.Running;
		}
		return StateStatus.Finished;
	}
}


using UnityEngine;

public class CombatState : BasicAIState
{
	private float nextActionTime;

	private Vector3 combatStartPosition;

	public CombatState()
		: base(AIState.Combat)
	{
		base.AgrresiveState = true;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		combatStartPosition = ((Component)entity).transform.position;
		FaceTarget();
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		(entity as HumanNPC).SetDucked(flag: false);
		brain.Navigator.ClearFacingDirectionOverride();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		HumanNPC humanNPC = entity as HumanNPC;
		FaceTarget();
		if (Time.time > nextActionTime)
		{
			if (Random.Range(0, 3) == 1)
			{
				nextActionTime = Time.time + Random.Range(1f, 2f);
				humanNPC.SetDucked(flag: true);
				brain.Navigator.Stop();
			}
			else
			{
				nextActionTime = Time.time + Random.Range(2f, 3f);
				humanNPC.SetDucked(flag: false);
				brain.Navigator.SetDestination(brain.PathFinder.GetRandomPositionAround(combatStartPosition, 1f), BaseNavigator.NavigationSpeed.Normal);
			}
		}
		return StateStatus.Running;
	}

	private void FaceTarget()
	{
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			brain.Navigator.ClearFacingDirectionOverride();
		}
		else
		{
			brain.Navigator.SetFacingDirectionEntity(baseEntity);
		}
	}
}


using UnityEngine;

public class CombatStationaryState : BasicAIState
{
	public CombatStationaryState()
		: base(AIState.CombatStationary)
	{
		base.AgrresiveState = true;
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		brain.Navigator.ClearFacingDirectionOverride();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity != (Object)null)
		{
			brain.Navigator.SetFacingDirectionEntity(baseEntity);
		}
		else
		{
			brain.Navigator.ClearFacingDirectionOverride();
		}
		return StateStatus.Running;
	}
}


using UnityEngine;

public class CoverState : BasicAIState
{
	public CoverState()
		: base(AIState.Cover)
	{
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		HumanNPC humanNPC = entity as HumanNPC;
		humanNPC.SetDucked(flag: true);
		AIPoint aIPoint = brain.Events.Memory.AIPoint.Get(4);
		if ((Object)(object)aIPoint != (Object)null)
		{
			aIPoint.SetUsedBy(entity);
		}
		if (!(humanNPC.healthFraction <= brain.HealBelowHealthFraction) || !(Random.Range(0f, 1f) <= brain.HealChance))
		{
			return;
		}
		Item item = humanNPC.FindHealingItem();
		if (item != null)
		{
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity == (Object)null || (!brain.Senses.Memory.IsLOS(baseEntity) && Vector3.Distance(((Component)entity).transform.position, ((Component)baseEntity).transform.position) >= 5f))
			{
				humanNPC.UseHealingItem(item);
			}
		}
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		(entity as HumanNPC).SetDucked(flag: false);
		brain.Navigator.ClearFacingDirectionOverride();
		AIPoint aIPoint = brain.Events.Memory.AIPoint.Get(4);
		if ((Object)(object)aIPoint != (Object)null)
		{
			aIPoint.ClearIfUsedBy(entity);
		}
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		HumanNPC humanNPC = entity as HumanNPC;
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		float num = humanNPC.AmmoFractionRemaining();
		if (num == 0f || ((Object)(object)baseEntity != (Object)null && !brain.Senses.Memory.IsLOS(baseEntity) && num < 0.25f))
		{
			humanNPC.AttemptReload();
		}
		if ((Object)(object)baseEntity != (Object)null)
		{
			brain.Navigator.SetFacingDirectionEntity(baseEntity);
		}
		return StateStatus.Running;
	}
}


using UnityEngine;

public class DismountedState : BaseDismountedState
{
	private StateStatus status = StateStatus.Error;

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		status = StateStatus.Error;
		if (brain.PathFinder == null)
		{
			return;
		}
		AIInformationZone informationZone = (entity as HumanNPC).GetInformationZone(((Component)entity).transform.position);
		if (!((Object)(object)informationZone == (Object)null))
		{
			AICoverPoint bestCoverPoint = informationZone.GetBestCoverPoint(((Component)entity).transform.position, ((Component)entity).transform.position, 25f, 50f, entity);
			if (Object.op_Implicit((Object)(object)bestCoverPoint))
			{
				bestCoverPoint.SetUsedBy(entity, 10f);
			}
			Vector3 pos = (((Object)(object)bestCoverPoint == (Object)null) ? ((Component)entity).transform.position : ((Component)bestCoverPoint).transform.position);
			if (brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Fast))
			{
				status = StateStatus.Running;
			}
		}
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		if (status == StateStatus.Error)
		{
			return status;
		}
		if (brain.Navigator.Moving)
		{
			return StateStatus.Running;
		}
		return StateStatus.Finished;
	}
}


public class IdleState : BaseIdleState
{
}


public class KillSelfState : BasicAIState
{
	public KillSelfState()
		: base(AIState.KillSelf)
	{
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateEnter(brain, entity);
		entity.Kill();
	}
}


using UnityEngine;

public class MountAPC : BasicAIState
{
	public MountAPC()
		: base(AIState.MountAPC)
	{
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateEnter(brain, entity);
		BradleyAPC bradleyAPC = brain.Events.Memory.Entity.Get(7) as BradleyAPC;
		if ((Object)(object)bradleyAPC != (Object)null)
		{
			bradleyAPC.OnScientistMounted(entity as ScientistNPC);
		}
		entity.Kill();
	}
}


public class MountedState : BaseMountedState
{
}


using UnityEngine;

public class MoveToVector3State : BasicAIState
{
	public MoveToVector3State()
		: base(AIState.MoveToVector3)
	{
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	private void Stop()
	{
		brain.Navigator.Stop();
		brain.Navigator.ClearFacingDirectionOverride();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		Vector3 pos = brain.Events.Memory.Position.Get(7);
		if (!brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Fast, 0.5f))
		{
			return StateStatus.Error;
		}
		if (!brain.Navigator.Moving)
		{
			return StateStatus.Finished;
		}
		return StateStatus.Running;
	}
}


using UnityEngine;

public class RoamState : BaseRoamState
{
	private StateStatus status = StateStatus.Error;

	private AIMovePoint roamPoint;

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
		ClearRoamPointUsage(entity);
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		status = StateStatus.Error;
		ClearRoamPointUsage(entity);
		if (brain.PathFinder == null)
		{
			return;
		}
		status = StateStatus.Error;
		roamPoint = brain.PathFinder.GetBestRoamPoint(GetRoamAnchorPosition(), ((Component)entity).transform.position, (entity as HumanNPC).eyes.BodyForward(), brain.Navigator.MaxRoamDistanceFromHome, brain.Navigator.BestRoamPointMaxDistance);
		if ((Object)(object)roamPoint != (Object)null)
		{
			if (brain.Navigator.SetDestination(((Component)roamPoint).transform.position, BaseNavigator.NavigationSpeed.Slow))
			{
				roamPoint.SetUsedBy(entity);
				status = StateStatus.Running;
			}
			else
			{
				roamPoint.SetUsedBy(entity, 600f);
			}
		}
	}

	private void ClearRoamPointUsage(BaseEntity entity)
	{
		if ((Object)(object)roamPoint != (Object)null)
		{
			roamPoint.ClearIfUsedBy(entity);
			roamPoint = null;
		}
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		if (status == StateStatus.Error)
		{
			return status;
		}
		if (brain.Navigator.Moving)
		{
			return StateStatus.Running;
		}
		PickGoodLookDirection();
		return StateStatus.Finished;
	}

	private void PickGoodLookDirection()
	{
	}
}


using UnityEngine;

public class TakeCoverState : BasicAIState
{
	private StateStatus status = StateStatus.Error;

	private BaseEntity coverFromEntity;

	public TakeCoverState()
		: base(AIState.TakeCover)
	{
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateEnter(brain, entity);
		status = StateStatus.Running;
		if (!StartMovingToCover(entity as HumanNPC))
		{
			status = StateStatus.Error;
		}
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		brain.Navigator.ClearFacingDirectionOverride();
		ClearCoverPointUsage(entity);
	}

	private void ClearCoverPointUsage(BaseEntity entity)
	{
		AIPoint aIPoint = brain.Events.Memory.AIPoint.Get(4);
		if ((Object)(object)aIPoint != (Object)null)
		{
			aIPoint.ClearIfUsedBy(entity);
		}
	}

	private bool StartMovingToCover(HumanNPC entity)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		coverFromEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		Vector3 hideFromPosition = (Object.op_Implicit((Object)(object)coverFromEntity) ? ((Component)coverFromEntity).transform.position : (((Component)entity).transform.position + entity.LastAttackedDir * 30f));
		AIInformationZone informationZone = entity.GetInformationZone(((Component)entity).transform.position);
		if ((Object)(object)informationZone == (Object)null)
		{
			return false;
		}
		float minRange = ((entity.SecondsSinceAttacked < 2f) ? 2f : 0f);
		float bestCoverPointMaxDistance = brain.Navigator.BestCoverPointMaxDistance;
		AICoverPoint bestCoverPoint = informationZone.GetBestCoverPoint(((Component)entity).transform.position, hideFromPosition, minRange, bestCoverPointMaxDistance, entity);
		if ((Object)(object)bestCoverPoint == (Object)null)
		{
			return false;
		}
		Vector3 position = ((Component)bestCoverPoint).transform.position;
		if (!brain.Navigator.SetDestination(position, BaseNavigator.NavigationSpeed.Normal))
		{
			return false;
		}
		FaceCoverFromEntity();
		brain.Events.Memory.AIPoint.Set(bestCoverPoint, 4);
		bestCoverPoint.SetUsedBy(entity);
		return true;
	}

	public override void DrawGizmos()
	{
		base.DrawGizmos();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		FaceCoverFromEntity();
		if (status == StateStatus.Error)
		{
			return status;
		}
		if (brain.Navigator.Moving)
		{
			return StateStatus.Running;
		}
		return StateStatus.Finished;
	}

	private void FaceCoverFromEntity()
	{
		coverFromEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if (!((Object)(object)coverFromEntity == (Object)null))
		{
			brain.Navigator.SetFacingDirectionEntity(coverFromEntity);
		}
	}
}


using System;
using Oxide.Core;
using UnityEngine;

public class ScientistNPC : HumanNPC, IAIMounted
{
	public enum RadioChatterType
	{
		NONE,
		Idle,
		Alert
	}

	public GameObjectRef[] RadioChatterEffects;

	public GameObjectRef[] DeathEffects;

	public string deathStatName = "kill_scientist";

	public static readonly Phrase ScientistName = new Phrase("npc_scientist", "Scientist");

	public Vector2 IdleChatterRepeatRange = new Vector2(10f, 15f);

	public RadioChatterType radioChatterType;

	public float lastAlertedTime = -100f;

	public override string displayName => ScientistName.translated;

	public void SetChatterType(RadioChatterType newType)
	{
		if (newType != radioChatterType)
		{
			if (newType == RadioChatterType.Idle)
			{
				QueueRadioChatter();
			}
			else
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)PlayRadioChatter);
			}
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetChatterType(RadioChatterType.Idle);
		((FacepunchBehaviour)this).InvokeRandomized((Action)IdleCheck, 0f, 20f, 1f);
	}

	public void IdleCheck()
	{
		if (Time.time > lastAlertedTime + 20f)
		{
			SetChatterType(RadioChatterType.Idle);
		}
	}

	public void QueueRadioChatter()
	{
		if (IsAlive() && !base.IsDestroyed)
		{
			((FacepunchBehaviour)this).Invoke((Action)PlayRadioChatter, Random.Range(IdleChatterRepeatRange.x, IdleChatterRepeatRange.y));
		}
	}

	public override bool ShotTest(float targetDist)
	{
		bool result = base.ShotTest(targetDist);
		if (Time.time - lastGunShotTime < 5f)
		{
			Alert();
		}
		return result;
	}

	public void Alert()
	{
		if (Interface.CallHook("OnNpcAlert", (object)this) == null)
		{
			lastAlertedTime = Time.time;
			SetChatterType(RadioChatterType.Alert);
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		Alert();
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		base.OnDied(info);
		SetChatterType(RadioChatterType.NONE);
		if (DeathEffects.Length != 0)
		{
			Effect.server.Run(DeathEffects[Random.Range(0, DeathEffects.Length)].resourcePath, ServerPosition, Vector3.up);
		}
		if (info != null && (Object)(object)info.InitiatorPlayer != (Object)null && !info.InitiatorPlayer.IsNpc)
		{
			info.InitiatorPlayer.stats.Add(deathStatName, 1, (Stats)5);
		}
	}

	public void PlayRadioChatter()
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (RadioChatterEffects.Length != 0)
		{
			if (base.IsDestroyed || (Object)(object)((Component)this).transform == (Object)null)
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)PlayRadioChatter);
			}
			else if (Interface.CallHook("OnNpcRadioChatter", (object)this) == null)
			{
				Effect.server.Run(RadioChatterEffects[Random.Range(0, RadioChatterEffects.Length)].resourcePath, this, StringPool.Get("head"), Vector3.zero, Vector3.zero);
				QueueRadioChatter();
			}
		}
	}

	public override void EquipWeapon(bool skipDeployDelay = false)
	{
		base.EquipWeapon(skipDeployDelay);
		HeldEntity heldEntity = GetHeldEntity();
		if (!((Object)(object)heldEntity != (Object)null))
		{
			return;
		}
		Item item = heldEntity.GetItem();
		if (item == null || item.contents == null || Interface.CallHook("OnNpcEquipWeapon", (object)this, (object)item) != null)
		{
			return;
		}
		if (Random.Range(0, 3) == 0)
		{
			Item item2 = ItemManager.CreateByName("weapon.mod.flashlight", 1, 0uL);
			if (!item2.MoveToContainer(item.contents))
			{
				item2.Remove();
				return;
			}
			lightsOn = false;
			((FacepunchBehaviour)this).InvokeRandomized((Action)base.LightCheck, 0f, 30f, 5f);
			LightCheck();
		}
		else
		{
			Item item3 = ItemManager.CreateByName("weapon.mod.lasersight", 1, 0uL);
			if (!item3.MoveToContainer(item.contents))
			{
				item3.Remove();
			}
			LightToggle();
			lightsOn = true;
		}
	}

	public bool IsMounted()
	{
		return base.isMounted;
	}
}


public enum RadioChatterType
{
	NONE,
	Idle,
	Alert
}


using Rust;
using UnityEngine;

public class TunnelDweller : HumanNPC
{
	public static readonly Phrase TunnelDwellerName = new Phrase("npc_tunneldweller", "Tunnel Dweller");

	private const string DWELLER_KILL_STAT = "dweller_kills_while_moving";

	public override string displayName => TunnelDwellerName.translated;

	protected override void OnKilledByPlayer(BasePlayer p)
	{
		base.OnKilledByPlayer(p);
		if (GameInfo.HasAchievements && (Object)(object)p.GetParentEntity() != (Object)null && p.GetParentEntity() is TrainEngine { CurThrottleSetting: not TrainEngine.EngineSpeeds.Zero, IsMovingOrOn: not false })
		{
			p.stats.Add("dweller_kills_while_moving", 1, Stats.All);
			p.stats.Save(forceSteamSave: true);
		}
	}
}


public class UnderwaterDweller : HumanNPC
{
	public static readonly Phrase UnderwaterDwellerName = new Phrase("npc_underwaterdweller", "Underwater Dweller");

	public override string displayName => UnderwaterDwellerName.translated;
}


using System;
using System.Collections;
using System.Collections.Generic;
using ConVar;
using Oxide.Core;
using UnityEngine;
using UnityEngine.AI;

public class NPCPlayer : BasePlayer
{
	public float MovementTickStartDelay = 1f;

	public AIInformationZone VirtualInfoZone;

	public Vector3 finalDestination;

	[NonSerialized]
	private float randomOffset;

	[NonSerialized]
	public Vector3 spawnPos;

	public PlayerInventoryProperties[] loadouts;

	public LayerMask movementMask = LayerMask.op_Implicit(1503731969);

	public bool LegacyNavigation = true;

	public NavMeshAgent NavAgent;

	public float damageScale = 1f;

	public float shortRange = 10f;

	public float attackLengthMaxShortRangeScale = 1f;

	private bool _isDormant;

	private string loadoutname;

	public float lastGunShotTime;

	public float triggerEndTime;

	public float nextTriggerTime;

	private float lastThinkTime;

	private float lastPositionUpdateTime;

	private float lastMovementTickTime;

	public Vector3 lastPos;

	private float lastThrowTime;

	public override bool IsNpc => true;

	public virtual bool IsDormant
	{
		get
		{
			return _isDormant;
		}
		set
		{
			_isDormant = value;
			_ = _isDormant;
		}
	}

	public override float PositionTickRate
	{
		protected get
		{
			return 0.1f;
		}
	}

	public virtual bool IsOnNavMeshLink
	{
		get
		{
			if (IsNavRunning())
			{
				return NavAgent.isOnOffMeshLink;
			}
			return false;
		}
	}

	public virtual bool HasPath
	{
		get
		{
			if (IsNavRunning())
			{
				return NavAgent.hasPath;
			}
			return false;
		}
	}

	protected virtual string CorpsePath => "assets/prefabs/npc/scientist/scientist_corpse.prefab";

	protected virtual bool ShouldCorpseTakeChildren => true;

	protected virtual bool KeepCorpseClothingIntact => true;

	protected virtual string OverrideCorpseName => displayName;

	protected virtual bool CopyInventoryToCorpse => true;

	public virtual bool IsLoadBalanced()
	{
		return false;
	}

	public override void ServerInit()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		spawnPos = GetPosition();
		randomOffset = Random.Range(0f, 1f);
		base.ServerInit();
		UpdateNetworkGroup();
		EquipLoadout(loadouts);
		if (!IsLoadBalanced())
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)ServerThink_Internal, 0f, 0.1f);
			lastThinkTime = Time.time;
		}
		((FacepunchBehaviour)this).Invoke((Action)EquipTest, 0.25f);
		finalDestination = ((Component)this).transform.position;
		if ((Object)(object)NavAgent == (Object)null)
		{
			NavAgent = ((Component)this).GetComponent<NavMeshAgent>();
		}
		if (Object.op_Implicit((Object)(object)NavAgent))
		{
			NavAgent.updateRotation = false;
			NavAgent.updatePosition = false;
			if (!LegacyNavigation)
			{
				((Component)((Component)this).transform).gameObject.GetComponent<BaseNavigator>().Init(this, NavAgent);
			}
		}
		((FacepunchBehaviour)this).InvokeRandomized((Action)TickMovement, MovementTickStartDelay, PositionTickRate, PositionTickRate * 0.1f);
	}

	public string GetLoadoutName()
	{
		return loadoutname;
	}

	public void EquipLoadout(PlayerInventoryProperties[] loads)
	{
		if (loads != null && loads.Length != 0)
		{
			int num = Random.Range(0, loads.Length);
			loadoutname = loads[num].niceName;
			loads[num].GiveToPlayer(this);
		}
	}

	public override void ApplyInheritedVelocity(Vector3 velocity)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		ServerPosition = BaseNpc.GetNewNavPosWithVelocity(this, velocity);
	}

	public void RandomMove()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		float num = 8f;
		Vector2 val = Random.insideUnitCircle * num;
		SetDestination(spawnPos + new Vector3(val.x, 0f, val.y));
	}

	public virtual void SetDestination(Vector3 newDestination)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		finalDestination = newDestination;
	}

	public AttackEntity GetAttackEntity()
	{
		return GetHeldEntity() as AttackEntity;
	}

	public BaseProjectile GetGun()
	{
		AttackEntity attackEntity = GetHeldEntity() as AttackEntity;
		if ((Object)(object)attackEntity == (Object)null)
		{
			return null;
		}
		BaseProjectile baseProjectile = attackEntity as BaseProjectile;
		if (Object.op_Implicit((Object)(object)baseProjectile))
		{
			return baseProjectile;
		}
		return null;
	}

	public virtual float AmmoFractionRemaining()
	{
		AttackEntity attackEntity = GetAttackEntity();
		if (Object.op_Implicit((Object)(object)attackEntity))
		{
			return attackEntity.AmmoFraction();
		}
		return 0f;
	}

	public virtual bool IsReloading()
	{
		AttackEntity attackEntity = GetAttackEntity();
		if (!Object.op_Implicit((Object)(object)attackEntity))
		{
			return false;
		}
		return attackEntity.ServerIsReloading();
	}

	public virtual void AttemptReload()
	{
		AttackEntity attackEntity = GetAttackEntity();
		if (!((Object)(object)attackEntity == (Object)null) && attackEntity.CanReload())
		{
			attackEntity.ServerReload();
		}
	}

	public virtual bool ShotTest(float targetDist)
	{
		AttackEntity attackEntity = GetHeldEntity() as AttackEntity;
		if ((Object)(object)attackEntity == (Object)null)
		{
			return false;
		}
		BaseProjectile baseProjectile = attackEntity as BaseProjectile;
		if (Object.op_Implicit((Object)(object)baseProjectile))
		{
			if (baseProjectile.primaryMagazine.contents <= 0)
			{
				baseProjectile.ServerReload();
				return false;
			}
			if (baseProjectile.NextAttackTime > Time.time)
			{
				return false;
			}
		}
		else
		{
			FlameThrower flameThrower = attackEntity as FlameThrower;
			if ((Object)(object)flameThrower != (Object)null && flameThrower.ammo <= 0)
			{
				flameThrower.ServerReload();
				return false;
			}
		}
		if (!Mathf.Approximately(attackEntity.attackLengthMin, -1f))
		{
			if (((FacepunchBehaviour)this).IsInvoking((Action)TriggerDown))
			{
				return true;
			}
			if (Time.time < nextTriggerTime)
			{
				return true;
			}
			((FacepunchBehaviour)this).InvokeRepeating((Action)TriggerDown, 0f, 0.01f);
			if (targetDist <= shortRange)
			{
				triggerEndTime = Time.time + Random.Range(attackEntity.attackLengthMin, attackEntity.attackLengthMax * attackLengthMaxShortRangeScale);
			}
			else
			{
				triggerEndTime = Time.time + Random.Range(attackEntity.attackLengthMin, attackEntity.attackLengthMax);
			}
			TriggerDown();
			return true;
		}
		attackEntity.ServerUse(damageScale, 1f, null);
		lastGunShotTime = Time.time;
		return true;
	}

	public virtual float GetAimConeScale()
	{
		return 1f;
	}

	public void CancelBurst(float delay = 0.2f)
	{
		if (triggerEndTime > Time.time + delay)
		{
			triggerEndTime = Time.time + delay;
		}
	}

	public bool MeleeAttack()
	{
		AttackEntity attackEntity = GetHeldEntity() as AttackEntity;
		if ((Object)(object)attackEntity == (Object)null)
		{
			return false;
		}
		BaseMelee baseMelee = attackEntity as BaseMelee;
		if ((Object)(object)baseMelee == (Object)null)
		{
			return false;
		}
		baseMelee.ServerUse(damageScale, 1f, null);
		return true;
	}

	public virtual void TriggerDown()
	{
		AttackEntity attackEntity = GetHeldEntity() as AttackEntity;
		if ((Object)(object)attackEntity != (Object)null)
		{
			attackEntity.ServerUse(damageScale, 1f, null);
		}
		lastGunShotTime = Time.time;
		if (Time.time > triggerEndTime)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)TriggerDown);
			nextTriggerTime = Time.time + (((Object)(object)attackEntity != (Object)null) ? attackEntity.attackSpacing : 1f);
		}
	}

	public virtual void EquipWeapon(bool skipDeployDelay = false)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)base.inventory == (Object)null || base.inventory.containerBelt == null)
		{
			return;
		}
		Item slot = base.inventory.containerBelt.GetSlot(0);
		if (Interface.CallHook("OnNpcEquipWeapon", (object)this, (object)slot) != null || slot == null)
		{
			return;
		}
		UpdateActiveItem(base.inventory.containerBelt.GetSlot(0).uid);
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (!((Object)(object)heldEntity != (Object)null))
		{
			return;
		}
		AttackEntity component = ((Component)heldEntity).GetComponent<AttackEntity>();
		if ((Object)(object)component != (Object)null)
		{
			if (skipDeployDelay)
			{
				component.ResetAttackCooldown();
			}
			component.TopUpAmmo();
		}
	}

	public void EquipTest()
	{
		EquipWeapon(skipDeployDelay: true);
	}

	internal void ServerThink_Internal()
	{
		float delta = Time.time - lastThinkTime;
		ServerThink(delta);
		lastThinkTime = Time.time;
	}

	public virtual void ServerThink(float delta)
	{
		TickAi(delta);
	}

	public virtual void Resume()
	{
	}

	public virtual bool IsNavRunning()
	{
		return false;
	}

	public virtual void TickAi(float delta)
	{
	}

	public void TickMovement()
	{
		float delta = Time.realtimeSinceStartup - lastMovementTickTime;
		lastMovementTickTime = Time.realtimeSinceStartup;
		MovementUpdate(delta);
	}

	public override float GetNetworkTime()
	{
		if (Time.realtimeSinceStartup - lastPositionUpdateTime > PositionTickRate * 2f)
		{
			return Time.time;
		}
		return lastPositionUpdateTime;
	}

	public virtual void MovementUpdate(float delta)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		if (!LegacyNavigation || base.isClient || !IsAlive() || IsWounded() || (!base.isMounted && !IsNavRunning()))
		{
			return;
		}
		if (IsDormant || !syncPosition)
		{
			if (IsNavRunning())
			{
				NavAgent.destination = ServerPosition;
			}
			return;
		}
		Vector3 moveToPosition = ((Component)this).transform.position;
		if (HasPath)
		{
			moveToPosition = NavAgent.nextPosition;
		}
		if (ValidateNextPosition(ref moveToPosition))
		{
			UpdateSpeed(delta);
			UpdatePositionAndRotation(moveToPosition);
		}
	}

	private bool ValidateNextPosition(ref Vector3 moveToPosition)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		if (!ValidBounds.Test(this, moveToPosition) && (Object)(object)((Component)this).transform != (Object)null && !base.IsDestroyed)
		{
			Debug.Log((object)("Invalid NavAgent Position: " + ((object)this)?.ToString() + " " + ((object)(Vector3)(ref moveToPosition)/*cast due to .constrained prefix*/).ToString() + " (destroying)"));
			Kill();
			return false;
		}
		return true;
	}

	private void UpdateSpeed(float delta)
	{
		float num = DesiredMoveSpeed();
		NavAgent.speed = Mathf.Lerp(NavAgent.speed, num, delta * 8f);
	}

	protected virtual void UpdatePositionAndRotation(Vector3 moveToPosition)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		lastPositionUpdateTime = Time.time;
		ServerPosition = moveToPosition;
		SetAimDirection(GetAimDirection());
	}

	public Vector3 GetPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public virtual float DesiredMoveSpeed()
	{
		float running = Mathf.Sin(Time.time + randomOffset);
		return GetSpeed(running, 0f, 0f);
	}

	public override bool EligibleForWounding(HitInfo info)
	{
		return false;
	}

	public virtual Vector3 GetAimDirection()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3Ex.Distance2D(finalDestination, GetPosition()) >= 1f)
		{
			Vector3 val = finalDestination - GetPosition();
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			return new Vector3(normalized.x, 0f, normalized.z);
		}
		return base.eyes.BodyForward();
	}

	public virtual void SetAimDirection(Vector3 newAim)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (!(newAim == Vector3.zero))
		{
			AttackEntity attackEntity = GetAttackEntity();
			if (Object.op_Implicit((Object)(object)attackEntity))
			{
				newAim = attackEntity.ModifyAIAim(newAim);
			}
			base.eyes.rotation = Quaternion.LookRotation(newAim, Vector3.up);
			Quaternion rotation = base.eyes.rotation;
			viewAngles = ((Quaternion)(ref rotation)).eulerAngles;
			ServerRotation = base.eyes.rotation;
			lastPositionUpdateTime = Time.time;
		}
	}

	public bool TryUseThrownWeapon(BaseEntity target, float attackRate)
	{
		if (HasThrownItemCooldown())
		{
			return false;
		}
		Item item = FindThrownWeapon();
		if (item == null)
		{
			lastThrowTime = Time.time;
			return false;
		}
		return TryUseThrownWeapon(item, target, attackRate);
	}

	public bool TryUseThrownWeapon(Item item, BaseEntity target, float attackRate)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (HasThrownItemCooldown())
		{
			return false;
		}
		float num = Vector3.Distance(((Component)target).transform.position, ((Component)this).transform.position);
		if (num <= 2f || num >= 20f)
		{
			return false;
		}
		Vector3 position = ((Component)target).transform.position;
		if (!IsVisible(CenterPoint(), position))
		{
			return false;
		}
		if (UseThrownWeapon(item, target))
		{
			if (this is ScarecrowNPC)
			{
				ScarecrowNPC.NextBeanCanAllowedTime = Time.time + Halloween.scarecrow_throw_beancan_global_delay;
			}
			lastThrowTime = Time.time;
			return true;
		}
		return false;
	}

	public bool HasThrownItemCooldown()
	{
		return Time.time - lastThrowTime < 10f;
	}

	protected bool UseThrownWeapon(Item item, BaseEntity target)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		UpdateActiveItem(item.uid);
		ThrownWeapon thrownWeapon = GetActiveItem().GetHeldEntity() as ThrownWeapon;
		if ((Object)(object)thrownWeapon == (Object)null)
		{
			return false;
		}
		((MonoBehaviour)this).StartCoroutine(DoThrow(thrownWeapon, target));
		return true;
	}

	private IEnumerator DoThrow(ThrownWeapon thrownWeapon, BaseEntity target)
	{
		modelState.aiming = true;
		yield return (object)new WaitForSeconds(1.5f);
		SetAimDirection(Vector3Ex.Direction(((Component)target).transform.position, ((Component)this).transform.position));
		thrownWeapon.ResetAttackCooldown();
		thrownWeapon.ServerThrow(((Component)target).transform.position);
		modelState.aiming = false;
		((FacepunchBehaviour)this).Invoke((Action)EquipTest, 0.5f);
	}

	public Item FindThrownWeapon()
	{
		if ((Object)(object)base.inventory == (Object)null || base.inventory.containerBelt == null)
		{
			return null;
		}
		for (int i = 0; i < base.inventory.containerBelt.capacity; i++)
		{
			Item slot = base.inventory.containerBelt.GetSlot(i);
			if (slot != null && (Object)(object)(slot.GetHeldEntity() as ThrownWeapon) != (Object)null)
			{
				return slot;
			}
		}
		return null;
	}

	public override BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List<TriggerBase> triggersOnDeath, bool forceServerSide = false)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Create corpse", 0);
		try
		{
			NPCPlayerCorpse nPCPlayerCorpse = DropCorpse(CorpsePath, flagsOnDeath, modelState) as NPCPlayerCorpse;
			if (Object.op_Implicit((Object)(object)nPCPlayerCorpse))
			{
				if ((Object)(object)NavAgent != (Object)null)
				{
					Transform transform = ((Component)nPCPlayerCorpse).transform;
					transform.position += Vector3.down * NavAgent.baseOffset;
				}
				nPCPlayerCorpse.SetLootableIn(2f);
				nPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				nPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);
				if (CopyInventoryToCorpse)
				{
					nPCPlayerCorpse.TakeFrom(this, base.inventory.containerMain, base.inventory.containerWear, base.inventory.containerBelt);
				}
				else
				{
					nPCPlayerCorpse.CreateEmptyContainer(base.inventory.containerMain.capacity);
				}
				nPCPlayerCorpse.playerName = OverrideCorpseName;
				nPCPlayerCorpse.playerSteamID = userID;
				nPCPlayerCorpse.Spawn();
				if (ShouldCorpseTakeChildren)
				{
					nPCPlayerCorpse.TakeChildren(this);
				}
				for (int i = 0; i < nPCPlayerCorpse.containers.Length; i++)
				{
					ItemContainer itemContainer = nPCPlayerCorpse.containers[i];
					if (!KeepCorpseClothingIntact || i != 1)
					{
						itemContainer.Clear();
					}
				}
				object obj = Interface.CallHook("OnCorpsePopulate", (object)this, (object)nPCPlayerCorpse);
				if (obj is BaseCorpse)
				{
					return (BaseCorpse)obj;
				}
				ApplyLoot(nPCPlayerCorpse);
			}
			return nPCPlayerCorpse;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected virtual void ApplyLoot(NPCPlayerCorpse corpse)
	{
	}
}


using UnityEngine;

public class FrankensteinBrain : PetBrain
{
	public class MoveToPointState : BasicAIState
	{
		private float originalStopDistance;

		public MoveToPointState()
			: base(AIState.MoveToPoint)
		{
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateEnter(brain, entity);
			BaseNavigator navigator = brain.Navigator;
			originalStopDistance = navigator.StoppingDistance;
			navigator.StoppingDistance = 0.5f;
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			brain.Navigator.StoppingDistance = originalStopDistance;
			Stop();
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			Vector3 pos = brain.Events.Memory.Position.Get(6);
			if (!brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Normal, MoveTowardsRate))
			{
				return StateStatus.Error;
			}
			if (!brain.Navigator.Moving)
			{
				brain.LoadDefaultAIDesign();
			}
			if (!brain.Navigator.Moving)
			{
				return StateStatus.Finished;
			}
			return StateStatus.Running;
		}
	}

	public class MoveTorwardsState : BasicAIState
	{
		public MoveTorwardsState()
			: base(AIState.MoveTowards)
		{
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity == (Object)null)
			{
				Stop();
				return StateStatus.Error;
			}
			if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Normal, MoveTowardsRate))
			{
				return StateStatus.Error;
			}
			if (!brain.Navigator.Moving)
			{
				return StateStatus.Finished;
			}
			return StateStatus.Running;
		}
	}

	[ServerVar]
	public static float MoveTowardsRate = 1f;

	public override void AddStates()
	{
		base.AddStates();
		AddState(new BaseIdleState());
		AddState(new MoveTorwardsState());
		AddState(new BaseChaseState());
		AddState(new BaseAttackState());
		AddState(new MoveToPointState());
	}

	public override void InitializeAI()
	{
		base.InitializeAI();
		base.ThinkMode = AIThinkMode.Interval;
		thinkRate = 0.25f;
		base.PathFinder = new HumanPathFinder();
		((HumanPathFinder)base.PathFinder).Init(GetBaseEntity());
	}

	public FrankensteinPet GetEntity()
	{
		return GetBaseEntity() as FrankensteinPet;
	}

	public override void OnDestroy()
	{
		base.OnDestroy();
	}
}


using UnityEngine;

public class MoveToPointState : BasicAIState
{
	private float originalStopDistance;

	public MoveToPointState()
		: base(AIState.MoveToPoint)
	{
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateEnter(brain, entity);
		BaseNavigator navigator = brain.Navigator;
		originalStopDistance = navigator.StoppingDistance;
		navigator.StoppingDistance = 0.5f;
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		brain.Navigator.StoppingDistance = originalStopDistance;
		Stop();
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		Vector3 pos = brain.Events.Memory.Position.Get(6);
		if (!brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Normal, MoveTowardsRate))
		{
			return StateStatus.Error;
		}
		if (!brain.Navigator.Moving)
		{
			brain.LoadDefaultAIDesign();
		}
		if (!brain.Navigator.Moving)
		{
			return StateStatus.Finished;
		}
		return StateStatus.Running;
	}
}


using UnityEngine;

public class MoveTorwardsState : BasicAIState
{
	public MoveTorwardsState()
		: base(AIState.MoveTowards)
	{
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			Stop();
			return StateStatus.Error;
		}
		if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Normal, MoveTowardsRate))
		{
			return StateStatus.Error;
		}
		if (!brain.Navigator.Moving)
		{
			return StateStatus.Finished;
		}
		return StateStatus.Running;
	}
}


public class MapMarkerPet : MapMarker
{
	public override void ServerInit()
	{
		base.ServerInit();
		base.limitNetworking = true;
	}

	public override bool ShouldNetworkTo(BasePlayer player)
	{
		return (ulong)player.userID == base.OwnerID;
	}
}


using ConVar;
using UnityEngine;

public class ScarecrowBrain : BaseAIBrain
{
	public class AttackState : BasicAIState
	{
		private IAIAttack attack;

		private float originalStoppingDistance;

		public AttackState()
			: base(AIState.Attack)
		{
			base.AgrresiveState = true;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			entity.SetFlag(BaseEntity.Flags.Reserved3, b: true);
			originalStoppingDistance = brain.Navigator.StoppingDistance;
			brain.Navigator.Agent.stoppingDistance = 1f;
			brain.Navigator.StoppingDistance = 1f;
			base.StateEnter(brain, entity);
			attack = entity as IAIAttack;
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity != (Object)null)
			{
				Vector3 aimDirection = GetAimDirection(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position);
				brain.Navigator.SetFacingDirectionOverride(aimDirection);
				if (attack.CanAttack(baseEntity))
				{
					StartAttacking(baseEntity);
				}
				brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
			}
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			entity.SetFlag(BaseEntity.Flags.Reserved3, b: false);
			brain.Navigator.Agent.stoppingDistance = originalStoppingDistance;
			brain.Navigator.StoppingDistance = originalStoppingDistance;
			brain.Navigator.ClearFacingDirectionOverride();
			brain.Navigator.Stop();
			StopAttacking();
		}

		private void StopAttacking()
		{
			attack.StopAttacking();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if (attack == null)
			{
				return StateStatus.Error;
			}
			if ((Object)(object)baseEntity == (Object)null)
			{
				brain.Navigator.ClearFacingDirectionOverride();
				StopAttacking();
				return StateStatus.Finished;
			}
			if (brain.Senses.ignoreSafeZonePlayers)
			{
				BasePlayer basePlayer = baseEntity as BasePlayer;
				if ((Object)(object)basePlayer != (Object)null && basePlayer.InSafeZone())
				{
					return StateStatus.Error;
				}
			}
			Vector3Ex.Direction2D(((Component)baseEntity).transform.position, ((Component)entity).transform.position);
			Vector3 position = ((Component)baseEntity).transform.position;
			if (!brain.Navigator.SetDestination(position, BaseNavigator.NavigationSpeed.Fast, 0.2f))
			{
				return StateStatus.Error;
			}
			Vector3 aimDirection = GetAimDirection(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position);
			brain.Navigator.SetFacingDirectionOverride(aimDirection);
			if (attack.CanAttack(baseEntity))
			{
				StartAttacking(baseEntity);
			}
			else
			{
				StopAttacking();
			}
			return StateStatus.Running;
		}

		private static Vector3 GetAimDirection(Vector3 from, Vector3 target)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			return Vector3Ex.Direction2D(target, from);
		}

		private void StartAttacking(BaseEntity entity)
		{
			attack.StartAttacking(entity);
		}
	}

	public class ChaseState : BasicAIState
	{
		private float throwDelayTime;

		private bool useBeanCan;

		public ChaseState()
			: base(AIState.Chase)
		{
			base.AgrresiveState = true;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			entity.SetFlag(BaseEntity.Flags.Reserved3, b: true);
			throwDelayTime = Time.time + Random.Range(0.2f, 0.5f);
			useBeanCan = (float)Random.Range(0, 100) <= 20f;
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity != (Object)null)
			{
				brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
			}
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			entity.SetFlag(BaseEntity.Flags.Reserved3, b: false);
			Stop();
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity == (Object)null)
			{
				Stop();
				return StateStatus.Error;
			}
			if (useBeanCan && Time.time >= throwDelayTime && AI.npc_use_thrown_weapons && Halloween.scarecrows_throw_beancans && Time.time >= ScarecrowNPC.NextBeanCanAllowedTime && (brain.GetBrainBaseEntity() as ScarecrowNPC).TryUseThrownWeapon(baseEntity, 10f))
			{
				brain.Navigator.Stop();
				return StateStatus.Running;
			}
			if (!(brain.GetBrainBaseEntity() as BasePlayer).modelState.aiming)
			{
				if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast, 0.25f))
				{
					return StateStatus.Error;
				}
				if (!brain.Navigator.Moving)
				{
					return StateStatus.Finished;
				}
				return StateStatus.Running;
			}
			return StateStatus.Running;
		}
	}

	public class RoamState : BasicAIState
	{
		private StateStatus status = StateStatus.Error;

		public RoamState()
			: base(AIState.Roam)
		{
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			status = StateStatus.Error;
			if (brain.PathFinder == null)
			{
				return;
			}
			ScarecrowNPC scarecrowNPC = entity as ScarecrowNPC;
			if (!((Object)(object)scarecrowNPC == (Object)null))
			{
				Vector3 val = brain.Events.Memory.Position.Get(4);
				Vector3 val2 = val;
				val2 = ((!scarecrowNPC.RoamAroundHomePoint) ? brain.PathFinder.GetBestRoamPosition(brain.Navigator, ((Component)brain.Navigator).transform.position, brain.Events.Memory.Position.Get(4), 10f, brain.Navigator.BestRoamPointMaxDistance) : brain.PathFinder.GetBestRoamPositionFromAnchor(brain.Navigator, val, val, 1f, brain.Navigator.BestRoamPointMaxDistance));
				if (brain.Navigator.SetDestination(val2, BaseNavigator.NavigationSpeed.Slow))
				{
					status = StateStatus.Running;
				}
				else
				{
					status = StateStatus.Error;
				}
			}
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			base.StateThink(delta, brain, entity);
			if (status == StateStatus.Error)
			{
				return status;
			}
			if (brain.Navigator.Moving)
			{
				return StateStatus.Running;
			}
			return StateStatus.Finished;
		}
	}

	public override void AddStates()
	{
		base.AddStates();
		AddState(new BaseIdleState());
		AddState(new ChaseState());
		AddState(new AttackState());
		AddState(new RoamState());
		AddState(new BaseFleeState());
	}

	public override void InitializeAI()
	{
		base.InitializeAI();
		base.ThinkMode = AIThinkMode.Interval;
		thinkRate = 0.25f;
		base.PathFinder = new HumanPathFinder();
		((HumanPathFinder)base.PathFinder).Init(GetBaseEntity());
	}

	public override void OnDestroy()
	{
		base.OnDestroy();
	}
}


using UnityEngine;

public class AttackState : BasicAIState
{
	private IAIAttack attack;

	private float originalStoppingDistance;

	public AttackState()
		: base(AIState.Attack)
	{
		base.AgrresiveState = true;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		entity.SetFlag(BaseEntity.Flags.Reserved3, b: true);
		originalStoppingDistance = brain.Navigator.StoppingDistance;
		brain.Navigator.Agent.stoppingDistance = 1f;
		brain.Navigator.StoppingDistance = 1f;
		base.StateEnter(brain, entity);
		attack = entity as IAIAttack;
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity != (Object)null)
		{
			Vector3 aimDirection = GetAimDirection(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position);
			brain.Navigator.SetFacingDirectionOverride(aimDirection);
			if (attack.CanAttack(baseEntity))
			{
				StartAttacking(baseEntity);
			}
			brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
		}
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		entity.SetFlag(BaseEntity.Flags.Reserved3, b: false);
		brain.Navigator.Agent.stoppingDistance = originalStoppingDistance;
		brain.Navigator.StoppingDistance = originalStoppingDistance;
		brain.Navigator.ClearFacingDirectionOverride();
		brain.Navigator.Stop();
		StopAttacking();
	}

	private void StopAttacking()
	{
		attack.StopAttacking();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if (attack == null)
		{
			return StateStatus.Error;
		}
		if ((Object)(object)baseEntity == (Object)null)
		{
			brain.Navigator.ClearFacingDirectionOverride();
			StopAttacking();
			return StateStatus.Finished;
		}
		if (brain.Senses.ignoreSafeZonePlayers)
		{
			BasePlayer basePlayer = baseEntity as BasePlayer;
			if ((Object)(object)basePlayer != (Object)null && basePlayer.InSafeZone())
			{
				return StateStatus.Error;
			}
		}
		Vector3Ex.Direction2D(((Component)baseEntity).transform.position, ((Component)entity).transform.position);
		Vector3 position = ((Component)baseEntity).transform.position;
		if (!brain.Navigator.SetDestination(position, BaseNavigator.NavigationSpeed.Fast, 0.2f))
		{
			return StateStatus.Error;
		}
		Vector3 aimDirection = GetAimDirection(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position);
		brain.Navigator.SetFacingDirectionOverride(aimDirection);
		if (attack.CanAttack(baseEntity))
		{
			StartAttacking(baseEntity);
		}
		else
		{
			StopAttacking();
		}
		return StateStatus.Running;
	}

	private static Vector3 GetAimDirection(Vector3 from, Vector3 target)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.Direction2D(target, from);
	}

	private void StartAttacking(BaseEntity entity)
	{
		attack.StartAttacking(entity);
	}
}


using ConVar;
using UnityEngine;

public class ChaseState : BasicAIState
{
	private float throwDelayTime;

	private bool useBeanCan;

	public ChaseState()
		: base(AIState.Chase)
	{
		base.AgrresiveState = true;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		entity.SetFlag(BaseEntity.Flags.Reserved3, b: true);
		throwDelayTime = Time.time + Random.Range(0.2f, 0.5f);
		useBeanCan = (float)Random.Range(0, 100) <= 20f;
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity != (Object)null)
		{
			brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
		}
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		entity.SetFlag(BaseEntity.Flags.Reserved3, b: false);
		Stop();
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			Stop();
			return StateStatus.Error;
		}
		if (useBeanCan && Time.time >= throwDelayTime && AI.npc_use_thrown_weapons && Halloween.scarecrows_throw_beancans && Time.time >= ScarecrowNPC.NextBeanCanAllowedTime && (brain.GetBrainBaseEntity() as ScarecrowNPC).TryUseThrownWeapon(baseEntity, 10f))
		{
			brain.Navigator.Stop();
			return StateStatus.Running;
		}
		if (!(brain.GetBrainBaseEntity() as BasePlayer).modelState.aiming)
		{
			if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast, 0.25f))
			{
				return StateStatus.Error;
			}
			if (!brain.Navigator.Moving)
			{
				return StateStatus.Finished;
			}
			return StateStatus.Running;
		}
		return StateStatus.Running;
	}
}


using UnityEngine;

public class RoamState : BasicAIState
{
	private StateStatus status = StateStatus.Error;

	public RoamState()
		: base(AIState.Roam)
	{
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		status = StateStatus.Error;
		if (brain.PathFinder == null)
		{
			return;
		}
		ScarecrowNPC scarecrowNPC = entity as ScarecrowNPC;
		if (!((Object)(object)scarecrowNPC == (Object)null))
		{
			Vector3 val = brain.Events.Memory.Position.Get(4);
			Vector3 val2 = val;
			val2 = ((!scarecrowNPC.RoamAroundHomePoint) ? brain.PathFinder.GetBestRoamPosition(brain.Navigator, ((Component)brain.Navigator).transform.position, brain.Events.Memory.Position.Get(4), 10f, brain.Navigator.BestRoamPointMaxDistance) : brain.PathFinder.GetBestRoamPositionFromAnchor(brain.Navigator, val, val, 1f, brain.Navigator.BestRoamPointMaxDistance));
			if (brain.Navigator.SetDestination(val2, BaseNavigator.NavigationSpeed.Slow))
			{
				status = StateStatus.Running;
			}
			else
			{
				status = StateStatus.Error;
			}
		}
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		if (status == StateStatus.Error)
		{
			return status;
		}
		if (brain.Navigator.Moving)
		{
			return StateStatus.Running;
		}
		return StateStatus.Finished;
	}
}


using ConVar;
using ProtoBuf;
using Rust;
using UnityEngine;

public class ScarecrowNPC : NPCPlayer, IAISenses, IAIAttack, IThinker
{
	public float BaseAttackRate = 2f;

	[Header("Loot")]
	public LootContainer.LootSpawnSlot[] LootSpawnSlots;

	public LootContainer.LootSpawnSlot[] bonusLootSlots;

	public static float NextBeanCanAllowedTime;

	public bool BlockClothingOnCorpse;

	public bool RoamAroundHomePoint;

	public GameObjectRef soulReleaseEffect;

	public bool wasSoulReleased;

	public ScarecrowBrain Brain { get; set; }

	public override BaseNpc.AiStatistics.FamilyEnum Family => BaseNpc.AiStatistics.FamilyEnum.Murderer;

	protected override string CorpsePath => "assets/prefabs/npc/murderer/murderer_corpse.prefab";

	protected override bool ShouldCorpseTakeChildren => false;

	protected override string OverrideCorpseName => "Scarecrow";

	public override float StartHealth()
	{
		return startHealth;
	}

	public override float StartMaxHealth()
	{
		return startHealth;
	}

	public override float MaxHealth()
	{
		return startHealth;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		Brain = ((Component)this).GetComponent<ScarecrowBrain>();
		if (!base.isClient)
		{
			AIThinkManager.Add(this);
			wasSoulReleased = false;
		}
	}

	internal override void DoServerDestroy()
	{
		AIThinkManager.Remove(this);
		base.DoServerDestroy();
	}

	public virtual void TryThink()
	{
		ServerThink_Internal();
	}

	public override void ServerThink(float delta)
	{
		base.ServerThink(delta);
		if (Brain.ShouldServerThink())
		{
			Brain.DoThink();
		}
	}

	public override string Categorize()
	{
		return "Scarecrow";
	}

	public override void EquipWeapon(bool skipDeployDelay = false)
	{
		base.EquipWeapon(skipDeployDelay);
		HeldEntity heldEntity = GetHeldEntity();
		if ((Object)(object)heldEntity != (Object)null && heldEntity is Chainsaw chainsaw)
		{
			chainsaw.ServerNPCStart();
		}
	}

	public float EngagementRange()
	{
		AttackEntity attackEntity = GetAttackEntity();
		if (Object.op_Implicit((Object)(object)attackEntity))
		{
			return attackEntity.effectiveRange * (attackEntity.aiOnlyInRange ? 1f : 2f) * Brain.AttackRangeMultiplier;
		}
		return Brain.SenseRange;
	}

	public bool IsThreat(BaseEntity entity)
	{
		return IsTarget(entity);
	}

	public bool IsTarget(BaseEntity entity)
	{
		if (entity is BasePlayer)
		{
			return !entity.IsNpc;
		}
		return false;
	}

	public bool IsFriendly(BaseEntity entity)
	{
		return false;
	}

	public bool CanAttack(BaseEntity entity)
	{
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		if (NeedsToReload())
		{
			return false;
		}
		if (IsOnCooldown())
		{
			return false;
		}
		if (!IsTargetInRange(entity, out var _))
		{
			return false;
		}
		if (InSafeZone() || (entity is BasePlayer basePlayer && basePlayer.InSafeZone()))
		{
			return false;
		}
		if (!CanSeeTarget(entity))
		{
			return false;
		}
		return true;
	}

	public bool IsTargetInRange(BaseEntity entity, out float dist)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		dist = Vector3.Distance(((Component)entity).transform.position, ((Component)this).transform.position);
		return dist <= EngagementRange();
	}

	public bool CanSeeTarget(BaseEntity entity)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		return entity.IsVisible(GetEntity().CenterPoint(), entity.CenterPoint());
	}

	public bool NeedsToReload()
	{
		return false;
	}

	public bool Reload()
	{
		return true;
	}

	public float CooldownDuration()
	{
		return BaseAttackRate;
	}

	public bool IsOnCooldown()
	{
		AttackEntity attackEntity = GetAttackEntity();
		if (Object.op_Implicit((Object)(object)attackEntity))
		{
			return attackEntity.HasAttackCooldown();
		}
		return true;
	}

	public bool StartAttacking(BaseEntity target)
	{
		BaseCombatEntity baseCombatEntity = target as BaseCombatEntity;
		if ((Object)(object)baseCombatEntity == (Object)null)
		{
			return false;
		}
		Attack(baseCombatEntity);
		return true;
	}

	private void Attack(BaseCombatEntity target)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)target == (Object)null))
		{
			Vector3 val = target.ServerPosition - ServerPosition;
			if (((Vector3)(ref val)).magnitude > 0.001f)
			{
				ServerRotation = Quaternion.LookRotation(((Vector3)(ref val)).normalized);
			}
			AttackEntity attackEntity = GetAttackEntity();
			if (Object.op_Implicit((Object)(object)attackEntity))
			{
				attackEntity.ServerUse(1f, 1f, null);
			}
		}
	}

	public void StopAttacking()
	{
	}

	public float GetAmmoFraction()
	{
		return AmmoFractionRemaining();
	}

	public BaseEntity GetBestTarget()
	{
		return null;
	}

	public void AttackTick(float delta, BaseEntity target, bool targetIsLOS)
	{
	}

	public override bool ShouldDropActiveItem()
	{
		return false;
	}

	protected override void ApplyLoot(NPCPlayerCorpse corpse)
	{
		base.ApplyLoot(corpse);
		LootContainer.LootSpawnSlot[] lootSpawnSlots;
		if (LootSpawnSlots.Length != 0)
		{
			lootSpawnSlots = LootSpawnSlots;
			for (int i = 0; i < lootSpawnSlots.Length; i++)
			{
				LootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[i];
				for (int j = 0; j < lootSpawnSlot.numberToSpawn; j++)
				{
					if (Random.Range(0f, 1f) <= lootSpawnSlot.probability)
					{
						lootSpawnSlot.definition.SpawnIntoContainer(corpse.containers[0]);
					}
				}
			}
		}
		if (!wasSoulReleased)
		{
			return;
		}
		lootSpawnSlots = bonusLootSlots;
		for (int i = 0; i < lootSpawnSlots.Length; i++)
		{
			LootContainer.LootSpawnSlot lootSpawnSlot2 = lootSpawnSlots[i];
			for (int k = 0; k < lootSpawnSlot2.numberToSpawn; k++)
			{
				if (Random.Range(0f, 1f) <= lootSpawnSlot2.probability)
				{
					lootSpawnSlot2.definition.SpawnIntoContainer(corpse.containers[0]);
				}
			}
		}
	}

	public override void Hurt(HitInfo info)
	{
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		bool flag = info.damageTypes.Has(DamageType.Slash) && info.damageTypes.Has(DamageType.Stab) && info.damageTypes.Has(DamageType.Generic) && info.damageTypes.Get(DamageType.Generic) <= 0.1f;
		if (flag)
		{
			if ((Object)(object)info.ProjectilePrefab != (Object)null && !((Object)info.ProjectilePrefab).name.Contains("vamp"))
			{
				flag = false;
			}
			if ((Object)(object)info.WeaponPrefab != (Object)null && !((Object)info.WeaponPrefab).name.Contains("vamp"))
			{
				flag = false;
			}
		}
		if (flag)
		{
			wasSoulReleased = true;
			info.damageTypes.ScaleAll(1000f);
			Effect.server.Run(soulReleaseEffect.resourcePath, this, StringPool.Get("spine3"), Vector3.zero, Vector3.forward);
		}
		else if (!info.isHeadshot)
		{
			if (((Object)(object)info.InitiatorPlayer != (Object)null && !info.InitiatorPlayer.IsNpc) || ((Object)(object)info.InitiatorPlayer == (Object)null && (Object)(object)info.Initiator != (Object)null && info.Initiator.IsNpc))
			{
				info.damageTypes.ScaleAll(Halloween.scarecrow_body_dmg_modifier);
			}
			else
			{
				info.damageTypes.ScaleAll(2f);
			}
		}
		base.Hurt(info);
	}

	public override void AttackerInfo(DeathInfo info)
	{
		base.AttackerInfo(info);
		info.inflictorName = base.inventory.containerBelt.GetSlot(0).info.shortname;
		info.attackerName = base.ShortPrefabName;
	}
}


using UnityEngine;

public class Stag : BaseAnimalNPC
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 3f;

	public override float RealisticMass => 200f;

	public override TraitFlag Traits => TraitFlag.Alive | TraitFlag.Animal | TraitFlag.Food | TraitFlag.Meat;

	public override bool WantsToEat(BaseEntity best)
	{
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		if (best.HasTrait(TraitFlag.Meat))
		{
			return false;
		}
		CollectibleEntity collectibleEntity = best as CollectibleEntity;
		if ((Object)(object)collectibleEntity != (Object)null)
		{
			ItemAmount[] itemList = collectibleEntity.itemList;
			for (int i = 0; i < itemList.Length; i++)
			{
				if (itemList[i].itemDef.category == ItemCategory.Food)
				{
					return true;
				}
			}
		}
		return base.WantsToEat(best);
	}

	public override string Categorize()
	{
		return "Stag";
	}
}


using UnityEngine;

public class ClawMark : BaseEntity
{
	public Material[] materials;

	public DeferredDecal decalComponent;
}


using System;
using UnityEngine;

public class NightEyeComponent : FacepunchBehaviour, IClientComponent
{
	[SerializeField]
	private Renderer[] nightEyes;

	private bool wasDayLastCheck;

	private void OnEnable()
	{
		wasDayLastCheck = TOD_Sky.Instance.IsDay;
		Renderer[] array = nightEyes;
		for (int i = 0; i < array.Length; i++)
		{
			((Component)array[i]).gameObject.SetActive(TOD_Sky.Instance.IsNight);
		}
		((FacepunchBehaviour)this).InvokeRandomized((Action)Tick, 5f, 5f, 2.5f);
	}

	private void OnDisable()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)Tick);
	}

	private void Tick()
	{
		TimeWarning val = TimeWarning.New("NightEyeComponent:Tick", 0);
		try
		{
			if (wasDayLastCheck && TOD_Sky.Instance.IsNight)
			{
				Renderer[] array = nightEyes;
				for (int i = 0; i < array.Length; i++)
				{
					((Component)array[i]).gameObject.SetActive(true);
				}
			}
			else if (!wasDayLastCheck && TOD_Sky.Instance.IsDay)
			{
				Renderer[] array = nightEyes;
				for (int i = 0; i < array.Length; i++)
				{
					((Component)array[i]).gameObject.SetActive(false);
				}
			}
			wasDayLastCheck = TOD_Sky.Instance.IsDay;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


public class Wolf : BaseAnimalNPC
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 2f;

	public override float RealisticMass => 45f;

	public override TraitFlag Traits => TraitFlag.Alive | TraitFlag.Animal | TraitFlag.Food | TraitFlag.Meat;

	public override bool WantsToEat(BaseEntity best)
	{
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		if (best.HasTrait(TraitFlag.Meat))
		{
			return true;
		}
		return base.WantsToEat(best);
	}

	public override string Categorize()
	{
		return "Wolf";
	}
}


public class Zombie : BaseAnimalNPC
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population;

	public override TraitFlag Traits => TraitFlag.Alive | TraitFlag.Animal | TraitFlag.Food | TraitFlag.Meat;

	public override bool WantsToEat(BaseEntity best)
	{
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		return base.WantsToEat(best);
	}

	protected override void TickSleep()
	{
		Sleep = 100f;
	}

	public override string Categorize()
	{
		return "Zombie";
	}
}


using UnityEngine;

public class AIArena : MonoBehaviour
{
}


using UnityEngine;

public class AIArenaNameTag : MonoBehaviour
{
	public BasePlayer Entity;

	public bool ShowHealth = true;

	public bool ShowName = true;

	private string trimmedName;
}


using UnityEngine;

public class AICoverPoint : AIPoint
{
	public float coverDot = 0.5f;

	public void OnDrawGizmos()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position + Vector3.up * 1f;
		Gizmos.color = Color.white;
		Gizmos.DrawLine(val, val + ((Component)this).transform.forward * 0.5f);
		Gizmos.color = Color.yellow;
		Gizmos.DrawCube(((Component)this).transform.position + Vector3.up * 0.125f, new Vector3(0.5f, 0.25f, 0.5f));
		Gizmos.DrawLine(((Component)this).transform.position, val);
		Vector3 val2 = ((Component)this).transform.forward + ((Component)this).transform.right * coverDot * 1f;
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		val2 = ((Component)this).transform.forward + -((Component)this).transform.right * coverDot * 1f;
		Vector3 normalized2 = ((Vector3)(ref val2)).normalized;
		Gizmos.DrawLine(val, val + normalized * 1f);
		Gizmos.DrawLine(val, val + normalized2 * 1f);
	}
}


using UnityEngine;

public class AICoverPointTool : MonoBehaviour
{
	private struct TestResult
	{
		public Vector3 Position;

		public bool Valid;

		public bool Forward;

		public bool Right;

		public bool Backward;

		public bool Left;
	}

	[ContextMenu("Place Cover Points")]
	public void PlaceCoverPoints()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		foreach (Transform item in ((Component)this).transform)
		{
			Object.DestroyImmediate((Object)(object)((Component)item).gameObject);
		}
		Vector3 pos = default(Vector3);
		((Vector3)(ref pos))..ctor(((Component)this).transform.position.x - 50f, ((Component)this).transform.position.y, ((Component)this).transform.position.z - 50f);
		for (int i = 0; i < 50; i++)
		{
			for (int j = 0; j < 50; j++)
			{
				TestResult result = TestPoint(pos);
				if (result.Valid)
				{
					PlacePoint(result);
				}
				pos.x += 2f;
			}
			pos.x -= 100f;
			pos.z += 2f;
		}
	}

	private TestResult TestPoint(Vector3 pos)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		pos.y += 0.5f;
		TestResult result = default(TestResult);
		result.Position = pos;
		if (HitsCover(new Ray(pos, Vector3.forward), 1218519041, 1f))
		{
			result.Forward = true;
			result.Valid = true;
		}
		if (HitsCover(new Ray(pos, Vector3.right), 1218519041, 1f))
		{
			result.Right = true;
			result.Valid = true;
		}
		if (HitsCover(new Ray(pos, Vector3.back), 1218519041, 1f))
		{
			result.Backward = true;
			result.Valid = true;
		}
		if (HitsCover(new Ray(pos, Vector3.left), 1218519041, 1f))
		{
			result.Left = true;
			result.Valid = true;
		}
		return result;
	}

	private void PlacePoint(TestResult result)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (result.Forward)
		{
			PlacePoint(result.Position, Vector3.forward);
		}
		if (result.Right)
		{
			PlacePoint(result.Position, Vector3.right);
		}
		if (result.Backward)
		{
			PlacePoint(result.Position, Vector3.back);
		}
		if (result.Left)
		{
			PlacePoint(result.Position, Vector3.left);
		}
	}

	private void PlacePoint(Vector3 pos, Vector3 dir)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		AICoverPoint aICoverPoint = new GameObject("CP").AddComponent<AICoverPoint>();
		((Component)aICoverPoint).transform.position = pos;
		((Component)aICoverPoint).transform.forward = dir;
		((Component)aICoverPoint).transform.SetParent(((Component)this).transform);
	}

	public bool HitsCover(Ray ray, int layerMask, float maxDistance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3Ex.IsNaNOrInfinity(((Ray)(ref ray)).origin))
		{
			return false;
		}
		if (Vector3Ex.IsNaNOrInfinity(((Ray)(ref ray)).direction))
		{
			return false;
		}
		if (((Ray)(ref ray)).direction == Vector3.zero)
		{
			return false;
		}
		if (GamePhysics.Trace(ray, 0f, out var _, maxDistance, layerMask, (QueryTriggerInteraction)0))
		{
			return true;
		}
		return false;
	}
}


using UnityEngine;

private struct TestResult
{
	public Vector3 Position;

	public bool Valid;

	public bool Forward;

	public bool Right;

	public bool Backward;

	public bool Left;
}


using System.Collections.Generic;
using UnityEngine;

public class AIInformationCell
{
	public Bounds BoundingBox;

	public List<AIInformationCell> NeighbourCells = new List<AIInformationCell>();

	public AIInformationCellContents<AIMovePoint> MovePoints = new AIInformationCellContents<AIMovePoint>();

	public AIInformationCellContents<AICoverPoint> CoverPoints = new AIInformationCellContents<AICoverPoint>();

	public int X { get; }

	public int Z { get; }

	public AIInformationCell(Bounds bounds, GameObject root, int x, int z)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		BoundingBox = bounds;
		X = x;
		Z = z;
		MovePoints.Init(bounds, root);
		CoverPoints.Init(bounds, root);
	}

	public void DebugDraw(Color color, bool points, float scale = 1f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		Color color2 = Gizmos.color;
		Gizmos.color = color;
		Gizmos.DrawWireCube(((Bounds)(ref BoundingBox)).center, ((Bounds)(ref BoundingBox)).size * scale);
		Gizmos.color = color2;
		if (!points)
		{
			return;
		}
		foreach (AIMovePoint item in MovePoints.Items)
		{
			Gizmos.DrawLine(((Bounds)(ref BoundingBox)).center, ((Component)item).transform.position);
		}
		foreach (AICoverPoint item2 in CoverPoints.Items)
		{
			Gizmos.DrawLine(((Bounds)(ref BoundingBox)).center, ((Component)item2).transform.position);
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class AIInformationCellContents<T> where T : AIPoint
{
	public HashSet<T> Items = new HashSet<T>();

	public int Count => Items.Count;

	public bool Empty => Items.Count == 0;

	public void Init(Bounds cellBounds, GameObject root)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		Clear();
		T[] componentsInChildren = root.GetComponentsInChildren<T>(true);
		foreach (T val in componentsInChildren)
		{
			if (((Bounds)(ref cellBounds)).Contains(((Component)val).gameObject.transform.position))
			{
				Add(val);
			}
		}
	}

	public void Clear()
	{
		Items.Clear();
	}

	public void Add(T item)
	{
		Items.Add(item);
	}

	public void Remove(T item)
	{
		Items.Remove(item);
	}
}


using UnityEngine;

public class AIInformationGrid : MonoBehaviour
{
	public int CellSize = 10;

	public Bounds BoundingBox;

	public AIInformationCell[] Cells;

	private Vector3 origin;

	private int xCellCount;

	private int zCellCount;

	private const int maxPointResults = 2048;

	private AIMovePoint[] movePointResults = new AIMovePoint[2048];

	private AICoverPoint[] coverPointResults = new AICoverPoint[2048];

	private const int maxCellResults = 512;

	private AIInformationCell[] resultCells = new AIInformationCell[512];

	[ContextMenu("Init")]
	public void Init()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		AIInformationZone component = ((Component)this).GetComponent<AIInformationZone>();
		if ((Object)(object)component == (Object)null)
		{
			Debug.LogWarning((object)"Unable to Init AIInformationGrid, no AIInformationZone found!");
			return;
		}
		BoundingBox = component.bounds;
		((Bounds)(ref BoundingBox)).center = ((Component)this).transform.position + ((Bounds)(ref component.bounds)).center + new Vector3(0f, ((Bounds)(ref BoundingBox)).extents.y, 0f);
		float num = ((Bounds)(ref BoundingBox)).extents.x * 2f;
		float num2 = ((Bounds)(ref BoundingBox)).extents.z * 2f;
		xCellCount = (int)Mathf.Ceil(num / (float)CellSize);
		zCellCount = (int)Mathf.Ceil(num2 / (float)CellSize);
		Cells = new AIInformationCell[xCellCount * zCellCount];
		Vector3 val = (origin = ((Bounds)(ref BoundingBox)).min);
		val.x = ((Bounds)(ref BoundingBox)).min.x + (float)CellSize / 2f;
		val.z = ((Bounds)(ref BoundingBox)).min.z + (float)CellSize / 2f;
		Bounds bounds = default(Bounds);
		for (int i = 0; i < zCellCount; i++)
		{
			for (int j = 0; j < xCellCount; j++)
			{
				Vector3 val2 = val;
				((Bounds)(ref bounds))..ctor(val2, new Vector3((float)CellSize, ((Bounds)(ref BoundingBox)).extents.y * 2f, (float)CellSize));
				Cells[GetIndex(j, i)] = new AIInformationCell(bounds, ((Component)this).gameObject, j, i);
				val.x += CellSize;
			}
			val.x = ((Bounds)(ref BoundingBox)).min.x + (float)CellSize / 2f;
			val.z += CellSize;
		}
	}

	private int GetIndex(int x, int z)
	{
		return z * xCellCount + x;
	}

	public AIInformationCell CellAt(int x, int z)
	{
		return Cells[GetIndex(x, z)];
	}

	public AIMovePoint[] GetMovePointsInRange(Vector3 position, float maxRange, out int pointCount)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		pointCount = 0;
		int cellCount;
		AIInformationCell[] cellsInRange = GetCellsInRange(position, maxRange, out cellCount);
		if (cellCount > 0)
		{
			for (int i = 0; i < cellCount; i++)
			{
				if (cellsInRange[i] == null)
				{
					continue;
				}
				foreach (AIMovePoint item in cellsInRange[i].MovePoints.Items)
				{
					movePointResults[pointCount] = item;
					pointCount++;
				}
			}
		}
		return movePointResults;
	}

	public AICoverPoint[] GetCoverPointsInRange(Vector3 position, float maxRange, out int pointCount)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		pointCount = 0;
		int cellCount;
		AIInformationCell[] cellsInRange = GetCellsInRange(position, maxRange, out cellCount);
		if (cellCount > 0)
		{
			for (int i = 0; i < cellCount; i++)
			{
				if (cellsInRange[i] == null)
				{
					continue;
				}
				foreach (AICoverPoint item in cellsInRange[i].CoverPoints.Items)
				{
					coverPointResults[pointCount] = item;
					pointCount++;
				}
			}
		}
		return coverPointResults;
	}

	public AIInformationCell[] GetCellsInRange(Vector3 position, float maxRange, out int cellCount)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		cellCount = 0;
		int num = (int)(maxRange / (float)CellSize);
		AIInformationCell cell = GetCell(position);
		if (cell == null)
		{
			return resultCells;
		}
		int num2 = Mathf.Max(cell.X - num, 0);
		int num3 = Mathf.Min(cell.X + num, xCellCount - 1);
		int num4 = Mathf.Max(cell.Z - num, 0);
		int num5 = Mathf.Min(cell.Z + num, zCellCount - 1);
		for (int i = num4; i <= num5; i++)
		{
			for (int j = num2; j <= num3; j++)
			{
				resultCells[cellCount] = CellAt(j, i);
				cellCount++;
				if (cellCount >= 512)
				{
					return resultCells;
				}
			}
		}
		return resultCells;
	}

	public AIInformationCell GetCell(Vector3 position)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (Cells == null)
		{
			return null;
		}
		Vector3 val = position - origin;
		if (val.x < 0f || val.z < 0f)
		{
			return null;
		}
		int num = (int)(val.x / (float)CellSize);
		int num2 = (int)(val.z / (float)CellSize);
		if (num < 0 || num >= xCellCount)
		{
			return null;
		}
		if (num2 < 0 || num2 >= zCellCount)
		{
			return null;
		}
		return CellAt(num, num2);
	}

	public void OnDrawGizmos()
	{
		DebugDraw();
	}

	public void DebugDraw()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (Cells != null)
		{
			AIInformationCell[] cells = Cells;
			for (int i = 0; i < cells.Length; i++)
			{
				cells[i]?.DebugDraw(Color.white, points: false);
			}
		}
	}
}


using UnityEngine;

public class AIInformationGridTester : MonoBehaviour
{
	public AIInformationGrid Grid;

	public float Range = 10f;
}


using System;
using System.Collections.Generic;
using ConVar;
using Unity.AI.Navigation;
using UnityEngine;
using UnityEngine.AI;

public class AIInformationZone : BaseMonoBehaviour, IServerComponent
{
	public bool RenderBounds;

	public bool ShouldSleepAI;

	public bool Virtual;

	public bool UseCalculatedCoverDistances = true;

	public static List<AIInformationZone> zones = new List<AIInformationZone>();

	public List<AICoverPoint> coverPoints = new List<AICoverPoint>();

	public List<AIMovePoint> movePoints = new List<AIMovePoint>();

	private AICoverPoint[] coverPointArray;

	private AIMovePoint[] movePointArray;

	public List<NavMeshLink> navMeshLinks = new List<NavMeshLink>();

	public List<AIMovePointPath> paths = new List<AIMovePointPath>();

	public Bounds bounds;

	public bool SetMovePointTerrainYOnEnable;

	private AIInformationGrid grid;

	[ServerVar]
	public static bool UseSimpleLOSCheck = false;

	private List<IAISleepable> sleepables = new List<IAISleepable>();

	private OBB areaBox;

	private bool isDirty = true;

	private int processIndex;

	private int halfPaths;

	private int pathSuccesses;

	private int pathFails;

	private bool initd;

	private static bool lastFrameAnyDirty = false;

	private static float rebuildStartTime = 0f;

	public static float buildTimeTest = 0f;

	private static float lastNavmeshBuildTime = 0f;

	public bool Sleeping { get; private set; }

	public int SleepingCount
	{
		get
		{
			if (!Sleeping)
			{
				return 0;
			}
			return sleepables.Count;
		}
	}

	public static AIInformationZone Merge(List<AIInformationZone> zones, GameObject newRoot)
	{
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		if (zones == null)
		{
			return null;
		}
		AIInformationZone aIInformationZone = newRoot.AddComponent<AIInformationZone>();
		aIInformationZone.UseCalculatedCoverDistances = false;
		foreach (AIInformationZone zone in zones)
		{
			if ((Object)(object)zone == (Object)null)
			{
				continue;
			}
			foreach (AIMovePoint movePoint in zone.movePoints)
			{
				aIInformationZone.AddMovePoint(movePoint);
				((Component)movePoint).transform.SetParent(newRoot.transform);
			}
			foreach (AICoverPoint coverPoint in zone.coverPoints)
			{
				aIInformationZone.AddCoverPoint(coverPoint);
				((Component)coverPoint).transform.SetParent(newRoot.transform);
			}
		}
		aIInformationZone.bounds = EncapsulateBounds(zones);
		ref Bounds reference = ref aIInformationZone.bounds;
		((Bounds)(ref reference)).extents = ((Bounds)(ref reference)).extents + new Vector3(5f, 0f, 5f);
		ref Bounds reference2 = ref aIInformationZone.bounds;
		((Bounds)(ref reference2)).center = ((Bounds)(ref reference2)).center - ((Component)aIInformationZone).transform.position;
		for (int num = zones.Count - 1; num >= 0; num--)
		{
			AIInformationZone aIInformationZone2 = zones[num];
			if (!((Object)(object)aIInformationZone2 == (Object)null))
			{
				Object.Destroy((Object)(object)aIInformationZone2);
			}
		}
		return aIInformationZone;
	}

	public static Bounds EncapsulateBounds(List<AIInformationZone> zones)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		Bounds result = default(Bounds);
		((Bounds)(ref result)).center = ((Component)zones[0]).transform.position;
		foreach (AIInformationZone zone in zones)
		{
			if (!((Object)(object)zone == (Object)null))
			{
				Vector3 center = ((Bounds)(ref zone.bounds)).center + ((Component)zone).transform.position;
				Bounds val = zone.bounds;
				((Bounds)(ref val)).center = center;
				((Bounds)(ref result)).Encapsulate(val);
			}
		}
		return result;
	}

	public void Start()
	{
		Init();
	}

	private void OnEnable()
	{
		Init();
		if (SetMovePointTerrainYOnEnable)
		{
			SetMovePointsY(8454144, 4f, 8f, 0f);
		}
	}

	private void OnDisable()
	{
		if (zones != null)
		{
			zones.Remove(this);
		}
	}

	public void Init()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		areaBox = new OBB(((Component)this).transform.position, ((Component)this).transform.lossyScale, ((Component)this).transform.rotation, bounds);
		if (!zones.Contains(this))
		{
			zones.Add(this);
		}
		if (!initd)
		{
			initd = true;
			AddInitialPoints();
			grid = ((Component)this).GetComponent<AIInformationGrid>();
			if ((Object)(object)grid != (Object)null)
			{
				grid.Init();
			}
		}
	}

	private void SetMovePointsY(int layerMask, float yStartOffset, float yDistance, float localYDefault)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		foreach (AIMovePoint movePoint in movePoints)
		{
			if (!((Object)(object)movePoint == (Object)null))
			{
				if (Physics.Raycast(((Component)movePoint).transform.position + Vector3.up * yStartOffset, Vector3.down, ref val, yDistance, layerMask))
				{
					((Component)movePoint).transform.position = ((RaycastHit)(ref val)).point + Vector3.up * 0.1f;
				}
				else
				{
					((Component)movePoint).transform.localPosition = new Vector3(((Component)movePoint).transform.localPosition.x, localYDefault, ((Component)movePoint).transform.localPosition.z);
				}
			}
		}
	}

	public void RegisterSleepableEntity(IAISleepable sleepable)
	{
		if (sleepable != null && sleepable.AllowedToSleep() && !sleepables.Contains(sleepable))
		{
			sleepables.Add(sleepable);
			if (Sleeping && sleepable.AllowedToSleep())
			{
				sleepable.SleepAI();
			}
		}
	}

	public void UnregisterSleepableEntity(IAISleepable sleepable)
	{
		if (sleepable != null)
		{
			sleepables.Remove(sleepable);
		}
	}

	public void SleepAI()
	{
		if (!AI.sleepwake || !ShouldSleepAI)
		{
			return;
		}
		foreach (IAISleepable sleepable in sleepables)
		{
			sleepable?.SleepAI();
		}
		Sleeping = true;
	}

	public void WakeAI()
	{
		foreach (IAISleepable sleepable in sleepables)
		{
			sleepable?.WakeAI();
		}
		Sleeping = false;
	}

	private void AddCoverPoint(AICoverPoint point)
	{
		if (!coverPoints.Contains(point))
		{
			coverPoints.Add(point);
			MarkDirty();
		}
	}

	private void RemoveCoverPoint(AICoverPoint point, bool markDirty = true)
	{
		coverPoints.Remove(point);
		if (markDirty)
		{
			MarkDirty();
		}
	}

	private void AddMovePoint(AIMovePoint point)
	{
		if (!movePoints.Contains(point))
		{
			movePoints.Add(point);
			MarkDirty();
		}
	}

	private void RemoveMovePoint(AIMovePoint point, bool markDirty = true)
	{
		movePoints.Remove(point);
		if (markDirty)
		{
			MarkDirty();
		}
	}

	public void MarkDirty(bool completeRefresh = false)
	{
		isDirty = true;
		processIndex = 0;
		halfPaths = 0;
		pathSuccesses = 0;
		pathFails = 0;
		if (!completeRefresh)
		{
			return;
		}
		foreach (AIMovePoint movePoint in movePoints)
		{
			movePoint.distances.Clear();
			movePoint.distancesToCover.Clear();
		}
	}

	private bool PassesBudget(float startTime, float budgetSeconds)
	{
		if (Time.realtimeSinceStartup - startTime > budgetSeconds)
		{
			return false;
		}
		return true;
	}

	public bool ProcessDistancesAttempt()
	{
		return true;
	}

	private bool ProcessDistances()
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Expected O, but got Unknown
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Invalid comparison between Unknown and I4
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		if (!UseCalculatedCoverDistances)
		{
			return true;
		}
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		float budgetSeconds = AIThinkManager.framebudgetms / 1000f * 0.25f;
		if (realtimeSinceStartup < lastNavmeshBuildTime + 60f)
		{
			budgetSeconds = 0.1f;
		}
		int num = 1 << NavMesh.GetAreaFromName("HumanNPC");
		NavMeshPath val = new NavMeshPath();
		while (PassesBudget(realtimeSinceStartup, budgetSeconds))
		{
			AIMovePoint aIMovePoint = movePoints[processIndex];
			bool flag = true;
			int num2 = 0;
			for (int num3 = aIMovePoint.distances.Keys.Count - 1; num3 >= 0; num3--)
			{
				AIMovePoint aIMovePoint2 = aIMovePoint.distances.Keys[num3];
				if (!movePoints.Contains(aIMovePoint2))
				{
					aIMovePoint.distances.Remove(aIMovePoint2);
				}
			}
			for (int num4 = aIMovePoint.distancesToCover.Keys.Count - 1; num4 >= 0; num4--)
			{
				AICoverPoint aICoverPoint = aIMovePoint.distancesToCover.Keys[num4];
				if (!coverPoints.Contains(aICoverPoint))
				{
					num2++;
					aIMovePoint.distancesToCover.Remove(aICoverPoint);
				}
			}
			foreach (AICoverPoint coverPoint in coverPoints)
			{
				if ((Object)(object)coverPoint == (Object)null || aIMovePoint.distancesToCover.Contains(coverPoint))
				{
					continue;
				}
				float num5 = -1f;
				if (Vector3.Distance(((Component)aIMovePoint).transform.position, ((Component)coverPoint).transform.position) > 40f)
				{
					num5 = -2f;
				}
				else if (NavMesh.CalculatePath(((Component)aIMovePoint).transform.position, ((Component)coverPoint).transform.position, num, val) && (int)val.status == 0)
				{
					int num6 = val.corners.Length;
					if (num6 > 1)
					{
						Vector3 val2 = val.corners[0];
						float num7 = 0f;
						for (int i = 0; i < num6; i++)
						{
							Vector3 val3 = val.corners[i];
							num7 += Vector3.Distance(val2, val3);
							val2 = val3;
						}
						num5 = num7;
						pathSuccesses++;
					}
					else
					{
						num5 = Vector3.Distance(((Component)aIMovePoint).transform.position, ((Component)coverPoint).transform.position);
						halfPaths++;
					}
				}
				else
				{
					pathFails++;
					num5 = -2f;
				}
				aIMovePoint.distancesToCover.Add(coverPoint, num5);
				if (!PassesBudget(realtimeSinceStartup, budgetSeconds))
				{
					flag = false;
					break;
				}
			}
			if (flag)
			{
				processIndex++;
			}
			if (processIndex >= movePoints.Count - 1)
			{
				break;
			}
		}
		return processIndex >= movePoints.Count - 1;
	}

	public static void BudgetedTick()
	{
		if (!AI.move || Time.realtimeSinceStartup < buildTimeTest)
		{
			return;
		}
		bool flag = false;
		foreach (AIInformationZone zone in zones)
		{
			if (zone.isDirty)
			{
				flag = true;
				_ = zone.isDirty;
				zone.isDirty = !zone.ProcessDistancesAttempt();
				break;
			}
		}
		if (Global.developer > 0)
		{
			if (flag && !lastFrameAnyDirty)
			{
				Debug.Log((object)"AIInformationZones rebuilding...");
				rebuildStartTime = Time.realtimeSinceStartup;
			}
			if (lastFrameAnyDirty && !flag)
			{
				Debug.Log((object)("AIInformationZone rebuild complete! Duration : " + (Time.realtimeSinceStartup - rebuildStartTime) + " seconds."));
			}
		}
		lastFrameAnyDirty = flag;
	}

	public void NavmeshBuildingComplete()
	{
		lastNavmeshBuildTime = Time.realtimeSinceStartup;
		buildTimeTest = Time.realtimeSinceStartup + 15f;
		MarkDirty(completeRefresh: true);
	}

	public Vector3 ClosestPointTo(Vector3 target)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return ((OBB)(ref areaBox)).ClosestPoint(target);
	}

	public void AddInitialPoints()
	{
		AICoverPoint[] componentsInChildren = ((Component)((Component)this).transform).GetComponentsInChildren<AICoverPoint>();
		foreach (AICoverPoint point in componentsInChildren)
		{
			AddCoverPoint(point);
		}
		AIMovePoint[] componentsInChildren2 = ((Component)((Component)this).transform).GetComponentsInChildren<AIMovePoint>(true);
		foreach (AIMovePoint point2 in componentsInChildren2)
		{
			AddMovePoint(point2);
		}
		RefreshPointArrays();
		NavMeshLink[] componentsInChildren3 = ((Component)((Component)this).transform).GetComponentsInChildren<NavMeshLink>(true);
		navMeshLinks.AddRange(componentsInChildren3);
		AIMovePointPath[] componentsInChildren4 = ((Component)((Component)this).transform).GetComponentsInChildren<AIMovePointPath>();
		paths.AddRange(componentsInChildren4);
	}

	private void RefreshPointArrays()
	{
		movePointArray = movePoints?.ToArray();
		coverPointArray = coverPoints?.ToArray();
	}

	public void AddDynamicAIPoints(AIMovePoint[] movePoints, AICoverPoint[] coverPoints, Func<Vector3, bool> validatePoint = null)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		if (movePoints != null)
		{
			foreach (AIMovePoint aIMovePoint in movePoints)
			{
				if (!((Object)(object)aIMovePoint == (Object)null) && (validatePoint == null || (validatePoint != null && validatePoint(((Component)aIMovePoint).transform.position))))
				{
					AddMovePoint(aIMovePoint);
				}
			}
		}
		if (coverPoints != null)
		{
			foreach (AICoverPoint aICoverPoint in coverPoints)
			{
				if (!((Object)(object)aICoverPoint == (Object)null) && (validatePoint == null || (validatePoint != null && validatePoint(((Component)aICoverPoint).transform.position))))
				{
					AddCoverPoint(aICoverPoint);
				}
			}
		}
		RefreshPointArrays();
	}

	public void RemoveDynamicAIPoints(AIMovePoint[] movePoints, AICoverPoint[] coverPoints)
	{
		if (movePoints != null)
		{
			foreach (AIMovePoint aIMovePoint in movePoints)
			{
				if (!((Object)(object)aIMovePoint == (Object)null))
				{
					RemoveMovePoint(aIMovePoint, markDirty: false);
				}
			}
		}
		if (coverPoints != null)
		{
			foreach (AICoverPoint aICoverPoint in coverPoints)
			{
				if (!((Object)(object)aICoverPoint == (Object)null))
				{
					RemoveCoverPoint(aICoverPoint, markDirty: false);
				}
			}
		}
		MarkDirty();
		RefreshPointArrays();
	}

	public AIMovePointPath GetNearestPath(Vector3 position)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if (paths == null || paths.Count == 0)
		{
			return null;
		}
		float num = float.MaxValue;
		AIMovePointPath result = null;
		foreach (AIMovePointPath path in paths)
		{
			foreach (AIMovePoint point in path.Points)
			{
				float num2 = Vector3.SqrMagnitude(((Component)point).transform.position - position);
				if (num2 < num)
				{
					num = num2;
					result = path;
				}
			}
		}
		return result;
	}

	public static AIInformationZone GetForPoint(Vector3 point, bool fallBackToNearest = true)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		if (zones == null || zones.Count == 0)
		{
			return null;
		}
		foreach (AIInformationZone zone in zones)
		{
			if (!((Object)(object)zone == (Object)null) && !zone.Virtual && ((OBB)(ref zone.areaBox)).Contains(point))
			{
				return zone;
			}
		}
		if (!fallBackToNearest)
		{
			return null;
		}
		float num = float.PositiveInfinity;
		AIInformationZone aIInformationZone = zones[0];
		foreach (AIInformationZone zone2 in zones)
		{
			if (!((Object)(object)zone2 == (Object)null) && !((Object)(object)((Component)zone2).transform == (Object)null) && !zone2.Virtual)
			{
				float num2 = Vector3.Distance(((Component)zone2).transform.position, point);
				if (num2 < num)
				{
					num = num2;
					aIInformationZone = zone2;
				}
			}
		}
		if (aIInformationZone.Virtual)
		{
			aIInformationZone = null;
		}
		return aIInformationZone;
	}

	public bool PointInside(Vector3 point)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((OBB)(ref areaBox)).Contains(point);
	}

	public AIMovePoint GetBestMovePointNear(BaseEntity targetEntity, BaseEntity fromEntity, float minRange, float maxRange, bool checkLOS = false, BaseEntity forObject = null, bool returnClosest = false, bool returnRandom = false)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)targetEntity == (Object)null || (Object)(object)fromEntity == (Object)null)
		{
			return null;
		}
		AIPoint aIPoint = null;
		AIPoint aIPoint2 = null;
		float num = -1f;
		float num2 = float.PositiveInfinity;
		int pointCount;
		AIPoint[] movePointsInRange = GetMovePointsInRange(((Component)targetEntity).transform.position, maxRange, out pointCount);
		if (movePointsInRange == null || pointCount <= 0)
		{
			return null;
		}
		for (int i = 0; i < pointCount; i++)
		{
			AIPoint aIPoint3 = movePointsInRange[i];
			if (!((Component)((Component)aIPoint3).transform.parent).gameObject.activeSelf || (!(((Component)fromEntity).transform.position.y < WaterSystem.OceanLevel) && ((Component)aIPoint3).transform.position.y < WaterSystem.OceanLevel))
			{
				continue;
			}
			float num3 = 0f;
			Vector3 position = ((Component)aIPoint3).transform.position;
			float num4 = Vector3.Distance(((Component)targetEntity).transform.position, position);
			if (num4 < num2)
			{
				aIPoint2 = aIPoint3;
				num2 = num4;
			}
			if (num4 > maxRange)
			{
				continue;
			}
			num3 += (aIPoint3.CanBeUsedBy(forObject) ? 100f : 0f);
			num3 += (1f - Mathf.InverseLerp(minRange, maxRange, num4)) * 100f;
			if (num3 < num)
			{
				continue;
			}
			if (checkLOS)
			{
				BasePlayer basePlayer = targetEntity as BasePlayer;
				HumanNPC humanNPC = fromEntity as HumanNPC;
				bool flag;
				if (!UseSimpleLOSCheck && (Object)(object)basePlayer != (Object)null && (Object)(object)humanNPC != (Object)null)
				{
					Vector3 fromOffset = position - ((Component)humanNPC).transform.position;
					flag = humanNPC.CanSeeTarget(basePlayer, fromOffset);
				}
				else
				{
					flag = !Physics.Linecast(((Component)targetEntity).transform.position + Vector3.up, position + Vector3.up, 1218519297, (QueryTriggerInteraction)1);
				}
				if (!flag)
				{
					continue;
				}
			}
			if (num3 > num)
			{
				aIPoint = aIPoint3;
				num = num3;
			}
		}
		if ((Object)(object)aIPoint == (Object)null && returnRandom)
		{
			return movePointsInRange[Random.Range(0, movePointsInRange.Length)] as AIMovePoint;
		}
		if ((Object)(object)aIPoint == (Object)null && returnClosest)
		{
			return aIPoint2 as AIMovePoint;
		}
		return aIPoint as AIMovePoint;
	}

	public AIPoint[] GetMovePointsInRange(Vector3 currentPos, float maxRange, out int pointCount)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		pointCount = 0;
		AIMovePoint[] movePointsInRange;
		if ((Object)(object)grid != (Object)null && AI.usegrid)
		{
			movePointsInRange = grid.GetMovePointsInRange(currentPos, maxRange, out pointCount);
		}
		else
		{
			movePointsInRange = movePointArray;
			if (movePointsInRange != null)
			{
				pointCount = movePointsInRange.Length;
			}
		}
		return movePointsInRange;
	}

	private AIMovePoint GetClosestRaw(Vector3 pos, bool onlyIncludeWithCover = false)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		AIMovePoint result = null;
		float num = float.PositiveInfinity;
		foreach (AIMovePoint movePoint in movePoints)
		{
			if (!onlyIncludeWithCover || movePoint.distancesToCover.Count != 0)
			{
				float num2 = Vector3.Distance(((Component)movePoint).transform.position, pos);
				if (num2 < num)
				{
					num = num2;
					result = movePoint;
				}
			}
		}
		return result;
	}

	public AICoverPoint GetBestCoverPoint(Vector3 currentPosition, Vector3 hideFromPosition, float minRange = 0f, float maxRange = 20f, BaseEntity forObject = null, bool allowObjectToReuse = true)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		AICoverPoint aICoverPoint = null;
		float num = 0f;
		AIMovePoint closestRaw = GetClosestRaw(currentPosition, onlyIncludeWithCover: true);
		int pointCount;
		AICoverPoint[] coverPointsInRange = GetCoverPointsInRange(currentPosition, maxRange, out pointCount);
		if (coverPointsInRange == null || pointCount <= 0)
		{
			return null;
		}
		for (int i = 0; i < pointCount; i++)
		{
			AICoverPoint aICoverPoint2 = coverPointsInRange[i];
			Vector3 position = ((Component)aICoverPoint2).transform.position;
			Vector3 val = hideFromPosition - position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			float num2 = Vector3.Dot(((Component)aICoverPoint2).transform.forward, normalized);
			if (num2 < 1f - aICoverPoint2.coverDot)
			{
				continue;
			}
			float num3 = -1f;
			if (UseCalculatedCoverDistances && (Object)(object)closestRaw != (Object)null && closestRaw.distancesToCover.Contains(aICoverPoint2) && !isDirty)
			{
				num3 = closestRaw.distancesToCover[aICoverPoint2];
				if (num3 == -2f)
				{
					continue;
				}
			}
			else
			{
				num3 = Vector3.Distance(currentPosition, position);
			}
			float num4 = 0f;
			if (aICoverPoint2.InUse())
			{
				bool flag = aICoverPoint2.IsUsedBy(forObject);
				if (!(allowObjectToReuse && flag))
				{
					num4 -= 1000f;
				}
			}
			if (minRange > 0f)
			{
				num4 -= (1f - Mathf.InverseLerp(0f, minRange, num3)) * 100f;
			}
			float num5 = Mathf.Abs(position.y - currentPosition.y);
			num4 += (1f - Mathf.InverseLerp(1f, 5f, num5)) * 500f;
			num4 += Mathf.InverseLerp(1f - aICoverPoint2.coverDot, 1f, num2) * 50f;
			num4 += (1f - Mathf.InverseLerp(2f, maxRange, num3)) * 100f;
			float num6 = 1f - Mathf.InverseLerp(4f, 10f, Vector3.Distance(currentPosition, hideFromPosition));
			val = ((Component)aICoverPoint2).transform.position - currentPosition;
			float num7 = Vector3.Dot(((Vector3)(ref val)).normalized, normalized);
			num4 -= Mathf.InverseLerp(-1f, 0.25f, num7) * 50f * num6;
			if (num4 > num)
			{
				aICoverPoint = aICoverPoint2;
				num = num4;
			}
		}
		if (Object.op_Implicit((Object)(object)aICoverPoint))
		{
			return aICoverPoint;
		}
		return null;
	}

	private AICoverPoint[] GetCoverPointsInRange(Vector3 position, float maxRange, out int pointCount)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		pointCount = 0;
		AICoverPoint[] coverPointsInRange;
		if ((Object)(object)grid != (Object)null && AI.usegrid)
		{
			coverPointsInRange = grid.GetCoverPointsInRange(position, maxRange, out pointCount);
		}
		else
		{
			coverPointsInRange = coverPointArray;
			if (coverPointsInRange != null)
			{
				pointCount = coverPointsInRange.Length;
			}
		}
		return coverPointsInRange;
	}

	public NavMeshLink GetClosestNavMeshLink(Vector3 pos)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		NavMeshLink result = null;
		float num = float.PositiveInfinity;
		foreach (NavMeshLink navMeshLink in navMeshLinks)
		{
			float num2 = Vector3.Distance(((Component)navMeshLink).gameObject.transform.position, pos);
			if (num2 < num)
			{
				result = navMeshLink;
				num = num2;
				if (num2 < 0.25f)
				{
					break;
				}
			}
		}
		return result;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class AIMovePoint : AIPoint
{
	public class DistTo
	{
		public float distance;

		public AIMovePoint target;
	}

	public ListDictionary<AIMovePoint, float> distances = new ListDictionary<AIMovePoint, float>();

	public ListDictionary<AICoverPoint, float> distancesToCover = new ListDictionary<AICoverPoint, float>();

	public float radius = 1f;

	public float WaitTime;

	public List<Transform> LookAtPoints;

	public void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		Color color = Gizmos.color;
		Gizmos.color = Color.green;
		GizmosUtil.DrawWireCircleY(((Component)this).transform.position, radius);
		Gizmos.color = color;
	}

	public void DrawLookAtPoints()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		Color color = Gizmos.color;
		Gizmos.color = Color.gray;
		if (LookAtPoints != null)
		{
			foreach (Transform lookAtPoint in LookAtPoints)
			{
				if (!((Object)(object)lookAtPoint == (Object)null))
				{
					Gizmos.DrawSphere(lookAtPoint.position, 0.2f);
					Gizmos.DrawLine(((Component)this).transform.position, lookAtPoint.position);
				}
			}
		}
		Gizmos.color = color;
	}

	public void Clear()
	{
		LookAtPoints = null;
	}

	public void AddLookAtPoint(Transform transform)
	{
		if (LookAtPoints == null)
		{
			LookAtPoints = new List<Transform>();
		}
		LookAtPoints.Add(transform);
	}

	public bool HasLookAtPoints()
	{
		if (LookAtPoints != null)
		{
			return LookAtPoints.Count > 0;
		}
		return false;
	}

	public Transform GetRandomLookAtPoint()
	{
		if (LookAtPoints == null || LookAtPoints.Count == 0)
		{
			return null;
		}
		return LookAtPoints[Random.Range(0, LookAtPoints.Count)];
	}
}


public class DistTo
{
	public float distance;

	public AIMovePoint target;
}


using System.Collections.Generic;
using UnityEngine;

public class AIMovePointPath : MonoBehaviour
{
	public enum Mode
	{
		Loop,
		Reverse
	}

	public enum PathDirection
	{
		Forwards,
		Backwards
	}

	public Color DebugPathColor = Color.green;

	public Mode LoopMode;

	public List<AIMovePoint> Points = new List<AIMovePoint>();

	public void Clear()
	{
		Points.Clear();
	}

	public void AddPoint(AIMovePoint point)
	{
		Points.Add(point);
	}

	public AIMovePoint FindNearestPoint(Vector3 position)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Points[FindNearestPointIndex(position)];
	}

	public int FindNearestPointIndex(Vector3 position)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		int result = 0;
		int num2 = 0;
		foreach (AIMovePoint point in Points)
		{
			float num3 = Vector3.SqrMagnitude(position - ((Component)point).transform.position);
			if (num3 < num)
			{
				num = num3;
				result = num2;
			}
			num2++;
		}
		return result;
	}

	public AIMovePoint GetPointAtIndex(int index)
	{
		if (index < 0 || index >= Points.Count)
		{
			return null;
		}
		return Points[index];
	}

	public int GetNextPointIndex(int currentPointIndex, ref PathDirection pathDirection)
	{
		int num = currentPointIndex + ((pathDirection == PathDirection.Forwards) ? 1 : (-1));
		if (num < 0)
		{
			if (LoopMode == Mode.Loop)
			{
				num = Points.Count - 1;
			}
			else
			{
				num = 1;
				pathDirection = PathDirection.Forwards;
			}
		}
		else if (num >= Points.Count)
		{
			if (LoopMode == Mode.Loop)
			{
				num = 0;
			}
			else
			{
				num = Points.Count - 2;
				pathDirection = PathDirection.Backwards;
			}
		}
		return num;
	}

	private void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		Color color = Gizmos.color;
		Gizmos.color = DebugPathColor;
		int num = -1;
		foreach (AIMovePoint point in Points)
		{
			num++;
			if (!((Object)(object)point == (Object)null))
			{
				if (num + 1 < Points.Count)
				{
					Gizmos.DrawLine(((Component)point).transform.position, ((Component)Points[num + 1]).transform.position);
				}
				else if (LoopMode == Mode.Loop)
				{
					Gizmos.DrawLine(((Component)point).transform.position, ((Component)Points[0]).transform.position);
				}
			}
		}
		Gizmos.color = color;
	}

	private void OnDrawGizmosSelected()
	{
		if (Points == null)
		{
			return;
		}
		foreach (AIMovePoint point in Points)
		{
			point.DrawLookAtPoints();
		}
	}

	[ContextMenu("Add Child Points")]
	public void AddChildPoints()
	{
		Points = new List<AIMovePoint>();
		Points.AddRange(((Component)this).GetComponentsInChildren<AIMovePoint>());
	}
}


public enum Mode
{
	Loop,
	Reverse
}


public enum PathDirection
{
	Forwards,
	Backwards
}


using System;
using UnityEngine;

public class AIPoint : BaseMonoBehaviour
{
	private BaseEntity currentUser;

	public bool InUse()
	{
		return (Object)(object)currentUser != (Object)null;
	}

	public bool IsUsedBy(BaseEntity user)
	{
		if (!InUse())
		{
			return false;
		}
		if ((Object)(object)user == (Object)null)
		{
			return false;
		}
		return (Object)(object)user == (Object)(object)currentUser;
	}

	public bool CanBeUsedBy(BaseEntity user)
	{
		if ((Object)(object)user != (Object)null && (Object)(object)currentUser == (Object)(object)user)
		{
			return true;
		}
		return !InUse();
	}

	public void SetUsedBy(BaseEntity user, float duration = 5f)
	{
		currentUser = user;
		((FacepunchBehaviour)this).CancelInvoke((Action)ClearUsed);
		((FacepunchBehaviour)this).Invoke((Action)ClearUsed, duration);
	}

	public void SetUsedBy(BaseEntity user)
	{
		currentUser = user;
	}

	public void ClearUsed()
	{
		currentUser = null;
	}

	public void ClearIfUsedBy(BaseEntity user)
	{
		if ((Object)(object)currentUser == (Object)(object)user)
		{
			ClearUsed();
		}
	}
}


using UnityEngine;

public class AITraversalArea : TriggerBase
{
	public Transform entryPoint1;

	public Transform entryPoint2;

	public AITraversalWaitPoint[] waitPoints;

	public Bounds movementArea;

	public Transform activeEntryPoint;

	public float nextFreeTime;

	public void OnValidate()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		((Bounds)(ref movementArea)).center = ((Component)this).transform.position;
	}

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (!baseEntity.IsNpc)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public bool CanTraverse(BaseEntity ent)
	{
		return Time.time > nextFreeTime;
	}

	public Transform GetClosestEntry(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3.Distance(position, entryPoint1.position);
		float num2 = Vector3.Distance(position, entryPoint2.position);
		if (num < num2)
		{
			return entryPoint1;
		}
		return entryPoint2;
	}

	public Transform GetFarthestEntry(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3.Distance(position, entryPoint1.position);
		float num2 = Vector3.Distance(position, entryPoint2.position);
		if (num > num2)
		{
			return entryPoint1;
		}
		return entryPoint2;
	}

	public void SetBusyFor(float dur = 1f)
	{
		nextFreeTime = Time.time + dur;
	}

	public bool CanUse(Vector3 dirFrom)
	{
		return Time.time > nextFreeTime;
	}

	public override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
	}

	public AITraversalWaitPoint GetEntryPointNear(Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = GetClosestEntry(pos).position;
		Vector3 position2 = GetFarthestEntry(pos).position;
		_ = new BaseEntity[1];
		AITraversalWaitPoint result = null;
		float num = 0f;
		AITraversalWaitPoint[] array = waitPoints;
		foreach (AITraversalWaitPoint aITraversalWaitPoint in array)
		{
			if (aITraversalWaitPoint.Occupied())
			{
				continue;
			}
			Vector3 position3 = ((Component)aITraversalWaitPoint).transform.position;
			float num2 = Vector3.Distance(position, position3);
			if (!(Vector3.Distance(position2, position3) < num2))
			{
				float num3 = Vector3.Distance(position3, pos);
				float num4 = (1f - Mathf.InverseLerp(0f, 20f, num3)) * 100f;
				if (num4 > num)
				{
					num = num4;
					result = aITraversalWaitPoint;
				}
			}
		}
		return result;
	}

	public bool EntityFilter(BaseEntity ent)
	{
		if (ent.IsNpc)
		{
			return ent.isServer;
		}
		return false;
	}

	public override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
	}

	public void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.magenta;
		Gizmos.DrawCube(entryPoint1.position + Vector3.up * 0.125f, new Vector3(0.5f, 0.25f, 0.5f));
		Gizmos.DrawCube(entryPoint2.position + Vector3.up * 0.125f, new Vector3(0.5f, 0.25f, 0.5f));
		Gizmos.color = new Color(0.2f, 1f, 0.2f, 0.5f);
		Gizmos.DrawCube(((Bounds)(ref movementArea)).center, ((Bounds)(ref movementArea)).size);
		Gizmos.color = Color.magenta;
		AITraversalWaitPoint[] array = waitPoints;
		for (int i = 0; i < array.Length; i++)
		{
			GizmosUtil.DrawCircleY(((Component)array[i]).transform.position, 0.5f);
		}
	}
}


using UnityEngine;

public class AITraversalWaitPoint : MonoBehaviour
{
	public float nextFreeTime;

	public bool Occupied()
	{
		return Time.time > nextFreeTime;
	}

	public void Occupy(float dur = 1f)
	{
		nextFreeTime = Time.time + dur;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

public class BaseNavigator : BaseMonoBehaviour
{
	public enum NavigationType
	{
		None,
		NavMesh,
		AStar,
		Custom,
		Base
	}

	public enum NavigationSpeed
	{
		Slowest,
		Slow,
		Normal,
		Fast
	}

	protected enum OverrideFacingDirectionMode
	{
		None,
		Direction,
		Entity
	}

	[ServerVar(Help = "The max step-up height difference for pet base navigation")]
	public static float maxStepUpDistance = 1.7f;

	[ServerVar(Help = "How many frames between base navigation movement updates")]
	public static int baseNavMovementFrameInterval = 2;

	[ServerVar(Help = "How long we are not moving for before trigger the stuck event")]
	public static float stuckTriggerDuration = 10f;

	[ServerVar]
	public static float navTypeHeightOffset = 0.5f;

	[ServerVar]
	public static float navTypeDistance = 1f;

	[Header("General")]
	public bool CanNavigateMounted;

	public bool CanUseNavMesh = true;

	public bool CanUseAStar = true;

	public bool CanUseBaseNav;

	public bool CanUseCustomNav;

	public float StoppingDistance = 0.5f;

	public string DefaultArea = "Walkable";

	public bool CanPathFindToChaseTargetIfNoMovePoint;

	public int PathFindChaseLOSAttemptCount = 5;

	public float PathFindChaseLOSDistanceMultiplier = 1.5f;

	[Header("Stuck Detection")]
	public bool TriggerStuckEvent;

	public float StuckDistance = 1f;

	[Header("Speed")]
	public float Speed = 5f;

	public float Acceleration = 5f;

	public float TurnSpeed = 10f;

	public NavigationSpeed MoveTowardsSpeed = NavigationSpeed.Normal;

	public bool FaceMoveTowardsTarget;

	[Header("Speed Fractions")]
	public float SlowestSpeedFraction = 0.16f;

	public float SlowSpeedFraction = 0.3f;

	public float NormalSpeedFraction = 0.5f;

	public float FastSpeedFraction = 1f;

	public float LowHealthSpeedReductionTriggerFraction;

	public float LowHealthMaxSpeedFraction = 0.5f;

	public float SwimmingSpeedMultiplier = 0.25f;

	[Header("AIPoint Usage")]
	public float BestMovementPointMaxDistance = 10f;

	public float BestCoverPointMaxDistance = 20f;

	public float BestRoamPointMaxDistance = 20f;

	public float MaxRoamDistanceFromHome = -1f;

	[Header("Misc")]
	public float FaceTargetChaseDistance = 10f;

	public bool CanUseRandomMovePointIfNonFound;

	public float MaxWaterDepth = 0.75f;

	public bool SpeedBasedAvoidancePriority;

	private NavMeshPath path;

	private NavMeshQueryFilter navMeshQueryFilter;

	private int defaultAreaMask;

	[InspectorFlags]
	public Enum biomePreference = (Enum)12;

	public bool UseBiomePreference;

	[InspectorFlags]
	public Enum topologyPreference = (Enum)96;

	[InspectorFlags]
	public Enum topologyPrevent;

	[InspectorFlags]
	public Enum biomeRequirement;

	public float stuckTimer;

	public Vector3 stuckCheckPosition;

	protected bool traversingNavMeshLink;

	protected string currentNavMeshLinkName;

	protected Vector3 currentNavMeshLinkEndPos;

	protected Stack<IAIPathNode> currentAStarPath;

	protected IAIPathNode targetNode;

	protected float currentSpeedFraction = 1f;

	private float lastSetDestinationTime;

	protected OverrideFacingDirectionMode overrideFacingDirectionMode;

	protected BaseEntity facingDirectionEntity;

	protected bool overrideFacingDirection;

	protected Vector3 facingDirectionOverride;

	protected bool paused;

	private int frameCount;

	private float accumDelta;

	public AIMovePointPath Path { get; set; }

	public BasePath AStarGraph { get; set; }

	public NavMeshAgent Agent { get; private set; }

	public BaseCombatEntity BaseEntity { get; private set; }

	public Vector3 Destination { get; set; }

	public virtual bool IsOnNavMeshLink
	{
		get
		{
			if (((Behaviour)Agent).enabled)
			{
				return Agent.isOnOffMeshLink;
			}
			return false;
		}
	}

	public bool Moving => CurrentNavigationType != NavigationType.None;

	public NavigationType CurrentNavigationType { get; private set; }

	public NavigationType LastUsedNavigationType { get; private set; }

	[HideInInspector]
	public bool StuckOffNavmesh { get; private set; }

	public virtual bool HasPath
	{
		get
		{
			if ((Object)(object)Agent == (Object)null)
			{
				return false;
			}
			if (((Behaviour)Agent).enabled && Agent.hasPath)
			{
				return true;
			}
			if (currentAStarPath != null)
			{
				return true;
			}
			return false;
		}
	}

	public bool IsOverridingFacingDirection => overrideFacingDirectionMode != OverrideFacingDirectionMode.None;

	public Vector3 FacingDirectionOverride => facingDirectionOverride;

	public int TopologyPreference()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected I4, but got Unknown
		return (int)topologyPreference;
	}

	public int TopologyPrevent()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected I4, but got Unknown
		return (int)topologyPrevent;
	}

	public int BiomeRequirement()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected I4, but got Unknown
		return (int)biomeRequirement;
	}

	public virtual void Init(BaseCombatEntity entity, NavMeshAgent agent)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Expected O, but got Unknown
		defaultAreaMask = 1 << NavMesh.GetAreaFromName(DefaultArea);
		BaseEntity = entity;
		Agent = agent;
		if ((Object)(object)Agent != (Object)null)
		{
			Agent.acceleration = Acceleration;
			Agent.angularSpeed = TurnSpeed;
		}
		navMeshQueryFilter = default(NavMeshQueryFilter);
		((NavMeshQueryFilter)(ref navMeshQueryFilter)).agentTypeID = Agent.agentTypeID;
		((NavMeshQueryFilter)(ref navMeshQueryFilter)).areaMask = defaultAreaMask;
		path = new NavMeshPath();
		SetCurrentNavigationType(NavigationType.None);
	}

	public void SetNavMeshEnabled(bool flag)
	{
		if ((Object)(object)Agent == (Object)null || ((Behaviour)Agent).enabled == flag)
		{
			return;
		}
		if (AiManager.nav_disable)
		{
			((Behaviour)Agent).enabled = false;
			return;
		}
		if (((Behaviour)Agent).enabled)
		{
			if (flag)
			{
				if (Agent.isOnNavMesh)
				{
					Agent.isStopped = false;
				}
			}
			else if (Agent.isOnNavMesh)
			{
				Agent.isStopped = true;
			}
		}
		((Behaviour)Agent).enabled = flag;
		if (flag && CanEnableNavMeshNavigation())
		{
			PlaceOnNavMesh(2f);
		}
	}

	protected virtual bool CanEnableNavMeshNavigation()
	{
		if (!CanUseNavMesh)
		{
			return false;
		}
		return true;
	}

	protected virtual bool CanUpdateMovement()
	{
		if ((Object)(object)BaseEntity != (Object)null && !BaseEntity.IsAlive())
		{
			return false;
		}
		return true;
	}

	public void ForceToGround()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)DelayedForceToGround);
		((FacepunchBehaviour)this).Invoke((Action)DelayedForceToGround, 0.5f);
	}

	private void DelayedForceToGround()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		int num = 10551296;
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(((Component)this).transform.position + Vector3.up * 0.5f, Vector3.down, ref val, 1000f, num))
		{
			BaseEntity.ServerPosition = ((RaycastHit)(ref val)).point;
		}
	}

	public bool PlaceOnNavMesh(float yOffset)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (Agent.isOnNavMesh)
		{
			return true;
		}
		bool flag = false;
		float maxRange = (IsSwimming() ? 30f : 6f);
		if (GetNearestNavmeshPosition(((Component)this).transform.position + Vector3.one * yOffset, out var position, maxRange))
		{
			flag = Warp(position);
			if (flag)
			{
				OnPlacedOnNavmesh();
			}
		}
		if (!flag)
		{
			StuckOffNavmesh = true;
			OnFailedToPlaceOnNavmesh();
		}
		return flag;
	}

	public virtual void OnPlacedOnNavmesh()
	{
	}

	public virtual void OnFailedToPlaceOnNavmesh()
	{
	}

	public bool Warp(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Agent.Warp(position);
		((Behaviour)Agent).enabled = true;
		((Component)this).transform.position = position;
		if (!Agent.isOnNavMesh)
		{
			Debug.LogWarning((object)("Agent still not on navmesh after a warp. No navmesh areas matching agent type? Agent type: " + Agent.agentTypeID), (Object)(object)((Component)this).gameObject);
			StuckOffNavmesh = true;
			return false;
		}
		StuckOffNavmesh = false;
		return true;
	}

	public bool GetNearestNavmeshPosition(Vector3 target, out Vector3 position, float maxRange)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		position = ((Component)this).transform.position;
		bool result = true;
		NavMeshHit val = default(NavMeshHit);
		if (NavMesh.SamplePosition(target, ref val, maxRange, defaultAreaMask))
		{
			position = ((NavMeshHit)(ref val)).position;
		}
		else
		{
			result = false;
		}
		return result;
	}

	public bool SetBaseDestination(Vector3 pos, float speedFraction)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.move)
		{
			return false;
		}
		if (!AI.navthink)
		{
			return false;
		}
		paused = false;
		currentSpeedFraction = speedFraction;
		if (ReachedPosition(pos))
		{
			return true;
		}
		Destination = pos;
		SetCurrentNavigationType(NavigationType.Base);
		return true;
	}

	public bool SetDestination(BasePath path, IAIPathNode newTargetNode, float speedFraction)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.move)
		{
			return false;
		}
		if (!AI.navthink)
		{
			return false;
		}
		paused = false;
		if (!CanUseAStar)
		{
			return false;
		}
		if (newTargetNode == targetNode && HasPath)
		{
			return true;
		}
		if (ReachedPosition(newTargetNode.Position))
		{
			return true;
		}
		IAIPathNode closestToPoint = path.GetClosestToPoint(((Component)this).transform.position);
		if (closestToPoint == null || !closestToPoint.IsValid())
		{
			return false;
		}
		if (AStarPath.FindPath(closestToPoint, newTargetNode, out currentAStarPath, out var _))
		{
			currentSpeedFraction = speedFraction;
			targetNode = newTargetNode;
			SetCurrentNavigationType(NavigationType.AStar);
			Destination = newTargetNode.Position;
			return true;
		}
		return false;
	}

	public bool SetDestination(Vector3 pos, NavigationSpeed speed, float updateInterval = 0f, float navmeshSampleDistance = 0f)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return SetDestination(pos, GetSpeedFraction(speed), updateInterval, navmeshSampleDistance);
	}

	public virtual bool SetCustomDestination(Vector3 pos, float speedFraction = 1f, float updateInterval = 0f)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.move)
		{
			return false;
		}
		if (!AI.navthink)
		{
			return false;
		}
		if (!CanUseCustomNav)
		{
			return false;
		}
		paused = false;
		if (ReachedPosition(pos))
		{
			return true;
		}
		currentSpeedFraction = speedFraction;
		SetCurrentNavigationType(NavigationType.Custom);
		return true;
	}

	public bool SetDestination(Vector3 pos, float speedFraction = 1f, float updateInterval = 0f, float navmeshSampleDistance = 0f)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.move)
		{
			return false;
		}
		if (!AI.navthink)
		{
			return false;
		}
		if (updateInterval > 0f && !UpdateIntervalElapsed(updateInterval))
		{
			return true;
		}
		lastSetDestinationTime = Time.time;
		paused = false;
		currentSpeedFraction = speedFraction;
		if (ReachedPosition(pos))
		{
			return true;
		}
		NavigationType navigationType = NavigationType.NavMesh;
		bool num = CanUseBaseNav && CanUseNavMesh;
		NavigationType navigationType2 = NavigationType.None;
		if (num)
		{
			Vector3 navMeshPos;
			NavigationType navigationType3 = DetermineNavigationType(((Component)this).transform.position, out navMeshPos);
			navigationType2 = DetermineNavigationType(pos, out var _);
			if (navigationType2 == NavigationType.NavMesh && navigationType3 == NavigationType.NavMesh && (CurrentNavigationType == NavigationType.None || CurrentNavigationType == NavigationType.Base))
			{
				Warp(navMeshPos);
			}
			if (navigationType2 == NavigationType.Base && navigationType3 != NavigationType.Base)
			{
				BasePet basePet = BaseEntity as BasePet;
				if ((Object)(object)basePet != (Object)null)
				{
					BasePlayer basePlayer = basePet.Brain.Events.Memory.Entity.Get(5) as BasePlayer;
					if ((Object)(object)basePlayer != (Object)null)
					{
						BuildingPrivlidge buildingPrivilege = basePlayer.GetBuildingPrivilege(new OBB(pos, ((Component)this).transform.rotation, BaseEntity.bounds));
						if ((Object)(object)buildingPrivilege != (Object)null && !buildingPrivilege.IsAuthed(basePlayer) && buildingPrivilege.AnyAuthed())
						{
							return false;
						}
					}
				}
			}
			switch (navigationType2)
			{
			case NavigationType.Base:
				navigationType = ((navigationType3 == NavigationType.Base) ? NavigationType.Base : ((!(Vector3.Distance(BaseEntity.ServerPosition, pos) <= 10f) || !(Mathf.Abs(BaseEntity.ServerPosition.y - pos.y) <= 3f)) ? NavigationType.NavMesh : NavigationType.Base));
				break;
			case NavigationType.NavMesh:
				navigationType = ((navigationType3 == NavigationType.NavMesh) ? NavigationType.NavMesh : NavigationType.Base);
				break;
			}
		}
		else
		{
			navigationType = (CanUseNavMesh ? NavigationType.NavMesh : NavigationType.AStar);
		}
		switch (navigationType)
		{
		case NavigationType.Base:
			return SetBaseDestination(pos, speedFraction);
		case NavigationType.AStar:
			if ((Object)(object)AStarGraph != (Object)null)
			{
				return SetDestination(AStarGraph, AStarGraph.GetClosestToPoint(pos), speedFraction);
			}
			if (CanUseCustomNav)
			{
				return SetCustomDestination(pos, speedFraction, updateInterval);
			}
			return false;
		default:
		{
			if (AiManager.nav_disable)
			{
				return false;
			}
			if (navmeshSampleDistance > 0f && AI.setdestinationsamplenavmesh)
			{
				NavMeshHit val = default(NavMeshHit);
				if (!NavMesh.SamplePosition(pos, ref val, navmeshSampleDistance, defaultAreaMask))
				{
					return false;
				}
				pos = ((NavMeshHit)(ref val)).position;
			}
			SetCurrentNavigationType(NavigationType.NavMesh);
			if (!Agent.isOnNavMesh)
			{
				return false;
			}
			if (!((Behaviour)Agent).isActiveAndEnabled)
			{
				return false;
			}
			Destination = pos;
			bool flag;
			if (AI.usecalculatepath)
			{
				flag = NavMesh.CalculatePath(((Component)this).transform.position, Destination, navMeshQueryFilter, path);
				if (flag)
				{
					Agent.SetPath(path);
				}
				else if (AI.usesetdestinationfallback)
				{
					flag = Agent.SetDestination(Destination);
				}
			}
			else
			{
				flag = Agent.SetDestination(Destination);
			}
			if (flag && SpeedBasedAvoidancePriority)
			{
				Agent.avoidancePriority = Random.Range(0, 21) + Mathf.FloorToInt(speedFraction * 80f);
			}
			return flag;
		}
		}
	}

	private NavigationType DetermineNavigationType(Vector3 location, out Vector3 navMeshPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		navMeshPos = location;
		int num = 2097152;
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(location + Vector3.up * navTypeHeightOffset, Vector3.down, ref val, navTypeDistance, num))
		{
			return NavigationType.Base;
		}
		Vector3 position;
		int result = (GetNearestNavmeshPosition(location + Vector3.up * navTypeHeightOffset, out position, navTypeDistance) ? 1 : 4);
		navMeshPos = position;
		return (NavigationType)result;
	}

	public void SetCurrentSpeed(NavigationSpeed speed)
	{
		currentSpeedFraction = GetSpeedFraction(speed);
	}

	public bool UpdateIntervalElapsed(float updateInterval)
	{
		if (updateInterval <= 0f)
		{
			return true;
		}
		return Time.time - lastSetDestinationTime >= updateInterval;
	}

	public float GetSpeedFraction(NavigationSpeed speed)
	{
		return speed switch
		{
			NavigationSpeed.Fast => FastSpeedFraction, 
			NavigationSpeed.Normal => NormalSpeedFraction, 
			NavigationSpeed.Slow => SlowSpeedFraction, 
			NavigationSpeed.Slowest => SlowestSpeedFraction, 
			_ => 1f, 
		};
	}

	public void SetCurrentNavigationType(NavigationType navType)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (CurrentNavigationType == NavigationType.None)
		{
			stuckCheckPosition = ((Component)this).transform.position;
			stuckTimer = 0f;
		}
		CurrentNavigationType = navType;
		if (CurrentNavigationType != 0)
		{
			LastUsedNavigationType = CurrentNavigationType;
		}
		switch (navType)
		{
		case NavigationType.None:
			stuckTimer = 0f;
			break;
		case NavigationType.NavMesh:
			SetNavMeshEnabled(flag: true);
			break;
		}
	}

	public void Pause()
	{
		if (CurrentNavigationType != 0)
		{
			Stop();
			paused = true;
		}
	}

	public void Resume()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		if (paused)
		{
			SetDestination(Destination, currentSpeedFraction);
			paused = false;
		}
	}

	public void Stop()
	{
		switch (CurrentNavigationType)
		{
		case NavigationType.AStar:
			StopAStar();
			break;
		case NavigationType.NavMesh:
			StopNavMesh();
			break;
		case NavigationType.Custom:
			StopCustom();
			break;
		}
		SetCurrentNavigationType(NavigationType.None);
		paused = false;
	}

	private void StopNavMesh()
	{
		SetNavMeshEnabled(flag: false);
	}

	private void StopAStar()
	{
		currentAStarPath = null;
		targetNode = null;
	}

	protected virtual void StopCustom()
	{
	}

	public void Think(float delta)
	{
		if (AI.move && AI.navthink && !((Object)(object)BaseEntity == (Object)null))
		{
			UpdateNavigation(delta);
		}
	}

	public void UpdateNavigation(float delta)
	{
		UpdateMovement(delta);
	}

	private void UpdateMovement(float delta)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.move || !CanUpdateMovement())
		{
			return;
		}
		Vector3 moveToPosition = ((Component)this).transform.position;
		if (TriggerStuckEvent)
		{
			stuckTimer += delta;
			if (CurrentNavigationType != 0 && stuckTimer >= stuckTriggerDuration)
			{
				if (Vector3.Distance(((Component)this).transform.position, stuckCheckPosition) <= StuckDistance)
				{
					OnStuck();
				}
				stuckTimer = 0f;
				stuckCheckPosition = ((Component)this).transform.position;
			}
		}
		if (CurrentNavigationType == NavigationType.Base)
		{
			moveToPosition = Destination;
		}
		else if (IsOnNavMeshLink)
		{
			HandleNavMeshLinkTraversal(delta, ref moveToPosition);
		}
		else if (HasPath)
		{
			moveToPosition = GetNextPathPosition();
		}
		else if (CurrentNavigationType == NavigationType.Custom)
		{
			moveToPosition = Destination;
		}
		if (ValidateNextPosition(ref moveToPosition))
		{
			bool swimming = IsSwimming();
			UpdateSpeed(delta, swimming);
			UpdatePositionAndRotation(moveToPosition, delta);
		}
	}

	public virtual void OnStuck()
	{
		BasePet basePet = BaseEntity as BasePet;
		if ((Object)(object)basePet != (Object)null && (Object)(object)basePet.Brain != (Object)null)
		{
			basePet.Brain.LoadDefaultAIDesign();
		}
	}

	public virtual bool IsSwimming()
	{
		return false;
	}

	private Vector3 GetNextPathPosition()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (currentAStarPath != null && currentAStarPath.Count > 0)
		{
			IAIPathNode iAIPathNode = currentAStarPath.Peek();
			if (iAIPathNode == null || !iAIPathNode.IsValid())
			{
				return ((Component)this).transform.position;
			}
			return iAIPathNode.Position;
		}
		return Agent.nextPosition;
	}

	private bool ValidateNextPosition(ref Vector3 moveToPosition)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		bool flag = ValidBounds.Test(BaseEntity, moveToPosition);
		if ((Object)(object)BaseEntity != (Object)null && !flag && (Object)(object)((Component)this).transform != (Object)null && !BaseEntity.IsDestroyed)
		{
			Debug.Log((object)("Invalid NavAgent Position: " + ((object)this)?.ToString() + " " + ((object)(Vector3)(ref moveToPosition)/*cast due to .constrained prefix*/).ToString() + " (destroying)"));
			BaseEntity.Kill();
			return false;
		}
		return true;
	}

	private void UpdateSpeed(float delta, bool swimming)
	{
		float num = GetTargetSpeed();
		if (LowHealthSpeedReductionTriggerFraction > 0f && BaseEntity.healthFraction <= LowHealthSpeedReductionTriggerFraction)
		{
			num = Mathf.Min(num, Speed * LowHealthMaxSpeedFraction);
		}
		Agent.speed = num * (swimming ? SwimmingSpeedMultiplier : 1f);
	}

	protected virtual float GetTargetSpeed()
	{
		return Speed * currentSpeedFraction;
	}

	protected virtual void UpdatePositionAndRotation(Vector3 moveToPosition, float delta)
	{
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		if (CurrentNavigationType == NavigationType.AStar && currentAStarPath != null && currentAStarPath.Count > 0)
		{
			((Component)this).transform.position = Vector3.MoveTowards(((Component)this).transform.position, moveToPosition, Agent.speed * delta);
			BaseEntity.ServerPosition = ((Component)this).transform.localPosition;
			if (ReachedPosition(moveToPosition))
			{
				currentAStarPath.Pop();
				if (currentAStarPath.Count == 0)
				{
					Stop();
					return;
				}
				moveToPosition = currentAStarPath.Peek().Position;
			}
		}
		if (CurrentNavigationType == NavigationType.NavMesh)
		{
			if (ReachedPosition(Agent.destination))
			{
				Stop();
			}
			if ((Object)(object)BaseEntity != (Object)null)
			{
				BaseEntity.ServerPosition = moveToPosition;
			}
		}
		if (CurrentNavigationType == NavigationType.Base)
		{
			frameCount++;
			accumDelta += delta;
			if (frameCount < baseNavMovementFrameInterval)
			{
				return;
			}
			frameCount = 0;
			delta = accumDelta;
			accumDelta = 0f;
			int num = 10551552;
			Vector3 val = Vector3Ex.Direction2D(Destination, BaseEntity.ServerPosition);
			Vector3 val2 = BaseEntity.ServerPosition + val * delta * Agent.speed;
			Vector3 val3 = BaseEntity.ServerPosition + Vector3.up * maxStepUpDistance;
			Vector3 val4 = Vector3Ex.Direction(val2 + Vector3.up * maxStepUpDistance, BaseEntity.ServerPosition + Vector3.up * maxStepUpDistance);
			float num2 = Vector3.Distance(val3, val2 + Vector3.up * maxStepUpDistance) + 0.25f;
			RaycastHit val5 = default(RaycastHit);
			if (Physics.Raycast(val3, val4, ref val5, num2, num))
			{
				return;
			}
			Vector3 val6 = val2 + Vector3.up * (maxStepUpDistance + 0.3f);
			Vector3 val7 = val2;
			if (!Physics.SphereCast(val6, 0.25f, Vector3.down, ref val5, 10f, num))
			{
				return;
			}
			val7 = ((RaycastHit)(ref val5)).point;
			if (val7.y - BaseEntity.ServerPosition.y > maxStepUpDistance)
			{
				return;
			}
			BaseEntity.ServerPosition = val7;
			if (ReachedPosition(moveToPosition))
			{
				Stop();
			}
		}
		if (overrideFacingDirectionMode != 0)
		{
			ApplyFacingDirectionOverride();
		}
	}

	public virtual void ApplyFacingDirectionOverride()
	{
	}

	public void SetFacingDirectionEntity(BaseEntity entity)
	{
		overrideFacingDirectionMode = OverrideFacingDirectionMode.Entity;
		facingDirectionEntity = entity;
	}

	public void SetFacingDirectionOverride(Vector3 direction)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		overrideFacingDirectionMode = OverrideFacingDirectionMode.Direction;
		overrideFacingDirection = true;
		facingDirectionOverride = direction;
	}

	public void ClearFacingDirectionOverride()
	{
		overrideFacingDirectionMode = OverrideFacingDirectionMode.None;
		overrideFacingDirection = false;
		facingDirectionEntity = null;
	}

	protected bool ReachedPosition(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Distance(position, ((Component)this).transform.position) <= StoppingDistance;
	}

	private void HandleNavMeshLinkTraversal(float delta, ref Vector3 moveToPosition)
	{
		if (!traversingNavMeshLink)
		{
			HandleNavMeshLinkTraversalStart(delta);
		}
		HandleNavMeshLinkTraversalTick(delta, ref moveToPosition);
		if (IsNavMeshLinkTraversalComplete(delta, ref moveToPosition))
		{
			CompleteNavMeshLink();
		}
	}

	private bool HandleNavMeshLinkTraversalStart(float delta)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		OffMeshLinkData currentOffMeshLinkData = Agent.currentOffMeshLinkData;
		if (!((OffMeshLinkData)(ref currentOffMeshLinkData)).valid || !((OffMeshLinkData)(ref currentOffMeshLinkData)).activated)
		{
			return false;
		}
		Vector3 val = ((OffMeshLinkData)(ref currentOffMeshLinkData)).endPos - ((OffMeshLinkData)(ref currentOffMeshLinkData)).startPos;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		normalized.y = 0f;
		Vector3 desiredVelocity = Agent.desiredVelocity;
		desiredVelocity.y = 0f;
		if (Vector3.Dot(desiredVelocity, normalized) < 0.1f)
		{
			CompleteNavMeshLink();
			return false;
		}
		OffMeshLinkType linkType = ((OffMeshLinkData)(ref currentOffMeshLinkData)).linkType;
		currentNavMeshLinkName = ((object)(OffMeshLinkType)(ref linkType)/*cast due to .constrained prefix*/).ToString();
		Vector3 val2 = (((Object)(object)BaseEntity != (Object)null) ? BaseEntity.ServerPosition : ((Component)this).transform.position);
		val = val2 - ((OffMeshLinkData)(ref currentOffMeshLinkData)).startPos;
		float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
		val = val2 - ((OffMeshLinkData)(ref currentOffMeshLinkData)).endPos;
		if (sqrMagnitude > ((Vector3)(ref val)).sqrMagnitude)
		{
			currentNavMeshLinkEndPos = ((OffMeshLinkData)(ref currentOffMeshLinkData)).startPos;
		}
		else
		{
			currentNavMeshLinkEndPos = ((OffMeshLinkData)(ref currentOffMeshLinkData)).endPos;
		}
		traversingNavMeshLink = true;
		Agent.ActivateCurrentOffMeshLink(false);
		Agent.obstacleAvoidanceType = (ObstacleAvoidanceType)0;
		if (!(currentNavMeshLinkName == "OpenDoorLink") && !(currentNavMeshLinkName == "JumpRockLink"))
		{
			_ = currentNavMeshLinkName == "JumpFoundationLink";
		}
		return true;
	}

	private void HandleNavMeshLinkTraversalTick(float delta, ref Vector3 moveToPosition)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		if (currentNavMeshLinkName == "OpenDoorLink")
		{
			moveToPosition = Vector3.MoveTowards(moveToPosition, currentNavMeshLinkEndPos, Agent.speed * delta);
		}
		else if (currentNavMeshLinkName == "JumpRockLink")
		{
			moveToPosition = Vector3.MoveTowards(moveToPosition, currentNavMeshLinkEndPos, Agent.speed * delta);
		}
		else if (currentNavMeshLinkName == "JumpFoundationLink")
		{
			moveToPosition = Vector3.MoveTowards(moveToPosition, currentNavMeshLinkEndPos, Agent.speed * delta);
		}
		else
		{
			moveToPosition = Vector3.MoveTowards(moveToPosition, currentNavMeshLinkEndPos, Agent.speed * delta);
		}
	}

	private bool IsNavMeshLinkTraversalComplete(float delta, ref Vector3 moveToPosition)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = moveToPosition - currentNavMeshLinkEndPos;
		if (((Vector3)(ref val)).sqrMagnitude < 0.01f)
		{
			moveToPosition = currentNavMeshLinkEndPos;
			traversingNavMeshLink = false;
			currentNavMeshLinkName = string.Empty;
			CompleteNavMeshLink();
			return true;
		}
		return false;
	}

	private void CompleteNavMeshLink()
	{
		Agent.ActivateCurrentOffMeshLink(true);
		Agent.CompleteOffMeshLink();
		Agent.isStopped = false;
		Agent.obstacleAvoidanceType = (ObstacleAvoidanceType)4;
	}

	public bool IsPositionATopologyPreference(Vector3 position)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.TopologyMap != (Object)null)
		{
			int topology = TerrainMeta.TopologyMap.GetTopology(position);
			if ((TopologyPreference() & topology) != 0)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsPositionPreventTopology(Vector3 position)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.TopologyMap != (Object)null)
		{
			int topology = TerrainMeta.TopologyMap.GetTopology(position);
			if ((TopologyPrevent() & topology) != 0)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsPositionABiomePreference(Vector3 position)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Expected I4, but got Unknown
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if (!UseBiomePreference)
		{
			return true;
		}
		if ((Object)(object)TerrainMeta.BiomeMap != (Object)null)
		{
			int num = (int)biomePreference;
			if ((TerrainMeta.BiomeMap.GetBiomeMaxType(position) & num) != 0)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsPositionABiomeRequirement(Vector3 position)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if ((int)biomeRequirement == 0)
		{
			return true;
		}
		if ((Object)(object)TerrainMeta.BiomeMap != (Object)null)
		{
			int biomeMaxType = TerrainMeta.BiomeMap.GetBiomeMaxType(position);
			if ((BiomeRequirement() & biomeMaxType) != 0)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsAcceptableWaterDepth(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return WaterLevel.GetOverallWaterDepth(pos, waves: true, volumes: false) <= MaxWaterDepth;
	}

	public void SetBrakingEnabled(bool flag)
	{
		Agent.autoBraking = flag;
	}

	public static int GetNavMeshAgentID(string name)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < NavMesh.GetSettingsCount(); i++)
		{
			NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(i);
			if (name == NavMesh.GetSettingsNameFromID(((NavMeshBuildSettings)(ref settingsByIndex)).agentTypeID))
			{
				return ((NavMeshBuildSettings)(ref settingsByIndex)).agentTypeID;
			}
		}
		return -1;
	}
}


public enum NavigationType
{
	None,
	NavMesh,
	AStar,
	Custom,
	Base
}


public enum NavigationSpeed
{
	Slowest,
	Slow,
	Normal,
	Fast
}


protected enum OverrideFacingDirectionMode
{
	None,
	Direction,
	Entity
}


using System.Collections;
using Unity.Mathematics;
using UnityEngine;

public class FishSwarm : MonoBehaviour
{
	public FishShoal.FishType[] fishTypes;

	public FishShoal[] fishShoals;

	private void Awake()
	{
		fishShoals = new FishShoal[fishTypes.Length];
		for (int i = 0; i < fishTypes.Length; i++)
		{
			fishShoals[i] = new FishShoal(fishTypes[i]);
		}
		((MonoBehaviour)this).StartCoroutine(SpawnFish());
	}

	private IEnumerator SpawnFish()
	{
		while (true)
		{
			yield return CoroutineEx.waitForEndOfFrame;
			if (Object.op_Implicit((Object)(object)TerrainMeta.WaterMap) && Object.op_Implicit((Object)(object)TerrainMeta.HeightMap))
			{
				FishShoal[] array = fishShoals;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].TrySpawn(float3.op_Implicit(((Component)this).transform.position));
					yield return CoroutineEx.waitForEndOfFrame;
				}
			}
		}
	}

	private void Update()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		FishShoal[] array = fishShoals;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].OnUpdate(float3.op_Implicit(((Component)this).transform.position));
		}
	}

	private void LateUpdate()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		FishShoal[] array = fishShoals;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].OnLateUpdate(float3.op_Implicit(((Component)this).transform.position));
		}
	}

	private void OnDestroy()
	{
		FishShoal[] array = fishShoals;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Dispose();
		}
	}

	private void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.DrawWireSphere(((Component)this).transform.position, 15f);
		Gizmos.DrawWireSphere(((Component)this).transform.position, 40f);
		if (Application.isPlaying)
		{
			FishShoal[] array = fishShoals;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].OnDrawGizmosSelected();
			}
		}
	}
}


