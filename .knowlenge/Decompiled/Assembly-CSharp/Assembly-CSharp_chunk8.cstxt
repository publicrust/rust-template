using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class WeaponRack : StorageContainer
{
	[Serializable]
	public enum RackType
	{
		Board,
		Stand
	}

	public enum SpecialRackType
	{
		None,
		WesternDLC
	}

	[Header("Text")]
	public Phrase textLoadAmmos;

	public RackType Type;

	public float GridCellSize = 0.15f;

	public bool SetGridCellSizeFromCollision = true;

	public int Capacity = 30;

	public bool UseColliders;

	public int GridCellCountX = 10;

	public int GridCellCountY = 10;

	public BoxCollider Collision;

	public Transform Anchor;

	public Transform SmallPegPrefab;

	public Transform LargePegPrefab;

	[Header("Lights")]
	public GameObjectRef LightPrefab;

	public Transform[] LightPoints;

	public WeaponRackSlot[] gridSlots;

	private WeaponRackSlot[] gridCellSlotReferences;

	public int ForceItemRotation = -1;

	public bool CreatePegs = true;

	[Header("Custom Rack")]
	public SpecialRackType CustomRackType;

	public Transform CustomCenter;

	private static HashSet<int> usedSlots = new HashSet<int>();

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WeaponRack.OnRpcMessage", 0);
		try
		{
			if (rpc == 1682065633 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - LoadWeaponAmmo "));
				}
				TimeWarning val2 = TimeWarning.New("LoadWeaponAmmo", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						LoadWeaponAmmo(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in LoadWeaponAmmo");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 879556270 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ReqMountBackSlot "));
				}
				TimeWarning val2 = TimeWarning.New("ReqMountBackSlot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(879556270u, "ReqMountBackSlot", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(879556270u, "ReqMountBackSlot", this, player, 2f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ReqMountBackSlot(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ReqMountBackSlot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2640584497u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ReqMountWeapon "));
				}
				TimeWarning val2 = TimeWarning.New("ReqMountWeapon", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2640584497u, "ReqMountWeapon", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2640584497u, "ReqMountWeapon", this, player, 2f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							ReqMountWeapon(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in ReqMountWeapon");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2753286621u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ReqSwapWeapon "));
				}
				TimeWarning val2 = TimeWarning.New("ReqSwapWeapon", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2753286621u, "ReqSwapWeapon", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2753286621u, "ReqSwapWeapon", this, player, 2f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							ReqSwapWeapon(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in ReqSwapWeapon");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3761066327u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ReqTakeAll "));
				}
				TimeWarning val2 = TimeWarning.New("ReqTakeAll", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3761066327u, "ReqTakeAll", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3761066327u, "ReqTakeAll", this, player, 2f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							ReqTakeAll(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in ReqTakeAll");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1987971716 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ReqTakeWeapon "));
				}
				TimeWarning val2 = TimeWarning.New("ReqTakeWeapon", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1987971716u, "ReqTakeWeapon", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1987971716u, "ReqTakeWeapon", this, player, 2f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg7 = rPCMessage;
							ReqTakeWeapon(msg7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in ReqTakeWeapon");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3314206579u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ReqUnloadWeapon "));
				}
				TimeWarning val2 = TimeWarning.New("ReqUnloadWeapon", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3314206579u, "ReqUnloadWeapon", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3314206579u, "ReqUnloadWeapon", this, player, 2f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg8 = rPCMessage;
							ReqUnloadWeapon(msg8);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex7)
					{
						Debug.LogException(ex7);
						player.Kick("RPC Error in ReqUnloadWeapon");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		base.InitShared();
		if (SetGridCellSizeFromCollision)
		{
			GridCellSize = Collision.size.x / (float)GridCellCountX;
		}
		gridSlots = new WeaponRackSlot[Capacity];
		for (int i = 0; i < gridSlots.Length; i++)
		{
			gridSlots[i] = new WeaponRackSlot();
		}
		ClearGridCellContentsRefs();
	}

	private void ClearGridCellContentsRefs()
	{
		if (gridCellSlotReferences == null)
		{
			gridCellSlotReferences = new WeaponRackSlot[GridCellCountX * GridCellCountY];
			return;
		}
		for (int i = 0; i < gridCellSlotReferences.Length; i++)
		{
			gridCellSlotReferences[i] = null;
		}
	}

	private void SetupSlot(WeaponRackSlot slot)
	{
		if (slot != null && !((Object)(object)slot.ItemDef == (Object)null))
		{
			SetGridCellContents(slot, clear: false);
		}
	}

	private void ClearSlot(WeaponRackSlot slot)
	{
		if (slot != null && slot.Used)
		{
			SetGridCellContents(slot, clear: true);
		}
	}

	public void SetGridCellContents(WeaponRackSlot slot, bool clear)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (slot == null)
		{
			return;
		}
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(slot.ItemDef);
		if ((Object)(object)forItemDef == (Object)null)
		{
			return;
		}
		Vector2Int xYForIndex = GetXYForIndex(slot.GridSlotIndex);
		Vector2Int weaponSize = GetWeaponSize(forItemDef, slot.Rotation);
		Vector2Int weaponStart = GetWeaponStart(xYForIndex, weaponSize, clamp: false);
		if (((Vector2Int)(ref weaponStart)).x < 0 || ((Vector2Int)(ref weaponStart)).y < 0 || ((Vector2Int)(ref weaponStart)).x + ((Vector2Int)(ref weaponSize)).x > GridCellCountX || ((Vector2Int)(ref weaponStart)).y + ((Vector2Int)(ref weaponSize)).y > GridCellCountY)
		{
			return;
		}
		for (int i = ((Vector2Int)(ref weaponStart)).y; i < ((Vector2Int)(ref weaponStart)).y + ((Vector2Int)(ref weaponSize)).y; i++)
		{
			for (int j = ((Vector2Int)(ref weaponStart)).x; j < ((Vector2Int)(ref weaponStart)).x + ((Vector2Int)(ref weaponSize)).x; j++)
			{
				gridCellSlotReferences[GetGridCellIndex(j, i)] = (clear ? null : slot);
			}
		}
		slot.SetUsed(!clear);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		usedSlots.Clear();
		ClearGridCellContentsRefs();
		if (info.msg.weaponRack == null)
		{
			return;
		}
		foreach (WeaponRackItem item in info.msg.weaponRack.items)
		{
			usedSlots.Add(item.inventorySlot);
			gridSlots[item.inventorySlot].InitFromProto(item);
		}
		for (int i = 0; i < Capacity; i++)
		{
			if (usedSlots.Contains(i))
			{
				SetupSlot(gridSlots[i]);
			}
			else
			{
				ClearSlot(gridSlots[i]);
			}
		}
	}

	public WeaponRackSlot GetWeaponAtIndex(int gridIndex)
	{
		if (gridIndex < 0)
		{
			return null;
		}
		if (gridIndex >= gridCellSlotReferences.Length)
		{
			return null;
		}
		return gridCellSlotReferences[gridIndex];
	}

	public Vector2Int GetXYForIndex(int index)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2Int(index % GridCellCountX, index / GridCellCountX);
	}

	private Vector2Int GetWeaponSize(WorldModelRackMountConfig config, int rotation)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		int num = ((Type == RackType.Board) ? config.XSize : config.ZSize);
		int num2 = ((Type == RackType.Board) ? config.YSize : config.XSize);
		if (rotation != 0 && Type == RackType.Board)
		{
			return new Vector2Int(num2, num);
		}
		return new Vector2Int(num, num2);
	}

	private Vector2Int GetWeaponStart(Vector2Int targetXY, Vector2Int size, bool clamp)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if (Type == RackType.Board)
		{
			((Vector2Int)(ref targetXY)).x = ((Vector2Int)(ref targetXY)).x - ((Vector2Int)(ref size)).x / 2;
			((Vector2Int)(ref targetXY)).y = ((Vector2Int)(ref targetXY)).y - ((Vector2Int)(ref size)).y / 2;
		}
		if (clamp)
		{
			((Vector2Int)(ref targetXY)).x = Mathf.Max(((Vector2Int)(ref targetXY)).x, 0);
			((Vector2Int)(ref targetXY)).y = Mathf.Max(((Vector2Int)(ref targetXY)).y, 0);
		}
		return targetXY;
	}

	public bool CanAcceptWeaponType(WorldModelRackMountConfig weaponConfig)
	{
		if ((Object)(object)weaponConfig == (Object)null)
		{
			return false;
		}
		if (weaponConfig.ExcludedRackTypes.Contains(Type))
		{
			return false;
		}
		if (CustomRackType != 0 && weaponConfig.FindCustomRackPosition(CustomRackType) == null)
		{
			return false;
		}
		return true;
	}

	public int GetBestPlacementCellIndex(Vector2Int targetXY, WorldModelRackMountConfig config, int rotation, WeaponRackSlot ignoreSlot)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		if (Type == RackType.Stand)
		{
			((Vector2Int)(ref targetXY)).y = 0;
		}
		int gridCellIndex = GetGridCellIndex(((Vector2Int)(ref targetXY)).x, ((Vector2Int)(ref targetXY)).y);
		if (GridCellsFree(config, gridCellIndex, rotation, ignoreSlot))
		{
			return gridCellIndex;
		}
		float num = float.MaxValue;
		int result = -1;
		Vector2Int weaponSize = GetWeaponSize(config, rotation);
		Vector2Int weaponStart = GetWeaponStart(targetXY, weaponSize, clamp: true);
		Vector2Int val = default(Vector2Int);
		for (int i = ((Vector2Int)(ref weaponStart)).y; i < ((Vector2Int)(ref weaponStart)).y + ((Vector2Int)(ref weaponSize)).y + 1; i++)
		{
			if (Type == RackType.Stand && i != 0)
			{
				continue;
			}
			for (int j = ((Vector2Int)(ref weaponStart)).x; j < ((Vector2Int)(ref weaponStart)).x + ((Vector2Int)(ref weaponSize)).x + 1; j++)
			{
				gridCellIndex = GetGridCellIndex(j, i);
				if (GridCellsFree(config, gridCellIndex, rotation, ignoreSlot))
				{
					((Vector2Int)(ref val)).x = j;
					((Vector2Int)(ref val)).y = i;
					float num2 = Vector2Int.Distance(targetXY, val);
					if (!(num2 >= num))
					{
						result = gridCellIndex;
						num = num2;
					}
				}
			}
		}
		return result;
	}

	public int GetGridIndexAtPosition(Vector3 pos)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		float num = Collision.size.x - (pos.x + Collision.size.x / 2f);
		float num2 = pos.y + Collision.size.y / 2f;
		int num3 = (int)(num / GridCellSize);
		return (int)(num2 / GridCellSize) * GridCellCountX + num3;
	}

	private bool GridCellsFree(WorldModelRackMountConfig config, int gridIndex, int rotation, WeaponRackSlot ignoreGridSlot)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (gridIndex == -1)
		{
			return false;
		}
		Vector2Int xYForIndex = GetXYForIndex(gridIndex);
		Vector2Int weaponSize = GetWeaponSize(config, rotation);
		Vector2Int weaponStart = GetWeaponStart(xYForIndex, weaponSize, clamp: false);
		if (((Vector2Int)(ref weaponStart)).x < 0 || ((Vector2Int)(ref weaponStart)).y < 0)
		{
			return false;
		}
		for (int i = ((Vector2Int)(ref weaponStart)).y; i < ((Vector2Int)(ref weaponStart)).y + ((Vector2Int)(ref weaponSize)).y; i++)
		{
			for (int j = ((Vector2Int)(ref weaponStart)).x; j < ((Vector2Int)(ref weaponStart)).x + ((Vector2Int)(ref weaponSize)).x; j++)
			{
				int gridCellIndex = GetGridCellIndex(j, i);
				if (gridCellIndex == -1 || !GridCellFree(gridCellIndex, ignoreGridSlot))
				{
					return false;
				}
			}
		}
		return true;
	}

	private int GetGridCellIndex(int x, int y)
	{
		if (x < 0 || x >= GridCellCountX || y < 0 || y >= GridCellCountY)
		{
			return -1;
		}
		return y * GridCellCountX + x;
	}

	private bool GridCellFree(int index, WeaponRackSlot ignoreSlot)
	{
		if (gridCellSlotReferences[index] != null)
		{
			if (ignoreSlot != null)
			{
				return gridCellSlotReferences[index] == ignoreSlot;
			}
			return false;
		}
		return true;
	}

	private static bool ItemIsRackMountable(Item item)
	{
		return (Object)(object)WorldModelRackMountConfig.GetForItemDef(item.info) != (Object)null;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		base.inventory.onItemAddedRemoved = OnItemAddedOrRemoved;
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(InventoryItemFilter));
		SpawnLightSubEntities();
	}

	private void SpawnLightSubEntities()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoadingSave || LightPrefab == null || LightPoints == null)
		{
			return;
		}
		Transform[] lightPoints = LightPoints;
		foreach (Transform val in lightPoints)
		{
			SimpleLight simpleLight = GameManager.server.CreateEntity(LightPrefab.resourcePath, val.position, val.rotation) as SimpleLight;
			if (Object.op_Implicit((Object)(object)simpleLight))
			{
				simpleLight.enableSaving = true;
				simpleLight.SetParent(this, worldPositionStays: true);
				simpleLight.Spawn();
			}
		}
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		bool flag = false;
		if (!added)
		{
			WeaponRackSlot[] array = gridSlots;
			foreach (WeaponRackSlot weaponRackSlot in array)
			{
				if (weaponRackSlot != null && weaponRackSlot.Used)
				{
					ItemDefinition itemDef = weaponRackSlot.ItemDef;
					if ((Object)(object)itemDef == (Object)null || !itemDef.IsAllowed((EraRestriction)0))
					{
						ClearSlot(weaponRackSlot);
						flag = true;
					}
				}
			}
		}
		if (flag)
		{
			SendNetworkUpdateImmediate();
		}
	}

	private bool InventoryItemFilter(Item item, int targetSlot)
	{
		if (item == null)
		{
			return false;
		}
		return ItemIsRackMountable(item);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.weaponRack = Pool.Get<WeaponRack>();
		info.msg.weaponRack.items = Pool.Get<List<WeaponRackItem>>();
		WeaponRackSlot[] array = gridSlots;
		foreach (WeaponRackSlot weaponRackSlot in array)
		{
			if (weaponRackSlot.Used)
			{
				Item slot = base.inventory.GetSlot(weaponRackSlot.InventoryIndex);
				WeaponRackItem proto = Pool.Get<WeaponRackItem>();
				info.msg.weaponRack.items.Add(weaponRackSlot.SaveToProto(slot, proto));
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(2f)]
	private void ReqSwapWeapon(RPCMessage msg)
	{
		int num = msg.read.Int32();
		if (num != -1)
		{
			int rotation = msg.read.Int32();
			Item item = msg.player.GetHeldEntity()?.GetItem();
			if (item != null)
			{
				SwapPlayerWeapon(msg.player, num, item.position, rotation);
			}
		}
	}

	private void SwapPlayerWeapon(BasePlayer player, int gridCellIndex, int takeFromBeltIndex, int rotation)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		Item item = player.GetHeldEntity()?.GetItem();
		if (item == null)
		{
			return;
		}
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);
		if ((Object)(object)forItemDef == (Object)null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridCellIndex);
		if (weaponAtIndex != null)
		{
			int mountSlotIndex = gridCellIndex;
			if (CustomRackType != 0)
			{
				gridCellIndex = 0;
			}
			int bestPlacementCellIndex = GetBestPlacementCellIndex(GetXYForIndex(gridCellIndex), forItemDef, rotation, weaponAtIndex);
			if (bestPlacementCellIndex != -1 && Interface.CallHook("OnRackedWeaponSwap", (object)item, (object)weaponAtIndex, (object)player, (object)this) == null)
			{
				item.RemoveFromContainer();
				GivePlayerWeapon(player, mountSlotIndex, takeFromBeltIndex, tryHold: false);
				MountWeapon(item, player, bestPlacementCellIndex, rotation, sendUpdate: false);
				ItemManager.DoRemoves();
				SendNetworkUpdateImmediate();
				Interface.CallHook("OnRackedWeaponSwapped", (object)item, (object)weaponAtIndex, (object)player, (object)this);
			}
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	[RPC_Server.MaxDistance(2f)]
	private void ReqTakeWeapon(RPCMessage msg)
	{
		int num = msg.read.Int32();
		if (num != -1)
		{
			GivePlayerWeapon(msg.player, num);
		}
	}

	private void GivePlayerWeapon(BasePlayer player, int mountSlotIndex, int playerBeltIndex = -1, bool tryHold = true, bool sendUpdate = true)
	{
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);
		if (weaponAtIndex == null)
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null || Interface.CallHook("OnRackedWeaponTake", (object)slot, (object)player, (object)this) != null)
		{
			return;
		}
		ClearSlot(weaponAtIndex);
		bool flag = false;
		bool flag2 = true;
		if (slot.IsBackpack())
		{
			flag2 = false;
			if ((Object)(object)((Component)slot.info).GetComponent<ItemModBackpack>() != (Object)null && player.inventory.GetAnyBackpack() == null)
			{
				flag = slot.MoveToContainer(player.inventory.containerWear);
			}
		}
		if (!flag)
		{
			flag = slot.MoveToContainer(player.inventory.containerBelt, playerBeltIndex);
		}
		if (flag)
		{
			if (flag2 && ((tryHold && (Object)(object)player.GetHeldEntity() == (Object)null) || playerBeltIndex != -1))
			{
				ClientRPC(RpcTarget.Player("SetActiveBeltSlot", player), slot.position, slot.uid);
			}
			ClientRPC(RpcTarget.Player("PlayGrabSound", player), slot.info.itemid);
		}
		else if (!slot.MoveToContainer(player.inventory.containerMain))
		{
			slot.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
		}
		if (sendUpdate)
		{
			ItemManager.DoRemoves();
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnRackedWeaponTaken", (object)slot, (object)player, (object)this);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(2f)]
	[RPC_Server]
	private void ReqTakeAll(RPCMessage msg)
	{
		int num = msg.read.Int32();
		if (num != -1)
		{
			GivePlayerAllWeapons(msg.player, num);
		}
	}

	private void GivePlayerAllWeapons(BasePlayer player, int mountSlotIndex)
	{
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);
		if (weaponAtIndex != null)
		{
			GivePlayerWeapon(player, weaponAtIndex.GridSlotIndex);
		}
		for (int num = gridSlots.Length - 1; num >= 0; num--)
		{
			WeaponRackSlot weaponRackSlot = gridSlots[num];
			if (weaponRackSlot.Used)
			{
				GivePlayerWeapon(player, weaponRackSlot.GridSlotIndex, -1, tryHold: false);
			}
		}
		ItemManager.DoRemoves();
		SendNetworkUpdateImmediate();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(2f)]
	private void ReqUnloadWeapon(RPCMessage msg)
	{
		int num = msg.read.Int32();
		if (num != -1)
		{
			UnloadWeapon(msg.player, num);
		}
	}

	private void UnloadWeapon(BasePlayer player, int mountSlotIndex)
	{
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);
		if (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null || Interface.CallHook("OnRackedWeaponUnload", (object)slot, (object)player, (object)this) != null)
		{
			return;
		}
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (!((Object)(object)heldEntity == (Object)null))
		{
			BaseProjectile component = ((Component)heldEntity).GetComponent<BaseProjectile>();
			if (!((Object)(object)component == (Object)null))
			{
				ItemDefinition ammoType = component.primaryMagazine.ammoType;
				component.UnloadAmmo(slot, player);
				SetSlotAmmoDetails(weaponAtIndex, slot);
				SendNetworkUpdateImmediate();
				ClientRPC(RpcTarget.Player("PlayAmmoSound", player), ammoType.itemid, 1);
				Interface.CallHook("OnRackedWeaponUnloaded", (object)slot, (object)player, (object)this);
			}
		}
	}

	[RPC_Server.MaxDistance(2f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void ReqMountWeapon(RPCMessage msg)
	{
		if (base.inventory.itemList.Count != base.inventory.capacity)
		{
			int num = msg.read.Int32();
			if (num != -1)
			{
				int rotation = msg.read.Int32();
				MountWeapon(msg.player, num, rotation);
			}
		}
	}

	private void MountWeapon(BasePlayer player, int gridCellIndex, int rotation)
	{
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		HeldEntity heldEntity = player.GetHeldEntity();
		if (!((Object)(object)heldEntity == (Object)null))
		{
			Item item = heldEntity.GetItem();
			if (item != null)
			{
				MountWeapon(item, player, gridCellIndex, rotation);
			}
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	[RPC_Server.MaxDistance(2f)]
	private void ReqMountBackSlot(RPCMessage msg)
	{
		if (base.inventory.itemList.Count != base.inventory.capacity)
		{
			int num = msg.read.Int32();
			if (num != -1)
			{
				int rotation = msg.read.Int32();
				MountBackSlot(msg.player, num, rotation);
			}
		}
	}

	private void MountBackSlot(BasePlayer player, int gridCellIndex, int rotation)
	{
		if (!((Object)(object)player == (Object)null))
		{
			Item anyBackpack = player.inventory.GetAnyBackpack();
			if (anyBackpack != null && (!((Object)(object)((Component)anyBackpack.info).GetComponent<ItemModBackpack>() != (Object)null) || anyBackpack.contents == null || anyBackpack.contents.itemList == null || anyBackpack.contents.itemList.Count <= 0))
			{
				MountWeapon(anyBackpack, player, gridCellIndex, rotation);
			}
		}
	}

	private void SetSlotItem(WeaponRackSlot slot, Item item, int gridCellIndex, int rotation)
	{
		slot.SetItem(item, base.inventory.GetSlot(item.position)?.info, gridCellIndex, rotation);
	}

	private void SetSlotAmmoDetails(WeaponRackSlot slot, Item item)
	{
		slot?.SetAmmoDetails(item);
	}

	private bool MountWeapon(Item item, BasePlayer player, int gridCellIndex, int rotation, bool sendUpdate = true)
	{
		if (item == null)
		{
			return false;
		}
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnRackedWeaponMount", (object)item, (object)player, (object)this);
		if (obj != null)
		{
			if (!(obj is bool))
			{
				return false;
			}
			return (bool)obj;
		}
		int itemid = item.info.itemid;
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);
		if ((Object)(object)forItemDef == (Object)null)
		{
			Debug.LogWarning((object)"no rackmount config");
			return false;
		}
		if (!CanAcceptWeaponType(forItemDef))
		{
			return false;
		}
		if (!GridCellsFree(forItemDef, gridCellIndex, rotation, null))
		{
			return false;
		}
		if (item.MoveToContainer(base.inventory, -1, allowStack: false) && item.position >= 0 && item.position < gridSlots.Length)
		{
			WeaponRackSlot slot = gridSlots[item.position];
			SetSlotItem(slot, item, gridCellIndex, rotation);
			SetupSlot(slot);
			if ((Object)(object)player != (Object)null)
			{
				ClientRPC(RpcTarget.Player("PlayMountSound", player), itemid);
			}
		}
		if (sendUpdate)
		{
			ItemManager.DoRemoves();
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnRackedWeaponMounted", (object)item, (object)player, (object)this);
		return true;
	}

	private void PlayMountSound(int itemID)
	{
		ClientRPC(RpcTarget.NetworkGroup("PlayMountSound"), itemID);
	}

	[RPC_Server]
	private void LoadWeaponAmmo(RPCMessage msg)
	{
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (!Object.op_Implicit((Object)(object)player))
		{
			return;
		}
		int gridIndex = msg.read.Int32();
		int num = msg.read.Int32();
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridIndex);
		if (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null)
		{
			return;
		}
		BaseEntity heldEntity = slot.GetHeldEntity();
		if ((Object)(object)heldEntity == (Object)null)
		{
			return;
		}
		BaseProjectile component = ((Component)heldEntity).GetComponent<BaseProjectile>();
		if ((Object)(object)component == (Object)null)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		if ((Object)(object)itemDefinition == (Object)null || Interface.CallHook("OnRackedWeaponLoad", (object)slot, (object)itemDefinition, (object)player, (object)this) != null)
		{
			return;
		}
		if ((Object)(object)itemDefinition == (Object)(object)SnowballGun.SnowballInventoryItem)
		{
			itemDefinition = SnowballGun.SnowballAmmoItem;
			if (!((Object)(object)itemDefinition != (Object)null))
			{
				return;
			}
			num = itemDefinition.itemid;
		}
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return;
		}
		ItemModProjectile component2 = ((Component)itemDefinition).GetComponent<ItemModProjectile>();
		if (!((Object)(object)component2 == (Object)null) && component2.IsAmmo(component.primaryMagazine.definition.ammoTypes))
		{
			if (num != component.primaryMagazine.ammoType.itemid && component.primaryMagazine.contents > 0)
			{
				player.GiveItem(ItemManager.CreateByItemID(component.primaryMagazine.ammoType.itemid, component.primaryMagazine.contents, 0uL));
				component.SetAmmoCount(0);
			}
			component.primaryMagazine.ammoType = itemDefinition;
			component.TryReloadMagazine(player.inventory);
			SetSlotAmmoDetails(weaponAtIndex, slot);
			SendNetworkUpdateImmediate();
			ClientRPC(RpcTarget.Player("PlayAmmoSound", player), itemDefinition.itemid, 0);
			Interface.CallHook("OnRackedWeaponLoaded", (object)slot, (object)itemDefinition, (object)player, (object)this);
		}
	}
}


using System;

[Serializable]
public enum RackType
{
	Board,
	Stand
}


public enum SpecialRackType
{
	None,
	WesternDLC
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class WheelSwitch : IOEntity
{
	public Transform wheelObj;

	public float rotateSpeed = 90f;

	public Flags BeingRotated = Flags.Reserved1;

	public Flags RotatingLeft = Flags.Reserved2;

	public Flags RotatingRight = Flags.Reserved3;

	public float rotateProgress;

	public Animator animator;

	public float kineticEnergyPerSec = 1f;

	private BasePlayer rotatorPlayer;

	private float progressTickRate = 0.1f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WheelSwitch.OnRpcMessage", 0);
		try
		{
			if (rpc == 2223603322u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - BeginRotate "));
				}
				TimeWarning val2 = TimeWarning.New("BeginRotate", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2223603322u, "BeginRotate", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							BeginRotate(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in BeginRotate");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 434251040 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - CancelRotate "));
				}
				TimeWarning val2 = TimeWarning.New("CancelRotate", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(434251040u, "CancelRotate", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							CancelRotate(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in CancelRotate");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetIOState()
	{
		CancelPlayerRotation();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void BeginRotate(RPCMessage msg)
	{
		if (!IsBeingRotated())
		{
			SetFlag(BeingRotated, b: true);
			rotatorPlayer = msg.player;
			((FacepunchBehaviour)this).InvokeRepeating((Action)RotateProgress, 0f, progressTickRate);
		}
	}

	public void CancelPlayerRotation()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)RotateProgress);
		SetFlag(BeingRotated, b: false);
		IOSlot[] array = outputs;
		foreach (IOSlot iOSlot in array)
		{
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				iOSlot.connectedTo.Get().IOInput(this, ioType, 0f, iOSlot.connectedToSlot);
			}
		}
		rotatorPlayer = null;
	}

	public void RotateProgress()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)rotatorPlayer) || rotatorPlayer.IsDead() || rotatorPlayer.IsSleeping() || Vector3Ex.Distance2D(((Component)rotatorPlayer).transform.position, ((Component)this).transform.position) > 2f)
		{
			CancelPlayerRotation();
			return;
		}
		float num = kineticEnergyPerSec * progressTickRate;
		IOSlot[] array = outputs;
		foreach (IOSlot iOSlot in array)
		{
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				num = iOSlot.connectedTo.Get().IOInput(this, ioType, num, iOSlot.connectedToSlot);
			}
		}
		if (num == 0f)
		{
			SetRotateProgress(rotateProgress + 0.1f);
		}
		SendNetworkUpdate();
	}

	public void SetRotateProgress(float newValue)
	{
		float num = rotateProgress;
		rotateProgress = newValue;
		SetFlag(Flags.Reserved4, num != newValue);
		SendNetworkUpdate();
		((FacepunchBehaviour)this).CancelInvoke((Action)StoppedRotatingCheck);
		((FacepunchBehaviour)this).Invoke((Action)StoppedRotatingCheck, 0.25f);
	}

	public void StoppedRotatingCheck()
	{
		SetFlag(Flags.Reserved4, b: false);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void CancelRotate(RPCMessage msg)
	{
		CancelPlayerRotation();
	}

	public void Powered()
	{
		float inputAmount = kineticEnergyPerSec * progressTickRate;
		IOSlot[] array = outputs;
		foreach (IOSlot iOSlot in array)
		{
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				inputAmount = iOSlot.connectedTo.Get().IOInput(this, ioType, inputAmount, iOSlot.connectedToSlot);
			}
		}
		SetRotateProgress(rotateProgress + 0.1f);
	}

	public override float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot = 0)
	{
		if (inputAmount < 0f)
		{
			SetRotateProgress(rotateProgress + inputAmount);
			SendNetworkUpdate();
		}
		if (inputType == IOType.Electric && slot == 1)
		{
			if (inputAmount == 0f)
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)Powered);
			}
			else
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)Powered, 0f, progressTickRate);
			}
		}
		return Mathf.Clamp(inputAmount - 1f, 0f, inputAmount);
	}

	public bool IsBeingRotated()
	{
		return HasFlag(BeingRotated);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.sphereEntity != null)
		{
			rotateProgress = info.msg.sphereEntity.radius;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.sphereEntity = Pool.Get<SphereEntity>();
		info.msg.sphereEntity.radius = rotateProgress;
	}
}


using System;
using System.Linq;
using ConVar;
using Network;
using Rust;
using UnityEngine;

public class WildlifeHazard : BaseCombatEntity, IReceivePlayerTickListener
{
	public const Flags Flag_IsCorpse = Flags.Reserved8;

	[ServerVar]
	public static float ClientTickRate = 0.1f;

	[ServerVar]
	public static float ReactionTimeMultiplier = 1f;

	[ServerVar]
	public static float ChanceToRepositionMultiplier = 1f;

	[ServerVar]
	public static float RepositionRadiusMultiplier = 1f;

	[ServerVar]
	public static float RepositionTimerMultiplier = 1f;

	[ServerVar]
	public static int RepositionAttempts = 5;

	[Header("Wildlife Hazard")]
	public BUTTON ReactionSaveButton;

	public float SavingReactionTime = 2f;

	public float Damage = 20f;

	public float HazardInterval = 10f;

	public DamageType DamageType = DamageType.Bite;

	public float ChanceToReposition = 0.5f;

	public float RepositionDelay = 1.25f;

	public float RepositionTimer = 2f;

	public float RepositionRadiusMin = 2f;

	public float RepositionRadiusMax = 4f;

	public Transform ClientArtRoot;

	public TriggerQTE QTETrigger;

	public TriggerBase ClientTrigger;

	public float LookSpeed = 10f;

	public float MinTurnDegrees = 45f;

	public float MinFastTurnDistance = 2f;

	public float MaxWaterDepth = 0.1f;

	public float SlitherDuration = 1f;

	public float SlitherSpeed = 2f;

	public GameObjectRef CorpsePrefab;

	public GameObjectRef BitFX;

	[Header("Wildlife Hazad Visuals")]
	public Animator Animator;

	public GameObjectRef PrefabRepositionEffect;

	public GameObjectRef PrefabReappearEffect;

	[Header("Wildlife Hazard Audio")]
	public SoundDefinition HazardTriggeredSound;

	public bool PlayAlertSounds = true;

	public SoundDefinition AlertIntervalSound;

	public SoundDefinition AttackSound;

	public float AlertSoundMinInterval = 3f;

	public float AlertSoundMaxInterval = 5f;

	public SoundDefinition RepositionDisappearSound;

	public SoundDefinition RepositionReappearSound;

	[Header("Wildlife Hazard Corpse")]
	public ResourceDispenser DeadResourceDispenser;

	public ProtectionProperties DeadProtectionProperties;

	[Tooltip("If enabled, only triggers for one player at a time")]
	public bool SingularInteraction = true;

	public float AttackRange = 1.5f;

	public float AlertToIdleCooldown = 5f;

	protected const int placementMask = 8388608;

	protected const int blockMask = 1075904769;

	protected Vector3 repositionLookAtPos;

	protected Vector3 repositionTo;

	protected int failedRepositionAttempts;

	public override bool IsNpc => true;

	public bool IsCorpse => HasFlag(Flags.Reserved8);

	public BasePlayer SingularInteractionPlayer { get; private set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WildlifeHazard.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		SetFlag(Flags.Reserved8, b: false);
		((Behaviour)DeadResourceDispenser).enabled = false;
		failedRepositionAttempts = 0;
	}

	public virtual void TriggeredByPlayer(BasePlayer player)
	{
		if (ShouldStartHazard(player))
		{
			StartHazard(player);
		}
	}

	protected virtual bool ShouldStartHazard(BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (IsCorpse)
		{
			return false;
		}
		if (!IsAlive())
		{
			return false;
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)StartReposition))
		{
			return false;
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)ReAttackCheck))
		{
			return false;
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)FailHazardDelayed))
		{
			return false;
		}
		if (SingularInteraction && (Object)(object)SingularInteractionPlayer != (Object)null)
		{
			return false;
		}
		if (!CanSeeTarget(((Component)player).transform))
		{
			return false;
		}
		return true;
	}

	private void StartHazard(BasePlayer player)
	{
		OnHazardStarted(player);
	}

	protected virtual void OnHazardStarted(BasePlayer player)
	{
		player.AddReceiveTickListener(this);
		if (SingularInteraction)
		{
			SingularInteractionPlayer = player;
		}
		((FacepunchBehaviour)this).CancelInvoke((Action)ReAttackCheck);
		((FacepunchBehaviour)this).CancelInvoke((Action)FailHazardDelayed);
		float reactionTime = GetReactionTime(player);
		((FacepunchBehaviour)this).Invoke((Action)FailHazardDelayed, reactionTime);
		ClientRPC(RpcTarget.Player("Client_StartHazard", player), reactionTime);
	}

	protected void FailHazardDelayed()
	{
		EndHazard(SingularInteractionPlayer, success: false);
	}

	protected void EndHazard(BasePlayer player, bool success)
	{
		if (success)
		{
			OnHazardCompleted(player);
		}
		else
		{
			OnHazardFailed(player);
		}
		OnHazardEnded(player);
	}

	protected virtual void OnHazardCompleted(BasePlayer player)
	{
	}

	protected virtual void OnHazardFailed(BasePlayer player)
	{
	}

	protected virtual void OnHazardEnded(BasePlayer player)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		ClientRPC(RpcTarget.Player("Client_EndHazard", player));
		((FacepunchBehaviour)this).CancelInvoke((Action)FailHazardDelayed);
		((FacepunchBehaviour)this).CancelInvoke((Action)ReAttackCheck);
		if ((Object)(object)player != (Object)null)
		{
			player.RemoveReceiveTickListener(this);
		}
		SingularInteractionPlayer = null;
		if (ShouldReposition())
		{
			if (FindSuitableReposition(out var pos))
			{
				failedRepositionAttempts = 0;
				repositionTo = pos;
				repositionLookAtPos = (((Object)(object)player != (Object)null) ? ((Component)player).transform.position : (((Component)this).transform.position + Vector3.forward));
				((FacepunchBehaviour)this).Invoke((Action)StartReposition, RepositionDelay);
			}
			else
			{
				failedRepositionAttempts++;
				if (failedRepositionAttempts <= 3)
				{
					((FacepunchBehaviour)this).Invoke((Action)ReAttackCheck, HazardInterval);
				}
				else
				{
					Kill();
				}
			}
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)ReAttackCheck, HazardInterval);
		}
	}

	private bool ShouldReposition()
	{
		if (IsCorpse)
		{
			return false;
		}
		float num = ChanceToReposition * ChanceToRepositionMultiplier;
		if (num <= 0f)
		{
			return false;
		}
		if (Random.Range(0f, 1f) > num)
		{
			return false;
		}
		return true;
	}

	public virtual void StartReposition()
	{
	}

	private bool FindSuitableReposition(out Vector3 pos)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		bool flag = true;
		int num = 0;
		Vector3 val = default(Vector3);
		while (flag)
		{
			float num2 = Random.Range(RepositionRadiusMin, RepositionRadiusMax) * RepositionRadiusMultiplier;
			float num3 = Random.value * (MathF.PI * 2f);
			((Vector3)(ref val))..ctor(Mathf.Cos(num3), 0f, Mathf.Sin(num3));
			pos = ((Component)this).transform.position + val * num2;
			bool flag2 = ValidatePosition(ref pos);
			if (flag2)
			{
				return true;
			}
			flag = !flag2 && ++num < RepositionAttempts;
		}
		pos = ((Component)this).transform.position;
		return false;
	}

	private bool ValidatePosition(ref Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(pos + Vector3.up * 3f, Vector3.down, ref val, 6f, 8388608))
		{
			if (WaterLevel.GetOverallWaterDepth(((RaycastHit)(ref val)).point, waves: true, volumes: false) > MaxWaterDepth)
			{
				return false;
			}
			if (!GamePhysics.LineOfSight(((RaycastHit)(ref val)).point, ((RaycastHit)(ref val)).point + Vector3.up * 4f, 1075904769))
			{
				return false;
			}
			if (!GamePhysics.LineOfSight(((Component)this).transform.position + Vector3.up * 0.25f, ((RaycastHit)(ref val)).point + Vector3.up * 0.25f, 1075904769))
			{
				return false;
			}
			pos = ((RaycastHit)(ref val)).point;
			return true;
		}
		return false;
	}

	private void ReAttackCheck()
	{
		if (IsCorpse || QTETrigger.contents == null || QTETrigger.contents.Count == 0)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)ReAttackCheck);
			return;
		}
		GameObject val = QTETrigger.contents.Single();
		if (!((Object)(object)val == (Object)null))
		{
			BaseEntity baseEntity = val.ToBaseEntity();
			if (!((Object)(object)baseEntity == (Object)null))
			{
				TriggeredByPlayer(baseEntity as BasePlayer);
			}
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		if (base.isServer)
		{
			if (IsCorpse)
			{
				OnCorpseAttacked(info);
			}
			else
			{
				OnAliveAttacked(info);
			}
		}
	}

	private void OnCorpseAttacked(HitInfo info)
	{
		ResetCorpseRemovalTime();
		if (!(info.Weapon is BaseMelee baseMelee) || baseMelee.GetGatherInfoFromIndex(ResourceDispenser.GatherType.Flesh).gatherDamage != 0f)
		{
			DeadResourceDispenser.DoGather(info);
			if (!info.DidGather)
			{
				base.OnAttacked(info);
			}
		}
	}

	private void OnAliveAttacked(HitInfo info)
	{
		base.OnAttacked(info);
	}

	public override void OnKilled()
	{
		base.OnKilled();
		if ((Object)(object)SingularInteractionPlayer != (Object)null)
		{
			SingularInteractionPlayer.RemoveReceiveTickListener(this);
		}
		CancelHazardInvokes();
	}

	public override void OnDied(HitInfo info)
	{
		if (base.isServer)
		{
			ClientRPC(RpcTarget.NetworkGroup("CL_Died"));
			((FacepunchBehaviour)this).CancelInvoke((Action)ReAttackCheck);
			((FacepunchBehaviour)this).CancelInvoke((Action)FailHazardDelayed);
			if ((Object)(object)SingularInteractionPlayer != (Object)null)
			{
				SingularInteractionPlayer.RemoveReceiveTickListener(this);
			}
			if (IsCorpse)
			{
				Kill();
			}
			else
			{
				TurnIntoCorpse();
			}
		}
	}

	public void TurnIntoCorpse()
	{
		SetFlag(Flags.Reserved8, b: true);
		SetHealth(MaxHealth());
		lifestate = LifeState.Alive;
		((Behaviour)DeadResourceDispenser).enabled = true;
		baseProtection = DeadProtectionProperties;
		sendsHitNotification = false;
		ResetCorpseRemovalTime();
	}

	private void CancelHazardInvokes()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)FailHazardDelayed);
		((FacepunchBehaviour)this).CancelInvoke((Action)StartReposition);
		((FacepunchBehaviour)this).CancelInvoke((Action)ReAttackCheck);
	}

	public void ResetCorpseRemovalTime()
	{
		ResetCorpseRemovalTime(ConVar.Server.corpsedespawn);
	}

	public void ResetCorpseRemovalTime(float dur)
	{
		TimeWarning val = TimeWarning.New("ResetRemovalTime", 0);
		try
		{
			if (((FacepunchBehaviour)this).IsInvoking((Action)RemoveCorpse))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)RemoveCorpse);
			}
			((FacepunchBehaviour)this).Invoke((Action)RemoveCorpse, dur);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void RemoveCorpse()
	{
		Kill();
	}

	bool IReceivePlayerTickListener.ShouldRemoveOnPlayerDeath()
	{
		return true;
	}

	void IReceivePlayerTickListener.OnReceivePlayerTick(BasePlayer player, PlayerTick msg)
	{
		if (!((Object)(object)player == (Object)null) && !((Object)(object)player != (Object)(object)SingularInteractionPlayer) && player.serverInput.WasJustPressed(ReactionSaveButton))
		{
			EndHazard(player, success: true);
		}
	}

	public virtual float GetReactionTime(BasePlayer player)
	{
		float num = (((Object)(object)player == (Object)null || player.net == null || player.net.connection == null) ? 0f : ((float)Net.sv.GetAveragePing(player.net.connection) / 1000f));
		return SavingReactionTime * ReactionTimeMultiplier + num;
	}

	public override void Hurt(HitInfo info)
	{
		base.Hurt(info);
		if (base.isServer)
		{
			ClientRPC(RpcTarget.NetworkGroup("CL_Hurt"));
		}
	}

	protected bool CanSeeTarget(Transform targetTransform)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)targetTransform == (Object)null)
		{
			return false;
		}
		if (!GamePhysics.LineOfSight(((Component)this).transform.position + Vector3.up * 0.25f, targetTransform.position + Vector3.up * 0.25f, 1075904769))
		{
			return false;
		}
		return true;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class WireTool : HeldEntity
{
	public enum WireColour
	{
		Gray,
		Red,
		Green,
		Blue,
		Yellow,
		Pink,
		Purple,
		Orange,
		White,
		LightBlue,
		Invisible,
		Count
	}

	public struct PendingPlug
	{
		public IOEntity ent;

		public bool isInput;

		public int index;
	}

	private const int maxLineNodes = 16;

	private const float industrialWallOffset = 0.04f;

	public IOEntity.IOType wireType;

	public WireColour DefaultColor;

	public float radialMenuHoldTime = 0.25f;

	public float disconnectDelay = 0.15f;

	public float clearDelay = 0.65f;

	private bool justCleared;

	public GameObjectRef plugEffect;

	public SoundDefinition clearStartSoundDef;

	public SoundDefinition clearSoundDef;

	public PendingPlug pendingPlug;

	private const float IndustrialThickness = 0.01f;

	private bool CanChangeColours
	{
		get
		{
			IOEntity.IOType iOType = wireType;
			return iOType == IOEntity.IOType.Electric || iOType == IOEntity.IOType.Fluidic || iOType == IOEntity.IOType.Industrial;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WireTool.OnRpcMessage", 0);
		try
		{
			if (rpc == 2571821359u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_MakeConnection "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_MakeConnection", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2571821359u, "RPC_MakeConnection", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(2571821359u, "RPC_MakeConnection", this, player, includeMounted: false))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(2571821359u, "RPC_MakeConnection", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_MakeConnection(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_MakeConnection");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 986119119 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RequestChangeColor "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RequestChangeColor", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(986119119u, "RPC_RequestChangeColor", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(986119119u, "RPC_RequestChangeColor", this, player, includeMounted: false))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(986119119u, "RPC_RequestChangeColor", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_RequestChangeColor(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_RequestChangeColor");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1514179840 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RequestClear "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RequestClear", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1514179840u, "RPC_RequestClear", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(1514179840u, "RPC_RequestClear", this, player, includeMounted: false))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(1514179840u, "RPC_RequestClear", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_RequestClear(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_RequestClear");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public float GetMaxWireLength(BasePlayer forPlayer)
	{
		if ((Object)(object)forPlayer == (Object)null || !forPlayer.IsInCreativeMode || !Creative.unlimitedIo)
		{
			return 30f;
		}
		return 200f;
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void RPC_MakeConnection(RPCMessage rpc)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = rpc.player;
		if (!CanPlayerUseWires(player))
		{
			return;
		}
		WireConnectionMessage val = rpc.read.Proto<WireConnectionMessage>((WireConnectionMessage)null);
		List<Vector3> linePoints = val.linePoints;
		int inputIndex = val.inputIndex;
		int outputIndex = val.outputIndex;
		IOEntity iOEntity = new EntityRef<IOEntity>(val.inputID).Get(serverside: true);
		IOEntity iOEntity2 = new EntityRef<IOEntity>(val.outputID).Get(serverside: true);
		if ((Object)(object)iOEntity == (Object)null || (Object)(object)iOEntity2 == (Object)null || !ValidateLine(linePoints, iOEntity, iOEntity2, player, outputIndex) || inputIndex >= iOEntity.inputs.Length || outputIndex >= iOEntity2.outputs.Length || (Object)(object)iOEntity.inputs[inputIndex].connectedTo.Get() != (Object)null || (Object)(object)iOEntity2.outputs[outputIndex].connectedTo.Get() != (Object)null || (iOEntity.inputs[inputIndex].rootConnectionsOnly && !iOEntity2.IsRootEntity()) || !CanModifyEntity(player, iOEntity) || !CanModifyEntity(player, iOEntity2))
		{
			return;
		}
		List<float> slackLevels = val.slackLevels;
		IOEntity.LineAnchor[] array = new IOEntity.LineAnchor[val.lineAnchors.Count];
		for (int i = 0; i < val.lineAnchors.Count; i++)
		{
			WireLineAnchorInfo val2 = val.lineAnchors[i];
			array[i].entityRef = new EntityRef<Door>(val2.parentID);
			array[i].boneName = val2.boneName;
			array[i].index = (int)val2.index;
			array[i].position = val2.position;
		}
		WireColour wireColour = IntToColour(val.wireColor);
		if (Interface.CallHook("OnWireConnect", (object)player, (object)iOEntity, (object)inputIndex, (object)iOEntity2, (object)outputIndex, (object)val.linePoints, (object)slackLevels) == null)
		{
			if (wireColour == WireColour.Invisible && !player.IsInCreativeMode)
			{
				wireColour = DefaultColor;
			}
			iOEntity2.ConnectTo(iOEntity, outputIndex, inputIndex, linePoints, slackLevels, array, wireColour);
			if (wireType == IOEntity.IOType.Industrial)
			{
				iOEntity.NotifyIndustrialNetworkChanged();
				iOEntity2.NotifyIndustrialNetworkChanged();
			}
		}
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	[RPC_Server.IsActiveItem]
	public void RPC_RequestClear(RPCMessage msg)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0401: Unknown result type (might be due to invalid IL or missing references)
		//IL_0405: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_040c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0411: Unknown result type (might be due to invalid IL or missing references)
		//IL_041c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (!CanPlayerUseWires(player))
		{
			return;
		}
		NetworkableId uid = msg.read.EntityID();
		int num = msg.read.Int32();
		bool flag = msg.read.Bit();
		bool flag2 = msg.read.Bit();
		IOEntity iOEntity = BaseNetworkable.serverEntities.Find(uid) as IOEntity;
		if ((Object)(object)iOEntity == (Object)null)
		{
			return;
		}
		WireReconnectMessage val = Pool.Get<WireReconnectMessage>();
		if (flag2)
		{
			IOEntity.IOSlot iOSlot = (flag ? iOEntity.inputs : iOEntity.outputs)[num];
			IOEntity iOEntity2 = iOSlot.connectedTo.Get();
			if ((Object)(object)iOEntity2 == (Object)null)
			{
				return;
			}
			IOEntity.IOSlot iOSlot2 = (flag ? iOEntity2.outputs : iOEntity2.inputs)[iOSlot.connectedToSlot];
			val.isInput = !flag;
			val.slotIndex = iOSlot.connectedToSlot;
			val.entityId = iOSlot.connectedTo.Get().net.ID;
			val.wireColor = (int)iOSlot.wireColour;
			val.linePoints = Pool.Get<List<Vector3>>();
			val.slackLevels = Pool.Get<List<float>>();
			val.lineAnchors = Pool.Get<List<WireLineAnchorInfo>>();
			IOEntity iOEntity3 = iOEntity;
			Vector3[] array = iOSlot.linePoints;
			IOEntity.IOSlot iOSlot3 = iOSlot;
			if (array == null || array.Length == 0)
			{
				iOEntity3 = iOEntity2;
				array = iOSlot2.linePoints;
				iOSlot3 = iOSlot2;
			}
			if (array == null)
			{
				array = Array.Empty<Vector3>();
			}
			bool flag3 = (Object)(object)iOEntity3 != (Object)(object)iOEntity;
			if ((Object)(object)iOEntity == (Object)(object)iOEntity3 && flag)
			{
				flag3 = true;
			}
			val.linePoints.AddRange(array);
			float[] slackLevels = iOSlot.slackLevels;
			if (slackLevels == null || slackLevels.Length == 0)
			{
				slackLevels = iOSlot2.slackLevels;
			}
			float[] array2 = slackLevels;
			foreach (float item in array2)
			{
				val.slackLevels.Add(item);
			}
			IOEntity.LineAnchor[] lineAnchors = iOSlot.lineAnchors;
			if (lineAnchors == null || lineAnchors.Length == 0)
			{
				lineAnchors = iOSlot2.lineAnchors;
			}
			if (lineAnchors != null)
			{
				IOEntity.LineAnchor[] array3 = lineAnchors;
				for (int i = 0; i < array3.Length; i++)
				{
					IOEntity.LineAnchor lineAnchor = array3[i];
					EntityRef<Door> entityRef = lineAnchor.entityRef;
					if (entityRef.Get(serverside: true).IsValid())
					{
						val.lineAnchors.Add(lineAnchor.ToInfo());
					}
				}
			}
			val.slackLevels.RemoveAt(val.slackLevels.Count - 1);
			if (flag3)
			{
				val.linePoints.Reverse();
				val.slackLevels.Reverse();
				int num2 = val.linePoints.Count - 1;
				foreach (WireLineAnchorInfo lineAnchor2 in val.lineAnchors)
				{
					lineAnchor2.index = num2 - lineAnchor2.index;
				}
			}
			if (val.lineAnchors.Count >= 0)
			{
				List<WireLineAnchorInfo> list = Pool.Get<List<WireLineAnchorInfo>>();
				foreach (WireLineAnchorInfo lineAnchor3 in val.lineAnchors)
				{
					if (lineAnchor3.index == 0L || lineAnchor3.index == val.linePoints.Count - 1)
					{
						list.Add(lineAnchor3);
					}
				}
				foreach (WireLineAnchorInfo item2 in list)
				{
					val.lineAnchors.Remove(item2);
				}
				Pool.Free<WireLineAnchorInfo>(ref list, false);
			}
			if (val.linePoints.Count >= 0)
			{
				val.linePoints.RemoveAt(0);
				val.linePoints.RemoveAt(val.linePoints.Count - 1);
			}
			if (val.slackLevels.Count >= 0)
			{
				val.slackLevels.RemoveAt(val.slackLevels.Count - 1);
			}
			for (int j = 0; j < val.linePoints.Count; j++)
			{
				Vector3 val2 = Quaternion.Euler(iOSlot3.originRotation) * val.linePoints[j];
				Vector3 value = iOSlot3.originPosition + val2;
				val.linePoints[j] = value;
			}
		}
		if (AttemptClearSlot(iOEntity, player, num, flag) && flag2)
		{
			ClientRPC(RpcTarget.Player("RPC_OnWireDisconnected", player), val);
		}
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.FromOwner(false)]
	public void RPC_RequestChangeColor(RPCMessage msg)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if (!CanPlayerUseWires(msg.player))
		{
			return;
		}
		NetworkableId uid = msg.read.EntityID();
		IOEntity iOEntity = BaseNetworkable.serverEntities.Find(uid) as IOEntity;
		if ((Object)(object)iOEntity == (Object)null)
		{
			return;
		}
		int index = msg.read.Int32();
		bool flag = msg.read.Bit();
		WireColour wireColour = IntToColour(msg.read.Int32());
		IOEntity.IOSlot iOSlot = (flag ? iOEntity.inputs.ElementAtOrDefault(index) : iOEntity.outputs.ElementAtOrDefault(index));
		if (iOSlot != null)
		{
			IOEntity iOEntity2 = iOSlot.connectedTo.Get();
			if (!((Object)(object)iOEntity2 == (Object)null))
			{
				IOEntity.IOSlot obj = (flag ? iOEntity2.outputs : iOEntity2.inputs)[iOSlot.connectedToSlot];
				iOSlot.wireColour = wireColour;
				iOEntity.SendNetworkUpdate();
				obj.wireColour = wireColour;
				iOEntity2.SendNetworkUpdate();
			}
		}
	}

	public static bool AttemptClearSlot(BaseNetworkable clearEnt, BasePlayer ply, int clearIndex, bool isInput)
	{
		IOEntity iOEntity = (((Object)(object)clearEnt != (Object)null) ? ((Component)clearEnt).GetComponent<IOEntity>() : null);
		IOEntity iOEntity2 = (IOEntity)(object)(isInput ? iOEntity.inputs[clearIndex] : iOEntity.outputs[clearIndex]);
		if ((Object)(object)((IOEntity.IOSlot)(object)iOEntity2).connectedTo.Get() == (Object)null)
		{
			return false;
		}
		iOEntity2 = ((IOEntity.IOSlot)(object)iOEntity2).connectedTo.Get();
		object obj = Interface.CallHook("OnWireClear", (object)ply, (object)iOEntity, (object)clearIndex, (object)iOEntity2, (object)isInput);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((Object)(object)iOEntity == (Object)null)
		{
			return false;
		}
		if ((Object)(object)ply != (Object)null && !CanModifyEntity(ply, iOEntity))
		{
			return false;
		}
		return iOEntity.Disconnect(clearIndex, isInput);
	}

	public WireColour IntToColour(int i)
	{
		i %= 11;
		return (WireColour)i;
	}

	public bool ValidateLine(List<Vector3> lineList, IOEntity inputEntity, IOEntity outputEntity, BasePlayer byPlayer, int outputIndex)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)byPlayer != (Object)null && byPlayer.IsInCreativeMode && Creative.unlimitedIo)
		{
			return true;
		}
		if (lineList.Count < 2 || lineList.Count > 18)
		{
			return false;
		}
		if ((Object)(object)inputEntity == (Object)null || (Object)(object)outputEntity == (Object)null)
		{
			return false;
		}
		Vector3 val = lineList[0];
		float num = 0f;
		int count = lineList.Count;
		float maxWireLength = GetMaxWireLength(byPlayer);
		for (int i = 1; i < count; i++)
		{
			Vector3 val2 = lineList[i];
			num += Vector3.Distance(val, val2);
			if (num > maxWireLength)
			{
				return false;
			}
			val = val2;
		}
		Vector3 val3 = lineList[count - 1];
		Bounds val4 = outputEntity.bounds;
		((Bounds)(ref val4)).Expand(0.5f);
		if (!((Bounds)(ref val4)).Contains(val3))
		{
			return false;
		}
		Vector3 val5 = ((Component)outputEntity).transform.TransformPoint(lineList[0]);
		val3 = ((Component)inputEntity).transform.InverseTransformPoint(val5);
		Bounds val6 = inputEntity.bounds;
		((Bounds)(ref val6)).Expand(0.5f);
		if (!((Bounds)(ref val6)).Contains(val3))
		{
			return false;
		}
		if ((Object)(object)byPlayer == (Object)null)
		{
			return false;
		}
		Vector3 position = ((Component)outputEntity).transform.TransformPoint(lineList[lineList.Count - 1]);
		if (byPlayer.Distance(position) > 5f && byPlayer.Distance(val5) > 5f)
		{
			return false;
		}
		if (outputIndex >= 0 && outputIndex < outputEntity.outputs.Length && outputEntity.outputs[outputIndex].type == IOEntity.IOType.Industrial && !VerifyLineOfSight(lineList, ((Component)outputEntity).transform.localToWorldMatrix))
		{
			return false;
		}
		return true;
	}

	public bool VerifyLineOfSight(List<Vector3> positions, Matrix4x4 localToWorldSpace)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 worldSpaceA = ((Matrix4x4)(ref localToWorldSpace)).MultiplyPoint3x4(positions[0]);
		for (int i = 1; i < positions.Count; i++)
		{
			Vector3 val = ((Matrix4x4)(ref localToWorldSpace)).MultiplyPoint3x4(positions[i]);
			if (!VerifyLineOfSight(worldSpaceA, val))
			{
				return false;
			}
			worldSpaceA = val;
		}
		return true;
	}

	public bool VerifyLineOfSight(Vector3 worldSpaceA, Vector3 worldSpaceB)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		float maxDistance = Vector3.Distance(worldSpaceA, worldSpaceB);
		Vector3 val = worldSpaceA - worldSpaceB;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAll(new Ray(worldSpaceB, normalized), 0.01f, list, maxDistance, 2162944, (QueryTriggerInteraction)0);
		bool result = true;
		foreach (RaycastHit item in list)
		{
			BaseEntity entity = item.GetEntity();
			if ((Object)(object)entity != (Object)null && item.IsOnLayer((Layer)8))
			{
				if (entity is VendingMachine)
				{
					result = false;
					break;
				}
			}
			else if (!((Object)(object)entity != (Object)null) || !(entity is Door))
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		return result;
	}

	public bool HasPendingPlug()
	{
		if ((Object)(object)pendingPlug.ent != (Object)null)
		{
			return pendingPlug.index != -1;
		}
		return false;
	}

	public bool PendingPlugIsInput()
	{
		if ((Object)(object)pendingPlug.ent != (Object)null && pendingPlug.index != -1)
		{
			return pendingPlug.isInput;
		}
		return false;
	}

	public bool PendingPlugIsType(IOEntity.IOType type)
	{
		if ((Object)(object)pendingPlug.ent == (Object)null || pendingPlug.index == -1)
		{
			return false;
		}
		IOEntity.IOSlot[] array = (pendingPlug.isInput ? pendingPlug.ent.inputs : pendingPlug.ent.outputs);
		if (pendingPlug.index < 0 || pendingPlug.index >= array.Length)
		{
			return false;
		}
		return array[pendingPlug.index].type == type;
	}

	public bool PendingPlugIsOutput()
	{
		if ((Object)(object)pendingPlug.ent != (Object)null && pendingPlug.index != -1)
		{
			return !pendingPlug.isInput;
		}
		return false;
	}

	public bool PendingPlugIsRoot()
	{
		if ((Object)(object)pendingPlug.ent != (Object)null)
		{
			return pendingPlug.ent.IsRootEntity();
		}
		return false;
	}

	private void ResetPendingPlug()
	{
		pendingPlug.ent = null;
		pendingPlug.index = -1;
	}

	public static bool CanPlayerUseWires(BasePlayer player, bool cached = false, float cacheDuration = 1f)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("CanUseWires", (object)player, (object)cached, (object)cacheDuration);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((Object)(object)player != (Object)null && player.IsInCreativeMode && Creative.unlimitedIo)
		{
			return true;
		}
		if (!player.CanBuild(cached, cacheDuration))
		{
			return false;
		}
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(player.eyes.position, 0.1f, list, 536870912, (QueryTriggerInteraction)2);
		bool result = true;
		foreach (Collider item in list)
		{
			if (!((Component)item).gameObject.CompareTag("IgnoreWireCheck"))
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	private static bool CanModifyEntity(BasePlayer player, IOEntity ent)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (ent.AllowWireConnections())
		{
			if (!player.CanBuild(((Component)ent).transform.position, ((Component)ent).transform.rotation, ent.bounds))
			{
				if (player.IsInCreativeMode)
				{
					return Creative.unlimitedIo;
				}
				return false;
			}
			return true;
		}
		return false;
	}
}


public enum WireColour
{
	Gray,
	Red,
	Green,
	Blue,
	Yellow,
	Pink,
	Purple,
	Orange,
	White,
	LightBlue,
	Invisible,
	Count
}


public struct PendingPlug
{
	public IOEntity ent;

	public bool isInput;

	public int index;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class Workbench : StorageContainer
{
	public const int blueprintSlot = 0;

	public const int experimentSlot = 1;

	public bool Static;

	public int Workbenchlevel;

	public LootSpawn experimentalItems;

	public GameObjectRef experimentStartEffect;

	public GameObjectRef experimentSuccessEffect;

	public ItemDefinition experimentResource;

	public TechTreeData[] techTrees;

	public static ItemDefinition blueprintBaseDef;

	private ItemDefinition pendingBlueprint;

	private bool creatingBlueprint;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Workbench.OnRpcMessage", 0);
		try
		{
			if (rpc == 2308794761u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_BeginExperiment "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_BeginExperiment", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2308794761u, "RPC_BeginExperiment", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_BeginExperiment(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_BeginExperiment");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4127240744u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_TechTreeUnlock "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_TechTreeUnlock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(4127240744u, "RPC_TechTreeUnlock", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_TechTreeUnlock(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_TechTreeUnlock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public IEnumerable<TechTreeData> GetTechTrees()
	{
		TechTreeData[] array = techTrees;
		foreach (TechTreeData techTreeData in array)
		{
			if (techTreeData.IsAllowedInEra(Server.Era) && techTreeData.IsAllowedInGameMode(base.isServer))
			{
				yield return techTreeData;
			}
		}
	}

	public TechTreeData GetTechTreeForLevel(int level)
	{
		foreach (TechTreeData techTree in GetTechTrees())
		{
			if (techTree.techTreeLevel == level)
			{
				return techTree;
			}
		}
		return null;
	}

	public int GetScrapForExperiment()
	{
		if (Workbenchlevel == 1)
		{
			return 75;
		}
		if (Workbenchlevel == 2)
		{
			return 300;
		}
		if (Workbenchlevel == 3)
		{
			return 1000;
		}
		Debug.LogWarning((object)"GetScrapForExperiment fucked up big time.");
		return 0;
	}

	public bool IsWorking()
	{
		return HasFlag(Flags.On);
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if (children.Count != 0)
		{
			pickupErrorToFormat = (format: PickupErrors.ItemHasAttachment, arg0: pickup.itemTarget.displayName);
			return false;
		}
		return base.CanCompletePickup(player);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_TechTreeUnlock(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int id = msg.read.Int32();
		int level = msg.read.Int32();
		TechTreeData techTreeForLevel = GetTechTreeForLevel(level);
		if ((Object)(object)techTreeForLevel == (Object)null)
		{
			return;
		}
		TechTreeData.NodeInstance byID = techTreeForLevel.GetByID(id);
		if (byID == null)
		{
			Debug.Log((object)("Node for unlock not found :" + id));
		}
		else
		{
			if (!techTreeForLevel.PlayerCanUnlock(player, byID))
			{
				return;
			}
			if (byID.IsGroup())
			{
				foreach (int output in byID.outputs)
				{
					TechTreeData.NodeInstance byID2 = techTreeForLevel.GetByID(output);
					if (byID2 != null && (Object)(object)byID2.itemDef != (Object)null)
					{
						player.blueprints.Unlock(byID2.itemDef);
						Analytics.Azure.OnBlueprintLearned(player, byID2.itemDef, "techtree", 0, this);
					}
				}
				Debug.Log((object)("Player unlocked group :" + byID.groupName));
			}
			else if ((Object)(object)byID.itemDef != (Object)null && Interface.CallHook("OnTechTreeNodeUnlock", (object)this, (object)byID, (object)player) == null)
			{
				int tax;
				int num = ScrapForResearch(byID.itemDef, techTreeForLevel.techTreeLevel, out tax);
				int itemid = ItemManager.FindItemDefinition("scrap").itemid;
				if (player.inventory.GetAmount(itemid) >= num + tax)
				{
					player.inventory.Take(null, itemid, num + tax);
					player.blueprints.Unlock(byID.itemDef);
					Interface.CallHook("OnTechTreeNodeUnlocked", (object)this, (object)byID, (object)player);
					Analytics.Azure.OnBlueprintLearned(player, byID.itemDef, "techtree", num + tax, this);
				}
			}
		}
	}

	public static ItemDefinition GetBlueprintTemplate()
	{
		if ((Object)(object)blueprintBaseDef == (Object)null)
		{
			blueprintBaseDef = ItemManager.FindItemDefinition("blueprintbase");
		}
		return blueprintBaseDef;
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_BeginExperiment(RPCMessage msg)
	{
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null || IsWorking())
		{
			return;
		}
		PersistantPlayer persistantPlayerInfo = player.PersistantPlayerInfo;
		int num = Random.Range(0, experimentalItems.subSpawn.Length);
		for (int i = 0; i < experimentalItems.subSpawn.Length; i++)
		{
			int num2 = i + num;
			if (num2 >= experimentalItems.subSpawn.Length)
			{
				num2 -= experimentalItems.subSpawn.Length;
			}
			ItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;
			if (Object.op_Implicit((Object)(object)itemDef.Blueprint) && !itemDef.Blueprint.defaultBlueprint && itemDef.Blueprint.userCraftable && itemDef.Blueprint.isResearchable && !itemDef.Blueprint.NeedsSteamItem && !itemDef.Blueprint.NeedsSteamDLC && !persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid))
			{
				pendingBlueprint = itemDef;
				break;
			}
		}
		if ((Object)(object)pendingBlueprint == (Object)null)
		{
			player.ChatMessage("You have already unlocked everything for this workbench tier.");
		}
		else
		{
			if (Interface.CallHook("OnExperimentStart", (object)this, (object)player) != null)
			{
				return;
			}
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				if (!slot.MoveToContainer(player.inventory.containerMain))
				{
					slot.Drop(GetDropPosition(), GetDropVelocity());
				}
				player.inventory.loot.SendImmediate();
			}
			if (experimentStartEffect.isValid)
			{
				Effect.server.Run(experimentStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			SetFlag(Flags.On, b: true);
			base.inventory.SetLocked(isLocked: true);
			((FacepunchBehaviour)this).CancelInvoke((Action)ExperimentComplete);
			((FacepunchBehaviour)this).Invoke((Action)ExperimentComplete, 5f);
			SendNetworkUpdate();
			Interface.CallHook("OnExperimentStarted", (object)this, (object)player);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		((FacepunchBehaviour)this).CancelInvoke((Action)ExperimentComplete);
	}

	public int GetAvailableExperimentResources()
	{
		Item experimentResourceItem = GetExperimentResourceItem();
		if (experimentResourceItem == null || (Object)(object)experimentResourceItem.info != (Object)(object)experimentResource)
		{
			return 0;
		}
		return experimentResourceItem.amount;
	}

	public Item GetExperimentResourceItem()
	{
		return base.inventory.GetSlot(1);
	}

	public void ExperimentComplete()
	{
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		Item experimentResourceItem = GetExperimentResourceItem();
		int scrapForExperiment = GetScrapForExperiment();
		if ((Object)(object)pendingBlueprint == (Object)null)
		{
			Debug.LogWarning((object)"Pending blueprint was null!");
		}
		if (Interface.CallHook("OnExperimentEnd", (object)this) != null)
		{
			return;
		}
		if (experimentResourceItem != null && experimentResourceItem.amount >= scrapForExperiment && (Object)(object)pendingBlueprint != (Object)null)
		{
			experimentResourceItem.UseItem(scrapForExperiment);
			Item item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);
			item.blueprintTarget = pendingBlueprint.itemid;
			creatingBlueprint = true;
			if (!item.MoveToContainer(base.inventory, 0))
			{
				item.Drop(GetDropPosition(), GetDropVelocity());
			}
			creatingBlueprint = false;
			if (experimentSuccessEffect.isValid)
			{
				Effect.server.Run(experimentSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
		SetFlag(Flags.On, b: false);
		pendingBlueprint = null;
		base.inventory.SetLocked(isLocked: false);
		SendNetworkUpdate();
		Interface.CallHook("OnExperimentEnded", (object)this);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.On, b: false);
		if (base.inventory != null)
		{
			base.inventory.SetLocked(isLocked: false);
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		base.inventory.canAcceptItem = ItemFilter;
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if ((targetSlot == 1 && (Object)(object)item.info == (Object)(object)experimentResource) || (targetSlot == 0 && creatingBlueprint))
		{
			return true;
		}
		return false;
	}

	public static int ScrapForResearch(ItemDefinition info, int workbenchLevel, out int tax)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Invalid comparison between Unknown and I4
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Invalid comparison between Unknown and I4
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Invalid comparison between Unknown and I4
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Invalid comparison between Unknown and I4
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		if ((int)info.rarity == 1)
		{
			num = 20;
		}
		if ((int)info.rarity == 2)
		{
			num = 75;
		}
		if ((int)info.rarity == 3)
		{
			num = 125;
		}
		if ((int)info.rarity == 4 || (int)info.rarity == 0)
		{
			num = 500;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode != (Object)null)
		{
			BaseGameMode.ResearchCostResult scrapCostForResearch = activeGameMode.GetScrapCostForResearch(info, ResearchTable.ResearchType.TechTree);
			if (scrapCostForResearch.Scale.HasValue)
			{
				num = Mathf.RoundToInt((float)num * scrapCostForResearch.Scale.Value);
			}
			else if (scrapCostForResearch.Amount.HasValue)
			{
				num = scrapCostForResearch.Amount.Value;
			}
		}
		float taxRateForWorkbenchUnlock = Server.GetTaxRateForWorkbenchUnlock(workbenchLevel);
		tax = 0;
		if (taxRateForWorkbenchUnlock > 0f)
		{
			tax = Mathf.CeilToInt((float)num * (taxRateForWorkbenchUnlock / 100f));
		}
		return num;
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}
}


using System;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class WorldItem : BaseEntity, PlayerInventory.ICanMoveFrom
{
	public static readonly Phrase OpenLootTitle = new Phrase("open_loot", "Open");

	public static readonly Phrase PickUpTitle = new Phrase("pick_up", "Pick Up");

	public static readonly Phrase HoldToPickupPhrase = new Phrase("hold_use_to_pickup", "Hold [USE] to pickup");

	[Header("WorldItem")]
	public bool allowPickup = true;

	[NonSerialized]
	public Item item;

	private float pickupStartTime;

	private bool _isInvokingSendItemUpdate;

	protected float eatSeconds = 10f;

	protected float caloriesPerSecond = 1f;

	public override TraitFlag Traits
	{
		get
		{
			if (item != null)
			{
				return item.Traits;
			}
			return base.Traits;
		}
	}

	protected virtual bool CanBePickedUp => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("WorldItem.OnRpcMessage", 0);
		try
		{
			if (rpc == 2778075470u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Pickup "));
				}
				TimeWarning val2 = TimeWarning.New("Pickup", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2778075470u, "Pickup", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Pickup(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Pickup");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2145528377 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - PickupTimer "));
				}
				TimeWarning val2 = TimeWarning.New("PickupTimer", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2145528377u, "PickupTimer", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							PickupTimer(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in PickupTimer");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 331989034 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenLoot "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenLoot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(331989034u, "RPC_OpenLoot", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_OpenLoot(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_OpenLoot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override Item GetItem()
	{
		return item;
	}

	public void InitializeItem(Item in_item)
	{
		if (item != null)
		{
			RemoveItem();
		}
		item = in_item;
		if (item != null)
		{
			item.OnDirty += OnItemDirty;
			((Object)this).name = item.info.shortname + " (world)";
			item.SetWorldEntity(this);
			OnItemDirty(item);
			if (base.isServer)
			{
				SingletonComponent<NpcFoodManager>.Instance.Add(this);
			}
		}
	}

	public void RemoveItem()
	{
		if (item != null)
		{
			if (base.isServer)
			{
				SingletonComponent<NpcFoodManager>.Instance.Remove(this);
			}
			item.OnDirty -= OnItemDirty;
			item = null;
		}
	}

	public void DestroyItem()
	{
		if (item != null)
		{
			if (base.isServer)
			{
				SingletonComponent<NpcFoodManager>.Instance.Remove(this);
			}
			item.OnDirty -= OnItemDirty;
			item.Remove();
			item = null;
		}
	}

	protected virtual void OnItemDirty(Item in_item)
	{
		Assert.IsTrue(item == in_item, "WorldItem:OnItemDirty - dirty item isn't ours!");
		if (item != null)
		{
			((Component)this).BroadcastMessage("OnItemChanged", (object)item, (SendMessageOptions)1);
		}
		DoItemNetworking();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.worldItem != null && info.msg.worldItem.item != null)
		{
			Item item = ItemManager.Load(info.msg.worldItem.item, this.item, base.isServer);
			if (item != null)
			{
				InitializeItem(item);
			}
		}
	}

	public override string ToString()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if (_name == null)
		{
			if (base.isServer)
			{
				_name = string.Format("{1}[{0}] {2}", (object)(NetworkableId)(((??)net?.ID) ?? default(NetworkableId)), base.ShortPrefabName, this.IsUnityNull() ? "NULL" : ((Object)this).name);
			}
			else
			{
				_name = base.ShortPrefabName;
			}
		}
		return _name;
	}

	public bool CanMoveFrom(BasePlayer player, Item item)
	{
		if ((Object)(object)((item != null) ? ((Component)item.info).GetComponent<ItemModBackpack>() : null) == (Object)null)
		{
			return true;
		}
		return item.parentItem?.parent == player.inventory.containerWear;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (item != null)
		{
			((Component)this).BroadcastMessage("OnItemChanged", (object)item, (SendMessageOptions)1);
		}
	}

	private void DoItemNetworking()
	{
		if (!_isInvokingSendItemUpdate)
		{
			_isInvokingSendItemUpdate = true;
			((FacepunchBehaviour)this).Invoke((Action)SendItemUpdate, 0.1f);
		}
	}

	private void SendItemUpdate()
	{
		_isInvokingSendItemUpdate = false;
		if (item == null)
		{
			return;
		}
		UpdateItem val = Pool.Get<UpdateItem>();
		try
		{
			val.item = item.Save(bIncludeContainer: false, bIncludeOwners: false);
			ClientRPC(RpcTarget.NetworkGroup("UpdateItem"), val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void Pickup(RPCMessage msg)
	{
		if (msg.player.CanInteract() && this.item != null && allowPickup && Interface.CallHook("OnItemPickup", (object)this.item, (object)msg.player, (object)this) == null && CanOpenInSafeZone(msg.player))
		{
			ItemModContainer component = ((Component)this.item.info).GetComponent<ItemModContainer>();
			if (!((Object)(object)component != (Object)null) || !component.canLootInWorld || !(component.pickupInWorldDelay > 0f) || !(Mathf.Abs(pickupStartTime + component.pickupInWorldDelay - Time.realtimeSinceStartup) > ConVar.AntiHack.rpc_timer_forgiveness))
			{
				ClientRPC(RpcTarget.NetworkGroup("PickupSound"));
				Item item = this.item;
				Analytics.Azure.OnItemPickup(msg.player, this);
				RemoveItem();
				TryApplyOwnershipOnPickup(msg.player, item);
				msg.player.GiveItem(item, GiveItemReason.PickedUp);
				msg.player.SignalBroadcast(Signal.Gesture, "pickup_item");
			}
		}
	}

	public virtual void TryApplyOwnershipOnPickup(BasePlayer player, Item item)
	{
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void PickupTimer(RPCMessage msg)
	{
		if (msg.player.CanInteract() && item != null && allowPickup && CanOpenInSafeZone(msg.player))
		{
			pickupStartTime = Time.realtimeSinceStartup;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (item != null)
		{
			bool forDisk = info.forDisk;
			info.msg.worldItem = Pool.Get<WorldItem>();
			info.msg.worldItem.item = item.Save(forDisk, bIncludeOwners: false);
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		DestroyItem();
	}

	public override void SwitchParent(BaseEntity ent)
	{
		SetParent(ent, parentBone);
	}

	public override void Eat(BaseNpc baseNpc, float timeSpent)
	{
		if (!(eatSeconds <= 0f))
		{
			eatSeconds -= timeSpent;
			baseNpc.AddCalories(caloriesPerSecond * timeSpent);
			if (eatSeconds < 0f)
			{
				DestroyItem();
				Kill();
			}
		}
	}

	private bool CanOpenInSafeZone(BasePlayer looter)
	{
		if (item == null || !item.info.blockStealingInSafeZone)
		{
			return true;
		}
		if (!(this is DroppedItem droppedItem))
		{
			return true;
		}
		if (looter.InSafeZone() && droppedItem.DroppedBy != (ulong)looter.userID && droppedItem.DroppedBy != 0L)
		{
			return false;
		}
		return true;
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (item == null || item.contents == null)
		{
			return;
		}
		ItemModContainer component = ((Component)item.info).GetComponent<ItemModContainer>();
		if (!((Object)(object)component == (Object)null) && component.canLootInWorld)
		{
			BasePlayer player = rpc.player;
			if (Object.op_Implicit((Object)(object)player) && player.CanInteract() && CanOpenInSafeZone(player) && Interface.CallHook("CanLootEntity", (object)player, (object)this) == null && player.inventory.loot.StartLootingEntity(this))
			{
				SetFlag(Flags.Open, b: true);
				player.inventory.loot.AddContainer(item.contents);
				player.inventory.loot.SendImmediate();
				player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), "generic_resizable");
				SendNetworkUpdate();
			}
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;

public class XMasRefill : BaseEntity
{
	public GameObjectRef[] giftPrefabs;

	public List<BasePlayer> goodKids;

	public List<Stocking> stockings;

	public AudioSource bells;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("XMasRefill.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public float GiftRadius()
	{
		return XMas.spawnRange;
	}

	public int GiftsPerPlayer()
	{
		return XMas.giftsPerPlayer;
	}

	public int GiftSpawnAttempts()
	{
		return XMas.giftsPerPlayer * XMas.spawnAttempts;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!XMas.enabled)
		{
			((FacepunchBehaviour)this).Invoke((Action)RemoveMe, 0.1f);
			return;
		}
		goodKids = ((BasePlayer.activePlayerList != null) ? new List<BasePlayer>((IEnumerable<BasePlayer>)BasePlayer.activePlayerList) : new List<BasePlayer>());
		stockings = ((Stocking.stockings != null) ? new List<Stocking>((IEnumerable<Stocking>)Stocking.stockings.Values) : new List<Stocking>());
		((FacepunchBehaviour)this).Invoke((Action)RemoveMe, 60f);
		if (Interface.CallHook("OnXmasLootDistribute", (object)this) == null)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)DistributeLoot, 3f, 0.02f);
			((FacepunchBehaviour)this).Invoke((Action)SendBells, 0.5f);
		}
	}

	public void SendBells()
	{
		ClientRPC(RpcTarget.NetworkGroup("PlayBells"));
	}

	public void RemoveMe()
	{
		if (goodKids.Count == 0 && stockings.Count == 0)
		{
			Kill();
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)RemoveMe, 60f);
		}
	}

	public void DistributeLoot()
	{
		if (goodKids.Count > 0)
		{
			BasePlayer basePlayer = null;
			foreach (BasePlayer goodKid in goodKids)
			{
				if (!goodKid.IsSleeping() && !goodKid.IsWounded() && goodKid.IsAlive())
				{
					basePlayer = goodKid;
					break;
				}
			}
			if (Object.op_Implicit((Object)(object)basePlayer))
			{
				DistributeGiftsForPlayer(basePlayer);
				goodKids.Remove(basePlayer);
			}
		}
		if (stockings.Count > 0)
		{
			Stocking stocking = stockings[0];
			if ((Object)(object)stocking != (Object)null)
			{
				stocking.SpawnLoot();
			}
			stockings.RemoveAt(0);
		}
	}

	protected bool DropToGround(ref Vector3 pos)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		int num = 1235288065;
		int num2 = 8454144;
		if (Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap) && (TerrainMeta.TopologyMap.GetTopology(pos) & 0x14080) != 0)
		{
			return false;
		}
		if (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap) && Object.op_Implicit((Object)(object)TerrainMeta.Collision) && !TerrainMeta.Collision.GetIgnore(pos))
		{
			float height = TerrainMeta.HeightMap.GetHeight(pos);
			pos.y = Mathf.Max(pos.y, height);
		}
		if (!TransformUtil.GetGroundInfo(pos, out var hitOut, 80f, LayerMask.op_Implicit(num)))
		{
			return false;
		}
		if (((1 << ((Component)((RaycastHit)(ref hitOut)).transform).gameObject.layer) & num2) == 0)
		{
			return false;
		}
		pos = ((RaycastHit)(ref hitOut)).point;
		return true;
	}

	public bool DistributeGiftsForPlayer(BasePlayer player)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnXmasGiftsDistribute", (object)this, (object)player) != null)
		{
			return false;
		}
		int num = GiftsPerPlayer();
		int num2 = GiftSpawnAttempts();
		for (int i = 0; i < num2; i++)
		{
			if (num <= 0)
			{
				break;
			}
			Vector2 val = Random.insideUnitCircle * GiftRadius();
			Vector3 pos = ((Component)player).transform.position + new Vector3(val.x, 10f, val.y);
			Quaternion rot = Quaternion.Euler(0f, Random.Range(0f, 360f), 0f);
			if (DropToGround(ref pos))
			{
				string resourcePath = giftPrefabs[Random.Range(0, giftPrefabs.Length)].resourcePath;
				BaseEntity baseEntity = GameManager.server.CreateEntity(resourcePath, pos, rot);
				if (Object.op_Implicit((Object)(object)baseEntity))
				{
					baseEntity.Spawn();
					num--;
				}
			}
		}
		return true;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class ZiplineLaunchPoint : BaseEntity
{
	public Transform LineDeparturePoint;

	public LineRenderer ZiplineRenderer;

	public Collider MountCollider;

	public BoxCollider[] BuildingBlocks;

	public BoxCollider[] PointBuildingBlocks;

	public SpawnableBoundsBlocker[] SpawnableBoundsBlockers;

	public GameObjectRef MountableRef;

	public float LineSlackAmount = 2f;

	public bool RegenLine;

	public List<Vector3> ziplineTargets = new List<Vector3>();

	private List<Vector3> linePoints;

	public GameObjectRef ArrivalPointRef;

	private const float MaxZiplineLength = 185f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("ZiplineLaunchPoint.OnRpcMessage", 0);
		try
		{
			if (rpc == 2256922575u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - MountPlayer "));
				}
				TimeWarning val2 = TimeWarning.New("MountPlayer", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2256922575u, "MountPlayer", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2256922575u, "MountPlayer", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							MountPlayer(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in MountPlayer");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
		ziplineTargets.Clear();
		linePoints = null;
	}

	public override void PostMapEntitySpawn()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		base.PostMapEntitySpawn();
		FindZiplineTarget(ref ziplineTargets);
		CalculateZiplinePoints(ziplineTargets, ref linePoints);
		if (ziplineTargets.Count == 0)
		{
			Kill();
			return;
		}
		Vector3 val = linePoints[0];
		List<Vector3> list = linePoints;
		if (Vector3.Distance(val, list[list.Count - 1]) > 100f && ArrivalPointRef != null && ArrivalPointRef.isValid)
		{
			GameManager obj = base.gameManager;
			string resourcePath = ArrivalPointRef.resourcePath;
			List<Vector3> list2 = linePoints;
			ZiplineArrivalPoint obj2 = obj.CreateEntity(resourcePath, list2[list2.Count - 1]) as ZiplineArrivalPoint;
			obj2.SetPositions(linePoints);
			obj2.Spawn();
		}
		UpdateBuildingBlocks();
		SendNetworkUpdate();
	}

	public void FindZiplineTarget(ref List<Vector3> foundPositions)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0351: Unknown result type (might be due to invalid IL or missing references)
		foundPositions.Clear();
		Vector3 position = LineDeparturePoint.position;
		List<ZiplineTarget> list = Pool.Get<List<ZiplineTarget>>();
		GamePhysics.OverlapSphere<ZiplineTarget>(position + ((Component)this).transform.forward * 185f, 185f, list, 1084293377, (QueryTriggerInteraction)1);
		ZiplineTarget ziplineTarget = null;
		float num = float.MinValue;
		float num2 = 3f;
		foreach (ZiplineTarget item in list)
		{
			if (item.IsChainPoint)
			{
				continue;
			}
			Vector3 position2 = ((Component)item).transform.position;
			Vector3 val = Vector3Ex.WithY(position2, position.y) - position;
			float num3 = Vector3.Dot(((Vector3)(ref val)).normalized, ((Component)this).transform.forward);
			val = position - Vector3Ex.WithY(position2, position.y);
			float num4 = Vector3.Dot(((Vector3)(ref val)).normalized, ((Component)item).transform.forward);
			float num5 = Vector3.Distance(position, position2) + (position2.y - position.y);
			float num6 = num5 * num3 * num4;
			if (!(num3 > 0.2f) || !item.IsValidPosition(position) || !(position.y + num2 > position2.y) || !(num5 > 10f) || !(num6 > num))
			{
				continue;
			}
			if (CheckLineOfSight(position, position2))
			{
				num = num6;
				ziplineTarget = item;
				foundPositions.Clear();
				foundPositions.Add(((Component)ziplineTarget).transform.position);
				continue;
			}
			foreach (ZiplineTarget item2 in list)
			{
				if (!item2.IsChainPoint || !item2.IsValidChainPoint(position, position2))
				{
					continue;
				}
				Vector3 position3 = ((Component)item2).transform.position;
				val = Vector3Ex.WithY(position3, position.y) - position;
				num3 = Vector3.Dot(((Vector3)(ref val)).normalized, ((Component)this).transform.forward);
				val = position - Vector3Ex.WithY(position3, position.y);
				num4 = Vector3.Dot(((Vector3)(ref val)).normalized, ((Component)item2).transform.forward);
				num6 = num5 * num3 * num4;
				bool flag = CheckLineOfSight(position, ((Component)item2).transform.position);
				bool flag2 = CheckLineOfSight(((Component)item2).transform.position, position2);
				if (flag && flag2)
				{
					num = num6;
					ziplineTarget = item;
					foundPositions.Clear();
					foundPositions.Add(((Component)item2).transform.position);
					foundPositions.Add(((Component)ziplineTarget).transform.position);
				}
				else
				{
					if (!flag)
					{
						continue;
					}
					foreach (ZiplineTarget item3 in list)
					{
						if (!((Object)(object)item3 == (Object)(object)item2) && item3.IsValidChainPoint(item2.Target.position, item.Target.position))
						{
							bool num7 = CheckLineOfSight(((Component)item2).transform.position, ((Component)item3).transform.position);
							bool flag3 = CheckLineOfSight(((Component)item3).transform.position, ((Component)item).transform.position);
							if (num7 && flag3)
							{
								num = num6;
								ziplineTarget = item;
								foundPositions.Clear();
								foundPositions.Add(((Component)item2).transform.position);
								foundPositions.Add(((Component)item3).transform.position);
								foundPositions.Add(((Component)ziplineTarget).transform.position);
							}
						}
					}
				}
			}
		}
	}

	public bool CheckLineOfSight(Vector3 from, Vector3 to)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = CalculateLineMidPoint(from, to) - Vector3.up * 0.75f;
		if (GamePhysics.LineOfSightRadius(from, to, 1084293377, 0.5f, 2f) && GamePhysics.LineOfSightRadius(from, val, 1084293377, 0.5f, 2f))
		{
			return GamePhysics.LineOfSightRadius(val, to, 1084293377, 0.5f, 2f);
		}
		return false;
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server]
	public void MountPlayer(RPCMessage msg)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		if (IsBusy() || (Object)(object)msg.player == (Object)null || !msg.player.CanInteract() || msg.player.Distance(LineDeparturePoint.position) > 3f || !IsPlayerFacingValidDirection(msg.player) || ziplineTargets.Count == 0)
		{
			return;
		}
		Vector3 position = LineDeparturePoint.position;
		Vector3 val = Vector3Ex.WithY(ziplineTargets[0], position.y) - position;
		Quaternion lineStartRot = Quaternion.LookRotation(((Vector3)(ref val)).normalized);
		val = position - Vector3Ex.WithY(((Component)msg.player).transform.position, position.y);
		Quaternion rot = Quaternion.LookRotation(((Vector3)(ref val)).normalized);
		ZiplineMountable ziplineMountable = base.gameManager.CreateEntity(MountableRef.resourcePath, ((Component)msg.player).transform.position + Vector3.up * 2.1f, rot) as ZiplineMountable;
		if ((Object)(object)ziplineMountable != (Object)null)
		{
			CalculateZiplinePoints(ziplineTargets, ref linePoints);
			ziplineMountable.SetDestination(linePoints, position, lineStartRot);
			ziplineMountable.Spawn();
			ziplineMountable.MountPlayer(msg.player);
			if ((Object)(object)msg.player.GetMounted() != (Object)(object)ziplineMountable)
			{
				ziplineMountable.Kill();
			}
			SetFlag(Flags.Busy, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ClearBusy, 2f);
		}
	}

	public void ClearBusy()
	{
		SetFlag(Flags.Busy, b: false);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.zipline == null)
		{
			info.msg.zipline = Pool.Get<Zipline>();
		}
		info.msg.zipline.destinationPoints = Pool.Get<List<VectorData>>();
		foreach (Vector3 ziplineTarget in ziplineTargets)
		{
			info.msg.zipline.destinationPoints.Add(new VectorData(ziplineTarget.x, ziplineTarget.y, ziplineTarget.z));
		}
	}

	[ServerVar(ServerAdmin = true)]
	public static void report(Arg arg)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		int num2 = 0;
		int num3 = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				if (current is ZiplineLaunchPoint ziplineLaunchPoint)
				{
					float lineLength = ziplineLaunchPoint.GetLineLength();
					num2++;
					num += lineLength;
				}
				else if (current is ZiplineArrivalPoint)
				{
					num3++;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith($"{num2} ziplines, total distance: {num:F2}, avg length: {num / (float)num2:F2}, arrival points: {num3}");
	}

	[ServerVar(ServerAdmin = true)]
	public static void highlight(Arg arg)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				if (enumerator.Current is ZiplineLaunchPoint ziplineLaunchPoint)
				{
					BasePlayer basePlayer = arg.Player();
					object[] obj = new object[7]
					{
						"60",
						Color.red,
						((Component)ziplineLaunchPoint).transform.position,
						null,
						null,
						null,
						null
					};
					List<Vector3> list = ziplineLaunchPoint.ziplineTargets;
					obj[3] = list[list.Count - 1];
					obj[4] = 25;
					obj[5] = 0;
					obj[6] = 0;
					basePlayer.SendConsoleCommand("ddraw.arrow", obj);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.zipline == null)
		{
			return;
		}
		ziplineTargets.Clear();
		foreach (VectorData destinationPoint in info.msg.zipline.destinationPoints)
		{
			ziplineTargets.Add(VectorData.op_Implicit(destinationPoint));
		}
	}

	public void CalculateZiplinePoints(List<Vector3> targets, ref List<Vector3> points)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (points == null && targets.Count != 0)
		{
			Vector3[] array = (Vector3[])(object)new Vector3[targets.Count + 1];
			array[0] = LineDeparturePoint.position;
			for (int i = 0; i < targets.Count; i++)
			{
				array[i + 1] = targets[i];
			}
			float[] array2 = new float[array.Length];
			for (int j = 0; j < array2.Length; j++)
			{
				array2[j] = LineSlackAmount;
			}
			points = new List<Vector3>();
			Bezier.ApplyLineSlack(array, array2, ref points, 25);
		}
	}

	public Vector3 CalculateLineMidPoint(Vector3 start, Vector3 endPoint)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 result = Vector3.Lerp(start, endPoint, 0.5f);
		result.y -= LineSlackAmount;
		return result;
	}

	public void UpdateBuildingBlocks()
	{
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		BoxCollider[] buildingBlocks = BuildingBlocks;
		for (int i = 0; i < buildingBlocks.Length; i++)
		{
			((Component)buildingBlocks[i]).gameObject.SetActive(false);
		}
		buildingBlocks = PointBuildingBlocks;
		for (int i = 0; i < buildingBlocks.Length; i++)
		{
			((Component)buildingBlocks[i]).gameObject.SetActive(false);
		}
		SpawnableBoundsBlocker[] spawnableBoundsBlockers = SpawnableBoundsBlockers;
		for (int i = 0; i < spawnableBoundsBlockers.Length; i++)
		{
			((Component)spawnableBoundsBlockers[i]).gameObject.SetActive(false);
		}
		int num = 0;
		if (ziplineTargets.Count <= 0)
		{
			return;
		}
		Vector3 val = Vector3.zero;
		int startIndex2 = 0;
		for (int j = 0; j < linePoints.Count; j++)
		{
			if (j == 0 || (base.isClient && j == 1))
			{
				continue;
			}
			Vector3 val2 = linePoints[j];
			Vector3 val3 = val2 - Vector3Ex.WithY(linePoints[j - 1], val2.y);
			Vector3 normalized = ((Vector3)(ref val3)).normalized;
			if (val != Vector3.zero && Vector3.Dot(normalized, val) < 0.98f)
			{
				if (num < BuildingBlocks.Length)
				{
					SetUpBuildingBlock(BuildingBlocks[num], PointBuildingBlocks[num], SpawnableBoundsBlockers[num++], startIndex2, j - 1);
				}
				startIndex2 = j - 1;
			}
			val = normalized;
		}
		if (num < BuildingBlocks.Length)
		{
			SetUpBuildingBlock(BuildingBlocks[num], PointBuildingBlocks[num], SpawnableBoundsBlockers[num], startIndex2, linePoints.Count - 1);
		}
		void SetUpBuildingBlock(BoxCollider longCollider, BoxCollider pointCollider, SpawnableBoundsBlocker spawnBlocker, int startIndex, int endIndex)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00de: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0114: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val4 = linePoints[startIndex];
			Vector3 val5 = linePoints[endIndex];
			Vector3 val6 = Vector3.zero;
			Vector3 center = val4 - val5;
			Quaternion rotation = Quaternion.LookRotation(((Vector3)(ref center)).normalized, Vector3.up);
			Vector3 position = Vector3.Lerp(val4, val5, 0.5f);
			((Component)longCollider).transform.position = position;
			((Component)longCollider).transform.rotation = rotation;
			for (int k = startIndex; k < endIndex; k++)
			{
				Vector3 val7 = ((Component)longCollider).transform.InverseTransformPoint(linePoints[k]);
				if (val7.y < val6.y)
				{
					val6 = val7;
				}
			}
			float num2 = Mathf.Abs(val6.y) + 2f;
			float num3 = Vector3.Distance(val4, val5);
			center = (longCollider.size = (spawnBlocker.BoxCollider.size = new Vector3(0.5f, num2, num3) + Vector3.one));
			BoxCollider boxCollider = spawnBlocker.BoxCollider;
			((Vector3)(ref center))..ctor(0f, 0f - num2 * 0.5f, 0f);
			boxCollider.center = center;
			longCollider.center = center;
			((Component)longCollider).gameObject.SetActive(true);
			((Component)pointCollider).transform.position = linePoints[endIndex];
			((Component)pointCollider).gameObject.SetActive(true);
			((Component)spawnBlocker).gameObject.SetActive(true);
			if (base.isServer)
			{
				spawnBlocker.ClearTrees();
			}
		}
	}

	public bool IsPlayerFacingValidDirection(BasePlayer ply)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Dot(ply.eyes.HeadForward(), ((Component)this).transform.forward) > 0.2f;
	}

	public float GetLineLength()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (linePoints == null)
		{
			return 0f;
		}
		float num = 0f;
		for (int i = 0; i < linePoints.Count - 1; i++)
		{
			num += Vector3.Distance(linePoints[i], linePoints[i + 1]);
		}
		return num;
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class LegacyShelter : DecayEntity
{
	public static readonly int FpShelterDefault = 1;

	[ReplicatedVar]
	public static int max_shelters = 1;

	private static Dictionary<ulong, List<LegacyShelter>> sheltersPerPlayer = new Dictionary<ulong, List<LegacyShelter>>();

	public static Phrase shelterLimitPhrase = new Phrase("shelter_limit_update", "You are now at {0}/{1} shelters");

	public static Phrase shelterLimitReachedPhrase = new Phrase("shelter_limit_reached", "You have reached your shelter limit!");

	[Header("Shelter References")]
	public GameObjectRef smallPrivilegePrefab;

	public GameObjectRef includedDoorPrefab;

	public GameObjectRef includedLockPrefab;

	public EntityRef<EntityPrivilege> entityPrivilege;

	private EntityRef<LegacyShelterDoor> childDoorInstance;

	private EntityRef<BaseLock> lockEntityInstance;

	private Decay decayReference;

	private float lastShelterDecayTick;

	public float lastInteractedWithDoor;

	private ulong shelterOwnerID;

	public static Dictionary<ulong, List<LegacyShelter>> SheltersPerPlayer => sheltersPerPlayer;

	public static Planner.CanBuildResult? CanBuildShelter(BasePlayer player, Construction construction)
	{
		GameObject obj = GameManager.server.FindPrefab(construction.prefabID);
		if (((obj != null) ? obj.GetComponent<BaseEntity>() : null) is LegacyShelter)
		{
			int num = 1;
			Planner.CanBuildResult value2;
			if (sheltersPerPlayer.TryGetValue(player.userID, out var value))
			{
				num = value.Count + 1;
				if (value.Count >= max_shelters)
				{
					value2 = default(Planner.CanBuildResult);
					value2.Result = false;
					value2.Phrase = shelterLimitReachedPhrase;
					return value2;
				}
			}
			value2 = default(Planner.CanBuildResult);
			value2.Result = true;
			value2.Phrase = shelterLimitPhrase;
			value2.Arguments = new string[2]
			{
				num.ToString(),
				max_shelters.ToString()
			};
			return value2;
		}
		return null;
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (sheltersPerPlayer.TryGetValue(shelterOwnerID, out var _))
		{
			sheltersPerPlayer[shelterOwnerID].Remove(this);
			BasePlayer basePlayer = BasePlayer.FindByID(shelterOwnerID);
			if ((Object)(object)basePlayer != (Object)null)
			{
				basePlayer.SendRespawnOptions();
			}
		}
	}

	public static int GetShelterCount(ulong userId)
	{
		if (userId == 0L)
		{
			return 0;
		}
		if (!sheltersPerPlayer.TryGetValue(userId, out var value))
		{
			return 0;
		}
		return value.Count;
	}

	private void AddToShelterList(ulong id)
	{
		if (!sheltersPerPlayer.ContainsKey(id))
		{
			sheltersPerPlayer.Add(id, new List<LegacyShelter>());
		}
		if (!IsShelterInList(sheltersPerPlayer[id], out var _))
		{
			sheltersPerPlayer[id].Add(this);
		}
	}

	private bool IsShelterInList(List<LegacyShelter> shelters, out LegacyShelter thisShelter)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		bool result = false;
		thisShelter = null;
		if (shelters.Count == 0)
		{
			return false;
		}
		if ((Object)(object)thisShelter == (Object)null)
		{
			return false;
		}
		foreach (LegacyShelter shelter in shelters)
		{
			if (shelter.net.ID == net.ID)
			{
				result = true;
				thisShelter = shelter;
				break;
			}
		}
		return result;
	}

	public override EntityPrivilege GetEntityBuildingPrivilege()
	{
		return GetEntityPrivilege();
	}

	public EntityPrivilege GetEntityPrivilege()
	{
		EntityPrivilege entityPrivilege = this.entityPrivilege.Get(base.isServer);
		if (entityPrivilege.IsValid())
		{
			return entityPrivilege;
		}
		return null;
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && child.prefabID == includedDoorPrefab.GetEntity().prefabID && !Application.isLoadingSave)
		{
			Setup(child);
		}
		if (child.prefabID == smallPrivilegePrefab.GetEntity().prefabID)
		{
			EntityPrivilege entity = (EntityPrivilege)child;
			entityPrivilege.Set(entity);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.legacyShelter == null || !base.isServer)
		{
			return;
		}
		shelterOwnerID = info.msg.legacyShelter.ownerId;
		childDoorInstance = new EntityRef<LegacyShelterDoor>(info.msg.legacyShelter.doorID);
		lastInteractedWithDoor = info.msg.legacyShelter.timeSinceInteracted;
		AddToShelterList(shelterOwnerID);
		if (max_shelters == FpShelterDefault)
		{
			BasePlayer basePlayer = BasePlayer.FindByID(shelterOwnerID);
			if ((Object)(object)basePlayer != (Object)null)
			{
				basePlayer.SendRespawnOptions();
			}
		}
	}

	public override void DecayTick()
	{
		base.DecayTick();
		float num = Time.time - lastShelterDecayTick;
		lastShelterDecayTick = Time.time;
		float num2 = num * ConVar.Decay.scale;
		lastInteractedWithDoor += num2;
		UpdateDoorHp();
	}

	public void HasInteracted()
	{
		lastInteractedWithDoor = 0f;
	}

	public void SetupDecay()
	{
		decayReference = PrefabAttribute.server.Find<Decay>(prefabID);
	}

	public override float GetEntityDecayDuration()
	{
		if (lastInteractedWithDoor < 64800f)
		{
			return float.MaxValue;
		}
		if (decayReference == null)
		{
			SetupDecay();
		}
		if (decayReference != null)
		{
			return decayReference.GetDecayDuration(this);
		}
		return float.MaxValue;
	}

	public LegacyShelterDoor GetChildDoor()
	{
		LegacyShelterDoor legacyShelterDoor = childDoorInstance.Get(base.isServer);
		if (legacyShelterDoor.IsValid())
		{
			return legacyShelterDoor;
		}
		return null;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.legacyShelter = Pool.Get<LegacyShelter>();
		info.msg.legacyShelter.doorID = childDoorInstance.uid;
		info.msg.legacyShelter.timeSinceInteracted = lastInteractedWithDoor;
		info.msg.legacyShelter.ownerId = shelterOwnerID;
	}

	public override void OnPlaced(BasePlayer player)
	{
		if (sheltersPerPlayer.TryGetValue(player.userID, out var value) && value.Count >= max_shelters)
		{
			value[0].Kill(DestroyMode.Gib);
		}
		shelterOwnerID = player.userID;
		AddToShelterList(shelterOwnerID);
		player.SendRespawnOptions();
	}

	public override void Hurt(HitInfo info)
	{
		base.Hurt(info);
		LegacyShelterDoor childDoor = GetChildDoor();
		if ((Object)(object)childDoor != (Object)null)
		{
			childDoor.ProtectedHurt(info);
		}
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		LegacyShelterDoor childDoor = GetChildDoor();
		if ((Object)(object)childDoor != (Object)null && !childDoor.IsDead())
		{
			childDoor.Die();
		}
	}

	public override void OnRepair()
	{
		base.OnRepair();
		UpdateDoorHp();
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		base.OnRepairFinished(player);
		UpdateDoorHp();
	}

	public void ProtectedHurt(HitInfo info)
	{
		info.HitEntity = this;
		base.Hurt(info);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		LegacyShelterDoor childDoor = GetChildDoor();
		if (Object.op_Implicit((Object)(object)childDoor))
		{
			childDoor.SetupDoor(this);
			childDoor.SetMaxHealth(MaxHealth());
			UpdateDoorHp();
		}
		SetupDecay();
	}

	private void Setup(BaseEntity child)
	{
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		LegacyShelterDoor legacyShelterDoor = (LegacyShelterDoor)child;
		childDoorInstance.Set(legacyShelterDoor);
		BasePlayer basePlayer = BasePlayer.FindByID(shelterOwnerID);
		((Component)this).GetComponentInChildren<EntityPrivilege>().AddPlayer(basePlayer);
		legacyShelterDoor.SetupDoor(this);
		legacyShelterDoor.SetMaxHealth(MaxHealth());
		UpdateDoorHp();
		BaseEntity baseEntity = GameManager.server.CreateEntity(includedLockPrefab.resourcePath);
		baseEntity.SetParent(legacyShelterDoor, legacyShelterDoor.GetSlotAnchorName(Slot.Lock));
		baseEntity.OwnerID = shelterOwnerID;
		baseEntity.OnDeployed(legacyShelterDoor, basePlayer, null);
		baseEntity.Spawn();
		BaseLock baseLock = (BaseLock)baseEntity;
		if ((Object)(object)baseLock != (Object)null)
		{
			baseLock.CanRemove = false;
		}
		legacyShelterDoor.SetSlot(Slot.Lock, baseEntity);
	}

	private void UpdateDoorHp()
	{
		LegacyShelterDoor childDoor = GetChildDoor();
		if ((Object)(object)childDoor != (Object)null)
		{
			childDoor.SetHealth(base.health);
		}
	}
}


using Rust;
using UnityEngine;

public class LegacyShelterDoor : Door
{
	public GameObjectRef includedLockPrefab;

	private LegacyShelter shelter;

	public void SetupDoor(LegacyShelter shelter)
	{
		this.shelter = shelter;
	}

	public override void DecayTick()
	{
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (Application.isLoadingSave && child.prefabID == includedLockPrefab.GetEntity().prefabID && child.IsValid())
		{
			BaseLock baseLock = (BaseLock)child;
			if ((Object)(object)baseLock != (Object)null)
			{
				baseLock.CanRemove = false;
			}
		}
	}

	protected override void OnPlayerOpenedDoor(BasePlayer p)
	{
		base.OnPlayerOpenedDoor(p);
		if ((Object)(object)shelter != (Object)null)
		{
			shelter.HasInteracted();
		}
	}

	public override void OnRepair()
	{
		base.OnRepair();
		UpdateShelterHp();
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		base.OnRepairFinished(player);
		UpdateShelterHp();
	}

	public override void Hurt(HitInfo info)
	{
		if (HasParent() && (Object)(object)shelter != (Object)null)
		{
			shelter.ProtectedHurt(info);
		}
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if ((Object)(object)shelter != (Object)null && !shelter.IsDead())
		{
			shelter.Die();
		}
	}

	public void ProtectedHurt(HitInfo info)
	{
		info.HitEntity = this;
		base.Hurt(info);
	}

	private void UpdateShelterHp()
	{
		if (HasParent() && (Object)(object)shelter != (Object)null)
		{
			shelter.SetHealth(base.health);
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ZiplineArrivalPoint : BaseEntity
{
	public LineRenderer Line;

	private Vector3[] linePositions;

	public override void Save(SaveInfo info)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.ZiplineArrival == null)
		{
			info.msg.ZiplineArrival = Pool.Get<ZiplineArrivalPoint>();
		}
		info.msg.ZiplineArrival.linePoints = Pool.Get<List<VectorData>>();
		Vector3[] array = linePositions;
		foreach (Vector3 val in array)
		{
			info.msg.ZiplineArrival.linePoints.Add(VectorData.op_Implicit(val));
		}
	}

	public void SetPositions(List<Vector3> points)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		linePositions = (Vector3[])(object)new Vector3[points.Count];
		for (int i = 0; i < points.Count; i++)
		{
			linePositions[i] = points[i];
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.ZiplineArrival != null && linePositions == null)
		{
			linePositions = (Vector3[])(object)new Vector3[info.msg.ZiplineArrival.linePoints.Count];
			for (int i = 0; i < info.msg.ZiplineArrival.linePoints.Count; i++)
			{
				linePositions[i] = VectorData.op_Implicit(info.msg.ZiplineArrival.linePoints[i]);
			}
		}
	}

	public override void ResetState()
	{
		base.ResetState();
		linePositions = null;
	}
}


using UnityEngine;

public class ZiplineAudio : MonoBehaviour
{
	public ZiplineMountable zipline;

	public SoundDefinition movementLoopDef;

	public SoundDefinition frictionLoopDef;

	public SoundDefinition sparksLoopDef;

	public AnimationCurve movementGainCurve;

	public AnimationCurve movementPitchCurve;

	public AnimationCurve frictionGainCurve;

	public AnimationCurve sparksGainCurve;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ZiplineMountable : BaseMountable
{
	public float MoveSpeed = 4f;

	public float ForwardAdditive = 5f;

	public CapsuleCollider ZipCollider;

	public Transform ZiplineGrabRoot;

	public Transform LeftHandIkPoint;

	public Transform RightHandIkPoint;

	public float SpeedUpTime = 0.6f;

	public bool EditorHoldInPlace;

	private List<Vector3> linePoints;

	public const Flags PushForward = Flags.Reserved1;

	public AnimationCurve MountPositionCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public AnimationCurve MountRotationCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public float MountEaseInTime = 0.5f;

	public const Flags ShowHandle = Flags.Reserved2;

	public float additiveValue;

	public float currentTravelDistance;

	public TimeSince mountTime;

	private bool hasEnded;

	public List<Collider> ignoreColliders = new List<Collider>();

	private Vector3 lastSafePosition;

	public Vector3 startPosition = Vector3.zero;

	public Vector3 endPosition = Vector3.zero;

	public Quaternion startRotation = Quaternion.identity;

	public Quaternion endRotation = Quaternion.identity;

	public float elapsedMoveTime;

	public bool isAnimatingIn;

	public Vector3 ProcessBezierMovement(float distanceToTravel)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		if (linePoints == null)
		{
			return Vector3.zero;
		}
		float num = 0f;
		for (int i = 0; i < linePoints.Count - 1; i++)
		{
			float num2 = Vector3.Distance(linePoints[i], linePoints[i + 1]);
			if (num + num2 > distanceToTravel)
			{
				float num3 = Mathf.Clamp((distanceToTravel - num) / num2, 0f, 1f);
				return Vector3.Lerp(linePoints[i], linePoints[i + 1], num3);
			}
			num += num2;
		}
		return linePoints[linePoints.Count - 1];
	}

	public Vector3 GetLineEndPoint(bool applyDismountOffset = false)
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (applyDismountOffset && linePoints != null)
		{
			List<Vector3> list = linePoints;
			Vector3 val = list[list.Count - 2];
			List<Vector3> list2 = linePoints;
			Vector3 val2 = val - list2[list2.Count - 1];
			Vector3 normalized = ((Vector3)(ref val2)).normalized;
			List<Vector3> list3 = linePoints;
			return list3[list3.Count - 1] + normalized * 1.5f;
		}
		List<Vector3> list4 = linePoints;
		return list4?[list4.Count - 1] ?? Vector3.zero;
	}

	public Vector3 GetNextLinePoint(Transform forTransform)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = forTransform.position;
		Vector3 forward = forTransform.forward;
		for (int i = 1; i < linePoints.Count - 1; i++)
		{
			Vector3 val = linePoints[i + 1] - position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			val = linePoints[i - 1] - position;
			Vector3 normalized2 = ((Vector3)(ref val)).normalized;
			float num = Vector3.Dot(forward, normalized);
			float num2 = Vector3.Dot(forward, normalized2);
			if (num > 0f && num2 < 0f)
			{
				return linePoints[i + 1];
			}
		}
		return GetLineEndPoint();
	}

	public override void ResetState()
	{
		base.ResetState();
		additiveValue = 0f;
		currentTravelDistance = 0f;
		hasEnded = false;
		linePoints = null;
	}

	public override float MaxVelocity()
	{
		return MoveSpeed + ForwardAdditive;
	}

	public void SetDestination(List<Vector3> targetLinePoints, Vector3 lineStartPos, Quaternion lineStartRot)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		linePoints = targetLinePoints;
		currentTravelDistance = 0f;
		mountTime = TimeSince.op_Implicit(0f);
		GamePhysics.OverlapSphere(((Component)this).transform.position, 6f, ignoreColliders, 1084293377, (QueryTriggerInteraction)1);
		startPosition = ((Component)this).transform.position;
		startRotation = ((Component)this).transform.rotation;
		lastSafePosition = startPosition;
		endPosition = lineStartPos;
		endRotation = lineStartRot;
		elapsedMoveTime = 0f;
		isAnimatingIn = true;
		((FacepunchBehaviour)this).InvokeRepeating((Action)MovePlayerToPosition, 0f, 0f);
	}

	private void Update()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		if (linePoints == null || base.isClient || isAnimatingIn || hasEnded)
		{
			return;
		}
		float num = (MoveSpeed + additiveValue * ForwardAdditive) * Mathf.Clamp(TimeSince.op_Implicit(mountTime) / SpeedUpTime, 0f, 1f) * Time.smoothDeltaTime;
		currentTravelDistance += num;
		Vector3 val = ProcessBezierMovement(currentTravelDistance);
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		Vector3 position = Vector3Ex.WithY(val, val.y - ZipCollider.height * 0.6f);
		Vector3 position2 = val;
		GamePhysics.CapsuleSweep(position, position2, 0.5f, ((Component)this).transform.forward, num, list, 1084293377, (QueryTriggerInteraction)1);
		foreach (RaycastHit item in list)
		{
			RaycastHit current = item;
			if (!((Object)(object)((RaycastHit)(ref current)).collider == (Object)(object)ZipCollider) && !ignoreColliders.Contains(((RaycastHit)(ref current)).collider) && !((Object)(object)((Component)((RaycastHit)(ref current)).collider).GetComponentInParent<PowerlineNode>() != (Object)null) && !((Object)(object)((Component)((RaycastHit)(ref current)).collider).GetComponent<TreeEntity>() != (Object)null) && !((Object)(object)((Component)((RaycastHit)(ref current)).collider).GetComponentInParent<TreeEntity>() != (Object)null))
			{
				ZiplineMountable componentInParent = ((Component)((RaycastHit)(ref current)).collider).GetComponentInParent<ZiplineMountable>();
				if ((Object)(object)componentInParent != (Object)null)
				{
					componentInParent.EndZipline();
				}
				if (!GetDismountPosition(GetMounted(), out var _, silent: true))
				{
					((Component)this).transform.position = lastSafePosition;
				}
				EndZipline();
				Pool.FreeUnmanaged<RaycastHit>(ref list);
				return;
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		if (Vector3.Distance(val, GetLineEndPoint()) < 0.1f)
		{
			((Component)this).transform.position = GetLineEndPoint(applyDismountOffset: true);
			hasEnded = true;
			return;
		}
		if (Vector3.Distance(lastSafePosition, ((Component)this).transform.position) > 0.5f && GetDismountPosition(GetMounted(), out var _, silent: true))
		{
			lastSafePosition = ((Component)this).transform.position;
		}
		Vector3 val2 = val - Vector3Ex.WithY(((Component)this).transform.position, val.y);
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		((Component)this).transform.position = Vector3.Lerp(((Component)this).transform.position, val, Time.deltaTime * 12f);
		((Component)this).transform.forward = normalized;
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		base.PlayerServerInput(inputState, player);
		if (linePoints == null)
		{
			return;
		}
		if (hasEnded)
		{
			if (!GetDismountPosition(GetMounted(), out var _, silent: true))
			{
				((Component)this).transform.position = lastSafePosition;
			}
			EndZipline();
		}
		else
		{
			Vector3 position = ((Component)this).transform.position;
			float num = ((GetNextLinePoint(((Component)this).transform).y < position.y + 0.1f && inputState.IsDown(BUTTON.FORWARD)) ? 1f : 0f);
			additiveValue = Mathf.MoveTowards(additiveValue, num, (float)Server.tickrate * ((num > 0f) ? 4f : 2f));
			SetFlag(Flags.Reserved1, additiveValue > 0.5f);
		}
	}

	public void EndZipline()
	{
		DismountAllPlayers();
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		base.OnPlayerDismounted(player);
		if (!base.IsDestroyed)
		{
			Kill();
		}
	}

	public override bool ValidDismountPosition(BasePlayer player, Vector3 disPos)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		((Collider)ZipCollider).enabled = false;
		bool result = base.ValidDismountPosition(player, disPos);
		((Collider)ZipCollider).enabled = true;
		return result;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (linePoints == null)
		{
			return;
		}
		if (info.msg.ziplineMountable == null)
		{
			info.msg.ziplineMountable = Pool.Get<ZiplineMountable>();
		}
		info.msg.ziplineMountable.linePoints = Pool.Get<List<VectorData>>();
		foreach (Vector3 linePoint in linePoints)
		{
			info.msg.ziplineMountable.linePoints.Add(VectorData.op_Implicit(linePoint));
		}
	}

	public void MovePlayerToPosition()
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		elapsedMoveTime += Time.deltaTime;
		float num = Mathf.Clamp(elapsedMoveTime / MountEaseInTime, 0f, 1f);
		Vector3 localPosition = Vector3.Lerp(startPosition, endPosition, MountPositionCurve.Evaluate(num));
		Quaternion localRotation = Quaternion.Lerp(startRotation, endRotation, MountRotationCurve.Evaluate(num));
		((Component)this).transform.localPosition = localPosition;
		((Component)this).transform.localRotation = localRotation;
		if (num >= 1f)
		{
			isAnimatingIn = false;
			SetFlag(Flags.Reserved2, b: true);
			mountTime = TimeSince.op_Implicit(0f);
			((FacepunchBehaviour)this).CancelInvoke((Action)MovePlayerToPosition);
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer && old.HasFlag(Flags.Busy) && !next.HasFlag(Flags.Busy) && !base.IsDestroyed)
		{
			Kill();
		}
	}
}


using UnityEngine;

public class ZiplineTarget : MonoBehaviour
{
	public Transform Target;

	public bool IsChainPoint;

	public float MonumentConnectionDotMin = 0.2f;

	public float MonumentConnectionDotMax = 1f;

	public bool IsValidPosition(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = position - Vector3Ex.WithY(Target.position, position.y);
		float num = Vector3.Dot(((Vector3)(ref val)).normalized, Target.forward);
		if (num >= MonumentConnectionDotMin)
		{
			return num <= MonumentConnectionDotMax;
		}
		return false;
	}

	public bool IsValidChainPoint(Vector3 from, Vector3 to)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = from - Vector3Ex.WithY(Target.position, from.y);
		float num = Vector3.Dot(((Vector3)(ref val)).normalized, Target.forward);
		val = to - Vector3Ex.WithY(Target.position, from.y);
		float num2 = Vector3.Dot(((Vector3)(ref val)).normalized, Target.forward);
		if ((num > 0f && num2 > 0f) || (num < 0f && num2 < 0f))
		{
			return false;
		}
		num2 = Mathf.Abs(num2);
		if (num2 >= MonumentConnectionDotMin)
		{
			return num2 <= MonumentConnectionDotMax;
		}
		return false;
	}
}


public class TriggerVineClimbTip : TriggerBase, IClientComponent
{
}


public class Vine : FacepunchBehaviour
{
	[ClientVar]
	public static bool DRAW_DEBUG;

	[ClientVar]
	public static bool PREVENT_VINE_DRAW;
}


using System;
using System.Collections.Generic;
using Facepunch;
using Spatial;
using UnityEngine;

public class VineLaunchPoint : MonoBehaviour
{
	[Header("References")]
	public GameObjectRef VineMountablePrefab;

	public float MaximumDestinationRange;

	public float MinimumDestinationRange;

	[Header("Arc Settings")]
	public float maxDistanceHeight = -10f;

	public float minDistanceHeight = -4f;

	public int resolution = 30;

	public bool drawArc = true;

	public float angle;

	public float VineSpawnOffset = 0.1f;

	public bool useLevelDirection = true;

	public Transform[] VineArrivalPoints;

	public VineSwingingTree ParentTree;

	private static Grid<VineLaunchPoint> pointGrid = new Grid<VineLaunchPoint>(32, 8096f);

	private bool hasDied;

	private VineMountable spawnedVine
	{
		get
		{
			return ParentTree.GetSpawnedVine(this);
		}
		set
		{
			ParentTree.SetSpawnedVine(this, value);
		}
	}

	public int Index()
	{
		if ((Object)(object)ParentTree != (Object)null)
		{
			for (int i = 0; i < ParentTree.LaunchPoints.Length; i++)
			{
				if ((Object)(object)ParentTree.LaunchPoints[i] == (Object)(object)this)
				{
					return i;
				}
			}
		}
		return -1;
	}

	public Vector3 GetSwingPointAtTime(float time, VineLaunchPoint forPoint)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return GetSwingPointAtTime(time, ((Component)forPoint).transform.position);
	}

	public Vector3 GetSwingPointAtTime(float time, Vector3 forPoint)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		Vector3 val = forPoint;
		Vector3 val2 = val - position;
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		position += normalized * VineSpawnOffset;
		val += normalized * (0f - VineSpawnOffset);
		float num = Mathx.RemapValClamped(Vector3.Distance(position, val), MinimumDestinationRange, MaximumDestinationRange, 0f, 1f);
		Vector3 point = VineUtils.SampleParabola(position, val, Mathf.Lerp(minDistanceHeight, maxDistanceHeight, num), time, useLevelDirection);
		Vector3 pivot = (position + val) / 2f;
		val2 = position - val;
		return VineUtils.RotateAroundWorldAxis(point, pivot, ((Vector3)(ref val2)).normalized, angle);
	}

	public void ServerInit()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		pointGrid.Add(this, position.x, position.z);
		hasDied = false;
	}

	public void DoServerDestroy()
	{
		if (!hasDied)
		{
			hasDied = true;
			pointGrid.Remove(this);
			VineMountable.NotifyVinesLaunchSiteRemoved(this);
		}
	}

	public void SpawnVineIfPossible(VineSwingingTree fromTree)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		hasDied = false;
		VineMountable vineMountable = spawnedVine;
		PooledList<VineLaunchPoint> val = Pool.Get<PooledList<VineLaunchPoint>>();
		try
		{
			if ((Object)(object)vineMountable != (Object)null)
			{
				if (GetReceivePoints((List<VineLaunchPoint>)(object)val))
				{
					vineMountable.Initialise(this, (List<VineLaunchPoint>)(object)val, vineMountable.WorldSpaceAnchorPoint);
					vineMountable.SendNetworkUpdate();
				}
				return;
			}
			((List<VineLaunchPoint>)(object)val).Clear();
			GetReceivePoints((List<VineLaunchPoint>)(object)val);
			if (((List<VineLaunchPoint>)(object)val).Count <= 0)
			{
				return;
			}
			Vector3 val2 = ((Component)this).transform.TransformPoint(Vector3.forward * VineSpawnOffset);
			PooledList<VineMountable> val3 = Pool.Get<PooledList<VineMountable>>();
			try
			{
				GamePhysics.OverlapSphere<VineMountable>(val2, 5f, (List<VineMountable>)(object)val3, 134217728, (QueryTriggerInteraction)2);
				foreach (VineMountable item in (List<VineMountable>)(object)val3)
				{
					if (!item.HasFlag(BaseEntity.Flags.Reserved1))
					{
						return;
					}
				}
				VineMountable vineMountable2 = GameManager.server.CreateEntity(VineMountablePrefab.resourcePath, val2, Quaternion.identity) as VineMountable;
				if (FindVacantArrivalPoint(vineMountable2, out var worldPos))
				{
					((Component)vineMountable2).transform.position = worldPos;
				}
				spawnedVine = vineMountable2;
				Vector3 vineSpawnPos = fromTree.GetVineSpawnPos((List<VineLaunchPoint>)(object)val);
				vineMountable2.Initialise(this, (List<VineLaunchPoint>)(object)val, vineSpawnPos);
				vineMountable2.Spawn();
				vineMountable2.SendNetworkUpdate();
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void OnVineKilled()
	{
		spawnedVine = null;
	}

	private bool GetReceivePoints(List<VineLaunchPoint> points)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		Vector3 forward = ((Component)this).transform.forward;
		bool result = false;
		PooledList<VineLaunchPoint> val = Pool.Get<PooledList<VineLaunchPoint>>();
		try
		{
			if (!Application.isPlaying)
			{
				((List<VineLaunchPoint>)(object)val).AddRange((IEnumerable<VineLaunchPoint>)Object.FindObjectsByType<VineLaunchPoint>((FindObjectsInactive)0, (FindObjectsSortMode)0));
			}
			else
			{
				pointGrid.Query<VineLaunchPoint>(position.x, position.z, MaximumDestinationRange, (List<VineLaunchPoint>)(object)val);
			}
			foreach (VineLaunchPoint item in (List<VineLaunchPoint>)(object)val)
			{
				if ((Object)(object)item == (Object)(object)this || points.Contains(item))
				{
					continue;
				}
				Vector3 position2 = ((Component)item).transform.position;
				float num = Vector3.Distance(position, Vector3Ex.WithY(position2, position.y));
				if (num > MaximumDestinationRange || num < MinimumDestinationRange)
				{
					continue;
				}
				Vector3 val2 = Vector3Ex.WithY(position2, position.y) - position;
				if (!(Vector3.Angle(forward, ((Vector3)(ref val2)).normalized) > 45f) && !(Vector3.Angle(forward, -((Component)item).transform.forward) > 90f))
				{
					if (!GamePhysics.LineOfSightRadius(position, position2, 1084293377, 0.25f, ParentTree))
					{
						return false;
					}
					Vector3 swingPointAtTime = GetSwingPointAtTime(0.5f, position2);
					if (!GamePhysics.LineOfSightRadius(position, swingPointAtTime, 1084293377, 0.25f, ParentTree))
					{
						return false;
					}
					if (!GamePhysics.LineOfSightRadius(position2, swingPointAtTime, 1084293377, 0.25f, ParentTree))
					{
						return false;
					}
					points.Add(item);
					result = true;
				}
			}
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool FindVacantArrivalPoint(VineMountable forMountable, out Vector3 worldPos)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		if (!forMountable.HasFlag(BaseEntity.Flags.Reserved1))
		{
			worldPos = ((Component)this).transform.TransformPoint(Vector3.forward * VineSpawnOffset);
			return true;
		}
		worldPos = Vector3.zero;
		PooledList<VineMountable> val = Pool.Get<PooledList<VineMountable>>();
		try
		{
			Vis.Entities(((Component)this).transform.position, 2f, (List<VineMountable>)(object)val, 134217728, (QueryTriggerInteraction)2);
			float num = float.MaxValue;
			Transform val2 = null;
			Transform[] vineArrivalPoints = VineArrivalPoints;
			foreach (Transform val3 in vineArrivalPoints)
			{
				Vector3 position = val3.position;
				bool flag = true;
				foreach (VineMountable item in (List<VineMountable>)(object)val)
				{
					if (!item.isClient && !((Object)(object)item == (Object)(object)forMountable) && Vector3.Distance(position, Vector3Ex.WithY(((Component)item).transform.position, position.y)) < 0.1f)
					{
						flag = false;
						break;
					}
				}
				if (flag)
				{
					float num2 = Vector3.Distance(Vector3Ex.WithY(((Component)forMountable).transform.position, position.y), position);
					if (num2 < num)
					{
						num = num2;
						val2 = val3;
					}
				}
			}
			bool num3 = (Object)(object)val2 != (Object)null;
			if (num3)
			{
				worldPos = val2.position;
			}
			return num3;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


public class VineLOD : RendererLOD
{
	public FakePhysicsRope.RenderMode[] renderModesPerLOD;

	public int MaxLodForShadows;
}


using UnityEngine;

public class VineRenderer : FakePhysicsRope
{
	[Header("Swing Settings")]
	public float swingDamp = 5f;

	public float swingStiffness = 20f;
}


using UnityEngine;

public static class VineUtils
{
	public static Vector3 SampleParabola(Vector3 start, Vector3 end, float height, float t, bool useLevelDirection = false)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		float num = t * 2f - 1f;
		if (Mathf.Abs(start.y - end.y) < 0.1f)
		{
			Vector3 val = end - start;
			Vector3 result = start + t * val;
			result.y += ((0f - num) * num + 1f) * height;
			return result;
		}
		Vector3 val2 = end - start;
		Vector3 val3 = end - new Vector3(start.x, end.y, start.z);
		Vector3 val4 = Vector3.Cross(val2, val3);
		Vector3 val5 = ((!useLevelDirection) ? Vector3.Cross(val4, val2) : Vector3.Cross(val4, val3));
		if (end.y > start.y)
		{
			val5 = -val5;
		}
		return start + t * val2 + ((0f - num) * num + 1f) * height * ((Vector3)(ref val5)).normalized;
	}

	public static float FindT(Vector3 start, Vector3 end, float height, Vector3 targetPosition, bool useLevelDirection = false)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		float num = 0.5f;
		float num2 = 0.01f;
		for (num = 0f; num <= 1f; num += num2)
		{
			if (Vector3.Distance(SampleParabola(start, end, height, num, useLevelDirection), targetPosition) < 0.01f)
			{
				return num;
			}
		}
		return -1f;
	}

	public static Vector3 RotateAroundWorldAxis(Vector3 point, Vector3 pivot, Vector3 axis, float angle)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.AngleAxis(angle, axis);
		Vector3 val2 = point - pivot;
		Vector3 val3 = val * val2;
		return pivot + val3;
	}
}


using UnityEngine;

public class VineViewmodel : BaseViewModel
{
	public Transform VineConnectionPoint;
}


using UnityEngine;
using UnityEngine.UI;

public class ShopFrontLootPanel : LootPanel
{
	public Text playerLabelA;

	public Text playerLabelB;

	public GameObject confirmButton;

	public GameObject confirmHelp;

	public GameObject denyButton;

	public GameObject denyHelp;

	public GameObject waitingText;

	public GameObject exchangeInProgressImage;

	public Phrase acceptedPhrase;

	public Phrase noOnePhrase;
}


using UnityEngine;

public class BurstClothCollider : MonoBehaviour, IClientComponent
{
	public float Height;

	public float Radius;

	public void GetParams(out Vector3 pointA, out Vector3 pointB, out Vector3 up, out float halfHeight)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		halfHeight = Height / 2f;
		up = ((Component)this).transform.rotation * Vector3.up;
		pointA = position + up * halfHeight;
		pointB = position - up * halfHeight;
	}
}


using System.Collections.Generic;
using Facepunch.BurstCloth;
using Unity.Mathematics;
using UnityEngine;

public class BurstClothHitBoxCollision : BurstCloth, IClientComponent, IPrefabPreProcess
{
	[Header("Rust Wearable BurstCloth")]
	public bool UseLocalGravity = true;

	public float GravityStrength = 0.8f;

	public float DefaultLength = 1f;

	public float MountedLengthMultiplier;

	public float DuckedLengthMultiplier = 0.5f;

	public float CorpseLengthMultiplier = 0.2f;

	public Transform UpAxis;

	[Header("Collision")]
	public Transform ColliderRoot;

	[Tooltip("Keywords in bone names which should be ignored for collision")]
	public string[] IgnoreKeywords;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	private static void BreakCapsuleIntoSpheres(Transform transform, Vector3 pointA, Vector3 pointB, Vector3 up, float halfHeight, float radius, List<SphereParams> sphereColliders)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pointA - up * radius;
		Vector3 val2 = pointB + up * radius;
		sphereColliders.Add(new SphereParams
		{
			Transform = transform,
			Point = transform.InverseTransformPoint(val),
			Radius = radius
		});
		sphereColliders.Add(new SphereParams
		{
			Transform = transform,
			Point = transform.InverseTransformPoint(val2),
			Radius = radius
		});
		Vector3 val3 = val - up * radius;
		int num = Mathf.CeilToInt(math.max((2f * halfHeight - 4f * radius) / radius, 1f));
		for (int i = 0; i < num; i++)
		{
			sphereColliders.Add(new SphereParams
			{
				Transform = transform,
				Point = transform.InverseTransformPoint(val3 - up * ((float)i * radius)),
				Radius = radius
			});
		}
	}

	protected override void GatherColliders(List<SphereParams> sphereColliders)
	{
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
	}
}


using EZhex1991.EZSoftBone;
using UnityEngine;

public class GhostSheetSystemSpaceUpdater : MonoBehaviour, IClientComponent
{
	private EZSoftBone[] ezSoftBones;

	private BasePlayer player;

	public void Awake()
	{
		ezSoftBones = ((Component)this).GetComponents<EZSoftBone>();
		player = ((Component)this).gameObject.ToBaseEntity() as BasePlayer;
	}

	public void Update()
	{
		if (ezSoftBones == null || ezSoftBones.Length == 0 || (Object)(object)player == (Object)null)
		{
			return;
		}
		BaseMountable mounted = player.GetMounted();
		if ((Object)(object)mounted != (Object)null)
		{
			SetSimulateSpace(((Component)mounted).transform, collisionEnabled: false);
			return;
		}
		BaseEntity parentEntity = player.GetParentEntity();
		if ((Object)(object)parentEntity != (Object)null)
		{
			SetSimulateSpace(((Component)parentEntity).transform, collisionEnabled: true);
		}
		else
		{
			SetSimulateSpace(null, collisionEnabled: true);
		}
	}

	private void SetSimulateSpace(Transform transform, bool collisionEnabled)
	{
		for (int i = 0; i < ezSoftBones.Length; i++)
		{
			EZSoftBone obj = ezSoftBones[i];
			obj.simulateSpace = transform;
			obj.collisionEnabled = collisionEnabled;
		}
	}
}


using UnityEngine;

public class PartyHatMaterialRandomiser : MonoBehaviour, IItemSetup
{
	public Material[] MaterialOptions;

	public Renderer[] TargetRenderers;

	public void OnItemSetup(Item item)
	{
	}

	public void OnSetupSkin(ulong skin, ItemDefinition definition)
	{
	}
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class NVGCamera : FacepunchBehaviour, IClothingChanged
{
	public static NVGCamera instance;

	public PostProcessVolume postProcessVolume;

	public GameObject lights;
}


using UnityStandardAssets.ImageEffects;

public class NVGColorCorrection : ColorCorrectionCurves
{
}


using System;
using UnityEngine;
using UnityStandardAssets.ImageEffects;

[AddComponentMenu("Image Effects/NVG Effect")]
[ExecuteInEditMode]
public class NVGEffect : PostEffectsBase, IImageEffect
{
	[Serializable]
	public struct ColorCorrectionParams
	{
		public float saturation;

		public AnimationCurve redChannel;

		public AnimationCurve greenChannel;

		public AnimationCurve blueChannel;
	}

	[Serializable]
	public struct NoiseAndGrainParams
	{
		public float intensityMultiplier;

		public float generalIntensity;

		public float blackIntensity;

		public float whiteIntensity;

		public float midGrey;

		public bool monochrome;

		public Vector3 intensities;

		public Vector3 tiling;

		public float monochromeTiling;

		public FilterMode filterMode;
	}

	public ColorCorrectionParams ColorCorrection1 = new ColorCorrectionParams
	{
		saturation = 1f,
		redChannel = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		}),
		greenChannel = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		}),
		blueChannel = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		})
	};

	public ColorCorrectionParams ColorCorrection2 = new ColorCorrectionParams
	{
		saturation = 1f,
		redChannel = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		}),
		greenChannel = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		}),
		blueChannel = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		})
	};

	public NoiseAndGrainParams NoiseAndGrain = new NoiseAndGrainParams
	{
		intensityMultiplier = 1.5f,
		generalIntensity = 1f,
		blackIntensity = 1f,
		whiteIntensity = 1f,
		midGrey = 0.182f,
		monochrome = true,
		intensities = new Vector3(1f, 1f, 1f),
		tiling = new Vector3(60f, 70f, 80f),
		monochromeTiling = 55f,
		filterMode = (FilterMode)0
	};

	private Texture2D rgbChannelTex1;

	private Texture2D rgbChannelTex2;

	private bool updateTexturesOnStartup = true;

	public Texture2D NoiseTexture;

	private static float NOISE_TILE_AMOUNT = 64f;

	public Shader Shader;

	private Material material;

	private void Awake()
	{
		updateTexturesOnStartup = true;
	}

	private void OnDestroy()
	{
		if ((Object)(object)rgbChannelTex1 != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)rgbChannelTex1);
			rgbChannelTex1 = null;
		}
		if ((Object)(object)rgbChannelTex2 != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)rgbChannelTex2);
			rgbChannelTex2 = null;
		}
		if ((Object)(object)material != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)material);
			material = null;
		}
	}

	private void UpdateColorCorrectionTexture(ColorCorrectionParams param, ref Texture2D tex)
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		if (param.redChannel != null && param.greenChannel != null && param.blueChannel != null)
		{
			for (float num = 0f; num <= 1f; num += 0.003921569f)
			{
				float num2 = Mathf.Clamp(param.redChannel.Evaluate(num), 0f, 1f);
				float num3 = Mathf.Clamp(param.greenChannel.Evaluate(num), 0f, 1f);
				float num4 = Mathf.Clamp(param.blueChannel.Evaluate(num), 0f, 1f);
				tex.SetPixel((int)Mathf.Floor(num * 255f), 0, new Color(num2, num2, num2));
				tex.SetPixel((int)Mathf.Floor(num * 255f), 1, new Color(num3, num3, num3));
				tex.SetPixel((int)Mathf.Floor(num * 255f), 2, new Color(num4, num4, num4));
			}
			tex.Apply();
		}
	}

	public void UpdateTextures()
	{
		((PostEffectsBase)this).CheckResources();
		UpdateColorCorrectionTexture(ColorCorrection1, ref rgbChannelTex1);
		UpdateColorCorrectionTexture(ColorCorrection2, ref rgbChannelTex2);
	}

	public override bool CheckResources()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Expected O, but got Unknown
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Expected O, but got Unknown
		((PostEffectsBase)this).CheckSupport(false);
		material = ((PostEffectsBase)this).CheckShaderAndCreateMaterial(Shader, material);
		if ((Object)(object)rgbChannelTex1 == (Object)null || (Object)(object)rgbChannelTex2 == (Object)null)
		{
			rgbChannelTex1 = new Texture2D(256, 4, (TextureFormat)5, false, true)
			{
				hideFlags = (HideFlags)52,
				wrapMode = (TextureWrapMode)1
			};
			rgbChannelTex2 = new Texture2D(256, 4, (TextureFormat)5, false, true)
			{
				hideFlags = (HideFlags)52,
				wrapMode = (TextureWrapMode)1
			};
		}
		if (!base.isSupported)
		{
			((PostEffectsBase)this).ReportAutoDisable();
		}
		return base.isSupported;
	}

	public bool IsActive()
	{
		if (((Behaviour)this).enabled && ((PostEffectsBase)this).CheckResources())
		{
			return (Object)(object)NoiseTexture != (Object)null;
		}
		return false;
	}

	public void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		if (!((PostEffectsBase)this).CheckResources())
		{
			Graphics.Blit((Texture)(object)source, destination);
			if ((Object)(object)NoiseTexture == (Object)null)
			{
				Debug.LogWarning((object)"[NVGEffect] Noise & Grain effect failing as noise texture is not assigned. please assign.", (Object)(object)((Component)this).transform);
			}
			return;
		}
		if (updateTexturesOnStartup)
		{
			UpdateTextures();
			updateTexturesOnStartup = false;
		}
		material.SetTexture("_MainTex", (Texture)(object)source);
		material.SetTexture("_RgbTex1", (Texture)(object)rgbChannelTex1);
		material.SetFloat("_Saturation1", ColorCorrection1.saturation);
		material.SetTexture("_RgbTex2", (Texture)(object)rgbChannelTex2);
		material.SetFloat("_Saturation2", ColorCorrection2.saturation);
		material.SetTexture("_NoiseTex", (Texture)(object)NoiseTexture);
		material.SetVector("_NoisePerChannel", Vector4.op_Implicit(NoiseAndGrain.monochrome ? Vector3.one : NoiseAndGrain.intensities));
		material.SetVector("_NoiseTilingPerChannel", Vector4.op_Implicit(NoiseAndGrain.monochrome ? (Vector3.one * NoiseAndGrain.monochromeTiling) : NoiseAndGrain.tiling));
		material.SetVector("_MidGrey", Vector4.op_Implicit(new Vector3(NoiseAndGrain.midGrey, 1f / (1f - NoiseAndGrain.midGrey), -1f / NoiseAndGrain.midGrey)));
		material.SetVector("_NoiseAmount", Vector4.op_Implicit(new Vector3(NoiseAndGrain.generalIntensity, NoiseAndGrain.blackIntensity, NoiseAndGrain.whiteIntensity) * NoiseAndGrain.intensityMultiplier));
		if (Object.op_Implicit((Object)(object)NoiseTexture))
		{
			((Texture)NoiseTexture).wrapMode = (TextureWrapMode)0;
			((Texture)NoiseTexture).filterMode = NoiseAndGrain.filterMode;
		}
		RenderTexture.active = destination;
		float num = (float)((Texture)NoiseTexture).width * 1f;
		float num2 = 1f * (float)((Texture)source).width / NOISE_TILE_AMOUNT;
		GL.PushMatrix();
		GL.LoadOrtho();
		float num3 = 1f * (float)((Texture)source).width / (1f * (float)((Texture)source).height);
		float num4 = 1f / num2;
		float num5 = num4 * num3;
		float num6 = num / ((float)((Texture)NoiseTexture).width * 1f);
		material.SetPass(0);
		GL.Begin(7);
		for (float num7 = 0f; num7 < 1f; num7 += num4)
		{
			for (float num8 = 0f; num8 < 1f; num8 += num5)
			{
				float num9 = Random.Range(0f, 1f);
				float num10 = Random.Range(0f, 1f);
				num9 = Mathf.Floor(num9 * num) / num;
				num10 = Mathf.Floor(num10 * num) / num;
				float num11 = 1f / num;
				GL.MultiTexCoord2(0, num9, num10);
				GL.MultiTexCoord2(1, 0f, 0f);
				GL.Vertex3(num7, num8, 0.1f);
				GL.MultiTexCoord2(0, num9 + num6 * num11, num10);
				GL.MultiTexCoord2(1, 1f, 0f);
				GL.Vertex3(num7 + num4, num8, 0.1f);
				GL.MultiTexCoord2(0, num9 + num6 * num11, num10 + num6 * num11);
				GL.MultiTexCoord2(1, 1f, 1f);
				GL.Vertex3(num7 + num4, num8 + num5, 0.1f);
				GL.MultiTexCoord2(0, num9, num10 + num6 * num11);
				GL.MultiTexCoord2(1, 0f, 1f);
				GL.Vertex3(num7, num8 + num5, 0.1f);
			}
		}
		GL.End();
		GL.PopMatrix();
	}
}


using System;
using UnityEngine;

[Serializable]
public struct ColorCorrectionParams
{
	public float saturation;

	public AnimationCurve redChannel;

	public AnimationCurve greenChannel;

	public AnimationCurve blueChannel;
}


using System;
using UnityEngine;

[Serializable]
public struct NoiseAndGrainParams
{
	public float intensityMultiplier;

	public float generalIntensity;

	public float blackIntensity;

	public float whiteIntensity;

	public float midGrey;

	public bool monochrome;

	public Vector3 intensities;

	public Vector3 tiling;

	public float monochromeTiling;

	public FilterMode filterMode;
}


public class NVGToggle : ItemEventFlag
{
	public SoundPlayer loopSfx;
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class Beehive : StorageContainer, IHeatSourceListener, ISplashable
{
	[Header("Beehive Settings")]
	public ItemDefinition HoneyCombDefinition;

	public ItemDefinition BeeNucleusDefinition;

	public float growthRate = 0.05f;

	public float beeStingTime = 2f;

	[Header("References")]
	public TriggerHurtEx hurtTrigger;

	public GameObjectRef masterSwarm;

	public const Flags HasNucleus = Flags.Reserved12;

	public const Flags HasBees = Flags.Reserved13;

	public const Flags AngryBees = Flags.Reserved14;

	[ServerVar(Help = "How long before a Beehive will update")]
	public static float updateHiveInterval = 120f;

	[ServerVar(Help = "How long before the Beehive will perform temperature and inside checks")]
	public static float updateHiveStatsInterval = 120f;

	[ServerVar(Help = "How much the Nucleus's XP should be increased per honeycomb generated")]
	public static int xpIncreasePerHoneycomb = 2;

	private static Vector3[] outsideLookupDirs;

	private bool hasNucleus;

	private float createNewCombAccumulator;

	private float honeyCombProductionMultiplier = 2f;

	private TimeSince timeSinceAngryBees;

	private TimeCachedValue<float> temperatureExposure;

	private TimeCachedValue<float> humidityExposure;

	private TimeCachedValue<bool> outsideCheck;

	private float serverHumidity;

	private float serverTemperature;

	private bool serverOutside;

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if (HasFlag(Flags.Reserved13) || HasFlag(Flags.Reserved12))
		{
			pickupErrorToFormat = (format: PickupErrors.ItemMustBeEmpty, arg0: pickup.itemTarget.displayName);
			return false;
		}
		return base.CanCompletePickup(player);
	}

	public bool IsOutsideAccurate()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		return SocketMod_Inside.IsOutside(((Component)this).transform.position + Vector3.up * 0.2f, Quaternion.identity, outsideLookupDirs);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (base.isServer && info.fromDisk && info.msg.beehive != null)
		{
			createNewCombAccumulator = info.msg.beehive.currentProgress;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.beehive = Pool.Get<Beehive>();
		info.msg.beehive.currentProgress = createNewCombAccumulator;
		if (!info.forDisk)
		{
			info.msg.beehive.temperature = serverTemperature;
			info.msg.beehive.inside = serverOutside;
			info.msg.beehive.humidity = serverHumidity;
		}
	}

	public override void OnItemRemovedFromStack(Item item, int amount)
	{
		base.OnItemRemovedFromStack(item, amount);
		OnItemAddedOrRemoved(item, added: false);
	}

	public override void OnItemAddedToStack(Item item, int amount)
	{
		base.OnItemAddedToStack(item, amount);
		OnItemAddedOrRemoved(item, added: true);
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		base.OnItemAddedOrRemoved(item, added);
		CheckNucleus();
		float num = base.inventory.GetAmount(HoneyCombDefinition.itemid, onlyUsableAmounts: false);
		SetFlag(Flags.Reserved13, num > 0f && hasNucleus);
		if (!added && (Object)(object)item.info == (Object)(object)HoneyCombDefinition)
		{
			BasePlayer basePlayer = BasePlayer.FindByID(base.LastLootedBy);
			if ((Object)(object)basePlayer != (Object)null && basePlayer.IsAlive() && !basePlayer.IsNpc && basePlayer.isServer)
			{
				timeSinceAngryBees = TimeSince.op_Implicit(0f);
				SetFlag(Flags.Reserved14, b: true);
			}
		}
		if (base.inventory.IsFull(checkForPartialStacks: true))
		{
			StopHive();
		}
	}

	private void OnPhysicsNeighbourChanged()
	{
		TimeWarning val = TimeWarning.New("Beehive.OnPhysicsNeighbourChanged", 0);
		try
		{
			CalculateQualifiers(force: true);
			SendNetworkUpdate();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		if (!base.isClient)
		{
			CheckNucleus();
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		CalculateQualifiers(force: true);
		CheckNucleus();
		((FacepunchBehaviour)this).InvokeRepeating((Action)HiveUpdateTick, 0f, 1f);
	}

	public void OnHeatSourceChanged()
	{
		CalculateQualifiers(force: true);
		SendNetworkUpdate();
	}

	private void HiveUpdateTick()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		if (TimeSince.op_Implicit(timeSinceAngryBees) > beeStingTime)
		{
			SetFlag(Flags.Reserved14, b: false);
		}
	}

	private void GenerateHoneyComb()
	{
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		float num = base.inventory.GetAmount(HoneyCombDefinition.itemid, onlyUsableAmounts: false);
		SetFlag(Flags.Reserved13, num > 0f && hasNucleus);
		createNewCombAccumulator += growthRate * honeyCombProductionMultiplier;
		if (!(createNewCombAccumulator >= 1f))
		{
			return;
		}
		createNewCombAccumulator = 0f;
		if (hasNucleus)
		{
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				int dataInt = slot.instanceData.dataInt;
				if (NucleusGrading.XpToGrade(dataInt) != NucleusGrading.NucleusGrade.Grade1)
				{
					dataInt += xpIncreasePerHoneycomb;
					SetNucleusData(slot, dataInt);
				}
			}
		}
		Item item = ItemManager.Create(HoneyCombDefinition, 1, 0uL);
		if (!item.MoveToContainer(base.inventory))
		{
			StopHive();
			item.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
		}
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if (targetSlot == 0)
		{
			return item.info.shortname.Equals(allowedItem.shortname);
		}
		if (targetSlot > 0)
		{
			return item.info.shortname.Equals(allowedItem2.shortname);
		}
		return base.ItemFilter(item, targetSlot);
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		return (Object)(object)splashType == (Object)(object)WaterTypes.RadioactiveWaterItemDef;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		if ((Object)(object)splashType == (Object)(object)WaterTypes.RadioactiveWaterItemDef)
		{
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				hasNucleus = (Object)(object)((Component)slot.info).GetComponent<ItemModBeehiveNucleus>() != (Object)null;
				if (hasNucleus)
				{
					base.inventory.Remove(slot);
					slot.Remove();
				}
			}
			return amount;
		}
		return amount;
	}

	private void SetNucleusData(Item targetItem, int xp)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Expected O, but got Unknown
		if (targetItem != null)
		{
			targetItem.instanceData = new InstanceData
			{
				ShouldPool = false,
				dataInt = xp
			};
		}
	}

	private void CheckNucleus()
	{
		if (base.inventory == null)
		{
			return;
		}
		Item slot = base.inventory.GetSlot(0);
		if (slot != null)
		{
			hasNucleus = (Object)(object)((Component)slot.info).GetComponent<ItemModBeehiveNucleus>() != (Object)null;
			if (slot == null || slot.instanceData == null || (slot.instanceData.dataInt == 0 && slot.instanceData.dataFloat == 0f))
			{
				SetNucleusData(slot, 0);
			}
			createNewCombAccumulator = 0f;
		}
		else
		{
			hasNucleus = false;
		}
		SetFlag(Flags.Reserved12, hasNucleus);
		if (hasNucleus)
		{
			StartHive();
		}
		else
		{
			StopHive();
		}
	}

	private void StartHive()
	{
		if (!((FacepunchBehaviour)this).IsInvoking((Action)UpdateGrowthRate))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateGrowthRate, 0f, updateHiveInterval);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)GenerateHoneyComb))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)GenerateHoneyComb, updateHiveInterval, updateHiveInterval);
		}
		SetFlag(Flags.On, b: true);
		CalculateQualifiers(force: true);
		SendNetworkUpdate();
	}

	private void StopHive()
	{
		if (((FacepunchBehaviour)this).IsInvoking((Action)UpdateGrowthRate))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)UpdateGrowthRate);
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)GenerateHoneyComb))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)GenerateHoneyComb);
		}
		SetFlag(Flags.On, b: false);
		SendNetworkUpdate();
	}

	public float CalculateRain()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			SingletonComponent<NpcFireManager>.Instance.GetFiresAround(((Component)this).transform.position, 2f, (List<BaseEntity>)(object)val);
			if (((List<BaseEntity>)(object)val).Count > 0)
			{
				return 0f;
			}
			if (!IsOutside())
			{
				return 0f;
			}
			return Climate.GetRain(((Component)this).transform.position);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public float CalculateTemperature()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		float temperature = Climate.GetTemperature(((Component)this).transform.position);
		float num = GrowableEntity.CalculateArtificialTemperature(((Component)this).transform);
		bool flag = num >= 10f;
		bool flag2 = temperature < 10f;
		bool flag3 = temperature < 16f && !flag2;
		if (flag)
		{
			if (flag3)
			{
				return 20f;
			}
			if (flag2)
			{
				return 16f;
			}
		}
		return temperature + num;
	}

	private void CalculateQualifiers(bool force = false)
	{
		TimeWarning val = TimeWarning.New("Beehive.CalculateQualifiers", 0);
		try
		{
			if (temperatureExposure == null)
			{
				temperatureExposure = new TimeCachedValue<float>
				{
					refreshCooldown = updateHiveStatsInterval,
					refreshRandomRange = 5f,
					updateValue = CalculateTemperature
				};
			}
			if (outsideCheck == null)
			{
				outsideCheck = new TimeCachedValue<bool>
				{
					refreshCooldown = updateHiveStatsInterval,
					refreshRandomRange = 5f,
					updateValue = IsOutsideAccurate
				};
			}
			if (humidityExposure == null)
			{
				humidityExposure = new TimeCachedValue<float>
				{
					refreshCooldown = updateHiveStatsInterval,
					refreshRandomRange = 5f,
					updateValue = CalculateRain
				};
			}
			serverHumidity = humidityExposure.Get(force);
			serverTemperature = temperatureExposure.Get(force);
			serverOutside = outsideCheck.Get(force);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void UpdateGrowthRate()
	{
		TimeWarning val = TimeWarning.New("Beehive.UpdateGrowthRate", 0);
		try
		{
			CalculateQualifiers();
			float num = serverTemperature;
			float num2 = ((num < 28f) ? ((num < 10f) ? 0.010000001f : ((!(num < 16f)) ? 0.1f : 0.05f)) : ((!(num < 40f)) ? 0.010000001f : 0.05f));
			growthRate = num2;
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				switch (NucleusGrading.XpToGrade(slot.instanceData.dataInt))
				{
				case NucleusGrading.NucleusGrade.Grade2:
					growthRate *= 2f;
					break;
				case NucleusGrading.NucleusGrade.Grade1:
					growthRate *= 3f;
					break;
				}
			}
			if (serverHumidity >= 0.5f)
			{
				growthRate *= 0.5f;
			}
			if (!serverOutside)
			{
				growthRate = 0f;
			}
			SendNetworkUpdate();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void DropItems(BaseEntity initiator = null)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		int index = -1;
		for (int i = 0; i < base.inventory.itemList.Count; i++)
		{
			if ((Object)(object)base.inventory.itemList[i].info == (Object)(object)BeeNucleusDefinition)
			{
				flag = true;
				index = i;
			}
		}
		if (flag && base.inventory.Remove(base.inventory.itemList[index]))
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(masterSwarm.resourcePath, ((Component)this).transform.position + Vector3.up * 1.5f, Quaternion.identity);
			if (creatorEntity is BasePlayer basePlayer)
			{
				baseEntity.creatorEntity = basePlayer;
				baseEntity.OwnerID = basePlayer.userID;
			}
			baseEntity.Spawn();
		}
		base.DropItems(initiator);
	}

	static Beehive()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = new Vector3[5];
		Vector3 val = new Vector3(0f, 1f, 0f);
		array[0] = ((Vector3)(ref val)).normalized;
		val = new Vector3(1f, 0f, 0f);
		array[1] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 0f, 1f);
		array[2] = ((Vector3)(ref val)).normalized;
		val = new Vector3(-1f, 0f, 0f);
		array[3] = ((Vector3)(ref val)).normalized;
		val = new Vector3(0f, 0f, -1f);
		array[4] = ((Vector3)(ref val)).normalized;
		outsideLookupDirs = (Vector3[])(object)array;
	}
}


using UnityEngine;

public class BeehiveLootPanel : LootPanel
{
	[Header("Info Bars")]
	public InfoBar Indoors;

	public InfoBar Humidity;

	public InfoBar Temperature;

	public InfoBar Overall;

	[Header("Grids")]
	public LootGrid LootGrid_Input;

	public LootGrid LootGrid_Output;

	[Header("Status")]
	public StatusPanel status;

	public static readonly Phrase YesIndoors = new Phrase("beehive.indoors.yes", "YES");

	public static readonly Phrase NoIndoors = new Phrase("beehive.indoors.no", "NO");
}


using UnityEngine;

public class IdentifierConfig : IOConfig<IRemoteControllable>
{
	[HideInInspector]
	public string id;
}


using System;

[Flags]
public enum RemoteControllableControls
{
	None = 0,
	Movement = 1,
	Mouse = 2,
	SprintAndDuck = 4,
	Fire = 8,
	Reload = 0x10,
	Crosshair = 0x20
}


using UnityEngine;

public interface IRemoteControllable
{
	bool RequiresMouse { get; }

	float MaxRange { get; }

	RemoteControllableControls RequiredControls { get; }

	CameraViewerId? ControllingViewerId { get; }

	bool CanPing { get; }

	Transform GetEyes();

	float GetFovScale();

	BaseEntity GetEnt();

	string GetIdentifier();

	float Health();

	float MaxHealth();

	void UpdateIdentifier(string newID, bool clientSend = false);

	void RCSetup();

	void RCShutdown();

	bool CanControl(ulong playerID);

	void UserInput(InputState inputState, CameraViewerId viewerID);

	bool InitializeControl(CameraViewerId viewerID);

	void StopControl(CameraViewerId viewerID);
}


using System;

public struct CameraViewerId : IEquatable<CameraViewerId>
{
	public readonly ulong SteamId;

	public readonly long ConnectionId;

	public CameraViewerId(ulong steamId, long connectionId)
	{
		SteamId = steamId;
		ConnectionId = connectionId;
	}

	public bool Equals(CameraViewerId other)
	{
		if (SteamId == other.SteamId)
		{
			return ConnectionId == other.ConnectionId;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is CameraViewerId other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		ulong steamId = SteamId;
		int num = steamId.GetHashCode() * 397;
		long connectionId = ConnectionId;
		return num ^ connectionId.GetHashCode();
	}

	public static bool operator ==(CameraViewerId left, CameraViewerId right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(CameraViewerId left, CameraViewerId right)
	{
		return !left.Equals(right);
	}
}


public class ClanTable : BaseCombatEntity
{
}


using System;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class Composter : StorageContainer
{
	[Header("Composter")]
	public ItemDefinition FertilizerDef;

	[Tooltip("If enabled, entire item stacks will be composted each tick, instead of a single item of a stack.")]
	public bool CompostEntireStack;

	public float fertilizerProductionProgress;

	protected float UpdateInterval => Server.composterUpdateInterval;

	public override void ServerInit()
	{
		base.ServerInit();
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(InventoryItemFilter));
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateComposting, UpdateInterval, UpdateInterval, UpdateInterval * 0.1f);
	}

	public bool InventoryItemFilter(Item item, int targetSlot)
	{
		if (item == null)
		{
			return false;
		}
		if ((Object)(object)((Component)item.info).GetComponent<ItemModCompostable>() != (Object)null || ItemIsFertilizer(item))
		{
			return true;
		}
		return false;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.composter = Pool.Get<Composter>();
		info.msg.composter.fertilizerProductionProgress = fertilizerProductionProgress;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.composter != null)
		{
			fertilizerProductionProgress = info.msg.composter.fertilizerProductionProgress;
		}
	}

	public bool ItemIsFertilizer(Item item)
	{
		return item.info.shortname == "fertilizer";
	}

	public void UpdateComposting()
	{
		if (Interface.CallHook("OnComposterUpdate", (object)this) != null)
		{
			return;
		}
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null)
			{
				CompostItem(slot);
			}
		}
	}

	public void CompostItem(Item item)
	{
		if (!ItemIsFertilizer(item))
		{
			ItemModCompostable component = ((Component)item.info).GetComponent<ItemModCompostable>();
			if (!((Object)(object)component == (Object)null))
			{
				int num = ((!CompostEntireStack) ? 1 : item.amount);
				item.UseItem(num);
				fertilizerProductionProgress += (float)num * component.TotalFertilizerProduced;
				ProduceFertilizer(Mathf.FloorToInt(fertilizerProductionProgress));
			}
		}
	}

	public void ProduceFertilizer(int amount)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (amount > 0)
		{
			Item item = ItemManager.Create(FertilizerDef, amount, 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				item.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
			}
			fertilizerProductionProgress -= amount;
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class ComputerMenu : UIDialog
{
	public RectTransform bookmarkContainer;

	public GameObject bookmarkPrefab;

	public List<RCBookmarkEntry> activeEntries = new List<RCBookmarkEntry>();
}


using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class RCBookmarkEntry : MonoBehaviour
{
	private ComputerMenu owner;

	public RectTransform connectButton;

	public RectTransform disconnectButton;

	public RawImage onlineIndicator;

	public RawImage offlineIndicator;

	public GameObject selectedindicator;

	public Image backgroundImage;

	public Color selectedColor;

	public Color activeColor;

	public Color inactiveColor;

	public Text nameLabel;

	public EventTrigger eventTrigger;

	public string identifier { get; private set; }

	public bool isSelected { get; private set; }

	public bool isControlling { get; private set; }
}


public interface IRemoteControllableClientCallbacks : IRemoteControllable
{
}


using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.UI;

public class RCMenu : ComputerMenu
{
	public Image backgroundOpaque;

	public InputField newBookmarkEntryField;

	public NeedsCursor needsCursor;

	public float hiddenOffset = -256f;

	public RectTransform devicesPanel;

	private Vector3 initialDevicesPosition;

	public static bool isControllingCamera;

	public CanvasGroup overExposure;

	public CanvasGroup interference;

	public float interferenceFadeDuration = 0.2f;

	public float rangeInterferenceScale = 10000f;

	public Text timeText;

	public Text watchedDurationText;

	public Text deviceNameText;

	public Text noSignalText;

	public Text healthText;

	public GameObject healthBarParent;

	public RectTransform healthBarBackground;

	public RectTransform healthBarFill;

	public SoundDefinition bookmarkPressedSoundDef;

	public GameObject[] hideIfStatic;

	public GameObject readOnlyIndicator;

	[FormerlySerializedAs("crosshair")]
	public GameObject aimCrosshair;

	public GameObject generalCrosshair;

	public float fogOverrideDensity = 0.1f;

	public float autoTurretFogDistance = 30f;

	public float autoTurretDotBaseScale = 2f;

	public float autoTurretDotGrowScale = 4f;

	public PingManager PingManager;

	public ScrollRectSettable scrollRect;

	public Phrase Phrase_NoSignal = new Phrase("no_signal", "No Signal");

	public Phrase Phrase_CameraDisabled = new Phrase("weak_signal", "Weak Signal");
}


using Rust;
using UnityEngine;

public class CookingWorkbench : MixingTable
{
	public GameObjectRef SubOvenPrefab;

	public Transform SubOvenPosition;

	[Tooltip("The recipes that will set the OvenCooking flag (to play the oven effects)")]
	public ItemDefinition[] ovenCookingFlagItems;

	public const Flags OvenCooking = Flags.Reserved9;

	public const Flags MixingTea = Flags.Reserved10;

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!base.isServer || next.HasFlag(Flags.On) == old.HasFlag(Flags.On))
		{
			return;
		}
		string text = (((Object)(object)currentRecipe != (Object)null) ? currentRecipe.ProducedItem.shortname : currentProductionItem?.shortname);
		if (string.IsNullOrEmpty(text))
		{
			return;
		}
		bool flag = GetChildBbq().IsOn();
		ItemDefinition[] array = ovenCookingFlagItems;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].shortname == text)
			{
				SetFlag(Flags.Reserved9, next.HasFlag(Flags.On) || flag);
				return;
			}
		}
		SetFlag(Flags.Reserved10, next.HasFlag(Flags.On));
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		SpawnOven();
	}

	private void SpawnOven()
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)GetChildBbq() != (Object)null) && SubOvenPrefab.isValid)
		{
			BaseEntity baseEntity = base.gameManager.CreateEntity(SubOvenPrefab.resourcePath, SubOvenPosition.position, SubOvenPosition.rotation);
			baseEntity.SetParent(this, worldPositionStays: true);
			((Component)baseEntity).transform.localPosition = SubOvenPosition.localPosition;
			((Component)baseEntity).transform.localRotation = SubOvenPosition.localRotation;
			baseEntity.Spawn();
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			SpawnOven();
		}
	}

	private CookingWorkbenchBbq GetChildBbq()
	{
		foreach (BaseEntity child in children)
		{
			if (child is CookingWorkbenchBbq result)
			{
				return result;
			}
		}
		return null;
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		CookingWorkbenchBbq childBbq = GetChildBbq();
		if ((Object)(object)childBbq != (Object)null && childBbq.inventory != null && !childBbq.inventory.IsEmpty())
		{
			pickupErrorToFormat = (format: PickupErrors.ItemInventoryMustBeEmpty, arg0: pickup.itemTarget.displayName);
			return false;
		}
		return base.CanCompletePickup(player);
	}

	internal override void DoServerDestroy()
	{
		CookingWorkbenchBbq childBbq = GetChildBbq();
		if ((Object)(object)childBbq != (Object)null)
		{
			childBbq.DropItems();
			childBbq.Kill();
		}
		base.DoServerDestroy();
	}
}


using UnityEngine;

public class CookingWorkbenchBbq : BaseOven
{
	private CookingWorkbench ParentBench
	{
		get
		{
			if (!parentEntity.IsValid(base.isServer))
			{
				return null;
			}
			return parentEntity.Get(base.isServer) as CookingWorkbench;
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		if ((Object)(object)ParentBench != (Object)null && base.isServer)
		{
			ParentBench.Hurt(info);
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer && next.HasFlag(Flags.On) != old.HasFlag(Flags.On))
		{
			CookingWorkbench parentBench = ParentBench;
			if ((Object)(object)parentBench != (Object)null)
			{
				bool b = (parentBench.IsOn() ? parentBench.IsOn() : next.HasFlag(Flags.On));
				parentBench.SetFlag(Flags.Reserved9, b);
			}
		}
	}

	public override void AdminKill()
	{
		BaseEntity baseEntity = GetParentEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			baseEntity.AdminKill();
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;

public class Drone : RemoteControlEntity, IRemoteControllableClientCallbacks, IRemoteControllable
{
	public struct DroneInputState
	{
		public Vector3 movement;

		public float throttle;

		public float pitch;

		public float yaw;

		public void Reset()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			movement = Vector3.zero;
			pitch = 0f;
			yaw = 0f;
		}
	}

	[ReplicatedVar(Help = "How far drones can be flown away from the controlling computer station", ShowInAdminUI = true, Default = "600")]
	public static float maxControlRange = 750f;

	[ServerVar(Help = "If greater than zero, overrides the drone's planar movement speed")]
	public static float movementSpeedOverride = 0f;

	[ServerVar(Help = "If greater than zero, overrides the drone's vertical movement speed")]
	public static float altitudeSpeedOverride = 0f;

	[ClientVar(ClientAdmin = true)]
	public static float windTimeDivisor = 10f;

	[ClientVar(ClientAdmin = true)]
	public static float windPositionDivisor = 100f;

	[ClientVar(ClientAdmin = true)]
	public static float windPositionScale = 1f;

	[ClientVar(ClientAdmin = true)]
	public static float windRotationMultiplier = 45f;

	[ClientVar(ClientAdmin = true)]
	public static float windLerpSpeed = 0.1f;

	public const Flags Flag_ThrottleUp = Flags.Reserved1;

	public const Flags Flag_Flying = Flags.Reserved2;

	[Header("Drone")]
	public Rigidbody body;

	public Transform modelRoot;

	public bool killInWater = true;

	public bool killInTerrain = true;

	public bool enableGrounding = true;

	public bool keepAboveTerrain = true;

	public float groundTraceDist = 0.1f;

	public float groundCheckInterval = 0.05f;

	public float altitudeAcceleration = 10f;

	public float movementAcceleration = 10f;

	public float yawSpeed = 2f;

	public float uprightSpeed = 2f;

	public float uprightPrediction = 0.15f;

	public float uprightDot = 0.5f;

	public float leanWeight = 0.1f;

	public float leanMaxVelocity = 5f;

	public float hurtVelocityThreshold = 3f;

	public float hurtDamagePower = 3f;

	public float collisionDisableTime = 0.25f;

	public float pitchMin = -60f;

	public float pitchMax = 60f;

	public float pitchSensitivity = -5f;

	public bool disableWhenHurt;

	[Range(0f, 1f)]
	public float disableWhenHurtChance = 0.25f;

	public float playerCheckInterval = 0.1f;

	public float playerCheckRadius;

	public float deployYOffset = 0.1f;

	[Header("Sound")]
	public SoundDefinition movementLoopSoundDef;

	public SoundDefinition movementStartSoundDef;

	public SoundDefinition movementStopSoundDef;

	public AnimationCurve movementLoopPitchCurve;

	public float movementSpeedReference = 50f;

	[Header("Animation")]
	public float propellerMaxSpeed = 1000f;

	public float propellerAcceleration = 3f;

	public Transform propellerA;

	public Transform propellerB;

	public Transform propellerC;

	public Transform propellerD;

	public float pitch;

	public Vector3? targetPosition;

	public DroneInputState currentInput;

	public float lastInputTime;

	public double lastCollision = -1000.0;

	public TimeSince lastGroundCheck;

	public bool isGrounded;

	public RealTimeSinceEx lastPlayerCheck;

	public override bool RequiresMouse => true;

	public override float MaxRange => maxControlRange;

	public override bool CanAcceptInput => true;

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	public override void Spawn()
	{
		base.Spawn();
		isGrounded = true;
	}

	public override void StopControl(CameraViewerId viewerID)
	{
		CameraViewerId? controllingViewerId = base.ControllingViewerId;
		if (viewerID == controllingViewerId)
		{
			SetFlag(Flags.Reserved1, b: false, recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
			pitch = 0f;
			SendNetworkUpdate();
		}
		base.StopControl(viewerID);
	}

	public override void UserInput(InputState inputState, CameraViewerId viewerID)
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		CameraViewerId? controllingViewerId = base.ControllingViewerId;
		if (!(viewerID != controllingViewerId))
		{
			currentInput.Reset();
			int num = (inputState.IsDown(BUTTON.FORWARD) ? 1 : 0) + (inputState.IsDown(BUTTON.BACKWARD) ? (-1) : 0);
			int num2 = (inputState.IsDown(BUTTON.RIGHT) ? 1 : 0) + (inputState.IsDown(BUTTON.LEFT) ? (-1) : 0);
			ref DroneInputState reference = ref currentInput;
			Vector3 val = new Vector3((float)num2, 0f, (float)num);
			reference.movement = ((Vector3)(ref val)).normalized;
			currentInput.throttle = (inputState.IsDown(BUTTON.SPRINT) ? 1 : 0) + (inputState.IsDown(BUTTON.DUCK) ? (-1) : 0);
			currentInput.yaw = inputState.current.mouseDelta.x;
			currentInput.pitch = inputState.current.mouseDelta.y;
			lastInputTime = Time.time;
			bool flag = false;
			bool flag2 = false;
			bool flag3 = currentInput.throttle > 0f;
			if (flag3 != HasFlag(Flags.Reserved1))
			{
				SetFlag(Flags.Reserved1, flag3, recursive: false, networkupdate: false);
				flag = true;
			}
			float num3 = pitch;
			pitch += currentInput.pitch * pitchSensitivity;
			pitch = Mathf.Clamp(pitch, pitchMin, pitchMax);
			if (!Mathf.Approximately(pitch, num3))
			{
				flag2 = true;
			}
			if (flag2)
			{
				SendNetworkUpdateImmediate();
			}
			else if (flag)
			{
				SendNetworkUpdate_Flags();
			}
		}
	}

	public virtual void Update_Server()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isServer || IsDead() || base.IsBeingControlled || !targetPosition.HasValue)
		{
			return;
		}
		Vector3 position = ((Component)this).transform.position;
		float height = TerrainMeta.HeightMap.GetHeight(position);
		Vector3 val = targetPosition.Value - body.velocity * 0.5f;
		if (keepAboveTerrain)
		{
			val.y = Mathf.Max(val.y, height + 1f);
		}
		Vector2 val2 = Vector3Ex.XZ2D(val);
		Vector2 val3 = Vector3Ex.XZ2D(position);
		Vector3 val4 = default(Vector3);
		float num = default(float);
		Vector3Ex.ToDirectionAndMagnitude(Vector3Ex.XZ3D(val2 - val3), ref val4, ref num);
		currentInput.Reset();
		lastInputTime = Time.time;
		if (position.y - height > 1f)
		{
			float num2 = Mathf.Clamp01(num);
			currentInput.movement = ((Component)this).transform.InverseTransformVector(val4) * num2;
			if (num > 0.5f)
			{
				Quaternion val5 = ((Component)this).transform.rotation;
				float y = ((Quaternion)(ref val5)).eulerAngles.y;
				val5 = Quaternion.FromToRotation(Vector3.forward, val4);
				float y2 = ((Quaternion)(ref val5)).eulerAngles.y;
				currentInput.yaw = Mathf.Clamp(Mathf.LerpAngle(y, y2, Time.deltaTime) - y, -2f, 2f);
			}
		}
		currentInput.throttle = Mathf.Clamp(val.y - position.y, -1f, 1f);
	}

	public void FixedUpdate()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0395: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03be: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_030d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_032b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		//IL_0334: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0340: Unknown result type (might be due to invalid IL or missing references)
		//IL_0348: Unknown result type (might be due to invalid IL or missing references)
		//IL_034c: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isServer || IsDead())
		{
			return;
		}
		if (killInTerrain && AntiHack.TestInsideTerrain(((Component)this).transform.position))
		{
			Kill();
			return;
		}
		if (killInWater)
		{
			float num = WaterFactor();
			if (num > 0f)
			{
				if (num > 0.99f)
				{
					Kill();
				}
				return;
			}
		}
		if ((!base.IsBeingControlled && !targetPosition.HasValue) || (isGrounded && currentInput.throttle <= 0f))
		{
			if (HasFlag(Flags.Reserved2))
			{
				SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
				SendNetworkUpdate_Flags();
			}
			return;
		}
		if (playerCheckRadius > 0f && (double)lastPlayerCheck > (double)playerCheckInterval)
		{
			lastPlayerCheck = 0.0;
			List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
			Vis.Entities(((Component)this).transform.position, playerCheckRadius, list, 131072, (QueryTriggerInteraction)2);
			if (list.Count > 0)
			{
				lastCollision = TimeEx.currentTimestamp;
			}
			Pool.FreeUnmanaged<BasePlayer>(ref list);
		}
		double currentTimestamp = TimeEx.currentTimestamp;
		bool num2 = lastCollision > 0.0 && currentTimestamp - lastCollision < (double)collisionDisableTime;
		if (enableGrounding)
		{
			if (TimeSince.op_Implicit(lastGroundCheck) >= groundCheckInterval)
			{
				lastGroundCheck = TimeSince.op_Implicit(0f);
				RaycastHit val = default(RaycastHit);
				bool flag = body.SweepTest(Vector3.down, ref val, groundTraceDist, (QueryTriggerInteraction)1);
				if (!flag && isGrounded)
				{
					lastPlayerCheck = playerCheckInterval;
				}
				isGrounded = flag;
			}
		}
		else
		{
			isGrounded = false;
		}
		Vector3 val2 = ((Component)this).transform.TransformDirection(currentInput.movement);
		Vector3 val3 = default(Vector3);
		float num3 = default(float);
		Vector3Ex.ToDirectionAndMagnitude(Vector3Ex.WithY(body.velocity, 0f), ref val3, ref num3);
		float num4 = Mathf.Clamp01(num3 / leanMaxVelocity);
		Vector3 val4 = (Mathf.Approximately(((Vector3)(ref val2)).sqrMagnitude, 0f) ? ((0f - num4) * val3) : val2);
		Vector3 val5 = Vector3.up + val4 * leanWeight * num4;
		Vector3 normalized = ((Vector3)(ref val5)).normalized;
		Vector3 up = ((Component)this).transform.up;
		float num5 = Mathf.Max(Vector3.Dot(normalized, up), 0f);
		if (!num2 || isGrounded)
		{
			Vector3 val6 = ((isGrounded && currentInput.throttle <= 0f) ? Vector3.zero : (-1f * ((Component)this).transform.up * Physics.gravity.y));
			Vector3 val7 = (isGrounded ? Vector3.zero : (val2 * ((movementSpeedOverride > 0f) ? movementSpeedOverride : movementAcceleration)));
			Vector3 val8 = ((Component)this).transform.up * currentInput.throttle * ((altitudeSpeedOverride > 0f) ? altitudeSpeedOverride : altitudeAcceleration);
			Vector3 val9 = val6 + val7 + val8;
			body.AddForce(val9 * num5, (ForceMode)5);
		}
		if (!num2 && !isGrounded)
		{
			Vector3 val10 = ((Component)this).transform.TransformVector(0f, currentInput.yaw * yawSpeed, 0f);
			Vector3 val11 = Vector3.Cross(Quaternion.Euler(body.angularVelocity * uprightPrediction) * up, normalized) * uprightSpeed;
			float num6 = ((num5 < uprightDot) ? 0f : num5);
			Vector3 val12 = val10 * num5 + val11 * num6;
			body.AddTorque(val12 * num5, (ForceMode)5);
		}
		bool flag2 = !num2;
		if (flag2 != HasFlag(Flags.Reserved2))
		{
			SetFlag(Flags.Reserved2, flag2, recursive: false, networkupdate: false);
			SendNetworkUpdate_Flags();
		}
	}

	public void OnCollisionEnter(Collision collision)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			lastCollision = TimeEx.currentTimestamp;
			Vector3 relativeVelocity = collision.relativeVelocity;
			float magnitude = ((Vector3)(ref relativeVelocity)).magnitude;
			if (magnitude > hurtVelocityThreshold)
			{
				Hurt(Mathf.Pow(magnitude, hurtDamagePower), DamageType.Fall, null, useProtection: false);
			}
		}
	}

	public void OnCollisionStay()
	{
		if (base.isServer)
		{
			lastCollision = TimeEx.currentTimestamp;
		}
	}

	public override void Hurt(HitInfo info)
	{
		base.Hurt(info);
		if (base.isServer && disableWhenHurt && info.damageTypes.GetMajorityDamageType() != DamageType.Fall && Random.value < disableWhenHurtChance)
		{
			lastCollision = TimeEx.currentTimestamp;
		}
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override Vector3 GetLocalVelocityServer()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)body == (Object)null)
		{
			return Vector3.zero;
		}
		return body.velocity;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk)
		{
			info.msg.drone = Pool.Get<Drone>();
			info.msg.drone.pitch = pitch;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.drone != null)
		{
			pitch = info.msg.drone.pitch;
		}
	}

	public virtual void Update()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		Update_Server();
		if (HasFlag(Flags.Reserved2))
		{
			Quaternion localRotation = viewEyes.localRotation;
			Vector3 eulerAngles = ((Quaternion)(ref localRotation)).eulerAngles;
			eulerAngles.x = Mathf.LerpAngle(eulerAngles.x, pitch, 0.1f);
			viewEyes.localRotation = Quaternion.Euler(eulerAngles);
		}
	}

	public override bool CanChangeID(BasePlayer player)
	{
		if ((Object)(object)player != (Object)null && base.OwnerID == (ulong)player.userID)
		{
			return !HasFlag(Flags.Reserved2);
		}
		return false;
	}

	protected override bool ShouldDisplayPickupOption(BasePlayer player)
	{
		if (!HasFlag(Flags.Reserved2))
		{
			return base.ShouldDisplayPickupOption(player);
		}
		return false;
	}

	public override void OnPickedUpPreItemMove(Item createdItem, BasePlayer player)
	{
		base.OnPickedUpPreItemMove(createdItem, player);
		if ((Object)(object)player != (Object)null && (ulong)player.userID == base.OwnerID)
		{
			createdItem.text = GetIdentifier();
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		base.OnDeployed(parent, deployedBy, fromItem);
		Transform transform = ((Component)this).transform;
		transform.position += ((Component)this).transform.up * deployYOffset;
		if ((Object)(object)body != (Object)null)
		{
			body.velocity = Vector3.zero;
			body.angularVelocity = Vector3.zero;
		}
		if (fromItem != null && !string.IsNullOrEmpty(fromItem.text) && ComputerStation.IsValidIdentifier(fromItem.text))
		{
			UpdateIdentifier(fromItem.text);
		}
	}

	public override bool ShouldNetworkOwnerInfo()
	{
		return true;
	}

	public override bool ShouldInheritNetworkGroup()
	{
		return false;
	}

	public override float MaxVelocity()
	{
		return 30f;
	}
}


using UnityEngine;

public struct DroneInputState
{
	public Vector3 movement;

	public float throttle;

	public float pitch;

	public float yaw;

	public void Reset()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		movement = Vector3.zero;
		pitch = 0f;
		yaw = 0f;
	}
}


using UnityEngine;

public class DropBox : Mailbox
{
	public Transform EyePoint;

	public override bool PlayerIsOwner(BasePlayer player)
	{
		return PlayerBehind(player);
	}

	public bool PlayerBehind(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 val = ((Component)player).transform.position - ((Component)this).transform.position;
		if (Vector3.Dot(forward, ((Vector3)(ref val)).normalized) <= -0.3f)
		{
			return GamePhysics.LineOfSight(player.eyes.position, EyePoint.position, 2162688);
		}
		return false;
	}

	public bool PlayerInfront(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 val = ((Component)player).transform.position - ((Component)this).transform.position;
		return Vector3.Dot(forward, ((Vector3)(ref val)).normalized) >= 0.7f;
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}
}


using System;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class Elevator : IOEntity, IFlagNotify
{
	public enum Direction
	{
		Up,
		Down
	}

	public Transform LiftRoot;

	public GameObjectRef LiftEntityPrefab;

	public GameObjectRef IoEntityPrefab;

	public Transform IoEntitySpawnPoint;

	public GameObject FloorBlockerVolume;

	public float LiftSpeedPerMetre = 1f;

	public GameObject[] PoweredObjects;

	public MeshRenderer PoweredMesh;

	[ColorUsage(true, true)]
	public Color PoweredLightColour;

	[ColorUsage(true, true)]
	public Color UnpoweredLightColour;

	public float LiftMoveDelay;

	protected const Flags TopFloorFlag = Flags.Reserved1;

	public const Flags ElevatorPowered = Flags.Reserved2;

	public EntityRef<ElevatorLift> liftEntity;

	public IOEntity ioEntity;

	public int[] previousPowerAmount = new int[2];

	public virtual bool IsStatic => false;

	public int Floor { get; set; }

	public bool IsTop => HasFlag(Flags.Reserved1);

	public virtual float FloorHeight => 3f;

	public override void Load(LoadInfo info)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.elevator != null)
		{
			Floor = info.msg.elevator.floor;
			liftEntity.uid = info.msg.elevator.spawnedLift;
		}
		if ((Object)(object)FloorBlockerVolume != (Object)null)
		{
			FloorBlockerVolume.SetActive(Floor > 0);
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		Elevator elevatorInDirection = GetElevatorInDirection(Direction.Down);
		if ((Object)(object)elevatorInDirection != (Object)null)
		{
			elevatorInDirection.SetFlag(Flags.Reserved1, b: false);
			Floor = elevatorInDirection.Floor + 1;
		}
		SetFlag(Flags.Reserved1, b: true);
		UpdateChildEntities(isTop: true);
		SendNetworkUpdate();
	}

	public virtual void CallElevator()
	{
		EntityLinkBroadcast(delegate(Elevator elevatorEnt)
		{
			if (elevatorEnt.IsTop && Interface.CallHook("OnElevatorCall", (object)this, (object)elevatorEnt) == null)
			{
				elevatorEnt.RequestMoveLiftTo(Floor, out var _, this);
			}
		}, (ConstructionSocket socket) => socket.socketType == ConstructionSocket.Type.Elevator);
	}

	public void Server_RaiseLowerElevator(Direction dir, bool goTopBottom)
	{
		if (IsBusy())
		{
			return;
		}
		int num = LiftPositionToFloor();
		switch (dir)
		{
		case Direction.Up:
			num++;
			if (goTopBottom)
			{
				num = Floor;
			}
			break;
		case Direction.Down:
			num--;
			if (goTopBottom)
			{
				num = 0;
			}
			break;
		}
		RequestMoveLiftTo(num, out var _, this);
	}

	public bool RequestMoveLiftTo(int targetFloor, out float timeToTravel, Elevator fromElevator)
	{
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		timeToTravel = 0f;
		if (Interface.CallHook("OnElevatorMove", (object)this, (object)targetFloor) != null)
		{
			return false;
		}
		if (IsBusy())
		{
			return false;
		}
		if (!IsStatic && (Object)(object)ioEntity != (Object)null && !ioEntity.IsPowered())
		{
			return false;
		}
		if (!IsValidFloor(targetFloor))
		{
			return false;
		}
		int num = LiftPositionToFloor();
		if (num == targetFloor)
		{
			OpenDoorsAtFloor(num);
			return false;
		}
		if (!liftEntity.IsValid(base.isServer))
		{
			return false;
		}
		ElevatorLift elevatorLift = liftEntity.Get(base.isServer);
		if (!elevatorLift.CanMove())
		{
			return false;
		}
		Vector3 worldSpaceFloorPosition = GetWorldSpaceFloorPosition(targetFloor);
		if (!GamePhysics.LineOfSight(((Component)elevatorLift).transform.position, worldSpaceFloorPosition, 2097152))
		{
			return false;
		}
		OnMoveBegin();
		timeToTravel = TimeToTravelDistance(Mathf.Abs(((Component)elevatorLift).transform.position.y - worldSpaceFloorPosition.y));
		LeanTween.moveY(((Component)elevatorLift).gameObject, worldSpaceFloorPosition.y, timeToTravel).delay = LiftMoveDelay;
		timeToTravel += LiftMoveDelay;
		SetFlag(Flags.Busy, b: true);
		if (targetFloor < Floor)
		{
			elevatorLift.ToggleHurtTrigger(state: true);
		}
		elevatorLift.SetFlag(Flags.Busy, b: true);
		((FacepunchBehaviour)this).Invoke((Action)ClearBusy, timeToTravel + 1f);
		elevatorLift.NotifyNewFloor(targetFloor, Floor);
		EntityLinkBroadcast(delegate(Elevator elevatorEnt)
		{
			elevatorEnt.SetFlag(Flags.Busy, b: true);
		}, (ConstructionSocket socket) => socket.socketType == ConstructionSocket.Type.Elevator);
		if ((Object)(object)ioEntity != (Object)null)
		{
			ioEntity.SetFlag(Flags.Busy, b: true);
			ioEntity.SendChangedToRoot(forceUpdate: true);
		}
		return true;
	}

	protected virtual void OpenLiftDoors()
	{
		NotifyLiftEntityDoorsOpen(state: true);
	}

	public virtual void OnMoveBegin()
	{
	}

	public float TimeToTravelDistance(float distance)
	{
		return distance / LiftSpeedPerMetre;
	}

	public virtual Vector3 GetWorldSpaceFloorPosition(int targetFloor)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		int num = Floor - targetFloor;
		Vector3 val = Vector3.up * ((float)num * FloorHeight);
		val.y -= 1f;
		return ((Component)this).transform.position - val;
	}

	public virtual void ClearBusy()
	{
		SetFlag(Flags.Busy, b: false);
		if (liftEntity.IsValid(base.isServer))
		{
			liftEntity.Get(base.isServer).ToggleHurtTrigger(state: false);
			liftEntity.Get(base.isServer).SetFlag(Flags.Busy, b: false);
		}
		if ((Object)(object)ioEntity != (Object)null)
		{
			ioEntity.SetFlag(Flags.Busy, b: false);
			ioEntity.SendChangedToRoot(forceUpdate: true);
		}
		EntityLinkBroadcast(delegate(Elevator elevatorEnt)
		{
			elevatorEnt.SetFlag(Flags.Busy, b: false);
		}, (ConstructionSocket socket) => socket.socketType == ConstructionSocket.Type.Elevator);
	}

	public virtual bool IsValidFloor(int targetFloor)
	{
		if (targetFloor <= Floor)
		{
			return targetFloor >= 0;
		}
		return false;
	}

	public Elevator GetElevatorInDirection(Direction dir)
	{
		EntityLink entityLink = FindLink((dir == Direction.Down) ? "elevator/sockets/elevator-male" : "elevator/sockets/elevator-female");
		if (entityLink != null && !entityLink.IsEmpty())
		{
			BaseEntity owner = entityLink.connections[0].owner;
			if ((Object)(object)owner != (Object)null && owner.isServer && owner is Elevator elevator && (Object)(object)elevator != (Object)(object)this)
			{
				return elevator;
			}
		}
		return null;
	}

	public void UpdateChildEntities(bool isTop)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		if (isTop)
		{
			if (!liftEntity.IsValid(base.isServer))
			{
				FindExistingLiftChild();
			}
			if (!liftEntity.IsValid(base.isServer))
			{
				ElevatorLift elevatorLift = GameManager.server.CreateEntity(LiftEntityPrefab.resourcePath, GetWorldSpaceFloorPosition(Floor), LiftRoot.rotation) as ElevatorLift;
				elevatorLift.SetOwnerElevator(this);
				elevatorLift.Spawn();
				liftEntity.Set(elevatorLift);
			}
			if (liftEntity.IsValid(base.isServer))
			{
				if ((Object)(object)liftEntity.Get(base.isServer).GetParentEntity() == (Object)(object)this)
				{
					liftEntity.Get(base.isServer).SetParent(null, worldPositionStays: true);
				}
				liftEntity.Get(base.isServer).SetOwnerElevator(this);
				liftEntity.Get(base.isServer).SetFlag(Flags.Reserved5, HasFlag(Flags.Reserved2) || IsStatic);
			}
			if ((Object)(object)ioEntity == (Object)null)
			{
				FindExistingIOChild();
			}
			if ((Object)(object)ioEntity == (Object)null && IoEntityPrefab.isValid)
			{
				ioEntity = GameManager.server.CreateEntity(IoEntityPrefab.resourcePath, IoEntitySpawnPoint.position, IoEntitySpawnPoint.rotation) as IOEntity;
				ioEntity.SetParent(this, worldPositionStays: true);
				ioEntity.Spawn();
			}
		}
		else
		{
			if (liftEntity.IsValid(base.isServer))
			{
				liftEntity.Get(base.isServer).Kill();
				liftEntity.Set(null);
			}
			if ((Object)(object)ioEntity != (Object)null)
			{
				ioEntity.Kill();
			}
		}
	}

	public void FindExistingIOChild()
	{
		foreach (BaseEntity child in children)
		{
			if (child is IOEntity iOEntity)
			{
				ioEntity = iOEntity;
				break;
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.elevator == null)
		{
			info.msg.elevator = Pool.Get<Elevator>();
		}
		info.msg.elevator.floor = Floor;
		info.msg.elevator.spawnedLift = liftEntity.uid;
	}

	public int LiftPositionToFloor()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (!liftEntity.IsValid(base.isServer))
		{
			return 0;
		}
		Vector3 position = ((Component)liftEntity.Get(base.isServer)).transform.position;
		int result = -1;
		float num = float.MaxValue;
		for (int i = 0; i <= Floor; i++)
		{
			float num2 = Vector3.Distance(GetWorldSpaceFloorPosition(i), position);
			if (num2 < num)
			{
				num = num2;
				result = i;
			}
		}
		return result;
	}

	public override void DestroyShared()
	{
		Cleanup();
		base.DestroyShared();
	}

	private void Cleanup()
	{
		Elevator elevatorInDirection = GetElevatorInDirection(Direction.Down);
		if ((Object)(object)elevatorInDirection != (Object)null)
		{
			elevatorInDirection.SetFlag(Flags.Reserved1, b: true);
		}
		Elevator elevatorInDirection2 = GetElevatorInDirection(Direction.Up);
		if ((Object)(object)elevatorInDirection2 != (Object)null)
		{
			elevatorInDirection2.Kill(DestroyMode.Gib);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.Busy, b: false);
		UpdateChildEntities(IsTop);
		if ((Object)(object)ioEntity != (Object)null)
		{
			ioEntity.SetFlag(Flags.Busy, b: false);
		}
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		base.UpdateHasPower(inputAmount, inputSlot);
		if (inputAmount > 0 && previousPowerAmount[inputSlot] == 0)
		{
			CallElevator();
		}
		previousPowerAmount[inputSlot] = inputAmount;
	}

	private void OnPhysicsNeighbourChanged()
	{
		if (!IsStatic && (Object)(object)GetElevatorInDirection(Direction.Down) == (Object)null && !HasFloorSocketConnection())
		{
			Kill(DestroyMode.Gib);
		}
	}

	public bool HasFloorSocketConnection()
	{
		EntityLink entityLink = FindLink("elevator/sockets/block-male");
		if (entityLink != null && !entityLink.IsEmpty())
		{
			return true;
		}
		return false;
	}

	public void NotifyLiftEntityDoorsOpen(bool state)
	{
		if (!liftEntity.IsValid(base.isServer))
		{
			return;
		}
		foreach (BaseEntity child in liftEntity.Get(base.isServer).children)
		{
			if (child is Door door)
			{
				door.SetOpen(state);
			}
		}
	}

	protected virtual void OpenDoorsAtFloor(int floor)
	{
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if ((Object)(object)liftEntity.Get(base.isServer) != (Object)null)
		{
			liftEntity.Get(base.isServer).Kill();
		}
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if ((Object)(object)liftEntity.Get(base.isServer) != (Object)null)
		{
			liftEntity.Get(base.isServer).Kill(DestroyMode.Gib);
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!Application.isLoading && base.isServer && old.HasFlag(Flags.Reserved1) != next.HasFlag(Flags.Reserved1))
		{
			UpdateChildEntities(next.HasFlag(Flags.Reserved1));
			SendNetworkUpdate();
		}
		if (base.isServer)
		{
			ElevatorLift elevatorLift = liftEntity.Get(base.isServer);
			if ((Object)(object)elevatorLift != (Object)null)
			{
				elevatorLift.SetFlag(Flags.Reserved5, HasFlag(Flags.Reserved2) || IsStatic);
			}
		}
		if (old.HasFlag(Flags.Reserved1) != next.HasFlag(Flags.Reserved1) && (Object)(object)FloorBlockerVolume != (Object)null)
		{
			FloorBlockerVolume.SetActive(next.HasFlag(Flags.Reserved1));
		}
	}

	public void FindExistingLiftChild()
	{
		foreach (BaseEntity child in children)
		{
			if (child is ElevatorLift entity)
			{
				liftEntity.Set(entity);
				break;
			}
		}
	}

	public void OnFlagToggled(bool state)
	{
		if (base.isServer)
		{
			SetFlag(Flags.Reserved2, state);
			ElevatorLift elevatorLift = liftEntity.Get(base.isServer);
			if ((Object)(object)elevatorLift != (Object)null)
			{
				elevatorLift.SetFlag(Flags.Reserved5, HasFlag(Flags.Reserved2) || IsStatic);
			}
		}
	}
}


public enum Direction
{
	Up,
	Down
}


using System;
using UnityEngine;

public class ElevatorButton : MonoBehaviour, IClientComponent
{
	[Flags]
	public enum ElevatorOption
	{
		GoUp = 1,
		GoUpExpress = 2,
		GoDown = 4,
		GoDownExpress = 8
	}

	public ElevatorOption AvailableActions;

	public Collider AttachedCollider;
}


using System;

[Flags]
public enum ElevatorOption
{
	GoUp = 1,
	GoUpExpress = 2,
	GoDown = 4,
	GoDownExpress = 8
}


using UnityEngine;

public class ElevatorLiftPlayer : ElevatorLift
{
	public Transform CableRoot;

	public Transform CableRootTop;

	public float CableRootOffset;

	public float CableRootTopOffset;
}


using Rust;
using UnityEngine;

public class ElevatorLiftStatic : ElevatorLift
{
	public GameObjectRef ElevatorDoorRef;

	public Transform ElevatorDoorLocation;

	public bool BlockPerFloorMovement;

	private const Flags CanGoUp = Flags.Reserved3;

	private const Flags CanGoDown = Flags.Reserved4;

	public override void ServerInit()
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (ElevatorDoorRef.isValid && (Object)(object)ElevatorDoorLocation != (Object)null && !Application.isLoadingSave)
		{
			foreach (BaseEntity child in children)
			{
				if (child is Door)
				{
					return;
				}
			}
			BaseEntity baseEntity = GameManager.server.CreateEntity(ElevatorDoorRef.resourcePath, ElevatorDoorLocation.localPosition, ElevatorDoorLocation.localRotation);
			baseEntity.SetParent(this);
			baseEntity.Spawn();
		}
		SetFlag(Flags.Reserved3, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved4, b: true);
	}

	public override void NotifyNewFloor(int newFloor, int totalFloors)
	{
		base.NotifyNewFloor(newFloor, totalFloors);
		SetFlag(Flags.Reserved3, newFloor < totalFloors);
		SetFlag(Flags.Reserved4, newFloor > 0);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

public class ElevatorStatic : Elevator
{
	public bool StaticTop;

	public const Flags LiftRecentlyArrived = Flags.Reserved3;

	public List<ElevatorStatic> floorPositions = new List<ElevatorStatic>();

	public ElevatorStatic ownerElevator;

	public override bool IsStatic => true;

	public override void Spawn()
	{
		base.Spawn();
		SetFlag(Flags.Reserved2, b: true);
		SetFlag(Flags.Reserved1, StaticTop);
		if (!Application.isLoadingSave)
		{
			UpdateFloorPositions();
		}
	}

	private void UpdateFloorPositions()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (!base.IsTop)
		{
			return;
		}
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAll(new Ray(((Component)this).transform.position, -Vector3.up), 0f, list, 200f, 262144, (QueryTriggerInteraction)2);
		foreach (RaycastHit item in list)
		{
			RaycastHit current = item;
			if ((Object)(object)((RaycastHit)(ref current)).transform.parent != (Object)null)
			{
				ElevatorStatic component = ((Component)((RaycastHit)(ref current)).transform.parent).GetComponent<ElevatorStatic>();
				if (!((Object)(object)component == (Object)null) && !((Object)(object)component == (Object)(object)this) && !component.isClient && !component.IsDestroyed)
				{
					floorPositions.Add(component);
				}
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		floorPositions.Reverse();
		base.Floor = floorPositions.Count;
		for (int i = 0; i < floorPositions.Count; i++)
		{
			floorPositions[i].SetFloorDetails(i, this);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		UpdateFloorPositions();
	}

	public override void PostMapEntitySpawn()
	{
		base.PostMapEntitySpawn();
		UpdateChildEntities(base.IsTop);
	}

	public override bool IsValidFloor(int targetFloor)
	{
		if (targetFloor >= 0)
		{
			return targetFloor <= base.Floor;
		}
		return false;
	}

	public override Vector3 GetWorldSpaceFloorPosition(int targetFloor)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if (targetFloor == base.Floor)
		{
			return ((Component)this).transform.position + Vector3.up * 1f;
		}
		Vector3 position = ((Component)this).transform.position;
		position.y = ((Component)floorPositions[targetFloor]).transform.position.y + 1f;
		return position;
	}

	public void SetFloorDetails(int floor, ElevatorStatic owner)
	{
		ownerElevator = owner;
		base.Floor = floor;
	}

	public override void CallElevator()
	{
		if ((Object)(object)ownerElevator != (Object)null)
		{
			ownerElevator.RequestMoveLiftTo(base.Floor, out var _, this);
		}
		else if (base.IsTop)
		{
			RequestMoveLiftTo(base.Floor, out var _, this);
		}
	}

	public ElevatorStatic ElevatorAtFloor(int floor)
	{
		if (floor == base.Floor)
		{
			return this;
		}
		if (floor >= 0 && floor < floorPositions.Count)
		{
			return floorPositions[floor];
		}
		return null;
	}

	protected override void OpenDoorsAtFloor(int floor)
	{
		base.OpenDoorsAtFloor(floor);
		if (floor == floorPositions.Count)
		{
			OpenLiftDoors();
		}
		else
		{
			floorPositions[floor].OpenLiftDoors();
		}
	}

	public override void OnMoveBegin()
	{
		base.OnMoveBegin();
		ElevatorStatic elevatorStatic = ElevatorAtFloor(LiftPositionToFloor());
		if ((Object)(object)elevatorStatic != (Object)null)
		{
			elevatorStatic.OnLiftLeavingFloor();
		}
		NotifyLiftEntityDoorsOpen(state: false);
	}

	public void OnLiftLeavingFloor()
	{
		ClearPowerOutput();
		if (((FacepunchBehaviour)this).IsInvoking((Action)ClearPowerOutput))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)ClearPowerOutput);
		}
	}

	public override void ClearBusy()
	{
		base.ClearBusy();
		ElevatorStatic elevatorStatic = ElevatorAtFloor(LiftPositionToFloor());
		if ((Object)(object)elevatorStatic != (Object)null)
		{
			elevatorStatic.OnLiftArrivedAtFloor();
		}
		NotifyLiftEntityDoorsOpen(state: true);
	}

	protected override void OpenLiftDoors()
	{
		base.OpenLiftDoors();
		OnLiftArrivedAtFloor();
	}

	public void OnLiftArrivedAtFloor()
	{
		SetFlag(Flags.Reserved3, b: true);
		MarkDirty();
		((FacepunchBehaviour)this).Invoke((Action)ClearPowerOutput, 10f);
	}

	public void ClearPowerOutput()
	{
		SetFlag(Flags.Reserved3, b: false);
		MarkDirty();
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!HasFlag(Flags.Reserved3))
		{
			return 0;
		}
		return 1;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk)
		{
			SetFlag(Flags.Reserved3, b: false);
		}
	}
}


using UnityEngine;

public class FrankensteinTableVisuals : MonoBehaviour
{
	public GameObject FXReady;

	public GameObject FXNotReady;

	public GameObject FXWake;

	public Transform HeadVisualAnchor;

	public Transform TorsoVisualAnchor;

	public Transform LegsVisualAnchor;

	public Animator Animator;
}


using System;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class HitchTrough : StorageContainer
{
	[Serializable]
	public class HitchSpot
	{
		public HitchTrough owner;

		public Transform tr;

		public EntityRef hitchableEntRef;

		public IHitchable GetHitchable(bool isServer = true)
		{
			return hitchableEntRef.Get(isServer) as IHitchable;
		}

		public bool IsOccupied(bool isServer = true)
		{
			return hitchableEntRef.IsValid(isServer);
		}

		public void SetOccupiedBy(IHitchable hitchable)
		{
			if (hitchable == null)
			{
				hitchableEntRef.Set(null);
				return;
			}
			BaseEntity baseEntity = hitchable as BaseEntity;
			if ((Object)(object)baseEntity != (Object)null)
			{
				hitchableEntRef.Set(baseEntity);
			}
		}
	}

	public interface IHitchable
	{
		void SetHitch(HitchTrough hitch, HitchSpot spot);
	}

	public HitchSpot[] hitchSpots;

	public float caloriesToDecaySeconds = 36f;

	public override void PostServerLoad()
	{
		HitchSpot[] array = hitchSpots;
		foreach (HitchSpot hitchSpot in array)
		{
			AttemptToHitch(hitchSpot.GetHitchable(), hitchSpot);
		}
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			UnHitchAll();
		}
		base.DestroyShared();
	}

	public Item GetFoodItem()
	{
		foreach (Item item in base.inventory.itemList)
		{
			if (item.info.category == ItemCategory.Food && Object.op_Implicit((Object)(object)((Component)item.info).GetComponent<ItemModConsumable>()))
			{
				return item;
			}
		}
		return null;
	}

	public bool HasSpace()
	{
		HitchSpot[] array = hitchSpots;
		for (int i = 0; i < array.Length; i++)
		{
			if (!array[i].IsOccupied())
			{
				return true;
			}
		}
		return false;
	}

	public bool IsValidHitchPosition(Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GetClosestSpot(pos, includeOccupied: false, 1f) != null;
	}

	public bool AttemptToHitch(IHitchable hitchable, HitchSpot spot = null)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (hitchable == null)
		{
			return false;
		}
		if (spot == null)
		{
			BaseEntity baseEntity = hitchable as BaseEntity;
			if ((Object)(object)baseEntity != (Object)null)
			{
				spot = GetClosestSpot(((Component)baseEntity).transform.position);
			}
		}
		if (spot != null)
		{
			object obj = Interface.CallHook("OnHorseHitch", (object)hitchable, (object)spot);
			if (obj is bool)
			{
				return (bool)obj;
			}
			spot.SetOccupiedBy(hitchable);
			hitchable.SetHitch(this, spot);
			return true;
		}
		return false;
	}

	public HitchSpot GetClosestSpot(Vector3 testPos, bool includeOccupied = false, float maxRadius = -1f)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		float num = 10000f;
		HitchSpot result = null;
		for (int i = 0; i < hitchSpots.Length; i++)
		{
			float num2 = Vector3.Distance(testPos, hitchSpots[i].tr.position);
			if (num2 < num && (maxRadius == -1f || num2 <= maxRadius) && (includeOccupied || !hitchSpots[i].IsOccupied()))
			{
				num = num2;
				result = hitchSpots[i];
			}
		}
		return result;
	}

	public void UnHitch(IHitchable hitchable)
	{
		HitchSpot[] array = hitchSpots;
		foreach (HitchSpot hitchSpot in array)
		{
			if (hitchSpot.GetHitchable(base.isServer) == hitchable)
			{
				if (Interface.CallHook("OnHorseUnhitch", (object)hitchable, (object)hitchSpot) != null)
				{
					break;
				}
				hitchSpot.SetOccupiedBy(null);
				hitchable.SetHitch(null, null);
			}
		}
	}

	public void UnHitchAll()
	{
		HitchSpot[] array = hitchSpots;
		for (int i = 0; i < array.Length; i++)
		{
			IHitchable hitchable = array[i].GetHitchable();
			if (hitchable != null)
			{
				UnHitch(hitchable);
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.ioEntity = Pool.Get<IOEntity>();
		info.msg.ioEntity.genericEntRef1 = hitchSpots[0].hitchableEntRef.uid;
		info.msg.ioEntity.genericEntRef2 = hitchSpots[1].hitchableEntRef.uid;
	}

	public override void Load(LoadInfo info)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			hitchSpots[0].hitchableEntRef.uid = info.msg.ioEntity.genericEntRef1;
			hitchSpots[1].hitchableEntRef.uid = info.msg.ioEntity.genericEntRef2;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class HitchSpot
{
	public HitchTrough owner;

	public Transform tr;

	public EntityRef hitchableEntRef;

	public IHitchable GetHitchable(bool isServer = true)
	{
		return hitchableEntRef.Get(isServer) as IHitchable;
	}

	public bool IsOccupied(bool isServer = true)
	{
		return hitchableEntRef.IsValid(isServer);
	}

	public void SetOccupiedBy(IHitchable hitchable)
	{
		if (hitchable == null)
		{
			hitchableEntRef.Set(null);
			return;
		}
		BaseEntity baseEntity = hitchable as BaseEntity;
		if ((Object)(object)baseEntity != (Object)null)
		{
			hitchableEntRef.Set(baseEntity);
		}
	}
}


public interface IHitchable
{
	void SetHitch(HitchTrough hitch, HitchSpot spot);
}


public class HotAirBalloonArmor : HotAirBalloonEquipment
{
	public float AdditionalHealth = 100f;

	public override void Added(HotAirBalloon hab, bool fromSave)
	{
		base.Added(hab, fromSave);
		hab.SetMaxHealth(hab.MaxHealth() + AdditionalHealth);
		if (!fromSave)
		{
			hab.health += AdditionalHealth;
		}
		SendNetworkUpdate();
	}

	public override void Removed(HotAirBalloon hab)
	{
		base.Removed(hab);
		hab.DelayNextUpgrade(DelayNextUpgradeOnRemoveDuration);
	}

	public override void Hurt(HitInfo info)
	{
		if (HasParent() && GetParentEntity() is HotAirBalloon { baseProtection: var protectionProperties } hotAirBalloon)
		{
			hotAirBalloon.baseProtection = baseProtection;
			hotAirBalloon.Hurt(info);
			hotAirBalloon.baseProtection = protectionProperties;
		}
	}
}


using UnityEngine;

public class HotAirBalloonEquipment : BaseCombatEntity
{
	[SerializeField]
	private DamageRenderer damageRenderer;

	[HideInInspector]
	public float DelayNextUpgradeOnRemoveDuration;

	private EntityRef<HotAirBalloon> hotAirBalloon;

	public virtual void Added(HotAirBalloon hab, bool fromSave)
	{
		hotAirBalloon.Set(hab);
	}

	public virtual void Removed(HotAirBalloon hab)
	{
		hotAirBalloon.Set(null);
	}

	public override void DoRepair(BasePlayer player)
	{
		HotAirBalloon hotAirBalloon = this.hotAirBalloon.Get(serverside: true);
		if (hotAirBalloon.IsValid())
		{
			hotAirBalloon.DoRepair(player);
		}
	}
}


using UnityEngine;

public class LootPanelMannequin : LootPanel
{
	public GameObject[] controls;
}


using UnityEngine;

[CreateAssetMenu(fileName = "MannequinPose", menuName = "MannequinPose")]
public class MannequinPose : BaseScriptableObject
{
	public Quaternion[] BoneRotations;
}


public class AudioAlarm : IOEntity
{
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ElectricBattery : IOEntity, IInstanceDataReceiver
{
	public int maxOutput;

	public float maxCapactiySeconds;

	public float rustWattSeconds;

	[Tooltip("How much energy we can request from power sources for charging is this value multiplied by our maxOutput")]
	public float maximumInboundEnergyRatio = 4f;

	public bool rechargable;

	public float chargeRatio = 0.25f;

	private int activeDrain;

	private float lastChargeIn;

	private const float tickRateSeconds = 1f;

	public const Flags Flag_HalfFull = Flags.Reserved5;

	public const Flags Flag_VeryFull = Flags.Reserved6;

	public const Flags Flag_Full = Flags.Reserved9;

	private bool wasLoaded;

	private HashSet<(IOEntity entity, int inputIndex)> connectedList = new HashSet<(IOEntity, int)>();

	private HashSet<(IOEntity entity, int inputIndex)> auxConnectedList = new HashSet<(IOEntity, int)>();

	private Queue<int> inputHistory = new Queue<int>();

	private const int inputHistorySize = 5;

	public override bool IsRootEntity()
	{
		return true;
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override int MaximalPowerOutput()
	{
		return maxOutput;
	}

	public int GetActiveDrain()
	{
		if (!IsOn())
		{
			return 0;
		}
		return activeDrain;
	}

	public void ReceiveInstanceData(InstanceData data)
	{
		rustWattSeconds = data.dataInt;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)CheckDischarge, Random.Range(0f, 1f), 1f, 0.1f);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		wasLoaded = true;
	}

	public override void OnPickedUp(Item createdItem, BasePlayer player)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Expected O, but got Unknown
		base.OnPickedUp(createdItem, player);
		if (createdItem.instanceData == null)
		{
			createdItem.instanceData = new InstanceData();
		}
		createdItem.instanceData.ShouldPool = false;
		createdItem.instanceData.dataInt = Mathf.FloorToInt(rustWattSeconds);
	}

	public override int GetCurrentEnergy()
	{
		return currentEnergy;
	}

	public int GetDrain()
	{
		connectedList.Clear();
		auxConnectedList.Clear();
		IOEntity iOEntity = outputs[0].connectedTo.Get();
		if ((Object)(object)iOEntity != (Object)null)
		{
			int connectedToSlot = outputs[0].connectedToSlot;
			if (iOEntity.WantsPower(connectedToSlot))
			{
				AddConnectedRecursive(iOEntity, connectedToSlot, ref connectedList);
			}
			else
			{
				connectedList.Add((iOEntity, connectedToSlot));
			}
		}
		int num = 0;
		if (HasFlag(Flags.Reserved9))
		{
			IOEntity iOEntity2 = outputs[1].connectedTo.Get();
			if ((Object)(object)iOEntity2 != (Object)null)
			{
				int connectedToSlot2 = outputs[1].connectedToSlot;
				if (iOEntity2.WantsPower(connectedToSlot2))
				{
					AddConnectedRecursive(iOEntity2, connectedToSlot2, ref auxConnectedList);
				}
				else
				{
					auxConnectedList.Add((iOEntity2, connectedToSlot2));
				}
			}
			foreach (var auxConnected in auxConnectedList)
			{
				if (auxConnected.entity.ShouldDrainBattery(this))
				{
					num += auxConnected.entity.DesiredPower(auxConnected.inputIndex);
					if (num >= 1)
					{
						num = 1;
						break;
					}
				}
			}
		}
		int num2 = num;
		foreach (var connected in connectedList)
		{
			if (connected.entity.ShouldDrainBattery(this))
			{
				num2 += connected.entity.DesiredPower(connected.inputIndex);
				if (num2 >= maxOutput)
				{
					num2 = maxOutput;
					break;
				}
			}
		}
		return num2;
	}

	public void AddConnectedRecursive(IOEntity root, int inputIndex, ref HashSet<(IOEntity, int)> listToUse)
	{
		listToUse.Add((root, inputIndex));
		if (!root.WantsPassthroughPower())
		{
			return;
		}
		for (int i = 0; i < root.outputs.Length; i++)
		{
			if (!root.AllowDrainFrom(i))
			{
				continue;
			}
			IOSlot iOSlot = root.outputs[i];
			if (iOSlot.type == IOType.Electric)
			{
				IOEntity iOEntity = iOSlot.connectedTo.Get();
				if ((Object)(object)iOEntity != (Object)null && !listToUse.Contains((iOEntity, iOSlot.connectedToSlot)) && iOEntity.WantsPower(iOSlot.connectedToSlot))
				{
					AddConnectedRecursive(iOEntity, iOSlot.connectedToSlot, ref listToUse);
				}
			}
		}
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		if (rustWattSeconds >= maxCapactiySeconds)
		{
			return 0;
		}
		if (!IsFlickering())
		{
			return Mathf.Min(currentEnergy, Mathf.FloorToInt((float)maxOutput * maximumInboundEnergyRatio));
		}
		return GetHighestInputFromHistory();
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		if (IsFlickering())
		{
			if (inputHistory.Count >= 5)
			{
				inputHistory.Dequeue();
			}
			inputHistory.Enqueue(inputAmount);
		}
		if (inputSlot == 0 && rechargable)
		{
			if (!IsPowered() && !IsFlickering())
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)AddCharge);
				lastChargeIn = 0f;
			}
			else if (!((FacepunchBehaviour)this).IsInvoking((Action)AddCharge))
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)AddCharge, 1f, 1f, 0.1f);
			}
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		switch (outputSlot)
		{
		case 0:
			if (IsOn())
			{
				return Mathf.FloorToInt((float)maxOutput * ((rustWattSeconds >= 1f) ? 1f : 0f));
			}
			return 0;
		case 1:
			if (!HasFlag(Flags.Reserved9))
			{
				return 0;
			}
			return 1;
		default:
			return 0;
		}
	}

	public override bool WantsPower(int inputIndex)
	{
		return rustWattSeconds < maxCapactiySeconds;
	}

	public override void SendAdditionalData(BasePlayer player, int slot, bool input)
	{
		int passthroughAmountForAnySlot = GetPassthroughAmountForAnySlot(slot, input);
		ClientRPC(RpcTarget.Player("Client_ReceiveAdditionalData", player), currentEnergy, passthroughAmountForAnySlot, rustWattSeconds, (float)activeDrain);
	}

	public override void OnCircuitChanged(bool forceUpdate)
	{
		base.OnCircuitChanged(forceUpdate);
		int drain = GetDrain();
		activeDrain = drain;
	}

	public void CheckDischarge()
	{
		if (rustWattSeconds < 5f)
		{
			SetDischarging(wantsOn: false);
			return;
		}
		IOEntity iOEntity = outputs[0].connectedTo.Get();
		IOEntity iOEntity2 = outputs[1].connectedTo.Get();
		int drain = GetDrain();
		activeDrain = drain;
		SetDischarging((Object)(object)iOEntity != (Object)null || (Object)(object)iOEntity2 != (Object)null);
	}

	public void SetDischarging(bool wantsOn)
	{
		SetPassthroughOn(wantsOn);
	}

	private int GetHighestInputFromHistory()
	{
		int num = 0;
		foreach (int item in inputHistory)
		{
			if (item > num)
			{
				num = item;
			}
		}
		return num;
	}

	public void TickUsage()
	{
		float oldCharge = rustWattSeconds;
		bool num = rustWattSeconds > 0f;
		if (rustWattSeconds >= 1f)
		{
			float num2 = 1f * (float)activeDrain;
			rustWattSeconds -= num2;
		}
		if (rustWattSeconds <= 0f)
		{
			rustWattSeconds = 0f;
		}
		bool flag = rustWattSeconds > 0f;
		ChargeChanged(oldCharge);
		if (num != flag)
		{
			MarkDirty();
			SendNetworkUpdate();
		}
	}

	public virtual void ChargeChanged(float oldCharge)
	{
		bool flag = rustWattSeconds > maxCapactiySeconds * 0.25f;
		bool flag2 = rustWattSeconds > maxCapactiySeconds * 0.75f;
		if (HasFlag(Flags.Reserved5) != flag || HasFlag(Flags.Reserved6) != flag2)
		{
			SetFlag(Flags.Reserved5, flag);
			SetFlag(Flags.Reserved6, flag2);
			SendNetworkUpdate_Flags();
		}
		RefreshFullChargeFlag();
	}

	private void RefreshFullChargeFlag()
	{
		bool flag = (float)Mathf.RoundToInt(rustWattSeconds / 60f) >= maxCapactiySeconds / 60f;
		bool flag2 = HasFlag(Flags.Reserved9);
		if (flag && !flag2)
		{
			SetFlag(Flags.Reserved9, b: true);
			MarkDirtyForceUpdateOutputs();
		}
		else if (!flag && flag2 && ((float)activeDrain > lastChargeIn || lastChargeIn == 0f))
		{
			SetFlag(Flags.Reserved9, b: false);
			MarkDirtyForceUpdateOutputs();
		}
	}

	public void SetCharge(float charge)
	{
		float oldCharge = rustWattSeconds;
		rustWattSeconds = charge;
		ChargeChanged(oldCharge);
	}

	public void AddCharge()
	{
		float oldCharge = rustWattSeconds;
		float num = (lastChargeIn = (float)Mathf.Min(IsFlickering() ? GetHighestInputFromHistory() : currentEnergy, DesiredPower()) * 1f * chargeRatio);
		if (num > 0f)
		{
			rustWattSeconds += num;
			rustWattSeconds = Mathf.Clamp(rustWattSeconds, 0f, maxCapactiySeconds);
			ChargeChanged(oldCharge);
		}
	}

	public void SetPassthroughOn(bool wantsOn)
	{
		if (wantsOn == IsOn() && !wasLoaded)
		{
			return;
		}
		wasLoaded = false;
		SetFlag(Flags.On, wantsOn);
		if (IsOn())
		{
			if (!((FacepunchBehaviour)this).IsInvoking((Action)TickUsage))
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)TickUsage, 1f, 1f, 0.1f);
			}
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)TickUsage);
		}
		MarkDirty();
	}

	public void UnBusy()
	{
		SetFlag(Flags.Busy, b: false);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.ioEntity == null)
		{
			info.msg.ioEntity = Pool.Get<IOEntity>();
		}
		info.msg.ioEntity.genericFloat1 = rustWattSeconds;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			rustWattSeconds = info.msg.ioEntity.genericFloat1;
		}
	}

	[ServerVar]
	public static void batteryid(Arg arg)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		ElectricBattery electricBattery = BaseNetworkable.serverEntities.Find(arg.GetEntityID(1)) as ElectricBattery;
		if ((Object)(object)electricBattery == (Object)null)
		{
			arg.ReplyWith("Not a battery");
			return;
		}
		string @string = arg.GetString(0, "");
		if (!(@string == "charge"))
		{
			if (@string == "deplete")
			{
				float oldCharge = electricBattery.rustWattSeconds;
				electricBattery.rustWattSeconds = 0f;
				electricBattery.ChargeChanged(oldCharge);
				arg.ReplyWith("Depleted " + electricBattery.GetDisplayName().english);
			}
			else
			{
				arg.ReplyWith("Unknown command");
			}
		}
		else
		{
			float oldCharge2 = electricBattery.rustWattSeconds;
			float num = arg.GetInt(2, (int)electricBattery.maxCapactiySeconds / 60);
			electricBattery.rustWattSeconds = Mathf.Clamp(electricBattery.rustWattSeconds + num * 60f, 0f, electricBattery.maxCapactiySeconds);
			electricBattery.ChargeChanged(oldCharge2);
			arg.ReplyWith("Charged " + electricBattery.GetDisplayName().english);
		}
	}
}


using UnityEngine;

public class BaseDetector : IOEntity, IDetector
{
	public PlayerDetectionTrigger myTrigger;

	public const Flags Flag_HasContents = Flags.Reserved1;

	public override int ConsumptionAmount()
	{
		return base.ConsumptionAmount();
	}

	public virtual bool ShouldTrigger()
	{
		return IsPowered();
	}

	public virtual void OnObjects()
	{
		SetFlag(Flags.Reserved1, b: true);
		if (ShouldTrigger())
		{
			OnDetectorTriggered();
			MarkDirty();
		}
	}

	public void OnObjectAdded(GameObject obj, Collider col)
	{
	}

	public virtual void OnEmpty()
	{
		SetFlag(Flags.Reserved1, b: false);
		if (ShouldTrigger())
		{
			OnDetectorReleased();
			MarkDirty();
		}
	}

	public virtual void OnDetectorTriggered()
	{
	}

	public virtual void OnDetectorReleased()
	{
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!HasFlag(Flags.Reserved1))
		{
			return 0;
		}
		return base.GetPassthroughAmount();
	}
}


using UnityEngine;

public interface IDetector
{
	bool ShouldTrigger();

	void OnObjects();

	void OnObjectAdded(GameObject obj, Collider col);

	void OnEmpty();
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class LaserDetector : BaseDetector
{
	public const Flags Flag_Triggered = Flags.Reserved12;

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!HasFlag(Flags.Reserved12))
		{
			return 0;
		}
		return currentEnergy;
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (IsPowered() && next.HasFlag(Flags.Reserved1))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)VisibilityCheck, 0f, 1f);
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)VisibilityCheck);
		}
	}

	private void VisibilityCheck()
	{
		if (myTrigger.entityContents == null)
		{
			return;
		}
		bool b = false;
		foreach (BaseEntity entityContent in myTrigger.entityContents)
		{
			if (!entityContent.isClient && CanSee(entityContent))
			{
				b = true;
				break;
			}
		}
		SetFlag(Flags.Reserved12, b);
		MarkDirty();
	}

	public override void OnEmpty()
	{
		base.OnEmpty();
		SetFlag(Flags.Reserved12, b: false);
		MarkDirty();
	}

	public bool CanSee(BaseEntity ent)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		PooledList<RaycastHit> val = Pool.Get<PooledList<RaycastHit>>();
		try
		{
			GamePhysics.TraceAll(new Ray(((Component)this).transform.position + ((Component)this).transform.forward * 0.25f, ((Component)this).transform.forward), 0.12f, (List<RaycastHit>)(object)val, 12f, 0x48A12101 | LayerMask.op_Implicit(myTrigger.InterestLayers), (QueryTriggerInteraction)1, this);
			foreach (RaycastHit item in (List<RaycastHit>)(object)val)
			{
				BaseEntity entity = item.GetEntity();
				if (!((Object)(object)entity == (Object)null) && !entity.isClient)
				{
					return (Object)(object)entity == (Object)(object)ent;
				}
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using UnityEngine;

public class PlayerDetectionTrigger : TriggerBase
{
	public GameObject detector;

	public IDetector _detector;

	private IDetector myDetector
	{
		get
		{
			if (_detector == null && (Object)(object)detector != (Object)null)
			{
				_detector = detector.GetComponent<IDetector>();
			}
			return _detector;
		}
	}

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	public override void OnObjects()
	{
		base.OnObjects();
		if (myDetector != null)
		{
			myDetector.OnObjects();
		}
	}

	internal override void OnObjectAdded(GameObject obj, Collider col)
	{
		base.OnObjectAdded(obj, col);
		if (myDetector != null)
		{
			myDetector.OnObjectAdded(obj, col);
		}
	}

	public override void OnEmpty()
	{
		base.OnEmpty();
		if (myDetector != null)
		{
			myDetector.OnEmpty();
		}
	}
}


using System;
using UnityEngine;

public class PressurePad : BaseDetector
{
	public float pressPowerTime = 0.5f;

	public int pressPowerAmount = 2;

	public const Flags Flag_EmittingPower = Flags.Reserved3;

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override bool IsRootEntity()
	{
		return true;
	}

	public override bool ShouldTrigger()
	{
		return true;
	}

	public override void OnDetectorTriggered()
	{
		base.OnDetectorTriggered();
		((FacepunchBehaviour)this).Invoke((Action)UnpowerTime, pressPowerTime);
		SetFlag(Flags.Reserved3, b: true);
	}

	public override void OnDetectorReleased()
	{
		base.OnDetectorReleased();
		SetFlag(Flags.Reserved3, b: false);
	}

	public void UnpowerTime()
	{
		SetFlag(Flags.Reserved3, b: false);
		MarkDirty();
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (HasFlag(Flags.Reserved1))
		{
			int passthroughAmount = base.GetPassthroughAmount(0);
			if (HasFlag(Flags.Reserved3))
			{
				return Mathf.Max(pressPowerAmount, passthroughAmount);
			}
			if (IsPowered())
			{
				return passthroughAmount;
			}
		}
		return 0;
	}
}


using UnityEngine;

public class ElectricalHeater : IOEntity
{
	public float fadeDuration = 1f;

	public Light sourceLight;

	public Light secondaryLight;

	public GrowableHeatSource growableHeatSource;

	public override int ConsumptionAmount()
	{
		return 3;
	}

	public override void ResetState()
	{
		base.ResetState();
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		bool flag = next.HasFlag(Flags.Reserved8);
		if (old.HasFlag(Flags.Reserved8) != flag && (Object)(object)growableHeatSource != (Object)null)
		{
			growableHeatSource.ForceUpdateGrowablesInRange();
		}
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if ((Object)(object)growableHeatSource != (Object)null)
		{
			growableHeatSource.ForceUpdateGrowablesInRange();
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public class GrowableHeatSource : EntityComponent<BaseEntity>, IServerComponent
{
	public float heatAmount = 5f;

	public AnimationCurve HeatFalloff = AnimationCurve.Linear(0f, 1f, 1f, 0f);

	public float ApplyHeat(Vector3 forPosition)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)base.baseEntity == (Object)null)
		{
			return 0f;
		}
		if (base.baseEntity.IsOn() || (base.baseEntity is IOEntity iOEntity && iOEntity.IsPowered()))
		{
			float num = Vector3.Distance(forPosition, ((Component)this).transform.position);
			float num2 = HeatFalloff.Evaluate(num / Server.artificialTemperatureGrowableRange);
			return heatAmount * num2;
		}
		return 0f;
	}

	public void ForceUpdateGrowablesInRange()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		List<IHeatSourceListener> list = Pool.Get<List<IHeatSourceListener>>();
		int layerMask = 524544;
		Vis.Entities(((Component)this).transform.position, Server.artificialTemperatureGrowableRange, list, layerMask, (QueryTriggerInteraction)2);
		List<PlanterBox> list2 = Pool.Get<List<PlanterBox>>();
		foreach (IHeatSourceListener item in list)
		{
			if (item is GrowableEntity growableEntity)
			{
				if (!growableEntity.isServer)
				{
					continue;
				}
				PlanterBox planter = growableEntity.GetPlanter();
				if ((Object)(object)planter != (Object)null && !list2.Contains(planter))
				{
					list2.Add(planter);
					planter.ForceTemperatureUpdate();
				}
			}
			item.OnHeatSourceChanged();
		}
		Pool.FreeUnmanaged<PlanterBox>(ref list2);
		Pool.FreeUnmanaged<IHeatSourceListener>(ref list);
	}
}


public interface IHeatSourceListener
{
	void OnHeatSourceChanged();
}


public class ElectricalBlocker : IOEntity
{
	protected int input1Amount;

	protected int input2Amount;

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		return base.GetPassthroughAmount(outputSlot) * ((!IsOn()) ? 1 : 0);
	}

	public override bool WantsPower(int inputIndex)
	{
		if (inputIndex != 0 || !IsFlickering())
		{
			return !IsOn();
		}
		return true;
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		SetFlag(Flags.Reserved8, input2Amount > 0, recursive: false, networkupdate: false);
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
	}

	public virtual void UpdateBlocked()
	{
		bool num = IsOn();
		SetFlag(Flags.On, input1Amount > 0, recursive: false, networkupdate: false);
		if (num != IsOn())
		{
			MarkDirty();
		}
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		switch (inputSlot)
		{
		case 1:
			input1Amount = inputAmount;
			UpdateBlocked();
			break;
		case 0:
			input2Amount = inputAmount;
			base.UpdateFromInput(inputAmount, inputSlot);
			break;
		}
	}
}


using UnityEngine;

public class ElectricalCombiner : IOEntity
{
	public int input1Amount;

	public int input2Amount;

	public int input3Amount;

	public override bool BlockFluidDraining => true;

	public override bool IsRootEntity()
	{
		return true;
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		int num = input1Amount + input2Amount + input3Amount;
		Mathf.Clamp(num, 0, num);
		return num;
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		SetFlag(Flags.Reserved8, input1Amount > 0 || input2Amount > 0, recursive: false, networkupdate: false);
	}

	public override void UpdateFromInput(int inputAmount, int slot)
	{
		if (inputAmount > 0 && IsConnectedTo(this, slot, IOEntity.backtracking * 2, defaultReturn: true))
		{
			inputAmount = 0;
			SetFlag(Flags.Reserved7, b: true);
		}
		else
		{
			SetFlag(Flags.Reserved7, b: false);
		}
		switch (slot)
		{
		case 0:
			input1Amount = inputAmount;
			break;
		case 1:
			input2Amount = inputAmount;
			break;
		case 2:
			input3Amount = inputAmount;
			break;
		}
		int num = input1Amount + input2Amount + input3Amount;
		bool b = num > 0;
		Flags num2 = flags;
		SetFlag(Flags.Reserved1, input1Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved2, input2Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved3, b, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved4, input1Amount > 0 || input2Amount > 0 || input3Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.On, num > 0, recursive: false, networkupdate: false);
		if (num2 != flags)
		{
			SendNetworkUpdate_Flags();
		}
		base.UpdateFromInput(num, slot);
	}
}


using System;
using UnityEngine;

public class ElectricalDFlipFlop : IOEntity
{
	[NonSerialized]
	private int setAmount;

	[NonSerialized]
	private int resetAmount;

	[NonSerialized]
	private int toggleAmount;

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		if (inputSlot == 0)
		{
			base.UpdateHasPower(inputAmount, inputSlot);
		}
	}

	public bool GetDesiredState()
	{
		if (setAmount > 0 && resetAmount == 0)
		{
			return true;
		}
		if (setAmount > 0 && resetAmount > 0)
		{
			return true;
		}
		if (setAmount == 0 && resetAmount > 0)
		{
			return false;
		}
		if (toggleAmount > 0)
		{
			return !IsOn();
		}
		if (setAmount == 0 && resetAmount == 0)
		{
			return IsOn();
		}
		return false;
	}

	public void UpdateState()
	{
		if (IsPowered())
		{
			bool num = IsOn();
			bool desiredState = GetDesiredState();
			SetFlag(Flags.On, desiredState);
			if (num != IsOn())
			{
				MarkDirtyForceUpdateOutputs();
			}
		}
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		bool flag = false;
		switch (inputSlot)
		{
		case 1:
			flag = inputAmount != setAmount;
			setAmount = inputAmount;
			break;
		case 2:
			flag = inputAmount != resetAmount;
			resetAmount = inputAmount;
			break;
		case 3:
			flag = inputAmount != toggleAmount;
			toggleAmount = inputAmount;
			break;
		case 0:
			base.UpdateFromInput(inputAmount, inputSlot);
			UpdateState();
			break;
		}
		if (flag)
		{
			UpdateState();
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		int result = Mathf.Max(0, currentEnergy);
		if (outputSlot == -1)
		{
			return result;
		}
		if (!AllowDrainFrom(outputSlot))
		{
			return 0;
		}
		return result;
	}

	public override void UpdateOutputs()
	{
		if (ShouldUpdateOutputs() && ensureOutputsUpdated)
		{
			int passthroughAmount = GetPassthroughAmount(-1);
			if ((Object)(object)outputs[0].connectedTo.Get() != (Object)null)
			{
				outputs[0].connectedTo.Get().UpdateFromInput(IsOn() ? passthroughAmount : 0, outputs[0].connectedToSlot);
			}
			if ((Object)(object)outputs[1].connectedTo.Get() != (Object)null)
			{
				outputs[1].connectedTo.Get().UpdateFromInput((!IsOn()) ? passthroughAmount : 0, outputs[1].connectedToSlot);
			}
		}
	}

	public override bool AllowDrainFrom(int outputSlot)
	{
		if (outputSlot == -1)
		{
			return true;
		}
		if (!IsOn())
		{
			return outputSlot == 1;
		}
		return outputSlot == 0;
	}

	public override bool WantsPower(int inputIndex)
	{
		return inputIndex == 0;
	}
}


using UnityEngine;

public class RANDSwitch : ElectricalBlocker
{
	private bool rand;

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		return GetCurrentEnergy() * (IsOn() ? 1 : 0);
	}

	public override bool WantsPower(int inputIndex)
	{
		if (inputIndex == 0)
		{
			return IsOn();
		}
		return false;
	}

	public override void UpdateBlocked()
	{
		bool num = IsOn();
		SetFlag(Flags.On, rand, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved8, rand, recursive: false, networkupdate: false);
		UpdateHasPower(input1Amount + input2Amount, 1);
		if (num != IsOn())
		{
			MarkDirty();
		}
	}

	public bool RandomRoll()
	{
		return Random.Range(0, 2) == 1;
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		if (inputSlot == 1 && inputAmount > 0)
		{
			input1Amount = inputAmount;
			rand = RandomRoll();
			UpdateBlocked();
		}
		if (inputSlot == 2)
		{
			if (inputAmount > 0)
			{
				rand = false;
				UpdateBlocked();
			}
		}
		else
		{
			base.UpdateFromInput(inputAmount, inputSlot);
		}
	}
}


public class FuelElectricGenerator : IOEntity
{
	public float electricAmount = 8f;
}


using System;
using Oxide.Core;
using UnityEngine;

public class SolarPanel : IOEntity
{
	public Transform sunSampler;

	private const int tickrateSeconds = 60;

	public int maximalPowerOutput = 10;

	public float dot_minimum = 0.1f;

	public float dot_maximum = 0.6f;

	public override bool IsRootEntity()
	{
		return true;
	}

	public override int MaximalPowerOutput()
	{
		return maximalPowerOutput;
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)SunUpdate, 1f, 5f, 2f);
	}

	public void SunUpdate()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		int num = currentEnergy;
		if (TOD_Sky.Instance.IsNight)
		{
			num = 0;
		}
		else
		{
			Vector3 sunDirection = TOD_Sky.Instance.SunDirection;
			float num2 = Vector3.Dot(sunSampler.forward, sunDirection);
			float num3 = Mathf.InverseLerp(dot_minimum, dot_maximum, num2);
			if (num3 > 0f && !IsVisible(sunSampler.position + sunDirection * 100f, 101f))
			{
				num3 = 0f;
			}
			num = Mathf.FloorToInt((float)maximalPowerOutput * num3 * base.healthFraction);
		}
		bool num4 = currentEnergy != num;
		currentEnergy = num;
		if (num4 && Interface.CallHook("OnSolarPanelSunUpdate", (object)this, (object)num) == null)
		{
			MarkDirty();
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (outputSlot != 0)
		{
			return 0;
		}
		return currentEnergy;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

public class Igniter : IOEntity
{
	public float IgniteRange = 5f;

	public float IgniteFrequency = 1f;

	public float IgniteStartDelay;

	public Transform LineOfSightEyes;

	public float SelfDamagePerIgnite = 0.5f;

	public int PowerConsumption = 2;

	public override int ConsumptionAmount()
	{
		return PowerConsumption;
	}

	public bool CanIgnite()
	{
		return base.healthFraction >= 0.1f;
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		base.UpdateFromInput(inputAmount, inputSlot);
		if (inputAmount > 0 && CanIgnite())
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)IgniteInRange, IgniteStartDelay, IgniteFrequency);
			SetFlag(Flags.On, b: true);
			return;
		}
		if (((FacepunchBehaviour)this).IsInvoking((Action)IgniteInRange))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)IgniteInRange);
		}
		SetFlag(Flags.On, b: false);
	}

	private void IgniteInRange()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(LineOfSightEyes.position, IgniteRange, list, 1237019409, (QueryTriggerInteraction)2);
		int num = 0;
		foreach (BaseEntity item in list)
		{
			if (item.HasFlag(Flags.On) || !item.IsVisible(LineOfSightEyes.position))
			{
				continue;
			}
			if (item.isServer && item is BaseOven)
			{
				(item as BaseOven).StartCooking();
				if (item.HasFlag(Flags.On))
				{
					num++;
				}
			}
			else if (item.isServer && item is IIgniteable igniteable && igniteable.CanIgnite())
			{
				igniteable.Ignite(((Component)this).transform.position);
				num++;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		Hurt(SelfDamagePerIgnite, DamageType.ElectricShock, this, useProtection: false);
		if (!CanIgnite())
		{
			SendChangedToRoot(forceUpdate: true);
		}
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		if (!CanIgnite())
		{
			return 0;
		}
		return base.DesiredPower(inputIndex);
	}

	public override void OnRepair()
	{
		base.OnRepair();
		if (CanIgnite())
		{
			SendChangedToRoot(forceUpdate: true);
		}
	}
}


using UnityEngine;

public class OrientableLightGuide : MonoBehaviour
{
	public Transform pivotTransform;
}


using UnityEngine;

public class FlasherLight : IOEntity
{
	public EmissionToggle toggler;

	public Light myLight;

	public float flashSpacing = 0.2f;

	public float flashBurstSpacing = 0.5f;

	public float flashOnTime = 0.1f;

	public int numFlashesPerBurst = 5;

	public float maximumLightRenderDistance = 25f;

	public override void ResetState()
	{
		base.ResetState();
	}
}


using UnityEngine;

public class SirenLight : IOEntity
{
	public EmissionToggle toggler;

	public GameObject lightObj;

	public float speed;

	public override void ResetState()
	{
		base.ResetState();
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using UnityEngine;

public class Sprinkler : IOEntity
{
	public float SplashFrequency = 1f;

	public Transform Eyes;

	public int WaterPerSplash = 1;

	public float DecayPerSplash = 0.8f;

	public const Flags Flag_Radiation = Flags.Reserved3;

	public ItemDefinition currentFuelType;

	private IOEntity currentFuelSource;

	private HashSet<ISplashable> cachedSplashables = new HashSet<ISplashable>();

	private TimeSince updateSplashableCache;

	private bool forceUpdateSplashables;

	public override bool BlockFluidDraining => (Object)(object)currentFuelSource != (Object)null;

	public override int ConsumptionAmount()
	{
		return 2;
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		return Mathf.Clamp(currentEnergy, 0, ConsumptionAmount());
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		base.UpdateHasPower(inputAmount, inputSlot);
		SetSprinklerState(inputAmount > 0);
	}

	public override int CalculateCurrentEnergy(int inputAmount, int inputSlot)
	{
		return inputAmount;
	}

	private void DoSplash()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SprinklerSplash", 0);
		try
		{
			int num = WaterPerSplash;
			if (TimeSince.op_Implicit(updateSplashableCache) > SplashFrequency * 4f || forceUpdateSplashables)
			{
				cachedSplashables.Clear();
				forceUpdateSplashables = false;
				updateSplashableCache = TimeSince.op_Implicit(0f);
				Vector3 position = Eyes.position;
				Vector3 up = ((Component)this).transform.up;
				float sprinklerEyeHeightOffset = Server.sprinklerEyeHeightOffset;
				float num2 = Vector3.Angle(up, Vector3.up) / 180f;
				num2 = Mathf.Clamp(num2, 0.2f, 1f);
				sprinklerEyeHeightOffset *= num2;
				Vector3 startPosition = position + up * (Server.sprinklerRadius * 0.5f);
				Vector3 endPosition = position + up * sprinklerEyeHeightOffset;
				List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
				Vis.Entities(startPosition, endPosition, Server.sprinklerRadius, list, 1237003025, (QueryTriggerInteraction)2);
				if (list.Count > 0)
				{
					foreach (BaseEntity item in list)
					{
						if (!item.isClient && item is ISplashable splashable && !cachedSplashables.Contains(splashable) && splashable.WantsSplash(currentFuelType, num) && item.IsVisible(position) && (!(item is IOEntity entity) || !IsConnectedTo(entity, IOEntity.backtracking)) && (!(item is BasePlayer) || !(currentFuelType.baseRadioactivity > 0f)))
						{
							cachedSplashables.Add(splashable);
						}
					}
				}
				Pool.FreeUnmanaged<BaseEntity>(ref list);
			}
			if (cachedSplashables.Count > 0)
			{
				int num3 = num / cachedSplashables.Count;
				float num4 = (float)(num % cachedSplashables.Count) / (float)cachedSplashables.Count;
				foreach (ISplashable cachedSplashable in cachedSplashables)
				{
					int amount = num3 + ((Random.value < num4) ? 1 : 0);
					if (!cachedSplashable.IsUnityNull() && cachedSplashable.WantsSplash(currentFuelType, amount))
					{
						int num5 = cachedSplashable.DoSplash(currentFuelType, amount);
						num -= num5;
						if (num <= 0)
						{
							break;
						}
					}
				}
			}
			if (DecayPerSplash > 0f)
			{
				Hurt(DecayPerSplash);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		Interface.CallHook("OnSprinklerSplashed", (object)this);
	}

	public void SetSprinklerState(bool wantsOn)
	{
		if (wantsOn)
		{
			TurnOn();
		}
		else
		{
			TurnOff();
		}
	}

	public void TurnOn()
	{
		if (!IsOn())
		{
			SetFlag(Flags.On, b: true);
			if ((Object)(object)currentFuelType != (Object)null)
			{
				SetFlag(Flags.Reserved3, currentFuelType.baseRadioactivity > 0f);
			}
			forceUpdateSplashables = true;
			if (!((FacepunchBehaviour)this).IsInvoking((Action)DoSplash))
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)DoSplash, SplashFrequency * 0.5f, SplashFrequency, SplashFrequency * 0.2f);
			}
		}
	}

	public void TurnOff()
	{
		if (IsOn())
		{
			SetFlag(Flags.On, b: false);
			SetFlag(Flags.Reserved3, b: false);
			if (((FacepunchBehaviour)this).IsInvoking((Action)DoSplash))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)DoSplash);
			}
			currentFuelSource = null;
			currentFuelType = null;
		}
	}

	public override void SetFuelType(ItemDefinition def, IOEntity source)
	{
		base.SetFuelType(def, source);
		currentFuelType = def;
		currentFuelSource = source;
		if ((Object)(object)currentFuelType != (Object)null)
		{
			SetFlag(Flags.Reserved3, currentFuelType.baseRadioactivity > 0f && IsOn());
		}
		else
		{
			SetFlag(Flags.Reserved3, b: false);
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk)
		{
			if (Server.useLegacySprinklerLoadProcess)
			{
				SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
			}
			else if (HasFlag(Flags.On) && !((FacepunchBehaviour)this).IsInvoking((Action)DoSplash))
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)DoSplash, SplashFrequency * 0.5f, SplashFrequency, SplashFrequency * 0.2f);
			}
		}
	}
}


using System;
using System.Linq;
using Rust;
using UnityEngine;

public class TeslaCoil : IOEntity
{
	public TargetTrigger targetTrigger;

	public TriggerMovement movementTrigger;

	public float powerToDamageRatio = 2f;

	public float dischargeTickRate = 0.25f;

	public float maxDischargeSelfDamageSeconds = 120f;

	public float maxDamageOutput = 35f;

	public Transform damageEyes;

	public const Flags Flag_WeakShorting = Flags.Reserved1;

	public const Flags Flag_StrongShorting = Flags.Reserved2;

	public int powerForHeavyShorting = 10;

	private float lastDischargeTime;

	public override int ConsumptionAmount()
	{
		return Mathf.CeilToInt(maxDamageOutput / powerToDamageRatio);
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		if (!CanDischarge())
		{
			return 0;
		}
		return Mathf.Clamp(currentEnergy, 0, ConsumptionAmount());
	}

	public bool CanDischarge()
	{
		return base.healthFraction >= 0.1f;
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		base.UpdateFromInput(inputAmount, inputSlot);
		if (inputAmount > 0 && CanDischarge())
		{
			float num = Time.time - lastDischargeTime;
			if (num < 0f)
			{
				num = 0f;
			}
			float num2 = Mathf.Min(dischargeTickRate - num, dischargeTickRate);
			((FacepunchBehaviour)this).InvokeRepeating((Action)Discharge, num2, dischargeTickRate);
			SetFlag(Flags.Reserved1, inputAmount < powerForHeavyShorting, recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved2, inputAmount >= powerForHeavyShorting, recursive: false, networkupdate: false);
			SetFlag(Flags.On, b: true);
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)Discharge);
			SetFlag(Flags.Reserved1, b: false, recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
			SetFlag(Flags.On, b: false);
		}
	}

	public void Discharge()
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		float damageAmount = Mathf.Clamp((float)currentEnergy * powerToDamageRatio, 0f, maxDamageOutput) * dischargeTickRate;
		lastDischargeTime = Time.time;
		if (targetTrigger.entityContents != null)
		{
			BaseEntity[] array = targetTrigger.entityContents.ToArray();
			if (array != null)
			{
				BaseEntity[] array2 = array;
				for (int i = 0; i < array2.Length; i++)
				{
					BaseCombatEntity component = ((Component)array2[i]).GetComponent<BaseCombatEntity>();
					if (Object.op_Implicit((Object)(object)component) && component.IsVisible(((Component)damageEyes).transform.position, component.CenterPoint()))
					{
						component.OnAttacked(new HitInfo(this, component, DamageType.ElectricShock, damageAmount));
					}
				}
			}
		}
		float amount = dischargeTickRate / maxDischargeSelfDamageSeconds * MaxHealth();
		Hurt(amount, DamageType.ElectricShock, this, useProtection: false);
		if (!CanDischarge())
		{
			SendChangedToRoot(forceUpdate: true);
		}
	}

	public override void OnRepair()
	{
		base.OnRepair();
		if (CanDischarge())
		{
			SendChangedToRoot(forceUpdate: true);
		}
	}
}


using UnityEngine;

public class CableTunnel : IOEntity
{
	private const int numChannels = 4;

	private int[] inputAmounts = new int[4];

	public override bool WantsPower(int inputIndex)
	{
		return true;
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		int num = inputAmounts[inputSlot];
		inputAmounts[inputSlot] = inputAmount;
		if (inputAmount != num)
		{
			ensureOutputsUpdated = true;
		}
		base.IOStateChanged(inputAmount, inputSlot);
	}

	public override void UpdateOutputs()
	{
		if (!ShouldUpdateOutputs() || !ensureOutputsUpdated)
		{
			return;
		}
		for (int i = 0; i < 4; i++)
		{
			IOSlot iOSlot = outputs[i];
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				iOSlot.connectedTo.Get().UpdateFromInput(inputAmounts[i], iOSlot.connectedToSlot);
			}
		}
	}
}


public class BranchConfig : IOConfig<ElectricalBranch>
{
}


public class CommandBlockConfig : IOConfig<CommandBlock>
{
	private string _currentCommand;
}


public class CounterConfig : IOConfig<PowerCounter>
{
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class DigitalClockConfig : IOConfig<DigitalClock>
{
	public DigitalClockConfigAlarm alarmPrefab;

	public Transform alarmParent;

	public GameObject placeHolder;

	public Button addButton;

	public RustButton muteButton;
}


using Rust.UI;
using UnityEngine;

public class DigitalClockConfigAlarm : MonoBehaviour
{
	public CanvasGroup canvasGroup;

	public ClockSlider slider;

	public RustButton toggleButton;

	[Space]
	public GameObject deleteButton;

	private DigitalClockConfig owner;

	private bool deleteButtonHovered;

	public bool Active { get; private set; }
}


using Rust.UI;

public class HBHFConfig : IOConfig<HBHFSensor>
{
	public RustButton authButton;

	public RustButton nonAuthButton;
}


using Rust.UI;
using UnityEngine;

public abstract class IOConfig<T> : UIDialog
{
	[Space]
	public RustInput input;

	public float minValue;

	public float maxValue = 100f;
}


public class SeismicSensorConfig : IOConfig<SeismicSensor>
{
}


public class TimerConfig : IOConfig<CustomTimerSwitch>
{
}


using UnityEngine;

public class DynamicDirtLayerController : MonoBehaviour, IClientComponent, ICustomMaterialReplacer
{
	[Range(0f, 1f)]
	public float Amount = 0.5f;

	public Texture DirtTexture;
}


using System.Collections.Generic;
using Rust.UI;
using UnityEngine;

public class LootPanelToolCupboard : LootPanel
{
	public List<VirtualItemIcon> costIcons;

	public RustText protectedText;

	public GameObject baseNotProtectedObj;

	public GameObject baseProtectedObj;

	public Phrase protectedPrefix;

	public Tooltip costToolTip;

	public Phrase blocksPhrase;

	public Phrase blocksAndDoorsPhrase;

	public GameObject toolsRow;
}


using System;
using ConVar;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class InvisibleVendingMachine : NPCVendingMachine
{
	public GameObjectRef buyEffect;

	public NPCVendingOrderManifest vmoManifest;

	public bool canRefreshOrders;

	public EntityRef<NPCShopKeeper> cachedShopKeeper;

	public const Flags HasAttachedShopkeeper = Flags.Reserved7;

	private static ListHashSet<InvisibleVendingMachine> allMachines = new ListHashSet<InvisibleVendingMachine>();

	public TimeUntil nextOrderRefresh;

	protected override bool BlockOrderRefreshOnLoad => canRefreshOrders;

	public static InvisibleVendingMachine GetMachineAtPosition(float tolerance, Vector3 position)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<InvisibleVendingMachine> enumerator = allMachines.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				InvisibleVendingMachine current = enumerator.Current;
				if ((Object)(object)current != (Object)null && current.Distance(position) < tolerance)
				{
					return current;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return null;
	}

	public void KeeperLookAt(Vector3 pos)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		NPCShopKeeper nPCShopKeeper = cachedShopKeeper.Get(base.isServer);
		if (!((Object)(object)nPCShopKeeper == (Object)null))
		{
			nPCShopKeeper.SetAimDirection(Vector3Ex.Direction2D(pos, ((Component)nPCShopKeeper).transform.position));
		}
	}

	public override bool HasVendingSounds()
	{
		return false;
	}

	public override float GetBuyDuration()
	{
		return 0.5f;
	}

	public override void CompletePendingOrder()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(buyEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
		NPCShopKeeper nPCShopKeeper = cachedShopKeeper.Get(base.isServer);
		if (Object.op_Implicit((Object)(object)nPCShopKeeper))
		{
			nPCShopKeeper.SignalBroadcast(Signal.Gesture, "victory");
			if ((Object)(object)vend_Player != (Object)null)
			{
				nPCShopKeeper.SetAimDirection(Vector3Ex.Direction2D(((Component)vend_Player).transform.position, ((Component)nPCShopKeeper).transform.position));
			}
		}
		base.CompletePendingOrder();
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		KeeperLookAt(((Component)player).transform.position);
		return base.PlayerOpenLoot(player, panelToOpen);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if ((Object)(object)vmoManifest != (Object)null && info.msg.vendingMachine != null)
		{
			info.msg.vendingMachine.vmoIndex = vmoManifest.GetIndex(vendingOrders);
		}
		info.msg.npcVendingMachine = Pool.Get<NPCVendingMachine>();
		info.msg.npcVendingMachine.attachedNpc = cachedShopKeeper.uid;
		info.msg.npcVendingMachine.nextRefresh = TimeUntil.op_Implicit(nextOrderRefresh);
	}

	public override void ServerInit()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (vmoManifest.GetIndex(vendingOrders) == -1)
		{
			Debug.LogError((object)"VENDING ORDERS NOT FOUND! Did you forget to add these orders to the VMOManifest?");
		}
		if (canRefreshOrders)
		{
			nextOrderRefresh = TimeUntil.op_Implicit(Server.waterWellNpcSalesRefreshFrequency * 60f * 60f);
			((FacepunchBehaviour)this).InvokeRepeating((Action)CheckSellOrderRefresh, 30f, 30f);
		}
		allMachines.TryAdd(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		allMachines.Remove(this);
	}

	public void CheckSellOrderRefresh()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (TimeUntil.op_Implicit(nextOrderRefresh) < 0f)
		{
			nextOrderRefresh = TimeUntil.op_Implicit(Server.waterWellNpcSalesRefreshFrequency * 60f * 60f);
			InstallFromVendingOrders();
		}
	}

	public void SetAttachedNPC(NPCShopKeeper shopkeeper)
	{
		cachedShopKeeper.Set(shopkeeper);
		SetFlag(Flags.Reserved7, (Object)(object)shopkeeper != (Object)null);
		SendNetworkUpdate();
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if ((Object)(object)cachedShopKeeper.Get(base.isServer) == (Object)null)
		{
			return false;
		}
		return base.CanBeLooted(player);
	}

	protected override bool CanShop(BasePlayer bp)
	{
		if (base.CanShop(bp))
		{
			return (Object)(object)cachedShopKeeper.Get(base.isServer) != (Object)null;
		}
		return false;
	}

	public override void Load(LoadInfo info)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.fromDisk && (Object)(object)vmoManifest != (Object)null && info.msg.vendingMachine != null)
		{
			NPCVendingOrder fromIndex = vmoManifest.GetFromIndex(info.msg.vendingMachine.vmoIndex);
			vendingOrders = fromIndex;
		}
		if (info.msg.npcVendingMachine != null)
		{
			cachedShopKeeper.uid = info.msg.npcVendingMachine.attachedNpc;
			if (base.isServer)
			{
				nextOrderRefresh = TimeUntil.op_Implicit(info.msg.npcVendingMachine.nextRefresh);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/NPC Vending Order")]
public class NPCVendingOrder : ScriptableObject
{
	[Serializable]
	public class Entry
	{
		public ItemDefinition sellItem;

		public int sellItemAmount;

		public bool sellItemAsBP;

		public ItemDefinition currencyItem;

		public int currencyAmount;

		public bool currencyAsBP;

		public int initialStock = -1;

		public int refillAmount = 1;

		public float refillDelay = 10f;

		public EntryRandom randomDetails;
	}

	[Serializable]
	public struct EntryRandom
	{
		public bool useRandom;

		[Range(0f, 1f)]
		[Tooltip("The higher this number, the more likely this will be chosen")]
		public float weight;

		[Tooltip("Minimum price for the currency item")]
		public int minPrice;

		[Tooltip("Maximum price for the currency item")]
		public int maxPrice;

		[Range(0f, 1f)]
		[Tooltip("Chance for a very low price to occur (0 to 1)")]
		public float veryLowPriceChance;

		[Tooltip("Minimum very low price")]
		public int veryLowPriceMin;

		[Tooltip("Maximum very low price")]
		public int veryLowPriceMax;

		public int GetRandomPrice()
		{
			int num = ((!(Random.value < veryLowPriceChance)) ? Random.Range(minPrice, maxPrice + 1) : Random.Range(veryLowPriceMin, veryLowPriceMax + 1));
			return Mathf.RoundToInt(((float)num + 2.5f) / 5f) * 5;
		}
	}

	public Era[] AllowedEras;

	public Entry[] orders;

	public void GetRandomEntries(int count, List<Entry> selectedEntries)
	{
		if (orders == null || orders.Length == 0 || count <= 0)
		{
			return;
		}
		List<bool> list = Pool.Get<List<bool>>();
		for (int i = 0; i < orders.Length; i++)
		{
			list.Add(item: false);
		}
		float num = 0f;
		count = Mathf.Min(count, orders.Length);
		Entry[] array = orders;
		foreach (Entry entry in array)
		{
			num += entry.randomDetails.weight;
		}
		for (int k = 0; k < count; k++)
		{
			if (num == 0f)
			{
				break;
			}
			float num2 = Random.Range(0f, num);
			for (int l = 0; l < orders.Length; l++)
			{
				Entry entry2 = orders[l];
				if (!list[l])
				{
					if (num2 < entry2.randomDetails.weight)
					{
						selectedEntries.Add(entry2);
						list[l] = true;
						num -= entry2.randomDetails.weight;
						break;
					}
					num2 -= entry2.randomDetails.weight;
				}
			}
		}
		Pool.FreeUnmanaged<bool>(ref list);
	}

	[ContextMenu("Print All Orders Info")]
	private void PrintOrdersInfo()
	{
		if (orders == null || orders.Length == 0)
		{
			Debug.Log((object)"No orders available.");
			return;
		}
		string text = "NPC Vending Orders Info:\n";
		Entry[] array = orders;
		foreach (Entry entry in array)
		{
			string arg = (((Object)(object)entry.sellItem != (Object)null) ? ((Object)entry.sellItem).name : "None");
			string arg2 = (((Object)(object)entry.currencyItem != (Object)null) ? ((Object)entry.currencyItem).name : "None");
			text = text + $"Sell Item: {arg}, Amount: {entry.sellItemAmount}, As Blueprint: {entry.sellItemAsBP}\n" + $"Currency Item: {arg2}, Amount: {entry.currencyAmount}, As Blueprint: {entry.currencyAsBP}\n" + $"Refill Amount: {entry.refillAmount}, Refill Delay: {entry.refillDelay}\n" + $"Random Details - Use Random: {entry.randomDetails.useRandom}, Weight: {entry.randomDetails.weight}\n" + $"Min Price: {entry.randomDetails.minPrice}, Max Price: {entry.randomDetails.maxPrice}\n" + $"Very Low Price Chance: {entry.randomDetails.veryLowPriceChance}, " + $"Very Low Price Min: {entry.randomDetails.veryLowPriceMin}, Very Low Price Max: {entry.randomDetails.veryLowPriceMax}\n\n";
			text += " ";
		}
		Debug.Log((object)text);
	}
}


using System;

[Serializable]
public class Entry
{
	public ItemDefinition sellItem;

	public int sellItemAmount;

	public bool sellItemAsBP;

	public ItemDefinition currencyItem;

	public int currencyAmount;

	public bool currencyAsBP;

	public int initialStock = -1;

	public int refillAmount = 1;

	public float refillDelay = 10f;

	public EntryRandom randomDetails;
}


using System;
using UnityEngine;

[Serializable]
public struct EntryRandom
{
	public bool useRandom;

	[Range(0f, 1f)]
	[Tooltip("The higher this number, the more likely this will be chosen")]
	public float weight;

	[Tooltip("Minimum price for the currency item")]
	public int minPrice;

	[Tooltip("Maximum price for the currency item")]
	public int maxPrice;

	[Range(0f, 1f)]
	[Tooltip("Chance for a very low price to occur (0 to 1)")]
	public float veryLowPriceChance;

	[Tooltip("Minimum very low price")]
	public int veryLowPriceMin;

	[Tooltip("Maximum very low price")]
	public int veryLowPriceMax;

	public int GetRandomPrice()
	{
		int num = ((!(Random.value < veryLowPriceChance)) ? Random.Range(minPrice, maxPrice + 1) : Random.Range(veryLowPriceMin, veryLowPriceMax + 1));
		return Mathf.RoundToInt(((float)num + 2.5f) / 5f) * 5;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/NPCVendingOrderManifest")]
public class NPCVendingOrderManifest : ScriptableObject
{
	public NPCVendingOrder[] orderList;

	public int GetIndex(NPCVendingOrder sample)
	{
		if ((Object)(object)sample == (Object)null)
		{
			return -1;
		}
		for (int i = 0; i < orderList.Length; i++)
		{
			NPCVendingOrder nPCVendingOrder = orderList[i];
			if ((Object)(object)sample == (Object)(object)nPCVendingOrder)
			{
				return i;
			}
		}
		return -1;
	}

	public NPCVendingOrder GetFromIndex(int index)
	{
		if (orderList == null)
		{
			return null;
		}
		if (index < 0)
		{
			return null;
		}
		if (index >= orderList.Length)
		{
			return null;
		}
		return orderList[index];
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class NPCVendingMachine : VendingMachine
{
	public class SalesData
	{
		public ulong TotalSales;

		public ulong TotalIntervals;

		public ulong SoldThisInterval;

		public float CurrentMultiplier;

		public bool IsForReceivedCurrency;

		public double GetAverageSalesPerInterval()
		{
			if (TotalSales == 0L || TotalIntervals == 0L)
			{
				return 0.0;
			}
			return (double)TotalSales / (double)TotalIntervals;
		}

		public void RecordSale(int count)
		{
			SoldThisInterval += (ulong)count;
		}

		public void ProcessEndOfInterval()
		{
			double averageSalesPerInterval = GetAverageSalesPerInterval();
			bool flag = TotalIntervals == 0;
			TotalSales += SoldThisInterval;
			TotalIntervals++;
			SoldThisInterval = 0uL;
			float num = 0f;
			num = ((!(GetAverageSalesPerInterval() <= averageSalesPerInterval || flag)) ? PriceIncreaseAmount : (0f - PriceDecreaseAmount));
			if (IsForReceivedCurrency)
			{
				CurrentMultiplier -= num;
			}
			else
			{
				CurrentMultiplier += num;
			}
			CurrentMultiplier = Mathf.Clamp(CurrentMultiplier, MinimumPriceMultiplier, MaximumPriceMultiplier);
		}
	}

	public NPCVendingOrder vendingOrders;

	public Phrase Phrase;

	public NPCVendingOrder[] alternativeVendingOrders;

	public float RefillTime = 1f;

	public int StartingStock = 10;

	public bool BypassDynamicPricing;

	public const int MaxVendingEntries = 7;

	public const int Capacity = 128;

	private static ListHashSet<NPCVendingMachine> allNpcVendingMachines = new ListHashSet<NPCVendingMachine>();

	private float[] refillTimes;

	[ServerVar(Saved = true, Help = "Whether to run the the dynamic pricing system")]
	public static bool DynamicPricingEnabled = true;

	[ServerVar(Saved = true, Help = "How many realtime hours are checked when looking for price increases. Max 72 (10 days), min 0.5 (half an hour)", ShowInAdminUI = true)]
	public static float PriceUpdateFrequencyDefault = 3f;

	[ServerVar(Saved = true, Help = "How many realtime hours are checked when looking for price increases. Max 72 (10 days), min 0.5 (half an hour)", ShowInAdminUI = true)]
	public static float PriceUpdateFrequencyBiWeekly = 2f;

	[ServerVar(Saved = true, Help = "How many realtime hours are checked when looking for price increases. Max 72 (10 days), min 0.5 (half an hour)", ShowInAdminUI = true)]
	public static float PriceUpdateFrequencyWeekly = 1f;

	private static bool hasCachedTags = false;

	private static bool cachedBiWeekly;

	private static bool cachedWeekly;

	[ServerVar(Saved = true, Help = "The maximum point that a price can increase to (2 = 200%)")]
	public static float MaximumPriceMultiplier = 2f;

	[ServerVar(Saved = true, Help = "The Minimum point that the price can drop to (0.5 = 50% off)")]
	public static float MinimumPriceMultiplier = 0.5f;

	[ServerVar(Saved = true, Help = "What discount surcharge should be applied to items when the server starts")]
	public static float StartingPriceMultiplier = 2f;

	[ServerVar(Saved = true, Help = "How much to increase the price by if it is selling a lot (0.05 = 5%)")]
	public static float PriceIncreaseAmount = 0.1f;

	[ServerVar(Saved = true, Help = "How much to decrease the price for if it is underselling (0.05 = 5%)")]
	public static float PriceDecreaseAmount = 0.05f;

	private SalesData[] allSalesData;

	private float timeToNextSalesUpdate;

	private bool preserveSalesData;

	private static ItemDefinition _scrapItem = null;

	private TimeSince lastHourCheck;

	public override EraRestriction CurrentEraRestriction => (EraRestriction)1;

	protected virtual bool BlockOrderRefreshOnLoad => false;

	public override bool ShouldRecordStats => false;

	private static float ScaledByWipeUpdateFrequency
	{
		get
		{
			if (!hasCachedTags)
			{
				cachedBiWeekly = StringEx.Contains(ConVar.Server.tags, "biweekly", CompareOptions.IgnoreCase);
				cachedWeekly = StringEx.Contains(ConVar.Server.tags, "weekly", CompareOptions.IgnoreCase);
				hasCachedTags = true;
			}
			if (cachedBiWeekly)
			{
				return PriceUpdateFrequencyBiWeekly;
			}
			if (cachedWeekly)
			{
				return PriceUpdateFrequencyWeekly;
			}
			return PriceUpdateFrequencyDefault;
		}
	}

	public static float IntervalSeconds => Mathf.Clamp(ScaledByWipeUpdateFrequency, 0.5f, 72f) * 60f * 60f;

	public static ItemDefinition ScrapItem
	{
		get
		{
			if ((Object)(object)_scrapItem == (Object)null)
			{
				_scrapItem = ItemManager.FindItemDefinition("scrap");
			}
			return _scrapItem;
		}
	}

	private bool CanApplyDynamicPricing
	{
		get
		{
			if (!BypassDynamicPricing)
			{
				return DynamicPricingEnabled;
			}
			return false;
		}
	}

	public byte GetBPState(bool sellItemAsBP, bool currencyItemAsBP)
	{
		byte result = 0;
		if (sellItemAsBP)
		{
			result = 1;
		}
		if (currencyItemAsBP)
		{
			result = 2;
		}
		if (sellItemAsBP && currencyItemAsBP)
		{
			result = 3;
		}
		return result;
	}

	public override void TakeCurrencyItem(Item takenCurrencyItem)
	{
		if (Interface.CallHook("OnTakeCurrencyItem", (object)this, (object)takenCurrencyItem) == null)
		{
			takenCurrencyItem.MoveToContainer(base.inventory);
			takenCurrencyItem.RemoveFromContainer();
			takenCurrencyItem.Remove();
		}
	}

	public override void GiveSoldItem(Item soldItem, BasePlayer buyer)
	{
		if (Interface.CallHook("OnNpcGiveSoldItem", (object)this, (object)soldItem, (object)buyer) == null)
		{
			soldItem.SetItemOwnership(buyer, ItemOwnershipPhrases.VendorSale);
			base.GiveSoldItem(soldItem, buyer);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (!BlockOrderRefreshOnLoad)
		{
			((FacepunchBehaviour)this).Invoke((Action)InstallFromVendingOrders, 1f);
		}
	}

	public void ChangeRefillTime(float newRefillTime)
	{
		RefillTime = newRefillTime;
		if (((FacepunchBehaviour)this).IsInvoking((Action)Refill))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)Refill);
		}
		((FacepunchBehaviour)this).InvokeRandomized((Action)Refill, 1f, RefillTime, 0.1f);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		skinID = 861142659uL;
		SendNetworkUpdate();
		if (!BlockOrderRefreshOnLoad || !Application.isLoadingSave)
		{
			((FacepunchBehaviour)this).Invoke((Action)InstallFromVendingOrders, 1f);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)Refill))
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)Refill, 1f, RefillTime, 0.1f);
		}
		DynamicPricingServerInit();
		allNpcVendingMachines.TryAdd(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		allNpcVendingMachines.Remove(this);
	}

	public virtual void InstallFromVendingOrders()
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Invalid comparison between I4 and Unknown
		if (alternativeVendingOrders != null && alternativeVendingOrders.Length != 0)
		{
			NPCVendingOrder[] array = alternativeVendingOrders;
			foreach (NPCVendingOrder nPCVendingOrder in array)
			{
				if (nPCVendingOrder.AllowedEras == null || nPCVendingOrder.AllowedEras.Length == 0)
				{
					vendingOrders = nPCVendingOrder;
					break;
				}
				Era[] allowedEras = nPCVendingOrder.AllowedEras;
				for (int j = 0; j < allowedEras.Length; j++)
				{
					if ((int)allowedEras[j] == (int)ConVar.Server.Era)
					{
						vendingOrders = nPCVendingOrder;
						break;
					}
				}
			}
		}
		if ((Object)(object)vendingOrders == (Object)null)
		{
			Debug.LogError((object)"No vending orders!");
			return;
		}
		int count = sellOrders.sellOrders.Count;
		ClearSellOrders();
		base.inventory.Clear();
		ItemManager.DoRemoves();
		if (numSlots == 0)
		{
			base.inventory.capacity = 128;
		}
		if (vendingOrders.orders.Length <= 7)
		{
			if (count == vendingOrders.orders.Length)
			{
				preserveSalesData = true;
			}
			try
			{
				NPCVendingOrder.Entry[] orders = vendingOrders.orders;
				foreach (NPCVendingOrder.Entry ent in orders)
				{
					SmartAddItemForSale(ent);
				}
				return;
			}
			finally
			{
				preserveSalesData = false;
			}
		}
		List<NPCVendingOrder.Entry> list = Pool.Get<List<NPCVendingOrder.Entry>>();
		vendingOrders.GetRandomEntries(7, list);
		foreach (NPCVendingOrder.Entry item in list)
		{
			SmartAddItemForSale(item);
		}
		Pool.FreeUnmanaged<NPCVendingOrder.Entry>(ref list);
	}

	private void SmartAddItemForSale(NPCVendingOrder.Entry ent)
	{
		int currencyPerTransaction = ent.currencyAmount;
		if (ent.randomDetails.useRandom)
		{
			currencyPerTransaction = ent.randomDetails.GetRandomPrice();
		}
		AddItemForSale(ent.sellItem.itemid, ent.sellItemAmount, ent.currencyItem.itemid, currencyPerTransaction, GetBPState(ent.sellItemAsBP, ent.currencyAsBP), ent.initialStock);
	}

	public override void InstallDefaultSellOrders()
	{
		base.InstallDefaultSellOrders();
	}

	public void Refill()
	{
		if ((Object)(object)vendingOrders == (Object)null || vendingOrders.orders == null || base.inventory == null)
		{
			return;
		}
		if (refillTimes == null)
		{
			refillTimes = new float[vendingOrders.orders.Length];
		}
		for (int i = 0; i < vendingOrders.orders.Length; i++)
		{
			NPCVendingOrder.Entry entry = vendingOrders.orders[i];
			if (!(Time.realtimeSinceStartup > refillTimes[i]))
			{
				continue;
			}
			int num = 0;
			num = ((!entry.sellItemAsBP) ? Mathf.FloorToInt((float)(base.inventory.GetAmount(entry.sellItem.itemid, onlyUsableAmounts: false) / entry.sellItemAmount)) : Mathf.FloorToInt((float)(base.inventory.GetAmount(base.blueprintBaseDef.itemid, entry.sellItem.itemid, onlyUsableAmounts: false) / entry.sellItemAmount)));
			int num2 = Mathf.Min(StartingStock - num, entry.refillAmount) * entry.sellItemAmount;
			if (num2 > 0)
			{
				transactionActive = true;
				Item item = null;
				if (entry.sellItemAsBP)
				{
					item = ItemManager.Create(base.blueprintBaseDef, num2, 0uL);
					item.blueprintTarget = entry.sellItem.itemid;
				}
				else
				{
					item = ItemManager.Create(entry.sellItem, num2, 0uL);
				}
				if (!item.MoveToContainer(base.inventory))
				{
					item.Remove();
				}
				transactionActive = false;
			}
			refillTimes[i] = Time.realtimeSinceStartup + entry.refillDelay;
		}
	}

	public void ClearSellOrders()
	{
		sellOrders.sellOrders.Clear();
	}

	public void AddItemForSale(int itemID, int amountToSell, int currencyID, int currencyPerTransaction, byte bpState, int initialStockOverride)
	{
		AddSellOrder(itemID, amountToSell, currencyID, currencyPerTransaction, bpState);
		transactionActive = true;
		int num = StartingStock;
		if (initialStockOverride >= 0)
		{
			num = Mathf.Min(initialStockOverride, StartingStock);
		}
		if (bpState == 1 || bpState == 3)
		{
			for (int i = 0; i < num; i++)
			{
				Item item = ItemManager.CreateByItemID(base.blueprintBaseDef.itemid, 1, 0uL);
				item.blueprintTarget = itemID;
				base.inventory.Insert(item);
			}
		}
		else
		{
			base.inventory.AddItem(ItemManager.FindItemDefinition(itemID), amountToSell * num, 0uL);
		}
		transactionActive = false;
		RefreshSellOrderStockLevel();
	}

	public void RefreshStock()
	{
	}

	protected override void RecordSaleAnalytics(Item itemSold, int orderId, int currencyUsed)
	{
		RecordSale(orderId, itemSold.amount, currencyUsed);
	}

	public override string GetTranslationToken()
	{
		return Phrase.token;
	}

	protected override bool CanRotate()
	{
		return false;
	}

	public override bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return false;
	}

	[ServerVar]
	public static void ResetFrequencyTags(Arg arg)
	{
		hasCachedTags = false;
		arg.ReplyWith($"Reset frequency tags. Scaled frequency is now:{ScaledByWipeUpdateFrequency} hours");
	}

	[ServerVar(Help = "Resets the state of all discounts and surcharges from NPC vending machines")]
	public static void resetDynamicPricing()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<NPCVendingMachine> enumerator = allNpcVendingMachines.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.ResetDynamicPricing();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar(Help = "Print out all current price changes on the server")]
	public static void printAllPriceChanges(Arg arg)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		Enumerator<NPCVendingMachine> enumerator = allNpcVendingMachines.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				NPCVendingMachine current = enumerator.Current;
				TextTable val = Pool.Get<TextTable>();
				try
				{
					val.AddColumns(new string[8] { "Item Name", "Original Price", "Discount/Surcharge", "Final Price", "Avg Sales/Interval", "Current Sales/Interval", "Total Sales", "Intervals" });
					int num = 0;
					int num2 = 0;
					foreach (SellOrder sellOrder in current.sellOrders.sellOrders)
					{
						if (sellOrder.priceMultiplier != 1f)
						{
							num++;
							ItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellOrder.itemToSellID);
							int totalPriceForOrder = VendingMachine.GetTotalPriceForOrder(sellOrder);
							SalesData salesData = current.allSalesData[num2];
							val.AddRow(new string[8]
							{
								itemDefinition.shortname,
								sellOrder.currencyAmountPerItem.ToString(),
								$"{Mathf.RoundToInt(sellOrder.priceMultiplier * 100f)}%",
								$"{totalPriceForOrder}",
								salesData.GetAverageSalesPerInterval().ToString(),
								salesData.SoldThisInterval.ToString(),
								salesData.TotalSales.ToString(),
								salesData.TotalIntervals.ToString()
							});
						}
						num2++;
					}
					if (num > 0)
					{
						stringBuilder.AppendLine(current.shopName);
						stringBuilder.AppendLine("==============");
						stringBuilder.AppendLine(((object)val).ToString());
					}
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar(Help = "Simulates the provided number of hours passing in the vending machine system")]
	public static void addHours(Arg arg)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		float num = (float)arg.GetInt(0, 0) * 60f * 60f;
		Enumerator<NPCVendingMachine> enumerator = allNpcVendingMachines.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				NPCVendingMachine current = enumerator.Current;
				current.lastHourCheck = TimeSince.op_Implicit(TimeSince.op_Implicit(current.lastHourCheck) + num);
				current.HourCheck();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public void RecordSale(int index, int countReceived, int currencyUsed)
	{
		if (CanApplyDynamicPricing)
		{
			CheckSalesDataLength();
			SalesData obj = allSalesData[index];
			obj.RecordSale(obj.IsForReceivedCurrency ? currencyUsed : countReceived);
		}
	}

	private void CheckSalesDataLength(bool reset = false)
	{
		if (reset)
		{
			allSalesData = null;
		}
		int count = sellOrders.sellOrders.Count;
		if (allSalesData == null || allSalesData.Length != count)
		{
			allSalesData = new SalesData[count];
			for (int i = 0; i < count; i++)
			{
				bool flag = sellOrders.sellOrders[i].itemToSellID == ScrapItem.itemid;
				allSalesData[i] = new SalesData
				{
					IsForReceivedCurrency = flag,
					CurrentMultiplier = (flag ? MinimumPriceMultiplier : StartingPriceMultiplier)
				};
			}
		}
	}

	protected override float GetDiscountForSlot(int sellOrderSlot, SellOrder forOrder)
	{
		if (!CanApplyDynamicPricing)
		{
			return 1f;
		}
		if (!preserveSalesData)
		{
			CheckSalesDataLength();
		}
		if (sellOrderSlot < 0 || sellOrderSlot >= allSalesData.Length)
		{
			return 1f;
		}
		if (forOrder.currencyID != ScrapItem.itemid)
		{
			return 1f;
		}
		return allSalesData[sellOrderSlot].CurrentMultiplier;
	}

	protected override float GetReceivedQuantityMultiplier(int sellOrderSlot, SellOrder forOrder)
	{
		if (!CanApplyDynamicPricing)
		{
			return 1f;
		}
		if (!preserveSalesData)
		{
			CheckSalesDataLength();
		}
		if (sellOrderSlot < 0 || sellOrderSlot >= allSalesData.Length)
		{
			return 1f;
		}
		if (forOrder.itemToSellID != ScrapItem.itemid)
		{
			return 1f;
		}
		return allSalesData[sellOrderSlot].CurrentMultiplier;
	}

	private void DynamicPricingServerInit()
	{
		timeToNextSalesUpdate = IntervalSeconds;
		((FacepunchBehaviour)this).InvokeRandomized((Action)HourCheck, 1f, 15f, 0.1f);
	}

	private void ResetDynamicPricing()
	{
		CheckSalesDataLength(reset: true);
		timeToNextSalesUpdate = IntervalSeconds;
		HourCheck();
	}

	private void HourCheck()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (!CanApplyDynamicPricing)
		{
			return;
		}
		float num = TimeSince.op_Implicit(lastHourCheck);
		lastHourCheck = TimeSince.op_Implicit(0f);
		timeToNextSalesUpdate -= num;
		while (timeToNextSalesUpdate < 0f)
		{
			timeToNextSalesUpdate += IntervalSeconds;
			SalesData[] array = allSalesData;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].ProcessEndOfInterval();
			}
			UpdateMapMarker();
			RefreshAndSendNetworkUpdate();
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (allSalesData != null && info.forDisk)
		{
			info.msg.vendingDynamicPricing = Pool.Get<VendingDynamicPricing>();
			info.msg.vendingDynamicPricing.allSalesData = Pool.Get<List<SalesData>>();
			info.msg.vendingDynamicPricing.timeToNextSalesUpdate = timeToNextSalesUpdate;
			SalesData[] array = allSalesData;
			foreach (SalesData salesData in array)
			{
				SalesData val = Pool.Get<SalesData>();
				val.totalSales = salesData.TotalSales;
				val.totalIntervals = salesData.TotalIntervals;
				val.soldThisInterval = salesData.SoldThisInterval;
				val.currentMultiplier = salesData.CurrentMultiplier;
				val.isForReceivedQuantity = salesData.IsForReceivedCurrency;
				info.msg.vendingDynamicPricing.allSalesData.Add(val);
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		if (info.msg.vendingDynamicPricing != null)
		{
			allSalesData = new SalesData[info.msg.vendingDynamicPricing.allSalesData.Count];
			int num = 0;
			timeToNextSalesUpdate = info.msg.vendingDynamicPricing.timeToNextSalesUpdate;
			foreach (SalesData allSalesDatum in info.msg.vendingDynamicPricing.allSalesData)
			{
				SalesData salesData = new SalesData
				{
					TotalSales = allSalesDatum.totalSales,
					TotalIntervals = allSalesDatum.totalIntervals,
					SoldThisInterval = allSalesDatum.soldThisInterval,
					CurrentMultiplier = allSalesDatum.currentMultiplier,
					IsForReceivedCurrency = allSalesDatum.isForReceivedQuantity
				};
				allSalesData[num] = salesData;
				num++;
			}
		}
		base.Load(info);
	}
}


using UnityEngine;

public class SalesData
{
	public ulong TotalSales;

	public ulong TotalIntervals;

	public ulong SoldThisInterval;

	public float CurrentMultiplier;

	public bool IsForReceivedCurrency;

	public double GetAverageSalesPerInterval()
	{
		if (TotalSales == 0L || TotalIntervals == 0L)
		{
			return 0.0;
		}
		return (double)TotalSales / (double)TotalIntervals;
	}

	public void RecordSale(int count)
	{
		SoldThisInterval += (ulong)count;
	}

	public void ProcessEndOfInterval()
	{
		double averageSalesPerInterval = GetAverageSalesPerInterval();
		bool flag = TotalIntervals == 0;
		TotalSales += SoldThisInterval;
		TotalIntervals++;
		SoldThisInterval = 0uL;
		float num = 0f;
		num = ((!(GetAverageSalesPerInterval() <= averageSalesPerInterval || flag)) ? PriceIncreaseAmount : (0f - PriceDecreaseAmount));
		if (IsForReceivedCurrency)
		{
			CurrentMultiplier -= num;
		}
		else
		{
			CurrentMultiplier += num;
		}
		CurrentMultiplier = Mathf.Clamp(CurrentMultiplier, MinimumPriceMultiplier, MaximumPriceMultiplier);
	}
}


using UnityEngine;
using UnityEngine.UI;

public class AddSellOrderManager : MonoBehaviour
{
	public VirtualItemIcon sellItemIcon;

	public VirtualItemIcon currencyItemIcon;

	public GameObject itemSearchParent;

	public ItemSearchEntry itemSearchEntryPrefab;

	public InputField sellItemInput;

	public InputField sellItemAmount;

	public InputField currencyItemInput;

	public InputField currencyItemAmount;

	public VendingPanelAdmin adminPanel;
}


using UnityEngine;

public class AdminExistingSellOrder : MonoBehaviour
{
	public VirtualItemIcon MerchandiseIcon;

	public VirtualItemIcon CurrencyIcon;

	private VendingPanelAdmin adminPanel;

	private int index;
}


using UnityEngine;
using UnityEngine.UI;

public class ItemSearchEntry : MonoBehaviour
{
	public Button button;

	public Text text;

	public RawImage image;

	public RawImage bpImage;
}


using UnityEngine;

public class LootPanelVendingMachine : LootPanel, IVendingMachineInterface
{
	public GameObjectRef sellOrderPrefab;

	public GameObject sellOrderContainer;

	public GameObject busyOverlayPrefab;

	private GameObject busyOverlayInstance;
}


public interface IVendingMachineInterface
{
}


using UnityEngine;

public class SellOrderEntry : MonoBehaviour, IInventoryChanged
{
	public VirtualItemIcon MerchandiseIcon;

	public VirtualItemIcon CurrencyIcon;

	private ItemDefinition merchandiseInfo;

	private ItemDefinition currencyInfo;

	public GameObject buyButton;

	public GameObject cantaffordNotification;

	public GameObject outOfStockNotification;

	private IVendingMachineInterface vendingPanel;

	public UIIntegerEntry intEntry;

	public VendingPriceMultiplierWidget priceMultiplier;

	public VendingPriceMultiplierWidget receivedCurrencyMultiplier;
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class FeedEntry : FacepunchBehaviour
{
	[Header("References")]
	public FlexElement Element;

	[SerializeField]
	private FlexTransition transition;

	public RectTransform TimeElement;

	[Header("Text")]
	public RustText IndexText;

	public RustText SoldText;

	public RustText EarnedText;

	[Header("Icons")]
	public Image IndexBacking;

	public VirtualItemIcon SoldIcon;

	public VirtualItemIcon EarnedIcon;

	[Header("Tooltips")]
	public Tooltip SoldIconTooltip;

	public Tooltip EarnedIconTooltip;

	public Tooltip TimeTooltip;
}


using TMPro;
using UnityEngine;

public class VendingPanelAdmin : UIDialog
{
	public GameObjectRef statsPanelRef;

	public AddSellOrderManager sellOrderManager;

	public EmojiGallery emojiGallery;

	public GameObject sellOrderAdminContainer;

	public GameObject sellOrderAdminPrefab;

	public TMP_InputField storeNameInputField;

	[Header("Drone Prediction")]
	public DeliveryDroneConfig predictionConfig;

	public GameObject droneAccessible;

	public GameObject droneInaccessible;
}


using Rust.UI;
using UnityEngine;

public class VendingPanelAdminStats : UIDialog
{
	[Header("References")]
	public Transform Feed;

	public TmProEmojiRedirector ShopName;

	public Dropdown TimeDropdown;

	public RustButton[] CategoryButtons;

	public RustText TotalSalesLabel;

	public RustText TotalSalesValue;

	public RustText PeakSaleHourLabel;

	public RustText PeakSaleHourValue;

	public RustText UniqueCustomersLabel;

	public RustText UniqueCustomersValue;

	public RustText RepeatCustomersLabel;

	public RustText RepeatCustomersValue;

	public RustText BestCustomerLabel;

	public RustText BestCustomerValue;

	[Header("Prefabs")]
	public GameObjectRef FeedEntryPrefab;

	public GameObjectRef SingleEntryPrefab;

	public GameObjectRef EmptyFeedEntryPrefab;
}


using Rust.UI;
using UnityEngine;

public class VendingPriceMultiplierWidget : MonoBehaviour
{
	public GameObject SurchargeRoot;

	public RustText SurchargeText;

	public GameObject DiscountRoot;

	public RustText DiscountText;

	public Tooltip SurchargeTooltip;

	public Tooltip DiscountTooltip;

	public GameObject RegularTooltip;

	public GameObject AlwaysOnTopTooltip;

	public bool Invert;
}


public class VendingMachineFront : BaseEntity
{
	public VendingMachine vendingMachine;
}


using UnityEngine;
using UnityEngine.UI;

public class VendingMachineScreen : MonoBehaviour, INotifyLOD, IClientComponent
{
	public enum vmScreenState
	{
		ItemScroll,
		Vending,
		Message,
		ShopName,
		OutOfStock
	}

	public RawImage largeIcon;

	public RawImage blueprintIcon;

	public Text mainText;

	public Text lowerText;

	public Text centerText;

	public RawImage smallIcon;

	public VendingMachine vendingMachine;

	public Sprite outOfStockSprite;

	public Renderer fadeoutMesh;

	public CanvasGroup screenCanvas;

	public Renderer light1;

	public Renderer light2;

	public bool isUpdatedWithNotifySystem;
}


public enum vmScreenState
{
	ItemScroll,
	Vending,
	Message,
	ShopName,
	OutOfStock
}


using System;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class ElectricWindmill : IOEntity
{
	public Animator animator;

	public int maxPowerGeneration = 100;

	public Transform vaneRot;

	public SoundDefinition wooshSound;

	public Transform wooshOrigin;

	private float cachedHeight;

	public float serverWindSpeed;

	public override int MaximalPowerOutput()
	{
		return maxPowerGeneration;
	}

	public override bool IsRootEntity()
	{
		return true;
	}

	public Vector3 GetWindAimDir(float time)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		float num = time / 3600f * 360f;
		int num2 = 10;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(Mathf.Sin(num * (MathF.PI / 180f)) * (float)num2, 0f, Mathf.Cos(num * (MathF.PI / 180f)) * (float)num2);
		return ((Vector3)(ref val)).normalized;
	}

	public override void ServerInit()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)WindUpdate, 1f, 20f, 2f);
		if (GamePhysics.Trace(new Ray(((Component)this).transform.position, Vector3.down), 0f, out var hitInfo, 10f, 8454144, (QueryTriggerInteraction)1, this))
		{
			cachedHeight = ((Component)this).transform.position.y - ((RaycastHit)(ref hitInfo)).point.y;
		}
		else
		{
			cachedHeight = ((Component)this).transform.position.y - TerrainMeta.HeightMap.GetHeight(((Component)this).transform.position);
		}
	}

	public bool AmIVisible()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		int num = 15;
		Vector3 val = ((Component)this).transform.position + Vector3.up * 6f;
		if (!IsVisible(val + ((Component)this).transform.up * (float)num, (float)(num + 1)))
		{
			return false;
		}
		Vector3 windAimDir = GetWindAimDir(Time.time);
		if (!IsVisible(val + windAimDir * (float)num, (float)(num + 1)))
		{
			return false;
		}
		return true;
	}

	public void WindUpdate()
	{
		if (Interface.CallHook("OnWindmillUpdate", (object)this) == null)
		{
			serverWindSpeed = GetWindSpeedScale();
			if (!AmIVisible())
			{
				serverWindSpeed = 0f;
			}
			int num = Mathf.FloorToInt((float)maxPowerGeneration * serverWindSpeed);
			bool num2 = currentEnergy != num;
			currentEnergy = num;
			if (num2)
			{
				MarkDirty();
			}
			SendNetworkUpdate();
			Interface.CallHook("OnWindmillUpdated", (object)this);
		}
	}

	public float GetWindSpeedScale()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.time / 600f;
		float num2 = ((Component)this).transform.position.x / 512f;
		float num3 = ((Component)this).transform.position.z / 512f;
		float num4 = Mathf.PerlinNoise(num2 + num, num3 + num * 0.1f);
		float num5 = cachedHeight;
		if (num5 < 0f)
		{
			num5 = 0f;
		}
		return Mathf.Clamp01(Mathf.InverseLerp(0f, 50f, num5) * 0.5f + num4);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (outputSlot != 0)
		{
			return 0;
		}
		return currentEnergy;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk)
		{
			if (info.msg.ioEntity == null)
			{
				info.msg.ioEntity = Pool.Get<IOEntity>();
			}
			info.msg.ioEntity.genericFloat1 = Time.time;
			info.msg.ioEntity.genericFloat2 = serverWindSpeed;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}
}


using ProtoBuf;

public class ItemModBeehiveNucleus : ItemMod
{
	public override void OnVirginItem(Item item, BasePlayer creatingPlayer)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Expected O, but got Unknown
		base.OnVirginItem(item, creatingPlayer);
		item.instanceData = new InstanceData
		{
			ShouldPool = false,
			dataInt = 0
		};
	}
}


using ProtoBuf;
using UnityEngine;

public class NucleusGradeItemSwap : ItemModSwap
{
	public ItemDefinition NucleusItem;

	protected override void AugmentItem(Item item)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Expected O, but got Unknown
		if ((Object)(object)item.info == (Object)(object)NucleusItem)
		{
			item.instanceData = new InstanceData
			{
				ShouldPool = false,
				dataInt = 0
			};
		}
	}
}


using System.Collections.Generic;

public static class NucleusGrading
{
	public enum NucleusGrade
	{
		Grade3,
		Grade2,
		Grade1
	}

	private static readonly Dictionary<NucleusGrade, float> NucleusXpThresholds = new Dictionary<NucleusGrade, float>
	{
		{
			NucleusGrade.Grade3,
			0f
		},
		{
			NucleusGrade.Grade2,
			200f
		},
		{
			NucleusGrade.Grade1,
			600f
		}
	};

	public static float GetXpThreshold(NucleusGrade grade)
	{
		return NucleusXpThresholds[grade];
	}

	public static string GetGradeAsString(NucleusGrade grade)
	{
		return grade switch
		{
			NucleusGrade.Grade3 => "3", 
			NucleusGrade.Grade2 => "2", 
			NucleusGrade.Grade1 => "1", 
			_ => "0", 
		};
	}

	public static NucleusGrade XpToGrade(float xp)
	{
		if (xp >= NucleusXpThresholds[NucleusGrade.Grade1])
		{
			return NucleusGrade.Grade1;
		}
		if (xp >= NucleusXpThresholds[NucleusGrade.Grade2])
		{
			return NucleusGrade.Grade2;
		}
		return NucleusGrade.Grade3;
	}

	public static float XpToNextGrade(float currentXp)
	{
		NucleusGrade key;
		switch (XpToGrade(currentXp))
		{
		case NucleusGrade.Grade3:
			key = NucleusGrade.Grade2;
			break;
		case NucleusGrade.Grade2:
			key = NucleusGrade.Grade1;
			break;
		default:
			return 0f;
		}
		return NucleusXpThresholds[key] - currentXp;
	}
}


public enum NucleusGrade
{
	Grade3,
	Grade2,
	Grade1
}


using System.Text;
using Rust.UI;

public class NucleusInformationPanel : ItemInformationPanel
{
	public InfoBar xpDisplay;

	public RustText gradeLabel;

	public RustText nextLevelLabel;

	public static readonly Phrase GradePhrase = new Phrase("nucleus.grade", "GRADE {0}");

	public static readonly Phrase XPPhrase = new Phrase("nucleus.xp", "{0} XP");

	public static readonly Phrase XPRequiredPhrase = new Phrase("nucleus.required", "{0} XP REQUIRED");

	public static readonly Phrase MaxPhrase = new Phrase("nucleus.max", "MAX LEVEL");

	private static StringBuilder builder;
}


using UnityEngine;

public class FoodIcon : MonoBehaviour, IEditorComponent
{
	public ItemDefinition FoodItem;
}


using UnityEngine;

public class InstrumentStateBehaviour : StateMachineBehaviour
{
}


using UnityEngine;

public class InstrumentViewmodel : MonoBehaviour
{
	public Animator ViewAnimator;

	public bool UpdateA = true;

	public bool UpdateB = true;

	public bool UpdateC = true;

	public bool UpdateD = true;

	public bool UpdateE = true;

	public bool UpdateF = true;

	public bool UpdateG = true;

	public bool UpdateRecentlyPlayed = true;

	public bool UpdatePlayedNoteTrigger;

	public bool UseTriggers;

	private readonly int note_a = Animator.StringToHash("play_A");

	private readonly int note_b = Animator.StringToHash("play_B");

	private readonly int note_c = Animator.StringToHash("play_C");

	private readonly int note_d = Animator.StringToHash("play_D");

	private readonly int note_e = Animator.StringToHash("play_E");

	private readonly int note_f = Animator.StringToHash("play_F");

	private readonly int note_g = Animator.StringToHash("play_G");

	private readonly int recentlyPlayedHash = Animator.StringToHash("recentlyPlayed");

	private readonly int playedNoteHash = Animator.StringToHash("playedNote");

	public void UpdateSlots(InstrumentKeyController.AnimationSlot currentSlot, bool recentlyPlayed, bool playedNoteThisFrame)
	{
		if (!((Object)(object)ViewAnimator == (Object)null))
		{
			if (UpdateA)
			{
				UpdateState(note_a, currentSlot == InstrumentKeyController.AnimationSlot.One);
			}
			if (UpdateB)
			{
				UpdateState(note_b, currentSlot == InstrumentKeyController.AnimationSlot.Two);
			}
			if (UpdateC)
			{
				UpdateState(note_c, currentSlot == InstrumentKeyController.AnimationSlot.Three);
			}
			if (UpdateD)
			{
				UpdateState(note_d, currentSlot == InstrumentKeyController.AnimationSlot.Four);
			}
			if (UpdateE)
			{
				UpdateState(note_e, currentSlot == InstrumentKeyController.AnimationSlot.Five);
			}
			if (UpdateF)
			{
				UpdateState(note_f, currentSlot == InstrumentKeyController.AnimationSlot.Six);
			}
			if (UpdateG)
			{
				UpdateState(note_g, currentSlot == InstrumentKeyController.AnimationSlot.Seven);
			}
			if (UpdateRecentlyPlayed)
			{
				ViewAnimator.SetBool(recentlyPlayedHash, recentlyPlayed);
			}
			if (UpdatePlayedNoteTrigger && playedNoteThisFrame)
			{
				ViewAnimator.SetTrigger(playedNoteHash);
			}
		}
	}

	private void UpdateState(int param, bool state)
	{
		if (!UseTriggers)
		{
			ViewAnimator.SetBool(param, state);
		}
		else if (state)
		{
			ViewAnimator.SetTrigger(param);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Rust;
using Oxide.Core;
using UnityEngine;

public class BigWheelGame : SpinnerWheel
{
	public float baseSpeed = 180f;

	public float offset = 3.852f;

	public AnimationCurve decelerationCurve;

	public AnimationCurve speedCurve;

	public HitNumber[] hitNumbers;

	private float targetAngle;

	private float minimumSpinTime;

	private bool isSpinning;

	private bool decelerating;

	private float elapsedTime;

	private Random random;

	[ServerVar]
	public static float spinFrequencySeconds = 45f;

	public int spinNumber;

	protected int targetNumber;

	public int lastPaidSpinNumber = -1;

	public List<BigWheelBettingTerminal> terminals = new List<BigWheelBettingTerminal>();

	public override bool AllowPlayerSpins()
	{
		return false;
	}

	public override bool CanUpdateSign(BasePlayer player)
	{
		return false;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)InitBettingTerminals, 3f);
		((FacepunchBehaviour)this).Invoke((Action)DoSpin, 10f);
	}

	public void DoSpin()
	{
		int seed = Random.Range(int.MinValue, int.MaxValue);
		random = new Random(seed);
		targetNumber = random.Next(0, hitNumbers.Length);
		targetAngle = 0f - 360f / (float)hitNumbers.Length * (float)targetNumber + offset;
		targetAngle += (float)(random.NextDouble() * 12.0 - 6.0);
		minimumSpinTime = (float)(random.NextDouble() * 5.0 + 13.0);
		elapsedTime = 0f;
		isSpinning = true;
		decelerating = false;
		spinNumber++;
		SetTerminalsLocked(isLocked: true);
	}

	public void SetTerminalsLocked(bool isLocked)
	{
		foreach (BigWheelBettingTerminal terminal in terminals)
		{
			terminal.inventory.SetLocked(isLocked);
		}
	}

	public void RemoveTerminal(BigWheelBettingTerminal terminal)
	{
		terminals.Remove(terminal);
	}

	public void InitBettingTerminals()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		terminals.Clear();
		Vis.Entities(((Component)this).transform.position, 30f, terminals, 256, (QueryTriggerInteraction)2);
		terminals = terminals.Distinct().ToList();
	}

	public float GetMaxSpinSpeed(float time)
	{
		return baseSpeed * speedCurve.Evaluate(time / minimumSpinTime);
	}

	public override void Update_Server()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		if (!isSpinning)
		{
			return;
		}
		float deltaTime = Time.deltaTime;
		elapsedTime += deltaTime;
		float num = NormalizeAngle(wheel.localEulerAngles.y);
		float num2 = NormalizeAngle(targetAngle);
		float num3 = (num2 - num + 360f) % 360f;
		if (!decelerating && (elapsedTime < minimumSpinTime || num3 < 120f))
		{
			float maxSpinSpeed = GetMaxSpinSpeed(elapsedTime);
			wheel.Rotate(((Component)this).transform.up, maxSpinSpeed * deltaTime, (Space)0);
		}
		else
		{
			decelerating = true;
			float num4 = decelerationCurve.Evaluate(num3 / 180f);
			float num5 = GetMaxSpinSpeed(elapsedTime) * num4 * deltaTime;
			if (num5 > num3)
			{
				num5 = num3;
			}
			wheel.Rotate(((Component)this).transform.up, num5, (Space)0);
			if (num3 < 0.1f)
			{
				wheel.localRotation = Quaternion.Euler(0f, num2, 0f);
				isSpinning = false;
				if (spinNumber > lastPaidSpinNumber)
				{
					Payout();
					lastPaidSpinNumber = spinNumber;
					QueueSpin();
				}
			}
		}
		SendNetworkUpdate();
	}

	private float NormalizeAngle(float angle)
	{
		angle %= 360f;
		if (angle < 0f)
		{
			angle += 360f;
		}
		return angle;
	}

	public float SpinSpacing()
	{
		return spinFrequencySeconds;
	}

	public void QueueSpin()
	{
		foreach (BigWheelBettingTerminal terminal in terminals)
		{
			terminal.ClientRPC(RpcTarget.NetworkGroup("SetTimeUntilNextSpin"), SpinSpacing());
		}
		((FacepunchBehaviour)this).Invoke((Action)DoSpin, SpinSpacing());
	}

	public void Payout()
	{
		HitNumber currentHitType = GetCurrentHitType();
		Guid value = Guid.NewGuid();
		foreach (BigWheelBettingTerminal terminal in terminals)
		{
			if (terminal.isClient)
			{
				continue;
			}
			bool flag = false;
			bool flag2 = false;
			Item slot = terminal.inventory.GetSlot((int)currentHitType.hitType);
			if (slot != null)
			{
				int num = currentHitType.ColorToMultiplier(currentHitType.hitType);
				int amount = slot.amount;
				if (Interface.CallHook("OnBigWheelWin", (object)this, (object)slot, (object)terminal, (object)num) == null)
				{
					slot.amount += slot.amount * num;
					slot.RemoveFromContainer();
					slot.MoveToContainer(terminal.inventory, 5);
					flag = true;
					Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, amount, slot.amount, value);
				}
			}
			for (int i = 0; i < 5; i++)
			{
				Item slot2 = terminal.inventory.GetSlot(i);
				if (slot2 != null && Interface.CallHook("OnBigWheelLoss", (object)this, (object)slot2, (object)terminal) == null)
				{
					Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, slot2.amount, 0, value);
					slot2.Remove();
					flag2 = true;
				}
			}
			if (flag || flag2)
			{
				terminal.ClientRPC(RpcTarget.NetworkGroup("WinOrLoseSound"), flag);
			}
		}
		ItemManager.DoRemoves();
		SetTerminalsLocked(isLocked: false);
	}

	public HitNumber GetCurrentHitType()
	{
		return hitNumbers[targetNumber];
	}
}


using UnityEngine;

public class HitNumber : MonoBehaviour
{
	public enum HitType
	{
		Yellow,
		Green,
		Blue,
		Purple,
		Red
	}

	public HitType hitType;

	public int ColorToMultiplier(HitType type)
	{
		return type switch
		{
			HitType.Yellow => 1, 
			HitType.Green => 3, 
			HitType.Blue => 5, 
			HitType.Purple => 10, 
			HitType.Red => 20, 
			_ => 0, 
		};
	}

	public void OnDrawGizmosSelected()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.white;
		Gizmos.DrawSphere(((Component)this).transform.position, 0.025f);
	}
}


public enum HitType
{
	Yellow,
	Green,
	Blue,
	Purple,
	Red
}


using Rust.UI;

public class LootPanelBigWheelTerminal : LootPanel
{
	public RustText timeRemainingText;
}


using UnityEngine.UI;

public class SlotMachineLootPanel : LootPanel
{
	public Text spinsRemainingText;

	public Text multiplierText;

	public LocalizeText ScrapCostText;
}


using UnityEngine;

public class SlotMachinePayoutDisplay : MonoBehaviour
{
	public GameObjectRef PayoutWidget;

	public RectTransform WidgetRoot;

	public Sprite[] FaceSprites;
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Slot Machine Payouts")]
public class SlotMachinePayoutSettings : ScriptableObject
{
	[Serializable]
	public struct PayoutInfo
	{
		public ItemAmount Item;

		[Range(0f, 15f)]
		public int Result1;

		[Range(0f, 15f)]
		public int Result2;

		[Range(0f, 15f)]
		public int Result3;

		public GameObjectRef OverrideWinEffect;
	}

	[Serializable]
	public struct IndividualPayouts
	{
		public ItemAmount Item;

		[Range(0f, 15f)]
		public int Result;
	}

	public ItemAmount SpinCost;

	public PayoutInfo[] Payouts;

	public int[] VirtualFaces = new int[16];

	public IndividualPayouts[] FacePayouts = new IndividualPayouts[0];

	public int TotalStops;

	public GameObjectRef DefaultWinEffect;
}


using System;
using UnityEngine;

[Serializable]
public struct PayoutInfo
{
	public ItemAmount Item;

	[Range(0f, 15f)]
	public int Result1;

	[Range(0f, 15f)]
	public int Result2;

	[Range(0f, 15f)]
	public int Result3;

	public GameObjectRef OverrideWinEffect;
}


using System;
using UnityEngine;

[Serializable]
public struct IndividualPayouts
{
	public ItemAmount Item;

	[Range(0f, 15f)]
	public int Result;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class SlotMachinePayoutWidget : MonoBehaviour
{
	public RustText PayoutAmount;

	public GameObject AnyText;

	public Image[] Faces;
}


using UnityEngine;

public class ChineseLantern : BaseFuelLightSource
{
	public Transform pivotRotator;

	public float swaySpeed = 1f;

	public float swayDistance = 0.25f;

	public float lerpSpeed = 2f;
}


using System;
using Rust;
using UnityEngine;

public class SkyLantern : StorageContainer, IIgniteable
{
	public float gravityScale = -0.1f;

	public float travelSpeed = 2f;

	public float collisionRadius = 0.5f;

	public float rotationSpeed = 5f;

	public float randOffset = 1f;

	public float lifeTime = 120f;

	public float hoverHeight = 14f;

	public Transform collisionCheckPoint;

	private float idealAltitude;

	private Vector3 travelVec = Vector3.forward;

	private float takeOffY;

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override void ServerInit()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		randOffset = ((Random.Range(0.5f, 1f) * (float)Random.Range(0, 2) == 1f) ? (-1f) : 1f);
		Vector3 val = Vector3.forward + Vector3.right * randOffset;
		travelVec = ((Vector3)(ref val)).normalized;
		((FacepunchBehaviour)this).Invoke((Action)StartSinking, lifeTime - 15f);
		((FacepunchBehaviour)this).Invoke((Action)SelfDestroy, lifeTime);
		travelSpeed = Random.Range(1.75f, 2.25f);
		gravityScale *= Random.Range(1f, 1.25f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateIdealAltitude, 0f, 1f);
	}

	public void Ignite(Vector3 fromPos)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).gameObject.transform.RemoveComponent<GroundWatch>();
		((Component)this).gameObject.transform.RemoveComponent<DestroyOnGroundMissing>();
		((Component)this).gameObject.layer = 14;
		takeOffY = ((Component)this).transform.position.y;
		travelVec = Vector3Ex.Direction2D(((Component)this).transform.position, fromPos);
		SetFlag(Flags.On, b: true);
		UpdateIdealAltitude();
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.OnAttacked(info);
		if (base.isServer)
		{
			if (info.damageTypes.Has(DamageType.Heat) && CanIgnite())
			{
				Ignite(info.PointStart);
			}
			else if (IsOn() && !IsBroken())
			{
				StartSinking();
			}
		}
	}

	public void SelfDestroy()
	{
		Kill();
	}

	public bool CanIgnite()
	{
		if (!IsOn())
		{
			return !IsBroken();
		}
		return false;
	}

	public void UpdateIdealAltitude()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (IsOn())
		{
			idealAltitude = WaterLevel.GetWaterOrTerrainSurface(((Component)this).transform.position, waves: false, volumes: false) + hoverHeight;
			if (takeOffY > idealAltitude)
			{
				idealAltitude = takeOffY + hoverHeight;
			}
			if (hoverHeight != 0f)
			{
				idealAltitude -= 2f * Mathf.Abs(randOffset);
			}
		}
	}

	public void StartSinking()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (!IsBroken())
		{
			hoverHeight = 0f;
			travelVec = Vector3.zero;
			UpdateIdealAltitude();
			SetFlag(Flags.Broken, b: true);
		}
	}

	public void FixedUpdate()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient && IsOn())
		{
			float num = Mathf.Abs(((Component)this).transform.position.y - idealAltitude);
			float num2 = ((((Component)this).transform.position.y < idealAltitude) ? (-1f) : 1f);
			float num3 = Mathf.InverseLerp(0f, 10f, num) * num2;
			if (IsBroken())
			{
				travelVec = Vector3.Lerp(travelVec, Vector3.zero, Time.fixedDeltaTime * 0.5f);
				num3 = 0.7f;
			}
			Vector3 zero = Vector3.zero;
			zero = Vector3.up * gravityScale * Physics.gravity.y * num3;
			zero += travelVec * travelSpeed;
			Vector3 val = ((Component)this).transform.position + zero * Time.fixedDeltaTime;
			Vector3 val2 = Vector3Ex.Direction(val, ((Component)this).transform.position);
			float num4 = Vector3.Distance(val, ((Component)this).transform.position);
			RaycastHit val3 = default(RaycastHit);
			if (!Physics.SphereCast(collisionCheckPoint.position, collisionRadius, val2, ref val3, num4, 1218519297))
			{
				((Component)this).transform.position = val;
				((Component)this).transform.Rotate(Vector3.up, rotationSpeed * randOffset * Time.deltaTime, (Space)1);
			}
			else
			{
				StartSinking();
			}
		}
	}
}


using UnityEngine;

public class FirecrackerRepeater : BaseMonoBehaviour, IClientComponent
{
	public GameObjectRef singleExplosionEffect;

	public Transform[] parts;

	public float partWidth = 0.2f;

	public float partLength = 0.1f;

	public Quaternion[] targetRotations;

	public Quaternion[] initialRotations;

	public Renderer[] renderers;

	public Material materialSource;

	public float explodeRepeatMin = 0.05f;

	public float explodeRepeatMax = 0.15f;

	public float explodeLerpSpeed = 30f;

	public Vector3 twistAmount;

	public float fuseLength = 3f;

	public float explodeStrength = 10f;

	public float explodeDirBlend = 0.5f;

	public float duration = 10f;

	public ParticleSystemContainer smokeParticle;
}


using UnityEngine;

public class StringFirecracker : TimedExplosive
{
	public Rigidbody serverRigidBody;

	public Rigidbody clientMiddleBody;

	public Rigidbody[] clientParts;

	public SpringJoint serverClientJoint;

	public Transform clientFirecrackerTransform;

	public override void InitShared()
	{
		base.InitShared();
		if (!base.isServer)
		{
			return;
		}
		Rigidbody[] array = clientParts;
		foreach (Rigidbody val in array)
		{
			if ((Object)(object)val != (Object)null)
			{
				val.isKinematic = true;
			}
		}
	}

	public void CreatePinJoint()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)serverClientJoint != (Object)null))
		{
			serverClientJoint = ((Component)this).gameObject.AddComponent<SpringJoint>();
			((Joint)serverClientJoint).connectedBody = clientMiddleBody;
			((Joint)serverClientJoint).autoConfigureConnectedAnchor = false;
			((Joint)serverClientJoint).anchor = Vector3.zero;
			((Joint)serverClientJoint).connectedAnchor = Vector3.zero;
			serverClientJoint.minDistance = 0f;
			serverClientJoint.maxDistance = 1f;
			serverClientJoint.damper = 1000f;
			serverClientJoint.spring = 5000f;
			((Joint)serverClientJoint).enableCollision = false;
			((Joint)serverClientJoint).enablePreprocessing = false;
		}
	}
}


public class ArcadeClientAuthTest : ArcadeEntityController
{
	public float speed = 0.2f;

	public float maxSpeed = 1f;

	public BaseArcadeGame myGame;

	public ArcadeEntity myEntity;
}


using System;
using UnityEngine;

public class ArcadeEntity : BaseMonoBehaviour
{
	public uint id;

	public uint spriteID;

	public uint soundID;

	public bool visible;

	public Vector3 heading = new Vector3(0f, 1f, 0f);

	public bool isEnabled;

	public bool dirty;

	public float alpha = 1f;

	public BoxCollider boxCollider;

	public bool host;

	public bool localAuthorativeOverride;

	public ArcadeEntity arcadeEntityParent;

	public uint prefabID;

	[Header("Health")]
	public bool takesDamage;

	public float health = 1f;

	public float maxHealth = 1f;

	[NonSerialized]
	public bool mapLoadedEntiy;
}


using UnityEngine;

public class ArcadeEntityController : BaseMonoBehaviour
{
	public BaseArcadeGame parentGame;

	public ArcadeEntity arcadeEntity;

	public ArcadeEntity sourceEntity;

	public Vector3 heading
	{
		get
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return arcadeEntity.heading;
		}
		set
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			arcadeEntity.heading = value;
		}
	}

	public Vector3 positionLocal
	{
		get
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			return ((Component)arcadeEntity).transform.localPosition;
		}
		set
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			((Component)arcadeEntity).transform.localPosition = value;
		}
	}

	public Vector3 positionWorld
	{
		get
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			return ((Component)arcadeEntity).transform.position;
		}
		set
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			((Component)arcadeEntity).transform.position = value;
		}
	}
}


using UnityEngine;

public class ArcadeNetworkTrigger : TriggerBase
{
	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class BaseArcadeGame : BaseMonoBehaviour
{
	public static List<BaseArcadeGame> globalActiveGames = new List<BaseArcadeGame>();

	public Camera cameraToRender;

	public RenderTexture renderTexture;

	public Texture2D distantTexture;

	public Transform center;

	public int frameRate = 30;

	public Dictionary<uint, ArcadeEntity> activeArcadeEntities = new Dictionary<uint, ArcadeEntity>();

	public Sprite[] spriteManifest;

	public ArcadeEntity[] entityManifest;

	public bool clientside;

	public bool clientsideInput = true;

	public const int spriteIndexInvisible = 1555;

	public GameObject arcadeEntityPrefab;

	public BaseArcadeMachine ownerMachine;

	public static int gameOffsetIndex = 0;

	private bool isAuthorative;

	public Canvas canvas;

	public BasePlayer GetHostPlayer()
	{
		if (Object.op_Implicit((Object)(object)ownerMachine))
		{
			return ownerMachine.GetDriver();
		}
		return null;
	}
}


using System;
using UnityEngine;

public class BossFormController : ArcadeEntityController
{
	[Serializable]
	public class BossDamagePoint
	{
		public BoxCollider hitBox;

		public float health;

		public ArcadeEntityController damagePrefab;

		public ArcadeEntityController damageInstance;

		public bool destroyed;
	}

	public float animationSpeed = 0.5f;

	public Sprite[] animationFrames;

	public Vector2 roamDistance;

	public Transform colliderParent;

	public BossDamagePoint[] damagePoints;

	public ArcadeEntityController flashController;

	public float health = 50f;
}


using System;
using UnityEngine;

[Serializable]
public class BossDamagePoint
{
	public BoxCollider hitBox;

	public float health;

	public ArcadeEntityController damagePrefab;

	public ArcadeEntityController damageInstance;

	public bool destroyed;
}


using UnityEngine;

public class ChippyArcadeGame : BaseArcadeGame
{
	public ChippyMainCharacter mainChar;

	public SpriteArcadeEntity mainCharAim;

	public ChippyBoss currentBoss;

	public ChippyBoss[] bossPrefabs;

	public SpriteArcadeEntity mainMenuLogo;

	public Transform respawnPoint;

	public Vector2 mouseAim = new Vector2(0f, 1f);

	public TextArcadeEntity levelIndicator;

	public TextArcadeEntity gameOverIndicator;

	public TextArcadeEntity playGameButton;

	public TextArcadeEntity highScoresButton;

	public bool OnMainMenu;

	public bool GameActive;

	public int level;

	public TextArcadeEntity[] scoreDisplays;

	public MenuButtonArcadeEntity[] mainMenuButtons;

	public int selectedButtonIndex;

	public bool OnHighScores;
}


using System;
using UnityEngine;

public class ChippyBoss : SpriteArcadeEntity
{
	[Serializable]
	public class BossDamagePoint
	{
		public BoxCollider hitBox;

		public float health;

		public ArcadeEntityController damagePrefab;

		public ArcadeEntityController damageInstance;

		public bool destroyed;
	}

	public Vector2 roamDistance;

	public float animationSpeed = 0.5f;

	public Sprite[] animationFrames;

	public ArcadeEntity bulletTest;

	public SpriteRenderer flashRenderer;

	public BossDamagePoint[] damagePoints;
}


using System;
using UnityEngine;

[Serializable]
public class BossDamagePoint
{
	public BoxCollider hitBox;

	public float health;

	public ArcadeEntityController damagePrefab;

	public ArcadeEntityController damageInstance;

	public bool destroyed;
}


public class ChippyBulletEntity : SpriteArcadeEntity
{
	public float speed = 4f;

	public float maxSpeed = 4f;

	public float radius;

	public float damage = 1f;

	public ArcadeEntity bulletImpact;
}


using UnityEngine;

public class ChippyMainCharacter : SpriteArcadeEntity
{
	public float speed;

	public float maxSpeed = 0.25f;

	public ChippyBulletEntity bulletPrefab;

	public float fireRate = 0.1f;

	public Vector3 aimDir = Vector3.up;
}


using UnityEngine;

public class ChippyMoveTest : MonoBehaviour
{
	public Vector3 heading = new Vector3(0f, 1f, 0f);

	public float speed = 0.2f;

	public float maxSpeed = 1f;

	private void FixedUpdate()
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		float num = ((Mathf.Abs(((Vector3)(ref heading)).magnitude) > 0f) ? 1f : 0f);
		speed = Mathf.MoveTowards(speed, maxSpeed * num, Time.fixedDeltaTime * ((num == 0f) ? 2f : 2f));
		Vector3 position = ((Component)this).transform.position;
		Vector3 val = new Vector3(heading.x, heading.y, 0f);
		Ray val2 = default(Ray);
		((Ray)(ref val2))..ctor(position, ((Vector3)(ref val)).normalized);
		if (!Physics.Raycast(val2, speed * Time.fixedDeltaTime, 16777216))
		{
			Transform transform = ((Component)this).transform;
			transform.position += ((Ray)(ref val2)).direction * Time.fixedDeltaTime * speed;
			if (Mathf.Abs(((Vector3)(ref heading)).magnitude) > 0f)
			{
				Transform transform2 = ((Component)this).transform;
				Vector3 forward = ((Component)this).transform.forward;
				val = new Vector3(heading.x, heading.y, 0f);
				transform2.rotation = QuaternionEx.LookRotationForcedUp(forward, ((Vector3)(ref val)).normalized);
			}
		}
	}
}


using System;
using UnityEngine;

public class DestroyArcadeEntity : BaseMonoBehaviour
{
	public ArcadeEntity ent;

	public float TimeToDie = 1f;

	public float TimeToDieVariance;

	private void Start()
	{
		((FacepunchBehaviour)this).Invoke((Action)DestroyAction, TimeToDie, TimeToDieVariance * 0.5f);
	}

	private void DestroyAction()
	{
		if (((Object)(object)ent != (Object)null) & ent.host)
		{
			Object.Destroy((Object)(object)((Component)ent).gameObject);
		}
	}
}


public class MenuButtonArcadeEntity : TextArcadeEntity
{
	public string titleText = "";

	public string selectionSuffix = " - ";

	public string clickMessage = "";

	public bool IsHighlighted()
	{
		return alpha == 1f;
	}
}


using UnityEngine;

public class SpriteArcadeEntity : ArcadeEntity
{
	public SpriteRenderer spriteRenderer;
}


public class ArcadeTennisPaddle : ArcadeEntity
{
}


using UnityEngine;

public class TennisArcadeGame : BaseArcadeGame
{
	public ArcadeEntity paddle1;

	public ArcadeEntity paddle2;

	public ArcadeEntity ball;

	public Transform paddle1Origin;

	public Transform paddle2Origin;

	public Transform paddle1Goal;

	public Transform paddle2Goal;

	public Transform ballSpawn;

	public float maxScore = 5f;

	public ArcadeEntity[] paddle1ScoreNodes;

	public ArcadeEntity[] paddle2ScoreNodes;

	public int paddle1Score;

	public int paddle2Score;

	public float sensitivity = 1f;

	public ArcadeEntity logo;

	public bool OnMainMenu;

	public bool GameActive;
}


public class TennisBall : SpriteArcadeEntity
{
	public float speed = 2f;

	public float maxSpeed = 2f;
}


using TMPro;

public class TextArcadeEntity : ArcadeEntity
{
	public TextMeshProUGUI text;
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class HeadEntity : BaseEntity
{
	public HeadData CurrentTrophyData;

	private const Wearable.OccupationSlots HeadMask = Wearable.OccupationSlots.HeadTop | Wearable.OccupationSlots.Face | Wearable.OccupationSlots.HeadBack | Wearable.OccupationSlots.Mouth | Wearable.OccupationSlots.Eyes;

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.headData == null && CurrentTrophyData != null)
		{
			info.msg.headData = Pool.Get<HeadData>();
			CurrentTrophyData.CopyTo(info.msg.headData);
		}
	}

	public void SetupSourceId(uint sourceID)
	{
		InitTrophyData();
		CurrentTrophyData.entitySource = sourceID;
		CurrentTrophyData.horseBreed = 0;
		CurrentTrophyData.playerId = 0uL;
		CurrentTrophyData.playerName = string.Empty;
		CurrentTrophyData.clothing?.Clear();
	}

	public void SetupPlayerId(string playerName, ulong playerId)
	{
		InitTrophyData();
		CurrentTrophyData.playerName = playerName;
		CurrentTrophyData.playerId = playerId;
	}

	public void AssignClothing(ItemContainer container)
	{
		InitTrophyData();
		if (CurrentTrophyData.clothing == null)
		{
			CurrentTrophyData.clothing = Pool.Get<List<int>>();
		}
		ItemModWearable itemModWearable = default(ItemModWearable);
		foreach (Item item in container.itemList)
		{
			if (((Component)item.info).TryGetComponent<ItemModWearable>(ref itemModWearable) && itemModWearable.entityPrefab.isValid)
			{
				Wearable component = itemModWearable.entityPrefab.Get().GetComponent<Wearable>();
				if ((component.occupationOver & (Wearable.OccupationSlots.HeadTop | Wearable.OccupationSlots.Face | Wearable.OccupationSlots.HeadBack | Wearable.OccupationSlots.Mouth | Wearable.OccupationSlots.Eyes)) != 0 || component.occupationOver == (Wearable.OccupationSlots)0)
				{
					CurrentTrophyData.clothing.Add(item.info.itemid);
				}
			}
		}
	}

	public void AssignHorseBreed(int breed)
	{
		InitTrophyData();
		CurrentTrophyData.horseBreed = breed;
	}

	private void InitTrophyData()
	{
		if (CurrentTrophyData == null)
		{
			CurrentTrophyData = Pool.Get<HeadData>();
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.headData != null)
		{
			InitTrophyData();
			info.msg.headData.CopyTo(CurrentTrophyData);
		}
		else if (CurrentTrophyData != null)
		{
			Pool.Free<HeadData>(ref CurrentTrophyData);
		}
	}

	public GameObject GetHeadSource()
	{
		if (CurrentTrophyData == null)
		{
			return null;
		}
		return GameManager.server.FindPrefab(CurrentTrophyData.entitySource);
	}
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class RockingChair : BaseChair
{
	[Header("Rocking Settings")]
	public float Acceleration = 0.8f;

	public float MaxRockingAngle = 9f;

	public float MaxRockVelocity = 4f;

	[Tooltip("Preserve and apply some existing velocity when swinging back and forth.")]
	public bool ApplyVelocityBetweenSwings = true;

	[Range(0f, 2f)]
	public float AppliedVelocity = 1f;

	[Range(0f, 2f)]
	public float WeaponFireImpact = 3f;

	[Header("Audio")]
	public SoundDefinition creakForwardSoundDef;

	public SoundDefinition creakBackwardSoundDef;

	public float creakForwardAngle = 0.1f;

	public float creakBackwardAngle = -0.1f;

	public float creakVelocityThreshold = 0.02f;

	public AnimationCurve creakGainCurve;

	private float initLocalY;

	private Vector3 initLocalRot;

	private float velocity;

	private float oppositePotentialVelocity;

	private TimeSince timeSinceInput;

	private float sineTime;

	private float timeUntilStartSine = 0.4f;

	private float t;

	private float angle;

	private Quaternion max;

	private Quaternion min;

	public override void ServerInit()
	{
		base.ServerInit();
		SaveBaseLocalPos();
		ResetChair();
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		((FacepunchBehaviour)this).Invoke((Action)SaveBaseLocalPos, 0f);
	}

	private void SaveBaseLocalPos()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		Quaternion localRotation = ((Component)this).transform.localRotation;
		initLocalRot = ((Quaternion)(ref localRotation)).eulerAngles;
		initLocalY = ((Component)this).transform.localPosition.y;
		max = Quaternion.Euler(initLocalRot) * Quaternion.AngleAxis(MaxRockingAngle, Vector3.right);
		min = Quaternion.Euler(initLocalRot) * Quaternion.AngleAxis(0f - MaxRockingAngle, Vector3.right);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.rockingChair = Pool.Get<RockingChair>();
		info.msg.rockingChair.initEuler = initLocalRot;
		info.msg.rockingChair.initY = initLocalY;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.rockingChair != null && base.isServer)
		{
			initLocalRot = info.msg.rockingChair.initEuler;
			((Component)this).transform.localRotation = Quaternion.Euler(initLocalRot);
			initLocalY = info.msg.rockingChair.initY;
			if (initLocalY == 0f)
			{
				initLocalY = ((Component)this).transform.localPosition.y;
			}
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		float timeSinceLastTick = player.timeSinceLastTick;
		Vector2 inputVector = GetInputVector(inputState);
		CalculateVelocity(inputVector);
		bool flag = !Mathf.Approximately(inputVector.y, 0f);
		if (flag)
		{
			timeSinceInput = TimeSince.op_Implicit(0f);
			sineTime = 0f;
		}
		else if (TimeSince.op_Implicit(timeSinceInput) > timeUntilStartSine)
		{
			angle = Mathf.Lerp(0f - MaxRockingAngle, MaxRockingAngle, t);
		}
		sineTime += player.timeSinceLastTick * 180f;
		PreventClipping(flag);
		ApplyVelocity(timeSinceLastTick, flag);
	}

	public override void OnWeaponFired(BaseProjectile weapon)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)weapon == (Object)null))
		{
			if ((Object)(object)weapon.recoil != (Object)null)
			{
				velocity += weapon.recoil.recoilPitchMax * WeaponFireImpact;
			}
			timeSinceInput = TimeSince.op_Implicit(0f);
			sineTime = 0f;
		}
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		base.OnPlayerDismounted(player);
		ResetChair();
	}

	private void PreventClipping(bool hasInput)
	{
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		float num = initLocalY + 0.06f;
		float num2 = Mathx.RemapValClamped(Mathf.Abs(angle), 0f, MaxRockingAngle, 0f, 1f);
		if (num2 > 0.7f)
		{
			((Component)this).transform.localPosition = Mathx.Lerp(new Vector3(((Component)this).transform.localPosition.x, initLocalY, ((Component)this).transform.localPosition.z), new Vector3(((Component)this).transform.localPosition.x, num, ((Component)this).transform.localPosition.z), 1.5f, num2);
		}
		else
		{
			((Component)this).transform.localPosition = Mathx.Lerp(((Component)this).transform.localPosition, new Vector3(((Component)this).transform.localPosition.x, initLocalY, ((Component)this).transform.localPosition.z), 1.5f, Time.deltaTime);
		}
	}

	private void CalculateVelocity(Vector2 currentInput)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		velocity += currentInput.y * Acceleration;
		velocity = Mathf.Clamp(velocity, 0f - MaxRockVelocity, MaxRockVelocity);
		oppositePotentialVelocity = (0f - velocity) * AppliedVelocity;
		int signZero = Mathx.GetSignZero(currentInput.y, true);
		int signZero2 = Mathx.GetSignZero(velocity, true);
		if (ApplyVelocityBetweenSwings && Mathf.Abs(velocity) > 0.3f && Mathx.HasSignFlipped(signZero, signZero2))
		{
			velocity += oppositePotentialVelocity;
		}
	}

	private void ApplyVelocity(float delta, bool hasInput)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		t = Mathf.Sin(sineTime * (MathF.PI / 180f));
		t = Mathx.RemapValClamped(t, -1f, 1f, 0f, 1f);
		t = EaseOutCubicOvershoot(t, 0.2f);
		t = Mathf.Lerp(t, 0.5f, Mathf.Clamp01(TimeSince.op_Implicit(timeSinceInput) / 10f));
		angle += velocity;
		angle = Mathf.Clamp(angle, 0f - MaxRockingAngle, MaxRockingAngle);
		Quaternion val = Quaternion.Euler(initLocalRot) * Quaternion.AngleAxis(angle, Vector3.right);
		Quaternion val2 = Quaternion.Slerp(min, max, t);
		float num = ((!hasInput && TimeSince.op_Implicit(timeSinceInput) > timeUntilStartSine) ? 1 : 0);
		Quaternion val3 = Quaternion.Slerp(val, val2, num);
		((Component)this).transform.localRotation = Quaternion.Slerp(((Component)this).transform.localRotation, val3, delta * 3f);
	}

	private void ResetChair()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.localRotation = Quaternion.Euler(initLocalRot);
		((Component)this).transform.localPosition = new Vector3(((Component)this).transform.localPosition.x, initLocalY, ((Component)this).transform.localPosition.z);
	}

	private Vector2 GetInputVector(InputState inputState)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		bool rightDown = false;
		bool forwardDown = inputState.IsDown(BUTTON.FORWARD);
		bool backDown = inputState.IsDown(BUTTON.BACKWARD);
		return ProcessInputVector(leftDown: false, rightDown, forwardDown, backDown);
	}

	private static Vector2 ProcessInputVector(bool leftDown, bool rightDown, bool forwardDown, bool backDown)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		Vector2 zero = Vector2.zero;
		if (leftDown && rightDown)
		{
			leftDown = (rightDown = false);
		}
		if (forwardDown && backDown)
		{
			forwardDown = (backDown = false);
		}
		if (forwardDown)
		{
			zero.y = 1f;
		}
		else if (backDown)
		{
			zero.y = -1f;
		}
		if (rightDown)
		{
			zero.x = 1f;
		}
		else if (leftDown)
		{
			zero.x = -1f;
		}
		return zero;
	}

	private float EaseOutCubic(float value)
	{
		return 1f - Mathf.Pow(1f - Mathf.Clamp01(value), 3f);
	}

	private float EaseOutCubicOvershoot(float value, float overshoot)
	{
		return 1f - Mathf.Pow(1f - Mathf.Clamp01(value), 3f) * (1f + overshoot * (Mathf.Clamp01(value) - 1f));
	}
}


using UnityEngine;

public class DiveSite : JunkPile
{
	public Transform bobber;

	public override bool DespawnIfAnyLootTaken => false;

	public override float TimeoutPlayerCheckRadius()
	{
		return 80f;
	}
}


using System;
using UnityEngine;

public class DiveSiteBuoy : BaseEntity
{
	public float UpdateCullRange = 128f;

	public Vector3 RotationRate;

	public float InitialSpawnRange = 32f;

	private Action _updateAction;

	private Action updateAction => _updateAction ?? new Action(UpdateMovement);

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (!BaseNetworkable.HasCloseConnections(((Component)this).transform.position, InitialSpawnRange))
		{
			UpdateMovement();
		}
		((FacepunchBehaviour)this).InvokeRandomized((Action)CheckForNearbyPlayers, 0f, 10f, 5f);
	}

	private void CheckForNearbyPlayers()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		bool flag = BaseNetworkable.HasCloseConnections(((Component)this).transform.position, UpdateCullRange);
		if (flag && !((FacepunchBehaviour)this).IsInvoking(updateAction))
		{
			((FacepunchBehaviour)this).InvokeRepeating(updateAction, 0f, 0f);
		}
		else if (!flag && ((FacepunchBehaviour)this).IsInvoking(updateAction))
		{
			((FacepunchBehaviour)this).CancelInvoke(updateAction);
		}
	}

	private void UpdateMovement()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		Quaternion rotation = ((Component)this).transform.rotation;
		position.y = WaterLevel.GetWaterSurface(position, waves: true, volumes: false) + Mathf.Sin(Time.time * 3f) * 0.075f;
		rotation *= Quaternion.Euler(RotationRate * Time.deltaTime);
		((Component)this).transform.SetPositionAndRotation(position, rotation);
	}
}


using UnityEngine;

public class EggAmmoRepresentation : MonoBehaviour, IInventoryChanged, IClientComponent
{
	public GameObject[] eggAmmo;
}


using UnityEngine;

public class EggSwap : MonoBehaviour
{
	public Renderer[] eggRenderers;

	public void Show(int index)
	{
		HideAll();
		eggRenderers[index].enabled = true;
	}

	public void HideAll()
	{
		Renderer[] array = eggRenderers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = false;
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class EggHuntEvent : BaseHuntEvent
{
	public class EggHunter
	{
		public ulong userid;

		public string displayName;

		public int numEggs;
	}

	public float warmupTime = 10f;

	public float warnTime = 20f;

	public float timeAlive;

	public static EggHuntEvent serverEvent = null;

	public static EggHuntEvent clientEvent = null;

	public const int CAST_LAYERS = 10551297;

	[NonSerialized]
	public static float durationSeconds = 180f;

	public Dictionary<ulong, EggHunter> _eggHunters = new Dictionary<ulong, EggHunter>();

	public ItemAmount[] placementAwards;

	private Dictionary<ulong, List<CollectableEasterEgg>> _spawnedEggs = new Dictionary<ulong, List<CollectableEasterEgg>>();

	private readonly int maxEggPerPlayer = 25;

	private int initialSpawnIndex;

	private readonly Stopwatch stopwatch = new Stopwatch();

	private const int maxBatchSize = 1024;

	private const int initialMinEggPerPlayer = 4;

	private const int initialMaxEggPerPlayer = 6;

	private float eggSpawningFrameBudget = 1.5f;

	[ServerVar(Help = "Will spawn eggs for bots, only for debug purposes - don't enable it!")]
	public static bool includeBots = false;

	public static Phrase topBunnyPhrase = new Phrase("egghunt.result.topbunny", "{0} is the top bunny with {1} eggs collected.");

	public static Phrase noPlayersPhrase = new Phrase("egghunt.result.noplayers", "Wow, no one played so no one won.");

	public static Phrase placePhrase = new Phrase("egghunt.result.place", "You placed {0} of {1} with {2} eggs collected.");

	public static Phrase rewardPhrase = new Phrase("egghunt.result.reward", "You received {0}x {1} as an award!.");

	public bool IsEventActive()
	{
		if (timeAlive > warmupTime)
		{
			return timeAlive - warmupTime < durationSeconds;
		}
		return false;
	}

	public void Update()
	{
		timeAlive += Time.deltaTime;
		if (base.isServer && !base.IsDestroyed)
		{
			if (timeAlive - warmupTime > durationSeconds - warnTime)
			{
				SetFlag(Flags.Reserved1, b: true);
			}
			if (timeAlive - warmupTime > durationSeconds && !((FacepunchBehaviour)this).IsInvoking((Action)Cooldown) && Interface.CallHook("OnHuntEventEnd", (object)this) == null)
			{
				SetFlag(Flags.Reserved2, b: true);
				CleanupEggs();
				PrintWinnersAndAward();
				((FacepunchBehaviour)this).Invoke((Action)Cooldown, 10f);
			}
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer)
		{
			serverEvent = null;
		}
		else
		{
			clientEvent = null;
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (Object.op_Implicit((Object)(object)serverEvent) && base.isServer)
		{
			serverEvent.Kill();
			serverEvent = null;
		}
		serverEvent = this;
		SpawnEggs();
		((FacepunchBehaviour)this).Invoke((Action)StartEvent, warmupTime);
	}

	private void StartEvent()
	{
		if (Interface.CallHook("OnHuntEventStart", (object)this) == null)
		{
			int count = BasePlayer.activePlayerList.Count;
			if (includeBots)
			{
				count = GetCombinedPlayerList(wantBots: true).Count;
			}
			if (initialSpawnIndex <= count)
			{
				eggSpawningFrameBudget = float.PositiveInfinity;
			}
			EnableEggs();
		}
	}

	private void EnableEggs()
	{
		foreach (KeyValuePair<ulong, List<CollectableEasterEgg>> spawnedEgg in _spawnedEggs)
		{
			foreach (CollectableEasterEgg item in spawnedEgg.Value)
			{
				((Component)item).gameObject.SetActive(true);
				item.SetFlag(Flags.Disabled, b: false);
			}
		}
	}

	[ContextMenu("SpawnDebug")]
	public void SpawnEggs()
	{
		initialSpawnIndex = 0;
		((MonoBehaviour)this).StartCoroutine(SpawnInitialEggs());
	}

	private IEnumerator SpawnInitialEggs()
	{
		NativeArray<RaycastCommand> raycastCommands = new NativeArray<RaycastCommand>(1024, (Allocator)4, (NativeArrayOptions)1);
		NativeArray<RaycastHit> hits = new NativeArray<RaycastHit>(1024, (Allocator)4, (NativeArrayOptions)1);
		NativeArray<ulong> ownerIDs = new NativeArray<ulong>(1024, (Allocator)4, (NativeArrayOptions)1);
		Queue<(Vector3 position, ulong ownerID)> pendingSpawns = new Queue<(Vector3, ulong)>();
		ListHashSet<BasePlayer> playerList = BasePlayer.activePlayerList;
		if (includeBots)
		{
			playerList = GetCombinedPlayerList(wantBots: true);
		}
		while (initialSpawnIndex != playerList.Count)
		{
			stopwatch.Reset();
			stopwatch.Start();
			int commandIndex = 0;
			for (int i = initialSpawnIndex; i < playerList.Count; i++)
			{
				BasePlayer basePlayer = playerList[i];
				int num = Random.Range(4, 6) + Mathf.RoundToInt(basePlayer.eggVision);
				Vector3 position = ((Component)basePlayer).transform.position;
				for (int j = 0; j < num; j++)
				{
					Vector3 randomSpawnPoint = GetRandomSpawnPoint(position, Vector3.zero, 15f, 25f);
					randomSpawnPoint += Vector3.up * 100f;
					raycastCommands[commandIndex] = new RaycastCommand(randomSpawnPoint, Vector3.down, 105f, 10551297, 1);
					ownerIDs[commandIndex] = basePlayer.userID;
					commandIndex++;
					if (commandIndex >= 1024)
					{
						break;
					}
				}
				initialSpawnIndex++;
				if (commandIndex >= 1024 || stopwatch.Elapsed.TotalMilliseconds >= (double)eggSpawningFrameBudget)
				{
					break;
				}
			}
			if (commandIndex > 0)
			{
				JobHandle handle = RaycastCommand.ScheduleBatch(raycastCommands, hits, 1, default(JobHandle));
				yield return (object)new WaitUntil((Func<bool>)(() => ((JobHandle)(ref handle)).IsCompleted));
				((JobHandle)(ref handle)).Complete();
				for (int k = 0; k < commandIndex; k++)
				{
					RaycastCommand val = raycastCommands[k];
					Vector3 val2 = ((RaycastCommand)(ref val)).from;
					RaycastHit val3 = hits[k];
					if ((Object)(object)((RaycastHit)(ref val3)).collider == (Object)null)
					{
						val2.y = TerrainMeta.HeightMap.GetHeight(val2);
					}
					else
					{
						val3 = hits[k];
						val2 = ((RaycastHit)(ref val3)).point;
					}
					pendingSpawns.Enqueue((val2, ownerIDs[k]));
				}
			}
			yield return CoroutineEx.waitForEndOfFrame;
		}
		while (pendingSpawns.Count > 0)
		{
			stopwatch.Reset();
			stopwatch.Start();
			while (pendingSpawns.Count > 0 && stopwatch.Elapsed.TotalMilliseconds < (double)eggSpawningFrameBudget)
			{
				(Vector3 position, ulong ownerID) tuple = pendingSpawns.Dequeue();
				Vector3 item = tuple.position;
				ulong item2 = tuple.ownerID;
				CollectableEasterEgg collectableEasterEgg = SpawnEggAtPoint(item, active: false);
				collectableEasterEgg.ownerUserID = item2;
				collectableEasterEgg.SetFlag(Flags.Disabled, b: true, recursive: false, networkupdate: false);
				collectableEasterEgg.Spawn();
				TryGetPlayerEggs(item2).Add(collectableEasterEgg);
			}
			yield return CoroutineEx.waitForEndOfFrame;
		}
		raycastCommands.Dispose();
		hits.Dispose();
		ownerIDs.Dispose();
	}

	private CollectableEasterEgg SpawnEggAtPoint(Vector3 pos, bool active)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if ((TerrainMeta.TopologyMap.GetTopology(pos) & 0x14080) != 0)
		{
			float waterLevel = WaterLevel.GetWaterLevel(pos, waves: false);
			if (waterLevel > TerrainMeta.HeightMap.GetHeight(pos) && pos.y < waterLevel)
			{
				pos.y = waterLevel;
			}
		}
		GameManager server = GameManager.server;
		string strPrefab = HuntableResourcePathCached[Random.Range(0, HuntableResourcePathCached.Count)];
		Vector3 pos2 = pos;
		bool startActive = active;
		return server.CreateEntity(strPrefab, pos2, default(Quaternion), startActive) as CollectableEasterEgg;
	}

	private Vector3 GetRandomSpawnPoint(Vector3 pos, Vector3 aimDir, float minDist = 1f, float maxDist = 2f, bool raycast = false)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		aimDir = ((aimDir == Vector3.zero) ? Random.onUnitSphere : AimConeUtil.GetModifiedAimConeDirection(90f, aimDir));
		Vector3 val = pos + Vector3Ex.Direction2D(pos + aimDir * 10f, pos) * Random.Range(minDist, maxDist);
		RaycastHit val2 = default(RaycastHit);
		if (raycast && Physics.Raycast(val + Vector3.up * 100f, Vector3.down, ref val2, 105f, 10551297))
		{
			val.y = ((RaycastHit)(ref val2)).point.y;
		}
		else
		{
			val.y = TerrainMeta.HeightMap.GetHeight(val);
		}
		return val;
	}

	public void OnEggCollected(BasePlayer player, CollectableEasterEgg collectedEgg)
	{
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		IncrementScore(player);
		if (_spawnedEggs.TryGetValue(collectedEgg.ownerUserID, out var value))
		{
			value.Remove(collectedEgg);
		}
		int num = ((!((float)Mathf.RoundToInt(player.eggVision) * 0.5f < 1f)) ? 1 : Random.Range(0, 2));
		int num2 = Random.Range(1 + num, 2 + num);
		List<CollectableEasterEgg> list = TryGetPlayerEggs(player.userID);
		for (int i = 0; i < num2; i++)
		{
			if (list.Count + 1 > maxEggPerPlayer)
			{
				list[0].Kill();
				list.Remove(list[0]);
			}
			Vector3 randomSpawnPoint = GetRandomSpawnPoint(((Component)player).transform.position, player.eyes.BodyForward(), 15f, 25f, raycast: true);
			CollectableEasterEgg collectableEasterEgg = SpawnEggAtPoint(randomSpawnPoint, active: true);
			collectableEasterEgg.ownerUserID = player.userID;
			collectableEasterEgg.Spawn();
			list.Add(collectableEasterEgg);
		}
	}

	private void IncrementScore(BasePlayer player)
	{
		if (!_eggHunters.TryGetValue(player.userID, out var value))
		{
			value = new EggHunter();
			value.displayName = player.displayName;
			value.userid = player.userID;
			_eggHunters.Add(player.userID, value);
		}
		value.numEggs++;
		QueueUpdate();
	}

	private void QueueUpdate()
	{
		if (!((FacepunchBehaviour)this).IsInvoking((Action)DoNetworkUpdate))
		{
			((FacepunchBehaviour)this).Invoke((Action)DoNetworkUpdate, 2f);
		}
	}

	private void DoNetworkUpdate()
	{
		SendNetworkUpdate();
	}

	private List<CollectableEasterEgg> TryGetPlayerEggs(ulong userID)
	{
		if (!_spawnedEggs.TryGetValue(userID, out var value))
		{
			value = new List<CollectableEasterEgg>();
			_spawnedEggs[userID] = value;
		}
		return value;
	}

	protected List<EggHunter> GetTopHunters()
	{
		List<EggHunter> list = Pool.Get<List<EggHunter>>();
		foreach (KeyValuePair<ulong, EggHunter> eggHunter in _eggHunters)
		{
			list.Add(eggHunter.Value);
		}
		list.Sort((EggHunter a, EggHunter b) => b.numEggs.CompareTo(a.numEggs));
		return list;
	}

	protected virtual Phrase GetTopBunnyPhrase()
	{
		return topBunnyPhrase;
	}

	protected virtual Phrase GetNoPlayersPhrase()
	{
		return noPlayersPhrase;
	}

	protected virtual Phrase GetPlacePhrase()
	{
		return placePhrase;
	}

	protected virtual Phrase GetRewardPhrase()
	{
		return rewardPhrase;
	}

	protected void PrintWinnersAndAward()
	{
		List<EggHunter> topHunters = GetTopHunters();
		if (topHunters.Count > 0)
		{
			EggHunter eggHunter = topHunters[0];
			Chat.Broadcast(string.Format(GetTopBunnyPhrase().translated, eggHunter.displayName, eggHunter.numEggs), "", "#eee", 0uL);
			for (int i = 0; i < topHunters.Count; i++)
			{
				EggHunter eggHunter2 = topHunters[i];
				BasePlayer basePlayer = BasePlayer.FindByID(eggHunter2.userid);
				if (Object.op_Implicit((Object)(object)basePlayer))
				{
					string translated = GetPlacePhrase().translated;
					translated = string.Format(translated, i + 1, topHunters.Count, topHunters[i].numEggs);
					basePlayer.ChatMessage(translated);
					ReportEggsCollected(topHunters[i].numEggs);
				}
				else
				{
					Debug.LogWarning((object)("EggHuntEvent PrintWinnersAndAward could not find player with id :" + eggHunter2.userid));
				}
			}
			ReportPlayerParticipated(topHunters.Count);
			for (int j = 0; j < placementAwards.Length && j < topHunters.Count; j++)
			{
				BasePlayer basePlayer2 = BasePlayer.FindByID(topHunters[j].userid);
				if (Object.op_Implicit((Object)(object)basePlayer2))
				{
					basePlayer2.inventory.GiveItem(ItemManager.Create(placementAwards[j].itemDef, (int)placementAwards[j].amount, 0uL), basePlayer2.inventory.containerMain);
					string translated2 = GetRewardPhrase().translated;
					translated2 = string.Format(translated2, (int)placementAwards[j].amount, placementAwards[j].itemDef.displayName.english);
					basePlayer2.ChatMessage(translated2);
				}
			}
		}
		else
		{
			Chat.Broadcast(GetNoPlayersPhrase().translated, "", "#eee", 0uL);
		}
	}

	protected virtual void ReportEggsCollected(int numEggs)
	{
	}

	protected virtual void ReportPlayerParticipated(int topCount)
	{
	}

	private void CleanupEggs()
	{
		foreach (KeyValuePair<ulong, List<CollectableEasterEgg>> spawnedEgg in _spawnedEggs)
		{
			if (spawnedEgg.Value == null)
			{
				continue;
			}
			foreach (CollectableEasterEgg item in spawnedEgg.Value)
			{
				if ((Object)(object)item != (Object)null)
				{
					item.Kill();
				}
			}
		}
	}

	private void Cooldown()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)Cooldown);
		Kill();
	}

	public static ListHashSet<BasePlayer> GetCombinedPlayerList(bool wantBots)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		ListHashSet<BasePlayer> val = new ListHashSet<BasePlayer>(BasePlayer.activePlayerList.Count + (wantBots ? BasePlayer.bots.Count : 0));
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				val.Add(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		if (wantBots)
		{
			enumerator = BasePlayer.bots.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current2 = enumerator.Current;
					val.Add(current2);
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		return val;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.eggHunt = Pool.Get<EggHunt>();
		List<EggHunter> topHunters = GetTopHunters();
		info.msg.eggHunt.hunters = Pool.Get<List<EggHunter>>();
		for (int i = 0; i < Mathf.Min(10, topHunters.Count); i++)
		{
			EggHunter val = Pool.Get<EggHunter>();
			val.displayName = topHunters[i].displayName;
			val.numEggs = topHunters[i].numEggs;
			val.playerID = topHunters[i].userid;
			info.msg.eggHunt.hunters.Add(val);
		}
	}
}


public class EggHunter
{
	public ulong userid;

	public string displayName;

	public int numEggs;
}


using System;
using UnityEngine;

public class AnimationFlagHandler : MonoBehaviour
{
	public Animator animator;

	public bool forceUpdateIfDisabled;

	public void SetBoolTrue(string name)
	{
		animator.SetBool(name, true);
		TryForceAnimation();
	}

	public void SetBoolFalse(string name)
	{
		animator.SetBool(name, false);
		TryForceAnimation();
	}

	private void TryForceAnimation()
	{
		if (forceUpdateIfDisabled && !((Behaviour)animator).isActiveAndEnabled)
		{
			((Behaviour)animator).enabled = true;
			animator.Update(10f);
			((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)DisableAnimator, 2f);
		}
	}

	private void DisableAnimator()
	{
		if (!((Object)(object)animator == (Object)null))
		{
			((Behaviour)animator).enabled = false;
		}
	}
}


using UnityEngine;

public class JiggleBone : BaseMonoBehaviour
{
	public bool debugMode = true;

	private Vector3 targetPos;

	private Vector3 dynamicPos;

	public Vector3 boneAxis = new Vector3(0f, 0f, 1f);

	public float targetDistance = 2f;

	public float bStiffness = 0.1f;

	public float bMass = 0.9f;

	public float bDamping = 0.75f;

	public float bGravity = 0.75f;

	private Vector3 force;

	private Vector3 acc;

	private Vector3 vel;

	public bool SquashAndStretch = true;

	public float sideStretch = 0.15f;

	public float frontStretch = 0.2f;

	public float disableDistance = 20f;

	private void Awake()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position + ((Component)this).transform.TransformDirection(new Vector3(boneAxis.x * targetDistance, boneAxis.y * targetDistance, boneAxis.z * targetDistance));
		dynamicPos = val;
	}

	private void LateUpdate()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_034a: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_035f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_036a: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0375: Unknown result type (might be due to invalid IL or missing references)
		//IL_037a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0385: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_0399: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.rotation = default(Quaternion);
		Vector3 val = ((Component)this).transform.TransformDirection(new Vector3(boneAxis.x * targetDistance, boneAxis.y * targetDistance, boneAxis.z * targetDistance));
		Vector3 val2 = ((Component)this).transform.TransformDirection(new Vector3(0f, 1f, 0f));
		Vector3 val3 = ((Component)this).transform.position + ((Component)this).transform.TransformDirection(new Vector3(boneAxis.x * targetDistance, boneAxis.y * targetDistance, boneAxis.z * targetDistance));
		force.x = (val3.x - dynamicPos.x) * bStiffness;
		acc.x = force.x / bMass;
		vel.x += acc.x * (1f - bDamping);
		force.y = (val3.y - dynamicPos.y) * bStiffness;
		force.y -= bGravity / 10f;
		acc.y = force.y / bMass;
		vel.y += acc.y * (1f - bDamping);
		force.z = (val3.z - dynamicPos.z) * bStiffness;
		acc.z = force.z / bMass;
		vel.z += acc.z * (1f - bDamping);
		dynamicPos += vel + force;
		((Component)this).transform.LookAt(dynamicPos, val2);
		if (SquashAndStretch)
		{
			Vector3 val4 = dynamicPos - val3;
			float magnitude = ((Vector3)(ref val4)).magnitude;
			float num = ((boneAxis.x != 0f) ? (1f + magnitude * frontStretch) : (1f + (0f - magnitude) * sideStretch));
			float num2 = ((boneAxis.y != 0f) ? (1f + magnitude * frontStretch) : (1f + (0f - magnitude) * sideStretch));
			float num3 = ((boneAxis.z != 0f) ? (1f + magnitude * frontStretch) : (1f + (0f - magnitude) * sideStretch));
			((Component)this).transform.localScale = new Vector3(num, num2, num3);
		}
		if (debugMode)
		{
			Debug.DrawRay(((Component)this).transform.position, val, Color.blue);
			Debug.DrawRay(((Component)this).transform.position, val2, Color.green);
			Debug.DrawRay(val3, Vector3.up * 0.2f, Color.yellow);
			Debug.DrawRay(dynamicPos, Vector3.up * 0.2f, Color.red);
		}
	}
}


using UnityEngine;

public class EggUpdater : MonoBehaviour
{
}


public class ItemModCrackOpen : ItemModUnwrap
{
	public static readonly Phrase CrackOpenTitle = new Phrase("crack_open", "Crack Open");

	public static readonly Phrase CrackOpenDesc = new Phrase("crack_open_desc", "Crack open the egg");
}


using UnityEngine;

public class RandomRendererEnable : MonoBehaviour
{
	public Renderer[] randoms;

	public int EnabledIndex { get; private set; }

	public void OnEnable()
	{
		int num2 = (EnabledIndex = Random.Range(0, randoms.Length));
		randoms[num2].enabled = true;
	}
}


using UnityEngine;
using UnityEngine.UI;

public class BunnyEntry : MonoBehaviour
{
	public Text nameText;

	public Text amountText;

	public RawImage starImage;

	public RawImage selfImage;
}


using Rust.UI;
using UnityEngine;

public class EggHuntNote : MonoBehaviour, IClientComponent
{
	public CanvasGroup mainGroup;

	public CanvasGroup timerGroup;

	public RustText timerText;

	public static readonly Phrase startsInPhrase = new Phrase("egghunt.start", "Starts in: {0}");
}


using UnityEngine;
using UnityEngine.UI;

public class TopBunnies : MonoBehaviour
{
	public BunnyEntry[] topBunnyEntries;

	public Text timerText;

	public CanvasGroup group;

	public Color endingColor;
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class GraveyardFence : SimpleBuildingBlock
{
	public BoxCollider[] pillars;

	public override void ServerInit()
	{
		base.ServerInit();
		UpdatePillars();
	}

	public override void DestroyShared()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.DestroyShared();
		List<GraveyardFence> list = Pool.Get<List<GraveyardFence>>();
		Vis.Entities(((Component)this).transform.position, 5f, list, 2097152, (QueryTriggerInteraction)2);
		foreach (GraveyardFence item in list)
		{
			item.UpdatePillars();
		}
		Pool.FreeUnmanaged<GraveyardFence>(ref list);
	}

	public virtual void UpdatePillars()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		BoxCollider[] array = pillars;
		foreach (BoxCollider val in array)
		{
			((Component)val).gameObject.SetActive(true);
			Collider[] array2 = Physics.OverlapBox(((Component)val).transform.TransformPoint(val.center), val.size * 0.5f, ((Component)val).transform.rotation, 2097152);
			foreach (Collider val2 in array2)
			{
				if (((Component)val2).CompareTag("Usable Auxiliary"))
				{
					BaseEntity baseEntity = ((Component)val2).gameObject.ToBaseEntity();
					if (!((Object)(object)baseEntity == (Object)null) && !EqualNetID((BaseNetworkable)baseEntity) && (Object)(object)val2 != (Object)(object)val)
					{
						((Component)val).gameObject.SetActive(false);
					}
				}
			}
		}
	}
}


public class HalloweenEventNote : EggHuntNote
{
}


public class HalloweenHunt : EggHuntEvent
{
	public static Phrase topCreepPhrase = new Phrase("candyhunt.result.topcreeps", "{0} is the top creep with {1} candies collected.");

	public static Phrase placeCreepPhrase = new Phrase("candyhunt.result.place", "You placed {0} of {1} with {2} candies collected.");

	protected override Phrase GetTopBunnyPhrase()
	{
		return topCreepPhrase;
	}

	protected override Phrase GetPlacePhrase()
	{
		return placeCreepPhrase;
	}

	protected override void ReportPlayerParticipated(int topCount)
	{
	}

	protected override void ReportEggsCollected(int numEggs)
	{
	}
}


public class ItemModOpenLootBag : ItemModUnwrap
{
	public static readonly Phrase OpenLootBagTitle = new Phrase("open_lootbag", "Open Bag");

	public static readonly Phrase OpenLootBagDesc = new Phrase("open_lootbag_desc", "");
}


using UnityEngine;

public class SpiderWeb : BaseCombatEntity
{
	public bool Fresh()
	{
		if (!HasFlag(Flags.Reserved1) && !HasFlag(Flags.Reserved2) && !HasFlag(Flags.Reserved3))
		{
			return !HasFlag(Flags.Reserved4);
		}
		return false;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (Fresh())
		{
			int num = Random.Range(0, 4);
			Flags f = Flags.Reserved1;
			switch (num)
			{
			case 0:
				f = Flags.Reserved1;
				break;
			case 1:
				f = Flags.Reserved2;
				break;
			case 2:
				f = Flags.Reserved3;
				break;
			case 3:
				f = Flags.Reserved4;
				break;
			}
			SetFlag(f, b: true);
		}
	}
}


using Facepunch;
using ntw.CurvedTextMeshPro;
using ProtoBuf;
using Rust.UI;
using UnityEngine;

public class SkullTrophy : StorageContainer
{
	public RustText NameText;

	public TextProOnACircle CircleModifier;

	public int AngleModifierMinCharCount = 3;

	public int AngleModifierMaxCharCount = 20;

	public int AngleModifierMinArcAngle = 20;

	public int AngleModifierMaxArcAngle = 45;

	public float SunsetTime = 18f;

	public float SunriseTime = 5f;

	public RendererLOD SkullRenderer;

	public Material[] DaySkull;

	public Material[] NightSkull;

	public Material[] NoSkull;

	public const Flags HasSkull = Flags.Reserved1;

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		SetFlag(Flags.Reserved1, base.inventory.GetSlot(0) != null);
		SendNetworkUpdate();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk)
		{
			if (base.inventory != null && base.inventory.itemList.Count == 1)
			{
				info.msg.skullTrophy = Pool.Get<SkullTrophy>();
				info.msg.skullTrophy.playerName = base.inventory.itemList[0].GetName(false);
				info.msg.skullTrophy.streamerName = base.inventory.itemList[0].GetName(true);
			}
			else if (info.msg.skullTrophy != null)
			{
				info.msg.skullTrophy.playerName = string.Empty;
				info.msg.skullTrophy.streamerName = string.Empty;
			}
		}
	}
}


using UnityEngine;

public class JunkPileBuoyancyPoint : MonoBehaviour
{
}


using UnityEngine;

public class JunkPileWater : JunkPile
{
	public class JunkpileWaterWorkQueue : ObjectWorkQueue<JunkPileWater>
	{
		protected override void RunJob(JunkPileWater entity)
		{
			if (((ObjectWorkQueue<JunkPileWater>)this).ShouldAdd(entity))
			{
				entity.UpdateNearbyPlayers();
			}
		}

		protected override bool ShouldAdd(JunkPileWater entity)
		{
			if (base.ShouldAdd(entity))
			{
				return entity.IsValid();
			}
			return false;
		}
	}

	public Transform[] buoyancyPoints;

	public bool debugDraw;

	public float updateCullRange = 16f;

	public float VehicleCheckRadius = 5f;

	private Quaternion baseRotation = Quaternion.identity;

	private bool first = true;

	private TimeUntil nextPlayerCheck;

	private bool hasPlayersNearby;

	public static JunkpileWaterWorkQueue junkpileWaterWorkQueue = new JunkpileWaterWorkQueue();

	[ServerVar]
	[Help("How many milliseconds to budget for processing junk pile updates per frame")]
	public static float framebudgetms = 0.25f;

	public override void Spawn()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		position.y = WaterLevel.GetWaterSurface(((Component)this).transform.position, waves: false, volumes: false);
		((Component)this).transform.position = position;
		base.Spawn();
		Quaternion rotation = ((Component)this).transform.rotation;
		baseRotation = Quaternion.Euler(0f, ((Quaternion)(ref rotation)).eulerAngles.y, 0f);
		if (Physics.CheckSphere(((Component)this).transform.position, VehicleCheckRadius, 134217728))
		{
			Kill();
		}
	}

	public void FixedUpdate()
	{
		if (!base.isClient)
		{
			UpdateMovement();
		}
	}

	public void UpdateMovement()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		if (TimeUntil.op_Implicit(nextPlayerCheck) <= 0f)
		{
			nextPlayerCheck = TimeUntil.op_Implicit(Random.Range(0.5f, 1f));
			((ObjectWorkQueue<JunkPileWater>)junkpileWaterWorkQueue).Add(this);
		}
		if (isSinking || !hasPlayersNearby)
		{
			return;
		}
		float waterSurface = WaterLevel.GetWaterSurface(((Component)this).transform.position, waves: true, volumes: false);
		((Component)this).transform.position = new Vector3(((Component)this).transform.position.x, waterSurface, ((Component)this).transform.position.z);
		if (buoyancyPoints != null && buoyancyPoints.Length >= 3)
		{
			Vector3 position = ((Component)this).transform.position;
			Vector3 localPosition = buoyancyPoints[0].localPosition;
			Vector3 localPosition2 = buoyancyPoints[1].localPosition;
			Vector3 localPosition3 = buoyancyPoints[2].localPosition;
			Vector3 val = localPosition + position;
			Vector3 val2 = localPosition2 + position;
			Vector3 val3 = localPosition3 + position;
			val.y = WaterLevel.GetWaterSurface(val, waves: true, volumes: false);
			val2.y = WaterLevel.GetWaterSurface(val2, waves: true, volumes: false);
			val3.y = WaterLevel.GetWaterSurface(val3, waves: true, volumes: false);
			Vector3 val4 = default(Vector3);
			((Vector3)(ref val4))..ctor(position.x, val.y - localPosition.y, position.z);
			Vector3 val5 = val2 - val;
			Vector3 val6 = Vector3.Cross(val3 - val, val5);
			Quaternion val7 = Quaternion.LookRotation(new Vector3(val6.x, val6.z, val6.y));
			Vector3 eulerAngles = ((Quaternion)(ref val7)).eulerAngles;
			val7 = Quaternion.Euler(0f - eulerAngles.x, 0f, 0f - eulerAngles.y);
			if (first)
			{
				Quaternion rotation = ((Component)this).transform.rotation;
				baseRotation = Quaternion.Euler(0f, ((Quaternion)(ref rotation)).eulerAngles.y, 0f);
				first = false;
			}
			((Component)this).transform.SetPositionAndRotation(val4, val7 * baseRotation);
		}
	}

	public void UpdateNearbyPlayers()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		hasPlayersNearby = BaseNetworkable.HasCloseConnections(((Component)this).transform.position, updateCullRange);
	}
}


public class JunkpileWaterWorkQueue : ObjectWorkQueue<JunkPileWater>
{
	protected override void RunJob(JunkPileWater entity)
	{
		if (((ObjectWorkQueue<JunkPileWater>)this).ShouldAdd(entity))
		{
			entity.UpdateNearbyPlayers();
		}
	}

	protected override bool ShouldAdd(JunkPileWater entity)
	{
		if (base.ShouldAdd(entity))
		{
			return entity.IsValid();
		}
		return false;
	}
}


using UnityEngine;

public class JunkPileWaterSpawner : SpawnGroup
{
	public BaseEntity attachToParent;

	protected override void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
	{
		base.PostSpawnProcess(entity, spawnPoint);
		if ((Object)(object)attachToParent != (Object)null)
		{
			entity.SetParent(attachToParent, worldPositionStays: true);
		}
	}
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class DeliveryDrone : Drone
{
	private enum State
	{
		Invalid,
		Takeoff,
		FlyToVendingMachine,
		DescendToVendingMachine,
		PickUpItems,
		AscendBeforeReturn,
		ReturnToTerminal,
		Landing
	}

	[Header("Delivery Drone")]
	public float stateTimeout = 300f;

	public float targetPositionTolerance = 1f;

	public float preferredCruiseHeight = 20f;

	public float preferredHeightAboveObstacle = 5f;

	public float marginAbovePreferredHeight = 3f;

	public float obstacleHeightLockDuration = 3f;

	public int pickUpDelayInTicks = 3;

	public DeliveryDroneConfig config;

	public GameObjectRef mapMarkerPrefab;

	public EntityRef<Marketplace> sourceMarketplace;

	public EntityRef<MarketTerminal> sourceTerminal;

	public EntityRef<VendingMachine> targetVendingMachine;

	public State _state;

	public RealTimeSince _sinceLastStateChange;

	public Vector3? _stateGoalPosition;

	public float? _goToY;

	public TimeSince _sinceLastObstacleBlock;

	public float? _minimumYLock;

	public int _pickUpTicks;

	public BaseEntity _mapMarkerInstance;

	public void Setup(Marketplace marketplace, MarketTerminal terminal, VendingMachine vendingMachine)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		sourceMarketplace.Set(marketplace);
		sourceTerminal.Set(terminal);
		targetVendingMachine.Set(vendingMachine);
		_state = State.Takeoff;
		_sinceLastStateChange = RealTimeSince.op_Implicit(0f);
		_pickUpTicks = 0;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)Think, 0f, 0.5f, 0.25f);
		CreateMapMarker();
	}

	public void CreateMapMarker()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)_mapMarkerInstance != (Object)null)
		{
			_mapMarkerInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(mapMarkerPrefab?.resourcePath, Vector3.zero, Quaternion.identity);
		baseEntity.OwnerID = base.OwnerID;
		baseEntity.Spawn();
		baseEntity.SetParent(this);
		_mapMarkerInstance = baseEntity;
	}

	public void Think()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0345: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02de: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0323: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e6: Unknown result type (might be due to invalid IL or missing references)
		if (RealTimeSince.op_Implicit(_sinceLastStateChange) > stateTimeout)
		{
			Debug.LogError((object)"Delivery drone hasn't change state in too long, killing", (Object)(object)this);
			ForceRemove();
			return;
		}
		if (!sourceMarketplace.TryGet(serverside: true, out var marketplace) || !sourceTerminal.TryGet(serverside: true, out var _))
		{
			Debug.LogError((object)"Delivery drone's marketplace or terminal was destroyed, killing", (Object)(object)this);
			ForceRemove();
			return;
		}
		if (!targetVendingMachine.TryGet(serverside: true, out var entity2) && _state <= State.AscendBeforeReturn)
		{
			SetState(State.ReturnToTerminal);
		}
		Vector3 currentPosition = ((Component)this).transform.position;
		float num = GetMinimumHeight(Vector3.zero);
		if (_goToY.HasValue)
		{
			if (!IsAtGoToY())
			{
				targetPosition = Vector3Ex.WithY(currentPosition, _goToY.Value);
				return;
			}
			_goToY = null;
			_sinceLastObstacleBlock = TimeSince.op_Implicit(0f);
			_minimumYLock = currentPosition.y;
		}
		Vector3 waitPosition;
		switch (_state)
		{
		case State.Takeoff:
			SetGoalPosition(marketplace.droneLaunchPoint.position + Vector3.up * 15f);
			if (IsAtGoalPosition())
			{
				SetState(State.FlyToVendingMachine);
			}
			break;
		case State.FlyToVendingMachine:
		{
			bool isBlocked2;
			float num2 = CalculatePreferredY(out isBlocked2);
			if (isBlocked2 && currentPosition.y < num2)
			{
				SetGoToY(num2 + marginAbovePreferredHeight);
				return;
			}
			config.FindDescentPoints(entity2, num2 + marginAbovePreferredHeight, out waitPosition, out var descendPosition);
			SetGoalPosition(descendPosition);
			if (IsAtGoalPosition())
			{
				SetState(State.DescendToVendingMachine);
			}
			break;
		}
		case State.DescendToVendingMachine:
		{
			config.FindDescentPoints(entity2, currentPosition.y, out var waitPosition2, out waitPosition);
			SetGoalPosition(waitPosition2);
			if (IsAtGoalPosition())
			{
				SetState(State.PickUpItems);
			}
			break;
		}
		case State.PickUpItems:
			_pickUpTicks++;
			if (_pickUpTicks >= pickUpDelayInTicks)
			{
				SetState(State.AscendBeforeReturn);
			}
			break;
		case State.AscendBeforeReturn:
		{
			config.FindDescentPoints(entity2, num + preferredCruiseHeight, out waitPosition, out var descendPosition2);
			SetGoalPosition(descendPosition2);
			if (IsAtGoalPosition())
			{
				SetState(State.ReturnToTerminal);
			}
			break;
		}
		case State.ReturnToTerminal:
		{
			bool isBlocked3;
			float num3 = CalculatePreferredY(out isBlocked3);
			if (isBlocked3 && currentPosition.y < num3)
			{
				SetGoToY(num3 + marginAbovePreferredHeight);
				return;
			}
			Vector3 val = LandingPosition();
			if (Vector3Ex.Distance2D(currentPosition, val) < 30f)
			{
				val.y = Mathf.Max(val.y, num3 + marginAbovePreferredHeight);
			}
			else
			{
				val.y = num3 + marginAbovePreferredHeight;
			}
			SetGoalPosition(val);
			if (IsAtGoalPosition())
			{
				SetState(State.Landing);
			}
			break;
		}
		case State.Landing:
			SetGoalPosition(LandingPosition());
			if (IsAtGoalPosition())
			{
				marketplace.ReturnDrone(this);
				SetState(State.Invalid);
			}
			break;
		default:
			ForceRemove();
			break;
		}
		if (_minimumYLock.HasValue)
		{
			if (TimeSince.op_Implicit(_sinceLastObstacleBlock) > obstacleHeightLockDuration)
			{
				_minimumYLock = null;
			}
			else if (targetPosition.HasValue && targetPosition.Value.y < _minimumYLock.Value)
			{
				targetPosition = Vector3Ex.WithY(targetPosition.Value, _minimumYLock.Value);
			}
		}
		float CalculatePreferredY(out bool isBlocked)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0101: Unknown result type (might be due to invalid IL or missing references)
			//IL_0106: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0114: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			//IL_0126: Unknown result type (might be due to invalid IL or missing references)
			//IL_0129: Unknown result type (might be due to invalid IL or missing references)
			//IL_0130: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_0141: Unknown result type (might be due to invalid IL or missing references)
			//IL_014e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0153: Unknown result type (might be due to invalid IL or missing references)
			//IL_0158: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_016a: Unknown result type (might be due to invalid IL or missing references)
			//IL_016d: Unknown result type (might be due to invalid IL or missing references)
			//IL_016f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0171: Unknown result type (might be due to invalid IL or missing references)
			//IL_0178: Unknown result type (might be due to invalid IL or missing references)
			//IL_0185: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_019b: Unknown result type (might be due to invalid IL or missing references)
			//IL_019d: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01be: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val2 = default(Vector3);
			float num4 = default(float);
			Vector3Ex.ToDirectionAndMagnitude(Vector3Ex.WithY(body.velocity, 0f), ref val2, ref num4);
			if (num4 < 0.5f)
			{
				float num5 = GetMinimumHeight(Vector3.zero) + preferredCruiseHeight;
				Vector3 val3 = Vector3Ex.WithY(currentPosition, num5 + 1000f);
				Vector3Ex.WithY(currentPosition, num5);
				RaycastHit val4 = default(RaycastHit);
				isBlocked = Physics.Raycast(val3, Vector3.down, ref val4, 1000f, LayerMask.op_Implicit(config.layerMask));
				if (!isBlocked)
				{
					return num5;
				}
				return num5 + (1000f - ((RaycastHit)(ref val4)).distance) + preferredHeightAboveObstacle;
			}
			float num6 = num4 * 2f;
			float num7 = GetMinimumHeight(Vector3.zero);
			float num8 = GetMinimumHeight(new Vector3(0f, 0f, num6 / 2f));
			float num9 = GetMinimumHeight(new Vector3(0f, 0f, num6));
			float num10 = Mathf.Max(Mathf.Max(num7, num8), num9) + preferredCruiseHeight;
			Quaternion val5 = Quaternion.FromToRotation(Vector3.forward, val2);
			Vector3 val6 = Vector3Ex.WithZ(config.halfExtents, num6 / 2f);
			Vector3 val7 = Vector3Ex.WithY(Vector3Ex.WithY(currentPosition, num10) + val5 * new Vector3(0f, 0f, val6.z / 2f), num10 + 1000f);
			RaycastHit val8 = default(RaycastHit);
			isBlocked = Physics.BoxCast(val7, val6, Vector3.down, ref val8, val5, 1000f, LayerMask.op_Implicit(config.layerMask));
			if (isBlocked)
			{
				Ray ray = default(Ray);
				((Ray)(ref ray))..ctor(val7, Vector3.down);
				Vector3 val9 = ray.ClosestPoint(((RaycastHit)(ref val8)).point);
				float num11 = Vector3.Distance(((Ray)(ref ray)).origin, val9);
				return num10 + (1000f - num11) + preferredHeightAboveObstacle;
			}
			return num10;
		}
		float GetMinimumHeight(Vector3 offset)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return WaterLevel.GetWaterOrTerrainSurface(((Component)this).transform.TransformPoint(offset), waves: true, volumes: true);
		}
		bool IsAtGoalPosition()
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			if (_stateGoalPosition.HasValue)
			{
				return Vector3.Distance(_stateGoalPosition.Value, currentPosition) < targetPositionTolerance;
			}
			return false;
		}
		bool IsAtGoToY()
		{
			if (_goToY.HasValue)
			{
				return Mathf.Abs(_goToY.Value - currentPosition.y) < targetPositionTolerance;
			}
			return false;
		}
		Vector3 LandingPosition()
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			return marketplace.droneLaunchPoint.position;
		}
		void SetGoalPosition(Vector3 position)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			_goToY = null;
			_stateGoalPosition = position;
			targetPosition = position;
		}
		void SetGoToY(float y)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			_goToY = y;
			targetPosition = Vector3Ex.WithY(currentPosition, y);
		}
		void SetState(State newState)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			_state = newState;
			_sinceLastStateChange = RealTimeSince.op_Implicit(0f);
			_pickUpTicks = 0;
			_stateGoalPosition = null;
			_goToY = null;
			SetFlag(Flags.Reserved1, _state >= State.AscendBeforeReturn);
		}
	}

	public void ForceRemove()
	{
		if (sourceMarketplace.TryGet(serverside: true, out var entity))
		{
			entity.ReturnDrone(this);
		}
		else
		{
			Kill();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.deliveryDrone = Pool.Get<DeliveryDrone>();
			info.msg.deliveryDrone.marketplaceId = sourceMarketplace.uid;
			info.msg.deliveryDrone.terminalId = sourceTerminal.uid;
			info.msg.deliveryDrone.vendingMachineId = targetVendingMachine.uid;
			info.msg.deliveryDrone.state = (int)_state;
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.deliveryDrone != null)
		{
			sourceMarketplace = new EntityRef<Marketplace>(info.msg.deliveryDrone.marketplaceId);
			sourceTerminal = new EntityRef<MarketTerminal>(info.msg.deliveryDrone.terminalId);
			targetVendingMachine = new EntityRef<VendingMachine>(info.msg.deliveryDrone.vendingMachineId);
			_state = (State)info.msg.deliveryDrone.state;
		}
	}

	public override bool CanControl(ulong playerID)
	{
		return false;
	}
}


private enum State
{
	Invalid,
	Takeoff,
	FlyToVendingMachine,
	DescendToVendingMachine,
	PickUpItems,
	AscendBeforeReturn,
	ReturnToTerminal,
	Landing
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Delivery Drone Config")]
public class DeliveryDroneConfig : BaseScriptableObject
{
	public Vector3 vendingMachineOffset = new Vector3(0f, 1f, 1f);

	public float maxDistanceFromVendingMachine = 1f;

	public Vector3 halfExtents = new Vector3(0.5f, 0.5f, 0.5f);

	public float testHeight = 200f;

	public LayerMask layerMask = LayerMask.op_Implicit(161546496);

	public void FindDescentPoints(VendingMachine vendingMachine, float currentY, out Vector3 waitPosition, out Vector3 descendPosition)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		float num = maxDistanceFromVendingMachine / 4f;
		RaycastHit val4 = default(RaycastHit);
		for (int i = 0; i <= 4; i++)
		{
			Vector3 val = Vector3.forward * (num * (float)i);
			Vector3 val2 = ((Component)vendingMachine).transform.TransformPoint(vendingMachineOffset + val);
			Vector3 val3 = val2 + Vector3.up * testHeight;
			if (!Physics.BoxCast(val3, halfExtents, Vector3.down, ref val4, ((Component)vendingMachine).transform.rotation, testHeight, LayerMask.op_Implicit(layerMask)))
			{
				waitPosition = val2;
				descendPosition = Vector3Ex.WithY(val3, currentY);
				return;
			}
			if (i == 4)
			{
				waitPosition = val3 + Vector3.down * (((RaycastHit)(ref val4)).distance - halfExtents.y * 2f);
				descendPosition = Vector3Ex.WithY(val3, currentY);
				return;
			}
		}
		throw new Exception("Bug: FindDescentPoint didn't return a fallback value");
	}

	public bool IsVendingMachineAccessible(VendingMachine vendingMachine, Vector3 offset, out RaycastHit hitInfo)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)vendingMachine).transform.TransformPoint(offset);
		if (Physics.BoxCast(val + Vector3.up * testHeight, halfExtents, Vector3.down, ref hitInfo, ((Component)vendingMachine).transform.rotation, testHeight, LayerMask.op_Implicit(layerMask)))
		{
			return false;
		}
		return vendingMachine.IsVisible(val, 2f);
	}
}


public class MapMarkerDeliveryDrone : MapMarker
{
	public override void ServerInit()
	{
		base.ServerInit();
		base.limitNetworking = true;
	}

	public override bool ShouldNetworkTo(BasePlayer player)
	{
		return (ulong)player.userID == base.OwnerID;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class Marketplace : BaseEntity
{
	[Header("Marketplace")]
	public GameObjectRef terminalPrefab;

	public Transform[] terminalPoints;

	public Transform droneLaunchPoint;

	public GameObjectRef deliveryDronePrefab;

	[NonSerialized]
	public EntityRef<MarketTerminal>[] terminalEntities;

	public NetworkableId SendDrone(BasePlayer player, MarketTerminal sourceTerminal, VendingMachine vendingMachine)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)sourceTerminal == (Object)null || (Object)(object)vendingMachine == (Object)null)
		{
			return default(NetworkableId);
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(deliveryDronePrefab?.resourcePath, droneLaunchPoint.position, droneLaunchPoint.rotation);
		if (!(baseEntity is DeliveryDrone deliveryDrone))
		{
			baseEntity.Kill();
			return default(NetworkableId);
		}
		deliveryDrone.OwnerID = player.userID;
		deliveryDrone.Spawn();
		deliveryDrone.Setup(this, sourceTerminal, vendingMachine);
		return deliveryDrone.net.ID;
	}

	public void ReturnDrone(DeliveryDrone deliveryDrone)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		if (deliveryDrone.sourceTerminal.TryGet(serverside: true, out var entity))
		{
			entity.CompleteOrder(deliveryDrone.targetVendingMachine.uid);
		}
		deliveryDrone.Kill();
	}

	public override void Spawn()
	{
		base.Spawn();
		if (!Application.isLoadingSave)
		{
			SpawnSubEntities();
		}
	}

	private void SpawnSubEntities()
	{
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isServer)
		{
			return;
		}
		if (terminalEntities != null && terminalEntities.Length > terminalPoints.Length)
		{
			for (int i = terminalPoints.Length; i < terminalEntities.Length; i++)
			{
				if (terminalEntities[i].TryGet(serverside: true, out var entity))
				{
					entity.Kill();
				}
			}
		}
		Array.Resize(ref terminalEntities, terminalPoints.Length);
		for (int j = 0; j < terminalPoints.Length; j++)
		{
			Transform val = terminalPoints[j];
			if (!terminalEntities[j].TryGet(serverside: true, out var _))
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(terminalPrefab?.resourcePath, val.position, val.rotation);
				baseEntity.SetParent(this, worldPositionStays: true);
				baseEntity.Spawn();
				if (!(baseEntity is MarketTerminal marketTerminal))
				{
					Debug.LogError((object)("Marketplace.terminalPrefab did not spawn a MarketTerminal (it spawned " + ((object)baseEntity).GetType().FullName + ")"));
					baseEntity.Kill();
				}
				else
				{
					marketTerminal.Setup(this);
					terminalEntities[j].Set(marketTerminal);
				}
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.subEntityList != null)
		{
			List<NetworkableId> subEntityIds = info.msg.subEntityList.subEntityIds;
			Array.Resize(ref terminalEntities, subEntityIds.Count);
			for (int i = 0; i < subEntityIds.Count; i++)
			{
				terminalEntities[i] = new EntityRef<MarketTerminal>(subEntityIds[i]);
			}
		}
		SpawnSubEntities();
	}

	public override void Save(SaveInfo info)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.subEntityList = Pool.Get<SubEntityList>();
		info.msg.subEntityList.subEntityIds = Pool.Get<List<NetworkableId>>();
		if (terminalEntities != null)
		{
			for (int i = 0; i < terminalEntities.Length; i++)
			{
				info.msg.subEntityList.subEntityIds.Add(terminalEntities[i].uid);
			}
		}
	}
}


using UnityEngine;

public class UIMarketSearch : MonoBehaviour
{
	public GameObjectRef StoreEntryRef;

	public RectTransform StoreRoot;

	public UIMarketTerminal Terminal;
}


using Rust.UI;
using UnityEngine;

public class UIMarketSearchOrderEntry : MonoBehaviour
{
	public RustText ItemName;

	public GameObject OutOfStockRoot;

	public GameObject BpRoot;
}


using System.Collections.Generic;
using Rust.UI;
using UnityEngine;

public class UIMarketSearchStore : MonoBehaviour
{
	public RustText StoreName;

	public List<UIMarketSearchOrderEntry> Entries;
}


using Rust.UI;
using UnityEngine;

public class UIMarketTerminal : UIDialog, IVendingMachineInterface
{
	public static readonly Phrase PendingDeliveryPluralPhrase = new Phrase("market.pending_delivery.plural", "Waiting for {n} deliveries...");

	public static readonly Phrase PendingDeliverySingularPhrase = new Phrase("market.pending_delivery.singular", "Waiting for delivery...");

	public Canvas canvas;

	public MapView mapView;

	public RectTransform shopDetailsPanel;

	public float shopDetailsMargin = 16f;

	public float easeDuration = 0.2f;

	public LeanTweenType easeType = (LeanTweenType)1;

	public TmProEmojiRedirector shopName;

	public GameObject shopOrderingPanel;

	public RectTransform sellOrderContainer;

	public GameObjectRef sellOrderPrefab;

	public VirtualItemIcon deliveryFeeIcon;

	public GameObject deliveryFeeCantAffordIndicator;

	public GameObject inventoryFullIndicator;

	public GameObject notEligiblePanel;

	public GameObject pendingDeliveryPanel;

	public RustText pendingDeliveryLabel;

	public RectTransform itemNoticesContainer;

	public GameObjectRef itemRemovedPrefab;

	public GameObjectRef itemPendingPrefab;

	public GameObjectRef itemAddedPrefab;

	public CanvasGroup gettingStartedTip;

	public SoundDefinition buyItemSoundDef;

	public SoundDefinition buttonPressSoundDef;
}


using System;
using System.Collections.Generic;
using ConVar;
using UnityEngine;

public class RadiationSphere : BaseEntity
{
	private struct RadiationLight
	{
		public IOEntity Light;

		public Color OriginalColor;
	}

	public AnimationCurve RadiationCurve;

	public float InvokeDelay = 5f;

	public List<IOEntity> RadiationLights = new List<IOEntity>();

	private float timeStarted;

	private TriggerRadiation[] radiationTriggers;

	public static List<RadiationSphere> All { get; private set; } = new List<RadiationSphere>();

	public override void ServerInit()
	{
		base.ServerInit();
		radiationTriggers = ((Component)this).GetComponentsInChildren<TriggerRadiation>();
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateRadiation, InvokeDelay, InvokeDelay, InvokeDelay / 10f);
		All.Add(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		All.Remove(this);
	}

	public void RestartRadiation()
	{
		timeStarted = Time.time;
	}

	public void StopRadation()
	{
		timeStarted = 0f;
	}

	public void UpdateRadiation()
	{
		float num = RadiationCurve.Evaluate((Time.time - timeStarted) / 60f * Server.oilrig_radiation_time_scale) * Server.oilrig_radiation_amount_scale;
		if (timeStarted == 0f)
		{
			num = 0f;
		}
		TriggerRadiation[] array = radiationTriggers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].RadiationAmountOverride = num;
		}
		SetLights(num > Server.oilrig_radiation_alarm_threshold);
	}

	private void SetLights(bool state)
	{
		foreach (IOEntity radiationLight in RadiationLights)
		{
			if (!((Object)(object)radiationLight == (Object)null))
			{
				radiationLight.SetFlag(Flags.Reserved8, state);
			}
		}
	}

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		if (msg == "HackingStarted")
		{
			RestartRadiation();
		}
	}

	public void OnPuzzleReset()
	{
		StopRadation();
	}
}


using UnityEngine;

private struct RadiationLight
{
	public IOEntity Light;

	public Color OriginalColor;
}


using Rust.UI;
using UnityEngine;

public class MonumentSign : LODComponent
{
	public float viewDistance = 30f;

	public GameObject uiRoot;

	public RustText signText;
}


using UnityEngine;
using UnityEngine.UI;

public class NotePanel : MonoBehaviour, IItemPanel
{
	public InputField input;

	private Item item;
}


using Facepunch.Extend;
using UnityEngine;

[Factory("note")]
public class note : ConsoleSystem
{
	[ServerUserVar]
	public static void update(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		ItemId itemID = arg.GetItemID(0);
		string @string = arg.GetString(1, "");
		Item item = arg.Player().inventory.FindItemByUID(itemID);
		if (item != null)
		{
			item.text = StringExtensions.Truncate(@string, 1024, (string)null);
			item.MarkDirty();
		}
	}
}


public class CoverageQueryFlare : BaseMonoBehaviour, IClientComponent
{
	public bool isDynamic;

	public bool timeShimmer;

	public bool positionalShimmer;

	public bool rotate;

	public float maxVisibleDistance = 30f;

	public bool lightScaled;

	public float dotMin = -1f;

	public float dotMax = -1f;

	public CoverageQueries.RadiusSpace coverageRadiusSpace;

	public float coverageRadius = 0.01f;

	public LODDistanceMode DistanceMode;
}


using UnityEngine;

public class OreHotSpot : BaseCombatEntity, ILOD
{
	public float visualDistance = 20f;

	public GameObjectRef visualEffect;

	public GameObjectRef finishEffect;

	public GameObjectRef damageEffect;

	public OreResourceEntity owner;

	public void OreOwner(OreResourceEntity newOwner)
	{
		owner = newOwner;
	}

	public override void ServerInit()
	{
		base.ServerInit();
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (!base.isClient && Object.op_Implicit((Object)(object)owner))
		{
			owner.OnAttacked(info);
		}
	}

	public override void OnDied(HitInfo info)
	{
		FireFinishEffect();
		base.OnDied(info);
	}

	public void FireFinishEffect()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (finishEffect.isValid)
		{
			Effect.server.Run(finishEffect.resourcePath, ((Component)this).transform.position, ((Component)this).transform.forward);
		}
	}
}


using UnityEngine;

public class PlacementTest : MonoBehaviour
{
	public MeshCollider myMeshCollider;

	public Transform testTransform;

	public Transform visualTest;

	public float hemisphere = 45f;

	public float clampTest = 45f;

	public float testDist = 2f;

	private float nextTest;

	public Vector3 RandomHemisphereDirection(Vector3 input, float degreesOffset)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		degreesOffset = Mathf.Clamp(degreesOffset / 180f, -180f, 180f);
		Vector2 insideUnitCircle = Random.insideUnitCircle;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(insideUnitCircle.x * degreesOffset, Random.Range(-1f, 1f) * degreesOffset, insideUnitCircle.y * degreesOffset);
		Vector3 val2 = input + val;
		return ((Vector3)(ref val2)).normalized;
	}

	public Vector3 RandomCylinderPointAroundVector(Vector3 input, float distance, float minHeight = 0f, float maxHeight = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Vector2 insideUnitCircle = Random.insideUnitCircle;
		Vector3 val = new Vector3(insideUnitCircle.x, 0f, insideUnitCircle.y);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		return new Vector3(normalized.x * distance, Random.Range(minHeight, maxHeight), normalized.z * distance);
	}

	public Vector3 ClampToHemisphere(Vector3 hemiInput, float degreesOffset, Vector3 inputVec)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		degreesOffset = Mathf.Clamp(degreesOffset / 180f, -180f, 180f);
		Vector3 val = hemiInput + Vector3.one * degreesOffset;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		val = hemiInput + Vector3.one * (0f - degreesOffset);
		Vector3 normalized2 = ((Vector3)(ref val)).normalized;
		for (int i = 0; i < 3; i++)
		{
			((Vector3)(ref inputVec))[i] = Mathf.Clamp(((Vector3)(ref inputVec))[i], ((Vector3)(ref normalized2))[i], ((Vector3)(ref normalized))[i]);
		}
		return ((Vector3)(ref inputVec)).normalized;
	}

	private void Update()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		if (Time.realtimeSinceStartup < nextTest)
		{
			return;
		}
		nextTest = Time.realtimeSinceStartup + 0f;
		Vector3 val = RandomCylinderPointAroundVector(Vector3.up, 0.5f, 0.25f, 0.5f);
		val = ((Component)this).transform.TransformPoint(val);
		((Component)testTransform).transform.position = val;
		if ((Object)(object)testTransform != (Object)null && (Object)(object)visualTest != (Object)null)
		{
			Vector3 position = ((Component)this).transform.position;
			MeshCollider obj = myMeshCollider;
			Vector3 position2 = testTransform.position;
			Vector3 val2 = ((Component)this).transform.position - testTransform.position;
			RaycastHit val3 = default(RaycastHit);
			if (((Collider)obj).Raycast(new Ray(position2, ((Vector3)(ref val2)).normalized), ref val3, 5f))
			{
				position = ((RaycastHit)(ref val3)).point;
			}
			else
			{
				Debug.LogError((object)"Missed");
			}
			((Component)visualTest).transform.position = position;
		}
	}

	public void OnDrawGizmos()
	{
	}
}


public class ItemModParachute : ItemModBackpack
{
	public GameObjectRef ParachuteVehiclePrefab;
}


using System;
using Facepunch.Rust;
using Rust;
using UnityEngine;

public class Parachute : BaseVehicle, SamSite.ISamSiteTarget
{
	public Collider ParachuteCollider;

	public ItemDefinition PackedParachute;

	public GameObjectRef DetachedParachute;

	public Transform DetachedSpawnPoint;

	public float ConditionLossPerUse = 0.2f;

	public float HurtDeployTime = 1f;

	public float HurtAmount = 80f;

	public Animator ColliderAnimator;

	public Animator ColliderWorldAnimator;

	public float UprightLerpForce = 5f;

	public float ConstantForwardForce = 2f;

	public ForceMode ForwardForceMode = (ForceMode)5;

	public float TurnForce = 2f;

	public ForceMode TurnForceMode = (ForceMode)5;

	public float ForwardTiltAcceleration = 2f;

	public float BackInputForceMultiplier = 0.2f;

	public float DeployAnimationLength = 3f;

	public float TargetDrag = 1f;

	public float TargetAngularDrag = 1f;

	public AnimationCurve DragCurve = new AnimationCurve();

	public AnimationCurve DragDamageCurve = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	public AnimationCurve MassDamageCurve = AnimationCurve.Linear(0f, 30f, 1f, 1f);

	public AnimationCurve DamageHorizontalVelocityCurve = AnimationCurve.Linear(0f, 5f, 1f, 20f);

	[Range(0f, 1f)]
	public float DamageTester = 1f;

	public float AnimationInputSmoothness = 1f;

	public Vector2 AnimationInputScale = new Vector2(0.5f, 0.5f);

	public ParachuteWearable FirstPersonCanopy;

	public GameObjectRef ParachuteLandScreenBounce;

	private static readonly int AnimatorInputXParameter = Animator.StringToHash("InputX");

	private static readonly int AnimatorInputYParameter = Animator.StringToHash("InputY");

	private TimeSince mountTime;

	public const Flags Flag_InputForward = Flags.Reserved1;

	public const Flags Flag_InputBack = Flags.Reserved2;

	public const Flags Flag_InputLeft = Flags.Reserved3;

	public const Flags Flag_InputRight = Flags.Reserved4;

	public SoundDefinition deploySoundDef;

	public SoundDefinition releaseSoundDef;

	public SoundDefinition flightLoopSoundDef;

	public SoundDefinition steerSoundDef;

	public AnimationCurve flightLoopPitchCurve;

	public AnimationCurve flightLoopGainCurve;

	[ServerVar(Saved = true)]
	public static bool BypassRepack = false;

	[ServerVar(Saved = true)]
	public static bool LandingAnimations = false;

	public bool collisionDeath;

	public Vector3 collisionImpulse = Vector3.zero;

	private float startHeight;

	private float distanceTravelled;

	private Vector3 lastPosition = Vector3.zero;

	private Vector2 lerpedInput = Vector2.zero;

	public Vector3 collisionLocalPos;

	public Vector3 collisionWorldNormal;

	protected override bool BypassClothingMountBlocks => true;

	public SamSite.SamTargetType SAMTargetType => SamSite.targetTypeVehicle;

	public override void PlayerMounted(BasePlayer player, BaseMountable seat)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		base.PlayerMounted(player, seat);
		rigidBody.velocity = player.estimatedVelocity;
		mountTime = TimeSince.op_Implicit(0f);
		startHeight = ((Component)this).transform.position.y;
		distanceTravelled = 0f;
		canTriggerParent = false;
	}

	public override bool GetDismountPosition(BasePlayer player, out Vector3 res, bool silent = false)
	{
		ParachuteCollider.enabled = false;
		bool dismountPosition = base.GetDismountPosition(player, out res, silent);
		ParachuteCollider.enabled = true;
		return dismountPosition;
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		base.PlayerServerInput(inputState, player);
		player.PlayHeavyLandingAnimation = true;
		Vector3 position = ((Component)this).transform.position;
		float num = Vector3.Distance(lastPosition, position);
		distanceTravelled += num;
		lastPosition = position;
		if (WaterLevel.Test(((Component)this).transform.position, waves: true, volumes: true, this))
		{
			DismountAllPlayers();
		}
		else if (!(TimeSince.op_Implicit(mountTime) < DeployAnimationLength))
		{
			Vector2 val = ProcessInputVector(inputState, player);
			lerpedInput = Vector2.Lerp(lerpedInput, val, Time.deltaTime * 5f);
			ColliderAnimator.SetFloat(AnimatorInputXParameter, lerpedInput.x);
			ColliderAnimator.SetFloat(AnimatorInputYParameter, lerpedInput.y);
			SetFlag(Flags.Reserved1, inputState.IsDown(BUTTON.FORWARD), recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved2, inputState.IsDown(BUTTON.BACKWARD), recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved3, inputState.IsDown(BUTTON.LEFT), recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved4, inputState.IsDown(BUTTON.RIGHT));
		}
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_030d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0312: Unknown result type (might be due to invalid IL or missing references)
		//IL_0316: Unknown result type (might be due to invalid IL or missing references)
		//IL_032e: Unknown result type (might be due to invalid IL or missing references)
		//IL_034a: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Parachute.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			float num = base.healthFraction * DamageTester;
			float num2 = DragCurve.Evaluate(TimeSince.op_Implicit(mountTime));
			float num3 = DragDamageCurve.Evaluate(num);
			float mass = MassDamageCurve.Evaluate(num);
			rigidBody.mass = mass;
			rigidBody.drag = Mathf.Lerp(0f, TargetDrag * num3, num2);
			rigidBody.angularDrag = Mathf.Lerp(0f, TargetAngularDrag * num3, num2);
			float num4 = Mathf.Clamp01(TimeSince.op_Implicit(mountTime) / 1f);
			Vector3 forward = ((Component)this).transform.forward;
			Vector3 val2 = (forward * ConstantForwardForce + forward * (ForwardTiltAcceleration * Mathf.Clamp(lerpedInput.y, 0f, 1f))) * Time.fixedDeltaTime * num4;
			if (lerpedInput.y < -0.1f)
			{
				val2 *= 1f - BackInputForceMultiplier * Mathf.Abs(lerpedInput.y);
			}
			val2 *= num;
			rigidBody.AddForce(val2, ForwardForceMode);
			Quaternion rotation;
			if (lerpedInput.x != 0f)
			{
				rotation = rigidBody.rotation;
				Quaternion val3 = Quaternion.Euler(Vector3Ex.WithZ(((Quaternion)(ref rotation)).eulerAngles, Mathx.RemapValClamped(lerpedInput.x, -1f, 1f, 40f, -40f)));
				rigidBody.MoveRotation(Quaternion.Lerp(rigidBody.rotation, val3, Time.fixedDeltaTime * 30f));
				rigidBody.AddTorque(((Component)this).transform.TransformDirection(Vector3.up * (TurnForce * num * 0.2f * lerpedInput.x)), TurnForceMode);
			}
			if (lerpedInput.y > 0f)
			{
				rotation = rigidBody.rotation;
				Quaternion val4 = Quaternion.Euler(Vector3Ex.WithX(((Quaternion)(ref rotation)).eulerAngles, Mathx.RemapValClamped(lerpedInput.y, -1f, 1f, -50f, 60f)));
				rigidBody.MoveRotation(Quaternion.Lerp(rigidBody.rotation, val4, Time.fixedDeltaTime * 60f));
			}
			rotation = rigidBody.rotation;
			Quaternion val5 = Quaternion.Euler(Vector3Ex.WithZ(Vector3Ex.WithX(((Quaternion)(ref rotation)).eulerAngles, 0f), 0f));
			rigidBody.rotation = Quaternion.Lerp(rigidBody.rotation, val5, Time.fixedDeltaTime * UprightLerpForce);
			float num5 = DamageHorizontalVelocityCurve.Evaluate(num);
			Vector3 velocity = rigidBody.velocity;
			velocity.x = Mathf.Clamp(velocity.x, 0f - num5, num5);
			velocity.z = Mathf.Clamp(velocity.z, 0f - num5, num5);
			rigidBody.velocity = velocity;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void PlayerDismounted(BasePlayer player, BaseMountable seat)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		base.PlayerDismounted(player, seat);
		if (collisionDeath)
		{
			if (TimeSince.op_Implicit(mountTime) < HurtDeployTime)
			{
				float num = 1f - Mathf.Clamp01(TimeSince.op_Implicit(mountTime) / HurtDeployTime);
				player.Hurt(HurtAmount * num, DamageType.Fall);
			}
			else
			{
				float magnitude = ((Vector3)(ref collisionImpulse)).magnitude;
				if (magnitude > 50f)
				{
					float amount = Mathx.RemapValClamped(magnitude, 50f, 400f, 5f, 50f);
					player.Hurt(amount, DamageType.Fall);
				}
			}
		}
		if (BypassRepack)
		{
			Item item = ItemManager.Create(PackedParachute, 1, skinID);
			item.RepairCondition(item.maxCondition);
			player.inventory.containerWear.GiveItem(item);
		}
		Analytics.Azure.OnParachuteUsed(player, distanceTravelled, startHeight, TimeSince.op_Implicit(mountTime));
		if (collisionDeath && LandingAnimations)
		{
			Effect.server.Run(ParachuteLandScreenBounce.resourcePath, player, 0u, Vector3.zero, Vector3.zero);
			if (collisionLocalPos.y < 0.15f)
			{
				player.Server_StartGesture(GestureCollection.HeavyLandingId);
				player.PlayHeavyLandingAnimation = false;
			}
		}
		ProcessDeath();
		collisionDeath = false;
	}

	public void ProcessDeath()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		float num = base.healthFraction;
		num -= ConditionLossPerUse;
		bool num2 = num > 0f;
		if (num2 && !BypassRepack)
		{
			ParachuteUnpacked parachuteUnpacked = GameManager.server.CreateEntity(DetachedParachute.resourcePath, DetachedSpawnPoint.position, DetachedSpawnPoint.rotation) as ParachuteUnpacked;
			if ((Object)(object)parachuteUnpacked != (Object)null)
			{
				parachuteUnpacked.skinID = skinID;
				parachuteUnpacked.Spawn();
				parachuteUnpacked.Hurt(parachuteUnpacked.MaxHealth() * (1f - num), DamageType.Generic, null, useProtection: false);
				Rigidbody val = default(Rigidbody);
				if (((Component)parachuteUnpacked).TryGetComponent<Rigidbody>(ref val))
				{
					val.velocity = rigidBody.velocity;
				}
			}
		}
		DestroyMode mode = DestroyMode.None;
		if (!num2)
		{
			mode = DestroyMode.Gib;
		}
		Kill(mode);
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)hitEntity == (Object)null)
		{
			hitEntity = collision.collider.ToBaseEntity();
		}
		if (!((Object)(object)hitEntity == (Object)(object)this) && (!((Object)(object)hitEntity != (Object)null) || hitEntity.isServer == base.isServer) && base.isServer && !(hitEntity is TimedExplosive) && !collisionDeath)
		{
			collisionImpulse = collision.impulse;
			Transform transform = ((Component)this).transform;
			ContactPoint contact = collision.GetContact(0);
			collisionLocalPos = transform.InverseTransformPoint(((ContactPoint)(ref contact)).point);
			contact = collision.GetContact(0);
			collisionWorldNormal = ((ContactPoint)(ref contact)).normal;
			collisionDeath = true;
			((FacepunchBehaviour)this).Invoke((Action)DelayedDismount, 0f);
		}
	}

	public void DelayedDismount()
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		if (collisionDeath && distanceTravelled > 0f && (!((Object)(object)mountPoints[0].mountable != (Object)null) || !GetDismountPosition(mountPoints[0].mountable.GetMounted(), out var _)))
		{
			Transform transform = ((Component)this).transform;
			transform.position += collisionWorldNormal * 0.35f;
		}
		DismountAllPlayers();
	}

	public override float MaxVelocity()
	{
		return 13.5f;
	}

	public override bool AllowPlayerInstigatedDismount(BasePlayer player)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		if (TimeSince.op_Implicit(mountTime) < 1.5f)
		{
			return false;
		}
		return base.AllowPlayerInstigatedDismount(player);
	}

	public bool IsValidSAMTarget(bool staticRespawn)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		if (TimeSince.op_Implicit(mountTime) > 1f)
		{
			return !InSafeZone();
		}
		return false;
	}

	private Vector2 ProcessInputVector(InputState inputState, BasePlayer player)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player.GetHeldEntity() != (Object)null)
		{
			return Vector2.zero;
		}
		bool leftDown = inputState.IsDown(BUTTON.LEFT);
		bool rightDown = inputState.IsDown(BUTTON.RIGHT);
		bool forwardDown = inputState.IsDown(BUTTON.FORWARD);
		bool backDown = inputState.IsDown(BUTTON.BACKWARD);
		return ProcessInputVector(leftDown, rightDown, forwardDown, backDown);
	}

	private Vector2 ProcessInputVectorFromFlags(BasePlayer player)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player.GetHeldEntity() != (Object)null)
		{
			return Vector2.zero;
		}
		bool leftDown = HasFlag(Flags.Reserved3);
		bool rightDown = HasFlag(Flags.Reserved4);
		bool forwardDown = HasFlag(Flags.Reserved1);
		bool backDown = HasFlag(Flags.Reserved2);
		return ProcessInputVector(leftDown, rightDown, forwardDown, backDown);
	}

	private static Vector2 ProcessInputVector(bool leftDown, bool rightDown, bool forwardDown, bool backDown)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		Vector2 zero = Vector2.zero;
		if (leftDown && rightDown)
		{
			leftDown = (rightDown = false);
		}
		if (forwardDown && backDown)
		{
			forwardDown = (backDown = false);
		}
		if (forwardDown)
		{
			zero.y = 1f;
		}
		else if (backDown)
		{
			zero.y = -1f;
		}
		if (rightDown)
		{
			zero.x = 1f;
		}
		else if (leftDown)
		{
			zero.x = -1f;
		}
		return zero;
	}
}


public class ParachuteSeat : SledSeat
{
	protected override bool BypassClothingMountBlocks => true;
}


using UnityEngine;

public class ParachuteUnpacked : DecayEntity
{
	public Rigidbody targetRigidbody;

	public Transform centreOfMassRoot;

	public override void ServerInit()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		targetRigidbody.centerOfMass = centreOfMassRoot.localPosition;
	}
}


using UnityEngine;

public class ParachuteWearable : MonoBehaviour
{
	public Animator TargetAnimator;

	public Transform LeftHandTarget;

	public Transform RightHandTarget;
}


using System;
using UnityEngine;

public class Pinata : BaseCombatEntity
{
	[Serializable]
	public struct VisualThreshold
	{
		public GameObject Root;

		public GameObjectRef DestroyEffect;

		[Range(0f, 1f)]
		public float HealthGreaterThan;
	}

	public Transform DropPoint;

	public float DropPointRadius;

	[Header("Hit Animation")]
	public float TotalSwingTime = 0.6f;

	public float SwingForce = 45f;

	public Transform SwingTransform;

	public AnimationCurve SwingCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[3]
	{
		new Keyframe(0f, 0f),
		new Keyframe(0.5f, 1f),
		new Keyframe(1f, 0f)
	});

	[Header("Visual")]
	public VisualThreshold[] Thresholds;

	public LineRenderer Line;

	public Transform DestroyEffectSpawnPos;

	public float HangLength = -1.863f;

	public GameObjectRef FinalDestroyEffect;

	public override void OnDied(HitInfo info)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		base.OnDied(info);
		ItemAmount[] reward = PrefabAttribute.server.Find<PinataPayouts>(prefabID).GetPayout().Reward;
		foreach (ItemAmount itemAmount in reward)
		{
			if ((Object)(object)itemAmount.itemDef != (Object)null)
			{
				ItemManager.Create(itemAmount.itemDef, (int)itemAmount.amount, 0uL).CreateWorldObject(DropPoint.position + Random.onUnitSphere * Random.Range(0f, DropPointRadius));
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public struct VisualThreshold
{
	public GameObject Root;

	public GameObjectRef DestroyEffect;

	[Range(0f, 1f)]
	public float HealthGreaterThan;
}


using System;
using UnityEngine;

public class PinataPayouts : PrefabAttribute, IServerComponent
{
	[Serializable]
	public struct Payout
	{
		public ItemAmount[] Reward;

		public int Chance;
	}

	public Payout[] AllPayouts;

	private int totalChance;

	public Payout GetPayout()
	{
		if (totalChance == 0)
		{
			Payout[] allPayouts = AllPayouts;
			for (int i = 0; i < allPayouts.Length; i++)
			{
				Payout payout = allPayouts[i];
				totalChance += payout.Chance;
			}
		}
		if (totalChance == 0)
		{
			return AllPayouts[0];
		}
		int num = Random.Range(0, totalChance);
		int num2 = 0;
		for (int j = 0; j < AllPayouts.Length; j++)
		{
			Payout result = AllPayouts[j];
			if (num <= num2 + result.Chance)
			{
				return result;
			}
			num2 += result.Chance;
		}
		return AllPayouts[0];
	}

	protected override Type GetIndexedType()
	{
		return typeof(PinataPayouts);
	}
}


using System;

[Serializable]
public struct Payout
{
	public ItemAmount[] Reward;

	public int Chance;
}


using System.Collections.Generic;
using UnityEngine;

public class InstantCameraFlashController : MonoBehaviour
{
	[SerializeField]
	private List<Light> Flash = new List<Light>();

	private void Awake()
	{
		DisableFlash();
	}

	public void EnableFlash()
	{
		foreach (Light item in Flash)
		{
			if ((Object)(object)item != (Object)null)
			{
				((Behaviour)item).enabled = true;
			}
		}
	}

	public void DisableFlash()
	{
		foreach (Light item in Flash)
		{
			if ((Object)(object)item != (Object)null)
			{
				((Behaviour)item).enabled = false;
			}
		}
	}
}


public enum CameraFocusMode
{
	Off,
	Auto,
	Manual
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class PaddlingPool : LiquidContainer, ISplashable
{
	public const Flags FilledUp = Flags.Reserved4;

	public Transform poolWaterVolume;

	public GameObject poolWaterVisual;

	public float minimumWaterHeight;

	public float maximumWaterHeight = 1f;

	public WaterVolume waterVolume;

	public bool alignWaterUp = true;

	public GameObjectRef destroyedWithWaterEffect;

	public Transform destroyedWithWaterEffectPos;

	public Collider requireLookAt;

	private float lastFillAmount = -1f;

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		float normalisedFillLevel = GetNormalisedFillLevel();
		SetFlag(Flags.Reserved4, normalisedFillLevel >= 1f);
		UpdatePoolFillAmount(normalisedFillLevel);
		SendNetworkUpdate();
	}

	protected override void OnInventoryDirty()
	{
		base.OnInventoryDirty();
		float normalisedFillLevel = GetNormalisedFillLevel();
		UpdatePoolFillAmount(normalisedFillLevel);
		SendNetworkUpdate();
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		if (base.IsDestroyed)
		{
			return false;
		}
		if (!HasFlag(Flags.Reserved4) && (Object)(object)splashType != (Object)null)
		{
			for (int i = 0; i < ValidItems.Length; i++)
			{
				if ((Object)(object)ValidItems[i] != (Object)null && ValidItems[i].itemid == splashType.itemid)
				{
					return true;
				}
			}
		}
		return false;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		int amount2 = Mathf.Clamp(Mathf.RoundToInt((float)amount * 0.66f), 1, amount);
		base.inventory.AddItem(splashType, amount2, 0uL);
		return amount;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.WaterPool = Pool.Get<WaterPool>();
		info.msg.WaterPool.fillAmount = GetNormalisedFillLevel();
	}

	private float GetNormalisedFillLevel()
	{
		if (base.inventory.itemList.Count <= 0 || base.inventory.itemList[0] == null)
		{
			return 0f;
		}
		return (float)base.inventory.itemList[0].amount / (float)maxStackSize;
	}

	private void UpdatePoolFillAmount(float normalisedAmount)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		poolWaterVisual.gameObject.SetActive(normalisedAmount > 0f);
		waterVolume.waterEnabled = normalisedAmount > 0f;
		float y = Mathf.Lerp(minimumWaterHeight, maximumWaterHeight, normalisedAmount);
		Vector3 localPosition = poolWaterVolume.localPosition;
		localPosition.y = y;
		poolWaterVolume.localPosition = localPosition;
		if (alignWaterUp)
		{
			poolWaterVolume.up = Vector3.up;
		}
		if (normalisedAmount > 0f && lastFillAmount < normalisedAmount && waterVolume.entityContents != null)
		{
			foreach (BaseEntity entityContent in waterVolume.entityContents)
			{
				if (entityContent is IPoolVehicle poolVehicle)
				{
					poolVehicle.WakeUp();
				}
			}
		}
		lastFillAmount = normalisedAmount;
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (!base.isServer)
		{
			return;
		}
		List<IPoolVehicle> list = Pool.Get<List<IPoolVehicle>>();
		if (waterVolume.entityContents != null)
		{
			foreach (BaseEntity entityContent in waterVolume.entityContents)
			{
				if (entityContent is IPoolVehicle item)
				{
					list.Add(item);
				}
			}
		}
		foreach (IPoolVehicle item2 in list)
		{
			item2.OnPoolDestroyed();
		}
		Pool.FreeUnmanaged<IPoolVehicle>(ref list);
	}
}


public class ItemModPhoto : ItemModAssociatedEntity<PhotoEntity>
{
	protected override bool AllowNullParenting => true;
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using Rust;

public class PhotoEntity : ImageStorageEntity, IUGCBrowserEntity
{
	public ulong PhotographerSteamId { get; private set; }

	public uint ImageCrc { get; private set; }

	protected override uint CrcToLoad => ImageCrc;

	public override bool ShouldTransferAssociatedFiles => true;

	public uint[] GetContentCRCs
	{
		get
		{
			if (ImageCrc == 0)
			{
				return Array.Empty<uint>();
			}
			return new uint[1] { ImageCrc };
		}
	}

	public UGCType ContentType => UGCType.ImageJpg;

	public List<ulong> EditingHistory
	{
		get
		{
			if (PhotographerSteamId == 0)
			{
				return new List<ulong>();
			}
			return new List<ulong> { PhotographerSteamId };
		}
	}

	public BaseNetworkable UgcEntity => this;

	public string ContentString => string.Empty;

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.photo != null)
		{
			PhotographerSteamId = info.msg.photo.photographerSteamId;
			ImageCrc = info.msg.photo.imageCrc;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.photo = Pool.Get<Photo>();
		info.msg.photo.photographerSteamId = PhotographerSteamId;
		info.msg.photo.imageCrc = ImageCrc;
	}

	public void SetImageData(ulong steamId, byte[] data)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		ImageCrc = FileStorage.server.Store(data, FileStorage.Type.jpg, net.ID);
		PhotographerSteamId = steamId;
	}

	internal override void DoServerDestroy()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		base.DoServerDestroy();
		if (!Application.isQuitting && net != null)
		{
			FileStorage.server.RemoveAllByEntity(net.ID);
		}
	}

	public void ClearContent()
	{
		ImageCrc = 0u;
		SendNetworkUpdate();
	}
}


using UnityEngine;
using UnityEngine.UI;

public class PhotoPanel : MonoBehaviour, IImageReceiver, IItemPanel
{
	public RawImage Image;

	public InputField Message;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class SignPanel : MonoBehaviour, IImageReceiver, IItemPanel
{
	public RawImage Image;

	public RectTransform ImageContainer;

	public RustText DisabledSignsMessage;
}


using UnityEngine;

public class TwitchTrophy : BaseCombatEntity
{
	[Header("Trophy")]
	public GameObjectRef DialogPrefab;
}


using Rust.UI;
using UnityEngine;

public class UITwitchTrophy : UIDialog
{
	public HttpImage EventImage;

	public RustText EventName;

	public RustText WinningTeamName;

	public RectTransform TeamMembersRoot;

	public GameObject TeamMemberNamePrefab;

	public GameObject MissingDataOverlay;
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class NPCDwelling : BaseEntity
{
	public NPCSpawner npcSpawner;

	public float NPCSpawnChance = 1f;

	public SpawnGroup[] spawnGroups;

	public AIMovePoint[] movePoints;

	public AICoverPoint[] coverPoints;

	public override void ServerInit()
	{
		base.ServerInit();
		UpdateInformationZone(remove: false);
		if ((Object)(object)npcSpawner != (Object)null && Random.Range(0f, 1f) <= NPCSpawnChance)
		{
			npcSpawner.SpawnInitial();
		}
		SpawnGroup[] array = spawnGroups;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SpawnInitial();
		}
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			CleanupSpawned();
		}
		base.DestroyShared();
		if (base.isServer)
		{
			UpdateInformationZone(remove: true);
		}
	}

	public bool ValidateAIPoint(Vector3 pos)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).gameObject.SetActive(false);
		bool result = !GamePhysics.CheckSphere(pos + Vector3.up * 0.6f, 0.5f, 65537, (QueryTriggerInteraction)0);
		((Component)this).gameObject.SetActive(true);
		return result;
	}

	public void UpdateInformationZone(bool remove)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		AIInformationZone forPoint = AIInformationZone.GetForPoint(((Component)this).transform.position);
		if (!((Object)(object)forPoint == (Object)null))
		{
			if (remove)
			{
				forPoint.RemoveDynamicAIPoints(movePoints, coverPoints);
			}
			else
			{
				forPoint.AddDynamicAIPoints(movePoints, coverPoints, ValidateAIPoint);
			}
		}
	}

	public void CheckDespawn()
	{
		if (!PlayersNearby() && (!Object.op_Implicit((Object)(object)npcSpawner) || npcSpawner.currentPopulation <= 0))
		{
			CleanupSpawned();
			Kill();
		}
	}

	public void CleanupSpawned()
	{
		if (spawnGroups != null)
		{
			SpawnGroup[] array = spawnGroups;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Clear();
			}
		}
		if (Object.op_Implicit((Object)(object)npcSpawner))
		{
			npcSpawner.Clear();
		}
	}

	public bool PlayersNearby()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Vis.Entities(((Component)this).transform.position, TimeoutPlayerCheckRadius(), list, 131072, (QueryTriggerInteraction)2);
		bool result = false;
		foreach (BasePlayer item in list)
		{
			if (!item.IsSleeping() && item.IsAlive())
			{
				result = true;
				break;
			}
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
		return result;
	}

	public virtual float TimeoutPlayerCheckRadius()
	{
		return 10f;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class HexagonGridGenerator : BaseEntity
{
	public GameObjectRef[] hexTilePrefabs;

	[Space]
	public int gridRadius = 5;

	public float tileSpacing = 1.5f;

	[Space]
	public float levelCount = 5f;

	public float levelSpacing = 20f;

	private readonly List<HexagonTile> hexTiles = new List<HexagonTile>();

	public static HexagonGridGenerator Instance;

	public override void ServerInit()
	{
		base.ServerInit();
		Instance = this;
		GenerateHexGrid();
	}

	public void GenerateHexGrid()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		for (int num = hexTiles.Count; num > 0; num--)
		{
			hexTiles[num - 1].Kill();
		}
		hexTiles.Clear();
		for (int i = 0; (float)i < levelCount; i++)
		{
			GenerateLevel(((Component)this).transform.position + Vector3.up * (levelSpacing * (float)(i + 1)), i);
		}
	}

	private void GenerateLevel(Vector3 basePos, int level)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		float num = tileSpacing * 2f;
		float num2 = Mathf.Sqrt(3f) * tileSpacing;
		for (int i = -gridRadius; i <= gridRadius; i++)
		{
			int num3 = Mathf.Max(-gridRadius, -i - gridRadius);
			int num4 = Mathf.Min(gridRadius, -i + gridRadius);
			for (int j = num3; j <= num4; j++)
			{
				float num5 = ((float)i + (float)j / 2f) * num;
				float num6 = (float)j * num2;
				Vector3 pos = basePos + new Vector3(num5, 0f, num6);
				int num7 = Random.Range(-5, 6);
				float num8 = 30f + 180f * (float)num7;
				Quaternion rot = Quaternion.Euler(0f, num8, 0f);
				HexagonTile hexagonTile = GameManager.server.CreateEntity(hexTilePrefabs[level].resourcePath, pos, rot) as HexagonTile;
				hexagonTile.Spawn();
				hexTiles.Add(hexagonTile);
			}
		}
	}

	[ServerVar(Help = "<gridSize> 5 <tileSpacing> 1.35")]
	public static void generategrid(Arg args)
	{
		int @int = args.GetInt(0, 5);
		float @float = args.GetFloat(1, 1.35f);
		@int = Math.Clamp(@int, 1, 50);
		@float = Mathf.Clamp(@float, 1.35f, float.PositiveInfinity);
		Instance.gridRadius = @int;
		Instance.tileSpacing = @float;
		Instance.GenerateHexGrid();
	}
}


using System;
using UnityEngine;

public class HexagonTile : BaseCombatEntity, IDetector
{
	public GameObject[] variants;

	public AnimationCurve tweenCurve;

	private MeshRenderer mesh;

	public bool ShouldTrigger()
	{
		return true;
	}

	public void OnObjects()
	{
		SetFlag(Flags.Busy, b: true);
	}

	public void OnObjectAdded(GameObject obj, Collider col)
	{
	}

	public void OnEmpty()
	{
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		SetFlag(Flags.Busy, b: true);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (old.HasFlag(Flags.Busy) != next.HasFlag(Flags.Busy) && base.isServer)
		{
			((FacepunchBehaviour)this).Invoke((Action)delegate
			{
				Kill();
			}, 1.2f);
		}
	}
}


using UnityEngine;

public class RaceWaypointVisual : MonoBehaviour
{
	public GameObject RegularCheckpoint;

	public GameObject FinishCheckpoint;
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class WaypointRace : BaseEntity
{
	private class PendingRaceResults
	{
		private class Completion
		{
			public List<BasePlayer> players = new List<BasePlayer>();

			public float time;

			public bool valid;
		}

		private List<Completion> Completions = new List<Completion>();

		public int totalParticipants;

		public int RegisterCompletion(List<BasePlayer> forPlayers, float time, bool valid)
		{
			Completion completion = new Completion();
			foreach (BasePlayer forPlayer in forPlayers)
			{
				completion.players.Add(forPlayer);
			}
			completion.time = time;
			completion.valid = valid;
			Completions.Add(completion);
			if (Completions.Count == totalParticipants)
			{
				TextTable val = Pool.Get<TextTable>();
				try
				{
					val.AddColumns(new string[3] { "Place", "Players", "Time" });
					for (int i = 0; i < Completions.Count; i++)
					{
						Completion completion2 = Completions[i];
						if (!completion2.valid)
						{
							continue;
						}
						string text = "";
						foreach (BasePlayer player in completion2.players)
						{
							text = text + player.displayName + ",";
						}
						val.AddRow(new string[3]
						{
							$"P{i + 1}",
							text,
							MathEx.SnapTo(completion2.time, 0.1f).ToString()
						});
					}
					string msg = ((object)val).ToString();
					foreach (Completion completion3 in Completions)
					{
						foreach (BasePlayer player2 in completion3.players)
						{
							player2.ChatMessage(msg);
						}
					}
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}
			return Completions.Count;
		}
	}

	public float WaypointRadius = 10f;

	public RaceWaypointVisual TargetWaypointVisual;

	public RaceWaypointVisual NextWaypointVisual;

	private List<Vector3> racePoints = new List<Vector3>();

	private EntityRef<BaseVehicle> racingVehicle;

	private int currentWaypoint;

	public static Phrase stageNotifyPhrase = new Phrase("race_notify", "Reached checkpoint {0}/{1} : {2}s");

	public static Phrase raceCompletePhrase = new Phrase("race_complete", "Finished race {0}/{1} in {2}s");

	private PendingRaceResults raceResults;

	private TimeSince startTime;

	[ServerVar(Saved = true, Help = "How long a race can go until it times out (in seconds)")]
	public static float raceTimeout = 900f;

	[ServerVar]
	public static void startRace(Arg arg)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		string @string = arg.GetString(0, "");
		List<Transform> list = Pool.Get<List<Transform>>();
		WaypointRaceTarget.GetWaypoints(@string, list);
		if (list.Count == 0)
		{
			arg.ReplyWith("Couldn't find any waypoints for " + @string + ", is the name correct?");
			return;
		}
		Debug.Log((object)$"Starting race {@string} with {list.Count} waypoints");
		List<BasePlayer> list2 = Pool.Get<List<BasePlayer>>();
		Vis.Entities(list[0].position, 30f, list2, 131072, (QueryTriggerInteraction)2);
		List<BaseVehicle> list3 = Pool.Get<List<BaseVehicle>>();
		for (int i = 0; i < list2.Count; i++)
		{
			if (list2[i].isClient)
			{
				list2.RemoveAt(i);
				i--;
				continue;
			}
			if (!list2[i].isMounted)
			{
				Debug.Log((object)("Remove player " + list2[i].displayName + " from race, not mounted"));
				list2.RemoveAt(i);
				i--;
				continue;
			}
			BaseMountable mounted = list2[i].GetMounted();
			if ((Object)(object)mounted == (Object)null || (Object)(object)mounted.VehicleParent() == (Object)null)
			{
				Debug.Log((object)("Remove player " + list2[i].displayName + " from race, no vehicle"));
				list2.RemoveAt(i);
				i--;
				continue;
			}
			BaseVehicle baseVehicle = mounted.VehicleParent();
			if (!baseVehicle.IsDriver(list2[i]))
			{
				Debug.Log((object)("Remove player " + list2[i].displayName + " from race, not a driver"));
				list2.RemoveAt(i);
				i--;
			}
			else if (!list3.Contains(baseVehicle))
			{
				list3.Add(baseVehicle);
			}
		}
		PendingRaceResults results = new PendingRaceResults
		{
			totalParticipants = list3.Count
		};
		foreach (BaseVehicle item in list3)
		{
			WaypointRace obj = GameManager.server.CreateEntity("assets/prefabs/misc/waypointrace/waypointrace.prefab", ((Component)item).transform.position, Quaternion.identity) as WaypointRace;
			obj.Setup(list, item, results);
			obj.Spawn();
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list2);
		Pool.FreeUnmanaged<BaseVehicle>(ref list3);
		Pool.FreeUnmanaged<Transform>(ref list);
	}

	private void Setup(List<Transform> waypoints, BaseVehicle participant, PendingRaceResults results)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		racingVehicle.Set(participant);
		foreach (Transform waypoint in waypoints)
		{
			racePoints.Add(waypoint.position);
		}
		raceResults = results;
		startTime = TimeSince.op_Implicit(0f);
	}

	public override void Save(SaveInfo info)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.waypointRace == null)
		{
			info.msg.waypointRace = Pool.Get<WaypointRace>();
		}
		info.msg.waypointRace.positions = Pool.Get<List<Vector3>>();
		info.msg.waypointRace.positions.Clear();
		foreach (Vector3 racePoint in racePoints)
		{
			info.msg.waypointRace.positions.Add(racePoint);
		}
		info.msg.waypointRace.racingVehicle = racingVehicle.uid;
		info.msg.waypointRace.currentWaypoint = currentWaypoint;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}

	private void Update()
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isServer)
		{
			return;
		}
		BaseVehicle baseVehicle = racingVehicle.Get(base.isServer);
		if ((Object)(object)baseVehicle == (Object)null || baseVehicle.IsDestroyed || baseVehicle.IsDead() || TimeSince.op_Implicit(startTime) > raceTimeout)
		{
			raceResults.RegisterCompletion(new List<BasePlayer>(), TimeSince.op_Implicit(startTime), valid: false);
			Kill();
			return;
		}
		((Component)this).transform.position = ((Component)baseVehicle).transform.position;
		if (racePoints.Count <= currentWaypoint + 1)
		{
			return;
		}
		Vector3 val = racePoints[currentWaypoint + 1];
		Vector3 val2 = ((Component)baseVehicle).transform.position - val;
		if (!(((Vector3)(ref val2)).sqrMagnitude <= WaypointRadius * WaypointRadius))
		{
			return;
		}
		currentWaypoint++;
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		baseVehicle.GetMountedPlayers(list);
		if (currentWaypoint >= racePoints.Count - 1)
		{
			int num = raceResults.RegisterCompletion(list, TimeSince.op_Implicit(startTime), valid: true);
			foreach (BasePlayer item in list)
			{
				item.ShowToast(GameTip.Styles.Blue_Normal, raceCompletePhrase, false, num.ToString(), raceResults.totalParticipants.ToString(), MathEx.SnapTo(TimeSince.op_Implicit(startTime), 0.1f).ToString());
			}
			Kill();
		}
		else
		{
			foreach (BasePlayer item2 in list)
			{
				item2.ShowToast(GameTip.Styles.Blue_Normal, stageNotifyPhrase, false, currentWaypoint.ToString(), (racePoints.Count - 1).ToString(), MathEx.SnapTo(TimeSince.op_Implicit(startTime), 0.1f).ToString());
			}
			SendNetworkUpdate();
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

private class PendingRaceResults
{
	private class Completion
	{
		public List<BasePlayer> players = new List<BasePlayer>();

		public float time;

		public bool valid;
	}

	private List<Completion> Completions = new List<Completion>();

	public int totalParticipants;

	public int RegisterCompletion(List<BasePlayer> forPlayers, float time, bool valid)
	{
		Completion completion = new Completion();
		foreach (BasePlayer forPlayer in forPlayers)
		{
			completion.players.Add(forPlayer);
		}
		completion.time = time;
		completion.valid = valid;
		Completions.Add(completion);
		if (Completions.Count == totalParticipants)
		{
			TextTable val = Pool.Get<TextTable>();
			try
			{
				val.AddColumns(new string[3] { "Place", "Players", "Time" });
				for (int i = 0; i < Completions.Count; i++)
				{
					Completion completion2 = Completions[i];
					if (!completion2.valid)
					{
						continue;
					}
					string text = "";
					foreach (BasePlayer player in completion2.players)
					{
						text = text + player.displayName + ",";
					}
					val.AddRow(new string[3]
					{
						$"P{i + 1}",
						text,
						MathEx.SnapTo(completion2.time, 0.1f).ToString()
					});
				}
				string msg = ((object)val).ToString();
				foreach (Completion completion3 in Completions)
				{
					foreach (BasePlayer player2 in completion3.players)
					{
						player2.ChatMessage(msg);
					}
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		return Completions.Count;
	}
}


using System.Collections.Generic;

private class Completion
{
	public List<BasePlayer> players = new List<BasePlayer>();

	public float time;

	public bool valid;
}


using System.Collections.Generic;
using UnityEngine;

public class WaypointRaceTarget : MonoBehaviour
{
	private static Dictionary<string, Transform> allPoints = new Dictionary<string, Transform>();

	private void Start()
	{
		string text = ((Object)((Component)this).gameObject).name.ToLower();
		if (!allPoints.TryAdd(text, ((Component)this).transform))
		{
			Debug.Log((object)("Unable to add waypoint marker " + text + ", needs a unique name"));
		}
	}

	public static void GetWaypoints(string filter, List<Transform> found, int max = 20)
	{
		string empty = string.Empty;
		for (int i = 0; i < max; i++)
		{
			empty = $"{filter.ToLower()}{i}";
			if (allPoints.TryGetValue(empty, out var value))
			{
				found.Add(value);
			}
		}
	}
}


using UnityEngine;

public class IceFence : GraveyardFence
{
	public GameObject[] styles;

	private bool init;

	public AdaptMeshToTerrain snowMesh;

	public int GetStyleFromID()
	{
		uint num = (uint)net.ID.Value;
		return SeedRandom.Range(ref num, 0, styles.Length);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		InitStyle();
		UpdatePillars();
	}

	public void InitStyle()
	{
		if (!init)
		{
			SetStyle(GetStyleFromID());
		}
	}

	public void SetStyle(int style)
	{
		GameObject[] array = styles;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].gameObject.SetActive(false);
		}
		styles[style].gameObject.SetActive(true);
	}

	public override void UpdatePillars()
	{
		base.UpdatePillars();
	}
}


using Oxide.Core;
using UnityEngine;

public class ItemModUnwrap : ItemMod
{
	public static readonly Phrase UnwrapGiftTitle = new Phrase("unwrap_gift", "Unwrap");

	public static readonly Phrase UnwrapGiftDesc = new Phrase("unwrap_gift_desc", "Unwrap the gift");

	public Phrase OwnershipPhrase;

	public LootSpawn revealList;

	public GameObjectRef successEffect;

	public int minTries = 1;

	public int maxTries = 1;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		if (command == "unwrap" && item.amount > 0 && Interface.CallHook("OnItemUnwrap", (object)item, (object)player, (object)this) == null)
		{
			item.UseItem();
			int num = Random.Range(minTries, maxTries + 1);
			ItemOwnershipShare ownership = default(ItemOwnershipShare);
			if (OwnershipPhrase != null && !string.IsNullOrEmpty(OwnershipPhrase.token))
			{
				ItemOwnershipShare itemOwnershipShare = default(ItemOwnershipShare);
				itemOwnershipShare.username = player.displayName;
				itemOwnershipShare.reason = OwnershipPhrase.token;
				ownership = itemOwnershipShare;
			}
			for (int i = 0; i < num; i++)
			{
				revealList.SpawnIntoContainer(player.inventory.containerMain, ownership, player.inventory.containerBelt);
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}
}


using System;
using UnityEngine;

public class NeonMeshPaintableSource : MeshPaintableSource
{
	public NeonSign neonSign;

	public float editorEmissionScale = 2f;

	public AnimationCurve lightingCurve;

	[NonSerialized]
	public Color topLeft;

	[NonSerialized]
	public Color topRight;

	[NonSerialized]
	public Color bottomLeft;

	[NonSerialized]
	public Color bottomRight;

	public override void UpdateMaterials(MaterialPropertyBlock block, Texture2D textureOverride = null, bool forEditing = false, bool isSelected = false)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		base.UpdateMaterials(block, textureOverride, forEditing);
		if (forEditing)
		{
			block.SetFloat("_EmissionScale", editorEmissionScale);
			block.SetFloat("_Power", (float)(isSelected ? 1 : 0));
			if (!isSelected)
			{
				block.SetColor("_TubeInner", Color.clear);
				block.SetColor("_TubeOuter", Color.clear);
			}
		}
		else if ((Object)(object)neonSign != (Object)null)
		{
			block.SetFloat("_Power", (float)((isSelected && (neonSign.HasFlag(BaseEntity.Flags.Reserved8) || neonSign.HasFlag(BaseEntity.Flags.Reserved9))) ? 1 : 0));
		}
	}

	public override Color32[] UpdateFrom(Texture2D input)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		Init();
		Color32[] pixels = input.GetPixels32();
		texture.SetPixels32(pixels);
		texture.Apply(true, false);
		int width = ((Texture)input).width;
		int height = ((Texture)input).height;
		int num = width / 2;
		int num2 = height / 2;
		topLeft = GetColorForRegion(0, num2, num, num2);
		topRight = GetColorForRegion(num, num2, num, num2);
		bottomLeft = GetColorForRegion(0, 0, num, num2);
		bottomRight = GetColorForRegion(num, 0, num, num2);
		return pixels;
		Color GetColorForRegion(int x, int y, int regionWidth, int regionHeight)
		{
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			float num3 = 0f;
			float num4 = 0f;
			float num5 = 0f;
			int num6 = y + regionHeight;
			for (int i = y; i < num6; i++)
			{
				int num7 = i * width + x;
				int num8 = num7 + regionWidth;
				for (int j = num7; j < num8; j++)
				{
					Color32 val = pixels[j];
					float num9 = (float)(int)val.a / 255f;
					num3 += (float)(int)val.r * num9;
					num4 += (float)(int)val.g * num9;
					num5 += (float)(int)val.b * num9;
				}
			}
			int num10 = regionWidth * regionHeight * 255;
			return new Color(lightingCurve.Evaluate(num3 / (float)num10), lightingCurve.Evaluate(num4 / (float)num10), lightingCurve.Evaluate(num5 / (float)num10), 1f);
		}
	}
}


public class ChristmasLightsBulb : StringLightsBulb
{
}


using System;
using UnityEngine;

public class StringLightsBulb : MonoBehaviour
{
	[Serializable]
	public struct EmissionData
	{
		public int materialIndex;

		[ColorUsage(true, true, 0f, 100f, 0f, 100f)]
		public Color onColor;

		[ColorUsage(true, true, 0f, 100f, 0f, 100f)]
		public Color offColor;
	}

	public Renderer bulbRenderer;

	public EmissionData[] emissionColors;
}


using System;
using UnityEngine;

[Serializable]
public struct EmissionData
{
	public int materialIndex;

	[ColorUsage(true, true, 0f, 100f, 0f, 100f)]
	public Color onColor;

	[ColorUsage(true, true, 0f, 100f, 0f, 100f)]
	public Color offColor;
}


using System;
using UnityEngine;

public class Sled : BaseVehicle, INotifyTrigger
{
	public const Flags BrakeOn = Flags.Reserved1;

	public const Flags OnSnow = Flags.Reserved2;

	public const Flags IsGrounded = Flags.Reserved3;

	public const Flags OnSand = Flags.Reserved4;

	public PhysicMaterial BrakeMaterial;

	public PhysicMaterial SnowMaterial;

	public PhysicMaterial NonSnowMaterial;

	public Transform CentreOfMassTransform;

	public Collider[] PhysicsMaterialTargets;

	public float InitialForceCutoff = 3f;

	public float InitialForceIncreaseRate = 0.05f;

	public float TurnForce = 1f;

	public float DirectionMatchForce = 1f;

	public float VerticalAdjustmentForce = 1f;

	public float VerticalAdjustmentAngleThreshold = 15f;

	public float NudgeCooldown = 3f;

	public float NudgeForce = 2f;

	public float MaxNudgeVelocity = 2f;

	public const float DecayFrequency = 60f;

	public float DecayAmount = 10f;

	public ParticleSystemContainer TrailEffects;

	public SoundDefinition enterSnowSoundDef;

	public SoundDefinition snowSlideLoopSoundDef;

	public SoundDefinition dirtSlideLoopSoundDef;

	public AnimationCurve movementLoopGainCurve;

	public AnimationCurve movementLoopPitchCurve;

	public VehicleTerrainHandler terrainHandler;

	public PhysicMaterial cachedMaterial;

	public float initialForceScale;

	public TimeSince leftIce;

	public TimeSince lastNudge;

	public override bool BlocksDoors => false;

	public override void ServerInit()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		terrainHandler = new VehicleTerrainHandler(this);
		terrainHandler.RayLength = 0.6f;
		rigidBody.centerOfMass = CentreOfMassTransform.localPosition;
		((FacepunchBehaviour)this).InvokeRandomized((Action)DecayOverTime, Random.Range(30f, 60f), 60f, 6f);
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		SetFlag(Flags.Reserved1, b: true);
		UpdateGroundedFlag();
		UpdatePhysicsMaterial();
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Sled.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (!AnyMounted())
			{
				return;
			}
			terrainHandler.FixedUpdate();
			if (!terrainHandler.IsGrounded)
			{
				Quaternion val2 = Quaternion.FromToRotation(((Component)this).transform.up, Vector3.up) * rigidBody.rotation;
				if (Quaternion.Angle(rigidBody.rotation, val2) > VerticalAdjustmentAngleThreshold)
				{
					rigidBody.MoveRotation(Quaternion.Slerp(rigidBody.rotation, val2, Time.fixedDeltaTime * VerticalAdjustmentForce));
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void UpdatePhysicsMaterial()
	{
		cachedMaterial = GetPhysicMaterial();
		Collider[] physicsMaterialTargets = PhysicsMaterialTargets;
		for (int i = 0; i < physicsMaterialTargets.Length; i++)
		{
			physicsMaterialTargets[i].sharedMaterial = cachedMaterial;
		}
		if (!AnyMounted() && rigidBody.IsSleeping())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)UpdatePhysicsMaterial);
		}
		SetFlag(Flags.Reserved2, terrainHandler.IsOnSnowOrIce);
		SetFlag(Flags.Reserved4, terrainHandler.OnSurface == VehicleTerrainHandler.Surface.Sand);
	}

	public void UpdateGroundedFlag()
	{
		if (!AnyMounted() && rigidBody.IsSleeping())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)UpdateGroundedFlag);
		}
		SetFlag(Flags.Reserved3, terrainHandler.IsGrounded);
	}

	public PhysicMaterial GetPhysicMaterial()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		if (HasFlag(Flags.Reserved1) || !AnyMounted())
		{
			return BrakeMaterial;
		}
		bool flag = terrainHandler.IsOnSnowOrIce || terrainHandler.OnSurface == VehicleTerrainHandler.Surface.Sand;
		if (flag)
		{
			leftIce = TimeSince.op_Implicit(0f);
		}
		else if (TimeSince.op_Implicit(leftIce) < 2f)
		{
			flag = true;
		}
		if (!flag)
		{
			return NonSnowMaterial;
		}
		return SnowMaterial;
	}

	public override void PlayerMounted(BasePlayer player, BaseMountable seat)
	{
		base.PlayerMounted(player, seat);
		if (HasFlag(Flags.Reserved1))
		{
			initialForceScale = 0f;
			((FacepunchBehaviour)this).InvokeRepeating((Action)ApplyInitialForce, 0f, 0.1f);
			SetFlag(Flags.Reserved1, b: false);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)UpdatePhysicsMaterial))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdatePhysicsMaterial, 0f, 0.5f);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)UpdateGroundedFlag))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateGroundedFlag, 0f, 0.1f);
		}
		if (rigidBody.IsSleeping())
		{
			rigidBody.WakeUp();
		}
	}

	public void ApplyInitialForce()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 val = ((Vector3.Dot(forward, -Vector3.up) > Vector3.Dot(-forward, -Vector3.up)) ? forward : (-forward));
		rigidBody.AddForce(val * initialForceScale * (terrainHandler.IsOnSnowOrIce ? 1f : 0.25f), (ForceMode)5);
		initialForceScale += InitialForceIncreaseRate;
		if (initialForceScale >= InitialForceCutoff)
		{
			Vector3 velocity = rigidBody.velocity;
			if (((Vector3)(ref velocity)).magnitude > 1f || !terrainHandler.IsOnSnowOrIce)
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)ApplyInitialForce);
			}
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		base.PlayerServerInput(inputState, player);
		if (Vector3.Dot(((Component)this).transform.up, Vector3.up) < 0.1f || WaterFactor() > 0.25f)
		{
			DismountAllPlayers();
			return;
		}
		float num = (inputState.IsDown(BUTTON.LEFT) ? (-1f) : 0f);
		num += (inputState.IsDown(BUTTON.RIGHT) ? 1f : 0f);
		Vector3 velocity;
		if (inputState.IsDown(BUTTON.FORWARD) && TimeSince.op_Implicit(lastNudge) > NudgeCooldown)
		{
			velocity = rigidBody.velocity;
			if (((Vector3)(ref velocity)).magnitude < MaxNudgeVelocity)
			{
				rigidBody.WakeUp();
				rigidBody.AddForce(((Component)this).transform.forward * NudgeForce, (ForceMode)1);
				rigidBody.AddForce(((Component)this).transform.up * NudgeForce * 0.5f, (ForceMode)1);
				lastNudge = TimeSince.op_Implicit(0f);
			}
		}
		num *= TurnForce;
		Vector3 velocity2 = rigidBody.velocity;
		if (num != 0f)
		{
			((Component)this).transform.Rotate(Vector3.up * num * Time.deltaTime * ((Vector3)(ref velocity2)).magnitude, (Space)1);
		}
		if (terrainHandler.IsGrounded)
		{
			velocity = rigidBody.velocity;
			if (Vector3.Dot(((Vector3)(ref velocity)).normalized, ((Component)this).transform.forward) >= 0.5f)
			{
				rigidBody.velocity = Vector3.Lerp(rigidBody.velocity, ((Component)this).transform.forward * ((Vector3)(ref velocity2)).magnitude, Time.deltaTime * DirectionMatchForce);
			}
		}
	}

	public void DecayOverTime()
	{
		if (!AnyMounted())
		{
			Hurt(DecayAmount);
		}
	}

	protected override bool ShouldDisplayPickupOption(BasePlayer player)
	{
		if (base.ShouldDisplayPickupOption(player))
		{
			return !player.isMounted;
		}
		return false;
	}

	public void OnObjects(TriggerNotify trigger)
	{
		foreach (BaseEntity entityContent in trigger.entityContents)
		{
			if (!(entityContent is Sled))
			{
				if (entityContent is BaseVehicleModule baseVehicleModule && (Object)(object)baseVehicleModule.Vehicle != (Object)null && (baseVehicleModule.Vehicle.IsOn() || !baseVehicleModule.Vehicle.IsStationary()))
				{
					Kill(DestroyMode.Gib);
					break;
				}
				if (entityContent is BaseVehicle baseVehicle && baseVehicle.HasDriver() && (baseVehicle.IsMoving() || baseVehicle.HasFlag(Flags.On)))
				{
					Kill(DestroyMode.Gib);
					break;
				}
			}
		}
	}

	public void OnEmpty()
	{
	}
}


using UnityEngine;

public class SledSeat : BaseVehicleSeat
{
	public Transform LeftHand;

	public Transform RightHand;

	public Transform LeftFoot;

	public Transform RightFoot;

	public float MountedAnimationSpeed;
}


public class HandSnowball : BaseMelee
{
}


using UnityEngine;

public class SnowballGun : BaseProjectile
{
	public ItemDefinition OverrideProjectile;

	private static ItemDefinition _snowballInventoryItem;

	private static ItemDefinition _snowballAmmoItem;

	public static ItemDefinition SnowballInventoryItem
	{
		get
		{
			if ((Object)(object)_snowballInventoryItem == (Object)null)
			{
				_snowballInventoryItem = ItemManager.FindItemDefinition("snowball");
			}
			return _snowballInventoryItem;
		}
	}

	public static ItemDefinition SnowballAmmoItem
	{
		get
		{
			if ((Object)(object)_snowballAmmoItem == (Object)null)
			{
				_snowballAmmoItem = ItemManager.FindItemDefinition("ammo.snowballgun");
			}
			return _snowballAmmoItem;
		}
	}

	protected override ItemDefinition PrimaryMagazineAmmo
	{
		get
		{
			if (!((Object)(object)OverrideProjectile != (Object)null))
			{
				return base.PrimaryMagazineAmmo;
			}
			return OverrideProjectile;
		}
	}

	protected override bool CanRefundAmmo => false;

	public override bool TryReloadMagazine(IAmmoContainer ammoSource, int desiredAmount = -1)
	{
		desiredAmount = 1;
		if (!TryReload(ammoSource, desiredAmount, CanRefundAmmo))
		{
			return false;
		}
		SetAmmoCount(primaryMagazine.capacity);
		primaryMagazine.ammoType = OverrideProjectile;
		SendNetworkUpdateImmediate();
		ItemManager.DoRemoves();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null)
		{
			ownerPlayer.inventory.ServerUpdate(0f);
		}
		return true;
	}
}


public class SnowballGunProjectile : Projectile
{
	public float OverrideEffectScale = 0.5f;

	public GameObjectRef SnowballImpactEffect;
}


using UnityEngine;

public class SnowMachine : FogMachine
{
	public AdaptMeshToTerrain snowMesh;

	public TriggerTemperature tempTrigger;

	public override bool MotionModeEnabled()
	{
		return false;
	}

	public override void EnableFogField()
	{
		base.EnableFogField();
		((Component)tempTrigger).gameObject.SetActive(true);
	}

	public override void FinishFogging()
	{
		base.FinishFogging();
		((Component)tempTrigger).gameObject.SetActive(false);
	}
}


using Oxide.Core;
using Rust;
using UnityEngine;

public class Stocking : LootContainer
{
	public static ListHashSet<Stocking> stockings;

	public override void ServerInit()
	{
		base.ServerInit();
		if (stockings == null)
		{
			stockings = new ListHashSet<Stocking>();
		}
		stockings.Add(this);
	}

	internal override void DoServerDestroy()
	{
		stockings.Remove(this);
		base.DoServerDestroy();
	}

	public bool IsEmpty()
	{
		if (base.inventory == null)
		{
			return false;
		}
		for (int num = base.inventory.itemList.Count - 1; num >= 0; num--)
		{
			if (base.inventory.itemList[num] != null)
			{
				return false;
			}
		}
		return true;
	}

	public override void SpawnLoot()
	{
		if (base.inventory == null)
		{
			Debug.Log((object)("CONTACT DEVELOPERS! Stocking::PopulateLoot has null inventory!!! " + ((Object)this).name));
		}
		else if (IsEmpty() && Interface.CallHook("OnXmasStockingFill", (object)this) == null)
		{
			base.SpawnLoot();
			SetFlag(Flags.On, b: true);
			Hurt(MaxHealth() * 0.1f, DamageType.Generic, null, useProtection: false);
		}
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		base.PlayerStoppedLooting(player);
		SetFlag(Flags.On, b: false);
		if (IsEmpty() && base.healthFraction <= 0.1f)
		{
			Hurt(base.health, DamageType.Generic, this, useProtection: false);
		}
	}
}


public class ItemModOpenWrapped : ItemMod
{
	public GameObjectRef successEffect;

	public static Phrase open_wrapped_gift = new Phrase("open_wrapped_gift", "Unwrap");

	public static Phrase open_wrapped_gift_desc = new Phrase("open_wrapped_gift_desc", "Unwrap the gift and reveal its contents");

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (!(command == "open") || item.amount <= 0)
		{
			return;
		}
		Item slot = item.contents.GetSlot(0);
		if (slot != null)
		{
			int position = item.position;
			ItemContainer rootContainer = item.GetRootContainer();
			item.RemoveFromContainer();
			if (!slot.MoveToContainer(rootContainer, position))
			{
				player.GiveItem(slot);
			}
			item.Remove();
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}
}


public class ItemModWrap : ItemMod
{
	public GameObjectRef successEffect;

	public ItemDefinition wrappedDefinition;

	public static Phrase wrap_gift = new Phrase("wrap_gift", "Wrap Gift");

	public static Phrase wrap_gift_desc = new Phrase("wrap_gift_desc", "Wrap this item and turn it in to an openable gift");

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		if (!(command == "wrap") || item.amount <= 0)
		{
			return;
		}
		Item slot = item.contents.GetSlot(0);
		if (slot != null)
		{
			int position = item.position;
			ItemContainer parent = item.parent;
			item.RemoveFromContainer();
			Item item2 = ItemManager.Create(wrappedDefinition, 1, 0uL);
			item2.SetItemOwnership(player, ItemOwnershipPhrases.Wrap);
			slot.MoveToContainer(item2.contents);
			item2.MoveToContainer(parent, position);
			item.Remove();
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}
}


using UnityEngine;

public class ChristmasTree : StorageContainer
{
	public GameObject[] decorations;

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if ((Object)(object)((Component)item.info).GetComponent<ItemModXMasTreeDecoration>() == (Object)null)
		{
			return false;
		}
		foreach (Item item2 in base.inventory.itemList)
		{
			if ((Object)(object)item2.info == (Object)(object)item.info)
			{
				return false;
			}
		}
		return base.ItemFilter(item, targetSlot);
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		ItemModXMasTreeDecoration component = ((Component)item.info).GetComponent<ItemModXMasTreeDecoration>();
		if ((Object)(object)component != (Object)null)
		{
			SetFlag((Flags)component.flagsToChange, added);
		}
		base.OnItemAddedOrRemoved(item, added);
	}
}


public class ItemModXMasTreeDecoration : ItemMod
{
	public enum xmasFlags
	{
		pineCones = 0x80,
		candyCanes = 0x100,
		gingerbreadMen = 0x200,
		Tinsel = 0x400,
		Balls = 0x800,
		Star = 0x4000,
		Lights = 0x8000
	}

	public xmasFlags flagsToChange;
}


public enum xmasFlags
{
	pineCones = 0x80,
	candyCanes = 0x100,
	gingerbreadMen = 0x200,
	Tinsel = 0x400,
	Balls = 0x800,
	Star = 0x4000,
	Lights = 0x8000
}


using UnityEngine;

public class BunkerEntrance : BaseEntity, IMissionEntityListener
{
	public GameObjectRef portalPrefab;

	public GameObjectRef doorPrefab;

	public Transform portalSpawnPoint;

	public Transform doorSpawnPoint;

	public Door doorInstance;

	public BasePortal portalInstance;

	public override void ServerInit()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (portalPrefab.isValid)
		{
			portalInstance = ((Component)GameManager.server.CreateEntity(portalPrefab.resourcePath, portalSpawnPoint.position, portalSpawnPoint.rotation)).GetComponent<BasePortal>();
			portalInstance.SetParent(this, worldPositionStays: true);
			portalInstance.Spawn();
		}
		if (doorPrefab.isValid)
		{
			doorInstance = ((Component)GameManager.server.CreateEntity(doorPrefab.resourcePath, doorSpawnPoint.position, doorSpawnPoint.rotation)).GetComponent<Door>();
			doorInstance.SetParent(this, worldPositionStays: true);
			doorInstance.Spawn();
		}
	}

	public void MissionStarted(BasePlayer assignee, BaseMission.MissionInstance instance)
	{
	}

	public void MissionEnded(BasePlayer assignee, BaseMission.MissionInstance instance)
	{
	}
}


using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class DynamicDungeon : BaseEntity, IMissionEntityListener
{
	public Transform exitEntitySpawn;

	public GameObjectRef exitEntity;

	public string exitString;

	public MonumentNavMesh monumentNavMesh;

	private static List<DynamicDungeon> _dungeons = new List<DynamicDungeon>();

	public GameObjectRef portalPrefab;

	public Transform portalSpawnPoint;

	public BasePortal exitPortal;

	public GameObjectRef doorPrefab;

	public Transform doorSpawnPoint;

	public Door doorInstance;

	public static Vector3 nextDungeonPos = Vector3.zero;

	public static Vector3 dungeonStartPoint = Vector3.zero;

	public static float dungeonSpacing = 50f;

	public SpawnGroup[] spawnGroups;

	public bool AutoMergeAIZones = true;

	public static void AddDungeon(DynamicDungeon newDungeon)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		_dungeons.Add(newDungeon);
		Vector3 position = ((Component)newDungeon).transform.position;
		if (position.y >= nextDungeonPos.y)
		{
			nextDungeonPos = position + Vector3.up * dungeonSpacing;
		}
	}

	public static void RemoveDungeon(DynamicDungeon dungeon)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)dungeon).transform.position;
		if (_dungeons.Contains(dungeon))
		{
			_dungeons.Remove(dungeon);
		}
		nextDungeonPos = position;
	}

	public static Vector3 GetNextDungeonPoint()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (nextDungeonPos == Vector3.zero)
		{
			nextDungeonPos = Vector3.one * 700f;
		}
		return nextDungeonPos;
	}

	public IEnumerator UpdateNavMesh()
	{
		Debug.Log((object)"Dungeon Building navmesh");
		yield return ((MonoBehaviour)this).StartCoroutine(monumentNavMesh.UpdateNavMeshAndWait());
		Debug.Log((object)"Dunngeon done!");
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			SpawnGroup[] array = spawnGroups;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Clear();
			}
			if ((Object)(object)exitPortal != (Object)null)
			{
				exitPortal.Kill();
			}
			RemoveDungeon(this);
		}
		base.DestroyShared();
	}

	public override void ServerInit()
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		AddDungeon(this);
		if (portalPrefab.isValid)
		{
			exitPortal = ((Component)GameManager.server.CreateEntity(portalPrefab.resourcePath, portalSpawnPoint.position, portalSpawnPoint.rotation)).GetComponent<BasePortal>();
			exitPortal.SetParent(this, worldPositionStays: true);
			exitPortal.Spawn();
		}
		if (doorPrefab.isValid)
		{
			doorInstance = ((Component)GameManager.server.CreateEntity(doorPrefab.resourcePath, doorSpawnPoint.position, doorSpawnPoint.rotation)).GetComponent<Door>();
			doorInstance.SetParent(this, worldPositionStays: true);
			doorInstance.Spawn();
		}
		MergeAIZones();
		((MonoBehaviour)this).StartCoroutine(UpdateNavMesh());
	}

	private void MergeAIZones()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Expected O, but got Unknown
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (!AutoMergeAIZones)
		{
			return;
		}
		List<AIInformationZone> list = ((Component)this).GetComponentsInChildren<AIInformationZone>().ToList();
		foreach (AIInformationZone item in list)
		{
			item.AddInitialPoints();
		}
		GameObject val = new GameObject("AIZ");
		val.transform.position = ((Component)this).transform.position;
		AIInformationZone.Merge(list, val).ShouldSleepAI = false;
		val.transform.SetParent(((Component)this).transform);
	}

	public void MissionStarted(BasePlayer assignee, BaseMission.MissionInstance instance)
	{
		foreach (MissionEntity value in instance.missionEntities.Values)
		{
			BunkerEntrance component = ((Component)value).GetComponent<BunkerEntrance>();
			if ((Object)(object)component != (Object)null)
			{
				BasePortal portalInstance = component.portalInstance;
				if (Object.op_Implicit((Object)(object)portalInstance))
				{
					portalInstance.targetPortal = exitPortal;
					exitPortal.targetPortal = portalInstance;
					Debug.Log((object)"Dungeon portal linked...");
				}
			}
		}
	}

	public void MissionEnded(BasePlayer assignee, BaseMission.MissionInstance instance)
	{
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class HalloweenDungeon : BasePortal
{
	public GameObjectRef dungeonPrefab;

	public EntityRef<ProceduralDynamicDungeon> dungeonInstance;

	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float population = 0f;

	[ServerVar(Help = "How long each active dungeon should last before dying", ShowInAdminUI = true)]
	public static float lifetime = 600f;

	private float secondsUsed;

	private float timeAlive;

	public AnimationCurve radiationCurve;

	public Phrase collapsePhrase;

	public Phrase mountPhrase;

	private bool anyplayers_cached;

	private float nextPlayerCheckTime = float.NegativeInfinity;

	public virtual float GetLifetime()
	{
		return lifetime;
	}

	public override void Load(LoadInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.fromDisk && info.msg.ioEntity != null)
		{
			dungeonInstance.uid = info.msg.ioEntity.genericEntRef3;
			secondsUsed = info.msg.ioEntity.genericFloat1;
			timeAlive = info.msg.ioEntity.genericFloat2;
		}
	}

	public float GetLifeFraction()
	{
		return Mathf.Clamp01(secondsUsed / GetLifetime());
	}

	public void Update()
	{
		if (!base.isClient)
		{
			if (secondsUsed > 0f)
			{
				secondsUsed += Time.deltaTime;
			}
			timeAlive += Time.deltaTime;
			float lifeFraction = GetLifeFraction();
			if (dungeonInstance.IsValid(serverside: true))
			{
				ProceduralDynamicDungeon proceduralDynamicDungeon = dungeonInstance.Get(serverside: true);
				float num = radiationCurve.Evaluate(lifeFraction) * 80f;
				proceduralDynamicDungeon.exitRadiation.RadiationAmountOverride = Mathf.Clamp(num, 0f, float.PositiveInfinity);
			}
			if (lifeFraction >= 1f)
			{
				KillIfNoPlayers();
			}
			else if (timeAlive > 3600f && secondsUsed == 0f)
			{
				ClearAllEntitiesInRadius(80f);
				Kill();
			}
		}
	}

	public void KillIfNoPlayers()
	{
		if (!AnyPlayersInside())
		{
			ClearAllEntitiesInRadius(80f);
			Kill();
		}
	}

	public bool AnyPlayersInside()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		ProceduralDynamicDungeon proceduralDynamicDungeon = dungeonInstance.Get(serverside: true);
		if ((Object)(object)proceduralDynamicDungeon == (Object)null)
		{
			anyplayers_cached = false;
		}
		else if (Time.time > nextPlayerCheckTime)
		{
			nextPlayerCheckTime = Time.time + 10f;
			anyplayers_cached = BaseNetworkable.HasCloseConnections(((Component)proceduralDynamicDungeon).transform.position, 80f);
		}
		return anyplayers_cached;
	}

	private void ClearAllEntitiesInRadius(float radius)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		ProceduralDynamicDungeon proceduralDynamicDungeon = dungeonInstance.Get(serverside: true);
		if ((Object)(object)proceduralDynamicDungeon == (Object)null)
		{
			return;
		}
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(((Component)proceduralDynamicDungeon).transform.position, radius, list, -1, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (item.IsValid() && !item.IsDestroyed)
			{
				if (item is LootableCorpse lootableCorpse)
				{
					lootableCorpse.blockBagDrop = true;
				}
				item.Kill();
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.ioEntity == null)
		{
			info.msg.ioEntity = Pool.Get<IOEntity>();
		}
		info.msg.ioEntity.genericEntRef3 = dungeonInstance.uid;
		info.msg.ioEntity.genericFloat1 = secondsUsed;
		info.msg.ioEntity.genericFloat2 = timeAlive;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		timeAlive += Random.Range(0f, 60f);
	}

	public override void UsePortal(BasePlayer player)
	{
		if (GetLifeFraction() > 0.8f)
		{
			player.ShowToast(GameTip.Styles.Blue_Normal, collapsePhrase, false);
			return;
		}
		if (player.isMounted)
		{
			player.ShowToast(GameTip.Styles.Blue_Normal, mountPhrase, false);
			return;
		}
		if (secondsUsed == 0f)
		{
			secondsUsed = 1f;
		}
		base.UsePortal(player);
	}

	public override void Spawn()
	{
		base.Spawn();
	}

	public override void ServerInit()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			timeAlive = Random.Range(0f, 60f);
			SpawnSubEntities();
		}
		localEntryExitPos.DropToGround(alignToNormal: false, 10f);
		Transform transform = ((Component)localEntryExitPos).transform;
		transform.position += Vector3.up * 0.05f;
		((FacepunchBehaviour)this).Invoke((Action)CheckBlocked, 0.25f);
	}

	public void CheckBlocked()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		float num = 0.5f;
		float num2 = 1.8f;
		Vector3 position = localEntryExitPos.position;
		Vector3 val = position + new Vector3(0f, num, 0f);
		Vector3 val2 = position + new Vector3(0f, num2 - num, 0f);
		if (Physics.CheckCapsule(val, val2, num, 1537286401))
		{
			Kill();
		}
	}

	public static Vector3 GetDungeonSpawnPoint()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Floor(TerrainMeta.Size.x / 200f);
		float num2 = 1000f;
		Vector3 zero = Vector3.zero;
		zero.x = 0f - Mathf.Min(TerrainMeta.Size.x * 0.5f, 4000f) + 200f;
		zero.y = 1025f;
		zero.z = 0f - Mathf.Min(TerrainMeta.Size.z * 0.5f, 4000f) + 200f;
		_ = Vector3.zero;
		for (int i = 0; (float)i < num2; i++)
		{
			for (int j = 0; (float)j < num; j++)
			{
				Vector3 val = zero + new Vector3((float)j * 200f, (float)i * 100f, 0f);
				bool flag = false;
				foreach (ProceduralDynamicDungeon dungeon in ProceduralDynamicDungeon.dungeons)
				{
					if ((Object)(object)dungeon != (Object)null && dungeon.isServer && Vector3.Distance(((Component)dungeon).transform.position, val) < 10f)
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					return val;
				}
			}
		}
		return Vector3.zero;
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (dungeonInstance.IsValid(serverside: true))
		{
			dungeonInstance.Get(serverside: true).Kill();
		}
	}

	public void DelayedDestroy()
	{
		Kill();
	}

	public void SpawnSubEntities()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 dungeonSpawnPoint = GetDungeonSpawnPoint();
		if (dungeonSpawnPoint == Vector3.zero)
		{
			Debug.LogError((object)"No dungeon spawn point");
			((FacepunchBehaviour)this).Invoke((Action)DelayedDestroy, 5f);
			return;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(dungeonPrefab.resourcePath, dungeonSpawnPoint, Quaternion.identity);
		ProceduralDynamicDungeon component = ((Component)baseEntity).GetComponent<ProceduralDynamicDungeon>();
		component.mapOffset = ((Component)this).transform.position - dungeonSpawnPoint;
		baseEntity.Spawn();
		dungeonInstance.Set(component);
		BasePortal basePortal = (targetPortal = component.GetExitPortal());
		basePortal.targetPortal = this;
		LinkPortal();
		basePortal.LinkPortal();
	}
}


using System;
using UnityEngine;

public class XmasDungeon : HalloweenDungeon
{
	public const Flags HasPlayerOutside = Flags.Reserved7;

	public const Flags HasPlayerInside = Flags.Reserved8;

	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float xmaspopulation = 0f;

	[ServerVar(Help = "How long each active dungeon should last before dying", ShowInAdminUI = true)]
	public static float xmaslifetime = 1200f;

	[ServerVar(Help = "How far we detect players from our inside/outside", ShowInAdminUI = true)]
	public static float playerdetectrange = 30f;

	public override float GetLifetime()
	{
		return xmaslifetime;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)PlayerChecks, 1f, 1f);
	}

	public void PlayerChecks()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		ProceduralDynamicDungeon proceduralDynamicDungeon = dungeonInstance.Get(serverside: true);
		if ((Object)(object)proceduralDynamicDungeon == (Object)null)
		{
			return;
		}
		bool b = false;
		bool b2 = false;
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				float num = Vector3.Distance(((Component)current).transform.position, ((Component)this).transform.position);
				float num2 = Vector3.Distance(((Component)current).transform.position, ((Component)proceduralDynamicDungeon.GetExitPortal(serverSide: true)).transform.position);
				if (num < playerdetectrange)
				{
					b = true;
				}
				if (num2 < playerdetectrange * 2f)
				{
					b2 = true;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		SetFlag(Flags.Reserved8, b2);
		SetFlag(Flags.Reserved7, b);
		proceduralDynamicDungeon.SetFlag(Flags.Reserved7, b);
		proceduralDynamicDungeon.SetFlag(Flags.Reserved8, b2);
	}
}


using UnityEngine;

public class ProceduralDungeonCell : BaseMonoBehaviour
{
	public bool north;

	public bool east;

	public bool south;

	public bool west;

	public bool entrance;

	public bool hasSpawn;

	public Transform exitPointHack;

	public SpawnGroup[] spawnGroups;

	public RendererLOD[] mapRendererLods;

	public void Awake()
	{
		spawnGroups = ((Component)this).GetComponentsInChildren<SpawnGroup>();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class ProceduralDynamicDungeon : BaseEntity
{
	public int gridResolution = 6;

	public float gridSpacing = 12f;

	public bool[] grid;

	public List<GameObjectRef> cellPrefabReferences = new List<GameObjectRef>();

	public List<ProceduralDungeonCell> spawnedCells = new List<ProceduralDungeonCell>();

	public EnvironmentVolume envVolume;

	public MonumentNavMesh monumentNavMesh;

	public GameObjectRef exitPortalPrefab;

	private EntityRef<BasePortal> exitPortal;

	public TriggerRadiation exitRadiation;

	public uint seed;

	public uint baseseed;

	public Vector3 mapOffset = Vector3.zero;

	public static readonly List<ProceduralDynamicDungeon> dungeons = new List<ProceduralDynamicDungeon>();

	public ProceduralDungeonCell entranceHack;

	public override void InitShared()
	{
		base.InitShared();
		dungeons.Add(this);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		foreach (ProceduralDungeonCell spawnedCell in spawnedCells)
		{
			EntityFlag_Toggle[] componentsInChildren = ((Component)spawnedCell).GetComponentsInChildren<EntityFlag_Toggle>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].DoUpdate(this);
			}
		}
	}

	public BaseEntity GetExitPortal(bool serverSide)
	{
		return exitPortal.Get(serverSide);
	}

	public override void DestroyShared()
	{
		dungeons.Remove(this);
		RetireAllCells();
		base.DestroyShared();
	}

	public bool ContainsAnyPlayers()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		Bounds val = default(Bounds);
		((Bounds)(ref val))..ctor(((Component)this).transform.position, new Vector3((float)gridResolution * gridSpacing, 20f, (float)gridResolution * gridSpacing));
		for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
		{
			BasePlayer basePlayer = BasePlayer.activePlayerList[i];
			if (((Bounds)(ref val)).Contains(((Component)basePlayer).transform.position))
			{
				return true;
			}
		}
		for (int j = 0; j < BasePlayer.sleepingPlayerList.Count; j++)
		{
			BasePlayer basePlayer2 = BasePlayer.sleepingPlayerList[j];
			if (((Bounds)(ref val)).Contains(((Component)basePlayer2).transform.position))
			{
				return true;
			}
		}
		return false;
	}

	public void KillPlayers()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		Bounds val = default(Bounds);
		((Bounds)(ref val))..ctor(((Component)this).transform.position, new Vector3((float)gridResolution * gridSpacing, 20f, (float)gridResolution * gridSpacing));
		for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
		{
			BasePlayer basePlayer = BasePlayer.activePlayerList[i];
			if (((Bounds)(ref val)).Contains(((Component)basePlayer).transform.position))
			{
				basePlayer.Hurt(10000f, DamageType.Suicide, null, useProtection: false);
			}
		}
		for (int j = 0; j < BasePlayer.sleepingPlayerList.Count; j++)
		{
			BasePlayer basePlayer2 = BasePlayer.sleepingPlayerList[j];
			if (((Bounds)(ref val)).Contains(((Component)basePlayer2).transform.position))
			{
				basePlayer2.Hurt(10000f, DamageType.Suicide, null, useProtection: false);
			}
		}
	}

	internal override void DoServerDestroy()
	{
		KillPlayers();
		if (exitPortal.IsValid(serverside: true))
		{
			exitPortal.Get(serverside: true).Kill();
		}
		base.DoServerDestroy();
	}

	public override void ServerInit()
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		if (!Application.isLoadingSave)
		{
			baseseed = (seed = (uint)Random.Range(0, 12345567));
			int num = (int)seed;
			Debug.Log((object)("Spawning dungeon with seed :" + num));
		}
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			DoGeneration();
			BasePortal component = ((Component)GameManager.server.CreateEntity(exitPortalPrefab.resourcePath, entranceHack.exitPointHack.position, entranceHack.exitPointHack.rotation)).GetComponent<BasePortal>();
			component.Spawn();
			exitPortal.Set(component);
		}
	}

	public void DoGeneration()
	{
		GenerateGrid();
		CreateAIZ();
		if (base.isServer)
		{
			Debug.Log((object)"Server DoGeneration,calling routine update nav mesh");
			((MonoBehaviour)this).StartCoroutine(UpdateNavMesh());
		}
		((FacepunchBehaviour)this).Invoke((Action)InitSpawnGroups, 1f);
	}

	private void CreateAIZ()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		AIInformationZone aIInformationZone = ((Component)this).gameObject.AddComponent<AIInformationZone>();
		aIInformationZone.UseCalculatedCoverDistances = false;
		((Bounds)(ref aIInformationZone.bounds)).extents = new Vector3((float)gridResolution * gridSpacing * 0.75f, 10f, (float)gridResolution * gridSpacing * 0.75f);
		aIInformationZone.Init();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		DoGeneration();
	}

	public IEnumerator UpdateNavMesh()
	{
		Debug.Log((object)"Dungeon Building navmesh");
		yield return ((MonoBehaviour)this).StartCoroutine(monumentNavMesh.UpdateNavMeshAndWait());
		Debug.Log((object)"Dungeon done!");
	}

	public override void Save(SaveInfo info)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.proceduralDungeon == null)
		{
			info.msg.proceduralDungeon = Pool.Get<ProceduralDungeon>();
		}
		info.msg.proceduralDungeon.seed = baseseed;
		info.msg.proceduralDungeon.exitPortalID = exitPortal.uid;
		info.msg.proceduralDungeon.mapOffset = mapOffset;
	}

	public BasePortal GetExitPortal()
	{
		return exitPortal.Get(serverside: true);
	}

	public void InitSpawnGroups()
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		foreach (ProceduralDungeonCell spawnedCell in spawnedCells)
		{
			if (!((Object)(object)entranceHack != (Object)null) || !(Vector3.Distance(((Component)entranceHack).transform.position, ((Component)spawnedCell).transform.position) < 20f))
			{
				SpawnGroup[] spawnGroups = spawnedCell.spawnGroups;
				for (int i = 0; i < spawnGroups.Length; i++)
				{
					spawnGroups[i].Spawn();
				}
			}
		}
	}

	public void CleanupSpawnGroups()
	{
		foreach (ProceduralDungeonCell spawnedCell in spawnedCells)
		{
			SpawnGroup[] spawnGroups = spawnedCell.spawnGroups;
			for (int i = 0; i < spawnGroups.Length; i++)
			{
				spawnGroups[i].Clear();
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.proceduralDungeon != null)
		{
			baseseed = (seed = info.msg.proceduralDungeon.seed);
			exitPortal.uid = info.msg.proceduralDungeon.exitPortalID;
			mapOffset = info.msg.proceduralDungeon.mapOffset;
		}
	}

	[ContextMenu("Test Grid")]
	[ExecuteInEditMode]
	public void GenerateGrid()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position - new Vector3((float)gridResolution * gridSpacing * 0.5f, 0f, (float)gridResolution * gridSpacing * 0.5f);
		RetireAllCells();
		grid = new bool[gridResolution * gridResolution];
		for (int i = 0; i < grid.Length; i++)
		{
			grid[i] = SeedRandom.Range(ref seed, 0, 2) == 0;
		}
		SetEntrance(3, 0);
		for (int j = 0; j < gridResolution; j++)
		{
			for (int k = 0; k < gridResolution; k++)
			{
				if (GetGridState(j, k) && !HasPathToEntrance(j, k))
				{
					SetGridState(j, k, state: false);
				}
			}
		}
		for (int l = 0; l < gridResolution; l++)
		{
			for (int m = 0; m < gridResolution; m++)
			{
				if (!GetGridState(l, m))
				{
					continue;
				}
				bool gridState = GetGridState(l, m + 1);
				bool gridState2 = GetGridState(l, m - 1);
				bool gridState3 = GetGridState(l - 1, m);
				bool gridState4 = GetGridState(l + 1, m);
				bool flag = IsEntrance(l, m);
				GameObjectRef gameObjectRef = null;
				ProceduralDungeonCell proceduralDungeonCell = null;
				if ((Object)(object)proceduralDungeonCell == (Object)null)
				{
					foreach (GameObjectRef cellPrefabReference in cellPrefabReferences)
					{
						ProceduralDungeonCell component = cellPrefabReference.Get().GetComponent<ProceduralDungeonCell>();
						if (component.north == gridState && component.south == gridState2 && component.west == gridState3 && component.east == gridState4 && component.entrance == flag)
						{
							proceduralDungeonCell = component;
							gameObjectRef = cellPrefabReference;
							break;
						}
					}
				}
				if ((Object)(object)proceduralDungeonCell != (Object)null)
				{
					ProceduralDungeonCell proceduralDungeonCell2 = CellInstantiate(gameObjectRef.resourcePath);
					((Component)proceduralDungeonCell2).transform.position = val + new Vector3((float)l * gridSpacing, 0f, (float)m * gridSpacing);
					spawnedCells.Add(proceduralDungeonCell2);
					((Component)proceduralDungeonCell2).transform.SetParent(((Component)this).transform);
					if (proceduralDungeonCell2.entrance && (Object)(object)entranceHack == (Object)null)
					{
						entranceHack = proceduralDungeonCell2;
					}
				}
			}
		}
	}

	public ProceduralDungeonCell CellInstantiate(string path)
	{
		if (base.isServer)
		{
			return GameManager.server.CreatePrefab(path).GetComponent<ProceduralDungeonCell>();
		}
		return null;
	}

	public void RetireCell(GameObject cell)
	{
		if (!((Object)(object)cell == (Object)null) && base.isServer)
		{
			GameManager.server.Retire(cell);
		}
	}

	public void RetireAllCells()
	{
		if (base.isServer)
		{
			CleanupSpawnGroups();
		}
		for (int num = spawnedCells.Count - 1; num >= 0; num--)
		{
			ProceduralDungeonCell proceduralDungeonCell = spawnedCells[num];
			if (Object.op_Implicit((Object)(object)proceduralDungeonCell))
			{
				RetireCell(((Component)proceduralDungeonCell).gameObject);
			}
		}
		spawnedCells.Clear();
	}

	public bool CanSeeEntrance(int x, int y, ref List<int> checkedCells)
	{
		int gridIndex = GetGridIndex(x, y);
		if (checkedCells.Contains(gridIndex))
		{
			return false;
		}
		checkedCells.Add(gridIndex);
		if (!GetGridState(x, y))
		{
			return false;
		}
		if (IsEntrance(x, y))
		{
			return true;
		}
		bool num = CanSeeEntrance(x, y + 1, ref checkedCells);
		bool flag = CanSeeEntrance(x, y - 1, ref checkedCells);
		bool flag2 = CanSeeEntrance(x - 1, y, ref checkedCells);
		bool flag3 = CanSeeEntrance(x + 1, y, ref checkedCells);
		return num || flag3 || flag2 || flag;
	}

	public bool HasPathToEntrance(int x, int y)
	{
		List<int> checkedCells = new List<int>();
		bool result = CanSeeEntrance(x, y, ref checkedCells);
		checkedCells.Clear();
		return result;
	}

	public bool CanFindEntrance(int x, int y)
	{
		new List<int>();
		GetGridState(x, y + 1);
		GetGridState(x, y - 1);
		GetGridState(x - 1, y);
		GetGridState(x + 1, y);
		return true;
	}

	public bool IsEntrance(int x, int y)
	{
		return GetGridIndex(x, y) == GetEntranceIndex();
	}

	public int GetEntranceIndex()
	{
		return GetGridIndex(3, 0);
	}

	public void SetEntrance(int x, int y)
	{
		grid[GetGridIndex(x, y)] = true;
		grid[GetGridIndex(x, y + 1)] = true;
		grid[GetGridIndex(x - 1, y)] = false;
		grid[GetGridIndex(x + 1, y)] = false;
		grid[GetGridIndex(x, y + 2)] = true;
		grid[GetGridIndex(x + 1, y + 2)] = SeedRandom.Range(ref seed, 0, 1) == 1;
		grid[GetGridIndex(x + 2, y + 2)] = SeedRandom.Range(ref seed, 0, 1) == 1;
		grid[GetGridIndex(x, y + 3)] = true;
		grid[GetGridIndex(x, y + 4)] = true;
		grid[GetGridIndex(x - 1, y + 4)] = SeedRandom.Range(ref seed, 0, 1) == 1;
		grid[GetGridIndex(x - 2, y + 4)] = SeedRandom.Range(ref seed, 0, 1) == 1;
	}

	public void SetGridState(int x, int y, bool state)
	{
		int gridIndex = GetGridIndex(x, y);
		grid[gridIndex] = state;
	}

	public bool GetGridState(int x, int y)
	{
		if (GetGridIndex(x, y) >= grid.Length)
		{
			return false;
		}
		if (x < 0 || x >= gridResolution)
		{
			return false;
		}
		if (y < 0 || y >= gridResolution)
		{
			return false;
		}
		return grid[GetGridIndex(x, y)];
	}

	public int GetGridX(int index)
	{
		return index % gridResolution;
	}

	public int GetGridY(int index)
	{
		return Mathf.FloorToInt((float)index / (float)gridResolution);
	}

	public int GetGridIndex(int x, int y)
	{
		return y * gridResolution + x;
	}
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class CinematicScenePlaybackEntity : BaseEntity
{
	public Animator RootAnimator;

	public GameObjectRef CinematicUI;

	public float Duration = 10f;

	public GameObject DebugRoot;

	public bool ShowDebugRoot;

	public Transform LookPosition;

	public bool UseCinemachineBrain = true;

	public bool HidePlayerLegs = true;

	public float FadeToBlackTime = 0.5f;

	private EntityRef<BasePlayer> currentPlayer;

	public void SignalKillPlayer()
	{
		if (!base.isServer)
		{
			return;
		}
		BasePlayer basePlayer = currentPlayer.Get(serverside: true);
		if ((Object)(object)basePlayer != (Object)null)
		{
			TutorialIsland currentTutorialIsland = basePlayer.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				currentTutorialIsland.OnPlayerCompletedTutorial(basePlayer, isQuit: false, triggerAnalytics: true);
			}
		}
	}

	public void SignalFadeToBlack()
	{
	}

	public void AssignPlayer(BasePlayer bp)
	{
		currentPlayer.Set(bp);
		SendNetworkUpdate();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)Timeout, Duration);
	}

	private void Timeout()
	{
		BasePlayer basePlayer = currentPlayer.Get(serverside: true);
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.Respawn();
		}
		Kill();
	}

	public override void Save(SaveInfo info)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		BasePlayer basePlayer = currentPlayer.Get(serverside: true);
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (info.msg.cinematicEntity == null)
			{
				info.msg.cinematicEntity = Pool.Get<CinematicEntity>();
			}
			info.msg.cinematicEntity.targetPlayer = basePlayer.net.ID;
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		currentPlayer.Set(null);
		if (info.msg.cinematicEntity != null)
		{
			currentPlayer.uid = info.msg.cinematicEntity.targetPlayer;
		}
	}
}


using UnityEngine;

public class MenuHelp : MonoBehaviour
{
	public TutorialFullScreenHelpInfo[] AllHelp;

	public RectTransform CategoriesParent;

	public RectTransform ContentParent;

	public GameObjectRef CategoryWidget;

	public GameObjectRef HelpWidget;

	public TutorialFullScreenHelpInfo.MenuCategory StartingCategory;
}


using Rust.UI;
using UnityEngine;

public class MenuHelpCategory : MonoBehaviour
{
	public RustText CategoryText;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Video;

public class MenuHelpWidget : MonoBehaviour
{
	public RustText HelpText;

	public Image HelpImage;

	public VideoPlayer HelpVideo;

	public RawImage HelpVideoTexture;
}


using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Video;

[CreateAssetMenu(menuName = "Rust/Tutorials/Full Screen Help Info")]
public class TutorialFullScreenHelpInfo : ScriptableObject
{
	public enum MenuCategory
	{
		Movement,
		Crafting,
		Combat,
		Building
	}

	public static Phrase MovementPhrase = new Phrase("help_cat_movement", "MOVEMENT");

	public static Phrase CraftingPhrase = new Phrase("help_cat_crafting", "CRAFTING");

	public static Phrase CombatPhrase = new Phrase("help_cat_combat", "COMBAT");

	public static Phrase BuildingPhrase = new Phrase("help_cat_building", "BUILDING");

	public static Dictionary<MenuCategory, Phrase> CategoryPhraseLookup = new Dictionary<MenuCategory, Phrase>
	{
		{
			MenuCategory.Movement,
			MovementPhrase
		},
		{
			MenuCategory.Crafting,
			CraftingPhrase
		},
		{
			MenuCategory.Combat,
			CombatPhrase
		},
		{
			MenuCategory.Building,
			BuildingPhrase
		}
	};

	public MenuCategory Category;

	public int Priority;

	public TokenisedPhrase TextToDisplay;

	public Sprite StaticImage;

	public VideoClip VideoClip;
}


public enum MenuCategory
{
	Movement,
	Crafting,
	Combat,
	Building
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Tutorials/Help Set")]
public class TutorialMissionHelpSet : ScriptableObject
{
	public TutorialFullScreenHelpInfo[] Infos;
}


public class TriggerTutorialPrompt : TriggerBase
{
	public enum CustomCloseAction
	{
		None,
		OpenInventory,
		Sprint,
		Crouch
	}

	public TutorialFullScreenHelpInfo ToDisplay;

	public BaseMission RequiredMission;

	public int RequiredMissionStageActive = -1;

	public bool OnlyShowOnce;

	public CustomCloseAction CloseAction;

	public bool DebugConditions;

	public bool DeathDisplay;
}


public enum CustomCloseAction
{
	None,
	OpenInventory,
	Sprint,
	Crouch
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class TutorialBuildTarget : MonoBehaviour
{
	public BaseEntityRef TargetPrefab;

	public ItemDefinition TargetItemDef;

	public GameObject VisualObject;

	public Vector3 PhysCheckOffset = Vector3.zero;

	public bool Snap = true;

	public float MaxDistance = 0.5f;

	public BaseMission RequiredMission;

	public int RequiredMissionStage = -1;

	public float MaxValidAngle = 180f;

	public bool IsValid(Construction toConstruct, Construction.Target target, ref Construction.Placement placement)
	{
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		UpdateActive(target.player);
		if (!((Component)this).gameObject.activeInHierarchy)
		{
			return false;
		}
		if (!TargetPrefab.isValid || toConstruct.prefabID != TargetPrefab.Get().prefabID)
		{
			bool flag = false;
			if ((Object)(object)TargetItemDef != (Object)null && (Object)(object)target.player != (Object)null && (Object)(object)target.player.GetHeldEntity() != (Object)null && target.player.GetHeldEntity().GetItem() != null)
			{
				Item item = target.player.GetHeldEntity().GetItem();
				if ((Object)(object)item.info != (Object)null && (Object)(object)item.info.isRedirectOf == (Object)(object)TargetItemDef)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return false;
			}
		}
		if (Vector3.Distance(placement.position, ((Component)this).transform.position) < MaxDistance)
		{
			if (target.socket != null && MaxValidAngle < 180f && Vector3.Angle(((Component)this).transform.forward, placement.rotation * Vector3.forward) > MaxValidAngle)
			{
				return false;
			}
			if (Snap)
			{
				placement.position = ((Component)this).transform.position;
				placement.rotation = ((Component)this).transform.rotation;
			}
			return true;
		}
		return false;
	}

	public bool IsValid(BasePlayer player, Deployable deployable, Vector3 worldPosition, Quaternion worldRotation)
	{
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		UpdateActive(player);
		if (!((Component)this).gameObject.activeInHierarchy)
		{
			return false;
		}
		if (!TargetPrefab.isValid || deployable.prefabID != TargetPrefab.Get().prefabID)
		{
			bool flag = false;
			if ((Object)(object)TargetItemDef != (Object)null && (Object)(object)player != (Object)null && (Object)(object)player.GetHeldEntity() != (Object)null && player.GetHeldEntity().GetItem() != null)
			{
				Item item = player.GetHeldEntity().GetItem();
				if ((Object)(object)item.info != (Object)null && (Object)(object)item.info.isRedirectOf == (Object)(object)TargetItemDef)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return false;
			}
		}
		if (Vector3.Distance(worldPosition, ((Component)this).transform.position) < MaxDistance)
		{
			return true;
		}
		return false;
	}

	public void UpdateActive(BasePlayer p)
	{
		if ((Object)(object)p == (Object)null || !p.HasActiveMission())
		{
			((Component)this).gameObject.SetActive(false);
			return;
		}
		BaseMission.MissionInstance activeMissionInstance = p.GetActiveMissionInstance();
		bool flag = activeMissionInstance != null && activeMissionInstance.GetMission() == RequiredMission;
		if (flag && RequiredMissionStage >= 0 && !activeMissionInstance.objectiveStatuses[RequiredMissionStage].started)
		{
			flag = false;
		}
		((Component)this).gameObject.SetActive(flag && !HasTargetBeenBuilt());
	}

	private bool HasTargetBeenBuilt()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (!TargetPrefab.isValid)
		{
			return false;
		}
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(((Component)this).transform.position + PhysCheckOffset, 0.5f + MaxDistance, list, 1218652417, (QueryTriggerInteraction)2);
		bool flag = false;
		uint prefabID = TargetPrefab.Get().prefabID;
		foreach (BaseEntity item in list)
		{
			if (item.prefabID == prefabID)
			{
				flag = true;
				break;
			}
			if (item is Door)
			{
				foreach (BaseEntity child in item.children)
				{
					if (child.prefabID == prefabID)
					{
						flag = true;
						break;
					}
				}
			}
			if (flag)
			{
				break;
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return flag;
	}
}


using System.Collections.Generic;
using UnityEngine;

public static class TutorialIslandSpawner
{
	public static List<Vector3> GetEdgeSpawnPoints(Vector3 start, Vector3 bounds, Vector3 cellSize, int loopCount, out Bounds worldBoundsMinusTutorialIslands)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < loopCount; i++)
		{
			list.AddRange(GetEdgeSpawnPoints(start, bounds, cellSize, i));
		}
		worldBoundsMinusTutorialIslands = new Bounds(start + bounds / 2f, bounds - cellSize * 2f * (float)loopCount);
		((Bounds)(ref worldBoundsMinusTutorialIslands)).size = new Vector3(((Bounds)(ref worldBoundsMinusTutorialIslands)).size.x, 1000f, ((Bounds)(ref worldBoundsMinusTutorialIslands)).size.z);
		return list;
	}

	public static List<Vector3> GetEdgeSpawnPoints(Vector3 start, Vector3 bounds, Vector3 cellSize, int curLoop)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		List<Vector3> list = new List<Vector3>();
		bounds -= cellSize * 2f * (float)curLoop;
		start += cellSize * (float)curLoop;
		Vector3 val = start + bounds - cellSize / 2f;
		int num = (int)(bounds.x / cellSize.x);
		int num2 = (int)(bounds.z / cellSize.z);
		Vector3 val2 = start + cellSize / 2f;
		for (int i = 0; i < num; i++)
		{
			list.Add(val2);
			list.Add(new Vector3(val2.x, 0f, val.z));
			val2 += new Vector3(cellSize.x, 0f, 0f);
		}
		val2 = start + cellSize / 2f + new Vector3(0f, 0f, cellSize.z);
		for (int j = 1; j < num2 - 1; j++)
		{
			list.Add(val2);
			list.Add(new Vector3(val.x, 0f, val2.z));
			val2 += new Vector3(0f, 0f, cellSize.z);
		}
		return list;
	}
}


public class TutorialIsland_MapMarker : MapMarker
{
}


using System;
using System.Collections.Generic;
using ConVar;
using UnityEngine;

[CreateAssetMenu(fileName = "NewConversation", menuName = "Rust/ConversationData", order = 1)]
public class ConversationData : ScriptableObject
{
	[Serializable]
	public class ConversationCondition
	{
		public enum ConditionType
		{
			None,
			HasHealth,
			HasScrap,
			ProviderBusy,
			MissionComplete,
			MissionAttempted,
			CanAccept,
			ConVar
		}

		public ConditionType conditionType;

		public uint conditionAmount;

		public string conditionString = "";

		public BaseMission conditionMission;

		public bool inverse;

		public string failedSpeechNode;

		public bool Passes(BasePlayer player, IConversationProvider provider)
		{
			bool flag = false;
			if (conditionType == ConditionType.HasScrap)
			{
				flag = player.inventory.GetAmount(ItemManager.FindItemDefinition("scrap").itemid) >= conditionAmount;
			}
			else if (conditionType == ConditionType.HasHealth)
			{
				flag = player.health >= (float)conditionAmount;
			}
			else if (conditionType == ConditionType.ProviderBusy)
			{
				flag = provider.ProviderBusy();
			}
			else if (conditionType == ConditionType.MissionComplete)
			{
				flag = player.HasCompletedMission(MissionID());
			}
			else if (conditionType == ConditionType.MissionAttempted)
			{
				flag = player.HasAttemptedMission(MissionID());
			}
			else if (conditionType == ConditionType.CanAccept)
			{
				flag = player.CanAcceptMission(MissionID());
			}
			else if (conditionType == ConditionType.ConVar)
			{
				flag = GetNPCConvar(conditionString);
			}
			if (!inverse)
			{
				return flag;
			}
			return !flag;
		}

		private static bool GetNPCConvar(string convarString)
		{
			return convarString switch
			{
				"vendor_minicopter_enabled" => NPC_ConVars.vendor_minicopter_enabled, 
				"vendor_attack_heli_enabled" => NPC_ConVars.vendor_attack_heli_enabled, 
				"vendor_scrap_heli_enabled" => NPC_ConVars.vendor_scrap_heli_enabled, 
				"vendor_hab_enabled" => NPC_ConVars.vendor_hab_enabled, 
				"vendor_rowboat_enabled" => NPC_ConVars.vendor_rowboat_enabled, 
				"vendor_rhib_enabled" => NPC_ConVars.vendor_rhib_enabled, 
				"vendor_sub_solo_enabled" => NPC_ConVars.vendor_sub_solo_enabled, 
				"vendor_sub_duo_enabled" => NPC_ConVars.vendor_sub_duo_enabled, 
				_ => false, 
			};
		}

		private uint MissionID()
		{
			if (!(conditionMission != null))
			{
				return conditionAmount;
			}
			return conditionMission.id;
		}
	}

	[Serializable]
	public class ResponseNode
	{
		public enum ActionType
		{
			Custom,
			None,
			AssignMission
		}

		public Phrase responseTextLocalized;

		public ConversationCondition[] conditions;

		public ActionType actionType;

		public string actionString;

		public BaseMission actionMission;

		public string resultingSpeechNode;

		public string responseText => responseTextLocalized.translated;

		public bool PassesConditions(BasePlayer player, IConversationProvider provider)
		{
			ConversationCondition[] array = conditions;
			for (int i = 0; i < array.Length; i++)
			{
				if (!array[i].Passes(player, provider))
				{
					return false;
				}
			}
			return true;
		}

		public string GetFailedSpeechNode(BasePlayer player, IConversationProvider provider)
		{
			ConversationCondition[] array = conditions;
			foreach (ConversationCondition conversationCondition in array)
			{
				if (!conversationCondition.Passes(player, provider))
				{
					return conversationCondition.failedSpeechNode;
				}
			}
			return "";
		}

		public string GetActionString()
		{
			switch (actionType)
			{
			case ActionType.None:
				return "";
			case ActionType.Custom:
				return actionString ?? "";
			case ActionType.AssignMission:
				if (!(actionMission != null) || string.IsNullOrWhiteSpace(actionMission.shortname))
				{
					return "";
				}
				return "assignmission " + actionMission.shortname;
			default:
				Debug.LogWarning((object)$"Cannot get conversation action string! Unhandled action type: {actionType}");
				return "";
			}
		}
	}

	[Serializable]
	public class SpeechNode
	{
		public string shortname;

		public Phrase statementLocalized;

		public ResponseNode[] responses;

		public Vector2 nodePosition;

		public string statement => statementLocalized.translated;
	}

	public string shortname;

	public Phrase providerNameTranslated;

	public Sprite providerIcon;

	public bool canBeCancelled = true;

	public SpeechNode[] speeches;

	public string providerName => providerNameTranslated.translated;

	public int GetSpeechNodeIndex(string speechShortName)
	{
		for (int i = 0; i < speeches.Length; i++)
		{
			if (speeches[i].shortname == speechShortName)
			{
				return i;
			}
		}
		return -1;
	}

	public void FindAllMissionAssignments(List<BaseMission> results)
	{
		SpeechNode[] array = speeches;
		for (int i = 0; i < array.Length; i++)
		{
			ResponseNode[] responses = array[i].responses;
			foreach (ResponseNode responseNode in responses)
			{
				if (responseNode.actionType == ResponseNode.ActionType.AssignMission && responseNode.actionMission != null)
				{
					results.Add(responseNode.actionMission);
				}
			}
		}
	}
}


using System;
using ConVar;

[Serializable]
public class ConversationCondition
{
	public enum ConditionType
	{
		None,
		HasHealth,
		HasScrap,
		ProviderBusy,
		MissionComplete,
		MissionAttempted,
		CanAccept,
		ConVar
	}

	public ConditionType conditionType;

	public uint conditionAmount;

	public string conditionString = "";

	public BaseMission conditionMission;

	public bool inverse;

	public string failedSpeechNode;

	public bool Passes(BasePlayer player, IConversationProvider provider)
	{
		bool flag = false;
		if (conditionType == ConditionType.HasScrap)
		{
			flag = player.inventory.GetAmount(ItemManager.FindItemDefinition("scrap").itemid) >= conditionAmount;
		}
		else if (conditionType == ConditionType.HasHealth)
		{
			flag = player.health >= (float)conditionAmount;
		}
		else if (conditionType == ConditionType.ProviderBusy)
		{
			flag = provider.ProviderBusy();
		}
		else if (conditionType == ConditionType.MissionComplete)
		{
			flag = player.HasCompletedMission(MissionID());
		}
		else if (conditionType == ConditionType.MissionAttempted)
		{
			flag = player.HasAttemptedMission(MissionID());
		}
		else if (conditionType == ConditionType.CanAccept)
		{
			flag = player.CanAcceptMission(MissionID());
		}
		else if (conditionType == ConditionType.ConVar)
		{
			flag = GetNPCConvar(conditionString);
		}
		if (!inverse)
		{
			return flag;
		}
		return !flag;
	}

	private static bool GetNPCConvar(string convarString)
	{
		return convarString switch
		{
			"vendor_minicopter_enabled" => NPC_ConVars.vendor_minicopter_enabled, 
			"vendor_attack_heli_enabled" => NPC_ConVars.vendor_attack_heli_enabled, 
			"vendor_scrap_heli_enabled" => NPC_ConVars.vendor_scrap_heli_enabled, 
			"vendor_hab_enabled" => NPC_ConVars.vendor_hab_enabled, 
			"vendor_rowboat_enabled" => NPC_ConVars.vendor_rowboat_enabled, 
			"vendor_rhib_enabled" => NPC_ConVars.vendor_rhib_enabled, 
			"vendor_sub_solo_enabled" => NPC_ConVars.vendor_sub_solo_enabled, 
			"vendor_sub_duo_enabled" => NPC_ConVars.vendor_sub_duo_enabled, 
			_ => false, 
		};
	}

	private uint MissionID()
	{
		if (!(conditionMission != null))
		{
			return conditionAmount;
		}
		return conditionMission.id;
	}
}


public enum ConditionType
{
	None,
	HasHealth,
	HasScrap,
	ProviderBusy,
	MissionComplete,
	MissionAttempted,
	CanAccept,
	ConVar
}


using System;
using UnityEngine;

[Serializable]
public class ResponseNode
{
	public enum ActionType
	{
		Custom,
		None,
		AssignMission
	}

	public Phrase responseTextLocalized;

	public ConversationCondition[] conditions;

	public ActionType actionType;

	public string actionString;

	public BaseMission actionMission;

	public string resultingSpeechNode;

	public string responseText => responseTextLocalized.translated;

	public bool PassesConditions(BasePlayer player, IConversationProvider provider)
	{
		ConversationCondition[] array = conditions;
		for (int i = 0; i < array.Length; i++)
		{
			if (!array[i].Passes(player, provider))
			{
				return false;
			}
		}
		return true;
	}

	public string GetFailedSpeechNode(BasePlayer player, IConversationProvider provider)
	{
		ConversationCondition[] array = conditions;
		foreach (ConversationCondition conversationCondition in array)
		{
			if (!conversationCondition.Passes(player, provider))
			{
				return conversationCondition.failedSpeechNode;
			}
		}
		return "";
	}

	public string GetActionString()
	{
		switch (actionType)
		{
		case ActionType.None:
			return "";
		case ActionType.Custom:
			return actionString ?? "";
		case ActionType.AssignMission:
			if (!(actionMission != null) || string.IsNullOrWhiteSpace(actionMission.shortname))
			{
				return "";
			}
			return "assignmission " + actionMission.shortname;
		default:
			Debug.LogWarning((object)$"Cannot get conversation action string! Unhandled action type: {actionType}");
			return "";
		}
	}
}


public enum ActionType
{
	Custom,
	None,
	AssignMission
}


using System;
using UnityEngine;

[Serializable]
public class SpeechNode
{
	public string shortname;

	public Phrase statementLocalized;

	public ResponseNode[] responses;

	public Vector2 nodePosition;

	public string statement => statementLocalized.translated;
}


using System;
using UnityEngine;

public class HorseSpawner : VehicleSpawner
{
	public float respawnDelay = 10f;

	public float respawnDelayVariance = 5f;

	public bool spawnForSale = true;

	protected override bool LogAnalytics => false;

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)RespawnHorse, Random.Range(0f, 4f), respawnDelay, respawnDelayVariance);
	}

	public override int GetOccupyLayer()
	{
		return 2048;
	}

	public void RespawnHorse()
	{
		if (GetVehicleOccupying() != null)
		{
			return;
		}
		IVehicleSpawnUser vehicleSpawnUser = SpawnVehicle(objectsToSpawn[0].prefabToSpawn.resourcePath, null);
		if (spawnForSale)
		{
			RidableHorse ridableHorse = vehicleSpawnUser as RidableHorse;
			if ((Object)(object)ridableHorse != (Object)null)
			{
				ridableHorse.SetForSale();
			}
		}
	}
}


public static class ConversationManager
{
}


using System.Collections.Generic;

public interface IConversationProvider
{
	void GetGenericMissionList(List<BaseMission> foundMissions);

	bool ProviderBusy();
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class NPCMissionProvider : NPCTalking, IMissionProvider
{
	public MissionManifest manifest;

	public GameObjectRef MarkerPrefab;

	public BaseMission[] FallbackMissions = new BaseMission[0];

	public NetworkableId ProviderID()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return net.ID;
	}

	public Vector3 ProviderPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public BaseEntity Entity()
	{
		return this;
	}

	public override void ServerInit()
	{
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (MarkerPrefab != null && MarkerPrefab.isValid)
		{
			List<BaseMission> list = Pool.Get<List<BaseMission>>();
			ConversationData[] array = conversations;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].FindAllMissionAssignments(list);
			}
			BaseMission[] fallbackMissions = FallbackMissions;
			foreach (BaseMission item in fallbackMissions)
			{
				list.Add(item);
			}
			if (list.Count > 0)
			{
				MapMarkerMissionProvider obj = GameManager.server.CreateEntity(MarkerPrefab.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation) as MapMarkerMissionProvider;
				obj.AssignMissions(list, GetProviderToken());
				obj.Spawn();
			}
			Pool.FreeUnmanaged<BaseMission.MissionInstance>(ref missions);
		}
	}

	private string GetProviderToken()
	{
		ConversationData[] array = conversations;
		int num = 0;
		if (num < array.Length)
		{
			return array[num].providerNameTranslated.token;
		}
		return string.Empty;
	}

	public override void OnConversationEnded(BasePlayer player)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		player.ProcessMissionEvent(BaseMission.MissionEventType.CONVERSATION, ProviderID(), 0f);
		base.OnConversationEnded(player);
	}

	public override void OnConversationStarted(BasePlayer speakingTo)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		speakingTo.ProcessMissionEvent(BaseMission.MissionEventType.CONVERSATION, ProviderID(), 1f);
		base.OnConversationStarted(speakingTo);
	}

	public bool ContainsSpeech(string speech)
	{
		ConversationData[] array = conversations;
		for (int i = 0; i < array.Length; i++)
		{
			ConversationData.SpeechNode[] speeches = array[i].speeches;
			for (int j = 0; j < speeches.Length; j++)
			{
				if (speeches[j].shortname == speech)
				{
					return true;
				}
			}
		}
		return false;
	}

	public string IntroOverride(string overrideSpeech)
	{
		if (!ContainsSpeech(overrideSpeech))
		{
			return "intro";
		}
		return overrideSpeech;
	}

	public override string GetConversationStartSpeech(BasePlayer player)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		string text = "";
		foreach (BaseMission.MissionInstance mission in player.missions)
		{
			if (mission.status == BaseMission.MissionStatus.Active)
			{
				text = IntroOverride("missionactive");
			}
			if (mission.status == BaseMission.MissionStatus.Completed && mission.providerID == ProviderID() && Time.time - mission.endTime < 5f)
			{
				text = IntroOverride("missionreturn");
			}
		}
		if (string.IsNullOrEmpty(text))
		{
			text = base.GetConversationStartSpeech(player);
		}
		return text;
	}

	public override void OnConversationAction(BasePlayer player, string action)
	{
		if (action.StartsWith("assignmission "))
		{
			int num = action.IndexOf(" ");
			BaseMission fromShortName = MissionManifest.GetFromShortName(action.Substring(num + 1));
			if (Object.op_Implicit((Object)(object)fromShortName))
			{
				BaseMission.AssignMission(player, this, fromShortName);
			}
		}
		base.OnConversationAction(player, action);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class NPCShopKeeper : NPCPlayer
{
	public EntityRef invisibleVendingMachineRef;

	public InvisibleVendingMachine machine;

	public bool canBeHurt;

	public float greetDir;

	public Vector3 initialFacingDir;

	public BasePlayer lastWavedAtPlayer;

	protected override string OverrideCorpseName => "Shopkeeper";

	public InvisibleVendingMachine GetVendingMachine()
	{
		if (!invisibleVendingMachineRef.IsValid(base.isServer))
		{
			return null;
		}
		return ((Component)invisibleVendingMachineRef.Get(base.isServer)).GetComponent<InvisibleVendingMachine>();
	}

	public override void UpdateProtectionFromClothing()
	{
	}

	protected override bool AllowRagdoll()
	{
		return canBeHurt;
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if ((Object)(object)invisibleVendingMachineRef.Get(base.isServer) != (Object)null && invisibleVendingMachineRef.Get(base.isServer) is InvisibleVendingMachine invisibleVendingMachine)
		{
			invisibleVendingMachine.SetAttachedNPC(null);
		}
	}

	public override void Hurt(HitInfo info)
	{
		if (canBeHurt)
		{
			base.Hurt(info);
		}
	}

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		Quaternion rotation = ((Component)this).transform.rotation;
		initialFacingDir = rotation * Vector3.forward;
		((FacepunchBehaviour)this).Invoke((Action)DelayedSleepEnd, 3f);
		SetAimDirection(rotation * Vector3.forward);
		((FacepunchBehaviour)this).InvokeRandomized((Action)Greeting, Random.Range(5f, 10f), 5f, Random.Range(0f, 2f));
	}

	public override void PostInitShared()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		base.PostInitShared();
		if (base.isServer)
		{
			if ((Object)(object)machine == (Object)null)
			{
				machine = InvisibleVendingMachine.GetMachineAtPosition(1f, ((Component)this).transform.position);
			}
			if (invisibleVendingMachineRef.IsValid(serverside: true) && (Object)(object)machine == (Object)null)
			{
				machine = GetVendingMachine();
				machine.SetAttachedNPC(this);
			}
			else if ((Object)(object)machine != (Object)null && !invisibleVendingMachineRef.IsValid(serverside: true))
			{
				invisibleVendingMachineRef.Set(machine);
				machine.SetAttachedNPC(this);
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.shopKeeper = Pool.Get<ShopKeeper>();
		info.msg.shopKeeper.vendingRef = invisibleVendingMachineRef.uid;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.shopKeeper != null)
		{
			invisibleVendingMachineRef.uid = info.msg.shopKeeper.vendingRef;
		}
	}

	public void DelayedSleepEnd()
	{
		EndSleeping();
	}

	public virtual void GreetPlayer(BasePlayer player)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player != (Object)null)
		{
			SignalBroadcast(Signal.Gesture, "wave");
			SetAimDirection(Vector3Ex.Direction2D(player.eyes.position, base.eyes.position));
			lastWavedAtPlayer = player;
		}
		else
		{
			SetAimDirection(initialFacingDir);
		}
	}

	public virtual void Greeting()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Vis.Entities(((Component)this).transform.position, 10f, list, 131072, (QueryTriggerInteraction)2);
		BasePlayer basePlayer = null;
		foreach (BasePlayer item in list)
		{
			if (!item.isClient && !item.IsNpc && !((Object)(object)item == (Object)(object)this) && item.IsVisible(base.eyes.position) && !((Object)(object)item == (Object)(object)lastWavedAtPlayer) && !(Vector3.Dot(Vector3Ex.Direction2D(item.eyes.position, base.eyes.position), initialFacingDir) < 0.2f))
			{
				basePlayer = item;
				break;
			}
		}
		if ((Object)(object)basePlayer == (Object)null && !list.Contains(lastWavedAtPlayer))
		{
			lastWavedAtPlayer = null;
		}
		if ((Object)(object)basePlayer != (Object)null)
		{
			SignalBroadcast(Signal.Gesture, "wave");
			SetAimDirection(Vector3Ex.Direction2D(basePlayer.eyes.position, base.eyes.position));
			lastWavedAtPlayer = basePlayer;
		}
		else
		{
			SetAimDirection(initialFacingDir);
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class NPCSimpleMissionProvider : NPCTalking, IMissionProvider
{
	public GameObjectRef MarkerPrefab;

	public Phrase NPCName = new Phrase("", "");

	public override void ServerInit()
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (MarkerPrefab != null && MarkerPrefab.isValid)
		{
			List<BaseMission> list = Pool.Get<List<BaseMission>>();
			GetAvailableMissions(list);
			if (list.Count > 0)
			{
				MapMarkerMissionProvider obj = GameManager.server.CreateEntity(MarkerPrefab.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation) as MapMarkerMissionProvider;
				obj.AssignMissions(list, NPCName.token);
				obj.Spawn();
			}
			Pool.FreeUnmanaged<BaseMission.MissionInstance>(ref missions);
		}
	}

	public override void OnConversationEnded(BasePlayer player)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		player.ProcessMissionEvent(BaseMission.MissionEventType.CONVERSATION, ProviderID(), 0f);
		base.OnConversationEnded(player);
	}

	public override void OnConversationStarted(BasePlayer speakingTo)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		speakingTo.ProcessMissionEvent(BaseMission.MissionEventType.CONVERSATION, ProviderID(), 1f);
		base.OnConversationStarted(speakingTo);
	}

	protected override void TryAssignMissionToPlayer(BaseMission mission, BasePlayer player)
	{
		base.TryAssignMissionToPlayer(mission, player);
		BaseMission.AssignMission(player, this, mission);
	}

	public override string GetConversationStartSpeech(BasePlayer player)
	{
		PooledList<BaseMission> val = Pool.Get<PooledList<BaseMission>>();
		try
		{
			GetAvailableMissions((List<BaseMission>)(object)val);
			bool flag = false;
			foreach (BaseMission item in (List<BaseMission>)(object)val)
			{
				if (player.CanAcceptMission(item))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return "intro_no_missions";
			}
			return base.GetConversationStartSpeech(player);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void GetGenericMissionList(List<BaseMission> foundMissions)
	{
		base.GetGenericMissionList(foundMissions);
		GetAvailableMissions(foundMissions);
	}

	private void GetAvailableMissions(List<BaseMission> foundMissions)
	{
		ScriptableObjectRef[] missionList = MissionManifest.Get().missionList;
		NPCSimpleMissionProvider nPCSimpleMissionProvider = default(NPCSimpleMissionProvider);
		for (int i = 0; i < missionList.Length; i++)
		{
			BaseMission baseMission = missionList[i].Get() as BaseMission;
			if (baseMission != null && baseMission.genericMissionProvider.isValid && baseMission.genericMissionProvider.Get().TryGetComponent<NPCSimpleMissionProvider>(ref nPCSimpleMissionProvider) && nPCSimpleMissionProvider.prefabID == prefabID)
			{
				foundMissions.Add(baseMission);
			}
		}
	}

	public NetworkableId ProviderID()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return net.ID;
	}

	public Vector3 ProviderPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public BaseEntity Entity()
	{
		return this;
	}
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public class VehicleVendor : NPCTalking
{
	public EntityRef spawnerRef;

	public VehicleSpawner vehicleSpawner;

	public override string GetConversationStartSpeech(BasePlayer player)
	{
		if (ProviderBusy())
		{
			return "startbusy";
		}
		return "intro";
	}

	public VehicleSpawner GetVehicleSpawner()
	{
		if (!spawnerRef.IsValid(base.isServer))
		{
			return null;
		}
		return ((Component)spawnerRef.Get(base.isServer)).GetComponent<VehicleSpawner>();
	}

	public override void UpdateFlags()
	{
		base.UpdateFlags();
		VehicleSpawner vehicleSpawner = GetVehicleSpawner();
		bool b = (Object)(object)vehicleSpawner != (Object)null && vehicleSpawner.IsPadOccupied();
		SetFlag(Flags.Reserved1, b);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (spawnerRef.IsValid(serverside: true) && (Object)(object)vehicleSpawner == (Object)null)
		{
			vehicleSpawner = GetVehicleSpawner();
		}
		else if ((Object)(object)vehicleSpawner != (Object)null && !spawnerRef.IsValid(serverside: true))
		{
			spawnerRef.Set(vehicleSpawner);
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.vehicleVendor = Pool.Get<VehicleVendor>();
		info.msg.vehicleVendor.spawnerRef = spawnerRef.uid;
	}

	public override ConversationData GetConversationFor(BasePlayer player)
	{
		return conversations[0];
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.vehicleVendor != null)
		{
			spawnerRef.id_cached = info.msg.vehicleVendor.spawnerRef;
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.Rust;
using UnityEngine;

public class VehicleSpawner : BaseEntity
{
	public interface IVehicleSpawnUser
	{
		string ShortPrefabName { get; }

		bool IsClient { get; }

		bool IsDestroyed { get; }

		void SetupOwner(BasePlayer owner, Vector3 newSafeAreaOrigin, float newSafeAreaRadius);

		bool IsDespawnEligable();

		IFuelSystem GetFuelSystem();

		int StartingFuelUnits();

		void Kill(DestroyMode mode);
	}

	[Serializable]
	public class SpawnPair
	{
		public string message;

		public GameObjectRef prefabToSpawn;
	}

	public float spawnNudgeRadius = 6f;

	public float cleanupRadius = 10f;

	public float occupyRadius = 5f;

	public SpawnPair[] objectsToSpawn;

	public Transform spawnOffset;

	public float safeRadius = 10f;

	protected virtual bool LogAnalytics => true;

	public virtual int GetOccupyLayer()
	{
		return 32768;
	}

	public IVehicleSpawnUser GetVehicleOccupying()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		IVehicleSpawnUser result = null;
		List<IVehicleSpawnUser> list = Pool.Get<List<IVehicleSpawnUser>>();
		Vis.Entities(((Component)spawnOffset).transform.position, occupyRadius, list, GetOccupyLayer(), (QueryTriggerInteraction)1);
		if (list.Count > 0)
		{
			result = list[0];
		}
		Pool.FreeUnmanaged<IVehicleSpawnUser>(ref list);
		return result;
	}

	public bool IsPadOccupied()
	{
		IVehicleSpawnUser vehicleOccupying = GetVehicleOccupying();
		if (vehicleOccupying != null)
		{
			return !vehicleOccupying.IsDespawnEligable();
		}
		return false;
	}

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		BasePlayer newOwner = null;
		NPCTalking component = ((Component)from).GetComponent<NPCTalking>();
		if (Object.op_Implicit((Object)(object)component))
		{
			newOwner = component.GetActionPlayer();
		}
		SpawnPair[] array = objectsToSpawn;
		foreach (SpawnPair spawnPair in array)
		{
			if (msg == spawnPair.message)
			{
				SpawnVehicle(spawnPair.prefabToSpawn.resourcePath, newOwner);
				break;
			}
		}
	}

	public IVehicleSpawnUser SpawnVehicle(string prefabToSpawn, BasePlayer newOwner)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		CleanupArea(cleanupRadius);
		NudgePlayersInRadius(spawnNudgeRadius);
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefabToSpawn, ((Component)spawnOffset).transform.position, ((Component)spawnOffset).transform.rotation);
		baseEntity.Spawn();
		IVehicleSpawnUser component = ((Component)baseEntity).GetComponent<IVehicleSpawnUser>();
		if ((Object)(object)newOwner != (Object)null)
		{
			component.SetupOwner(newOwner, ((Component)spawnOffset).transform.position, safeRadius);
		}
		VehicleSpawnPoint.AddStartingFuel(component);
		if ((Object)(object)newOwner != (Object)null)
		{
			Analytics.Azure.OnVehiclePurchased(newOwner, baseEntity);
		}
		return component;
	}

	public void CleanupArea(float radius)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		List<IVehicleSpawnUser> list = Pool.Get<List<IVehicleSpawnUser>>();
		Vis.Entities(((Component)spawnOffset).transform.position, radius, list, 32768, (QueryTriggerInteraction)2);
		foreach (IVehicleSpawnUser item in list)
		{
			if (!item.IsClient && !item.IsDestroyed)
			{
				item.Kill(DestroyMode.None);
			}
		}
		List<ServerGib> list2 = Pool.Get<List<ServerGib>>();
		Vis.Entities(((Component)spawnOffset).transform.position, radius, list2, -2147483647, (QueryTriggerInteraction)2);
		foreach (ServerGib item2 in list2)
		{
			if (!item2.isClient)
			{
				item2.Kill();
			}
		}
		Pool.FreeUnmanaged<IVehicleSpawnUser>(ref list);
		Pool.FreeUnmanaged<ServerGib>(ref list2);
	}

	public void NudgePlayersInRadius(float radius)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Vis.Entities(((Component)spawnOffset).transform.position, radius, list, 131072, (QueryTriggerInteraction)2);
		foreach (BasePlayer item in list)
		{
			if (!item.IsNpc && !item.isMounted && item.IsConnected)
			{
				Vector3 position = ((Component)spawnOffset).transform.position;
				position += Vector3Ex.Direction2D(((Component)item).transform.position, ((Component)spawnOffset).transform.position) * radius;
				position += Vector3.up * 0.1f;
				item.MovePosition(position);
				item.ClientRPC(RpcTarget.Player("ForcePositionTo", item), position);
			}
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}
}


using UnityEngine;

public interface IVehicleSpawnUser
{
	string ShortPrefabName { get; }

	bool IsClient { get; }

	bool IsDestroyed { get; }

	void SetupOwner(BasePlayer owner, Vector3 newSafeAreaOrigin, float newSafeAreaRadius);

	bool IsDespawnEligable();

	IFuelSystem GetFuelSystem();

	int StartingFuelUnits();

	void Kill(DestroyMode mode);
}


using System;

[Serializable]
public class SpawnPair
{
	public string message;

	public GameObjectRef prefabToSpawn;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust.Ai;
using UnityEngine;

public class BeeSwarmAI : BaseCombatEntity, ISplashable
{
	[Header("Settings")]
	public float moveSpeed = 2f;

	public float stopThreshold = 0.2f;

	[Header("Animation")]
	public float ReductionAmount;

	public float ReductionDuration;

	public float Frequency;

	public ParticleSystem PSystem;

	public Light OnFireLight;

	public ParticleSystemForceField AngerForceField;

	private Vector3 pastPosition = Vector3.one;

	private Vector3 velocity = Vector3.zero;

	public const Flags IsAngry = Flags.Reserved12;

	public const Flags IsDying = Flags.Reserved13;

	public const Flags HasTarget = Flags.Reserved14;

	[ServerVar(Help = "How long a swarm will stick around without a target")]
	public static float killWithoutTargetTime = 150f;

	[ServerVar(Help = "How far away fire has to be to set the swarm on fire")]
	public static float flameSettingDistance = 5.5f;

	[ServerVar(Help = "How much water a player needs to be in to be ignored")]
	public static float waterThreshold = 0.6f;

	[ServerVar(Help = "Range to find new targets")]
	public static float searchRange = 10f;

	[ServerVar(Help = "Range to leave current target alone (should be higher than search)")]
	public static float breakRange = 15f;

	[ServerVar]
	public static bool disable = false;

	public static Phrase BeeHelpPhrase = (Phrase)(object)new TokenisedPhrase("bee.tip.help", "Throw water, light a fire, or put on a hazmat suit to deal with the bees.");

	private BasePlayer targetPlayer;

	private TimeSince timeSinceHadTarget;

	private float targetPlayerLastWaterLevel;

	private bool hasCameFromAHive;

	private TimeSince timeSinceEgress;

	private Vector3 egressDirection = Vector3.one;

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
	}

	private void Update()
	{
		DoAI();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk)
		{
			Die();
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (base.isServer)
		{
			SetFlag(Flags.Reserved12, b: true);
		}
	}

	public override void ServerInit()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		SetFlag(Flags.Reserved12, b: true);
		timeSinceHadTarget = TimeSince.op_Implicit(0f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)ThinkAI, 0f, 0.25f);
	}

	public void SetHasCameFromAHive(bool cameFromHive)
	{
		hasCameFromAHive = cameFromHive;
	}

	public void SetTarget(BasePlayer ply)
	{
		targetPlayer = ply;
	}

	private void ThinkAI()
	{
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BeeSwarmAI.ThinkAI", 0);
		try
		{
			if (!HasFlag(Flags.Reserved12) || disable)
			{
				return;
			}
			if (hasCameFromAHive)
			{
				if (AI.ignoreplayers || !AI.think)
				{
					return;
				}
			}
			else if (AI.effectaiweapons && (AI.ignoreplayers || !AI.think))
			{
				return;
			}
			if ((Object)(object)targetPlayer == (Object)null)
			{
				targetPlayer = FindTarget(((Component)this).transform);
				if ((Object)(object)targetPlayer != (Object)null)
				{
					targetPlayerLastWaterLevel = targetPlayer.metabolism.wetness.value;
					timeSinceHadTarget = TimeSince.op_Implicit(0f);
					SetFlag(Flags.Reserved14, b: true);
				}
			}
			ValidateTarget();
			if (IsSmoke())
			{
				StartDie();
			}
			if (TimeSince.op_Implicit(timeSinceHadTarget) > killWithoutTargetTime)
			{
				StartDie();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool IsSmoke()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			SingletonComponent<SmokeGrenadeManager>.Instance.GetSmokeAround(((Component)this).transform.position, 5f, (List<BaseEntity>)(object)val);
			return val != null && ((List<BaseEntity>)(object)val).Count > 0;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void DoAI()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BeeSwarmAI.DoAI", 0);
		try
		{
			if (HasFlag(Flags.Reserved12) && !disable && !((Object)(object)targetPlayer == (Object)null))
			{
				SteerToPlayer();
				Quaternion val2 = Quaternion.LookRotation(((Component)targetPlayer).transform.position - ((Component)this).transform.position);
				((Component)this).transform.rotation = Quaternion.Slerp(((Component)this).transform.rotation, val2, Time.deltaTime * 2f);
				if ((Object)(object)targetPlayer != (Object)null)
				{
					targetPlayerLastWaterLevel = targetPlayer.metabolism.wetness.value;
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool IsFire(out Vector3 firePosition)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			SingletonComponent<NpcFireManager>.Instance.GetFiresAround(GetTargetEyesPosition(), 2f, (List<BaseEntity>)(object)val);
			firePosition = Vector3.zero;
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				if (!((Object)(object)item == (Object)null) && !item.IsDestroyed)
				{
					if (item is FlameThrower && Vector3.Distance(((Component)this).transform.position, ((Component)item).transform.position) < flameSettingDistance)
					{
						SetOnFire();
					}
					firePosition = ((Component)item).transform.position;
				}
			}
			return ((List<BaseEntity>)(object)val).Count > 0;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public Vector3 GetTargetEyesPosition()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		Vector3 zero = Vector3.zero;
		if ((Object)(object)targetPlayer.eyes == (Object)null)
		{
			return ((Component)targetPlayer).transform.position + new Vector3(0f, 1f, 0f);
		}
		return targetPlayer.eyes.position;
	}

	private void ValidateTarget()
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)targetPlayer == (Object)null || targetPlayer.InSafeZone() || targetPlayer.IsDead())
		{
			targetPlayer = null;
			SetFlag(Flags.Reserved14, b: false);
			return;
		}
		if (targetPlayer.metabolism.wetness.value > waterThreshold || TimeSince.op_Implicit(targetPlayer.TimeSinceLastWaterSplash) < 1f || targetPlayer.WaterFactor() > 0.5f)
		{
			targetPlayer = null;
			SetFlag(Flags.Reserved14, b: false);
			return;
		}
		if (Vector3.Distance(((Component)this).transform.position, ((Component)targetPlayer).transform.position) > breakRange)
		{
			targetPlayer = null;
			SetFlag(Flags.Reserved14, b: false);
			return;
		}
		Vector3 p = ((Component)targetPlayer).transform.position + new Vector3(0f, 1f, 0f);
		if (!GamePhysics.LineOfSight(((Component)this).transform.position, p, 1218519041))
		{
			targetPlayer = null;
			SetFlag(Flags.Reserved14, b: false);
		}
	}

	private void SetOnFire()
	{
		SetFlag(Flags.Reserved14, b: false);
		SetFlag(Flags.OnFire, b: true);
		((FacepunchBehaviour)this).Invoke((Action)StartDie, 1f);
	}

	private void SteerToPlayer()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 targetEyesPosition = GetTargetEyesPosition();
		Vector3 localTarget = ((Component)this).transform.InverseTransformPoint(targetEyesPosition);
		if (IsFire(out var firePosition))
		{
			float num = 5f;
			Vector3 val = ((Component)this).transform.position - firePosition;
			if (((Vector3)(ref val)).magnitude < num)
			{
				((Vector3)(ref val)).Normalize();
				Transform transform = ((Component)this).transform;
				transform.position += val * moveSpeed * Time.deltaTime;
				return;
			}
		}
		if (!(Mathf.Abs(((Vector3)(ref localTarget)).magnitude) <= stopThreshold))
		{
			SteerToTarget(localTarget);
		}
	}

	private void SteerToTarget(Vector3 localTarget)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Clamp(localTarget.y, -1f, 1f);
		float num2 = Mathf.Clamp(localTarget.x, -1f, 1f);
		Vector3 val = ((Component)this).transform.forward + ((Component)this).transform.right * num2 + ((Component)this).transform.up * num;
		((Vector3)(ref val)).Normalize();
		Transform transform = ((Component)this).transform;
		transform.position += val * moveSpeed * Time.deltaTime;
	}

	private void StartDie()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		SetFlag(Flags.Reserved12, b: false);
		SetFlag(Flags.Reserved13, b: true);
		timeSinceEgress = TimeSince.op_Implicit(0f);
		int num = ((Random.Range(0, 2) != 0) ? 1 : (-1));
		int num2 = ((Random.Range(0, 2) != 0) ? 1 : (-1));
		egressDirection = Vector3.right * (float)num + Vector3.forward * (float)num2;
		((FacepunchBehaviour)this).InvokeRepeating((Action)Egress, 0f, 0f);
	}

	public static BasePlayer FindTarget(Transform transform)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BeeSwarmAI.FindTarget", 0);
		try
		{
			PooledList<BasePlayer> val2 = Pool.Get<PooledList<BasePlayer>>();
			try
			{
				Query.Server.GetPlayersInSphere(transform.position, searchRange, (List<BasePlayer>)(object)val2, Query.DistanceCheckType.None, includeHumanoidNpcs: true);
				BasePlayer result = null;
				float num = float.MaxValue;
				foreach (BasePlayer item in (List<BasePlayer>)(object)val2)
				{
					if (SimpleAIMemory.PlayerIgnoreList.Contains(item) || item.InSafeZone() || item.IsInTutorial || item.IsDead() || item.metabolism.wetness.value > waterThreshold)
					{
						continue;
					}
					Vector3 p = ((Component)item).transform.position + new Vector3(0f, 1f, 0f);
					if (GamePhysics.LineOfSight(transform.position, p, 1218519041))
					{
						Vector3 val3 = ((Component)item).transform.position - transform.position;
						float sqrMagnitude = ((Vector3)(ref val3)).sqrMagnitude;
						if (sqrMagnitude < num)
						{
							num = sqrMagnitude;
							result = item;
						}
					}
				}
				return result;
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool IsUnderWater(BasePlayer ply)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Mathf.Abs(WaterSystem.OceanLevel - GetTargetEyesPosition().y) > 1f;
	}

	private void Egress()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.rotation = Quaternion.LookRotation(egressDirection);
		SteerToTarget(egressDirection);
		if (TimeSince.op_Implicit(timeSinceEgress) > 10f)
		{
			Die();
		}
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		if ((Object)(object)splashType == (Object)null || splashType.shortname == null)
		{
			return false;
		}
		if (HasFlag(Flags.Reserved13))
		{
			return false;
		}
		if (amount > 0)
		{
			return true;
		}
		return false;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		float num = base.health - 10f;
		if (num > 0f)
		{
			Hurt(num);
		}
		if (base.health <= 10f)
		{
			StartDie();
		}
		return amount;
	}
}


using UnityEngine;

public class ch47Animator : MonoBehaviour
{
	public Animator animator;

	public bool bottomDoorOpen;

	public bool landingGearDown;

	public bool leftDoorOpen;

	public bool rightDoorOpen;

	public bool rearDoorOpen;

	public bool rearDoorExtensionOpen;

	public Transform rearRotorBlade;

	public Transform frontRotorBlade;

	public float rotorBladeSpeed;

	public float wheelTurnSpeed;

	public float wheelTurnAngle;

	public SkinnedMeshRenderer[] blurredRotorBlades;

	public SkinnedMeshRenderer[] RotorBlades;

	private bool blurredRotorBladesEnabled;

	public float blurSpeedThreshold = 100f;

	private void Start()
	{
		EnableBlurredRotorBlades(enabled: false);
		animator.SetBool("rotorblade_stop", false);
	}

	public void SetDropDoorOpen(bool isOpen)
	{
		bottomDoorOpen = isOpen;
	}

	private void Update()
	{
		animator.SetBool("bottomdoor", bottomDoorOpen);
		animator.SetBool("landinggear", landingGearDown);
		animator.SetBool("leftdoor", leftDoorOpen);
		animator.SetBool("rightdoor", rightDoorOpen);
		animator.SetBool("reardoor", rearDoorOpen);
		animator.SetBool("reardoor_extension", rearDoorExtensionOpen);
		if (rotorBladeSpeed >= blurSpeedThreshold && !blurredRotorBladesEnabled)
		{
			EnableBlurredRotorBlades(enabled: true);
		}
		else if (rotorBladeSpeed < blurSpeedThreshold && blurredRotorBladesEnabled)
		{
			EnableBlurredRotorBlades(enabled: false);
		}
		if (rotorBladeSpeed <= 0f)
		{
			animator.SetBool("rotorblade_stop", true);
		}
		else
		{
			animator.SetBool("rotorblade_stop", false);
		}
	}

	private void LateUpdate()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.deltaTime * rotorBladeSpeed * 15f;
		Vector3 localEulerAngles = frontRotorBlade.localEulerAngles;
		frontRotorBlade.localEulerAngles = new Vector3(localEulerAngles.x, localEulerAngles.y + num, localEulerAngles.z);
		localEulerAngles = rearRotorBlade.localEulerAngles;
		rearRotorBlade.localEulerAngles = new Vector3(localEulerAngles.x, localEulerAngles.y - num, localEulerAngles.z);
	}

	private void EnableBlurredRotorBlades(bool enabled)
	{
		blurredRotorBladesEnabled = enabled;
		SkinnedMeshRenderer[] array = blurredRotorBlades;
		for (int i = 0; i < array.Length; i++)
		{
			((Renderer)array[i]).enabled = enabled;
		}
		array = RotorBlades;
		for (int i = 0; i < array.Length; i++)
		{
			((Renderer)array[i]).enabled = !enabled;
		}
	}
}


using Development.Attributes;
using UnityEngine;

[ResetStaticFields]
public class CH47FlightTest : MonoBehaviour
{
	public struct HelicopterInputState_t
	{
		public float throttle;

		public float roll;

		public float yaw;

		public float pitch;
	}

	public Rigidbody rigidBody;

	public float engineThrustMax;

	public Vector3 torqueScale;

	public Transform com;

	public Transform[] GroundPoints;

	public Transform[] GroundEffects;

	public float currentThrottle;

	public float avgThrust;

	public float liftDotMax = 0.75f;

	public Transform AIMoveTarget;

	private static float altitudeTolerance = 1f;

	public void Awake()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		rigidBody.centerOfMass = com.localPosition;
	}

	public HelicopterInputState_t GetHelicopterInputState()
	{
		HelicopterInputState_t result = default(HelicopterInputState_t);
		result.throttle = (Input.GetKey((KeyCode)119) ? 1f : 0f);
		result.throttle -= (Input.GetKey((KeyCode)115) ? 1f : 0f);
		result.pitch = Input.GetAxis("Mouse Y");
		result.roll = 0f - Input.GetAxis("Mouse X");
		result.yaw = (Input.GetKey((KeyCode)100) ? 1f : 0f);
		result.yaw -= (Input.GetKey((KeyCode)97) ? 1f : 0f);
		result.pitch = Mathf.RoundToInt(result.pitch);
		result.roll = Mathf.RoundToInt(result.roll);
		return result;
	}

	public HelicopterInputState_t GetAIInputState()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		HelicopterInputState_t result = default(HelicopterInputState_t);
		Vector3 val = Vector3.Cross(Vector3.up, ((Component)this).transform.right);
		float num = Vector3.Dot(Vector3.Cross(Vector3.up, val), Vector3Ex.Direction2D(AIMoveTarget.position, ((Component)this).transform.position));
		result.yaw = ((num < 0f) ? 1f : 0f);
		result.yaw -= ((num > 0f) ? 1f : 0f);
		float num2 = Vector3.Dot(Vector3.up, ((Component)this).transform.right);
		result.roll = ((num2 < 0f) ? 1f : 0f);
		result.roll -= ((num2 > 0f) ? 1f : 0f);
		float num3 = Vector3Ex.Distance2D(((Component)this).transform.position, AIMoveTarget.position);
		float num4 = Vector3.Dot(val, Vector3Ex.Direction2D(AIMoveTarget.position, ((Component)this).transform.position));
		float num5 = Vector3.Dot(Vector3.up, ((Component)this).transform.forward);
		if (num3 > 10f)
		{
			result.pitch = ((num4 > 0.8f) ? (-0.25f) : 0f);
			result.pitch -= ((num4 < -0.8f) ? (-0.25f) : 0f);
			if (num5 < -0.35f)
			{
				result.pitch = -1f;
			}
			else if (num5 > 0.35f)
			{
				result.pitch = 1f;
			}
		}
		else if (num5 < -0f)
		{
			result.pitch = -1f;
		}
		else if (num5 > 0f)
		{
			result.pitch = 1f;
		}
		float idealAltitude = GetIdealAltitude();
		float y = ((Component)this).transform.position.y;
		float num6 = 0f;
		num6 = ((y > idealAltitude + altitudeTolerance) ? (-1f) : ((y < idealAltitude - altitudeTolerance) ? 1f : ((!(num3 > 20f)) ? 0f : Mathf.Lerp(0f, 1f, num3 / 20f))));
		Debug.Log((object)("desiredThrottle : " + num6));
		result.throttle = num6 * 1f;
		return result;
	}

	public float GetIdealAltitude()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)AIMoveTarget).transform.position.y;
	}

	public void FixedUpdate()
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		HelicopterInputState_t aIInputState = GetAIInputState();
		currentThrottle = Mathf.Lerp(currentThrottle, aIInputState.throttle, 2f * Time.fixedDeltaTime);
		currentThrottle = Mathf.Clamp(currentThrottle, -0.2f, 1f);
		rigidBody.AddRelativeTorque(new Vector3(aIInputState.pitch * torqueScale.x, aIInputState.yaw * torqueScale.y, aIInputState.roll * torqueScale.z) * Time.fixedDeltaTime, (ForceMode)0);
		avgThrust = Mathf.Lerp(avgThrust, engineThrustMax * currentThrottle, Time.fixedDeltaTime);
		float num = Mathf.Clamp01(Vector3.Dot(((Component)this).transform.up, Vector3.up));
		float num2 = Mathf.InverseLerp(liftDotMax, 1f, num);
		Vector3 val = Vector3.up * engineThrustMax * 0.5f * currentThrottle * num2;
		Vector3 val2 = ((Component)this).transform.up - Vector3.up;
		Vector3 val3 = ((Vector3)(ref val2)).normalized * engineThrustMax * currentThrottle * (1f - num2);
		float num3 = rigidBody.mass * (0f - Physics.gravity.y);
		rigidBody.AddForce(((Component)this).transform.up * num3 * num2 * 0.99f, (ForceMode)0);
		rigidBody.AddForce(val, (ForceMode)0);
		rigidBody.AddForce(val3, (ForceMode)0);
		RaycastHit val5 = default(RaycastHit);
		for (int i = 0; i < GroundEffects.Length; i++)
		{
			Transform obj = GroundPoints[i];
			Transform val4 = GroundEffects[i];
			if (Physics.Raycast(((Component)obj).transform.position, Vector3.down, ref val5, 50f, 8388608))
			{
				((Component)val4).gameObject.SetActive(true);
				((Component)val4).transform.position = ((RaycastHit)(ref val5)).point + new Vector3(0f, 1f, 0f);
			}
			else
			{
				((Component)val4).gameObject.SetActive(false);
			}
		}
	}

	public void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.yellow;
		Gizmos.DrawSphere(((Component)AIMoveTarget).transform.position, 1f);
		Vector3 val = Vector3.Cross(((Component)this).transform.right, Vector3.up);
		Vector3 val2 = Vector3.Cross(val, Vector3.up);
		Gizmos.color = Color.blue;
		Gizmos.DrawLine(((Component)this).transform.position, ((Component)this).transform.position + val * 10f);
		Gizmos.color = Color.red;
		Gizmos.DrawLine(((Component)this).transform.position, ((Component)this).transform.position + val2 * 10f);
	}
}


public struct HelicopterInputState_t
{
	public float throttle;

	public float roll;

	public float yaw;

	public float pitch;
}


using UnityEngine;

public class rottest : MonoBehaviour
{
	public Transform turretBase;

	public Vector3 aimDir;

	private void Start()
	{
	}

	private void Update()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		aimDir = new Vector3(0f, 45f * Mathf.Sin(Time.time * 6f), 0f);
		UpdateAiming();
	}

	public void UpdateAiming()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		if (!(aimDir == Vector3.zero))
		{
			Quaternion val = Quaternion.Euler(0f, aimDir.y, 0f);
			if (((Component)this).transform.localRotation != val)
			{
				((Component)this).transform.localRotation = Quaternion.Lerp(((Component)this).transform.localRotation, val, Time.deltaTime * 8f);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class BasePath : MonoBehaviour, IAIPath
{
	public List<BasePathNode> nodes;

	public List<PathInterestNode> interestZones;

	public List<PathSpeedZone> speedZones;

	private float? cachedLength;

	public IEnumerable<IAIPathInterestNode> InterestNodes => interestZones;

	public IEnumerable<IAIPathSpeedZone> SpeedZones => speedZones;

	private void AddChildren()
	{
		if (nodes != null)
		{
			nodes.Clear();
			nodes.AddRange(((Component)this).GetComponentsInChildren<BasePathNode>());
			foreach (BasePathNode node in nodes)
			{
				node.Path = this;
			}
		}
		if (interestZones != null)
		{
			interestZones.Clear();
			interestZones.AddRange(((Component)this).GetComponentsInChildren<PathInterestNode>());
		}
		if (speedZones != null)
		{
			speedZones.Clear();
			speedZones.AddRange(((Component)this).GetComponentsInChildren<PathSpeedZone>());
		}
	}

	private void ClearChildren()
	{
		if (nodes != null)
		{
			foreach (BasePathNode node in nodes)
			{
				node.linked.Clear();
			}
		}
		nodes.Clear();
	}

	public static void AutoGenerateLinks(BasePath path, float maxRange = -1f)
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		path.AddChildren();
		foreach (BasePathNode node in path.nodes)
		{
			if (node.linked == null)
			{
				node.linked = new List<BasePathNode>();
			}
			else
			{
				node.linked.Clear();
			}
			foreach (BasePathNode node2 in path.nodes)
			{
				if (!((Object)(object)node == (Object)(object)node2) && (maxRange == -1f || !(Vector3.Distance(node.Position, node2.Position) > maxRange)) && GamePhysics.LineOfSight(node.Position, node2.Position, 1503731969) && GamePhysics.LineOfSight(node2.Position, node.Position, 1503731969))
				{
					node.linked.Add(node2);
				}
			}
		}
	}

	public void GetNodesNear(Vector3 point, ref List<IAIPathNode> nearNodes, float dist = 10f)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		foreach (BasePathNode node in nodes)
		{
			Vector3 val = Vector3Ex.XZ(point) - Vector3Ex.XZ(node.Position);
			if (((Vector3)(ref val)).sqrMagnitude <= dist * dist)
			{
				nearNodes.Add(node);
			}
		}
	}

	public IAIPathNode GetClosestToPoint(Vector3 point)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		IAIPathNode result = nodes[0];
		float num = float.PositiveInfinity;
		foreach (BasePathNode node in nodes)
		{
			if (!((Object)(object)node == (Object)null) && !((Object)(object)((Component)node).transform == (Object)null))
			{
				Vector3 val = point - node.Position;
				float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
				if (sqrMagnitude < num)
				{
					num = sqrMagnitude;
					result = node;
				}
			}
		}
		return result;
	}

	public IAIPathInterestNode GetRandomInterestNodeAwayFrom(Vector3 from, float dist = 10f)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		PathInterestNode pathInterestNode = null;
		int num = 0;
		while ((Object)(object)pathInterestNode == (Object)null && num < 20)
		{
			pathInterestNode = interestZones[Random.Range(0, interestZones.Count)];
			Vector3 val = ((Component)pathInterestNode).transform.position - from;
			if (!(((Vector3)(ref val)).sqrMagnitude < dist * dist))
			{
				break;
			}
			pathInterestNode = null;
			num++;
		}
		if ((Object)(object)pathInterestNode == (Object)null)
		{
			Debug.LogError((object)"REturning default interest zone");
			pathInterestNode = interestZones[0];
		}
		return pathInterestNode;
	}

	public void AddInterestNode(IAIPathInterestNode interestZone)
	{
		throw new NotImplementedException();
	}

	public void AddSpeedZone(IAIPathSpeedZone speedZone)
	{
		throw new NotImplementedException();
	}

	public float GetPathLength()
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (cachedLength.HasValue)
		{
			return cachedLength.Value;
		}
		if (nodes.Count < 2)
		{
			return 0f;
		}
		cachedLength = 0f;
		for (int i = 0; i < nodes.Count - 1; i++)
		{
			cachedLength += Vector3.Distance(nodes[i].Position, nodes[i + 1].Position);
		}
		return cachedLength.Value;
	}

	public float GetPathProgress(Vector3 position)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		for (int i = 0; i < nodes.Count - 1; i++)
		{
			Vector3 position2 = nodes[i].Position;
			Vector3 position3 = nodes[i + 1].Position;
			Vector3 val = position2 - position3;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			val = position2 - position;
			Vector3 normalized2 = ((Vector3)(ref val)).normalized;
			val = position3 - position;
			Vector3 normalized3 = ((Vector3)(ref val)).normalized;
			float num2 = Vector3.Distance(position2, position3);
			float num3 = Vector3.Dot(normalized, normalized2);
			float num4 = Vector3.Dot(-normalized, normalized3);
			if (i == 0 && num3 < 0f)
			{
				return 0f;
			}
			if (num3 > -0.1f && num4 > -0.1f)
			{
				float num5 = Vector3.Distance(position2, position);
				return num + num5;
			}
			num += num2;
		}
		return GetPathLength();
	}

	public void GetPointInPath(float normalisedTime, out Vector3 pos, out Vector3 rotation)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		normalisedTime = Mathf.Clamp01(normalisedTime);
		pos = Vector3.zero;
		rotation = Vector3.zero;
		if (normalisedTime >= 1f)
		{
			List<BasePathNode> list = nodes;
			pos = list[list.Count - 1].Position;
			return;
		}
		float num = GetPathLength() * normalisedTime;
		float num2 = 0f;
		for (int i = 0; i < nodes.Count - 1; i++)
		{
			float num3 = Vector3.Distance(nodes[i].Position, nodes[i + 1].Position);
			if (num2 + num3 > num)
			{
				float num4 = (num - num2) / num3;
				pos = Vector3.Lerp(nodes[i].Position, nodes[i + 1].Position, num4);
				Vector3 val = nodes[i + 1].Position - nodes[i].Position;
				rotation = ((Vector3)(ref val)).normalized;
				break;
			}
			num2 += num3;
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class BasePathNode : MonoBehaviour, IAIPathNode
{
	public BasePath Path;

	public List<BasePathNode> linked;

	public float maxVelocityOnApproach = -1f;

	public bool straightaway;

	public Vector3 Position => ((Component)this).transform.position;

	public bool Straightaway => straightaway;

	public IEnumerable<IAIPathNode> Linked => linked;

	public bool IsValid()
	{
		return (Object)(object)((Component)this).transform != (Object)null;
	}

	public void AddLink(IAIPathNode link)
	{
		throw new NotImplementedException();
	}

	public void OnDrawGizmosSelected()
	{
	}
}


using UnityEngine;

public class BradleyMoveTest : MonoBehaviour
{
	public WheelCollider[] leftWheels;

	public WheelCollider[] rightWheels;

	public float moveForceMax = 2000f;

	public float brakeForce = 100f;

	public float throttle = 1f;

	public float turnForce = 2000f;

	public float sideStiffnessMax = 1f;

	public float sideStiffnessMin = 0.5f;

	public Transform centerOfMass;

	public float turning;

	public bool brake;

	public Rigidbody myRigidBody;

	public Vector3 destination;

	public float stoppingDist = 5f;

	public GameObject followTest;

	public void Awake()
	{
		Initialize();
	}

	public void Initialize()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		myRigidBody.centerOfMass = centerOfMass.localPosition;
		destination = ((Component)this).transform.position;
	}

	public void SetDestination(Vector3 dest)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		destination = dest;
	}

	public void FixedUpdate()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		Vector3 velocity = myRigidBody.velocity;
		SetDestination(followTest.transform.position);
		float num = Vector3.Distance(((Component)this).transform.position, destination);
		if (num > stoppingDist)
		{
			Vector3 zero = Vector3.zero;
			float num2 = Vector3.Dot(zero, ((Component)this).transform.right);
			float num3 = Vector3.Dot(zero, -((Component)this).transform.right);
			float num4 = Vector3.Dot(zero, ((Component)this).transform.right);
			if (Vector3.Dot(zero, -((Component)this).transform.forward) > num4)
			{
				if (num2 >= num3)
				{
					turning = 1f;
				}
				else
				{
					turning = -1f;
				}
			}
			else
			{
				turning = num4;
			}
			throttle = Mathf.InverseLerp(stoppingDist, 30f, num);
		}
		throttle = Mathf.Clamp(throttle, -1f, 1f);
		float num5 = throttle;
		float num6 = throttle;
		if (turning > 0f)
		{
			num6 = 0f - turning;
			num5 = turning;
		}
		else if (turning < 0f)
		{
			num5 = turning;
			num6 = turning * -1f;
		}
		ApplyBrakes(brake ? 1f : 0f);
		float num7 = throttle;
		num5 = Mathf.Clamp(num5 + num7, -1f, 1f);
		num6 = Mathf.Clamp(num6 + num7, -1f, 1f);
		AdjustFriction();
		float num8 = Mathf.InverseLerp(3f, 1f, ((Vector3)(ref velocity)).magnitude * Mathf.Abs(Vector3.Dot(((Vector3)(ref velocity)).normalized, ((Component)this).transform.forward)));
		float torqueAmount = Mathf.Lerp(moveForceMax, turnForce, num8);
		SetMotorTorque(num5, rightSide: false, torqueAmount);
		SetMotorTorque(num6, rightSide: true, torqueAmount);
	}

	public void ApplyBrakes(float amount)
	{
		ApplyBrakeTorque(amount, rightSide: true);
		ApplyBrakeTorque(amount, rightSide: false);
	}

	public float GetMotorTorque(bool rightSide)
	{
		float num = 0f;
		WheelCollider[] array = (rightSide ? rightWheels : leftWheels);
		foreach (WheelCollider val in array)
		{
			num += val.motorTorque;
		}
		return num / (float)rightWheels.Length;
	}

	public void SetMotorTorque(float newThrottle, bool rightSide, float torqueAmount)
	{
		newThrottle = Mathf.Clamp(newThrottle, -1f, 1f);
		float motorTorque = torqueAmount * newThrottle;
		WheelCollider[] array = (rightSide ? rightWheels : leftWheels);
		for (int i = 0; i < array.Length; i++)
		{
			array[i].motorTorque = motorTorque;
		}
	}

	public void ApplyBrakeTorque(float amount, bool rightSide)
	{
		WheelCollider[] array = (rightSide ? rightWheels : leftWheels);
		for (int i = 0; i < array.Length; i++)
		{
			array[i].brakeTorque = brakeForce * amount;
		}
	}

	public void AdjustFriction()
	{
	}
}


using System;
using ConVar;
using Rust;
using UnityEngine;

public class BradleySpawner : MonoBehaviour, IServerComponent
{
	public BasePath path;

	public GameObjectRef bradleyPrefab;

	[NonSerialized]
	public BradleyAPC spawned;

	public bool initialSpawn;

	public float minRespawnTimeMinutes = 5f;

	public float maxRespawnTimeMinutes = 5f;

	public static BradleySpawner singleton;

	private bool pendingRespawn;

	public void Start()
	{
		singleton = this;
		((MonoBehaviour)this).Invoke("DelayedStart", 3f);
	}

	public void DelayedStart()
	{
		if (initialSpawn)
		{
			DoRespawn();
		}
		((MonoBehaviour)this).InvokeRepeating("CheckIfRespawnNeeded", 0f, 5f);
	}

	public void CheckIfRespawnNeeded()
	{
		if (!pendingRespawn && ((Object)(object)spawned == (Object)null || !spawned.IsAlive()))
		{
			ScheduleRespawn();
		}
	}

	public void ScheduleRespawn()
	{
		((MonoBehaviour)this).CancelInvoke("DoRespawn");
		((MonoBehaviour)this).Invoke("DoRespawn", Random.Range(Bradley.respawnDelayMinutes - Bradley.respawnDelayVariance, Bradley.respawnDelayMinutes + Bradley.respawnDelayVariance) * 60f);
		pendingRespawn = true;
	}

	public void DoRespawn()
	{
		if (!Application.isLoading && !Application.isLoadingSave)
		{
			SpawnBradley();
		}
		pendingRespawn = false;
	}

	public void SpawnBradley()
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)spawned != (Object)null)
		{
			Debug.LogWarning((object)"Bradley attempting to spawn but one already exists!");
		}
		else if (Bradley.enabled)
		{
			Vector3 position = ((Component)path.interestZones[Random.Range(0, path.interestZones.Count)]).transform.position;
			BaseEntity baseEntity = GameManager.server.CreateEntity(bradleyPrefab.resourcePath, position);
			BradleyAPC component = ((Component)baseEntity).GetComponent<BradleyAPC>();
			component.RoadSpawned = false;
			if (Object.op_Implicit((Object)(object)component))
			{
				baseEntity.Spawn();
				component.InstallPatrolPath(path);
			}
			else
			{
				baseEntity.Kill();
			}
			Vector3 val = position;
			Debug.Log((object)("BradleyAPC Spawned at :" + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString()));
			spawned = component;
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public interface IAIPath
{
	IEnumerable<IAIPathSpeedZone> SpeedZones { get; }

	IEnumerable<IAIPathInterestNode> InterestNodes { get; }

	void GetNodesNear(Vector3 point, ref List<IAIPathNode> nearNodes, float dist = 10f);

	IAIPathInterestNode GetRandomInterestNodeAwayFrom(Vector3 from, float dist = 10f);

	IAIPathNode GetClosestToPoint(Vector3 point);

	void AddInterestNode(IAIPathInterestNode interestNode);

	void AddSpeedZone(IAIPathSpeedZone speedZone);
}


using System.Collections.Generic;
using UnityEngine;

public interface IAIPathNode
{
	Vector3 Position { get; }

	bool Straightaway { get; }

	IEnumerable<IAIPathNode> Linked { get; }

	bool IsValid();

	void AddLink(IAIPathNode link);
}


public interface IAIPathSpeedZone
{
	OBB WorldSpaceBounds();

	float GetMaxSpeed();
}


using UnityEngine;

public interface IAIPathInterestNode
{
	Vector3 Position { get; }

	float NextVisitTime { get; set; }
}


using UnityEngine;

public class PathInterestNode : MonoBehaviour, IAIPathInterestNode
{
	public Vector3 Position => ((Component)this).transform.position;

	public float NextVisitTime { get; set; }

	public void OnDrawGizmos()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = new Color(0f, 1f, 1f, 0.5f);
		Gizmos.DrawSphere(((Component)this).transform.position, 0.5f);
	}
}


using UnityEngine;

public class PathSpeedZone : MonoBehaviour, IAIPathSpeedZone
{
	public Bounds bounds;

	public OBB obbBounds;

	public float maxVelocityPerSec = 5f;

	public OBB WorldSpaceBounds()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		return new OBB(((Component)this).transform.position, ((Component)this).transform.lossyScale, ((Component)this).transform.rotation, bounds);
	}

	public float GetMaxSpeed()
	{
		return maxVelocityPerSec;
	}
}


using UnityEngine;

public class RuntimeInterestNode : IAIPathInterestNode
{
	public Vector3 Position { get; set; }

	public float NextVisitTime { get; set; }

	public RuntimeInterestNode(Vector3 position)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		Position = position;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class RuntimePath : IAIPath
{
	private List<IAIPathSpeedZone> speedZones = new List<IAIPathSpeedZone>();

	private List<IAIPathInterestNode> interestNodes = new List<IAIPathInterestNode>();

	public IAIPathNode[] Nodes { get; set; } = new IAIPathNode[0];

	public IEnumerable<IAIPathSpeedZone> SpeedZones => speedZones;

	public IEnumerable<IAIPathInterestNode> InterestNodes => interestNodes;

	public IAIPathNode GetClosestToPoint(Vector3 point)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		IAIPathNode result = Nodes[0];
		float num = float.PositiveInfinity;
		IAIPathNode[] nodes = Nodes;
		foreach (IAIPathNode iAIPathNode in nodes)
		{
			Vector3 val = point - iAIPathNode.Position;
			float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
			if (sqrMagnitude < num)
			{
				num = sqrMagnitude;
				result = iAIPathNode;
			}
		}
		return result;
	}

	public void GetNodesNear(Vector3 point, ref List<IAIPathNode> nearNodes, float dist = 10f)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		IAIPathNode[] nodes = Nodes;
		foreach (IAIPathNode iAIPathNode in nodes)
		{
			Vector3 val = Vector3Ex.XZ(point) - Vector3Ex.XZ(iAIPathNode.Position);
			if (((Vector3)(ref val)).sqrMagnitude <= dist * dist)
			{
				nearNodes.Add(iAIPathNode);
			}
		}
	}

	public IAIPathInterestNode GetRandomInterestNodeAwayFrom(Vector3 from, float dist = 10f)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		IAIPathInterestNode iAIPathInterestNode = null;
		int num = 0;
		while (iAIPathInterestNode == null && num < 20)
		{
			iAIPathInterestNode = interestNodes[Random.Range(0, interestNodes.Count)];
			Vector3 val = iAIPathInterestNode.Position - from;
			if (!(((Vector3)(ref val)).sqrMagnitude < dist * dist))
			{
				break;
			}
			iAIPathInterestNode = null;
			num++;
		}
		if (iAIPathInterestNode == null)
		{
			Debug.LogError((object)"Returning default interest zone");
			iAIPathInterestNode = interestNodes[0];
		}
		return iAIPathInterestNode;
	}

	public void AddInterestNode(IAIPathInterestNode interestNode)
	{
		if (!interestNodes.Contains(interestNode))
		{
			interestNodes.Add(interestNode);
		}
	}

	public void AddSpeedZone(IAIPathSpeedZone speedZone)
	{
		if (!speedZones.Contains(speedZone))
		{
			speedZones.Add(speedZone);
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class RuntimePathNode : IAIPathNode
{
	private HashSet<IAIPathNode> linked = new HashSet<IAIPathNode>();

	public Vector3 Position { get; set; }

	public bool Straightaway { get; set; }

	public IEnumerable<IAIPathNode> Linked => linked;

	public RuntimePathNode(Vector3 position)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		Position = position;
	}

	public bool IsValid()
	{
		return true;
	}

	public void AddLink(IAIPathNode link)
	{
		linked.Add(link);
	}
}


public class RuntimeSpeedZone : IAIPathSpeedZone
{
	public OBB worldOBBBounds;

	public float maxVelocityPerSec = 5f;

	public float GetMaxSpeed()
	{
		return maxVelocityPerSec;
	}

	public OBB WorldSpaceBounds()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return worldOBBBounds;
	}
}


using System;
using UnityEngine;

public class TreadAnimator : MonoBehaviour, IClientComponent
{
	[Serializable]
	public struct TreadRenderer
	{
		public Renderer Renderer;

		public int leftMaterialIndex;

		public int rightMaterialIndex;
	}

	public Animator mainBodyAnimator;

	public Transform[] wheelBones;

	public Vector3[] vecShocksOffsetPosition;

	public Vector3[] wheelBoneOrigin;

	public float wheelBoneDistMax = 0.26f;

	public TreadRenderer[] treadRenderers;

	public TreadEffects treadEffects;

	public float traceThickness = 0.25f;

	public float heightFudge = 0.13f;

	public bool useWheelYOrigin;

	public Vector2 treadTextureDirection = new Vector2(1f, 0f);

	public bool isMetallic;

	public float angularTreadConstant = 0.05f;

	public float treadConstant = 0.14f;

	public float wheelSpinConstant = 80f;

	public float traceLineMin = 0.55f;

	public float traceLineMax = 0.79f;

	public float maxShockDist = 0.26f;
}


using System;
using UnityEngine;

[Serializable]
public struct TreadRenderer
{
	public Renderer Renderer;

	public int leftMaterialIndex;

	public int rightMaterialIndex;
}


using UnityEngine;

public class TreadEffects : MonoBehaviour
{
	public ParticleSystem[] rearTreadDirt;

	public ParticleSystem[] rearTreadSmoke;

	public ParticleSystem[] middleTreadSmoke;
}


using System;

public class NPCPlayerCorpse : PlayerCorpse
{
	private bool lootEnabled;

	public override float GetRemovalTime()
	{
		return 600f;
	}

	public override bool CanLoot()
	{
		return lootEnabled;
	}

	public void SetLootableIn(float when)
	{
		((FacepunchBehaviour)this).Invoke((Action)EnableLooting, when);
	}

	public void EnableLooting()
	{
		lootEnabled = true;
	}

	protected override bool CanLootContainer(ItemContainer c, int index)
	{
		if (index == 1 || index == 2)
		{
			return false;
		}
		return base.CanLootContainer(c, index);
	}

	protected override void PreDropItems()
	{
		base.PreDropItems();
		if (containers != null && containers.Length >= 2)
		{
			containers[1].Clear();
			ItemManager.DoRemoves();
		}
	}
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class TutorialNPC : NPCMissionProvider
{
	public ConversationData StartConversation;

	public ConversationData MissionInProgressConversation;

	public ConversationData ForageCompleteConversation;

	public ConversationData FirstBuildCompleteConversation;

	public ConversationData SecondBuildCompleteConversation;

	public ConversationData PrepareForCombatConversation;

	public ConversationData BuildKayakConversation;

	public ConversationData SetSailConversation;

	public ConversationData PostBearAttackConversation;

	public BaseMission PostBearAttackMission;

	public GameObjectRef BearRoarSfx;

	public Transform BearRoarSpawnPos;

	[Range(0f, 1f)]
	public float TalkingHeadIkWeight = 0.7f;

	public RuntimeAnimatorController CustomAnimator;

	private static readonly int IsTalking = Animator.StringToHash("IsTalking");

	private const uint FORAGE_MISSION = 2265941643u;

	private const uint BUILD1_MISSION = 1726435040u;

	private const uint BUILD2_MISSION = 1928576498u;

	private const uint COOK_MISSION = 3432877204u;

	private const uint KILL_BEAR_MISSION = 3396482113u;

	private const uint CRAFT_KAYAK_MISSION = 3197637569u;

	public const uint BEAR_ATTACK_RESPAWN_MISSION = 3156134108u;

	private BasePlayer playerToKill;

	protected override bool CanTalkTo(BasePlayer bp)
	{
		if (base.CanTalkTo(bp))
		{
			return !bp.HasPendingFollowupMission;
		}
		return false;
	}

	public override ConversationData GetConversationFor(BasePlayer player)
	{
		if (player.HasActiveMission())
		{
			return MissionInProgressConversation;
		}
		if (player.HasCompletedMission(3197637569u))
		{
			return SetSailConversation;
		}
		if (player.HasCompletedMission(3396482113u))
		{
			return BuildKayakConversation;
		}
		if (player.HasCompletedMission(3156134108u))
		{
			return PostBearAttackConversation;
		}
		if (player.HasCompletedMission(3432877204u))
		{
			return PrepareForCombatConversation;
		}
		if (player.HasCompletedMission(1928576498u))
		{
			return SecondBuildCompleteConversation;
		}
		if (player.HasCompletedMission(1726435040u))
		{
			return FirstBuildCompleteConversation;
		}
		if (player.HasCompletedMission(2265941643u))
		{
			return ForageCompleteConversation;
		}
		return StartConversation;
	}

	public override void OnConversationAction(BasePlayer player, string action)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		base.OnConversationAction(player, action);
		if (action == "playbearsfx")
		{
			Effect.server.Run(BearRoarSfx.resourcePath, BearRoarSpawnPos.position);
			playerToKill = player;
			((FacepunchBehaviour)this).Invoke((Action)WaitAndKill, 2f);
		}
		else if (action == "cleardeathmarker")
		{
			player.ClearDeathMarker(sendToClient: true);
		}
	}

	private void WaitAndKill()
	{
		if ((Object)(object)playerToKill != (Object)null)
		{
			DeathInfo val = Pool.Get<DeathInfo>();
			val.attackerName = "bear";
			if (playerToKill.IsGod())
			{
				playerToKill.net.connection.info.Set("global.god", "0");
			}
			playerToKill.SetOverrideDeathBlow(val);
			playerToKill.Hurt(9999f);
			if (PostBearAttackMission != null)
			{
				BaseMission.AssignMission(playerToKill, this, PostBearAttackMission);
			}
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		EndSleeping();
	}

	public override void GreetPlayer(BasePlayer player)
	{
	}

	public override void Greeting()
	{
	}

	public override void OnConversationStarted(BasePlayer speakingTo)
	{
		base.OnConversationStarted(speakingTo);
		SetFlag(Flags.Busy, b: true);
	}

	public override void OnConversationEnded(BasePlayer player)
	{
		base.OnConversationEnded(player);
		SetFlag(Flags.Busy, b: false);
	}
}


using UnityEngine;

public class NaturalBeehive : LootContainer
{
	public GameObjectRef beeSwarmPrefab;

	public override void OnDied(HitInfo info)
	{
		SpawnSwarm();
		base.OnDied(info);
	}

	private void SpawnSwarm()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity(beeSwarmPrefab.resourcePath, ((Component)this).transform.position, Quaternion.identity);
		BeeSwarmAI beeSwarmAI = baseEntity as BeeSwarmAI;
		if (Object.op_Implicit((Object)(object)beeSwarmAI))
		{
			beeSwarmAI.SetHasCameFromAHive(cameFromHive: true);
		}
		baseEntity.Spawn();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk && base.isServer)
		{
			Kill();
		}
	}

	public override float BoundsPadding()
	{
		return 1f;
	}
}


using System.Collections.Generic;
using ProtoBuf;
using UnityEngine;

public class ItemModSetFrequency : ItemMod
{
	private struct ItemTime
	{
		public Item TargetItem;

		public TimeSince TimeSinceEdit;
	}

	public static readonly Phrase RfOffTitle = new Phrase("rf_off", "Disable RF");

	public static readonly Phrase RfOffDesc = new Phrase("rf_off_desc", " Disable detonation via RF");

	public static readonly Phrase RfOnTitle = new Phrase("rf_on", "Enable RF");

	public static readonly Phrase RfOnDesc = new Phrase("rf_on_desc", " Enable detonation via RF");

	public GameObjectRef frequencyPanelPrefab;

	public bool allowArmDisarm;

	public bool onlyFrequency;

	public int defaultFrequency = -1;

	public bool loseConditionOnChange;

	private static List<ItemTime> itemsOnCooldown = new List<ItemTime>();

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		base.ServerCommand(item, command, player);
		if (command.Contains("SetFrequency"))
		{
			if (itemsOnCooldown.Count > 0 && onlyFrequency)
			{
				for (int num = itemsOnCooldown.Count - 1; num >= 0; num--)
				{
					if (itemsOnCooldown[num].TargetItem == item && TimeSince.op_Implicit(itemsOnCooldown[num].TimeSinceEdit) < 2f)
					{
						return;
					}
					if (TimeSince.op_Implicit(itemsOnCooldown[num].TimeSinceEdit) > 2f)
					{
						itemsOnCooldown.RemoveAt(num);
					}
				}
			}
			int result = 0;
			if (int.TryParse(command.Substring(command.IndexOf(":") + 1), out result))
			{
				BaseEntity heldEntity = item.GetHeldEntity();
				if ((Object)(object)heldEntity != (Object)null && heldEntity is Detonator detonator)
				{
					detonator.ServerSetFrequency(player, result);
				}
				else
				{
					item.instanceData.dataInt = result;
					if (loseConditionOnChange)
					{
						item.LoseCondition(item.maxCondition * 0.01f);
					}
					item.MarkDirty();
				}
				if (onlyFrequency)
				{
					itemsOnCooldown.Add(new ItemTime
					{
						TargetItem = item,
						TimeSinceEdit = TimeSince.op_Implicit(0f)
					});
				}
			}
			else
			{
				Debug.Log((object)"Parse fuckup");
			}
		}
		if (!onlyFrequency)
		{
			if (command == "rf_on")
			{
				item.SetFlag(Item.Flag.IsOn, b: true);
				item.MarkDirty();
			}
			else if (command == "rf_off")
			{
				item.instanceData.dataInt = defaultFrequency;
				item.SetFlag(Item.Flag.IsOn, b: false);
				item.MarkDirty();
			}
		}
	}

	public override void OnItemCreated(Item item)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Expected O, but got Unknown
		if (item.instanceData == null)
		{
			item.instanceData = new InstanceData();
			item.instanceData.ShouldPool = false;
			item.instanceData.dataInt = defaultFrequency;
		}
	}
}


private struct ItemTime
{
	public Item TargetItem;

	public TimeSince TimeSinceEdit;
}


public class ItemModCompass : ItemMod
{
}


using System;
using UnityEngine;

public class FishingBobber : BaseCombatEntity
{
	public Transform centerOfMass;

	public Rigidbody myRigidBody;

	public Transform lineAttachPoint;

	public Transform bobberRoot;

	public const Flags CaughtFish = Flags.Reserved1;

	public float HorizontalMoveSpeed = 1f;

	public float PullAwayMoveSpeed = 1f;

	public float SidewaysInputForce = 1f;

	public float ReelInMoveSpeed = 1f;

	private float bobberForcePingPong;

	private Vector3 initialDirection;

	private Vector3 initialTargetPosition;

	private Vector3 spawnPosition;

	private TimeSince initialCastTime;

	private float initialDistance;

	public float TireAmount { get; private set; }

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		myRigidBody.centerOfMass = centerOfMass.localPosition;
		base.ServerInit();
	}

	public void InitialiseBobber(BasePlayer forPlayer, WaterBody forBody, Vector3 targetPos, float maxDuration)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		initialDirection = Vector3Ex.WithY(forPlayer.eyes.HeadForward(), 0f);
		spawnPosition = ((Component)this).transform.position;
		initialTargetPosition = targetPos;
		initialCastTime = TimeSince.op_Implicit(0f);
		initialDistance = Vector3.Distance(targetPos, Vector3Ex.WithY(((Component)forPlayer).transform.position, targetPos.y));
		((FacepunchBehaviour)this).InvokeRepeating((Action)ProcessInitialCast, 0f, 0f);
		((FacepunchBehaviour)this).Invoke((Action)TimeOutBobber, maxDuration);
	}

	private void ProcessInitialCast()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float num = 0.8f;
		if (TimeSince.op_Implicit(initialCastTime) > num)
		{
			((Component)this).transform.position = initialTargetPosition;
			((FacepunchBehaviour)this).CancelInvoke((Action)ProcessInitialCast);
			return;
		}
		float num2 = TimeSince.op_Implicit(initialCastTime) / num;
		Vector3 val = Vector3.Lerp(spawnPosition, initialTargetPosition, 0.5f);
		val.y += 1.5f;
		Vector3 position = Vector3.Lerp(Vector3.Lerp(spawnPosition, val, num2), Vector3.Lerp(val, initialTargetPosition, num2), num2);
		((Component)this).transform.position = position;
	}

	public void ServerMovementUpdate(bool inputLeft, bool inputRight, bool inputBack, ref BaseFishingRod.FishState state, Vector3 playerPos, ItemModFishable fishableModifier, float playerStrengthModifier)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = playerPos - ((Component)this).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = Vector3.zero;
		bobberForcePingPong = Mathf.Clamp(Mathf.PingPong(Time.time, 2f), 0.2f, 2f);
		if (state.Contains(BaseFishingRod.FishState.PullingLeft))
		{
			val2 = ((Component)this).transform.right * (Time.deltaTime * HorizontalMoveSpeed * bobberForcePingPong * fishableModifier.MoveMultiplier * (inputRight ? 0.5f : 1f));
		}
		if (state.Contains(BaseFishingRod.FishState.PullingRight))
		{
			val2 = -((Component)this).transform.right * (Time.deltaTime * HorizontalMoveSpeed * bobberForcePingPong * fishableModifier.MoveMultiplier * (inputLeft ? 0.5f : 1f));
		}
		if (state.Contains(BaseFishingRod.FishState.PullingBack))
		{
			val2 += -((Component)this).transform.forward * (Time.deltaTime * PullAwayMoveSpeed * bobberForcePingPong * fishableModifier.MoveMultiplier * (inputBack ? 0.5f : 1f));
		}
		if (inputLeft || inputRight)
		{
			float num = 0.8f;
			if ((inputLeft && state == BaseFishingRod.FishState.PullingRight) || (inputRight && state == BaseFishingRod.FishState.PullingLeft))
			{
				num = 1.25f;
			}
			TireAmount += Time.deltaTime * num;
		}
		else
		{
			TireAmount -= Time.deltaTime * 0.1f;
		}
		if (inputLeft && !state.Contains(BaseFishingRod.FishState.PullingLeft))
		{
			val2 += ((Component)this).transform.right * (Time.deltaTime * SidewaysInputForce * playerStrengthModifier);
		}
		else if (inputRight && !state.Contains(BaseFishingRod.FishState.PullingRight))
		{
			val2 += -((Component)this).transform.right * (Time.deltaTime * SidewaysInputForce * playerStrengthModifier);
		}
		if (inputBack)
		{
			float num2 = Mathx.RemapValClamped(TireAmount, 0f, 5f, 1f, 3f);
			val2 += normalized * (ReelInMoveSpeed * fishableModifier.ReelInSpeedMultiplier * num2 * Time.deltaTime * playerStrengthModifier);
		}
		((Component)this).transform.LookAt(Vector3Ex.WithY(playerPos, ((Component)this).transform.position.y));
		Vector3 val3 = ((Component)this).transform.position + val2;
		if (!IsDirectionValid(val3, ((Vector3)(ref val2)).magnitude, playerPos))
		{
			state = state.FlipHorizontal();
		}
		else
		{
			((Component)this).transform.position = val3;
		}
	}

	private bool IsDirectionValid(Vector3 pos, float checkLength, Vector3 playerPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - playerPos;
		if (Vector3.Angle(Vector3Ex.WithY(((Vector3)(ref val)).normalized, 0f), initialDirection) > 60f)
		{
			return false;
		}
		Vector3 position = ((Component)this).transform.position;
		val = pos - position;
		if (GamePhysics.Trace(new Ray(position, ((Vector3)(ref val)).normalized), 0.1f, out var _, checkLength, 1084293377, (QueryTriggerInteraction)0))
		{
			return false;
		}
		return true;
	}

	private void TimeOutBobber()
	{
		Kill();
	}
}


using UnityEngine;

public class BobberPreview : MonoBehaviour
{
	public Material ValidMaterial;

	public Material InvalidMaterial;

	public MeshRenderer TargetRenderer;
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Fishing Lookup")]
public class FishLookup : BaseScriptableObject
{
	public ItemModFishable FallbackFish;

	private static FishLookup _instance;

	private static ItemModFishable[] AvailableFish;

	public static ItemDefinition[] BaitItems;

	private static TimeSince lastShuffle;

	public const int ALL_FISH_COUNT = 9;

	public const string ALL_FISH_ACHIEVEMENT_NAME = "PRO_ANGLER";

	public static FishLookup Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = FileSystem.Load<FishLookup>("assets/prefabs/tools/fishing rod/fishlookup.asset", true);
			}
			return _instance;
		}
	}

	public static void LoadFish()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		if (AvailableFish != null)
		{
			if (TimeSince.op_Implicit(lastShuffle) > 5f)
			{
				AvailableFish.Shuffle((uint)Random.Range(0, 10000));
			}
			return;
		}
		List<ItemModFishable> list = Pool.Get<List<ItemModFishable>>();
		List<ItemDefinition> list2 = Pool.Get<List<ItemDefinition>>();
		ItemModFishable item = default(ItemModFishable);
		ItemModCompostable itemModCompostable = default(ItemModCompostable);
		foreach (ItemDefinition item2 in ItemManager.itemList)
		{
			if (((Component)item2).TryGetComponent<ItemModFishable>(ref item))
			{
				list.Add(item);
			}
			if (((Component)item2).TryGetComponent<ItemModCompostable>(ref itemModCompostable) && itemModCompostable.BaitValue > 0f)
			{
				list2.Add(item2);
			}
		}
		AvailableFish = list.ToArray();
		BaitItems = list2.ToArray();
		Pool.FreeUnmanaged<ItemModFishable>(ref list);
		Pool.FreeUnmanaged<ItemDefinition>(ref list2);
	}

	public ItemDefinition GetFish(Vector3 worldPos, WaterBody bodyType, Item lure, out ItemModFishable fishable, ItemModFishable ignoreFish, out int usedLureAmount, float overrideDepth = 0f)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		LoadFish();
		usedLureAmount = 1;
		ItemModCompostable itemModCompostable = default(ItemModCompostable);
		float num = (((Component)lure.info).TryGetComponent<ItemModCompostable>(ref itemModCompostable) ? itemModCompostable.BaitValue : 0f);
		if ((Object)(object)itemModCompostable != (Object)null && itemModCompostable.MaxBaitStack > 0)
		{
			usedLureAmount = Mathf.Min(lure.amount, itemModCompostable.MaxBaitStack);
			num *= (float)usedLureAmount;
		}
		WaterBody.FishingTag fishingTag = (((Object)(object)bodyType != (Object)null) ? bodyType.FishingType : WaterBody.FishingTag.Ocean);
		if (WaterResource.IsFreshWater(worldPos))
		{
			fishingTag |= WaterBody.FishingTag.River;
		}
		float num2 = WaterLevel.GetOverallWaterDepth(worldPos, waves: true, volumes: false);
		if (worldPos.y < -10f)
		{
			num2 = 10f;
		}
		if (overrideDepth != 0f)
		{
			num2 = overrideDepth;
		}
		int num3 = Random.Range(0, AvailableFish.Length);
		for (int i = 0; i < AvailableFish.Length; i++)
		{
			num3++;
			if (num3 >= AvailableFish.Length)
			{
				num3 = 0;
			}
			ItemModFishable itemModFishable = AvailableFish[num3];
			if (itemModFishable.CanBeFished && !(itemModFishable.MinimumBaitLevel > num) && (!(itemModFishable.MaximumBaitLevel > 0f) || !(num > itemModFishable.MaximumBaitLevel)) && !((Object)(object)itemModFishable == (Object)(object)ignoreFish) && (itemModFishable.RequiredTag == (WaterBody.FishingTag)(-1) || (itemModFishable.RequiredTag & fishingTag) != 0) && ((fishingTag & WaterBody.FishingTag.Ocean) != WaterBody.FishingTag.Ocean || ((!(itemModFishable.MinimumWaterDepth > 0f) || !(num2 < itemModFishable.MinimumWaterDepth)) && (!(itemModFishable.MaximumWaterDepth > 0f) || !(num2 > itemModFishable.MaximumWaterDepth)))) && !(Random.Range(0f, 1f) - num * 3f * 0.01f > itemModFishable.Chance))
			{
				fishable = itemModFishable;
				return ((Component)itemModFishable).GetComponent<ItemDefinition>();
			}
		}
		fishable = FallbackFish;
		return ((Component)FallbackFish).GetComponent<ItemDefinition>();
	}

	public void CheckCatchAllAchievement(BasePlayer player)
	{
		LoadFish();
		int num = 0;
		ItemModFishable[] availableFish = AvailableFish;
		foreach (ItemModFishable itemModFishable in availableFish)
		{
			if (!string.IsNullOrEmpty(itemModFishable.SteamStatName) && player.stats.steam.Get(itemModFishable.SteamStatName) > 0)
			{
				num++;
			}
		}
		if (num == 9)
		{
			player.GiveAchievement("PRO_ANGLER");
		}
	}
}


using ProtoBuf;
using UnityEngine;

public class MapMarkerCH47 : MapMarker
{
	public bool IsCargoShip;

	public bool AutomaticallySetRotationToParent = true;

	public bool UseEntityRotation;

	private float GetRotation(BaseEntity forEntity)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)forEntity == (Object)null)
		{
			return 0f;
		}
		Vector3 forward = ((Component)forEntity).transform.forward;
		forward.y = 0f;
		((Vector3)(ref forward)).Normalize();
		return Mathf.Atan2(forward.x, 0f - forward.z) * 57.29578f + 180f;
	}

	public override AppMarker GetAppMarkerData()
	{
		AppMarker appMarkerData = base.GetAppMarkerData();
		appMarkerData.rotation = GetRotation(GetParentEntity());
		return appMarkerData;
	}
}


using System;
using UnityEngine;

public class MapMarkerExplosion : MapMarker
{
	private float duration = 10f;

	public void SetDuration(float newDuration)
	{
		duration = newDuration;
		if (((FacepunchBehaviour)this).IsInvoking((Action)DelayedDestroy))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)DelayedDestroy);
		}
		((FacepunchBehaviour)this).Invoke((Action)DelayedDestroy, duration * 60f);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk)
		{
			Debug.LogWarning((object)"Loaded explosion marker from disk, cleaning up");
			((FacepunchBehaviour)this).Invoke((Action)DelayedDestroy, 3f);
		}
	}

	public void DelayedDestroy()
	{
		Kill();
	}
}


public class MapMarkerHelicopterFlee : MapMarker
{
}


using UnityEngine;

public class MobileMapMarker : MapMarker
{
	private GameObject createdMarker;
}


using UnityEngine;

public class StaticMapMarker : MapMarker
{
	private GameObject createdMarker;
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class BuriedItem : IPooled
{
	public int? ItemId { get; private set; }

	public ulong UID { get; private set; }

	public ItemOwnershipShare? OwnershipShare { get; private set; }

	public ulong? SkinId { get; private set; }

	public long ExpiryTime { get; set; }

	public Vector2 Location { get; private set; }

	public float? Condition { get; private set; }

	public static BuriedItem Create(Item item, Vector3 worldPosition, long expiryTime)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		BuriedItem buriedItem = Pool.Get<BuriedItem>();
		if (buriedItem == null)
		{
			Debug.LogError((object)"Failed to fetch buried item from the pool. Are we out of memory, or is the pool broken?");
			return null;
		}
		if ((Object)(object)item.info == (Object)null || item.info == null)
		{
			Debug.LogError((object)$"Tried to create a buried item with an item that has no ItemDefinition! UID: {item.uid}, ItemId: {item.info?.itemid}");
			Pool.Free<BuriedItem>(ref buriedItem);
			return null;
		}
		buriedItem.ItemId = item.info.itemid;
		buriedItem.ExpiryTime = expiryTime;
		buriedItem.Location = new Vector2(worldPosition.x, worldPosition.z);
		buriedItem.Condition = (item.hasCondition ? new float?(item.condition) : ((float?)null));
		buriedItem.UID = item.uid.Value;
		if (item.ownershipShares.Count > 0)
		{
			buriedItem.OwnershipShare = item.ownershipShares[0];
		}
		if (item.skin != 0L)
		{
			buriedItem.SkinId = item.skin;
		}
		return buriedItem;
	}

	public static BuriedItem Create(StoredBuriedItem storedBuriedItem)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		BuriedItem buriedItem = Pool.Get<BuriedItem>();
		buriedItem.ItemId = storedBuriedItem.itemId;
		buriedItem.SkinId = storedBuriedItem.skinId;
		buriedItem.Location = storedBuriedItem.location;
		buriedItem.ExpiryTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() + storedBuriedItem.expiryTimeDiff;
		buriedItem.Condition = ((storedBuriedItem.condition < 0f) ? ((float?)null) : new float?(storedBuriedItem.condition));
		buriedItem.UID = storedBuriedItem.uid;
		if (storedBuriedItem.ownership != null)
		{
			buriedItem.OwnershipShare = new ItemOwnershipShare
			{
				amount = storedBuriedItem.ownership.amount,
				reason = storedBuriedItem.ownership.reason,
				username = storedBuriedItem.ownership.username
			};
		}
		return buriedItem;
	}

	public void EnterPool()
	{
		ItemId = null;
		OwnershipShare = null;
		SkinId = null;
	}

	public void LeavePool()
	{
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using Spatial;
using UnityEngine;

public class BuriedItems : PointEntity
{
	[ServerVar(Help = "Time in seconds before an item expires.")]
	public static float expiryTime = 86400f;

	private const int CellSize = 128;

	private const float WorldSize = 8096f;

	private const float QuerySize = 64f;

	[ServerVar]
	public static int maxBuriedItems = 32;

	[ServerVar(Help = "Metal detector loot weight is 100.")]
	public static int buriedItemWeight = 100;

	[ServerVar(Help = "[0.0 to 1.0]")]
	public static float buryItemChance = 0.85f;

	private Grid<BuriedItem> grid = new Grid<BuriedItem>(128, 8096f);

	private readonly SortedList<long, BuriedItem> itemExpiryTracking = new SortedList<long, BuriedItem>(128);

	private readonly Dictionary<ulong, BuriedItem> uidItemMapping = new Dictionary<ulong, BuriedItem>(128);

	private static readonly Random Random = new Random();

	private (long lastExpiryTime, long modifiedExpiryTime)? lastExpiryTime;

	public static BuriedItems Instance { get; private set; }

	public override void ServerInit()
	{
		base.ServerInit();
		Clear();
		Instance = this;
	}

	public void Register(Item item, Vector3 worldPosition)
	{
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		if (item != null && ((ItemId)(ref item.uid)).IsValid && item.info.allowBurying && Random.NextDouble() <= (double)buryItemChance && itemExpiryTracking.Count < maxBuriedItems)
		{
			TimeSpan timeSpan = TimeSpan.FromSeconds(expiryTime);
			long num = DateTimeOffset.UtcNow.Add(timeSpan).ToUnixTimeMilliseconds();
			BuriedItem buriedItem = BuriedItem.Create(item, worldPosition, num);
			if (buriedItem != null)
			{
				Add(buriedItem);
			}
		}
	}

	private void Add(BuriedItem buriedItem)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		HandleDuplicateExpiryTimes(buriedItem);
		grid.Add(buriedItem, buriedItem.Location.x, buriedItem.Location.y);
		itemExpiryTracking.Add(buriedItem.ExpiryTime, buriedItem);
		uidItemMapping.Add(buriedItem.UID, buriedItem);
	}

	private void HandleDuplicateExpiryTimes(BuriedItem buriedItem)
	{
		long num = buriedItem.ExpiryTime;
		if (lastExpiryTime.HasValue && lastExpiryTime.Value.lastExpiryTime == num)
		{
			long num2;
			for (num2 = lastExpiryTime.Value.modifiedExpiryTime + 1; itemExpiryTracking.ContainsKey(num2); num2++)
			{
			}
			lastExpiryTime = (num, num2);
			buriedItem.ExpiryTime = num2;
		}
		else
		{
			lastExpiryTime = (num, num);
		}
	}

	private void PruneExpiredItems()
	{
		if (itemExpiryTracking.Count == 0)
		{
			return;
		}
		long num = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
		if (itemExpiryTracking.Values[0].ExpiryTime > num)
		{
			return;
		}
		PooledList<BuriedItem> val = Pool.Get<PooledList<BuriedItem>>();
		try
		{
			foreach (var (num3, item) in itemExpiryTracking)
			{
				if (num3 <= num)
				{
					((List<BuriedItem>)(object)val).Add(item);
					continue;
				}
				break;
			}
			if (((List<BuriedItem>)(object)val).Count <= 0)
			{
				return;
			}
			if (((List<BuriedItem>)(object)val).Count == itemExpiryTracking.Count)
			{
				itemExpiryTracking.Clear();
			}
			foreach (BuriedItem item2 in (List<BuriedItem>)(object)val)
			{
				UnregisterItem(item2);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void UnregisterItem(BuriedItem buriedItem)
	{
		grid.Remove(buriedItem);
		itemExpiryTracking.Remove(buriedItem.ExpiryTime);
		uidItemMapping.Remove(buriedItem.UID);
		Pool.Free<BuriedItem>(ref buriedItem);
	}

	public void UnregisterItem(ulong itemUid)
	{
		if (itemUid == 0L || !uidItemMapping.TryGetValue(itemUid, out var value))
		{
			Debug.LogError((object)$"Couldn't find buried item with ID {itemUid}");
		}
		else
		{
			UnregisterItem(value);
		}
	}

	public void Clear()
	{
		uidItemMapping.Clear();
		foreach (BuriedItem value in itemExpiryTracking.Values)
		{
			BuriedItem current = value;
			Pool.Free<BuriedItem>(ref current);
		}
		itemExpiryTracking.Clear();
		grid = new Grid<BuriedItem>(128, 8096f);
		lastExpiryTime = null;
	}

	public void DoUpdate()
	{
		PruneExpiredItems();
	}

	public void AddItems(List<DiggableEntityLoot.ItemEntry> items, Vector3 digWorldPos)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		List<BuriedItem> list = Pool.Get<List<BuriedItem>>();
		grid.Query<BuriedItem>(digWorldPos.x, digWorldPos.z, 64f, list);
		foreach (BuriedItem item in list)
		{
			if (item.ItemId.HasValue)
			{
				items.Add(new DiggableEntityLoot.ItemEntry
				{
					Item = ItemManager.FindItemDefinition(item.ItemId.Value),
					Skin = item.SkinId.GetValueOrDefault(),
					Min = 1,
					Max = 1,
					Weight = buriedItemWeight,
					Condition = item.Condition,
					UID = item.UID,
					Owner = item.OwnershipShare
				});
			}
		}
		Pool.Free<BuriedItem>(ref list, false);
	}

	public override void Save(SaveInfo info)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (!info.forDisk)
		{
			return;
		}
		BuriedItems val = Pool.Get<BuriedItems>();
		val.buriedItems = Pool.Get<List<StoredBuriedItem>>();
		foreach (BuriedItem value in itemExpiryTracking.Values)
		{
			if (value.ItemId.HasValue)
			{
				StoredBuriedItem val2 = Pool.Get<StoredBuriedItem>();
				val2.itemId = value.ItemId.Value;
				val2.skinId = value.SkinId.GetValueOrDefault();
				val2.expiryTimeDiff = value.ExpiryTime - DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
				val2.location = value.Location;
				val2.condition = (value.Condition.HasValue ? value.Condition.Value : (-1f));
				val2.uid = value.UID;
				if (value.OwnershipShare.HasValue)
				{
					ItemOwnershipAmount val3 = Pool.Get<ItemOwnershipAmount>();
					val3.amount = value.OwnershipShare.Value.amount;
					val3.username = value.OwnershipShare.Value.username;
					val3.reason = value.OwnershipShare.Value.reason;
					val2.ownership = val3;
				}
				val.buriedItems.Add(val2);
			}
		}
		info.msg.buriedItemStorage = val;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (!info.fromDisk || info.msg.buriedItemStorage == null)
		{
			return;
		}
		Clear();
		foreach (StoredBuriedItem buriedItem2 in info.msg.buriedItemStorage.buriedItems)
		{
			if (buriedItem2.uid != 0L)
			{
				BuriedItem buriedItem = BuriedItem.Create(buriedItem2);
				Add(buriedItem);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Rust;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/DiggableLoot Spawn")]
public class DiggableEntityLoot : ScriptableObject
{
	[Serializable]
	public struct ItemEntry
	{
		public ItemDefinition Item;

		public int Weight;

		public int Min;

		public int Max;

		public ulong Skin;

		public float? Condition;

		public ItemOwnershipShare? Owner;

		public ulong? UID;
	}

	public List<ItemEntry> Items = new List<ItemEntry>();

	private List<ItemEntry> allowedItems;

	private Era cachedEra;

	[InspectorFlags]
	public Enum Biomes = (Enum)(-1);

	[InspectorFlags]
	public Enum Topology = (Enum)(-1);

	public IList<ItemEntry> GetItems()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (cachedEra != ConVar.Server.Era)
		{
			allowedItems = null;
			cachedEra = ConVar.Server.Era;
		}
		if (allowedItems == null)
		{
			allowedItems = new List<ItemEntry>();
			foreach (ItemEntry item in Items)
			{
				if (item.Item.IsAllowed((EraRestriction)32))
				{
					allowedItems.Add(item);
				}
			}
		}
		return allowedItems;
	}

	public bool VerifyLootListForWorldPosition(Vector3 worldPos)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		int num = (Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap) ? TerrainMeta.BiomeMap.GetBiomeMaxType(worldPos) : 2);
		int num2 = ((!Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap)) ? 1 : TerrainMeta.TopologyMap.GetTopology(worldPos));
		if ((num & Biomes) == 0)
		{
			return false;
		}
		if ((num2 & Topology) == 0)
		{
			return false;
		}
		return true;
	}
}


using System;

[Serializable]
public struct ItemEntry
{
	public ItemDefinition Item;

	public int Weight;

	public int Min;

	public int Max;

	public ulong Skin;

	public float? Condition;

	public ItemOwnershipShare? Owner;

	public ulong? UID;
}


using System.Collections.Generic;
using UnityEngine;

public interface IMetalDetectable
{
	List<Vector3> GetScanLocations();

	Vector3 GetNearestPosition(Vector3 pos);

	bool VerifyScanPosition(Vector3 playerPos, Vector3 pos, out Vector3 spotPos);

	void Detected(Vector3 pos);

	float GetRadius();
}


using System;
using UnityEngine;

public class MetalDetectorFlag : BaseDiggableEntity
{
	public Collider Collision;

	public GameObject FlagModel;

	public float MoveUpBy = 0.2f;

	[ServerVar]
	public static float TimeoutDuration = 10800f;

	public override void ServerInit()
	{
		base.ServerInit();
		ResetTimeout();
	}

	private void ResetTimeout()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)Timeout);
		((FacepunchBehaviour)this).Invoke((Action)Timeout, TimeoutDuration * Random.Range(0.8f, 1.2f));
	}

	private void Timeout()
	{
		Kill();
	}

	public override void OnFullyDug(BasePlayer player)
	{
		if ((Object)(object)Collision != (Object)null)
		{
			Collision.enabled = false;
		}
		player.ProcessMissionEvent(BaseMission.MissionEventType.METAL_DETECTOR_FIND, 0, 1f);
		base.OnFullyDug(player);
	}

	public override void OnSingleDig(BasePlayer player)
	{
		base.OnSingleDig(player);
	}

	public override void OnFirstDig(BasePlayer player)
	{
		base.OnFirstDig(player);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class MetalDetectorSource : BaseEntity, IMetalDetectable
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 1200f;

	[ServerVar]
	public static int AttemptsPerSubSourceSpawn = 5;

	[ServerVar]
	public static float MinDistanceBetweenSubSources = 1.5f;

	[ServerVar]
	public static float TimeoutDuration = 7200f;

	public static int ServerCount = 0;

	[ClientVar(Saved = true)]
	public static bool DrawEditorGizmos = false;

	public int MinSources = 2;

	public int MaxSources = 5;

	public float SpawnRadiusMin = 4f;

	public float SpawnRadiusMax = 6f;

	public float SpawnRadiusBuffer = 1f;

	public GameObjectRef FlagPrefab;

	public GameObjectRef EffectPrefab;

	public const int placementMask = 8388608;

	public const int blockMask = 1075904769;

	public float SpawnRadius { get; private set; }

	public List<Vector3> SpawnLocations { get; private set; } = new List<Vector3>();

	[ServerVar]
	public static void ServerCountSources()
	{
		Debug.Log((object)("Server sources: " + ServerCount));
	}

	public override void ServerInit()
	{
		base.ServerInit();
		base.limitNetworking = true;
		ServerCount++;
		SpawnRadius = Random.Range(SpawnRadiusMin, SpawnRadiusMax);
		ResetTimeout();
		((FacepunchBehaviour)this).Invoke((Action)SpawnSources, Random.Range(0.1f, 1.5f));
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		ServerCount--;
	}

	private void SpawnSources()
	{
		SpawnLocations.Clear();
		int num = Random.Range(MinSources, MaxSources);
		for (int i = 0; i < num; i++)
		{
			TrySpawnSource();
		}
		KillIfNoSources();
		SendNetworkUpdate();
	}

	private void TrySpawnSource()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		bool flag = true;
		int num = 0;
		while (flag)
		{
			Vector3 val = Vector2.op_Implicit(Random.insideUnitCircle);
			Vector3 pos = ((Component)this).transform.position + new Vector3(val.x, 0f, val.y) * (SpawnRadius - SpawnRadiusBuffer);
			bool num2 = ValidateSourcePosition(ref pos);
			if (num2)
			{
				AddSource(pos);
			}
			flag = !num2 && ++num < AttemptsPerSubSourceSpawn;
		}
	}

	private bool ValidateSourcePosition(ref Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(pos + Vector3.up, Vector3.down, ref val, 4f, 8388608))
		{
			foreach (Vector3 spawnLocation in SpawnLocations)
			{
				if (Vector3.SqrMagnitude(((RaycastHit)(ref val)).point - spawnLocation) < MinDistanceBetweenSubSources * MinDistanceBetweenSubSources)
				{
					return false;
				}
			}
			if (!GamePhysics.LineOfSight(((RaycastHit)(ref val)).point, ((RaycastHit)(ref val)).point + Vector3.up * 4f, 1075904769))
			{
				return false;
			}
			if (!GamePhysics.LineOfSight(((Component)this).transform.position, ((RaycastHit)(ref val)).point, 1075904769))
			{
				return false;
			}
			pos = ((RaycastHit)(ref val)).point;
			return true;
		}
		return false;
	}

	private void ResetTimeout()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)Timeout);
		((FacepunchBehaviour)this).Invoke((Action)Timeout, TimeoutDuration * Random.Range(0.8f, 1.2f));
	}

	private void Timeout()
	{
		Kill();
	}

	private void KillIfNoSources()
	{
		if (SpawnLocations.Count == 0)
		{
			Kill();
		}
	}

	private void AddSource(Vector3 pos)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		SpawnLocations.Add(pos);
	}

	private void RemoveSource(Vector3 pos)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		SpawnLocations.Remove(pos);
		KillIfNoSources();
	}

	public Vector3 FindNearestSubSource(Vector3 scanPosition)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		float num = float.PositiveInfinity;
		Vector3 result = scanPosition;
		foreach (Vector3 spawnLocation in SpawnLocations)
		{
			float num2 = Vector3.SqrMagnitude(scanPosition - spawnLocation);
			if (num2 < num)
			{
				num = num2;
				result = spawnLocation;
			}
		}
		return result;
	}

	public void RemoveSweetSpotAndCreateFlag(Vector3 position)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		for (int num = SpawnLocations.Count - 1; num >= 0; num--)
		{
			Vector3 val = SpawnLocations[num];
			if (Vector3.SqrMagnitude(position - val) <= 0.040000003f)
			{
				RemoveSource(val);
				CreateFlag(val);
				flag = true;
			}
		}
		if (flag)
		{
			SendNetworkUpdateImmediate();
		}
	}

	private void CreateFlag(Vector3 pos)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		GameManager.server.CreateEntity(FlagPrefab.resourcePath, pos, Quaternion.Euler(0f, (float)Random.Range(0, 360), 0f)).Spawn();
		Effect.server.Run(EffectPrefab.resourcePath, pos + Vector3.up * 0.1f, Vector3.up);
	}

	public bool VerifySweetSpotPosition(Vector3 playerPos, Vector3 pos, out Vector3 spotPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		spotPos = playerPos;
		if (Vector3.SqrMagnitude(playerPos - pos) >= 4f)
		{
			return false;
		}
		foreach (Vector3 spawnLocation in SpawnLocations)
		{
			if (Vector3.SqrMagnitude(pos - spawnLocation) <= 0.25f)
			{
				spotPos = spawnLocation;
				return true;
			}
		}
		return false;
	}

	public List<Vector3> GetScanLocations()
	{
		return SpawnLocations;
	}

	public Vector3 GetNearestPosition(Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return FindNearestSubSource(pos);
	}

	public bool VerifyScanPosition(Vector3 playerPos, Vector3 pos, out Vector3 spotPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return VerifySweetSpotPosition(playerPos, pos, out spotPos);
	}

	public void Detected(Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		RemoveSweetSpotAndCreateFlag(pos);
	}

	public float GetRadius()
	{
		return SpawnRadius;
	}
}


using UnityEngine;

public class ItemModPager : ItemModRFListener
{
	public static readonly Phrase SilentOffTitle = new Phrase("silent_off", "Silent OFF");

	public static readonly Phrase SilentOffDesc = new Phrase("silent_off_desc", "Emits a small buzzing sound at short distance");

	public static readonly Phrase SilentOnTitle = new Phrase("silent_on", "Silent ON");

	public static readonly Phrase SilentOnDesc = new Phrase("silent_on_desc", "Emits an audible sound at a distance");

	public static readonly Phrase StopTitle = new Phrase("stop", "Stop");

	public static readonly Phrase StopDesc = new Phrase("stop_desc", "Stop the alert");

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		base.ServerCommand(item, command, player);
		PagerEntity component = ((Component)ItemModAssociatedEntity<BaseEntity>.GetAssociatedEntity(item)).GetComponent<PagerEntity>();
		if (Object.op_Implicit((Object)(object)component))
		{
			switch (command)
			{
			case "stop":
				component.SetOff();
				break;
			case "silenton":
				component.SetSilentMode(wantsSilent: true);
				break;
			case "silentoff":
				component.SetSilentMode(wantsSilent: false);
				break;
			}
		}
	}
}


public class ItemModRFListener : ItemModAssociatedEntity<BaseEntity>
{
	public static readonly Phrase SetFreqTitle = new Phrase("setfreq", "Set Frequency");

	public static readonly Phrase SetFreqDesc = new Phrase("setfreq_desc", "Configure which frequency to listen to");

	public GameObjectRef frequencyPanelPrefab;

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		base.ServerCommand(item, command, player);
	}
}


public class ClientIOLine_Pipe : ClientIOLine, INotifyLOD
{
	public NotifyLOD NotifyLod;

	public PipeMesh PipeRenderer;
}


using UnityEngine;

public class PipeMesh : MonoBehaviour
{
	public float PipeRadius = 0.04f;

	public Material PipeMaterial;

	public float StraightLength = 0.3f;

	public int PipeSubdivisions = 8;

	public int BendTesselation = 6;

	public float RidgeHeight = 0.05f;

	public float UvScaleMultiplier = 2f;

	public float RidgeIncrements = 0.5f;

	public float RidgeLength = 0.05f;

	public Vector2 HorizontalUvRange = new Vector2(0f, 0.2f);
}


using System.Collections.Generic;
using UnityEngine;

[ExecuteInEditMode]
public class PipeMeshTester : MonoBehaviour
{
	public List<Vector3> positions;

	public Vector3 startDir;

	public Vector3 endDir;

	public Transform startGuide;

	public Transform endGuide;
}


public class Shovel : BaseMelee
{
}


using System;
using UnityEngine;

public class AlignedLineDrawer : MonoBehaviour, IClientComponent
{
	[Serializable]
	public struct LinePoint
	{
		public Vector3 LocalPosition;

		public Vector3 WorldNormal;
	}

	public MeshFilter Filter;

	public MeshRenderer Renderer;

	public float LineWidth = 1f;

	public float SurfaceOffset = 0.001f;

	public float SprayThickness = 0.4f;

	public float uvTilingFactor = 1f;

	public bool DrawEndCaps;

	public bool DrawSideMesh;

	public bool DrawBackMesh;

	public SprayCanSpray_Freehand Spray;
}


using System;
using UnityEngine;

[Serializable]
public struct LinePoint
{
	public Vector3 LocalPosition;

	public Vector3 WorldNormal;
}


public class AlignedLineDrawerDecal : AlignedLineDrawer, INotifyLOD
{
	public DeferredDecal decalComponent;
}


using UnityEngine;

public class ReskinEffect : MonoBehaviour
{
	public ParticleSystem TargetSystem;
}


public interface ISprayCallback
{
	void OnReskinned(BasePlayer byPlayer);
}


using UnityEngine;

public class SprayCanViewmodel : MonoBehaviour, IAnimationEventReceiver
{
	public ParticleSystem Particles;

	public SoundDefinition sprayLoopDef;
}


using Rust.Workshop;
using UnityEngine;

public class SprayCanSpray_Decal : SprayCanSpray, ICustomMaterialReplacer, IPropRenderNotify, INotifyLOD, IWorkshopPreview
{
	public DeferredDecal DecalComponent;

	public GameObject IconPreviewRoot;

	public Material DefaultMaterial;
}


using System.Collections.Generic;
using UnityEngine;

public class ClientIOLine : BaseMonoBehaviour, INotifyLOD
{
	public LineRenderer _line;

	public NotifyLOD lod;

	public Material directionalMaterial;

	public Material defaultMaterial;

	public IOEntity.IOType lineType;

	public WireTool.WireColour colour;

	public static List<ClientIOLine> allLines = new List<ClientIOLine>();

	public IOEntity ownerIOEnt;
}


using System;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/IO/Wire Color Settings")]
public class WireColorSettings : BaseScriptableObject
{
	[Serializable]
	public struct WireColor
	{
		public WireTool.WireColour type;

		public Color color;

		public GameObjectRef prefab;

		public Phrase name;

		public Phrase desc;

		public bool requireCreativeMode;
	}

	private static readonly List<WireColorSettings> settings = new List<WireColorSettings>();

	public IOEntity.IOType ioType;

	public WireColor[] WireColors;

	public static WireColorSettings Get(IOEntity.IOType type)
	{
		foreach (WireColorSettings setting in settings)
		{
			if (setting.ioType == type)
			{
				return setting;
			}
		}
		WireColorSettings wireColorSettings = FileSystem.Load<WireColorSettings>($"Assets/Prefabs/Tools/Wire/{type} Color Settings.asset", true);
		settings.Add(wireColorSettings);
		return wireColorSettings;
	}

	public GameObjectRef GetPrefabRef(WireTool.WireColour wireColor)
	{
		WireColor[] wireColors = WireColors;
		for (int i = 0; i < wireColors.Length; i++)
		{
			WireColor wireColor2 = wireColors[i];
			if (wireColor2.type == wireColor)
			{
				return wireColor2.prefab;
			}
		}
		if (WireColors.Length != 0)
		{
			return WireColors[0].prefab;
		}
		return null;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct WireColor
{
	public WireTool.WireColour type;

	public Color color;

	public GameObjectRef prefab;

	public Phrase name;

	public Phrase desc;

	public bool requireCreativeMode;
}


using UnityEngine;

public class CassettePanel : NotePanel
{
	public GameObject[] CassetteSprites;
}


using UnityEngine;

public class EffectMount : EntityComponent<BaseEntity>, IClientComponent
{
	public bool firstPerson;

	public GameObject effectPrefab;

	public GameObject spawnedEffect;

	public GameObject mountBone;

	public SoundDefinition onSoundDef;

	public SoundDefinition offSoundDef;

	public bool blockOffSoundWhenGettingDisabled;
}


using UnityEngine;

public class EffectParent : EntityComponent<BaseEntity>, IClientComponent
{
	public GameObject effect;

	[Tooltip("If true the effect isn't our direct child and is in another hierarchy - USE WITH CAUTION")]
	public bool separatedEffect;

	[Header("USING COLLIDERS? - COLLIDER SAFETY")]
	[Tooltip("If true the effect will be forced to the safe layer that doesn't interact with player colliders")]
	public bool forceSafePlayerCollisionLayer;
}


using UnityEngine;

public class FlashlightBeam : MonoBehaviour, IClientComponent
{
	public Vector2 scrollDir;

	public Vector3 localEndPoint = new Vector3(0f, 0f, 2f);

	public LineRenderer beamRenderer;
}


using UnityEngine;

public class LineRendererActivate : MonoBehaviour, IClientComponent
{
	private void OnEnable()
	{
		((Renderer)((Component)this).GetComponent<LineRenderer>()).enabled = true;
	}
}


using UnityEngine;

public class HolosightReticlePositioning : MonoBehaviour
{
	public IronsightAimPoint aimPoint;

	public RectTransform rectTransform
	{
		get
		{
			Transform transform = ((Component)this).transform;
			return (RectTransform)(object)((transform is RectTransform) ? transform : null);
		}
	}

	private void Update()
	{
		if (MainCamera.isValid)
		{
			UpdatePosition(MainCamera.mainCamera);
		}
	}

	private void UpdatePosition(Camera cam)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)aimPoint.targetPoint).transform.position;
		Vector2 val = RectTransformUtility.WorldToScreenPoint(cam, position);
		Transform parent = ((Transform)rectTransform).parent;
		RectTransformUtility.ScreenPointToLocalPointInRectangle((RectTransform)(object)((parent is RectTransform) ? parent : null), val, cam, ref val);
		ref float x = ref val.x;
		float num = x;
		Transform parent2 = ((Transform)rectTransform).parent;
		Rect rect = ((RectTransform)((parent2 is RectTransform) ? parent2 : null)).rect;
		x = num / (((Rect)(ref rect)).width * 0.5f);
		ref float y = ref val.y;
		float num2 = y;
		Transform parent3 = ((Transform)rectTransform).parent;
		rect = ((RectTransform)((parent3 is RectTransform) ? parent3 : null)).rect;
		y = num2 / (((Rect)(ref rect)).height * 0.5f);
		rectTransform.anchoredPosition = val;
	}
}


using UnityEngine;

public class LaserBeam : MonoBehaviour
{
	public float scrollSpeed = 0.5f;

	public LineRenderer beamRenderer;

	public GameObject dotObject;

	public Renderer dotRenderer;

	public GameObject dotSpotlight;

	public Vector2 scrollDir;

	public float maxDistance = 100f;

	public float stillBlendFactor = 0.1f;

	public float movementBlendFactor = 0.5f;

	public float movementThreshhold = 0.15f;

	public bool isFirstPerson;

	public Transform emissionOverride;
}


using UnityEngine;

public class HideIfScoped : MonoBehaviour
{
	public Renderer[] renderers;

	public void SetVisible(bool vis)
	{
		Renderer[] array = renderers;
		foreach (Renderer val in array)
		{
			if ((Object)(object)val != (Object)null)
			{
				val.enabled = vis;
			}
		}
	}
}


using UnityEngine;

public class ViewmodelScope : MonoBehaviour
{
	public float smoothSpeed = 0.05f;

	public Material scopeMaterialOverride;
}


using UnityEngine;

public class HideIfAiming : MonoBehaviour, IEffect
{
	public ParticleSystem[] systems;
}


using UnityEngine;

public class BeeGrenade : TimedExplosive
{
	public GameObjectRef beeSwarmPrefab;

	[Header("Spawning Settings")]
	public int beeSwarmAmount = 1;

	public float spawnRadius = 2f;

	private const int mask = -928830719;

	public override void Explode()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		if (beeSwarmPrefab.isValid && !WaterLevel.Test(((Component)this).transform.position, waves: true, volumes: true, this))
		{
			RaycastHit val4 = default(RaycastHit);
			RaycastHit val6 = default(RaycastHit);
			RaycastHit val7 = default(RaycastHit);
			for (int i = 0; i < Mathf.Max(1, beeSwarmAmount); i++)
			{
				Vector3 val = ((Component)this).transform.position;
				Vector3 val5;
				if (beeSwarmAmount > 1)
				{
					Vector2 val2 = Random.insideUnitCircle * spawnRadius;
					Vector3 val3 = ((Component)this).transform.position + new Vector3(val2.x, 0f, val2.y);
					if (Physics.Linecast(((Component)this).transform.position, val3, ref val4, -928830719))
					{
						Vector3 point = ((RaycastHit)(ref val4)).point;
						val5 = ((Component)this).transform.position - point;
						Vector3 normalized = ((Vector3)(ref val5)).normalized;
						val = point + normalized * 1.5f;
					}
					else
					{
						val5 = ((Component)this).transform.position - ((Component)this).transform.position;
						Vector3 normalized2 = ((Vector3)(ref val5)).normalized;
						val = val3;
						val += normalized2 * 0.5f;
					}
				}
				if (Physics.Raycast(new Ray(val + Vector3.up * 0.5f, Vector3.down), ref val6, 2f, -928830719))
				{
					val.y = ((RaycastHit)(ref val6)).point.y;
				}
				val += Vector3.up * 1.5f;
				if (Physics.Linecast(((Component)this).transform.position, val, ref val7, -928830719))
				{
					val = ((RaycastHit)(ref val7)).point;
				}
				if ((Object)(object)creatorPlayer != (Object)null)
				{
					val5 = ((Component)creatorPlayer).transform.position - ((Component)this).transform.position;
					Vector3 normalized3 = ((Vector3)(ref val5)).normalized;
					val += normalized3;
				}
				BaseEntity baseEntity = GameManager.server.CreateEntity(beeSwarmPrefab.resourcePath, val, Quaternion.identity);
				if ((Object)(object)creatorPlayer != (Object)null)
				{
					baseEntity.OwnerID = creatorPlayer.userID;
					baseEntity.creatorEntity = creatorPlayer;
				}
				baseEntity.Spawn();
			}
		}
		base.Explode();
	}

	public void DelayedDestroy()
	{
		Kill(DestroyMode.Gib);
	}
}


using UnityEngine;

public class BeeTriggerHurt : TriggerHurtEx
{
	public GameObjectRef BeeGrenadePrefab;

	protected override void ModifyHit(HitInfo info)
	{
		base.ModifyHit(info);
		if ((Object)(object)info.Initiator != (Object)null && info.Initiator.OwnerID != 0L)
		{
			info.Initiator = BasePlayer.FindByID(info.Initiator.OwnerID);
			info.WeaponPrefab = GameManager.server.FindPrefab(BeeGrenadePrefab.resourcePath).GetComponent<BaseEntity>();
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using Rust;
using UnityEngine;

public class ThrownBoomerangServerProjectile : ServerProjectile
{
	public DamageProperties damageProperties;

	public List<DamageTypeEntry> damageTypes = new List<DamageTypeEntry>();

	public float worldAttackRadius;

	private Vector3 startPosition;

	private bool willKill;

	public void ProjectileHandleMovement(bool state)
	{
		shouldMoveProjectile = state;
	}

	public void SetStartPosition(Vector3 position)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		startPosition = position;
	}

	public void CalculateDamage(HitInfo info, float scale)
	{
		foreach (DamageTypeEntry damageType in damageTypes)
		{
			info.damageTypes.Add(damageType.type, damageType.amount * scale);
		}
		if (Global.developer > 0)
		{
			Debug.Log((object)(" Projectile damage: " + info.damageTypes.Total() + " (scalar=" + scale + ")"));
		}
	}

	protected override bool AutomaticallyRotate()
	{
		return false;
	}

	protected override void OnHit(RaycastHit rayHit, BaseEntity hitEntity)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		base.OnHit(rayHit, hitEntity);
		willKill = true;
		HitInfo hitInfo = new HitInfo();
		hitInfo.Initiator = base.baseEntity.creatorEntity;
		hitInfo.WeaponPrefab = base.baseEntity;
		hitInfo.IsPredicting = false;
		hitInfo.DoDecals = true;
		hitInfo.DoHitEffects = true;
		hitInfo.DidHit = true;
		hitInfo.HitPositionWorld = ((RaycastHit)(ref rayHit)).point;
		hitInfo.HitNormalWorld = ((RaycastHit)(ref rayHit)).normal;
		hitInfo.ProjectileVelocity = base.CurrentVelocity;
		hitInfo.PointStart = startPosition;
		hitInfo.PointEnd = ((RaycastHit)(ref rayHit)).point;
		hitInfo.damageProperties = damageProperties;
		CalculateDamage(hitInfo, 1f);
		hitInfo.HitMaterial = StringPool.Get(GetMaterialName(rayHit));
		ThrownBoomerang obj = base.baseEntity as ThrownBoomerang;
		obj.OnHit();
		if (hitEntity.IsValid())
		{
			hitInfo.HitEntity = hitEntity;
			hitInfo.HitPositionLocal = ((Component)hitInfo.HitEntity).transform.InverseTransformPoint(hitInfo.HitPositionWorld);
			hitInfo.HitNormalLocal = ((Component)hitInfo.HitEntity).transform.InverseTransformDirection(hitInfo.HitNormalWorld);
			Shield shield = hitInfo.HitEntity as Shield;
			if (hitInfo.HitEntity is BasePlayer || hitInfo.HitEntity is BaseNpc || (Object)(object)shield != (Object)null)
			{
				hitInfo.HitMaterial = StringPool.Get(((Object)(object)shield != (Object)null) ? shield.GetHitMaterialString() : "Flesh");
			}
			if (!(hitInfo.HitEntity is BasePlayer) && !(hitInfo.HitEntity is BaseNpc))
			{
				hitInfo.damageTypes.ScaleAll(0.03f);
			}
			hitInfo.HitEntity.OnAttacked(hitInfo);
		}
		Vector3 currentVelocity = base.CurrentVelocity;
		obj.CreateWorldModel(hitInfo, ((Vector3)(ref currentVelocity)).normalized);
		Effect.server.ImpactEffect(hitInfo);
	}

	protected override bool DoHitDetection(Vector3 velocityToUse, float distance)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		List<RaycastHit> list2 = Pool.Get<List<RaycastHit>>();
		Vector3 position = ((Component)this).transform.position;
		GamePhysics.TraceAll(new Ray(position, ((Vector3)(ref velocityToUse)).normalized), radius, list, distance + scanRange, mask, (QueryTriggerInteraction)1);
		GamePhysics.TraceAll(new Ray(position, ((Vector3)(ref velocityToUse)).normalized), worldAttackRadius, list2, distance + scanRange, mask, (QueryTriggerInteraction)1);
		foreach (RaycastHit item in list)
		{
			RaycastHit current = item;
			BaseEntity entity = current.GetEntity();
			if ((!((Object)(object)entity != (Object)null) || !entity.isClient) && (!IgnoreAI || !IsAnIgnoredAI(entity)) && (entity is BasePlayer || entity is BaseNpc) && IsAValidHit(entity) && GamePhysics.LineOfSight(((Component)this).transform.position, ((RaycastHit)(ref current)).point, mask, 0f))
			{
				ProcessHit(current, entity, position);
				Pool.FreeUnmanaged<RaycastHit>(ref list);
				Pool.FreeUnmanaged<RaycastHit>(ref list2);
				return true;
			}
		}
		foreach (RaycastHit item2 in list2)
		{
			BaseEntity entity2 = item2.GetEntity();
			if ((!((Object)(object)entity2 != (Object)null) || !entity2.isClient) && (!IgnoreAI || !IsAnIgnoredAI(entity2)) && IsAValidHit(entity2) && IsShootable(item2))
			{
				ProcessHit(item2, entity2, position);
				Pool.FreeUnmanaged<RaycastHit>(ref list);
				Pool.FreeUnmanaged<RaycastHit>(ref list2);
				return true;
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		Pool.FreeUnmanaged<RaycastHit>(ref list2);
		return false;
	}

	protected override void PostDoMove()
	{
		if (willKill)
		{
			base.baseEntity.Kill();
		}
	}

	protected override bool IsAValidHit(BaseEntity hitEnt)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)hitEnt != (Object)null)
		{
			if (base.baseEntity.creatorEntity.IsValid() && hitEnt.net.ID == base.baseEntity.creatorEntity.net.ID)
			{
				return false;
			}
			if (ignoreEntity.IsValid() && hitEnt.net.ID == ignoreEntity.net.ID)
			{
				return false;
			}
		}
		return true;
	}

	private string GetMaterialName(RaycastHit rayHit)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		string result = "generic";
		if ((Object)(object)rayHit.GetCollider() != (Object)null && (Object)(object)rayHit.GetCollider().sharedMaterial != (Object)null)
		{
			result = ((Object)rayHit.GetCollider().sharedMaterial).name;
		}
		if (rayHit.IsWaterHit())
		{
			result = "Water";
		}
		return result;
	}
}


using UnityEngine;

public class v_chainsaw : MonoBehaviour
{
	public bool bAttacking;

	public bool bHitMetal;

	public bool bHitWood;

	public bool bHitFlesh;

	public bool bEngineOn;

	public ParticleSystem[] hitMetalFX;

	public ParticleSystem[] hitWoodFX;

	public ParticleSystem[] hitFleshFX;

	public SoundDefinition hitMetalSoundDef;

	public SoundDefinition hitWoodSoundDef;

	public SoundDefinition hitFleshSoundDef;

	public Sound hitSound;

	public GameObject hitSoundTarget;

	public float hitSoundFadeTime = 0.1f;

	public ParticleSystem smokeEffect;

	public Animator chainsawAnimator;

	public Renderer chainRenderer;

	public Material chainlink;

	private MaterialPropertyBlock block;

	private Vector2 saveST;

	private float chainSpeed;

	private float chainAmount;

	public float temp1;

	public float temp2;

	public void OnEnable()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Expected O, but got Unknown
		if (block == null)
		{
			block = new MaterialPropertyBlock();
		}
		saveST = Vector4.op_Implicit(chainRenderer.sharedMaterial.GetVector("_MainTex_ST"));
	}

	private void Awake()
	{
		chainlink = chainRenderer.sharedMaterial;
	}

	private void Start()
	{
	}

	private void ScrollChainTexture()
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		float num = (chainAmount = (chainAmount + Time.deltaTime * chainSpeed) % 1f);
		block.Clear();
		block.SetVector("_MainTex_ST", new Vector4(saveST.x, saveST.y, num, 0f));
		chainRenderer.SetPropertyBlock(block);
	}

	private void Update()
	{
		chainsawAnimator.SetBool("attacking", bAttacking);
		smokeEffect.enableEmission = bEngineOn;
		if (bHitMetal)
		{
			chainsawAnimator.SetBool("attackHit", true);
			ParticleSystem[] array = hitMetalFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = true;
			}
			array = hitWoodFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = false;
			}
			array = hitFleshFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = false;
			}
			DoHitSound(hitMetalSoundDef);
		}
		else if (bHitWood)
		{
			chainsawAnimator.SetBool("attackHit", true);
			ParticleSystem[] array = hitMetalFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = false;
			}
			array = hitWoodFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = true;
			}
			array = hitFleshFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = false;
			}
			DoHitSound(hitWoodSoundDef);
		}
		else if (bHitFlesh)
		{
			chainsawAnimator.SetBool("attackHit", true);
			ParticleSystem[] array = hitMetalFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = false;
			}
			array = hitWoodFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = false;
			}
			array = hitFleshFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = true;
			}
			DoHitSound(hitFleshSoundDef);
		}
		else
		{
			chainsawAnimator.SetBool("attackHit", false);
			ParticleSystem[] array = hitMetalFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = false;
			}
			array = hitWoodFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = false;
			}
			array = hitFleshFX;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enableEmission = false;
			}
		}
	}

	private void DoHitSound(SoundDefinition soundDef)
	{
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

public class DeployableSiegeExplosive : BaseCombatEntity, IIgniteable, ISplashable
{
	public GameObjectRef ExplosionEffect;

	public GameObjectRef ExplosionImpact;

	public Vector3 EffectOffset;

	public Transform ExplosionSpawnPoint;

	public const Flags Lit = Flags.Reserved1;

	public float MinimumFuseTime = 3f;

	public float MaximumFuseTime = 10f;

	public float NeighbourExplodeRadius = 2f;

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		creatorEntity = deployedBy;
	}

	public override void Hurt(HitInfo info)
	{
		if (!base.isClient && !HasFlag(Flags.Reserved1))
		{
			info.damageTypes.ScaleAll(0f);
			base.Hurt(info);
			SetFlag(Flags.Reserved1, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ActuallyExplode, Random.Range(MinimumFuseTime, MaximumFuseTime));
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (HasFlag(Flags.Reserved1))
		{
			((FacepunchBehaviour)this).Invoke((Action)ActuallyExplode, Random.Range(MinimumFuseTime, MaximumFuseTime));
		}
	}

	private void ActuallyExplode()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		if (ExplosionEffect.isValid)
		{
			Vector3 position = ExplosionSpawnPoint.position;
			BaseEntity baseEntity = GameManager.server.CreateEntity(ExplosionEffect.resourcePath, position);
			ServerProjectile component = ((Component)baseEntity).GetComponent<ServerProjectile>();
			component.InitializeVelocity(Vector3.up);
			baseEntity.Spawn();
			TimedExplosive timedExplosive = default(TimedExplosive);
			if (((Component)component).TryGetComponent<TimedExplosive>(ref timedExplosive))
			{
				timedExplosive.creatorEntity = creatorEntity;
				timedExplosive.Explode();
			}
			if (ExplosionImpact.isValid)
			{
				Effect.server.Run(ExplosionImpact.resourcePath, position + EffectOffset);
			}
			PooledList<DeployableSiegeExplosive> val = Pool.Get<PooledList<DeployableSiegeExplosive>>();
			try
			{
				Vis.Entities(position, NeighbourExplodeRadius, (List<DeployableSiegeExplosive>)(object)val, 256, (QueryTriggerInteraction)2);
				foreach (DeployableSiegeExplosive item in (List<DeployableSiegeExplosive>)(object)val)
				{
					if (item.isServer && !item.HasFlag(Flags.Reserved1) && CanSee(position, item.ExplosionSpawnPoint.position))
					{
						item.Hurt(3f, DamageType.Heat, this);
					}
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		Kill();
	}

	public void Ignite(Vector3 fromPos)
	{
		SetFlag(Flags.Reserved1, b: true);
		((FacepunchBehaviour)this).Invoke((Action)ActuallyExplode, Random.Range(MinimumFuseTime, MaximumFuseTime));
	}

	public bool CanIgnite()
	{
		return !HasFlag(Flags.Reserved1);
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		return HasFlag(Flags.Reserved1);
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		SetFlag(Flags.Reserved1, b: false);
		((FacepunchBehaviour)this).CancelInvoke((Action)ActuallyExplode);
		return 0;
	}

	private void OnGroundMissing()
	{
		ActuallyExplode();
	}

	protected override bool ShouldDisplayPickupOption(BasePlayer player)
	{
		if (!HasFlag(Flags.Reserved1))
		{
			return base.ShouldDisplayPickupOption(player);
		}
		return false;
	}
}


using UnityEngine;

public class DoubleShotgunViewModel : BaseViewModel
{
	public GameObject NoSkinRoot;
}


using UnityEngine;

public class FlameJet : MonoBehaviour
{
	public LineRenderer line;

	public float tesselation = 0.025f;

	private float length;

	public float maxLength = 2f;

	public float drag;

	private int numSegments;

	private float spacing;

	public bool on;

	public bool autoDisable;

	private Vector3[] lastWorldSegments;

	private Vector3[] currentSegments = (Vector3[])(object)new Vector3[0];

	public Color startColor;

	public Color endColor;

	public Color currentColor;

	public bool externalUpdate;

	private void Initialize()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		currentColor = startColor;
		tesselation = 0.1f;
		numSegments = Mathf.CeilToInt(maxLength / tesselation);
		spacing = maxLength / (float)numSegments;
		if (currentSegments.Length != numSegments)
		{
			currentSegments = (Vector3[])(object)new Vector3[numSegments];
		}
	}

	private void Awake()
	{
		Initialize();
	}

	public void LateUpdate()
	{
		if (!externalUpdate)
		{
			UpdateLine();
		}
	}

	public void SetOn(bool isOn)
	{
		on = isOn;
	}

	private float curve(float x)
	{
		return x * x;
	}

	public void UpdateLine()
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		currentColor.a = Mathf.Lerp(currentColor.a, on ? 1f : 0f, Time.deltaTime * 40f);
		line.SetColors(currentColor, endColor);
		if (lastWorldSegments == null)
		{
			lastWorldSegments = (Vector3[])(object)new Vector3[numSegments];
		}
		int num = currentSegments.Length;
		Vector3 val3 = default(Vector3);
		for (int i = 0; i < num; i++)
		{
			float num2 = 0f;
			float num3 = 0f;
			if (lastWorldSegments != null && lastWorldSegments[i] != Vector3.zero && i > 0)
			{
				Vector3 val = ((Component)this).transform.InverseTransformPoint(lastWorldSegments[i]);
				float num4 = (float)i / (float)currentSegments.Length;
				Vector3 val2 = Vector3.Lerp(val, Vector3.zero, Time.deltaTime * drag);
				val2 = Vector3.Lerp(Vector3.zero, val2, Mathf.Sqrt(num4));
				num2 = val2.x;
				num3 = val2.y;
			}
			if (i == 0)
			{
				num2 = (num3 = 0f);
			}
			((Vector3)(ref val3))..ctor(num2, num3, (float)i * spacing);
			currentSegments[i] = val3;
			lastWorldSegments[i] = ((Component)this).transform.TransformPoint(val3);
		}
		line.positionCount = numSegments;
		line.SetPositions(currentSegments);
		if (autoDisable && !on && currentColor.a < 0.01f)
		{
			currentColor.a = 0f;
			line.SetColors(currentColor, endColor);
			((Behaviour)this).enabled = false;
		}
	}
}


using UnityEngine;
using UnityEngine.UI;

public class HomingLauncherUIDialog : UIDialog
{
	[Header("Homing Launcher")]
	[SerializeField]
	private Canvas canvas;

	[SerializeField]
	private GameObject mainUI;

	[SerializeField]
	private GameObject scopeCircle;

	[SerializeField]
	private RawImage blackScreen;

	[SerializeField]
	private AnimationCurve fadeEffectCurve;

	[SerializeField]
	private float visualSwapTime = 0.5f;

	[SerializeField]
	private Image lockPercentImage;

	[SerializeField]
	private Image trackingImage;

	[SerializeField]
	private GameObject armedObj;

	[SerializeField]
	private GameObject lockedObj;

	[SerializeField]
	private GameObject noAmmoObj;
}


public class HomingLauncherViewModel : BaseViewModel
{
}


using System;
using UnityEngine;

public class SeekerTest : BaseEntity, SeekerTarget.ISeekerTargetOwner
{
	public GameObjectRef roadFlare;

	public bool useRoadFlares;

	public int numFlares = 3;

	public int maxFlares = 3;

	public float flareRegenTime = 10f;

	public float timeBetweenFlares = 10f;

	public Transform flareSpawnPoint;

	public float flareDuration = 5f;

	private float nextFlareRegenTime;

	public override void ServerInit()
	{
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.MEDIUM);
		base.ServerInit();
	}

	public void Update()
	{
		if (Time.time > nextFlareRegenTime)
		{
			numFlares = Mathf.Clamp(numFlares + 1, 0, maxFlares);
			nextFlareRegenTime = Time.time + timeBetweenFlares;
		}
	}

	public void DoFlare()
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (numFlares != 0)
		{
			numFlares--;
			if (useRoadFlares)
			{
				GameManager.server.CreateEntity(roadFlare.resourcePath, flareSpawnPoint.position).Spawn();
				return;
			}
			SetFlag(Flags.OnFire, b: true);
			SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
			((FacepunchBehaviour)this).Invoke((Action)ClearFlares, flareDuration);
		}
	}

	public void ClearFlares()
	{
		SetFlag(Flags.OnFire, b: false);
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.MEDIUM);
	}

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		if (msg == "RadarLock")
		{
			if (!((FacepunchBehaviour)this).IsInvoking((Action)DoFlare))
			{
				((FacepunchBehaviour)this).Invoke((Action)DoFlare, Random.Range(0.5f, 1f));
			}
		}
		else if (msg == "RadarWarning")
		{
			SetFlag(Flags.Reserved1, b: true);
			((FacepunchBehaviour)this).Invoke((Action)ClearWarning, 1f);
		}
		else
		{
			base.OnEntityMessage(from, msg);
		}
	}

	public void ClearWarning()
	{
		SetFlag(Flags.Reserved1, b: false);
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
		}
		base.DestroyShared();
	}

	public bool IsValidHomingTarget()
	{
		return true;
	}
}


public class ItemModShield : ItemMod
{
}


using System;
using UnityEngine;

public class ShieldHeldEntityOffset : PrefabAttribute, IClientComponent
{
	public enum BoneType
	{
		r_prop,
		l_prop
	}

	public BoneType Type;

	public Vector3 LocalSpaceHoldOffsetPos;

	public Quaternion LocalSpaceHoldOffsetRot;

	protected override Type GetIndexedType()
	{
		return typeof(ShieldHeldEntityOffset);
	}
}


public enum BoneType
{
	r_prop,
	l_prop
}


using UnityEngine;

public class ShieldViewmodel : MonoBehaviour, IViewmodelComponent
{
	public Animator TargetAnimator;

	public Transform RightArmBone;
}


using System.Collections.Generic;

public class MiniCrossbow : BaseProjectile
{
	public List<LODGroupRenderers> ArrowRenderers;

	public override bool ForceSendMagazine(SaveInfo saveInfo)
	{
		return true;
	}

	public override void DidAttackServerside()
	{
		base.DidAttackServerside();
		SendNetworkUpdateImmediate();
	}
}


using UnityEngine;

public class MiniCrossbowViewmodel : FacepunchBehaviour, IViewmodelComponent, IAnimationEventReceiver
{
	public Renderer[] ArrowRenderers;

	public Animator TargetAnimator;

	public Transform BarrelJoint;

	public float RotateDuration = 0.6f;

	public AnimationCurve RotateCurve;

	public AnimationCurve RotateCurveReload;
}


using UnityEngine;

public class ViewmodelIgniteToggle : MonoBehaviour
{
	public void Start()
	{
	}
}


using UnityEngine;

public class ToolgunBeam : MonoBehaviour
{
	public LineRenderer electricalBeam;

	public float scrollSpeed = -8f;

	private Color fadeColor = new Color(1f, 1f, 1f, 1f);

	public float fadeSpeed = 4f;

	public void Update()
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		if (fadeColor.a <= 0f)
		{
			Object.Destroy((Object)(object)((Component)this).gameObject);
			return;
		}
		((Renderer)electricalBeam).sharedMaterial.SetTextureOffset("_MainTex", new Vector2(Time.time * scrollSpeed, 0f));
		fadeColor.a -= Time.deltaTime * fadeSpeed;
		electricalBeam.startColor = fadeColor;
		electricalBeam.endColor = fadeColor;
	}
}


using UnityEngine;
using UnityEngine.UI;

public class ToolgunScreen : MonoBehaviour
{
	public Text blockInfoText;

	public Text noBlockText;

	public void SetScreenText(string newText)
	{
		bool flag = string.IsNullOrEmpty(newText);
		((Component)blockInfoText).gameObject.SetActive(!flag);
		((Component)noBlockText).gameObject.SetActive(flag);
		blockInfoText.text = newText;
	}
}


using UnityEngine;

public class AnimalBrain : BaseAIBrain
{
	public class AttackState : BasicAIState
	{
		private IAIAttack attack;

		public AttackState()
			: base(AIState.Attack)
		{
			base.AgrresiveState = true;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			attack = entity as IAIAttack;
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			BasePlayer basePlayer = baseEntity as BasePlayer;
			if ((Object)(object)basePlayer != (Object)null && basePlayer.IsDead())
			{
				StopAttacking();
			}
			else if ((Object)(object)baseEntity != (Object)null && baseEntity.Health() > 0f)
			{
				BaseCombatEntity target = baseEntity as BaseCombatEntity;
				Vector3 aimDirection = GetAimDirection(entity as BaseCombatEntity, target);
				brain.Navigator.SetFacingDirectionOverride(aimDirection);
				if (attack.CanAttack(baseEntity))
				{
					StartAttacking(baseEntity);
				}
				brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
			}
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			brain.Navigator.ClearFacingDirectionOverride();
			brain.Navigator.Stop();
			StopAttacking();
		}

		private void StopAttacking()
		{
			attack.StopAttacking();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_00de: Unknown result type (might be due to invalid IL or missing references)
			//IL_0122: Unknown result type (might be due to invalid IL or missing references)
			//IL_0127: Unknown result type (might be due to invalid IL or missing references)
			//IL_012f: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if (attack == null)
			{
				return StateStatus.Error;
			}
			if ((Object)(object)baseEntity == (Object)null)
			{
				brain.Navigator.ClearFacingDirectionOverride();
				StopAttacking();
				return StateStatus.Finished;
			}
			if (baseEntity.Health() <= 0f)
			{
				StopAttacking();
				return StateStatus.Finished;
			}
			BasePlayer basePlayer = baseEntity as BasePlayer;
			if ((Object)(object)basePlayer != (Object)null && basePlayer.IsDead())
			{
				StopAttacking();
				return StateStatus.Finished;
			}
			BaseVehicle baseVehicle = (((Object)(object)basePlayer != (Object)null) ? basePlayer.GetMountedVehicle() : null);
			if ((Object)(object)baseVehicle != (Object)null && baseVehicle is BaseModularVehicle)
			{
				StopAttacking();
				return StateStatus.Error;
			}
			if (brain.Senses.ignoreSafeZonePlayers && (Object)(object)basePlayer != (Object)null && basePlayer.InSafeZone())
			{
				return StateStatus.Error;
			}
			if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast, 0.25f, (baseEntity is BasePlayer && attack != null) ? attack.EngagementRange() : 0f))
			{
				return StateStatus.Error;
			}
			BaseCombatEntity target = baseEntity as BaseCombatEntity;
			Vector3 aimDirection = GetAimDirection(entity as BaseCombatEntity, target);
			brain.Navigator.SetFacingDirectionOverride(aimDirection);
			if (attack.CanAttack(baseEntity))
			{
				StartAttacking(baseEntity);
			}
			else
			{
				StopAttacking();
			}
			return StateStatus.Running;
		}

		private static Vector3 GetAimDirection(BaseCombatEntity from, BaseCombatEntity target)
		{
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)from == (Object)null || (Object)(object)target == (Object)null)
			{
				if (!((Object)(object)from != (Object)null))
				{
					return Vector3.forward;
				}
				return ((Component)from).transform.forward;
			}
			return Vector3Ex.Direction2D(((Component)target).transform.position, ((Component)from).transform.position);
		}

		private void StartAttacking(BaseEntity entity)
		{
			attack.StartAttacking(entity);
		}
	}

	public class ChaseState : BasicAIState
	{
		private IAIAttack attack;

		public ChaseState()
			: base(AIState.Chase)
		{
			base.AgrresiveState = true;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			attack = entity as IAIAttack;
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity != (Object)null)
			{
				brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
			}
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity == (Object)null)
			{
				Stop();
				return StateStatus.Error;
			}
			if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast, 0.25f, (baseEntity is BasePlayer && attack != null) ? attack.EngagementRange() : 0f))
			{
				return StateStatus.Error;
			}
			if (!brain.Navigator.Moving)
			{
				return StateStatus.Finished;
			}
			return StateStatus.Running;
		}
	}

	public class FleeState : BasicAIState
	{
		private float nextInterval = 2f;

		private float stopFleeDistance;

		public FleeState()
			: base(AIState.Flee)
		{
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity != (Object)null)
			{
				stopFleeDistance = Random.Range(80f, 100f) + Mathf.Clamp(Vector3Ex.Distance2D(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position), 0f, 50f);
			}
			FleeFrom(brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot), entity);
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity == (Object)null)
			{
				return StateStatus.Finished;
			}
			if (Vector3Ex.Distance2D(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position) >= stopFleeDistance)
			{
				return StateStatus.Finished;
			}
			if ((brain.Navigator.UpdateIntervalElapsed(nextInterval) || !brain.Navigator.Moving) && !FleeFrom(baseEntity, entity))
			{
				return StateStatus.Error;
			}
			return StateStatus.Running;
		}

		private bool FleeFrom(BaseEntity fleeFromEntity, BaseEntity thisEntity)
		{
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)thisEntity == (Object)null || (Object)(object)fleeFromEntity == (Object)null)
			{
				return false;
			}
			nextInterval = Random.Range(3f, 6f);
			if (!brain.PathFinder.GetBestFleePosition(brain.Navigator, brain.Senses, fleeFromEntity, brain.Events.Memory.Position.Get(4), 50f, 100f, out var result))
			{
				return false;
			}
			bool num = brain.Navigator.SetDestination(result, BaseNavigator.NavigationSpeed.Fast);
			if (!num)
			{
				Stop();
			}
			return num;
		}
	}

	public class IdleState : BaseIdleState
	{
		private float nextTurnTime;

		private float minTurnTime = 10f;

		private float maxTurnTime = 20f;

		private int turnChance = 33;

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateEnter(brain, entity);
			FaceNewDirection(entity);
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			brain.Navigator.ClearFacingDirectionOverride();
		}

		private void FaceNewDirection(BaseEntity entity)
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			if (Random.Range(0, 100) <= turnChance)
			{
				Vector3 position = ((Component)entity).transform.position;
				Vector3 val = BasePathFinder.GetPointOnCircle(position, 1f, Random.Range(0f, 594f)) - position;
				Vector3 normalized = ((Vector3)(ref val)).normalized;
				brain.Navigator.SetFacingDirectionOverride(normalized);
			}
			nextTurnTime = Time.realtimeSinceStartup + Random.Range(minTurnTime, maxTurnTime);
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			base.StateThink(delta, brain, entity);
			if (Time.realtimeSinceStartup >= nextTurnTime)
			{
				FaceNewDirection(entity);
			}
			return StateStatus.Running;
		}
	}

	public class MoveToPointState : BasicAIState
	{
		private float originalStopDistance;

		public MoveToPointState()
			: base(AIState.MoveToPoint)
		{
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateEnter(brain, entity);
			BaseNavigator navigator = brain.Navigator;
			originalStopDistance = navigator.StoppingDistance;
			navigator.StoppingDistance = 0.5f;
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			brain.Navigator.StoppingDistance = originalStopDistance;
			Stop();
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			Vector3 pos = brain.Events.Memory.Position.Get(6);
			if (!brain.Navigator.SetDestination(pos, ControlTestAnimalSpeed))
			{
				return StateStatus.Error;
			}
			if (!brain.Navigator.Moving)
			{
				return StateStatus.Finished;
			}
			return StateStatus.Running;
		}
	}

	public class MoveTowardsState : BaseMoveTorwardsState
	{
	}

	public class RoamState : BasicAIState
	{
		private StateStatus status = StateStatus.Error;

		public RoamState()
			: base(AIState.Roam)
		{
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			status = StateStatus.Error;
			if (brain.PathFinder == null)
			{
				return;
			}
			Vector3 center;
			if (brain.InGroup() && !brain.IsGroupLeader)
			{
				center = brain.Events.Memory.Position.Get(5);
				center = BasePathFinder.GetPointOnCircle(center, Random.Range(2f, 7f), Random.Range(0f, 359f));
			}
			else
			{
				center = brain.PathFinder.GetBestRoamPosition(brain.Navigator, GetRoamAnchorPosition(), brain.Events.Memory.Position.Get(4), GetRoamPointMinDistance(), GetRoamPointMaxDistance());
			}
			if (brain.Navigator.SetDestination(center, BaseNavigator.NavigationSpeed.Slow))
			{
				if (brain.InGroup() && brain.IsGroupLeader)
				{
					brain.SetGroupRoamRootPosition(center);
				}
				status = StateStatus.Running;
			}
			else
			{
				status = StateStatus.Error;
			}
		}

		public virtual Vector3 GetRoamAnchorPosition()
		{
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			if (brain.Navigator.MaxRoamDistanceFromHome > -1f)
			{
				return brain.Events.Memory.Position.Get(4);
			}
			return ((Component)brain.Navigator).transform.position;
		}

		public virtual float GetRoamPointMinDistance()
		{
			if (brain.Navigator.MaxRoamDistanceFromHome > -1f)
			{
				return 5f;
			}
			return 20f;
		}

		public virtual float GetRoamPointMaxDistance()
		{
			if (brain.Navigator.MaxRoamDistanceFromHome > -1f)
			{
				return brain.Navigator.MaxRoamDistanceFromHome;
			}
			return brain.Navigator.BestRoamPointMaxDistance;
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			base.StateThink(delta, brain, entity);
			if (status == StateStatus.Error)
			{
				return status;
			}
			if (brain.Navigator.Moving)
			{
				return StateStatus.Running;
			}
			return StateStatus.Finished;
		}
	}

	public static int Count;

	public static BaseNavigator.NavigationSpeed ControlTestAnimalSpeed = BaseNavigator.NavigationSpeed.Fast;

	public override void AddStates()
	{
		base.AddStates();
		AddState(new IdleState());
		AddState(new MoveTowardsState());
		AddState(new FleeState());
		AddState(new RoamState());
		AddState(new AttackState());
		AddState(new BaseSleepState());
		AddState(new ChaseState());
		AddState(new BaseCooldownState());
		AddState(new MoveToPointState());
	}

	public override void InitializeAI()
	{
		base.InitializeAI();
		base.ThinkMode = AIThinkMode.Interval;
		thinkRate = 0.25f;
		base.PathFinder = new BasePathFinder();
		Count++;
	}

	public override void OnDestroy()
	{
		base.OnDestroy();
		Count--;
	}

	public BaseAnimalNPC GetEntity()
	{
		return GetBaseEntity() as BaseAnimalNPC;
	}
}


using UnityEngine;

public class AttackState : BasicAIState
{
	private IAIAttack attack;

	public AttackState()
		: base(AIState.Attack)
	{
		base.AgrresiveState = true;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		attack = entity as IAIAttack;
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		BasePlayer basePlayer = baseEntity as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null && basePlayer.IsDead())
		{
			StopAttacking();
		}
		else if ((Object)(object)baseEntity != (Object)null && baseEntity.Health() > 0f)
		{
			BaseCombatEntity target = baseEntity as BaseCombatEntity;
			Vector3 aimDirection = GetAimDirection(entity as BaseCombatEntity, target);
			brain.Navigator.SetFacingDirectionOverride(aimDirection);
			if (attack.CanAttack(baseEntity))
			{
				StartAttacking(baseEntity);
			}
			brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
		}
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		brain.Navigator.ClearFacingDirectionOverride();
		brain.Navigator.Stop();
		StopAttacking();
	}

	private void StopAttacking()
	{
		attack.StopAttacking();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if (attack == null)
		{
			return StateStatus.Error;
		}
		if ((Object)(object)baseEntity == (Object)null)
		{
			brain.Navigator.ClearFacingDirectionOverride();
			StopAttacking();
			return StateStatus.Finished;
		}
		if (baseEntity.Health() <= 0f)
		{
			StopAttacking();
			return StateStatus.Finished;
		}
		BasePlayer basePlayer = baseEntity as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null && basePlayer.IsDead())
		{
			StopAttacking();
			return StateStatus.Finished;
		}
		BaseVehicle baseVehicle = (((Object)(object)basePlayer != (Object)null) ? basePlayer.GetMountedVehicle() : null);
		if ((Object)(object)baseVehicle != (Object)null && baseVehicle is BaseModularVehicle)
		{
			StopAttacking();
			return StateStatus.Error;
		}
		if (brain.Senses.ignoreSafeZonePlayers && (Object)(object)basePlayer != (Object)null && basePlayer.InSafeZone())
		{
			return StateStatus.Error;
		}
		if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast, 0.25f, (baseEntity is BasePlayer && attack != null) ? attack.EngagementRange() : 0f))
		{
			return StateStatus.Error;
		}
		BaseCombatEntity target = baseEntity as BaseCombatEntity;
		Vector3 aimDirection = GetAimDirection(entity as BaseCombatEntity, target);
		brain.Navigator.SetFacingDirectionOverride(aimDirection);
		if (attack.CanAttack(baseEntity))
		{
			StartAttacking(baseEntity);
		}
		else
		{
			StopAttacking();
		}
		return StateStatus.Running;
	}

	private static Vector3 GetAimDirection(BaseCombatEntity from, BaseCombatEntity target)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)from == (Object)null || (Object)(object)target == (Object)null)
		{
			if (!((Object)(object)from != (Object)null))
			{
				return Vector3.forward;
			}
			return ((Component)from).transform.forward;
		}
		return Vector3Ex.Direction2D(((Component)target).transform.position, ((Component)from).transform.position);
	}

	private void StartAttacking(BaseEntity entity)
	{
		attack.StartAttacking(entity);
	}
}


using UnityEngine;

public class ChaseState : BasicAIState
{
	private IAIAttack attack;

	public ChaseState()
		: base(AIState.Chase)
	{
		base.AgrresiveState = true;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		attack = entity as IAIAttack;
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity != (Object)null)
		{
			brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
		}
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			Stop();
			return StateStatus.Error;
		}
		if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast, 0.25f, (baseEntity is BasePlayer && attack != null) ? attack.EngagementRange() : 0f))
		{
			return StateStatus.Error;
		}
		if (!brain.Navigator.Moving)
		{
			return StateStatus.Finished;
		}
		return StateStatus.Running;
	}
}


using UnityEngine;

public class FleeState : BasicAIState
{
	private float nextInterval = 2f;

	private float stopFleeDistance;

	public FleeState()
		: base(AIState.Flee)
	{
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity != (Object)null)
		{
			stopFleeDistance = Random.Range(80f, 100f) + Mathf.Clamp(Vector3Ex.Distance2D(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position), 0f, 50f);
		}
		FleeFrom(brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot), entity);
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			return StateStatus.Finished;
		}
		if (Vector3Ex.Distance2D(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position) >= stopFleeDistance)
		{
			return StateStatus.Finished;
		}
		if ((brain.Navigator.UpdateIntervalElapsed(nextInterval) || !brain.Navigator.Moving) && !FleeFrom(baseEntity, entity))
		{
			return StateStatus.Error;
		}
		return StateStatus.Running;
	}

	private bool FleeFrom(BaseEntity fleeFromEntity, BaseEntity thisEntity)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)thisEntity == (Object)null || (Object)(object)fleeFromEntity == (Object)null)
		{
			return false;
		}
		nextInterval = Random.Range(3f, 6f);
		if (!brain.PathFinder.GetBestFleePosition(brain.Navigator, brain.Senses, fleeFromEntity, brain.Events.Memory.Position.Get(4), 50f, 100f, out var result))
		{
			return false;
		}
		bool num = brain.Navigator.SetDestination(result, BaseNavigator.NavigationSpeed.Fast);
		if (!num)
		{
			Stop();
		}
		return num;
	}
}


using UnityEngine;

public class IdleState : BaseIdleState
{
	private float nextTurnTime;

	private float minTurnTime = 10f;

	private float maxTurnTime = 20f;

	private int turnChance = 33;

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateEnter(brain, entity);
		FaceNewDirection(entity);
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		brain.Navigator.ClearFacingDirectionOverride();
	}

	private void FaceNewDirection(BaseEntity entity)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (Random.Range(0, 100) <= turnChance)
		{
			Vector3 position = ((Component)entity).transform.position;
			Vector3 val = BasePathFinder.GetPointOnCircle(position, 1f, Random.Range(0f, 594f)) - position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			brain.Navigator.SetFacingDirectionOverride(normalized);
		}
		nextTurnTime = Time.realtimeSinceStartup + Random.Range(minTurnTime, maxTurnTime);
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		if (Time.realtimeSinceStartup >= nextTurnTime)
		{
			FaceNewDirection(entity);
		}
		return StateStatus.Running;
	}
}


using UnityEngine;

public class MoveToPointState : BasicAIState
{
	private float originalStopDistance;

	public MoveToPointState()
		: base(AIState.MoveToPoint)
	{
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateEnter(brain, entity);
		BaseNavigator navigator = brain.Navigator;
		originalStopDistance = navigator.StoppingDistance;
		navigator.StoppingDistance = 0.5f;
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		brain.Navigator.StoppingDistance = originalStopDistance;
		Stop();
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		Vector3 pos = brain.Events.Memory.Position.Get(6);
		if (!brain.Navigator.SetDestination(pos, ControlTestAnimalSpeed))
		{
			return StateStatus.Error;
		}
		if (!brain.Navigator.Moving)
		{
			return StateStatus.Finished;
		}
		return StateStatus.Running;
	}
}


public class MoveTowardsState : BaseMoveTorwardsState
{
}


using UnityEngine;

public class RoamState : BasicAIState
{
	private StateStatus status = StateStatus.Error;

	public RoamState()
		: base(AIState.Roam)
	{
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		status = StateStatus.Error;
		if (brain.PathFinder == null)
		{
			return;
		}
		Vector3 center;
		if (brain.InGroup() && !brain.IsGroupLeader)
		{
			center = brain.Events.Memory.Position.Get(5);
			center = BasePathFinder.GetPointOnCircle(center, Random.Range(2f, 7f), Random.Range(0f, 359f));
		}
		else
		{
			center = brain.PathFinder.GetBestRoamPosition(brain.Navigator, GetRoamAnchorPosition(), brain.Events.Memory.Position.Get(4), GetRoamPointMinDistance(), GetRoamPointMaxDistance());
		}
		if (brain.Navigator.SetDestination(center, BaseNavigator.NavigationSpeed.Slow))
		{
			if (brain.InGroup() && brain.IsGroupLeader)
			{
				brain.SetGroupRoamRootPosition(center);
			}
			status = StateStatus.Running;
		}
		else
		{
			status = StateStatus.Error;
		}
	}

	public virtual Vector3 GetRoamAnchorPosition()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if (brain.Navigator.MaxRoamDistanceFromHome > -1f)
		{
			return brain.Events.Memory.Position.Get(4);
		}
		return ((Component)brain.Navigator).transform.position;
	}

	public virtual float GetRoamPointMinDistance()
	{
		if (brain.Navigator.MaxRoamDistanceFromHome > -1f)
		{
			return 5f;
		}
		return 20f;
	}

	public virtual float GetRoamPointMaxDistance()
	{
		if (brain.Navigator.MaxRoamDistanceFromHome > -1f)
		{
			return brain.Navigator.MaxRoamDistanceFromHome;
		}
		return brain.Navigator.BestRoamPointMaxDistance;
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		if (status == StateStatus.Error)
		{
			return status;
		}
		if (brain.Navigator.Moving)
		{
			return StateStatus.Running;
		}
		return StateStatus.Finished;
	}
}


public class Bear : BaseAnimalNPC
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 2f;

	public override float RealisticMass => 150f;

	public override TraitFlag Traits => TraitFlag.Alive | TraitFlag.Animal | TraitFlag.Food | TraitFlag.Meat;

	public override bool WantsToEat(BaseEntity best)
	{
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		return base.WantsToEat(best);
	}

	public override string Categorize()
	{
		return "Bear";
	}
}


public class Polarbear : BaseAnimalNPC
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 1f;

	public override float RealisticMass => 150f;

	public override TraitFlag Traits => TraitFlag.Alive | TraitFlag.Animal | TraitFlag.Food | TraitFlag.Meat;

	public override bool WantsToEat(BaseEntity best)
	{
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		return base.WantsToEat(best);
	}

	public override string Categorize()
	{
		return "Polarbear";
	}
}


using UnityEngine;

public class Boar : BaseAnimalNPC
{
	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 5f;

	public override float RealisticMass => 85f;

	public override TraitFlag Traits => TraitFlag.Alive | TraitFlag.Animal | TraitFlag.Food | TraitFlag.Meat;

	public override bool WantsToEat(BaseEntity best)
	{
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		if (best.HasTrait(TraitFlag.Meat))
		{
			return false;
		}
		CollectibleEntity collectibleEntity = best as CollectibleEntity;
		if ((Object)(object)collectibleEntity != (Object)null)
		{
			ItemAmount[] itemList = collectibleEntity.itemList;
			for (int i = 0; i < itemList.Length; i++)
			{
				if (itemList[i].itemDef.category == ItemCategory.Food)
				{
					return true;
				}
			}
		}
		return base.WantsToEat(best);
	}

	public override string Categorize()
	{
		return "Boar";
	}
}


using System;
using UnityEngine;

public class Chicken : BaseAnimalNPC
{
	public class EggDropWorkQueue : ObjectWorkQueue<Chicken>
	{
		protected override void RunJob(Chicken entity)
		{
			if (((ObjectWorkQueue<Chicken>)this).ShouldAdd(entity))
			{
				entity.CheckEggDrop();
			}
		}

		protected override bool ShouldAdd(Chicken entity)
		{
			if (base.ShouldAdd(entity))
			{
				return entity.IsValid();
			}
			return false;
		}
	}

	[ServerVar(Help = "Population active on the server, per square km", ShowInAdminUI = true)]
	public static float Population = 3f;

	public ItemDefinition EggDefinition;

	public float EggDropFrequency = 30f;

	public Vector3 EggDropLocalPos;

	public static EggDropWorkQueue EggWorkQueue = new EggDropWorkQueue();

	public override float RealisticMass => 3f;

	public override TraitFlag Traits => TraitFlag.Alive | TraitFlag.Animal | TraitFlag.Food | TraitFlag.Meat;

	public override void ServerInit()
	{
		base.ServerInit();
		if ((Object)(object)EggDefinition != (Object)null)
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)QueueEggDropCheck, EggDropFrequency, EggDropFrequency, EggDropFrequency * 0.5f);
		}
	}

	private void QueueEggDropCheck()
	{
		((ObjectWorkQueue<Chicken>)EggWorkQueue).Add(this);
	}

	public override bool WantsToEat(BaseEntity best)
	{
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		if (best.HasTrait(TraitFlag.Meat))
		{
			return false;
		}
		CollectibleEntity collectibleEntity = best as CollectibleEntity;
		if ((Object)(object)collectibleEntity != (Object)null)
		{
			ItemAmount[] itemList = collectibleEntity.itemList;
			for (int i = 0; i < itemList.Length; i++)
			{
				if (itemList[i].itemDef.category == ItemCategory.Food)
				{
					return true;
				}
			}
		}
		return base.WantsToEat(best);
	}

	private void CheckEggDrop()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer && Random.Range(0, 100) > 50 && (Object)(object)((Component)this).transform != (Object)null && BaseNetworkable.HasCloseConnections(((Component)this).transform.position, 100f))
		{
			SpawnEgg();
		}
	}

	public void SpawnEgg()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)EggDefinition != (Object)null)
		{
			ItemManager.Create(EggDefinition, 1, 0uL).Drop(((Component)this).transform.TransformPoint(EggDropLocalPos), -((Component)this).transform.forward);
		}
	}

	public override string Categorize()
	{
		return "Chicken";
	}
}


public class EggDropWorkQueue : ObjectWorkQueue<Chicken>
{
	protected override void RunJob(Chicken entity)
	{
		if (((ObjectWorkQueue<Chicken>)this).ShouldAdd(entity))
		{
			entity.CheckEggDrop();
		}
	}

	protected override bool ShouldAdd(Chicken entity)
	{
		if (base.ShouldAdd(entity))
		{
			return entity.IsValid();
		}
		return false;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class FishBrain : BaseAIBrain
{
	public class IdleState : BaseIdleState
	{
		private StateStatus status = StateStatus.Error;

		private List<Vector3> idlePoints;

		private int currentPointIndex;

		private Vector3 idleRootPos;

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			idleRootPos = ((Component)brain.Navigator).transform.position;
			GenerateIdlePoints(20f, 0f);
			currentPointIndex = 0;
			status = StateStatus.Error;
			if (brain.PathFinder != null)
			{
				if (brain.Navigator.SetDestination(idleRootPos + idlePoints[0], BaseNavigator.NavigationSpeed.Normal))
				{
					status = StateStatus.Running;
				}
				else
				{
					status = StateStatus.Error;
				}
			}
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			if (Vector3.Distance(((Component)brain.Navigator).transform.position, idleRootPos + idlePoints[currentPointIndex]) < 4f)
			{
				currentPointIndex++;
			}
			if (currentPointIndex >= idlePoints.Count)
			{
				currentPointIndex = 0;
			}
			if (brain.Navigator.SetDestination(idleRootPos + idlePoints[currentPointIndex], BaseNavigator.NavigationSpeed.Normal))
			{
				status = StateStatus.Running;
			}
			else
			{
				status = StateStatus.Error;
			}
			return status;
		}

		private void GenerateIdlePoints(float radius, float heightOffset)
		{
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			if (idlePoints == null)
			{
				idlePoints = new List<Vector3>();
				float num = 0f;
				int num2 = 32;
				(float, float) waterAndTerrainSurface = WaterLevel.GetWaterAndTerrainSurface(((Component)brain.Navigator).transform.position, waves: false, volumes: false);
				float item = waterAndTerrainSurface.Item1;
				float item2 = waterAndTerrainSurface.Item2;
				for (int i = 0; i < num2; i++)
				{
					num += 360f / (float)num2;
					Vector3 pointOnCircle = BasePathFinder.GetPointOnCircle(Vector3.zero, radius, num);
					pointOnCircle.y += Random.Range(0f - heightOffset, heightOffset);
					pointOnCircle.y = Mathf.Clamp(pointOnCircle.y, item2, item);
					idlePoints.Add(pointOnCircle);
				}
			}
		}
	}

	public class RoamState : BasicAIState
	{
		private StateStatus status = StateStatus.Error;

		public RoamState()
			: base(AIState.Roam)
		{
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			status = StateStatus.Error;
			if (brain.PathFinder != null)
			{
				Vector3 fallbackPos = brain.Events.Memory.Position.Get(4);
				Vector3 bestRoamPosition = brain.PathFinder.GetBestRoamPosition(brain.Navigator, ((Component)brain.Navigator).transform.position, fallbackPos, 5f, brain.Navigator.MaxRoamDistanceFromHome);
				if (brain.Navigator.SetDestination(bestRoamPosition, BaseNavigator.NavigationSpeed.Normal))
				{
					status = StateStatus.Running;
				}
				else
				{
					status = StateStatus.Error;
				}
			}
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			base.StateThink(delta, brain, entity);
			if (status == StateStatus.Error)
			{
				return status;
			}
			if (brain.Navigator.Moving)
			{
				return StateStatus.Running;
			}
			return StateStatus.Finished;
		}
	}

	public static int Count;

	public override void AddStates()
	{
		base.AddStates();
		AddState(new IdleState());
		AddState(new RoamState());
		AddState(new BaseFleeState());
		AddState(new BaseChaseState());
		AddState(new BaseMoveTorwardsState());
		AddState(new BaseAttackState());
		AddState(new BaseCooldownState());
	}

	public override void InitializeAI()
	{
		base.InitializeAI();
		base.ThinkMode = AIThinkMode.Interval;
		thinkRate = 0.25f;
		base.PathFinder = new UnderwaterPathFinder();
		((UnderwaterPathFinder)base.PathFinder).Init(GetBaseEntity());
		Count++;
	}

	public override void OnDestroy()
	{
		base.OnDestroy();
		Count--;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class IdleState : BaseIdleState
{
	private StateStatus status = StateStatus.Error;

	private List<Vector3> idlePoints;

	private int currentPointIndex;

	private Vector3 idleRootPos;

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		idleRootPos = ((Component)brain.Navigator).transform.position;
		GenerateIdlePoints(20f, 0f);
		currentPointIndex = 0;
		status = StateStatus.Error;
		if (brain.PathFinder != null)
		{
			if (brain.Navigator.SetDestination(idleRootPos + idlePoints[0], BaseNavigator.NavigationSpeed.Normal))
			{
				status = StateStatus.Running;
			}
			else
			{
				status = StateStatus.Error;
			}
		}
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		if (Vector3.Distance(((Component)brain.Navigator).transform.position, idleRootPos + idlePoints[currentPointIndex]) < 4f)
		{
			currentPointIndex++;
		}
		if (currentPointIndex >= idlePoints.Count)
		{
			currentPointIndex = 0;
		}
		if (brain.Navigator.SetDestination(idleRootPos + idlePoints[currentPointIndex], BaseNavigator.NavigationSpeed.Normal))
		{
			status = StateStatus.Running;
		}
		else
		{
			status = StateStatus.Error;
		}
		return status;
	}

	private void GenerateIdlePoints(float radius, float heightOffset)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		if (idlePoints == null)
		{
			idlePoints = new List<Vector3>();
			float num = 0f;
			int num2 = 32;
			(float, float) waterAndTerrainSurface = WaterLevel.GetWaterAndTerrainSurface(((Component)brain.Navigator).transform.position, waves: false, volumes: false);
			float item = waterAndTerrainSurface.Item1;
			float item2 = waterAndTerrainSurface.Item2;
			for (int i = 0; i < num2; i++)
			{
				num += 360f / (float)num2;
				Vector3 pointOnCircle = BasePathFinder.GetPointOnCircle(Vector3.zero, radius, num);
				pointOnCircle.y += Random.Range(0f - heightOffset, heightOffset);
				pointOnCircle.y = Mathf.Clamp(pointOnCircle.y, item2, item);
				idlePoints.Add(pointOnCircle);
			}
		}
	}
}


using UnityEngine;

public class RoamState : BasicAIState
{
	private StateStatus status = StateStatus.Error;

	public RoamState()
		: base(AIState.Roam)
	{
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		status = StateStatus.Error;
		if (brain.PathFinder != null)
		{
			Vector3 fallbackPos = brain.Events.Memory.Position.Get(4);
			Vector3 bestRoamPosition = brain.PathFinder.GetBestRoamPosition(brain.Navigator, ((Component)brain.Navigator).transform.position, fallbackPos, 5f, brain.Navigator.MaxRoamDistanceFromHome);
			if (brain.Navigator.SetDestination(bestRoamPosition, BaseNavigator.NavigationSpeed.Normal))
			{
				status = StateStatus.Running;
			}
			else
			{
				status = StateStatus.Error;
			}
		}
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		if (status == StateStatus.Error)
		{
			return status;
		}
		if (brain.Navigator.Moving)
		{
			return StateStatus.Running;
		}
		return StateStatus.Finished;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Rust;
using Rust.Ai;
using UnityEngine;

public class SimpleShark : BaseCombatEntity
{
	public class SimpleState
	{
		public SimpleShark entity;

		private float stateEnterTime;

		public SimpleState(SimpleShark owner)
		{
			entity = owner;
		}

		public virtual float State_Weight()
		{
			return 0f;
		}

		public virtual void State_Enter()
		{
			stateEnterTime = Time.realtimeSinceStartup;
		}

		public virtual void State_Think(float delta)
		{
		}

		public virtual void State_Exit()
		{
		}

		public virtual bool CanInterrupt()
		{
			return true;
		}

		public virtual float TimeInState()
		{
			return Time.realtimeSinceStartup - stateEnterTime;
		}
	}

	public class IdleState : SimpleState
	{
		private int patrolTargetIndex;

		public IdleState(SimpleShark owner)
			: base(owner)
		{
		}

		public Vector3 GetTargetPatrolPosition()
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			return entity.patrolPath[patrolTargetIndex];
		}

		public override float State_Weight()
		{
			return 1f;
		}

		public override void State_Enter()
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			float num = float.PositiveInfinity;
			int num2 = 0;
			for (int i = 0; i < entity.patrolPath.Count; i++)
			{
				float num3 = Vector3.Distance(entity.patrolPath[i], ((Component)entity).transform.position);
				if (num3 < num)
				{
					num2 = i;
					num = num3;
				}
			}
			patrolTargetIndex = num2;
			base.State_Enter();
		}

		public override void State_Think(float delta)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			if (Vector3.Distance(GetTargetPatrolPosition(), ((Component)entity).transform.position) < entity.stoppingDistance)
			{
				patrolTargetIndex++;
				if (patrolTargetIndex >= entity.patrolPath.Count)
				{
					patrolTargetIndex = 0;
				}
			}
			if (entity.TimeSinceAttacked() >= 120f && entity.healthFraction < 1f)
			{
				entity.health = entity.MaxHealth();
			}
			entity.destination = entity.WaterClamp(GetTargetPatrolPosition());
		}

		public override void State_Exit()
		{
			base.State_Exit();
		}

		public override bool CanInterrupt()
		{
			return true;
		}
	}

	public class AttackState : SimpleState
	{
		public AttackState(SimpleShark owner)
			: base(owner)
		{
		}

		public override float State_Weight()
		{
			if (!entity.HasTarget() || !entity.CanAttack())
			{
				return 0f;
			}
			return 10f;
		}

		public override void State_Enter()
		{
			base.State_Enter();
		}

		public override void State_Think(float delta)
		{
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_0105: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			BasePlayer target = entity.GetTarget();
			if ((Object)(object)target == (Object)null)
			{
				return;
			}
			if (TimeInState() >= 10f)
			{
				entity.nextAttackTime = Time.realtimeSinceStartup + 4f;
				entity.Startle();
				return;
			}
			if (entity.CanAttack())
			{
				entity.Startle();
			}
			float num = Vector3.Distance(entity.GetTarget().eyes.position, ((Component)entity).transform.position);
			bool num2 = num < 4f;
			if (entity.CanAttack() && num <= 2f)
			{
				entity.DoAttack();
			}
			if (!num2)
			{
				Vector3 val = Vector3Ex.Direction(entity.GetTarget().eyes.position, ((Component)entity).transform.position);
				Vector3 point = target.eyes.position + val * 10f;
				point = entity.WaterClamp(point);
				entity.destination = point;
			}
		}

		public override void State_Exit()
		{
			base.State_Exit();
		}

		public override bool CanInterrupt()
		{
			return true;
		}
	}

	public Vector3 destination;

	public float minSpeed;

	public float maxSpeed;

	public float idealDepth;

	public float minTurnSpeed = 0.25f;

	public float maxTurnSpeed = 2f;

	public float attackCooldown = 7f;

	public float aggroRange = 15f;

	public float obstacleDetectionRadius = 1f;

	public Animator animator;

	public GameObjectRef bloodCloud;

	public GameObjectRef corpsePrefab;

	private const string SPEARGUN_KILL_STAT = "shark_speargun_kills";

	[ServerVar]
	public static float forceSurfaceAmount = 0f;

	[ServerVar]
	public static bool disable = false;

	private Vector3 spawnPos;

	private float stoppingDistance = 3f;

	private float currentSpeed;

	private float lastStartleTime;

	private float startleDuration = 1f;

	private SimpleState[] states;

	private SimpleState _currentState;

	private bool sleeping;

	private List<Vector3> patrolPath = new List<Vector3>();

	private BasePlayer target;

	private float lastSeenTargetTime;

	private float nextTargetSearchTime;

	private static BasePlayer[] playerQueryResults = new BasePlayer[64];

	private float minFloorDist = 2f;

	private float minSurfaceDist = 1f;

	private float lastTimeAttacked;

	public float nextAttackTime;

	private Vector3 cachedObstacleNormal;

	private float cachedObstacleDistance;

	private float obstacleAvoidanceScale;

	private float obstacleDetectionRange = 5f;

	private float timeSinceLastObstacleCheck;

	public override bool IsNpc => true;

	private void GenerateIdlePoints(Vector3 center, float radius, float heightOffset, float staggerOffset = 0f)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		patrolPath.Clear();
		float num = 0f;
		int num2 = 32;
		int num3 = 10551553;
		(float, float) waterAndTerrainSurface = WaterLevel.GetWaterAndTerrainSurface(center, waves: false, volumes: false);
		float item = waterAndTerrainSurface.Item1;
		float item2 = waterAndTerrainSurface.Item2;
		RaycastHit val2 = default(RaycastHit);
		for (int i = 0; i < num2; i++)
		{
			num += 360f / (float)num2;
			float radius2 = 1f;
			Vector3 pointOnCircle = BasePathFinder.GetPointOnCircle(center, radius2, num);
			Vector3 val = Vector3Ex.Direction(pointOnCircle, center);
			pointOnCircle = ((!Physics.SphereCast(center, obstacleDetectionRadius, val, ref val2, radius + staggerOffset, num3)) ? (center + val * radius) : (center + val * (((RaycastHit)(ref val2)).distance - 6f)));
			if (staggerOffset != 0f)
			{
				pointOnCircle += val * Random.Range(0f - staggerOffset, staggerOffset);
			}
			pointOnCircle.y += Random.Range(0f - heightOffset, heightOffset);
			pointOnCircle.y = Mathf.Clamp(pointOnCircle.y, item2 + 3f, item - 3f);
			patrolPath.Add(pointOnCircle);
		}
	}

	private void GenerateIdlePoints_Shrinkwrap(Vector3 center, float radius, float heightOffset, float staggerOffset = 0f)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		patrolPath.Clear();
		float num = 0f;
		int num2 = 32;
		int num3 = 10551553;
		(float, float) waterAndTerrainSurface = WaterLevel.GetWaterAndTerrainSurface(center, waves: false, volumes: false);
		float item = waterAndTerrainSurface.Item1;
		float item2 = waterAndTerrainSurface.Item2;
		RaycastHit val2 = default(RaycastHit);
		for (int i = 0; i < num2; i++)
		{
			num += 360f / (float)num2;
			float radius2 = radius * 2f;
			Vector3 pointOnCircle = BasePathFinder.GetPointOnCircle(center, radius2, num);
			Vector3 val = Vector3Ex.Direction(center, pointOnCircle);
			pointOnCircle = ((!Physics.SphereCast(pointOnCircle, obstacleDetectionRadius, val, ref val2, radius + staggerOffset, num3)) ? (pointOnCircle + val * radius) : (((RaycastHit)(ref val2)).point - val * 6f));
			if (staggerOffset != 0f)
			{
				pointOnCircle += val * Random.Range(0f - staggerOffset, staggerOffset);
			}
			pointOnCircle.y += Random.Range(0f - heightOffset, heightOffset);
			pointOnCircle.y = Mathf.Clamp(pointOnCircle.y, item2 + 3f, item - 3f);
			patrolPath.Add(pointOnCircle);
		}
	}

	public override void ServerInit()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (disable)
		{
			((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0.01f);
			return;
		}
		((Component)this).transform.position = WaterClamp(((Component)this).transform.position);
		Init();
		((FacepunchBehaviour)this).InvokeRandomized((Action)CheckSleepState, 0f, 1f, 0.5f);
	}

	public void CheckSleepState()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		bool flag = BaseNetworkable.HasCloseConnections(((Component)this).transform.position, 100f);
		sleeping = !flag;
	}

	public void Init()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		GenerateIdlePoints_Shrinkwrap(((Component)this).transform.position, 20f, 2f, 3f);
		states = new SimpleState[2];
		states[0] = new IdleState(this);
		states[1] = new AttackState(this);
		((Component)this).transform.position = patrolPath[0];
	}

	private void Think(float delta)
	{
		if (states == null)
		{
			return;
		}
		if (disable)
		{
			if (!((FacepunchBehaviour)this).IsInvoking((Action)base.KillMessage))
			{
				((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0.01f);
			}
		}
		else
		{
			if (sleeping)
			{
				return;
			}
			SimpleState simpleState = null;
			float num = -1f;
			SimpleState[] array = states;
			foreach (SimpleState simpleState2 in array)
			{
				float num2 = simpleState2.State_Weight();
				if (num2 > num)
				{
					simpleState = simpleState2;
					num = num2;
				}
			}
			if (simpleState != _currentState && (_currentState == null || _currentState.CanInterrupt()))
			{
				if (_currentState != null)
				{
					_currentState.State_Exit();
				}
				simpleState.State_Enter();
				_currentState = simpleState;
			}
			UpdateTarget(delta);
			_currentState.State_Think(delta);
			UpdateObstacleAvoidance(delta);
			UpdateDirection(delta);
			UpdateSpeed(delta);
			UpdatePosition(delta);
			SetFlag(Flags.Open, HasTarget() && CanAttack());
		}
	}

	public Vector3 WaterClamp(Vector3 point)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		(float, float) waterAndTerrainSurface = WaterLevel.GetWaterAndTerrainSurface(point, waves: false, volumes: false);
		float item = waterAndTerrainSurface.Item1;
		float num = waterAndTerrainSurface.Item2 + minFloorDist;
		float num2 = item - minSurfaceDist;
		if (forceSurfaceAmount != 0f)
		{
			item = WaterLevel.GetWaterSurface(point, waves: false, volumes: false);
			num = (num2 = item + forceSurfaceAmount);
		}
		point.y = Mathf.Clamp(point.y, num, num2);
		return point;
	}

	public bool ValidTarget(BasePlayer newTarget)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		if (AI.ignoreplayers || SimpleAIMemory.PlayerIgnoreList.Contains(newTarget))
		{
			return false;
		}
		float num = Vector3.Distance(newTarget.eyes.position, ((Component)this).transform.position);
		Vector3 val = Vector3Ex.Direction(newTarget.eyes.position, ((Component)this).transform.position);
		int num2 = 10551552;
		if (Physics.Raycast(((Component)this).transform.position, val, num, num2))
		{
			return false;
		}
		if (newTarget.isMounted)
		{
			if (Object.op_Implicit((Object)(object)newTarget.GetMountedVehicle()))
			{
				return false;
			}
			WaterInflatable component = ((Component)newTarget.GetMounted()).GetComponent<WaterInflatable>();
			if ((Object)(object)component != (Object)null && !((Behaviour)component.buoyancy).enabled)
			{
				return false;
			}
		}
		else if (!WaterLevel.Test(newTarget.CenterPoint(), waves: true, volumes: false, newTarget))
		{
			return false;
		}
		return true;
	}

	public void ClearTarget()
	{
		target = null;
		lastSeenTargetTime = 0f;
	}

	public override void OnDied(HitInfo hitInfo = null)
	{
		if (base.isServer)
		{
			if (GameInfo.HasAchievements && hitInfo != null && (Object)(object)hitInfo.InitiatorPlayer != (Object)null && !hitInfo.InitiatorPlayer.IsNpc && (Object)(object)hitInfo.Weapon != (Object)null && hitInfo.Weapon.ShortPrefabName.Contains("speargun"))
			{
				hitInfo.InitiatorPlayer.stats.Add("shark_speargun_kills", 1, Stats.All);
				hitInfo.InitiatorPlayer.stats.Save(forceSteamSave: true);
			}
			BaseCorpse baseCorpse = DropCorpse(corpsePrefab.resourcePath);
			if (Object.op_Implicit((Object)(object)baseCorpse))
			{
				baseCorpse.Spawn();
				baseCorpse.TakeChildren(this);
			}
			((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0.5f);
		}
		base.OnDied(hitInfo);
	}

	public void UpdateTarget(float delta)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)target != (Object)null)
		{
			bool flag = Vector3.Distance(target.eyes.position, ((Component)this).transform.position) > aggroRange * 2f;
			bool flag2 = Time.realtimeSinceStartup > lastSeenTargetTime + 4f;
			if (!ValidTarget(target) || flag || flag2)
			{
				ClearTarget();
			}
			else
			{
				lastSeenTargetTime = Time.realtimeSinceStartup;
			}
		}
		if (Time.realtimeSinceStartup < nextTargetSearchTime || !((Object)(object)target == (Object)null))
		{
			return;
		}
		nextTargetSearchTime = Time.realtimeSinceStartup + 1f;
		if (!BaseNetworkable.HasCloseConnections(((Component)this).transform.position, aggroRange))
		{
			return;
		}
		int playersInSphereFast = Query.Server.GetPlayersInSphereFast(((Component)this).transform.position, aggroRange, playerQueryResults);
		for (int i = 0; i < playersInSphereFast; i++)
		{
			BasePlayer basePlayer = playerQueryResults[i];
			if (!basePlayer.isClient && ValidTarget(basePlayer))
			{
				target = basePlayer;
				lastSeenTargetTime = Time.realtimeSinceStartup;
				break;
			}
		}
	}

	public float TimeSinceAttacked()
	{
		return Time.realtimeSinceStartup - lastTimeAttacked;
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		lastTimeAttacked = Time.realtimeSinceStartup;
		if (info.damageTypes.Total() > 20f)
		{
			Startle();
		}
		if ((Object)(object)info.InitiatorPlayer != (Object)null && (Object)(object)target == (Object)null && ValidTarget(info.InitiatorPlayer))
		{
			target = info.InitiatorPlayer;
			lastSeenTargetTime = Time.realtimeSinceStartup;
		}
	}

	public bool HasTarget()
	{
		return (Object)(object)target != (Object)null;
	}

	public BasePlayer GetTarget()
	{
		return target;
	}

	public override string Categorize()
	{
		return "Shark";
	}

	public bool CanAttack()
	{
		return Time.realtimeSinceStartup > nextAttackTime;
	}

	public void DoAttack()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if (HasTarget())
		{
			GetTarget().Hurt(Random.Range(30f, 70f), DamageType.Bite, this);
			Vector3 posWorld = WaterClamp(GetTarget().CenterPoint());
			Effect.server.Run(bloodCloud.resourcePath, posWorld, Vector3.forward);
			nextAttackTime = Time.realtimeSinceStartup + attackCooldown;
		}
	}

	public void Startle()
	{
		lastStartleTime = Time.realtimeSinceStartup;
	}

	public bool IsStartled()
	{
		return lastStartleTime + startleDuration > Time.realtimeSinceStartup;
	}

	private float GetDesiredSpeed()
	{
		if (!IsStartled())
		{
			return minSpeed;
		}
		return maxSpeed;
	}

	public float GetTurnSpeed()
	{
		if (IsStartled())
		{
			return maxTurnSpeed;
		}
		if (obstacleAvoidanceScale != 0f)
		{
			return Mathf.Lerp(minTurnSpeed, maxTurnSpeed, obstacleAvoidanceScale);
		}
		return minTurnSpeed;
	}

	private float GetCurrentSpeed()
	{
		return currentSpeed;
	}

	private void UpdateObstacleAvoidance(float delta)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		timeSinceLastObstacleCheck += delta;
		if (timeSinceLastObstacleCheck < 0.5f)
		{
			return;
		}
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 position = ((Component)this).transform.position;
		int num = 1503764737;
		RaycastHit val = default(RaycastHit);
		if (Physics.SphereCast(position, obstacleDetectionRadius, forward, ref val, obstacleDetectionRange, num))
		{
			Vector3 point = ((RaycastHit)(ref val)).point;
			Vector3 val2 = Vector3.zero;
			Vector3 val3 = Vector3.zero;
			RaycastHit val4 = default(RaycastHit);
			if (Physics.SphereCast(position + Vector3.down * 0.25f + ((Component)this).transform.right * 0.25f, obstacleDetectionRadius, forward, ref val4, obstacleDetectionRange, num))
			{
				val2 = ((RaycastHit)(ref val4)).point;
			}
			RaycastHit val5 = default(RaycastHit);
			if (Physics.SphereCast(position + Vector3.down * 0.25f - ((Component)this).transform.right * 0.25f, obstacleDetectionRadius, forward, ref val5, obstacleDetectionRange, num))
			{
				val3 = ((RaycastHit)(ref val5)).point;
			}
			if (val2 != Vector3.zero && val3 != Vector3.zero)
			{
				Plane val6 = default(Plane);
				((Plane)(ref val6))..ctor(point, val2, val3);
				Vector3 normal = ((Plane)(ref val6)).normal;
				if (normal != Vector3.zero)
				{
					((RaycastHit)(ref val)).normal = normal;
				}
			}
			cachedObstacleNormal = ((RaycastHit)(ref val)).normal;
			cachedObstacleDistance = ((RaycastHit)(ref val)).distance;
			obstacleAvoidanceScale = 1f - Mathf.InverseLerp(2f, obstacleDetectionRange * 0.75f, ((RaycastHit)(ref val)).distance);
		}
		else
		{
			obstacleAvoidanceScale = Mathf.MoveTowards(obstacleAvoidanceScale, 0f, timeSinceLastObstacleCheck * 2f);
			if (obstacleAvoidanceScale == 0f)
			{
				cachedObstacleDistance = 0f;
			}
		}
		timeSinceLastObstacleCheck = 0f;
	}

	private void UpdateDirection(float delta)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		_ = ((Component)this).transform.forward;
		Vector3 val = Vector3Ex.Direction(WaterClamp(destination), ((Component)this).transform.position);
		if (obstacleAvoidanceScale != 0f)
		{
			Vector3 val3;
			if (cachedObstacleNormal != Vector3.zero)
			{
				Vector3 val2 = QuaternionEx.LookRotationForcedUp(cachedObstacleNormal, Vector3.up) * Vector3.forward;
				val3 = ((!(Vector3.Dot(val2, ((Component)this).transform.right) > Vector3.Dot(val2, -((Component)this).transform.right))) ? (-((Component)this).transform.right) : ((Component)this).transform.right);
			}
			else
			{
				val3 = ((Component)this).transform.right;
			}
			val = val3 * obstacleAvoidanceScale;
			((Vector3)(ref val)).Normalize();
		}
		if (val != Vector3.zero)
		{
			Quaternion val4 = Quaternion.LookRotation(val, Vector3.up);
			((Component)this).transform.rotation = Quaternion.Lerp(((Component)this).transform.rotation, val4, delta * GetTurnSpeed());
		}
	}

	private void UpdatePosition(float delta)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 point = ((Component)this).transform.position + forward * GetCurrentSpeed() * delta;
		point = WaterClamp(point);
		((Component)this).transform.position = point;
	}

	private void UpdateSpeed(float delta)
	{
		currentSpeed = Mathf.Lerp(currentSpeed, GetDesiredSpeed(), delta * 4f);
	}

	public void Update()
	{
		if (base.isServer)
		{
			Think(Time.deltaTime);
		}
	}
}


using UnityEngine;

public class SimpleState
{
	public SimpleShark entity;

	private float stateEnterTime;

	public SimpleState(SimpleShark owner)
	{
		entity = owner;
	}

	public virtual float State_Weight()
	{
		return 0f;
	}

	public virtual void State_Enter()
	{
		stateEnterTime = Time.realtimeSinceStartup;
	}

	public virtual void State_Think(float delta)
	{
	}

	public virtual void State_Exit()
	{
	}

	public virtual bool CanInterrupt()
	{
		return true;
	}

	public virtual float TimeInState()
	{
		return Time.realtimeSinceStartup - stateEnterTime;
	}
}


using UnityEngine;

public class IdleState : SimpleState
{
	private int patrolTargetIndex;

	public IdleState(SimpleShark owner)
		: base(owner)
	{
	}

	public Vector3 GetTargetPatrolPosition()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return entity.patrolPath[patrolTargetIndex];
	}

	public override float State_Weight()
	{
		return 1f;
	}

	public override void State_Enter()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		float num = float.PositiveInfinity;
		int num2 = 0;
		for (int i = 0; i < entity.patrolPath.Count; i++)
		{
			float num3 = Vector3.Distance(entity.patrolPath[i], ((Component)entity).transform.position);
			if (num3 < num)
			{
				num2 = i;
				num = num3;
			}
		}
		patrolTargetIndex = num2;
		base.State_Enter();
	}

	public override void State_Think(float delta)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3.Distance(GetTargetPatrolPosition(), ((Component)entity).transform.position) < entity.stoppingDistance)
		{
			patrolTargetIndex++;
			if (patrolTargetIndex >= entity.patrolPath.Count)
			{
				patrolTargetIndex = 0;
			}
		}
		if (entity.TimeSinceAttacked() >= 120f && entity.healthFraction < 1f)
		{
			entity.health = entity.MaxHealth();
		}
		entity.destination = entity.WaterClamp(GetTargetPatrolPosition());
	}

	public override void State_Exit()
	{
		base.State_Exit();
	}

	public override bool CanInterrupt()
	{
		return true;
	}
}


using UnityEngine;

public class AttackState : SimpleState
{
	public AttackState(SimpleShark owner)
		: base(owner)
	{
	}

	public override float State_Weight()
	{
		if (!entity.HasTarget() || !entity.CanAttack())
		{
			return 0f;
		}
		return 10f;
	}

	public override void State_Enter()
	{
		base.State_Enter();
	}

	public override void State_Think(float delta)
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer target = entity.GetTarget();
		if ((Object)(object)target == (Object)null)
		{
			return;
		}
		if (TimeInState() >= 10f)
		{
			entity.nextAttackTime = Time.realtimeSinceStartup + 4f;
			entity.Startle();
			return;
		}
		if (entity.CanAttack())
		{
			entity.Startle();
		}
		float num = Vector3.Distance(entity.GetTarget().eyes.position, ((Component)entity).transform.position);
		bool num2 = num < 4f;
		if (entity.CanAttack() && num <= 2f)
		{
			entity.DoAttack();
		}
		if (!num2)
		{
			Vector3 val = Vector3Ex.Direction(entity.GetTarget().eyes.position, ((Component)entity).transform.position);
			Vector3 point = target.eyes.position + val * 10f;
			point = entity.WaterClamp(point);
			entity.destination = point;
		}
	}

	public override void State_Exit()
	{
		base.State_Exit();
	}

	public override bool CanInterrupt()
	{
		return true;
	}
}


using System;
using System.Collections.Generic;
using Rust;
using UnityEngine;

public class BasePet : NPCPlayer, IThinker
{
	public static Dictionary<ulong, BasePet> ActivePetByOwnerID = new Dictionary<ulong, BasePet>();

	[ServerVar]
	public static bool queuedMovementsAllowed = true;

	[ServerVar]
	public static bool onlyQueueBaseNavMovements = true;

	[ServerVar]
	[Help("How many miliseconds to budget for processing pet movements per frame")]
	public static float movementupdatebudgetms = 1f;

	public float BaseAttackRate = 2f;

	public float BaseAttackDamge = 20f;

	public DamageType AttackDamageType = DamageType.Slash;

	public GameObjectRef mapMarkerPrefab;

	private BaseEntity _mapMarkerInstance;

	[NonSerialized]
	[HideInInspector]
	public bool inQueue;

	public static Queue<BasePet> _movementProcessQueue = new Queue<BasePet>();

	public PetBrain Brain { get; protected set; }

	public override float StartHealth()
	{
		return startHealth;
	}

	public override float StartMaxHealth()
	{
		return startHealth;
	}

	public override float MaxHealth()
	{
		return _maxHealth;
	}

	public static void ProcessMovementQueue()
	{
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		float num = movementupdatebudgetms / 1000f;
		while (_movementProcessQueue.Count > 0 && Time.realtimeSinceStartup < realtimeSinceStartup + num)
		{
			BasePet basePet = _movementProcessQueue.Dequeue();
			if ((Object)(object)basePet != (Object)null)
			{
				basePet.DoBudgetedMoveUpdate();
				basePet.inQueue = false;
			}
		}
	}

	public void DoBudgetedMoveUpdate()
	{
		if ((Object)(object)Brain != (Object)null)
		{
			Brain.DoMovementTick();
		}
	}

	public override bool IsLoadBalanced()
	{
		return true;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		Brain = ((Component)this).GetComponent<PetBrain>();
		if (!base.isClient)
		{
			AIThinkManager.AddPet(this);
		}
	}

	public void CreateMapMarker()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)_mapMarkerInstance != (Object)null)
		{
			_mapMarkerInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(mapMarkerPrefab?.resourcePath, Vector3.zero, Quaternion.identity);
		baseEntity.OwnerID = base.OwnerID;
		baseEntity.Spawn();
		baseEntity.SetParent(this);
		_mapMarkerInstance = baseEntity;
	}

	internal override void DoServerDestroy()
	{
		if ((Object)(object)Brain.OwningPlayer != (Object)null)
		{
			Brain.OwningPlayer.ClearClientPetLink();
		}
		AIThinkManager.RemovePet(this);
		base.DoServerDestroy();
	}

	public virtual void TryThink()
	{
		ServerThink_Internal();
	}

	public override void ServerThink(float delta)
	{
		base.ServerThink(delta);
		if (Brain.ShouldServerThink())
		{
			Brain.DoThink();
		}
	}

	public void ApplyPetStatModifiers()
	{
		if ((Object)(object)base.inventory == (Object)null)
		{
			return;
		}
		for (int i = 0; i < base.inventory.containerWear.capacity; i++)
		{
			Item slot = base.inventory.containerWear.GetSlot(i);
			if (slot != null)
			{
				ItemModPetStats component = ((Component)slot.info).GetComponent<ItemModPetStats>();
				if ((Object)(object)component != (Object)null)
				{
					component.Apply(this);
				}
			}
		}
		Heal(MaxHealth());
	}

	private void OnPhysicsNeighbourChanged()
	{
		if ((Object)(object)Brain != (Object)null && (Object)(object)Brain.Navigator != (Object)null)
		{
			Brain.Navigator.ForceToGround();
		}
	}
}


using UnityEngine;

public class GingerbreadBrain : BaseAIBrain
{
	public class AttackState : BasicAIState
	{
		private IAIAttack attack;

		private float originalStoppingDistance;

		public AttackState()
			: base(AIState.Attack)
		{
			base.AgrresiveState = true;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			entity.SetFlag(BaseEntity.Flags.Reserved3, b: true);
			originalStoppingDistance = brain.Navigator.StoppingDistance;
			brain.Navigator.Agent.stoppingDistance = 1f;
			brain.Navigator.StoppingDistance = 1f;
			base.StateEnter(brain, entity);
			attack = entity as IAIAttack;
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity != (Object)null)
			{
				Vector3 aimDirection = GetAimDirection(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position);
				brain.Navigator.SetFacingDirectionOverride(aimDirection);
				if (attack.CanAttack(baseEntity))
				{
					StartAttacking(baseEntity);
				}
				brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
			}
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			entity.SetFlag(BaseEntity.Flags.Reserved3, b: false);
			brain.Navigator.Agent.stoppingDistance = originalStoppingDistance;
			brain.Navigator.StoppingDistance = originalStoppingDistance;
			brain.Navigator.ClearFacingDirectionOverride();
			brain.Navigator.Stop();
			StopAttacking();
		}

		private void StopAttacking()
		{
			attack.StopAttacking();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if (attack == null)
			{
				return StateStatus.Error;
			}
			if ((Object)(object)baseEntity == (Object)null)
			{
				brain.Navigator.ClearFacingDirectionOverride();
				StopAttacking();
				return StateStatus.Finished;
			}
			if (brain.Senses.ignoreSafeZonePlayers)
			{
				BasePlayer basePlayer = baseEntity as BasePlayer;
				if ((Object)(object)basePlayer != (Object)null && basePlayer.InSafeZone())
				{
					return StateStatus.Error;
				}
			}
			Vector3Ex.Direction2D(((Component)baseEntity).transform.position, ((Component)entity).transform.position);
			Vector3 position = ((Component)baseEntity).transform.position;
			if (!brain.Navigator.SetDestination(position, BaseNavigator.NavigationSpeed.Fast, 0.2f))
			{
				return StateStatus.Error;
			}
			Vector3 aimDirection = GetAimDirection(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position);
			brain.Navigator.SetFacingDirectionOverride(aimDirection);
			if (attack.CanAttack(baseEntity))
			{
				StartAttacking(baseEntity);
			}
			else
			{
				StopAttacking();
			}
			return StateStatus.Running;
		}

		private static Vector3 GetAimDirection(Vector3 from, Vector3 target)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			return Vector3Ex.Direction2D(target, from);
		}

		private void StartAttacking(BaseEntity entity)
		{
			attack.StartAttacking(entity);
		}
	}

	public class RoamState : BasicAIState
	{
		private StateStatus status = StateStatus.Error;

		public RoamState()
			: base(AIState.Roam)
		{
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			status = StateStatus.Error;
			if (brain.PathFinder == null)
			{
				return;
			}
			ScarecrowNPC scarecrowNPC = entity as ScarecrowNPC;
			if (!((Object)(object)scarecrowNPC == (Object)null))
			{
				Vector3 val = brain.Events.Memory.Position.Get(4);
				Vector3 val2 = val;
				val2 = ((!scarecrowNPC.RoamAroundHomePoint) ? brain.PathFinder.GetBestRoamPosition(brain.Navigator, ((Component)brain.Navigator).transform.position, brain.Events.Memory.Position.Get(4), 10f, brain.Navigator.BestRoamPointMaxDistance) : brain.PathFinder.GetBestRoamPositionFromAnchor(brain.Navigator, val, val, 1f, brain.Navigator.BestRoamPointMaxDistance));
				if (brain.Navigator.SetDestination(val2, BaseNavigator.NavigationSpeed.Slow))
				{
					status = StateStatus.Running;
				}
				else
				{
					status = StateStatus.Error;
				}
			}
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			base.StateThink(delta, brain, entity);
			if (status == StateStatus.Error)
			{
				return status;
			}
			if (brain.Navigator.Moving)
			{
				return StateStatus.Running;
			}
			return StateStatus.Finished;
		}
	}

	public override void AddStates()
	{
		base.AddStates();
		AddState(new BaseIdleState());
		AddState(new BaseChaseState());
		AddState(new AttackState());
		AddState(new RoamState());
		AddState(new BaseFleeState());
	}

	public override void InitializeAI()
	{
		base.InitializeAI();
		base.ThinkMode = AIThinkMode.Interval;
		thinkRate = 0.25f;
		base.PathFinder = new HumanPathFinder();
		((HumanPathFinder)base.PathFinder).Init(GetBaseEntity());
	}

	public override void OnDestroy()
	{
		base.OnDestroy();
	}
}


using UnityEngine;

public class AttackState : BasicAIState
{
	private IAIAttack attack;

	private float originalStoppingDistance;

	public AttackState()
		: base(AIState.Attack)
	{
		base.AgrresiveState = true;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		entity.SetFlag(BaseEntity.Flags.Reserved3, b: true);
		originalStoppingDistance = brain.Navigator.StoppingDistance;
		brain.Navigator.Agent.stoppingDistance = 1f;
		brain.Navigator.StoppingDistance = 1f;
		base.StateEnter(brain, entity);
		attack = entity as IAIAttack;
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity != (Object)null)
		{
			Vector3 aimDirection = GetAimDirection(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position);
			brain.Navigator.SetFacingDirectionOverride(aimDirection);
			if (attack.CanAttack(baseEntity))
			{
				StartAttacking(baseEntity);
			}
			brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
		}
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		entity.SetFlag(BaseEntity.Flags.Reserved3, b: false);
		brain.Navigator.Agent.stoppingDistance = originalStoppingDistance;
		brain.Navigator.StoppingDistance = originalStoppingDistance;
		brain.Navigator.ClearFacingDirectionOverride();
		brain.Navigator.Stop();
		StopAttacking();
	}

	private void StopAttacking()
	{
		attack.StopAttacking();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if (attack == null)
		{
			return StateStatus.Error;
		}
		if ((Object)(object)baseEntity == (Object)null)
		{
			brain.Navigator.ClearFacingDirectionOverride();
			StopAttacking();
			return StateStatus.Finished;
		}
		if (brain.Senses.ignoreSafeZonePlayers)
		{
			BasePlayer basePlayer = baseEntity as BasePlayer;
			if ((Object)(object)basePlayer != (Object)null && basePlayer.InSafeZone())
			{
				return StateStatus.Error;
			}
		}
		Vector3Ex.Direction2D(((Component)baseEntity).transform.position, ((Component)entity).transform.position);
		Vector3 position = ((Component)baseEntity).transform.position;
		if (!brain.Navigator.SetDestination(position, BaseNavigator.NavigationSpeed.Fast, 0.2f))
		{
			return StateStatus.Error;
		}
		Vector3 aimDirection = GetAimDirection(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position);
		brain.Navigator.SetFacingDirectionOverride(aimDirection);
		if (attack.CanAttack(baseEntity))
		{
			StartAttacking(baseEntity);
		}
		else
		{
			StopAttacking();
		}
		return StateStatus.Running;
	}

	private static Vector3 GetAimDirection(Vector3 from, Vector3 target)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.Direction2D(target, from);
	}

	private void StartAttacking(BaseEntity entity)
	{
		attack.StartAttacking(entity);
	}
}


using UnityEngine;

public class RoamState : BasicAIState
{
	private StateStatus status = StateStatus.Error;

	public RoamState()
		: base(AIState.Roam)
	{
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		status = StateStatus.Error;
		if (brain.PathFinder == null)
		{
			return;
		}
		ScarecrowNPC scarecrowNPC = entity as ScarecrowNPC;
		if (!((Object)(object)scarecrowNPC == (Object)null))
		{
			Vector3 val = brain.Events.Memory.Position.Get(4);
			Vector3 val2 = val;
			val2 = ((!scarecrowNPC.RoamAroundHomePoint) ? brain.PathFinder.GetBestRoamPosition(brain.Navigator, ((Component)brain.Navigator).transform.position, brain.Events.Memory.Position.Get(4), 10f, brain.Navigator.BestRoamPointMaxDistance) : brain.PathFinder.GetBestRoamPositionFromAnchor(brain.Navigator, val, val, 1f, brain.Navigator.BestRoamPointMaxDistance));
			if (brain.Navigator.SetDestination(val2, BaseNavigator.NavigationSpeed.Slow))
			{
				status = StateStatus.Running;
			}
			else
			{
				status = StateStatus.Error;
			}
		}
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		if (status == StateStatus.Error)
		{
			return status;
		}
		if (brain.Navigator.Moving)
		{
			return StateStatus.Running;
		}
		return StateStatus.Finished;
	}
}


using ConVar;
using ProtoBuf;
using UnityEngine;

public class GingerbreadNPC : HumanNPC, IClientBrainStateListener
{
	public GameObjectRef OverrideCorpseMale;

	public GameObjectRef OverrideCorpseFemale;

	public PhysicMaterial HitMaterial;

	public bool RoamAroundHomePoint;

	protected override string CorpsePath => CorpseResourcePath;

	protected override string OverrideCorpseName => "Gingerbread";

	protected override bool ShouldCorpseTakeChildren => false;

	protected override bool KeepCorpseClothingIntact => false;

	protected override bool CopyInventoryToCorpse => false;

	protected string CorpseResourcePath
	{
		get
		{
			bool flag = GetFloatBasedOnUserID(userID, 4332uL) > 0.5f;
			if (OverrideCorpseMale.isValid && !flag)
			{
				return OverrideCorpseMale.resourcePath;
			}
			if (OverrideCorpseFemale.isValid && flag)
			{
				return OverrideCorpseFemale.resourcePath;
			}
			return "assets/prefabs/npc/murderer/murderer_corpse.prefab";
			static float GetFloatBasedOnUserID(ulong steamid, ulong seed)
			{
				//IL_0000: Unknown result type (might be due to invalid IL or missing references)
				//IL_0005: Unknown result type (might be due to invalid IL or missing references)
				//IL_001e: Unknown result type (might be due to invalid IL or missing references)
				State state = Random.state;
				Random.InitState((int)(seed + steamid));
				float result = Random.Range(0f, 1f);
				Random.state = state;
				return result;
			}
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		info.HitMaterial = Global.GingerbreadMaterialID();
	}

	public override string Categorize()
	{
		return "Gingerbread";
	}

	public override bool ShouldDropActiveItem()
	{
		return false;
	}

	public override void AttackerInfo(DeathInfo info)
	{
		base.AttackerInfo(info);
		info.inflictorName = base.inventory.containerBelt.GetSlot(0).info.shortname;
		info.attackerName = base.ShortPrefabName;
	}

	public void OnClientStateChanged(AIState state)
	{
	}
}


using System;
using UnityEngine;

public class AIThinkManager : BaseMonoBehaviour, IServerComponent
{
	public enum QueueType
	{
		Human,
		Animal,
		Pets
	}

	public static ListHashSet<IThinker> _processQueue = new ListHashSet<IThinker>();

	public static ListHashSet<IThinker> _removalQueue = new ListHashSet<IThinker>();

	public static ListHashSet<IThinker> _animalProcessQueue = new ListHashSet<IThinker>();

	public static ListHashSet<IThinker> _animalremovalQueue = new ListHashSet<IThinker>();

	public static ListHashSet<IThinker> _petProcessQueue = new ListHashSet<IThinker>();

	public static ListHashSet<IThinker> _petRemovalQueue = new ListHashSet<IThinker>();

	[ServerVar]
	[Help("How many miliseconds to budget for processing AI entities per server frame")]
	public static float framebudgetms = 2.5f;

	[Help("How many miliseconds to budget for processing animal AI entities per server frame")]
	[ServerVar]
	public static float animalframebudgetms = 2.5f;

	[ServerVar]
	[Help("How many miliseconds to budget for processing pet AI entities per server frame")]
	public static float petframebudgetms = 1f;

	private static int lastIndex = 0;

	private static int lastAnimalIndex = 0;

	private static int lastPetIndex;

	public static void ProcessQueue(QueueType queueType)
	{
		if (queueType != 0)
		{
			_ = 2;
		}
		switch (queueType)
		{
		case QueueType.Human:
			DoRemoval(_removalQueue, _processQueue);
			AIInformationZone.BudgetedTick();
			break;
		case QueueType.Pets:
			DoRemoval(_petRemovalQueue, _petProcessQueue);
			break;
		default:
			DoRemoval(_animalremovalQueue, _animalProcessQueue);
			break;
		}
		switch (queueType)
		{
		case QueueType.Human:
			DoProcessing(_processQueue, framebudgetms / 1000f, ref lastIndex);
			break;
		case QueueType.Pets:
			DoProcessing(_petProcessQueue, petframebudgetms / 1000f, ref lastPetIndex);
			break;
		default:
			DoProcessing(_animalProcessQueue, animalframebudgetms / 1000f, ref lastAnimalIndex);
			break;
		}
	}

	private static void DoRemoval(ListHashSet<IThinker> removal, ListHashSet<IThinker> process)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		if (removal.Count <= 0)
		{
			return;
		}
		Enumerator<IThinker> enumerator = removal.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				IThinker current = enumerator.Current;
				process.Remove(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		removal.Clear();
	}

	private static void DoProcessing(ListHashSet<IThinker> process, float budgetSeconds, ref int last)
	{
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		while (last < process.Count && Time.realtimeSinceStartup < realtimeSinceStartup + budgetSeconds)
		{
			IThinker thinker = process[last];
			if (thinker != null)
			{
				try
				{
					thinker.TryThink();
				}
				catch (Exception ex)
				{
					Debug.LogWarning((object)ex);
				}
			}
			last++;
		}
		if (last >= process.Count)
		{
			last = 0;
		}
	}

	public static void Add(IThinker toAdd)
	{
		_processQueue.Add(toAdd);
	}

	public static void Remove(IThinker toRemove)
	{
		_removalQueue.Add(toRemove);
	}

	public static void AddAnimal(IThinker toAdd)
	{
		_animalProcessQueue.Add(toAdd);
	}

	public static void RemoveAnimal(IThinker toRemove)
	{
		_animalremovalQueue.Add(toRemove);
	}

	public static void AddPet(IThinker toAdd)
	{
		_petProcessQueue.Add(toAdd);
	}

	public static void RemovePet(IThinker toRemove)
	{
		_petRemovalQueue.Add(toRemove);
	}
}


public enum QueueType
{
	Human,
	Animal,
	Pets
}


public class BanditGuard : HumanNPC
{
}


