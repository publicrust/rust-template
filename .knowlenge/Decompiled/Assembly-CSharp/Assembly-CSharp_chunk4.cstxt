using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using BasePlayerJobs;
using CompanionServer;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Math;
using Facepunch.Models;
using Facepunch.Rust;
using JetBrains.Annotations;
using Network;
using Network.Visibility;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using ProtoBuf;
using ProtoBuf.Nexus;
using Rust;
using Rust.Ai.Gen2;
using SilentOrbit.ProtocolBuffers;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Jobs;

public class BasePlayer : BaseCombatEntity, LootPanel.IHasLootPanel, IIdealSlotEntity, IInventoryProvider, PlayerInventory.ICanMoveFrom, ISplashable, IStableIndex
{
	public enum CameraMode
	{
		FirstPerson = 0,
		ThirdPerson = 1,
		Eyes = 2,
		FirstPersonWithArms = 3,
		DeathCamClassic = 4,
		Last = 3
	}

	public enum NetworkQueue
	{
		Update,
		UpdateDistance,
		Count
	}

	private class NetworkQueueList
	{
		public HashSet<BaseNetworkable> queueInternal = new HashSet<BaseNetworkable>();

		public int MaxLength;

		public int Length => queueInternal.Count;

		public bool Contains(BaseNetworkable ent)
		{
			return queueInternal.Contains(ent);
		}

		public void Add(BaseNetworkable ent)
		{
			if (!Contains(ent))
			{
				queueInternal.Add(ent);
			}
			MaxLength = Mathf.Max(MaxLength, queueInternal.Count);
		}

		public void Add(BaseNetworkable[] ent)
		{
			foreach (BaseNetworkable ent2 in ent)
			{
				Add(ent2);
			}
		}

		public void Clear(Group group)
		{
			TimeWarning val = TimeWarning.New("NetworkQueueList.Clear", 0);
			try
			{
				if (group != null)
				{
					if (group.isGlobal)
					{
						return;
					}
					List<BaseNetworkable> list = Pool.Get<List<BaseNetworkable>>();
					foreach (BaseNetworkable item in queueInternal)
					{
						if ((Object)(object)item == (Object)null || item.net?.group == null || item.net.group == group)
						{
							list.Add(item);
						}
					}
					foreach (BaseNetworkable item2 in list)
					{
						queueInternal.Remove(item2);
					}
					Pool.FreeUnmanaged<BaseNetworkable>(ref list);
				}
				else
				{
					queueInternal.RemoveWhere((BaseNetworkable x) => (Object)(object)x == (Object)null || x.net?.group == null || !x.net.group.isGlobal);
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	[Flags]
	public enum PlayerFlags
	{
		Unused1 = 1,
		Unused2 = 2,
		IsAdmin = 4,
		ReceivingSnapshot = 8,
		Sleeping = 0x10,
		Spectating = 0x20,
		Wounded = 0x40,
		IsDeveloper = 0x80,
		Connected = 0x100,
		ThirdPersonViewmode = 0x400,
		EyesViewmode = 0x800,
		ChatMute = 0x1000,
		NoSprint = 0x2000,
		Aiming = 0x4000,
		DisplaySash = 0x8000,
		Relaxed = 0x10000,
		SafeZone = 0x20000,
		ServerFall = 0x40000,
		Incapacitated = 0x80000,
		Workbench1 = 0x100000,
		Workbench2 = 0x200000,
		Workbench3 = 0x400000,
		VoiceRangeBoost = 0x800000,
		ModifyClan = 0x1000000,
		LoadingAfterTransfer = 0x2000000,
		NoRespawnZone = 0x4000000,
		IsInTutorial = 0x8000000,
		IsRestrained = 0x10000000,
		CreativeMode = 0x20000000,
		WaitingForGestureInteraction = 0x40000000,
		Ragdolling = int.MinValue
	}

	private enum RPSWinState
	{
		Win,
		Loss,
		Draw
	}

	public static class GestureIds
	{
		public const uint FlashBlindId = 235662700u;
	}

	public enum GestureStartSource
	{
		ServerAction,
		Player
	}

	public enum MapNoteType
	{
		Death,
		PointOfInterest
	}

	public enum PingType
	{
		Hostile = 0,
		GoTo = 1,
		Dollar = 2,
		Loot = 3,
		Node = 4,
		Gun = 5,
		Build = 6,
		LAST = 6
	}

	public struct PingStyle
	{
		public int IconIndex;

		public int ColourIndex;

		public Phrase PingTitle;

		public Phrase PingDescription;

		public PingType Type;

		public PingStyle(int icon, int colour, Phrase title, Phrase desc, PingType pType)
		{
			IconIndex = icon;
			ColourIndex = colour;
			PingTitle = title;
			PingDescription = desc;
			Type = pType;
		}
	}

	[JsonModel]
	public struct FiredProjectileUpdate
	{
		public Vector3 OldPosition;

		public Vector3 NewPosition;

		public Vector3 OldVelocity;

		public Vector3 NewVelocity;

		public float Mismatch;

		public float PartialTime;
	}

	public class FiredProjectile : IPooled
	{
		public ItemDefinition itemDef;

		public ItemModProjectile itemMod;

		public Projectile projectilePrefab;

		public float firedTime;

		public float travelTime;

		public float partialTime;

		public AttackEntity weaponSource;

		public AttackEntity weaponPrefab;

		public Projectile.Modifier projectileModifier;

		public Item pickupItem;

		public float integrity;

		public float trajectoryMismatch;

		public float startPointMismatch;

		public float endPointMismatch;

		public float entityDistance;

		public Vector3 position;

		public Vector3 initialPositionOffset;

		public Vector3 positionOffset;

		public Vector3 velocity;

		public Vector3 initialPosition;

		public Vector3 initialVelocity;

		public Vector3 inheritedVelocity;

		public int protection;

		public int ricochets;

		public int hits;

		public BaseEntity lastEntityHit;

		public float desyncLifeTime;

		public int id;

		public BasePlayer attacker;

		public bool invalid;

		public List<FiredProjectileUpdate> updates = new List<FiredProjectileUpdate>();

		public List<Vector3> simulatedPositions = new List<Vector3>();

		public void EnterPool()
		{
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
			itemDef = null;
			itemMod = null;
			projectilePrefab = null;
			firedTime = 0f;
			travelTime = 0f;
			partialTime = 0f;
			weaponSource = null;
			weaponPrefab = null;
			projectileModifier = default(Projectile.Modifier);
			pickupItem = null;
			integrity = 0f;
			trajectoryMismatch = 0f;
			startPointMismatch = 0f;
			endPointMismatch = 0f;
			entityDistance = 0f;
			position = default(Vector3);
			velocity = default(Vector3);
			initialPosition = default(Vector3);
			initialVelocity = default(Vector3);
			inheritedVelocity = default(Vector3);
			protection = 0;
			ricochets = 0;
			hits = 0;
			lastEntityHit = null;
			desyncLifeTime = 0f;
			id = 0;
			attacker = null;
			invalid = false;
			updates.Clear();
			simulatedPositions.Clear();
		}

		public void LeavePool()
		{
		}
	}

	public class SpawnPoint
	{
		public Vector3 pos;

		public Quaternion rot;

		public bool isProcedualSpawn;
	}

	internal struct DeathBlow
	{
		public BaseEntity Initiator;

		public BaseEntity WeaponPrefab;

		public uint HitBone;

		public bool IsValid;

		public static void From(HitInfo hitInfo, out DeathBlow deathBlow)
		{
			deathBlow = default(DeathBlow);
			deathBlow.IsValid = hitInfo != null;
			if (deathBlow.IsValid)
			{
				deathBlow.Initiator = hitInfo.Initiator;
				deathBlow.WeaponPrefab = hitInfo.WeaponPrefab;
				deathBlow.HitBone = hitInfo.HitBone;
			}
			else
			{
				deathBlow.IsValid = false;
				deathBlow.Initiator = null;
				deathBlow.WeaponPrefab = null;
			}
		}

		public static void Reset(ref DeathBlow deathBlow)
		{
			deathBlow.IsValid = false;
			deathBlow.Initiator = null;
			deathBlow.WeaponPrefab = null;
			deathBlow.HitBone = 0u;
		}
	}

	public enum TimeCategory
	{
		Wilderness = 1,
		Monument = 2,
		Base = 4,
		Flying = 8,
		Boating = 0x10,
		Swimming = 0x20,
		Driving = 0x40
	}

	public class LifeStoryWorkQueue : ObjectWorkQueue<BasePlayer>
	{
		protected override void RunJob(BasePlayer entity)
		{
			entity.UpdateTimeCategory();
		}

		protected override bool ShouldAdd(BasePlayer entity)
		{
			if (base.ShouldAdd(entity))
			{
				return entity.IsValid();
			}
			return false;
		}
	}

	private class NearbyStash
	{
		public StashContainer Entity;

		public float LookingAtTime;

		public NearbyStash(StashContainer stash)
		{
			Entity = stash;
			LookingAtTime = 0f;
		}
	}

	public struct CachedState
	{
		public WaterLevel.WaterInfo WaterInfo;

		public float WaterFactor;

		public bool IsSwimming;

		public bool IsValid;
	}

	public enum PositionChange
	{
		Same,
		Valid,
		Invalid
	}

	public enum TutorialItemAllowance
	{
		AlwaysAllowed = -1,
		None = 0,
		Level1_HatchetPickaxe = 10,
		Level2_Planner = 20,
		Level3_Bag_TC_Door = 30,
		Level3_Hammer = 35,
		Level4_Spear_Fire = 40,
		Level5_PrepareForCombat = 50,
		Level6_Furnace = 60,
		Level7_WorkBench = 70,
		Level8_Kayak = 80
	}

	public enum InjureState
	{
		Normal,
		Crawling,
		Incapacitated,
		Dead
	}

	[Serializable]
	public struct CapsuleColliderInfo
	{
		public float height;

		public float radius;

		public Vector3 center;

		public CapsuleColliderInfo(float height, float radius, Vector3 center)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			this.height = height;
			this.radius = radius;
			this.center = center;
		}
	}

	[NonSerialized]
	public bool isInAir;

	[NonSerialized]
	public bool isOnPlayer;

	[NonSerialized]
	public float violationLevel;

	[NonSerialized]
	public float lastViolationTime;

	[NonSerialized]
	public float lastMovementViolationTime;

	[NonSerialized]
	public float lastAdminCheatTime;

	[NonSerialized]
	public AntiHackType lastViolationType;

	[NonSerialized]
	public float vehiclePauseTime;

	[NonSerialized]
	public float forceCastTime;

	[NonSerialized]
	public float speedhackPauseTime;

	[NonSerialized]
	public float speedhackExtraSpeedTime;

	[NonSerialized]
	public float speedhackDistance;

	[NonSerialized]
	public float speedhackExtraSpeed;

	[NonSerialized]
	public float flyhackPauseTime;

	[NonSerialized]
	public float flyhackDistanceVertical;

	[NonSerialized]
	public float flyhackDistanceHorizontal;

	[NonSerialized]
	public Vector3 lastGroundedPosition;

	[NonSerialized]
	public float fallingVelocity;

	[NonSerialized]
	public float fallingDistance;

	[NonSerialized]
	public float timeInAir;

	[NonSerialized]
	public float waterDelay;

	[NonSerialized]
	public Vector3 initialVelocity;

	[NonSerialized]
	public float tickDistancePausetime;

	[NonSerialized]
	public float lastInAirTime;

	[NonSerialized]
	public TimeAverageValueLookup<uint> rpcHistory = new TimeAverageValueLookup<uint>();

	[NonSerialized]
	public float unparentTime;

	public static readonly Phrase ClanInviteSuccess = new Phrase("clan.action.invite.success", "Invited {name} to your clan.");

	public static readonly Phrase ClanInviteFailure = new Phrase("clan.action.invite.failure", "Failed to invite {name} to your clan. Please wait a minute and try again.");

	public static readonly Phrase ClanInviteFull = new Phrase("clan.action.invite.full", "Cannot invite {name} to your clan because your clan is full.");

	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public IClan serverClan;

	public ViewModel GestureViewModel;

	public const float drinkRange = 1.5f;

	public const float drinkMovementSpeed = 0.1f;

	[NonSerialized]
	private NetworkQueueList[] networkQueue = new NetworkQueueList[2]
	{
		new NetworkQueueList(),
		new NetworkQueueList()
	};

	[NonSerialized]
	private NetworkQueueList SnapshotQueue = new NetworkQueueList();

	private const int FogImagesCount = 16;

	public const string GestureCancelString = "cancel";

	public TimeUntil gestureFinishedTime;

	public TimeSince blockHeldInputTimer;

	public GestureConfig currentGesture;

	public static Phrase WinRPSPhrase = new Phrase("rps_win", "You win the game!");

	public static Phrase LoseRPSPhrase = new Phrase("rps_lose", "You lose the game!");

	public static Phrase DrawRPSPhrase = new Phrase("rps_draw", "The game was a draw!");

	private HashSet<NetworkableId> recentWaveTargets = new HashSet<NetworkableId>();

	public const string WAVED_PLAYERS_STAT = "waved_at_players";

	private NetworkableId rpsTarget;

	private int selectedRpsOption = -1;

	public const float RPSWaitTime = 10f;

	private TimeSince interactiveGestureStartTime;

	public ulong currentTeam;

	public static readonly Phrase MaxTeamSizeToast = new Phrase("maxteamsizetip", "Your team is full. Remove a member to invite another player.");

	private bool sentInstrumentTeamAchievement;

	private bool sentSummerTeamAchievement;

	private const int TEAMMATE_INSTRUMENT_COUNT_ACHIEVEMENT = 4;

	private const int TEAMMATE_SUMMER_FLOATING_COUNT_ACHIEVEMENT = 4;

	private const string TEAMMATE_INSTRUMENT_ACHIEVEMENT = "TEAM_INSTRUMENTS";

	private const string TEAMMATE_SUMMER_ACHIEVEMENT = "SUMMER_INFLATABLE";

	public static Phrase MarkerLimitPhrase = new Phrase("map.marker.limited", "Cannot place more than {0} markers.");

	public const int MaxMapNoteLabelLength = 10;

	public List<BaseMission.MissionInstance> missions = new List<BaseMission.MissionInstance>();

	private float thinkEvery = 1f;

	private float timeSinceMissionThink;

	private BaseMission followupMission;

	private IMissionProvider followupMissionProvider;

	private int _activeMission = -1;

	[NonSerialized]
	public ModelState modelState = new ModelState();

	[NonSerialized]
	private bool wantsSendModelState;

	[NonSerialized]
	public float nextModelStateUpdate;

	[NonSerialized]
	public EntityRef mounted;

	public float nextSeatSwapTime;

	public BaseEntity PetEntity;

	[NonSerialized]
	public IPet Pet;

	private float lastPetCommandIssuedTime;

	private static readonly Phrase HostileTitle = new Phrase("ping_hostile", "Hostile");

	private static readonly Phrase HostileDesc = new Phrase("ping_hostile_desc", "Danger in area");

	private static readonly PingStyle HostileMarker = new PingStyle(4, 3, HostileTitle, HostileDesc, PingType.Hostile);

	private static readonly Phrase GoToTitle = new Phrase("ping_goto", "Go To");

	private static readonly Phrase GoToDesc = new Phrase("ping_goto_desc", "Look at this");

	private static readonly PingStyle GoToMarker = new PingStyle(0, 2, GoToTitle, GoToDesc, PingType.GoTo);

	private static readonly Phrase DollarTitle = new Phrase("ping_dollar", "Value");

	private static readonly Phrase DollarDesc = new Phrase("ping_dollar_desc", "Something valuable is here");

	private static readonly PingStyle DollarMarker = new PingStyle(1, 1, DollarTitle, DollarDesc, PingType.Dollar);

	private static readonly Phrase LootTitle = new Phrase("ping_loot", "Loot");

	private static readonly Phrase LootDesc = new Phrase("ping_loot_desc", "Loot is here");

	private static readonly PingStyle LootMarker = new PingStyle(11, 0, LootTitle, LootDesc, PingType.Loot);

	private static readonly Phrase NodeTitle = new Phrase("ping_node", "Node");

	private static readonly Phrase NodeDesc = new Phrase("ping_node_desc", "An ore node is here");

	private static readonly PingStyle NodeMarker = new PingStyle(10, 4, NodeTitle, NodeDesc, PingType.Node);

	private static readonly Phrase GunTitle = new Phrase("ping_gun", "Weapon");

	private static readonly Phrase GunDesc = new Phrase("ping_weapon_desc", "A dropped weapon is here");

	private static readonly PingStyle GunMarker = new PingStyle(9, 5, GunTitle, GunDesc, PingType.Gun);

	private static readonly PingStyle BuildMarker = new PingStyle(12, 5, new Phrase("", ""), new Phrase("", ""), PingType.Build);

	private TimeSince lastTick;

	private List<(ItemDefinition item, PingType pingType)> tutorialDesiredResource = new List<(ItemDefinition, PingType)>();

	private List<(NetworkableId id, PingType pingType)> pingedEntities = new List<(NetworkableId, PingType)>();

	private TimeSince lastResourcePingUpdate;

	private bool _playerStateDirty;

	private string _wipeId;

	private float cachedVehicleBuildingPrivilegeTime;

	private BaseEntity cachedVehicleBuildingPrivilege;

	private bool cachedVehicleBuildingPrivilegeBlocked;

	private float cachedEntityBuildingPrivilegeTime;

	private BaseEntity cachedEntityBuildingPrivilege;

	private bool cachedEntityBuildingPrivilegeBlocked;

	[NonSerialized]
	public Dictionary<int, FiredProjectile> firedProjectiles = new Dictionary<int, FiredProjectile>();

	private const float radiationDamageTime = 1f;

	private const float radiationDamageThreshold = 2500f;

	private const float radiationRatioAdjustment = 0.05f;

	private const float containerCheckRadTime = 2500f;

	private const float containerRadRatioAdjustment = 0.05f;

	private Action inflictInventoryRadsAction;

	private float inventoryRads;

	private bool hasOpenedLoot;

	private List<ItemContainer> radiationCheckContainers = new List<ItemContainer>();

	private float containerRads;

	private Action inflictRadsAction;

	private Action checkRadsAction;

	private const string RagdollPath = "assets/prefabs/player/player_temp_ragdoll.prefab";

	[NonSerialized]
	public PlayerStatistics stats;

	[NonSerialized]
	public GameObjectRef DeathIconOverride;

	[NonSerialized]
	public ItemId svActiveItemID;

	[NonSerialized]
	public float NextChatTime;

	[NonSerialized]
	public float nextSuicideTime;

	[NonSerialized]
	public float nextRespawnTime;

	[NonSerialized]
	public string respawnId;

	[NonSerialized]
	public float nextMuteCheckTime;

	[NonSerialized]
	public bool isInvisible;

	private RealTimeUntil timeUntilLoadingExpires;

	public Dictionary<BaseNetworkable, float> lastPlayerVisibility = new Dictionary<BaseNetworkable, float>();

	public Vector3 viewAngles;

	public float lastSubscriptionTick;

	public float lastPlayerTick;

	public float sleepStartTime = -1f;

	public float fallTickRate = 0.1f;

	public float lastFallTime;

	public float fallVelocity;

	private DeathBlow cachedNonSuicideHit;

	private float timeSinceLastStung;

	private float timeSinceLastStungRPC;

	public static ListHashSet<BasePlayer> activePlayerList = new ListHashSet<BasePlayer>();

	public static ListHashSet<BasePlayer> sleepingPlayerList = new ListHashSet<BasePlayer>();

	public static ListHashSet<BasePlayer> bots = new ListHashSet<BasePlayer>();

	public float cachedCraftLevel;

	public float nextCheckTime;

	private Workbench _cachedWorkbench;

	public PersistantPlayer cachedPersistantPlayer;

	private static OceanPaths cachedOceanPaths = null;

	private const int WILDERNESS = 1;

	private const int MONUMENT = 2;

	private const int BASE = 4;

	private const int FLYING = 8;

	private const int BOATING = 16;

	private const int SWIMMING = 32;

	private const int DRIVING = 64;

	[ServerVar]
	[Help("How many milliseconds to budget for processing life story updates per frame")]
	public static float lifeStoryFramebudgetms = 0.25f;

	[NonSerialized]
	public PlayerLifeStory lifeStory;

	[NonSerialized]
	public PlayerLifeStory previousLifeStory;

	public const float TimeCategoryUpdateFrequency = 7f;

	public float nextTimeCategoryUpdate;

	private bool hasSentPresenceState;

	private bool LifeStoryInWilderness;

	private bool LifeStoryInMonument;

	private bool LifeStoryInBase;

	private bool LifeStoryFlying;

	private bool LifeStoryBoating;

	private bool LifeStorySwimming;

	private bool LifeStoryDriving;

	private bool waitingForLifeStoryUpdate;

	public static LifeStoryWorkQueue lifeStoryQueue = new LifeStoryWorkQueue();

	[CanBeNull]
	private DeathInfo cachedOverrideDeathInfo;

	private bool IsSpectatingTeamInfo;

	private TimeSince lastSpectateTeamInfoUpdate;

	public int SpectateOffset = 1000000;

	public string spectateFilter = "";

	private TimeSince timeSinceLastWaterSplash;

	private List<NearbyStash> nearbyStashes = new List<NearbyStash>();

	public float lastUpdateTime = float.NegativeInfinity;

	public float cachedThreatLevel;

	[NonSerialized]
	public float weaponDrawnDuration;

	[NonSerialized]
	public float lastTickTime;

	[NonSerialized]
	public float lastStallTime;

	[NonSerialized]
	private float stallProtectionTime;

	[NonSerialized]
	public float lastInputTime;

	[NonSerialized]
	private float tutorialKickTime;

	[NonSerialized]
	public ItemId? restraintItemId;

	public PlayerTick lastReceivedTick = new PlayerTick();

	private List<IReceivePlayerTickListener> receiveTickListeners = new List<IReceivePlayerTickListener>();

	private float tickDeltaTime;

	private bool tickNeedsFinalizing;

	private readonly TimeAverageValue ticksPerSecond = new TimeAverageValue();

	private readonly TimeAverageValue rawTicksPerSecond = new TimeAverageValue();

	private readonly TickInterpolator tickInterpolator = new TickInterpolator();

	public Deque<Vector3> eyeHistory = new Deque<Vector3>(8);

	public TickHistory tickHistory = new TickHistory();

	private static NativeArray<Vector3> PlayerLocalPos;

	private static NativeArray<Quaternion> PlayerLocalRots;

	private static NativeArray<PositionChange> PositionChanges;

	private static NativeArray<WaterLevel.WaterInfo> WaterInfos;

	private static NativeArray<float> WaterFactors;

	private static NativeArray<CachedState> CachedStates;

	private static TickInterpolatorCache TickCache;

	private static TransformAccessArray PlayerTransformsAccess;

	private static NativeList<int> PlayersToFinalize;

	private static NativeList<int> PlayersToValidate;

	private static NativeList<int> PlayersToRecache;

	private float startTutorialCooldown;

	public float nextUnderwearValidationTime;

	public uint lastValidUnderwearSkin;

	private InjureState playerInjureState;

	public float woundedDuration;

	public float lastWoundedStartTime = float.NegativeInfinity;

	public float healingWhileCrawling;

	public bool woundedByFallDamage;

	private const float INCAPACITATED_HEALTH_MIN = 2f;

	private const float INCAPACITATED_HEALTH_MAX = 6f;

	public const int MaxBotIdRange = 10000000;

	[Header("BasePlayer")]
	public GameObjectRef fallDamageEffect;

	public GameObjectRef drownEffect;

	[InspectorFlags]
	public PlayerFlags playerFlags;

	private HiddenValue<PlayerEyes> eyesValue = Pool.Get<HiddenValue<PlayerEyes>>();

	private HiddenValue<PlayerInventory> inventoryValue = Pool.Get<HiddenValue<PlayerInventory>>();

	[NonSerialized]
	public PlayerBlueprints blueprints;

	[NonSerialized]
	public PlayerMetabolism metabolism;

	[NonSerialized]
	public PlayerModifiers modifiers;

	private HiddenValue<CapsuleCollider> colliderValue = Pool.Get<HiddenValue<CapsuleCollider>>();

	public PlayerBelt Belt;

	public Rigidbody playerRigidbody;

	[NonSerialized]
	public EncryptedValue<ulong> userID = 0uL;

	[NonSerialized]
	public string UserIDString;

	[NonSerialized]
	public int gamemodeteam = -1;

	[NonSerialized]
	public int reputation;

	protected string _displayName;

	public string _lastSetName;

	public const float crouchSpeed = 1.7f;

	public const float walkSpeed = 2.8f;

	public const float runSpeed = 5.5f;

	public const float crawlSpeed = 0.72f;

	public CapsuleColliderInfo playerColliderStanding;

	public CapsuleColliderInfo playerColliderDucked;

	public CapsuleColliderInfo playerColliderCrawling;

	public CapsuleColliderInfo playerColliderLyingDown;

	public ProtectionProperties cachedProtection;

	private static readonly PlayerCache playerCache = new PlayerCache(128);

	public float nextColliderRefreshTime = -1f;

	public float weaponMoveSpeedScale = 1f;

	public bool clothingBlocksAiming;

	public float clothingMoveSpeedReduction;

	public float clothingWaterSpeedBonus;

	public float clothingAccuracyBonus;

	public bool equippingBlocked;

	public float eggVision;

	private static NativeArray<Vector3> Starts;

	private static NativeArray<Vector3> Ends;

	private static NativeArray<float> Radii;

	private static NativeArray<int> WaterQueryIndices;

	public PhoneController activeTelephone;

	public BaseEntity designingAIEntity;

	[NonSerialized]
	public IPlayer IPlayer;

	public Phrase LootPanelTitle => Phrase.op_Implicit(displayName);

	public bool IsReceivingSnapshot => HasPlayerFlag(PlayerFlags.ReceivingSnapshot);

	public bool IsAdmin => HasPlayerFlag(PlayerFlags.IsAdmin);

	public bool IsDeveloper => HasPlayerFlag(PlayerFlags.IsDeveloper);

	public bool IsInCreativeMode
	{
		get
		{
			if (!Creative.allUsers)
			{
				return HasPlayerFlag(PlayerFlags.CreativeMode);
			}
			return true;
		}
	}

	public bool UnlockAllSkins
	{
		get
		{
			if (!IsDeveloper)
			{
				return false;
			}
			if (base.isServer)
			{
				return net.connection.info.GetBool("client.unlock_all_skins", false);
			}
			return false;
		}
	}

	public bool IsAiming => HasPlayerFlag(PlayerFlags.Aiming);

	public bool IsFlying
	{
		get
		{
			if (modelState == null)
			{
				return false;
			}
			return modelState.flying;
		}
	}

	public bool IsConnected
	{
		get
		{
			if (base.isServer)
			{
				if (Net.sv == null)
				{
					return false;
				}
				if (net == null)
				{
					return false;
				}
				if (net.connection == null)
				{
					return false;
				}
				return true;
			}
			return false;
		}
	}

	public bool IsInTutorial => HasPlayerFlag(PlayerFlags.IsInTutorial);

	public bool IsRestrained
	{
		get
		{
			if (IsAlive())
			{
				return HasPlayerFlag(PlayerFlags.IsRestrained);
			}
			return false;
		}
	}

	public bool IsRestrainedOrSurrendering
	{
		get
		{
			if (!IsRestrained)
			{
				return CurrentGestureIsSurrendering;
			}
			return true;
		}
	}

	public static bool ShouldRunFogOfWar
	{
		get
		{
			BaseGameMode svActiveGameMode = BaseGameMode.svActiveGameMode;
			if ((Object)(object)svActiveGameMode != (Object)null)
			{
				return svActiveGameMode.fogOfWar;
			}
			return false;
		}
	}

	public bool InGesture
	{
		get
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)currentGesture != (Object)null)
			{
				if (!(TimeUntil.op_Implicit(gestureFinishedTime) > 0f))
				{
					return currentGesture.animationType == GestureConfig.AnimationType.Loop;
				}
				return true;
			}
			return false;
		}
	}

	private bool CurrentGestureBlocksMovement
	{
		get
		{
			if (InGesture)
			{
				return currentGesture.movementMode == GestureConfig.MovementCapabilities.NoMovement;
			}
			return false;
		}
	}

	public bool CurrentGestureIsDance
	{
		get
		{
			if (InGesture)
			{
				return currentGesture.actionType == GestureConfig.GestureActionType.DanceAchievement;
			}
			return false;
		}
	}

	public bool CurrentGestureIsFullBody
	{
		get
		{
			if (InGesture)
			{
				return currentGesture.playerModelLayer == GestureConfig.PlayerModelLayer.FullBody;
			}
			return false;
		}
	}

	public bool CurrentGestureIsUpperBody
	{
		get
		{
			if (InGesture)
			{
				return currentGesture.playerModelLayer == GestureConfig.PlayerModelLayer.UpperBody;
			}
			return false;
		}
	}

	public bool CurrentGestureIsSurrendering
	{
		get
		{
			if (InGesture)
			{
				return currentGesture.actionType == GestureConfig.GestureActionType.Surrender;
			}
			return false;
		}
	}

	private bool InGestureCancelCooldown => TimeSince.op_Implicit(blockHeldInputTimer) < 0.5f;

	public RelationshipManager.PlayerTeam Team
	{
		get
		{
			if ((Object)(object)RelationshipManager.ServerInstance == (Object)null)
			{
				return null;
			}
			return RelationshipManager.ServerInstance.FindTeam(currentTeam);
		}
	}

	private bool CanUseMapMarkers
	{
		get
		{
			BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(base.isServer);
			if ((Object)(object)activeGameMode != (Object)null)
			{
				return activeGameMode.mapMarkers;
			}
			return true;
		}
	}

	public MapNote ServerCurrentDeathNote
	{
		get
		{
			return State.deathMarker;
		}
		set
		{
			State.deathMarker = value;
		}
	}

	public bool HasPendingFollowupMission => ((FacepunchBehaviour)this).IsInvoking((Action)AssignFollowUpMission);

	public ModelState modelStateTick { get; private set; }

	public bool isMounted => mounted.IsValid(base.isServer);

	public bool isMountingHidingWeapon
	{
		get
		{
			if (isMounted)
			{
				return !GetMounted().CanHoldItems();
			}
			return false;
		}
	}

	private int TotalPingCount
	{
		get
		{
			if (State.pings == null)
			{
				return 0;
			}
			return State.pings.Count;
		}
	}

	public PlayerState State
	{
		get
		{
			if ((ulong)userID == 0L)
			{
				throw new InvalidOperationException("Cannot get player state without a SteamID");
			}
			return SingletonComponent<ServerMgr>.Instance.playerStateManager.Get(userID);
		}
	}

	public string WipeId
	{
		get
		{
			if (_wipeId == null)
			{
				_wipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(userID);
			}
			return _wipeId;
		}
	}

	public virtual BaseNpc.AiStatistics.FamilyEnum Family => BaseNpc.AiStatistics.FamilyEnum.Player;

	public override float PositionTickRate
	{
		protected get
		{
			return -1f;
		}
	}

	public int DebugMapMarkerIndex { get; set; }

	public bool PlayHeavyLandingAnimation { get; set; }

	public ServerOcclusion.Grid Chunk { get; set; }

	public ServerOcclusion.SubGrid SubGrid { get; set; }

	public Vector3? RcEntityPosition { get; private set; }

	public Vector3 estimatedVelocity { get; private set; }

	public Vector3 estimatedVelocityClamped => Vector3.ClampMagnitude(estimatedVelocity, GetMaxSpeed());

	public float inferedSpeed
	{
		get
		{
			if (estimatedSpeed < 0.01f)
			{
				return 0f;
			}
			if (modelState.sprinting)
			{
				return 5.5f;
			}
			if (modelState.ducked)
			{
				return 1.7f;
			}
			return 2.8f;
		}
	}

	public Vector3 inferedVelocity
	{
		get
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			float num = inferedSpeed;
			Vector3 val = estimatedVelocity;
			return num * ((Vector3)(ref val)).normalized;
		}
	}

	public float estimatedSpeed { get; private set; }

	public float estimatedSpeed2D { get; private set; }

	public int secondsConnected { get; private set; }

	public float desyncTimeRaw { get; set; }

	public float desyncTimeClamped { get; set; }

	public float secondsSleeping
	{
		get
		{
			if (sleepStartTime == -1f || !IsSleeping())
			{
				return 0f;
			}
			return Time.time - sleepStartTime;
		}
	}

	public static IEnumerable<BasePlayer> allPlayerList
	{
		get
		{
			Enumerator<BasePlayer> enumerator = sleepingPlayerList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					yield return enumerator.Current;
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
			enumerator = activePlayerList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					yield return enumerator.Current;
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
	}

	public float currentCraftLevel
	{
		get
		{
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			if (triggers == null)
			{
				_cachedWorkbench = null;
				return 0f;
			}
			if (nextCheckTime > Time.realtimeSinceStartup)
			{
				return cachedCraftLevel;
			}
			_cachedWorkbench = null;
			nextCheckTime = Time.realtimeSinceStartup + Random.Range(0.4f, 0.5f);
			float num = 0f;
			for (int i = 0; i < triggers.Count; i++)
			{
				TriggerWorkbench triggerWorkbench = triggers[i] as TriggerWorkbench;
				if (!((Object)(object)triggerWorkbench == (Object)null) && !((Object)(object)triggerWorkbench.parentBench == (Object)null) && triggerWorkbench.parentBench.IsVisible(eyes.position))
				{
					_cachedWorkbench = triggerWorkbench.parentBench;
					float num2 = triggerWorkbench.WorkbenchLevel();
					if (num2 > num)
					{
						num = num2;
					}
				}
			}
			cachedCraftLevel = num;
			return num;
		}
	}

	public float currentComfort
	{
		get
		{
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			float num = 0f;
			if (isMounted)
			{
				num = GetMounted().GetComfort();
			}
			if (triggers != null)
			{
				for (int i = 0; i < triggers.Count; i++)
				{
					TriggerComfort triggerComfort = triggers[i] as TriggerComfort;
					if (!((Object)(object)triggerComfort == (Object)null))
					{
						float num2 = triggerComfort.CalculateComfort(((Component)this).transform.position, this);
						if (num2 > num)
						{
							num = num2;
						}
					}
				}
			}
			float num3 = (((Object)(object)modifiers != (Object)null) ? modifiers.GetValue(Modifier.ModifierType.Comfort) : 0f);
			return num + num3;
		}
	}

	public PersistantPlayer PersistantPlayerInfo
	{
		get
		{
			if (cachedPersistantPlayer == null)
			{
				cachedPersistantPlayer = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerInfo(userID);
			}
			return cachedPersistantPlayer;
		}
		set
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			cachedPersistantPlayer = value;
			SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerInfo(userID, value);
		}
	}

	public bool hasPreviousLife => previousLifeStory != null;

	public int currentTimeCategory { get; private set; }

	public bool wantsSpectate { get; set; }

	public bool IsBeingSpectated { get; private set; }

	public TimeSince TimeSinceLastWaterSplash => timeSinceLastWaterSplash;

	public InputState serverInput { get; private set; } = new InputState();

	public int StableIndex { get; set; } = -1;

	public float timeSinceLastTick
	{
		get
		{
			if (lastTickTime == 0f)
			{
				return 0f;
			}
			return Time.time - lastTickTime;
		}
	}

	public float timeSinceLastStall
	{
		get
		{
			if (lastStallTime == 0f)
			{
				return 60f;
			}
			return Time.time - lastStallTime;
		}
	}

	public float IdleTime
	{
		get
		{
			if (lastInputTime == 0f)
			{
				return 0f;
			}
			return Time.time - lastInputTime;
		}
	}

	public bool isStalled
	{
		get
		{
			if (IsDead() || IsSleeping())
			{
				lastStallTime = 0f;
				return false;
			}
			if (stallProtectionTime <= 0f && timeSinceLastTick != 0f && timeSinceLastTick > ConVar.AntiHack.rpcstallthreshold)
			{
				lastStallTime = Time.time;
				return true;
			}
			return false;
		}
	}

	public bool wasStalled
	{
		get
		{
			if (stallProtectionTime <= 0f)
			{
				if (!isStalled)
				{
					return timeSinceLastStall < ConVar.AntiHack.rpcstallfade;
				}
				return true;
			}
			return false;
		}
	}

	internal float TickDeltaTime => tickDeltaTime;

	public Vector3 tickViewAngles { get; private set; }

	public Vector3 tickMouseDelta { get; private set; }

	internal TickInterpolator TickInterpolator => tickInterpolator;

	public int tickHistoryCapacity => Mathf.Max(1, Mathf.CeilToInt((float)ticksPerSecond.Calculate() * ConVar.AntiHack.tickhistorytime));

	public Matrix4x4 tickHistoryMatrix
	{
		get
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			if (!Object.op_Implicit((Object)(object)((Component)this).transform.parent))
			{
				return Matrix4x4.identity;
			}
			return ((Component)this).transform.parent.localToWorldMatrix;
		}
	}

	public ulong rawTickCount { get; set; }

	public TutorialItemAllowance CurrentTutorialAllowance { get; private set; }

	public InjureState PlayerInjureState
	{
		get
		{
			return playerInjureState;
		}
		set
		{
			if (playerInjureState != value)
			{
				Analytics.Azure.OnPlayerChangeInjureState(this, PlayerInjureState, value);
				playerInjureState = value;
			}
		}
	}

	public float TimeSinceWoundedStarted => Time.realtimeSinceStartup - lastWoundedStartTime;

	public Connection Connection
	{
		get
		{
			if (net != null)
			{
				return net.connection;
			}
			return null;
		}
	}

	public bool IsBot => (ulong)userID < 10000000;

	public PlayerEyes eyes
	{
		get
		{
			if (eyesValue == null)
			{
				return null;
			}
			return eyesValue.Get();
		}
		set
		{
			eyesValue.Set(value);
		}
	}

	public PlayerInventory inventory
	{
		get
		{
			if (inventoryValue == null)
			{
				return null;
			}
			return inventoryValue.Get();
		}
	}

	public CapsuleCollider playerCollider
	{
		get
		{
			if (colliderValue == null)
			{
				return null;
			}
			return colliderValue.Get();
		}
	}

	public virtual string displayName
	{
		get
		{
			return NameHelper.Get(userID, _displayName, base.isClient);
		}
		set
		{
			if (!(_lastSetName == value))
			{
				_lastSetName = value;
				_displayName = SanitizePlayerNameString(value, userID);
			}
		}
	}

	public override TraitFlag Traits => base.Traits | TraitFlag.Human | TraitFlag.Food | TraitFlag.Meat | TraitFlag.Alive;

	public bool HasActiveTelephone => (Object)(object)activeTelephone != (Object)null;

	public bool IsDesigningAI => (Object)(object)designingAIEntity != (Object)null;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BasePlayer.OnRpcMessage", 0);
		try
		{
			if (rpc == 935768323 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ClientKeepConnectionAlive "));
				}
				TimeWarning val2 = TimeWarning.New("ClientKeepConnectionAlive", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(935768323u, "ClientKeepConnectionAlive", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							ClientKeepConnectionAlive(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in ClientKeepConnectionAlive");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3782818894u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ClientLoadingComplete "));
				}
				TimeWarning val2 = TimeWarning.New("ClientLoadingComplete", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(3782818894u, "ClientLoadingComplete", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							ClientLoadingComplete(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in ClientLoadingComplete");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1217424607 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - FogImageUpdate "));
				}
				TimeWarning val2 = TimeWarning.New("FogImageUpdate", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1217424607u, "FogImageUpdate", this, player, 16uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(1217424607u, "FogImageUpdate", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							FogImageUpdate(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in FogImageUpdate");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1497207530 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - IssuePetCommand "));
				}
				TimeWarning val2 = TimeWarning.New("IssuePetCommand", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg5 = rPCMessage;
						IssuePetCommand(msg5);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex4)
				{
					Debug.LogException(ex4);
					player.Kick("RPC Error in IssuePetCommand");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2041023702 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - IssuePetCommandRaycast "));
				}
				TimeWarning val2 = TimeWarning.New("IssuePetCommandRaycast", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg6 = rPCMessage;
						IssuePetCommandRaycast(msg6);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex5)
				{
					Debug.LogException(ex5);
					player.Kick("RPC Error in IssuePetCommandRaycast");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 495414158 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - NotifyDebugCameraEnded "));
				}
				TimeWarning val2 = TimeWarning.New("NotifyDebugCameraEnded", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg7 = rPCMessage;
						NotifyDebugCameraEnded(msg7);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex6)
				{
					Debug.LogException(ex6);
					player.Kick("RPC Error in NotifyDebugCameraEnded");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3441821928u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - OnFeedbackReport "));
				}
				TimeWarning val2 = TimeWarning.New("OnFeedbackReport", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3441821928u, "OnFeedbackReport", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(3441821928u, "OnFeedbackReport", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg8 = rPCMessage;
							OnFeedbackReport(msg8);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex7)
					{
						Debug.LogException(ex7);
						player.Kick("RPC Error in OnFeedbackReport");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1998170713 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - OnPlayerLanded "));
				}
				TimeWarning val2 = TimeWarning.New("OnPlayerLanded", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(1998170713u, "OnPlayerLanded", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg9 = rPCMessage;
							OnPlayerLanded(msg9);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex8)
					{
						Debug.LogException(ex8);
						player.Kick("RPC Error in OnPlayerLanded");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2147041557 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - OnPlayerReported "));
				}
				TimeWarning val2 = TimeWarning.New("OnPlayerReported", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2147041557u, "OnPlayerReported", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(2147041557u, "OnPlayerReported", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg10 = rPCMessage;
							OnPlayerReported(msg10);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex9)
					{
						Debug.LogException(ex9);
						player.Kick("RPC Error in OnPlayerReported");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 363681694 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - OnProjectileAttack "));
				}
				TimeWarning val2 = TimeWarning.New("OnProjectileAttack", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(363681694u, "OnProjectileAttack", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg11 = rPCMessage;
							OnProjectileAttack(msg11);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex10)
					{
						Debug.LogException(ex10);
						player.Kick("RPC Error in OnProjectileAttack");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1500391289 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - OnProjectileRicochet "));
				}
				TimeWarning val2 = TimeWarning.New("OnProjectileRicochet", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(1500391289u, "OnProjectileRicochet", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg12 = rPCMessage;
							OnProjectileRicochet(msg12);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex11)
					{
						Debug.LogException(ex11);
						player.Kick("RPC Error in OnProjectileRicochet");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2324190493u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - OnProjectileUpdate "));
				}
				TimeWarning val2 = TimeWarning.New("OnProjectileUpdate", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(2324190493u, "OnProjectileUpdate", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg13 = rPCMessage;
							OnProjectileUpdate(msg13);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex12)
					{
						Debug.LogException(ex12);
						player.Kick("RPC Error in OnProjectileUpdate");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3167788018u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - PerformanceReport "));
				}
				TimeWarning val2 = TimeWarning.New("PerformanceReport", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3167788018u, "PerformanceReport", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(3167788018u, "PerformanceReport", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg14 = rPCMessage;
							PerformanceReport(msg14);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex13)
					{
						Debug.LogException(ex13);
						player.Kick("RPC Error in PerformanceReport");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4081064578u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - PlayerRequestedTutorialStart "));
				}
				TimeWarning val2 = TimeWarning.New("PlayerRequestedTutorialStart", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4081064578u, "PlayerRequestedTutorialStart", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(4081064578u, "PlayerRequestedTutorialStart", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg15 = rPCMessage;
							PlayerRequestedTutorialStart(msg15);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex14)
					{
						Debug.LogException(ex14);
						player.Kick("RPC Error in PlayerRequestedTutorialStart");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 56793194 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RequestJoinGesture "));
				}
				TimeWarning val2 = TimeWarning.New("RequestJoinGesture", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(56793194u, "RequestJoinGesture", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg16 = rPCMessage;
							RequestJoinGesture(msg16);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex15)
					{
						Debug.LogException(ex15);
						player.Kick("RPC Error in RequestJoinGesture");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1024003327 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RequestParachuteDeploy "));
				}
				TimeWarning val2 = TimeWarning.New("RequestParachuteDeploy", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1024003327u, "RequestParachuteDeploy", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(1024003327u, "RequestParachuteDeploy", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg17 = rPCMessage;
							RequestParachuteDeploy(msg17);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex16)
					{
						Debug.LogException(ex16);
						player.Kick("RPC Error in RequestParachuteDeploy");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 52352806 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RequestRespawnInformation "));
				}
				TimeWarning val2 = TimeWarning.New("RequestRespawnInformation", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(52352806u, "RequestRespawnInformation", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(52352806u, "RequestRespawnInformation", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg18 = rPCMessage;
							RequestRespawnInformation(msg18);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex17)
					{
						Debug.LogException(ex17);
						player.Kick("RPC Error in RequestRespawnInformation");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1774681338 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RequestServerEmoji "));
				}
				TimeWarning val2 = TimeWarning.New("RequestServerEmoji", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1774681338u, "RequestServerEmoji", this, player, 1uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RequestServerEmoji();
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex18)
					{
						Debug.LogException(ex18);
						player.Kick("RPC Error in RequestServerEmoji");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 970468557 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Assist "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Assist", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(970468557u, "RPC_Assist", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg19 = rPCMessage;
							RPC_Assist(msg19);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex19)
					{
						Debug.LogException(ex19);
						player.Kick("RPC Error in RPC_Assist");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3263238541u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_KeepAlive "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_KeepAlive", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3263238541u, "RPC_KeepAlive", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg20 = rPCMessage;
							RPC_KeepAlive(msg20);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex20)
					{
						Debug.LogException(ex20);
						player.Kick("RPC Error in RPC_KeepAlive");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3692395068u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_LootPlayer "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_LootPlayer", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3692395068u, "RPC_LootPlayer", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg21 = rPCMessage;
							RPC_LootPlayer(msg21);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex21)
					{
						Debug.LogException(ex21);
						player.Kick("RPC Error in RPC_LootPlayer");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2659547586u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ReqDoRestrainedPush "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ReqDoRestrainedPush", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2659547586u, "RPC_ReqDoRestrainedPush", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2659547586u, "RPC_ReqDoRestrainedPush", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2659547586u, "RPC_ReqDoRestrainedPush", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_ReqDoRestrainedPush(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex22)
					{
						Debug.LogException(ex22);
						player.Kick("RPC Error in RPC_ReqDoRestrainedPush");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3974264977u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ReqEquipHood "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ReqEquipHood", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3974264977u, "RPC_ReqEquipHood", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3974264977u, "RPC_ReqEquipHood", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3974264977u, "RPC_ReqEquipHood", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							RPC_ReqEquipHood(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex23)
					{
						Debug.LogException(ex23);
						player.Kick("RPC Error in RPC_ReqEquipHood");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4144905368u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ReqForceMountNearest "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ReqForceMountNearest", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4144905368u, "RPC_ReqForceMountNearest", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(4144905368u, "RPC_ReqForceMountNearest", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(4144905368u, "RPC_ReqForceMountNearest", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc4 = rPCMessage;
							RPC_ReqForceMountNearest(rpc4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex24)
					{
						Debug.LogException(ex24);
						player.Kick("RPC Error in RPC_ReqForceMountNearest");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3816898909u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ReqForceSwapSeat "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ReqForceSwapSeat", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3816898909u, "RPC_ReqForceSwapSeat", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(3816898909u, "RPC_ReqForceSwapSeat", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3816898909u, "RPC_ReqForceSwapSeat", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc5 = rPCMessage;
							RPC_ReqForceSwapSeat(rpc5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex25)
					{
						Debug.LogException(ex25);
						player.Kick("RPC Error in RPC_ReqForceSwapSeat");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 626234931 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ReqRemoveCuffs "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ReqRemoveCuffs", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(626234931u, "RPC_ReqRemoveCuffs", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(626234931u, "RPC_ReqRemoveCuffs", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(626234931u, "RPC_ReqRemoveCuffs", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc6 = rPCMessage;
							RPC_ReqRemoveCuffs(rpc6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex26)
					{
						Debug.LogException(ex26);
						player.Kick("RPC Error in RPC_ReqRemoveCuffs");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2289764809u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_ReqRemoveHood "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_ReqRemoveHood", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2289764809u, "RPC_ReqRemoveHood", this, player, 5uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2289764809u, "RPC_ReqRemoveHood", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2289764809u, "RPC_ReqRemoveHood", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc7 = rPCMessage;
							RPC_ReqRemoveHood(rpc7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex27)
					{
						Debug.LogException(ex27);
						player.Kick("RPC Error in RPC_ReqRemoveHood");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1539133504 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_StartClimb "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_StartClimb", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg22 = rPCMessage;
						RPC_StartClimb(msg22);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex28)
				{
					Debug.LogException(ex28);
					player.Kick("RPC Error in RPC_StartClimb");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1777651896 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SelectedRPSOption "));
				}
				TimeWarning val2 = TimeWarning.New("SelectedRPSOption", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(1777651896u, "SelectedRPSOption", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg23 = rPCMessage;
							SelectedRPSOption(msg23);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex29)
					{
						Debug.LogException(ex29);
						player.Kick("RPC Error in SelectedRPSOption");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3047177092u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_AddMarker "));
				}
				TimeWarning val2 = TimeWarning.New("Server_AddMarker", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3047177092u, "Server_AddMarker", this, player, 8uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(3047177092u, "Server_AddMarker", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg24 = rPCMessage;
							Server_AddMarker(msg24);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex30)
					{
						Debug.LogException(ex30);
						player.Kick("RPC Error in Server_AddMarker");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3618659425u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_AddPing "));
				}
				TimeWarning val2 = TimeWarning.New("Server_AddPing", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3618659425u, "Server_AddPing", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(3618659425u, "Server_AddPing", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg25 = rPCMessage;
							Server_AddPing(msg25);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex31)
					{
						Debug.LogException(ex31);
						player.Kick("RPC Error in Server_AddPing");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1005040107 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_CancelGesture "));
				}
				TimeWarning val2 = TimeWarning.New("Server_CancelGesture", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1005040107u, "Server_CancelGesture", this, player, 10uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(1005040107u, "Server_CancelGesture", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							Server_CancelGesture();
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex32)
					{
						Debug.LogException(ex32);
						player.Kick("RPC Error in Server_CancelGesture");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 706157120 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_ClearMapMarkers "));
				}
				TimeWarning val2 = TimeWarning.New("Server_ClearMapMarkers", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(706157120u, "Server_ClearMapMarkers", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(706157120u, "Server_ClearMapMarkers", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg26 = rPCMessage;
							Server_ClearMapMarkers(msg26);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex33)
					{
						Debug.LogException(ex33);
						player.Kick("RPC Error in Server_ClearMapMarkers");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 310453544 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_ClearPointsOfInterest "));
				}
				TimeWarning val2 = TimeWarning.New("Server_ClearPointsOfInterest", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(310453544u, "Server_ClearPointsOfInterest", this, player, 8uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(310453544u, "Server_ClearPointsOfInterest", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg27 = rPCMessage;
							Server_ClearPointsOfInterest(msg27);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex34)
					{
						Debug.LogException(ex34);
						player.Kick("RPC Error in Server_ClearPointsOfInterest");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1032755717 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RemovePing "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RemovePing", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1032755717u, "Server_RemovePing", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(1032755717u, "Server_RemovePing", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg28 = rPCMessage;
							Server_RemovePing(msg28);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex35)
					{
						Debug.LogException(ex35);
						player.Kick("RPC Error in Server_RemovePing");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 31713840 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RemovePointOfInterest "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RemovePointOfInterest", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(31713840u, "Server_RemovePointOfInterest", this, player, 10uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(31713840u, "Server_RemovePointOfInterest", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg29 = rPCMessage;
							Server_RemovePointOfInterest(msg29);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex36)
					{
						Debug.LogException(ex36);
						player.Kick("RPC Error in Server_RemovePointOfInterest");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2567683804u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RequestMarkers "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RequestMarkers", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2567683804u, "Server_RequestMarkers", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(2567683804u, "Server_RequestMarkers", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg30 = rPCMessage;
							Server_RequestMarkers(msg30);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex37)
					{
						Debug.LogException(ex37);
						player.Kick("RPC Error in Server_RequestMarkers");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1572722245 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_StartGesture "));
				}
				TimeWarning val2 = TimeWarning.New("Server_StartGesture", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1572722245u, "Server_StartGesture", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(1572722245u, "Server_StartGesture", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg31 = rPCMessage;
							Server_StartGesture(msg31);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex38)
					{
						Debug.LogException(ex38);
						player.Kick("RPC Error in Server_StartGesture");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1180369886 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_UpdateMarker "));
				}
				TimeWarning val2 = TimeWarning.New("Server_UpdateMarker", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1180369886u, "Server_UpdateMarker", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(1180369886u, "Server_UpdateMarker", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg32 = rPCMessage;
							Server_UpdateMarker(msg32);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex39)
					{
						Debug.LogException(ex39);
						player.Kick("RPC Error in Server_UpdateMarker");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2192544725u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerRequestEmojiData "));
				}
				TimeWarning val2 = TimeWarning.New("ServerRequestEmojiData", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2192544725u, "ServerRequestEmojiData", this, player, 3uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg33 = rPCMessage;
							ServerRequestEmojiData(msg33);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex40)
					{
						Debug.LogException(ex40);
						player.Kick("RPC Error in ServerRequestEmojiData");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3635568749u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerRPC_UnderwearChange "));
				}
				TimeWarning val2 = TimeWarning.New("ServerRPC_UnderwearChange", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg34 = rPCMessage;
						ServerRPC_UnderwearChange(msg34);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex41)
				{
					Debug.LogException(ex41);
					player.Kick("RPC Error in ServerRPC_UnderwearChange");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3222472445u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - StartTutorial "));
				}
				TimeWarning val2 = TimeWarning.New("StartTutorial", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg35 = rPCMessage;
						StartTutorial(msg35);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex42)
				{
					Debug.LogException(ex42);
					player.Kick("RPC Error in StartTutorial");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 970114602 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_Drink "));
				}
				TimeWarning val2 = TimeWarning.New("SV_Drink", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg36 = rPCMessage;
						SV_Drink(msg36);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex43)
				{
					Debug.LogException(ex43);
					player.Kick("RPC Error in SV_Drink");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1361044246 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - UpdateSpectatePositionFromDebugCamera "));
				}
				TimeWarning val2 = TimeWarning.New("UpdateSpectatePositionFromDebugCamera", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1361044246u, "UpdateSpectatePositionFromDebugCamera", this, player, 10uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(1361044246u, "UpdateSpectatePositionFromDebugCamera", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg37 = rPCMessage;
							UpdateSpectatePositionFromDebugCamera(msg37);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex44)
					{
						Debug.LogException(ex44);
						player.Kick("RPC Error in UpdateSpectatePositionFromDebugCamera");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public void ToggleShowFSMStateDebugInfo()
	{
		if (!((FacepunchBehaviour)this).IsInvoking((Action)ShowStateDebugInfo))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)ShowStateDebugInfo, 0f, 0.1f);
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)ShowStateDebugInfo);
		}
	}

	private void ShowStateDebugInfo()
	{
		FSMComponent.ShowDebugInfoAroundLocation(this);
	}

	public bool TriggeredAntiHack(float seconds = 1f, float score = float.PositiveInfinity)
	{
		if (!(Time.realtimeSinceStartup - lastViolationTime < seconds))
		{
			return violationLevel > score;
		}
		return true;
	}

	public bool TriggeredMovementAntiHack(float seconds = 1f)
	{
		return Time.realtimeSinceStartup - lastMovementViolationTime < seconds;
	}

	public bool UsedAdminCheat(float seconds = 2f)
	{
		return Time.realtimeSinceStartup - lastAdminCheatTime < seconds;
	}

	public void PauseVehicleNoClipDetection(float seconds = 1f)
	{
		vehiclePauseTime = Mathf.Max(vehiclePauseTime, seconds);
	}

	public void PauseFlyHackDetection(float seconds = 1f)
	{
		flyhackPauseTime = Mathf.Max(flyhackPauseTime, seconds);
	}

	public void AddTempSpeedHackBudget(float totalDistanceExpected = 1f, float seconds = 1f)
	{
		speedhackExtraSpeed = totalDistanceExpected / seconds;
		speedhackExtraSpeedTime = seconds;
	}

	public void PauseSpeedHackDetection(float seconds = 1f)
	{
		speedhackPauseTime = Mathf.Max(speedhackPauseTime, seconds);
	}

	public void PauseTickDistanceDetection(float seconds = 1f)
	{
		tickDistancePausetime = Mathf.Max(tickDistancePausetime, seconds);
	}

	public void ForceCastNoClip(float seconds = 1f)
	{
		forceCastTime = Mathf.Max(forceCastTime, seconds);
	}

	public bool RecentlyInAir(float seconds = 1f)
	{
		return Time.realtimeSinceStartup - lastInAirTime < seconds;
	}

	public int GetAntiHackKicks()
	{
		return AntiHack.GetKickRecord(this);
	}

	public void ResetAntiHack()
	{
		violationLevel = 0f;
		lastViolationTime = 0f;
		lastAdminCheatTime = 0f;
		speedhackPauseTime = 0f;
		speedhackExtraSpeedTime = 0f;
		speedhackDistance = 0f;
		speedhackExtraSpeed = 0f;
		flyhackPauseTime = 0f;
		flyhackDistanceVertical = 0f;
		flyhackDistanceHorizontal = 0f;
		tickDistancePausetime = 0f;
		lastInAirTime = 0f;
		rpcHistory.Clear();
	}

	public bool CanModifyClan()
	{
		if (!Clan.editsRequireClanTable)
		{
			return true;
		}
		if (base.isServer)
		{
			if (triggers == null || (Object)(object)ClanManager.ServerInstance == (Object)null)
			{
				return false;
			}
			foreach (TriggerBase trigger in triggers)
			{
				if (trigger is TriggerClanModify)
				{
					return true;
				}
			}
			return false;
		}
		return false;
	}

	public void LoadClanInfo()
	{
		ClanManager clanManager = ClanManager.ServerInstance;
		if (!((Object)(object)clanManager == (Object)null))
		{
			LoadClanInfoImpl();
		}
		async void LoadClanInfoImpl()
		{
			try
			{
				ClanValueResult<IClan> val = await clanManager.Backend.GetByMember((ulong)userID);
				if (!val.IsSuccess)
				{
					if ((int)val.Result != 3)
					{
						Debug.LogError((object)$"Failed to find clan for {userID.Get()}: {val.Result}");
						((FacepunchBehaviour)this).Invoke((Action)LoadClanInfo, (float)(45 + Random.Range(0, 30)));
						return;
					}
					serverClan = null;
					clanId = 0L;
				}
				else
				{
					serverClan = val.Value;
					clanId = serverClan.ClanId;
				}
				SendNetworkUpdate();
				Networkable obj = net;
				if (((obj != null) ? obj.connection : null) != null)
				{
					UpdateClanLastSeen();
					if (clanId != 0L)
					{
						clanManager.ClanMemberConnectionsChanged(clanId);
					}
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}
	}

	public void UpdateClanLastSeen()
	{
		ClanManager clanManager = ClanManager.ServerInstance;
		if (!((Object)(object)clanManager == (Object)null) && clanId != 0L)
		{
			UpdateClanLastSeenImpl();
		}
		async void UpdateClanLastSeenImpl()
		{
			_ = 1;
			try
			{
				ClanValueResult<IClan> val = await clanManager.Backend.Get(clanId);
				if (!val.IsSuccess)
				{
					LoadClanInfo();
				}
				else
				{
					ClanResult val2 = await val.Value.UpdateLastSeen((ulong)userID);
					if ((int)val2 != 1)
					{
						Debug.LogWarning((object)$"Couldn't update clan last seen for {userID.Get()}: {val2}");
					}
				}
			}
			catch (Exception arg)
			{
				Debug.LogError((object)$"Failed to update clan last seen for {userID.Get()}: {arg}");
			}
		}
	}

	public void AddClanScore(ClanScoreEventType type, int multiplier = 1, BasePlayer otherPlayer = null, IClan otherClan = null, string arg1 = null, string arg2 = null)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		ClanManager serverInstance = ClanManager.ServerInstance;
		if (!((Object)(object)serverInstance == (Object)null) && serverClan != null && !IsBot && !IsNpc && multiplier != 0)
		{
			int scoreForEvent = Clan.GetScoreForEvent(type);
			if (scoreForEvent != 0)
			{
				bool flag = (Object)(object)otherPlayer != (Object)null && !otherPlayer.IsBot && !otherPlayer.IsNpc;
				serverInstance.AddScore(serverClan, new ClanScoreEvent
				{
					Type = type,
					SteamId = userID,
					Score = scoreForEvent,
					Multiplier = multiplier,
					OtherSteamId = (flag ? new ulong?(otherPlayer.userID) : ((ulong?)null)),
					OtherClanId = ((otherClan != null && otherClan != serverClan) ? new long?(otherClan.ClanId) : ((flag && otherPlayer.clanId != 0L) ? new long?(otherPlayer.clanId) : ((long?)null))),
					Arg1 = arg1,
					Arg2 = arg2
				});
			}
		}
	}

	private void HandleClanPlayerKilled(BasePlayer killedByPlayer)
	{
		if (serverClan != null && killedByPlayer.serverClan != null && serverClan != killedByPlayer.serverClan)
		{
			AddClanScore((ClanScoreEventType)2, 1, killedByPlayer);
			killedByPlayer.AddClanScore((ClanScoreEventType)1, 1, this);
		}
		if (!HasPlayerFlag(PlayerFlags.DisplaySash) && killedByPlayer.serverClan != null)
		{
			killedByPlayer.AddClanScore((ClanScoreEventType)3, 1, this);
		}
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		object obj = Interface.CallHook("CanLootPlayer", (object)this, (object)player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((Object)(object)player == (Object)(object)this)
		{
			return false;
		}
		if ((IsWounded() || IsSleeping() || CurrentGestureIsSurrendering || IsRestrainedOrSurrendering) && !IsLoadingAfterTransfer())
		{
			return !IsTransferring();
		}
		return false;
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_LootPlayer(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (Object.op_Implicit((Object)(object)player) && player.CanInteract() && CanBeLooted(player) && player.inventory.loot.StartLootingEntity(this))
		{
			player.inventory.loot.AddContainer(inventory.containerMain);
			player.inventory.loot.AddContainer(inventory.containerWear);
			player.inventory.loot.AddContainer(inventory.containerBelt);
			Interface.CallHook("OnLootPlayer", (object)this, (object)player);
			player.inventory.loot.SendImmediate();
			player.RadioactiveLootCheck(player.inventory.loot.containers);
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), "player_corpse");
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_Assist(RPCMessage msg)
	{
		if (msg.player.CanInteract() && !((Object)(object)msg.player == (Object)(object)this) && IsWounded() && Interface.CallHook("OnPlayerAssist", (object)this, (object)msg.player) == null)
		{
			StopWounded(msg.player);
			msg.player.stats.Add("wounded_assisted", 1, (Stats)5);
			stats.Add("wounded_healed", 1);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_KeepAlive(RPCMessage msg)
	{
		if (msg.player.CanInteract() && !((Object)(object)msg.player == (Object)(object)this) && IsWounded() && Interface.CallHook("OnPlayerKeepAlive", (object)this, (object)msg.player) == null)
		{
			ProlongWounding(10f);
		}
	}

	[RPC_Server]
	private void SV_Drink(RPCMessage msg)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		Vector3 val = msg.read.Vector3();
		if (!Vector3Ex.IsNaNOrInfinity(val) && Object.op_Implicit((Object)(object)player) && player.metabolism.CanConsume() && !(Vector3.Distance(((Component)player).transform.position, val) > 5f) && WaterLevel.Test(val, waves: true, volumes: true, this) && (!isMounted || GetMounted().canDrinkWhileMounted))
		{
			ItemDefinition itemDefinition = WaterResource.SV_GetAtPoint(val);
			ItemModConsumable component = ((Component)itemDefinition).GetComponent<ItemModConsumable>();
			Item item = ItemManager.Create(itemDefinition, component.amountToConsume, 0uL);
			ItemModConsume component2 = ((Component)item.info).GetComponent<ItemModConsume>();
			if (component2.CanDoAction(item, player))
			{
				component2.DoAction(item, player);
			}
			item?.Remove();
			player.metabolism.MarkConsumption();
		}
	}

	[RPC_Server]
	public void RPC_StartClimb(RPCMessage msg)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		bool flag = msg.read.Bit();
		Vector3 val = msg.read.Vector3();
		NetworkableId val2 = msg.read.EntityID();
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(val2);
		Vector3 val3 = (flag ? ((Component)baseNetworkable).transform.TransformPoint(val) : val);
		if (player.IsRestrained || !player.isMounted || player.Distance(val3) > 5f || !GamePhysics.LineOfSight(player.eyes.position, val3, 1218519041) || !GamePhysics.LineOfSight(val3, val3 + player.eyes.offset, 1218519041))
		{
			return;
		}
		Vector3 val4 = val3 - player.eyes.position;
		Vector3 end = val3 - ((Vector3)(ref val4)).normalized * 0.25f;
		if (!GamePhysics.CheckCapsule(player.eyes.position, end, 0.25f, 1218519041, (QueryTriggerInteraction)0) && !AntiHack.TestNoClipping(player, val3 + NoClipOffset(), val3 + NoClipOffset(), NoClipRadius(ConVar.AntiHack.noclip_margin), ConVar.AntiHack.noclip_backtracking, out var _))
		{
			player.EnsureDismounted();
			((Component)player).transform.position = val3;
			Collider component = ((Component)player).GetComponent<Collider>();
			component.enabled = false;
			component.enabled = true;
			player.ForceUpdateTriggers();
			if (flag)
			{
				player.ClientRPC(RpcTarget.Player("ForcePositionToParentOffset", player), val, val2);
			}
			else
			{
				player.ClientRPC(RpcTarget.Player("ForcePositionTo", player), val3);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	private void RequestServerEmoji()
	{
		RustEmojiLibrary.FindAllServerEmoji();
		if (RustEmojiLibrary.allServerEmoji.Count > 0)
		{
			ClientRPCPlayerList(null, this, "ClientReceiveEmojiList", RustEmojiLibrary.cachedServerList);
		}
	}

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	private void ServerRequestEmojiData(RPCMessage msg)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		string text = msg.read.String(256, false);
		if (RustEmojiLibrary.allServerEmoji.TryGetValue(text, out var value))
		{
			byte[] array = FileStorage.server.Get(value.CRC, value.FileType, RustEmojiLibrary.EmojiStorageNetworkId);
			ClientRPC(RpcTarget.Player("ClientReceiveEmojiData", msg.player), (uint)array.Length, array, text, value.CRC, (int)value.FileType);
		}
	}

	public int GetQueuedUpdateCount(NetworkQueue queue)
	{
		return networkQueue[(int)queue].Length;
	}

	public void SendSnapshots(ListHashSet<Networkable> ents)
	{
		TimeWarning val = TimeWarning.New("SendSnapshots", 0);
		try
		{
			int count = ents.Values.Count;
			Networkable[] buffer = ents.Values.Buffer;
			for (int i = 0; i < count; i++)
			{
				SnapshotQueue.Add(buffer[i].handler as BaseNetworkable);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void QueueUpdate(NetworkQueue queue, BaseNetworkable ent)
	{
		if (!IsConnected)
		{
			return;
		}
		switch (queue)
		{
		case NetworkQueue.Update:
			networkQueue[0].Add(ent);
			break;
		case NetworkQueue.UpdateDistance:
			if (!IsReceivingSnapshot && !networkQueue[1].Contains(ent) && !networkQueue[0].Contains(ent))
			{
				NetworkQueueList networkQueueList = networkQueue[1];
				if (Distance(ent as BaseEntity) < 20f)
				{
					QueueUpdate(NetworkQueue.Update, ent);
				}
				else
				{
					networkQueueList.Add(ent);
				}
			}
			break;
		}
	}

	public void SendEntityUpdate()
	{
		TimeWarning val = TimeWarning.New("SendEntityUpdate", 0);
		try
		{
			SendEntityUpdates(SnapshotQueue);
			SendEntityUpdates(networkQueue[0]);
			SendEntityUpdates(networkQueue[1]);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void ClearEntityQueue(Group group = null)
	{
		SnapshotQueue.Clear(group);
		networkQueue[0].Clear(group);
		networkQueue[1].Clear(group);
	}

	private void SendEntityUpdates(NetworkQueueList queue)
	{
		if (queue.queueInternal.Count == 0)
		{
			return;
		}
		int num = (IsReceivingSnapshot ? ConVar.Server.updatebatchspawn : ConVar.Server.updatebatch);
		List<BaseNetworkable> list = Pool.Get<List<BaseNetworkable>>();
		TimeWarning val = TimeWarning.New("SendEntityUpdates.SendEntityUpdates", 0);
		try
		{
			int num2 = 0;
			foreach (BaseNetworkable item in queue.queueInternal)
			{
				SendEntitySnapshot(item);
				list.Add(item);
				num2++;
				if (num2 > num)
				{
					break;
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		if (num > queue.queueInternal.Count)
		{
			queue.queueInternal.Clear();
		}
		else
		{
			val = TimeWarning.New("SendEntityUpdates.Remove", 0);
			try
			{
				for (int i = 0; i < list.Count; i++)
				{
					queue.queueInternal.Remove(list[i]);
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		if (queue.queueInternal.Count == 0 && queue.MaxLength > 2048)
		{
			queue.queueInternal.Clear();
			queue.queueInternal = new HashSet<BaseNetworkable>();
			queue.MaxLength = 0;
		}
		Pool.FreeUnmanaged<BaseNetworkable>(ref list);
	}

	public void SendEntitySnapshot(BaseNetworkable ent)
	{
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnEntitySnapshot", (object)ent, (object)net.connection) != null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("SendEntitySnapshot", 0);
		try
		{
			if (!((Object)(object)ent == (Object)null) && ent.net != null && ent.ShouldNetworkTo(this))
			{
				NetWrite val2 = ((BaseNetwork)Net.sv).StartWrite();
				net.connection.validate.entityUpdates++;
				SaveInfo saveInfo = default(SaveInfo);
				saveInfo.forConnection = net.connection;
				saveInfo.forDisk = false;
				SaveInfo saveInfo2 = saveInfo;
				val2.PacketID((Type)5);
				val2.UInt32(net.connection.validate.entityUpdates);
				ent.ToStreamForNetwork((Stream)(object)val2, saveInfo2);
				val2.Send(new SendInfo(net.connection));
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool HasPlayerFlag(PlayerFlags f)
	{
		return (playerFlags & f) == f;
	}

	public void SetPlayerFlag(PlayerFlags f, bool b)
	{
		if (b)
		{
			if (HasPlayerFlag(f))
			{
				return;
			}
			playerFlags |= f;
		}
		else
		{
			if (!HasPlayerFlag(f))
			{
				return;
			}
			playerFlags &= ~f;
		}
		SendNetworkUpdate();
	}

	public void LightToggle(bool mask = true)
	{
		Item activeItem = GetActiveItem();
		if (activeItem != null)
		{
			BaseEntity heldEntity = activeItem.GetHeldEntity();
			if ((Object)(object)heldEntity != (Object)null)
			{
				HeldEntity component = ((Component)heldEntity).GetComponent<HeldEntity>();
				if (Object.op_Implicit((Object)(object)component))
				{
					((Component)component).SendMessage("SetLightsOn", (object)(mask && !component.LightsOn()), (SendMessageOptions)1);
				}
			}
		}
		foreach (Item item in inventory.containerWear.itemList)
		{
			ItemModWearable component2 = ((Component)item.info).GetComponent<ItemModWearable>();
			if (Object.op_Implicit((Object)(object)component2) && component2.emissive)
			{
				item.SetFlag(Item.Flag.IsOn, mask && !item.HasFlag(Item.Flag.IsOn));
				item.MarkDirty();
			}
		}
		if (isMounted)
		{
			GetMounted().LightToggle(this);
		}
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(16uL)]
	public void FogImageUpdate(RPCMessage msg)
	{
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		byte b = msg.read.UInt8();
		byte b2 = msg.read.UInt8();
		uint num = msg.read.UInt32();
		if (State.fogImages == null || State.fogImages.Count != 16)
		{
			State.fogImages = (List<uint>)(object)Pool.Get<PooledList<uint>>();
			for (int i = 0; i < 16; i++)
			{
				State.fogImages.Add(0u);
			}
		}
		if (b != 0 || State.fogImages[b2] != num)
		{
			uint num2 = (uint)(b * 1000 + b2);
			byte[] array = msg.read.BytesWithSize(10485760u, false);
			if (array != null)
			{
				FileStorage.server.RemoveEntityNum(net.ID, num2);
				uint value = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, num2);
				State.fogImages[b2] = value;
				DirtyPlayerState();
			}
		}
	}

	private void OnFogOfWarStale()
	{
		if (State.fogImages == null)
		{
			State.fogImages = (List<uint>)(object)Pool.Get<PooledList<uint>>();
		}
		State.fogImages.Clear();
		for (int i = 0; i < 16; i++)
		{
			State.fogImages.Add(0u);
		}
	}

	private RPSWinState Opposite(RPSWinState state)
	{
		return state switch
		{
			RPSWinState.Win => RPSWinState.Loss, 
			RPSWinState.Loss => RPSWinState.Win, 
			_ => state, 
		};
	}

	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	public void Server_StartGesture(RPCMessage msg)
	{
		if (!IsGestureBlocked())
		{
			uint id = msg.read.UInt32();
			GestureConfig toPlay = GestureCollection.Instance.IdToGesture(id);
			Server_StartGesture(toPlay);
		}
	}

	public void Server_StartGesture(uint gestureId)
	{
		GestureConfig toPlay = GestureCollection.Instance.IdToGesture(gestureId);
		Server_StartGesture(toPlay);
	}

	public void Server_StartGesture(GestureConfig toPlay, GestureStartSource startSource = GestureStartSource.Player, bool bypassOwnershipCheck = false)
	{
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		if (((Object)(object)toPlay != (Object)null && toPlay.hideInWheel && startSource == GestureStartSource.Player && !ConVar.Server.cinematic) || !((Object)(object)toPlay != (Object)null) || (!bypassOwnershipCheck && startSource != 0 && !toPlay.IsOwnedBy(this)) || !toPlay.CanBeUsedBy(this))
		{
			return;
		}
		if (toPlay.animationType == GestureConfig.AnimationType.OneShot)
		{
			((FacepunchBehaviour)this).Invoke((Action)TimeoutGestureServer, toPlay.duration);
		}
		else if (toPlay.animationType == GestureConfig.AnimationType.Loop)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)MonitorLoopingGesture, 0f, 0f);
		}
		ClientRPC(RpcTarget.NetworkGroup("Client_StartGesture"), toPlay.gestureId);
		gestureFinishedTime = TimeUntil.op_Implicit(toPlay.duration);
		currentGesture = toPlay;
		switch (toPlay.actionType)
		{
		case GestureConfig.GestureActionType.Surrender:
			inventory.SetLockedByRestraint(flag: true);
			break;
		case GestureConfig.GestureActionType.ShowNameTag:
			if (GameInfo.HasAchievements)
			{
				int val = CountWaveTargets(((Component)this).transform.position, 4f, 0.6f, eyes.HeadForward(), recentWaveTargets, 5);
				stats.Add("waved_at_players", val);
				stats.Save(forceSteamSave: true);
			}
			break;
		case GestureConfig.GestureActionType.DanceAchievement:
		{
			TriggerDanceAchievement triggerDanceAchievement = FindTrigger<TriggerDanceAchievement>();
			if ((Object)(object)triggerDanceAchievement != (Object)null)
			{
				triggerDanceAchievement.NotifyDanceStarted();
			}
			break;
		}
		}
		if (startSource == GestureStartSource.Player && toPlay.hasMultiplayerInteraction)
		{
			SetPlayerFlag(PlayerFlags.WaitingForGestureInteraction, b: true);
		}
		if (toPlay.animationType == GestureConfig.AnimationType.Loop)
		{
			SendNetworkUpdate();
		}
	}

	private void TimeoutGestureServer()
	{
		currentGesture = null;
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(10uL)]
	[RPC_Server.FromOwner(false)]
	public void Server_CancelGesture()
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)currentGesture != (Object)null && currentGesture.actionType == GestureConfig.GestureActionType.Surrender)
		{
			Handcuffs handcuffs = GetHeldEntity() as Handcuffs;
			if ((Object)(object)handcuffs == (Object)null || !handcuffs.Locked)
			{
				inventory.SetLockedByRestraint(flag: false);
			}
		}
		currentGesture = null;
		blockHeldInputTimer = TimeSince.op_Implicit(0f);
		SetPlayerFlag(PlayerFlags.WaitingForGestureInteraction, b: false);
		ClientRPC(RpcTarget.NetworkGroup("Client_RemoteCancelledGesture"));
		((FacepunchBehaviour)this).CancelInvoke((Action)MonitorLoopingGesture);
		((FacepunchBehaviour)this).CancelInvoke((Action)TimeoutGestureServer);
	}

	private void MonitorLoopingGesture()
	{
		bool flag = (Object)(object)currentGesture != (Object)null && currentGesture.canDuckDuringGesture;
		if (modelState == null || (!flag && modelState.ducked) || modelState.sleeping || IsWounded() || IsSwimming() || IsDead() || (isMounted && GetMounted().allowedGestures == BaseMountable.MountGestureType.UpperBody && !CurrentGestureIsUpperBody) || (isMounted && GetMounted().allowedGestures == BaseMountable.MountGestureType.None))
		{
			Server_CancelGesture();
		}
	}

	private void NotifyGesturesNewItemEquipped()
	{
		if (InGesture)
		{
			Server_CancelGesture();
		}
	}

	public int CountWaveTargets(Vector3 position, float distance, float minimumDot, Vector3 forward, HashSet<NetworkableId> workingList, int maxCount)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		float sqrDistance = distance * distance;
		Group group = net.group;
		if (group == null)
		{
			return 0;
		}
		List<Connection> subscribers = group.subscribers;
		int num = 0;
		for (int i = 0; i < subscribers.Count; i++)
		{
			Connection val = subscribers[i];
			if (!val.active)
			{
				continue;
			}
			BasePlayer basePlayer = val.player as BasePlayer;
			if (CheckPlayer(basePlayer))
			{
				workingList.Add(basePlayer.net.ID);
				num++;
				if (num >= maxCount)
				{
					break;
				}
			}
		}
		return num;
		bool CheckPlayer(BasePlayer player)
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)player == (Object)null)
			{
				return false;
			}
			if ((Object)(object)player == (Object)(object)this)
			{
				return false;
			}
			if (player.SqrDistance(position) > sqrDistance)
			{
				return false;
			}
			Vector3 val2 = ((Component)player).transform.position - position;
			if (Vector3.Dot(((Vector3)(ref val2)).normalized, forward) < minimumDot)
			{
				return false;
			}
			if (workingList.Contains(player.net.ID))
			{
				return false;
			}
			return true;
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RequestJoinGesture(RPCMessage msg)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId uid = msg.read.EntityID();
		BasePlayer basePlayer = BaseNetworkable.serverEntities.Find(uid) as BasePlayer;
		if (!HasPlayerFlag(PlayerFlags.WaitingForGestureInteraction) || !InGesture || (Object)(object)currentGesture == (Object)null)
		{
			return;
		}
		interactiveGestureStartTime = TimeSince.op_Implicit(0f);
		if ((Object)(object)msg.player != (Object)(object)basePlayer || !((Object)(object)basePlayer != (Object)null))
		{
			return;
		}
		SetPlayerFlag(PlayerFlags.WaitingForGestureInteraction, b: false);
		if (currentGesture.actionType == GestureConfig.GestureActionType.RockPaperScissors)
		{
			rpsTarget = uid;
			basePlayer.rpsTarget = net.ID;
			basePlayer.Server_StartGesture(GestureCollection.Instance.StringToGesture("rps"), GestureStartSource.ServerAction);
			ClientRPC(RpcTarget.Player("PromptToPickRPSHand", basePlayer), 10f);
			ClientRPC(RpcTarget.Player("PromptToPickRPSHand", this), 10f);
			if (basePlayer.IsBot)
			{
				((FacepunchBehaviour)basePlayer).Invoke((Action)BotRPSRandomise, 2f);
			}
			if (IsBot)
			{
				((FacepunchBehaviour)this).Invoke((Action)BotRPSRandomise, 2f);
			}
			((FacepunchBehaviour)this).InvokeRepeating((Action)MonitorRPSGame, 0f, 0f);
		}
	}

	private void BotRPSRandomise()
	{
		selectedRpsOption = Random.Range(0, 3);
		Debug.Log((object)$"Bot randomly selected {selectedRpsOption}");
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	private void SelectedRPSOption(RPCMessage msg)
	{
		selectedRpsOption = msg.read.Int32();
	}

	private void MonitorRPSGame()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		BasePlayer basePlayer = BaseNetworkable.serverEntities.Find(rpsTarget) as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null || Distance((BaseEntity)basePlayer) > 5f || IsWounded() || basePlayer.IsWounded() || IsDead() || basePlayer.IsDead())
		{
			flag = true;
		}
		if (!flag && TimeSince.op_Implicit(interactiveGestureStartTime) > 10f)
		{
			flag = true;
		}
		if (flag)
		{
			ClientRPC(RpcTarget.Player("CancelRPSGame", this));
			Server_CancelGesture();
			if ((Object)(object)basePlayer != (Object)null)
			{
				ClientRPC(RpcTarget.Player("CancelRPSGame", basePlayer));
				basePlayer.Server_CancelGesture();
			}
			((FacepunchBehaviour)this).CancelInvoke((Action)MonitorRPSGame);
		}
		if ((Object)(object)basePlayer != (Object)null && basePlayer.selectedRpsOption != -1 && selectedRpsOption != -1)
		{
			RPSWinState rPSWinState = (((selectedRpsOption != 0 || basePlayer.selectedRpsOption != 2) && (selectedRpsOption != 1 || basePlayer.selectedRpsOption != 0) && (selectedRpsOption != 2 || basePlayer.selectedRpsOption != 1)) ? RPSWinState.Loss : RPSWinState.Win);
			if (selectedRpsOption == basePlayer.selectedRpsOption)
			{
				rPSWinState = RPSWinState.Draw;
			}
			ClientRPC(RpcTarget.NetworkGroup("OnRPSResult"), (int)rPSWinState, selectedRpsOption);
			basePlayer.ClientRPC(RpcTarget.NetworkGroup("OnRPSResult"), (int)Opposite(rPSWinState), basePlayer.selectedRpsOption);
			basePlayer.selectedRpsOption = -1;
			basePlayer.rpsTarget = default(NetworkableId);
			selectedRpsOption = -1;
			rpsTarget = default(NetworkableId);
			((FacepunchBehaviour)this).CancelInvoke((Action)MonitorRPSGame);
			float num = ((rPSWinState == RPSWinState.Draw) ? 2.5f : 5f);
			((FacepunchBehaviour)this).Invoke((Action)Server_CancelGesture, num);
			((FacepunchBehaviour)basePlayer).Invoke((Action)basePlayer.Server_CancelGesture, num);
		}
	}

	private bool IsGestureBlocked()
	{
		if (isMounted && GetMounted().allowedGestures == BaseMountable.MountGestureType.None)
		{
			return true;
		}
		if (Object.op_Implicit((Object)(object)GetHeldEntity()) && GetHeldEntity().BlocksGestures())
		{
			return true;
		}
		bool flag = (Object)(object)currentGesture != (Object)null;
		if (flag && currentGesture.gestureType == GestureConfig.GestureType.Cinematic)
		{
			flag = false;
		}
		if (!(IsWounded() || flag) && !IsDead() && !IsSleeping())
		{
			return IsRestrained;
		}
		return true;
	}

	public void DelayedTeamUpdate()
	{
		UpdateTeam(currentTeam);
	}

	public void TeamUpdate()
	{
		TeamUpdate(fullTeamUpdate: false);
	}

	public void TeamUpdate(bool fullTeamUpdate)
	{
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		if (!RelationshipManager.TeamsEnabled() || !IsConnected || currentTeam == 0L)
		{
			return;
		}
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(currentTeam);
		if (playerTeam == null)
		{
			return;
		}
		int num = 0;
		int num2 = 0;
		PlayerTeam val = Pool.Get<PlayerTeam>();
		try
		{
			val.teamLeader = playerTeam.teamLeader;
			val.teamID = playerTeam.teamID;
			val.teamName = playerTeam.teamName;
			val.members = Pool.Get<List<TeamMember>>();
			val.teamLifetime = playerTeam.teamLifetime;
			val.teamPings = Pool.Get<List<MapNote>>();
			foreach (ulong member in playerTeam.members)
			{
				BasePlayer basePlayer = RelationshipManager.FindByID(member);
				if (Object.op_Implicit((Object)(object)basePlayer) && basePlayer.IsInTutorial)
				{
					continue;
				}
				TeamMember val2 = Pool.Get<TeamMember>();
				val2.displayName = (((Object)(object)basePlayer != (Object)null) ? basePlayer.displayName : (SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(member) ?? "DEAD"));
				val2.healthFraction = (((Object)(object)basePlayer != (Object)null && basePlayer.IsAlive()) ? basePlayer.healthFraction : 0f);
				val2.position = (((Object)(object)basePlayer != (Object)null) ? ((Component)basePlayer).transform.position : Vector3.zero);
				val2.online = (Object)(object)basePlayer != (Object)null && !basePlayer.IsSleeping();
				val2.wounded = (Object)(object)basePlayer != (Object)null && basePlayer.IsWounded();
				if ((!sentInstrumentTeamAchievement || !sentSummerTeamAchievement) && (Object)(object)basePlayer != (Object)null)
				{
					if (Object.op_Implicit((Object)(object)basePlayer.GetHeldEntity()) && basePlayer.GetHeldEntity().IsInstrument())
					{
						num++;
					}
					if (basePlayer.isMounted)
					{
						if (basePlayer.GetMounted().IsInstrument())
						{
							num++;
						}
						if (basePlayer.GetMounted().IsSummerDlcVehicle)
						{
							num2++;
						}
					}
					if (num >= 4 && !sentInstrumentTeamAchievement)
					{
						GiveAchievement("TEAM_INSTRUMENTS");
						sentInstrumentTeamAchievement = true;
					}
					if (num2 >= 4)
					{
						GiveAchievement("SUMMER_INFLATABLE");
						sentSummerTeamAchievement = true;
					}
				}
				val2.userID = member;
				val.members.Add(val2);
				if ((Object)(object)basePlayer != (Object)null)
				{
					if (basePlayer.State.pings != null && basePlayer.State.pings.Count > 0 && (Object)(object)basePlayer != (Object)(object)this)
					{
						val.teamPings.AddRange(basePlayer.State.pings);
					}
					if (fullTeamUpdate && (Object)(object)basePlayer != (Object)(object)this)
					{
						basePlayer.TeamUpdate(fullTeamUpdate: false);
					}
				}
			}
			val.leaderMapNotes = Pool.Get<List<MapNote>>();
			PlayerState val3 = SingletonComponent<ServerMgr>.Instance.playerStateManager.Get(playerTeam.teamLeader);
			if (val3?.pointsOfInterest != null)
			{
				foreach (MapNote item in val3.pointsOfInterest)
				{
					val.leaderMapNotes.Add(item);
				}
			}
			if (Interface.CallHook("OnTeamUpdated", (object)currentTeam, (object)val, (object)this) == null)
			{
				ClientRPC(RpcTarget.PlayerAndSpectators("CLIENT_ReceiveTeamInfo", this), val);
				if (val.leaderMapNotes != null)
				{
					val.leaderMapNotes.Clear();
				}
				if (val.teamPings != null)
				{
					val.teamPings.Clear();
				}
				BasePlayer basePlayer2 = FindByID(playerTeam.teamLeader);
				if (fullTeamUpdate && (Object)(object)basePlayer2 != (Object)null && (Object)(object)basePlayer2 != (Object)(object)this)
				{
					basePlayer2.TeamUpdate(fullTeamUpdate: false);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void UpdateTeam(ulong newTeam)
	{
		if (Interface.CallHook("OnTeamUpdate", (object)currentTeam, (object)newTeam, (object)this) == null)
		{
			currentTeam = newTeam;
			SendNetworkUpdate();
			if (RelationshipManager.ServerInstance.FindTeam(newTeam) == null)
			{
				ClearTeam();
			}
			else
			{
				TeamUpdate();
			}
		}
	}

	public void ClearTeam()
	{
		currentTeam = 0uL;
		ClientRPC(RpcTarget.PlayerAndSpectators("CLIENT_ClearTeam", this));
		SendNetworkUpdate();
	}

	public void ClearPendingInvite()
	{
		ClientRPC(RpcTarget.Player("CLIENT_PendingInvite", this), "", 0uL, 0uL);
	}

	public HeldEntity GetHeldEntity()
	{
		if (base.isServer)
		{
			Item activeItem = GetActiveItem();
			if (activeItem == null)
			{
				return null;
			}
			return activeItem.GetHeldEntity() as HeldEntity;
		}
		return null;
	}

	public bool IsHoldingEntity<T>()
	{
		HeldEntity heldEntity = GetHeldEntity();
		if ((Object)(object)heldEntity == (Object)null)
		{
			return false;
		}
		return heldEntity is T;
	}

	public Shield GetActiveShield()
	{
		if (!Object.op_Implicit((Object)(object)GetHeldEntity()))
		{
			return null;
		}
		if (!GetHeldEntity().canBeUsedWithShield)
		{
			return null;
		}
		Item anyBackpack = inventory.GetAnyBackpack();
		ItemModShield itemModShield = default(ItemModShield);
		if (anyBackpack != null && ((Component)anyBackpack.info).TryGetComponent<ItemModShield>(ref itemModShield))
		{
			return anyBackpack.GetHeldEntity() as Shield;
		}
		return null;
	}

	public bool GetActiveShield(out Shield foundShield)
	{
		foundShield = null;
		if (!Object.op_Implicit((Object)(object)GetHeldEntity()))
		{
			return false;
		}
		if (!GetHeldEntity().canBeUsedWithShield)
		{
			return false;
		}
		Item anyBackpack = inventory.GetAnyBackpack();
		ItemModShield itemModShield = default(ItemModShield);
		if (anyBackpack != null && ((Component)anyBackpack.info).TryGetComponent<ItemModShield>(ref itemModShield))
		{
			foundShield = anyBackpack.GetHeldEntity() as Shield;
			return (Object)(object)foundShield != (Object)null;
		}
		return false;
	}

	public bool IsHostileItem(Item item)
	{
		if (!item.info.isHoldable)
		{
			return false;
		}
		ItemModEntity component = ((Component)item.info).GetComponent<ItemModEntity>();
		if ((Object)(object)component == (Object)null)
		{
			return false;
		}
		GameObject val = component.entityPrefab.Get();
		if ((Object)(object)val == (Object)null)
		{
			return false;
		}
		AttackEntity component2 = val.GetComponent<AttackEntity>();
		if ((Object)(object)component2 == (Object)null)
		{
			return false;
		}
		return component2.hostile;
	}

	public bool IsItemHoldRestricted(Item item)
	{
		if (IsNpc)
		{
			return false;
		}
		if (InSafeZone() && item != null && IsHostileItem(item))
		{
			return true;
		}
		return false;
	}

	public virtual void HeldEntityServerTick()
	{
		HeldEntity heldEntity = GetHeldEntity();
		if ((Object)(object)heldEntity != (Object)null)
		{
			heldEntity.ServerTick(this);
			if (heldEntity.canBeUsedWithShield && GetActiveShield(out var foundShield))
			{
				foundShield.ServerTick(this);
			}
		}
	}

	public void ClearDeathMarker(bool sendToClient = false)
	{
		if (!IsNpc)
		{
			if (ServerCurrentDeathNote != null)
			{
				Pool.Free<MapNote>(ref State.deathMarker);
			}
			DirtyPlayerState();
			if (sendToClient)
			{
				SendMarkersToClient();
			}
		}
	}

	public void Server_LogDeathMarker(Vector3 position)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (!IsNpc)
		{
			if (ServerCurrentDeathNote == null)
			{
				ServerCurrentDeathNote = Pool.Get<MapNote>();
				ServerCurrentDeathNote.noteType = 0;
			}
			ServerCurrentDeathNote.worldPosition = position;
			ClientRPC(RpcTarget.Player("Client_AddNewDeathMarker", this), ServerCurrentDeathNote);
			DirtyPlayerState();
		}
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(8uL)]
	public void Server_AddMarker(RPCMessage msg)
	{
		MapNote val = msg.read.Proto<MapNote>((MapNote)null);
		if (Interface.CallHook("OnMapMarkerAdd", (object)this, (object)val) != null || !CanUseMapMarkers)
		{
			return;
		}
		if (State.pointsOfInterest == null)
		{
			State.pointsOfInterest = Pool.Get<List<MapNote>>();
		}
		if (State.pointsOfInterest.Count >= ConVar.Server.maximumMapMarkers)
		{
			msg.player.ShowToast(GameTip.Styles.Blue_Short, MarkerLimitPhrase, false, ConVar.Server.maximumMapMarkers.ToString());
			return;
		}
		if (val.label == "auto-name")
		{
			int num = FindUnusedNumberName();
			if (num != -1)
			{
				val.label = num.ToString();
			}
		}
		ValidateMapNote(val);
		if (val.colourIndex == -1)
		{
			val.colourIndex = FindUnusedPointOfInterestColour();
		}
		State.pointsOfInterest.Add(val);
		DirtyPlayerState();
		SendMarkersToClient();
		TeamUpdate();
		Interface.CallHook("OnMapMarkerAdded", (object)this, (object)val);
	}

	private int FindUnusedNumberName(int maxToCheck = 100)
	{
		List<MapNote> pointsOfInterest = State.pointsOfInterest;
		for (int i = 1; i < maxToCheck; i++)
		{
			bool flag = false;
			foreach (MapNote item in pointsOfInterest)
			{
				if (item.label == i.ToString())
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return i;
			}
		}
		return -1;
	}

	private int FindUnusedPointOfInterestColour()
	{
		if (State.pointsOfInterest == null)
		{
			return 0;
		}
		int num = 0;
		for (int i = 0; i < 6; i++)
		{
			if (HasColour(num))
			{
				num++;
			}
		}
		return num;
		bool HasColour(int index)
		{
			foreach (MapNote item in State.pointsOfInterest)
			{
				if (item.colourIndex == index)
				{
					return true;
				}
			}
			return false;
		}
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(1uL)]
	public void Server_UpdateMarker(RPCMessage msg)
	{
		if (State.pointsOfInterest == null)
		{
			State.pointsOfInterest = Pool.Get<List<MapNote>>();
		}
		int num = msg.read.Int32();
		if (State.pointsOfInterest.Count <= num)
		{
			return;
		}
		MapNote val = msg.read.Proto<MapNote>((MapNote)null);
		try
		{
			ValidateMapNote(val);
			val.CopyTo(State.pointsOfInterest[num]);
			DirtyPlayerState();
			SendMarkersToClient();
			TeamUpdate();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void ValidateMapNote(MapNote n)
	{
		if (n.label != null)
		{
			n.label = StringExtensions.Truncate(n.label, 10, (string)null).ToUpperInvariant();
		}
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(10uL)]
	public void Server_RemovePointOfInterest(RPCMessage msg)
	{
		int num = msg.read.Int32();
		if (State.pointsOfInterest != null && State.pointsOfInterest.Count > num && num >= 0 && Interface.CallHook("OnMapMarkerRemove", (object)this, (object)State.pointsOfInterest, (object)num) == null)
		{
			State.pointsOfInterest[num].Dispose();
			State.pointsOfInterest.RemoveAt(num);
			DirtyPlayerState();
			SendMarkersToClient();
			TeamUpdate();
		}
	}

	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	public void Server_RequestMarkers(RPCMessage msg)
	{
		SendMarkersToClient();
	}

	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	public void Server_ClearMapMarkers(RPCMessage msg)
	{
		if (Interface.CallHook("OnMapMarkersClear", (object)this, (object)State.pointsOfInterest) != null)
		{
			return;
		}
		MapNote serverCurrentDeathNote = ServerCurrentDeathNote;
		if (serverCurrentDeathNote != null)
		{
			serverCurrentDeathNote.Dispose();
		}
		ServerCurrentDeathNote = null;
		if (State.pointsOfInterest != null)
		{
			foreach (MapNote item in State.pointsOfInterest)
			{
				if (item != null)
				{
					item.Dispose();
				}
			}
			State.pointsOfInterest.Clear();
		}
		DirtyPlayerState();
		TeamUpdate();
		Interface.CallHook("OnMapMarkersCleared", (object)this);
	}

	[RPC_Server.CallsPerSecond(8uL)]
	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	public void Server_ClearPointsOfInterest(RPCMessage msg)
	{
		if (State.pointsOfInterest != null)
		{
			foreach (MapNote item in State.pointsOfInterest)
			{
				if (item != null)
				{
					item.Dispose();
				}
			}
			State.pointsOfInterest.Clear();
		}
		DirtyPlayerState();
		TeamUpdate();
	}

	public void SendMarkersToClient()
	{
		MapNoteList val = Pool.Get<MapNoteList>();
		try
		{
			val.notes = Pool.Get<List<MapNote>>();
			if (ServerCurrentDeathNote != null)
			{
				val.notes.Add(ServerCurrentDeathNote);
			}
			if (State.pointsOfInterest != null)
			{
				val.notes.AddRange(State.pointsOfInterest);
			}
			Interface.CallHook("OnPlayerMarkersSend", (object)this, (object)val);
			ClientRPC(RpcTarget.Player("Client_ReceiveMarkers", this), val);
			val.notes.Clear();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool HasAttemptedMission(uint missionID)
	{
		foreach (BaseMission.MissionInstance mission in missions)
		{
			if (mission.missionID == missionID)
			{
				return true;
			}
		}
		return false;
	}

	public bool CanAcceptMission(BaseMission mission)
	{
		return CanAcceptMission(mission.id);
	}

	public bool CanAcceptMission(uint missionID)
	{
		if (HasActiveMission())
		{
			return false;
		}
		if (!BaseMission.missionsenabled)
		{
			return false;
		}
		BaseMission fromID = MissionManifest.GetFromID(missionID);
		if (fromID == null)
		{
			Debug.LogError((object)("MISSION NOT FOUND IN MANIFEST, ID :" + missionID));
			return false;
		}
		if (fromID.acceptDependancies != null && fromID.acceptDependancies.Length != 0)
		{
			BaseMission.MissionDependancy[] acceptDependancies = fromID.acceptDependancies;
			foreach (BaseMission.MissionDependancy missionDependancy in acceptDependancies)
			{
				if (missionDependancy.everAttempted)
				{
					continue;
				}
				bool flag = false;
				foreach (BaseMission.MissionInstance mission in missions)
				{
					if (mission.missionID == missionDependancy.targetMissionID && mission.status == missionDependancy.targetMissionDesiredStatus)
					{
						flag = true;
					}
				}
				if (!flag)
				{
					return false;
				}
			}
		}
		if (IsMissionActive(missionID))
		{
			return false;
		}
		if (fromID.isRepeatable)
		{
			bool num = HasCompletedMission(missionID);
			bool flag2 = HasFailedMission(missionID);
			if (num && fromID.repeatDelaySecondsSuccess <= -1)
			{
				return false;
			}
			if (flag2 && fromID.repeatDelaySecondsFailed <= -1)
			{
				return false;
			}
			foreach (BaseMission.MissionInstance mission2 in missions)
			{
				if (mission2.missionID == missionID)
				{
					float num2 = 0f;
					if (mission2.status == BaseMission.MissionStatus.Completed)
					{
						num2 = fromID.repeatDelaySecondsSuccess;
					}
					else if (mission2.status == BaseMission.MissionStatus.Failed)
					{
						num2 = fromID.repeatDelaySecondsFailed;
					}
					float endTime = mission2.endTime;
					if (Time.time - endTime < num2)
					{
						return false;
					}
				}
			}
		}
		else if (HasCompletedMission(missionID))
		{
			return false;
		}
		BaseMission.PositionGenerator[] positionGenerators = fromID.positionGenerators;
		for (int i = 0; i < positionGenerators.Length; i++)
		{
			if (!positionGenerators[i].Validate(this, fromID))
			{
				return false;
			}
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(base.isServer);
		if ((Object)(object)activeGameMode != (Object)null && activeGameMode.HasBlockedMission(fromID))
		{
			return false;
		}
		if (fromID.requiredGameModeTags.Length != 0)
		{
			if ((Object)(object)activeGameMode == (Object)null)
			{
				bool flag3 = false;
				string[] requiredGameModeTags = fromID.requiredGameModeTags;
				for (int i = 0; i < requiredGameModeTags.Length; i++)
				{
					if (string.Equals(requiredGameModeTags[i], "vanilla"))
					{
						flag3 = true;
						break;
					}
				}
				if (!flag3)
				{
					return false;
				}
			}
			else if (!activeGameMode.HasAnyGameModeTag(fromID.requiredGameModeTags))
			{
				return false;
			}
		}
		return true;
	}

	public bool IsMissionActive(uint missionID)
	{
		foreach (BaseMission.MissionInstance mission in missions)
		{
			if (mission.missionID == missionID && (mission.status == BaseMission.MissionStatus.Active || mission.status == BaseMission.MissionStatus.Accomplished))
			{
				return true;
			}
		}
		return false;
	}

	public bool HasCompletedMission(uint missionID)
	{
		foreach (BaseMission.MissionInstance mission in missions)
		{
			if (mission.missionID == missionID && mission.status == BaseMission.MissionStatus.Completed)
			{
				return true;
			}
		}
		return false;
	}

	public bool HasFailedMission(uint missionID)
	{
		foreach (BaseMission.MissionInstance mission in missions)
		{
			if (mission.missionID == missionID && mission.status == BaseMission.MissionStatus.Failed)
			{
				return true;
			}
		}
		return false;
	}

	private void WipeMissions()
	{
		if (missions.Count > 0)
		{
			for (int num = missions.Count - 1; num >= 0; num--)
			{
				BaseMission.MissionInstance missionInstance = missions[num];
				if (missionInstance != null)
				{
					missionInstance.GetMission().MissionFailed(missionInstance, this, BaseMission.MissionFailReason.ResetPlayerState);
					Pool.Free<BaseMission.MissionInstance>(ref missionInstance);
				}
			}
		}
		missions.Clear();
		SetActiveMission(-1);
		MissionDirty();
	}

	private void PrepareMissionsForTutorial()
	{
		if (missions.Count > 0)
		{
			for (int num = missions.Count - 1; num >= 0; num--)
			{
				BaseMission.MissionInstance missionInstance = missions[num];
				if (missionInstance != null)
				{
					if (missionInstance.status == BaseMission.MissionStatus.Active)
					{
						missionInstance.GetMission().MissionFailed(missionInstance, this, BaseMission.MissionFailReason.ResetPlayerState);
					}
					if (missionInstance.GetMission().IsTutorialMission)
					{
						Pool.Free<BaseMission.MissionInstance>(ref missionInstance);
						missions.RemoveAt(num);
					}
				}
			}
		}
		SetActiveMission(-1);
		MissionDirty();
	}

	public void AbandonActiveMission()
	{
		if (HasActiveMission())
		{
			int activeMission = GetActiveMission();
			if (activeMission != -1 && activeMission < missions.Count)
			{
				BaseMission.MissionInstance missionInstance = missions[activeMission];
				missionInstance.GetMission().MissionFailed(missionInstance, this, BaseMission.MissionFailReason.Abandon);
			}
		}
	}

	public void ThinkMissions(float delta)
	{
		if (!BaseMission.missionsenabled)
		{
			return;
		}
		if (timeSinceMissionThink < thinkEvery)
		{
			timeSinceMissionThink += delta;
			return;
		}
		foreach (BaseMission.MissionInstance mission in missions)
		{
			mission.Think(this, timeSinceMissionThink);
		}
		timeSinceMissionThink = 0f;
	}

	public void MissionDirty(bool shouldSendNetworkUpdate = true)
	{
		if (BaseMission.missionsenabled)
		{
			State.missions = SaveMissions();
			DirtyPlayerState();
			if (shouldSendNetworkUpdate)
			{
				SendNetworkUpdate();
			}
		}
	}

	public void ProcessMissionEvent(BaseMission.MissionEventType type, uint identifier, float amount)
	{
		ProcessMissionEvent(type, new BaseMission.MissionEventPayload
		{
			UintIdentifier = identifier
		}, amount);
	}

	public void ProcessMissionEvent(BaseMission.MissionEventType type, uint identifier, float amount, Vector3 worldPos)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		ProcessMissionEvent(type, new BaseMission.MissionEventPayload
		{
			UintIdentifier = identifier,
			WorldPosition = worldPos
		}, amount);
	}

	public void ProcessMissionEvent(BaseMission.MissionEventType type, int identifier, float amount)
	{
		ProcessMissionEvent(type, new BaseMission.MissionEventPayload
		{
			IntIdentifier = identifier
		}, amount);
	}

	public void ProcessMissionEvent(BaseMission.MissionEventType type, NetworkableId identifier, float amount)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		ProcessMissionEvent(type, new BaseMission.MissionEventPayload
		{
			NetworkIdentifier = identifier
		}, amount);
	}

	public void ProcessMissionEvent(BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		if (!BaseMission.missionsenabled || missions == null)
		{
			return;
		}
		foreach (BaseMission.MissionInstance mission in missions)
		{
			mission.ProcessMissionEvent(this, type, payload, amount);
		}
	}

	private void AssignFollowUpMission()
	{
		if (followupMission != null && followupMissionProvider != null)
		{
			BaseMission.AssignMission(this, followupMissionProvider, followupMission);
		}
		followupMission = null;
		followupMissionProvider = null;
	}

	public void RegisterFollowupMission(BaseMission targetMission, IMissionProvider provider)
	{
		followupMission = targetMission;
		followupMissionProvider = provider;
		if (followupMission != null && followupMissionProvider != null)
		{
			((FacepunchBehaviour)this).Invoke((Action)AssignFollowUpMission, 1.5f);
		}
	}

	private Missions SaveMissions()
	{
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		Missions val = Pool.Get<Missions>();
		val.missions = Pool.Get<List<MissionInstance>>();
		val.activeMission = GetActiveMission();
		foreach (BaseMission.MissionInstance mission in missions)
		{
			MissionInstance val2 = Pool.Get<MissionInstance>();
			val2.missionID = mission.missionID;
			val2.missionStatus = (uint)mission.status;
			val.missions.Add(val2);
			if (mission.status != BaseMission.MissionStatus.Active && mission.status != BaseMission.MissionStatus.Accomplished)
			{
				continue;
			}
			MissionInstanceData val3 = (val2.instanceData = Pool.Get<MissionInstanceData>());
			val3.providerID = mission.providerID;
			val3.startTime = Time.time - mission.startTime;
			val3.endTime = mission.endTime;
			val3.missionLocation = mission.missionLocation;
			val3.missionPoints = Pool.Get<List<MissionPoint>>();
			foreach (KeyValuePair<string, Vector3> missionPoint in mission.missionPoints)
			{
				MissionPoint val4 = Pool.Get<MissionPoint>();
				val4.identifier = missionPoint.Key;
				val4.location = missionPoint.Value;
				val3.missionPoints.Add(val4);
			}
			val3.objectiveStatuses = Pool.Get<List<ObjectiveStatus>>();
			BaseMission.MissionInstance.ObjectiveStatus[] objectiveStatuses = mission.objectiveStatuses;
			foreach (BaseMission.MissionInstance.ObjectiveStatus objectiveStatus in objectiveStatuses)
			{
				ObjectiveStatus val5 = Pool.Get<ObjectiveStatus>();
				val5.completed = objectiveStatus.completed;
				val5.failed = objectiveStatus.failed;
				val5.started = objectiveStatus.started;
				val5.progressCurrent = objectiveStatus.progressCurrent;
				val5.progressTarget = objectiveStatus.progressTarget;
				val3.objectiveStatuses.Add(val5);
			}
			val3.missionEntities = Pool.Get<List<MissionEntity>>();
			foreach (KeyValuePair<string, MissionEntity> missionEntity in mission.missionEntities)
			{
				BaseEntity baseEntity = (((Object)(object)missionEntity.Value != (Object)null) ? missionEntity.Value.GetEntity() : null);
				if (baseEntity.IsValid())
				{
					MissionEntity val6 = Pool.Get<MissionEntity>();
					val6.identifier = missionEntity.Key;
					val6.entityID = baseEntity.net.ID;
					val3.missionEntities.Add(val6);
				}
			}
		}
		return val;
	}

	private void OnMissionsStale()
	{
		if (State.missions != null)
		{
			State.missions.activeMission = -1;
		}
		SetActiveMission(-1);
		State.missions = SaveMissions();
	}

	public void SetActiveMission(int index)
	{
		_ = _activeMission;
		_activeMission = index;
		if (IsInTutorial && (Object)(object)GetCurrentTutorialIsland() != (Object)null)
		{
			GetCurrentTutorialIsland().OnPlayerStartedMission(this);
		}
	}

	public int GetActiveMission()
	{
		return _activeMission;
	}

	public bool HasActiveMission()
	{
		return GetActiveMission() != -1;
	}

	public BaseMission.MissionInstance GetActiveMissionInstance()
	{
		int activeMission = GetActiveMission();
		if (activeMission >= 0 && activeMission < missions.Count)
		{
			return missions[activeMission];
		}
		return null;
	}

	private void LoadMissions(Missions loadedMissions)
	{
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		if (missions.Count > 0)
		{
			for (int num = missions.Count - 1; num >= 0; num--)
			{
				BaseMission.MissionInstance missionInstance = missions[num];
				if (missionInstance != null)
				{
					Pool.Free<BaseMission.MissionInstance>(ref missionInstance);
				}
			}
		}
		missions.Clear();
		if (base.isServer && loadedMissions != null && State.IsSaveStale())
		{
			Debug.Log((object)"Missions were from old protocol or different seed, or not from a loaded save. Clearing");
			loadedMissions.activeMission = -1;
			SetActiveMission(-1);
			State.missions = SaveMissions();
			return;
		}
		if (loadedMissions != null && loadedMissions.missions.Count > 0)
		{
			MissionEntity missionEntity2 = default(MissionEntity);
			foreach (MissionInstance mission2 in loadedMissions.missions)
			{
				BaseMission fromID = MissionManifest.GetFromID(mission2.missionID);
				if (fromID == null)
				{
					continue;
				}
				BaseMission.MissionInstance missionInstance2 = Pool.Get<BaseMission.MissionInstance>();
				missionInstance2.missionID = mission2.missionID;
				missionInstance2.status = (BaseMission.MissionStatus)mission2.missionStatus;
				MissionInstanceData instanceData = mission2.instanceData;
				if (instanceData != null)
				{
					missionInstance2.providerID = instanceData.providerID;
					missionInstance2.startTime = Time.time - instanceData.startTime;
					missionInstance2.endTime = instanceData.endTime;
					missionInstance2.missionLocation = instanceData.missionLocation;
					if (base.isServer && instanceData.missionPoints != null)
					{
						foreach (MissionPoint missionPoint in instanceData.missionPoints)
						{
							missionInstance2.missionPoints.Add(missionPoint.identifier, missionPoint.location);
							if (fromID.positionGenerators[missionInstance2.missionPoints.Count - 1].positionsAreExclusive)
							{
								BaseMission.AddBlocker(missionPoint.location);
							}
						}
					}
					missionInstance2.objectiveStatuses = new BaseMission.MissionInstance.ObjectiveStatus[instanceData.objectiveStatuses.Count];
					for (int i = 0; i < instanceData.objectiveStatuses.Count; i++)
					{
						ObjectiveStatus val = instanceData.objectiveStatuses[i];
						BaseMission.MissionInstance.ObjectiveStatus objectiveStatus = new BaseMission.MissionInstance.ObjectiveStatus();
						objectiveStatus.completed = val.completed;
						objectiveStatus.failed = val.failed;
						objectiveStatus.started = val.started;
						objectiveStatus.progressCurrent = val.progressCurrent;
						objectiveStatus.progressTarget = val.progressTarget;
						missionInstance2.objectiveStatuses[i] = objectiveStatus;
					}
					if (base.isServer && instanceData.missionEntities != null)
					{
						missionInstance2.missionEntities.Clear();
						BaseMission mission = missionInstance2.GetMission();
						foreach (MissionEntity missionEntity3 in instanceData.missionEntities)
						{
							MissionEntity missionEntity = null;
							BaseNetworkable baseNetworkable = ((missionEntity3.entityID != default(NetworkableId)) ? BaseNetworkable.serverEntities.Find(missionEntity3.entityID) : null);
							if ((Object)(object)baseNetworkable != (Object)null)
							{
								missionEntity = (((Component)baseNetworkable).gameObject.TryGetComponent<MissionEntity>(ref missionEntity2) ? missionEntity2 : ((Component)baseNetworkable).gameObject.AddComponent<MissionEntity>());
								BaseMission.MissionEntityEntry missionEntityEntry = ((mission != null) ? List.FindWith<BaseMission.MissionEntityEntry, string>((IReadOnlyCollection<BaseMission.MissionEntityEntry>)(object)mission.missionEntities, (Func<BaseMission.MissionEntityEntry, string>)((BaseMission.MissionEntityEntry ed) => ed.identifier), missionEntity3.identifier, (IEqualityComparer<string>)null) : null);
								missionEntity.Setup(this, missionInstance2, missionEntity3.identifier, missionEntityEntry?.cleanupOnMissionSuccess ?? true, missionEntityEntry?.cleanupOnMissionFailed ?? true);
							}
							missionInstance2.missionEntities.Add(missionEntity3.identifier, missionEntity);
						}
					}
				}
				missions.Add(missionInstance2);
			}
			SetActiveMission(loadedMissions.activeMission);
		}
		else
		{
			SetActiveMission(-1);
		}
		if (base.isServer)
		{
			GetActiveMissionInstance()?.PostServerLoad(this);
		}
	}

	private void UpdateModelState()
	{
		if (!IsDead() && !IsSpectating())
		{
			wantsSendModelState = true;
		}
	}

	public void SendModelState(bool force = false)
	{
		if (!force && (!wantsSendModelState || nextModelStateUpdate > Time.time))
		{
			return;
		}
		wantsSendModelState = false;
		nextModelStateUpdate = Time.time + 0.1f;
		if (!IsDead() && !IsSpectating())
		{
			modelState.sleeping = IsSleeping();
			modelState.mounted = isMounted;
			modelState.ragdolling = IsRagdolling();
			modelState.relaxed = IsRelaxed();
			modelState.onPhone = HasActiveTelephone && !activeTelephone.IsMobile;
			modelState.crawling = IsCrawling();
			if (!base.limitNetworking && Interface.CallHook("OnSendModelState", (object)this) == null)
			{
				modelState.loading = IsLoadingAfterTransfer();
				ClientRPC(RpcTarget.NetworkGroup("OnModelState"), modelState);
			}
		}
	}

	public BaseMountable GetMounted()
	{
		return mounted.Get(base.isServer) as BaseMountable;
	}

	public BaseVehicle GetMountedVehicle()
	{
		BaseMountable baseMountable = GetMounted();
		if (!baseMountable.IsValid())
		{
			return null;
		}
		return baseMountable.VehicleParent();
	}

	public void MarkSwapSeat()
	{
		nextSeatSwapTime = Time.time + 0.75f;
	}

	public bool SwapSeatCooldown()
	{
		return Time.time < nextSeatSwapTime;
	}

	public bool CanMountMountablesNow()
	{
		if (!IsDead())
		{
			return !IsWounded();
		}
		return false;
	}

	public void SetMounted(BaseMountable mount)
	{
		mounted.Set(mount);
	}

	public void EnsureDismounted()
	{
		if (isMounted)
		{
			GetMounted().DismountPlayer(this);
		}
	}

	public virtual void DismountObject()
	{
		mounted.Set(null);
		SendNetworkUpdate();
		PauseSpeedHackDetection(5f);
	}

	public void HandleMountedOnLoad()
	{
		if (!mounted.IsValid(base.isServer))
		{
			return;
		}
		BaseMountable baseMountable = mounted.Get(base.isServer) as BaseMountable;
		if ((Object)(object)baseMountable != (Object)null)
		{
			baseMountable.MountPlayer(this);
			if (!AllowSleeperMounting(baseMountable))
			{
				baseMountable.DismountPlayer(this);
			}
		}
		else
		{
			mounted.Set(null);
		}
	}

	public bool AllowSleeperMounting(BaseMountable mountable)
	{
		if (mountable.allowSleeperMounting)
		{
			return true;
		}
		if (!IsLoadingAfterTransfer())
		{
			return IsTransferProtected();
		}
		return true;
	}

	public PlayerSecondaryData SaveSecondaryData()
	{
		PlayerSecondaryData val = Pool.Get<PlayerSecondaryData>();
		val.userId = userID;
		PlayerState val2 = State.Copy();
		if (val2.pointsOfInterest != null)
		{
			Pool.Free<MapNote>(ref val2.pointsOfInterest, true);
		}
		if (val2.pings != null)
		{
			Pool.Free<MapNote>(ref val2.pings, true);
		}
		MapNote deathMarker = val2.deathMarker;
		if (deathMarker != null)
		{
			deathMarker.Dispose();
		}
		val2.deathMarker = null;
		Missions obj = val2.missions;
		if (obj != null)
		{
			obj.Dispose();
		}
		val2.missions = null;
		val2.numberOfTimesReported = 0;
		val.playerState = val2;
		if (currentTeam != 0L)
		{
			RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(currentTeam);
			if (playerTeam != null)
			{
				val.teamId = playerTeam.teamID;
				val.isTeamLeader = playerTeam.teamLeader == (ulong)userID;
			}
		}
		val.relationships = Pool.Get<List<RelationshipData>>();
		foreach (RelationshipManager.PlayerRelationshipInfo value in RelationshipManager.ServerInstance.GetRelationships(userID).relations.Values)
		{
			RelationshipData val3 = Pool.Get<RelationshipData>();
			val3.info = value.ToProto();
			val3.mugshotData = GetPoolableMugshotData(value);
			val.relationships.Add(val3);
		}
		return val;
		ArraySegment<byte> GetPoolableMugshotData(RelationshipManager.PlayerRelationshipInfo relationshipInfo)
		{
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			if (relationshipInfo.mugshotCrc == 0)
			{
				return default(ArraySegment<byte>);
			}
			try
			{
				uint steamIdHash = RelationshipManager.GetSteamIdHash(userID, relationshipInfo.player);
				byte[] array = FileStorage.server.Get(relationshipInfo.mugshotCrc, FileStorage.Type.jpg, RelationshipManager.ServerInstance.net.ID, steamIdHash);
				if (array == null)
				{
					return default(ArraySegment<byte>);
				}
				byte[] array2 = Shared.ArrayPool.Rent(array.Length);
				new Span<byte>(array).CopyTo(array2);
				return new ArraySegment<byte>(array2, 0, array.Length);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
				return default(ArraySegment<byte>);
			}
		}
	}

	public void LoadSecondaryData(PlayerSecondaryData data)
	{
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		if (data == null)
		{
			return;
		}
		if (data.userId != (ulong)userID)
		{
			Debug.LogError((object)$"Attempted to load secondary data with an incorrect userID! Expected {data.userId} but player has {userID.Get()}, not loading it.");
			return;
		}
		if (data.playerState != null)
		{
			State.unHostileTimestamp = data.playerState.unHostileTimestamp;
			DirtyPlayerState();
		}
		if (data.relationships == null)
		{
			return;
		}
		RelationshipManager.PlayerRelationships relationships = RelationshipManager.ServerInstance.GetRelationships(userID);
		relationships.ClearRelations();
		foreach (RelationshipData relationship in data.relationships)
		{
			if (relationship.mugshotData.Count > 0)
			{
				try
				{
					byte[] array = new byte[relationship.mugshotData.Count];
					relationship.mugshotData.AsSpan().CopyTo(array);
					uint steamIdHash = RelationshipManager.GetSteamIdHash(userID, relationship.info.playerID);
					uint num = FileStorage.server.Store(array, FileStorage.Type.jpg, RelationshipManager.ServerInstance.net.ID, steamIdHash);
					if (num != relationship.info.mugshotCrc)
					{
						Debug.LogWarning((object)$"Mugshot data for {userID.Get()}->{relationship.info.playerID} had a CRC mismatch, updating it");
						relationship.info.mugshotCrc = num;
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
				}
			}
			relationships.relations.Add(relationship.info.playerID, RelationshipManager.PlayerRelationshipInfo.FromProto(relationship.info));
		}
		RelationshipManager.ServerInstance.MarkRelationshipsDirtyFor(this);
	}

	public override void DisableTransferProtection()
	{
		BaseVehicle vehicleParent = GetVehicleParent();
		if ((Object)(object)vehicleParent != (Object)null && vehicleParent.IsTransferProtected())
		{
			vehicleParent.DisableTransferProtection();
		}
		BaseMountable baseMountable = GetMounted();
		if ((Object)(object)baseMountable != (Object)null && baseMountable.IsTransferProtected())
		{
			baseMountable.DisableTransferProtection();
		}
		base.DisableTransferProtection();
	}

	public void KickAfterServerTransfer()
	{
		if (IsConnected)
		{
			Kick("Redirecting to another zone...");
		}
		Kill();
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	private void RequestParachuteDeploy(RPCMessage msg)
	{
		RequestParachuteDeploy();
	}

	public void RequestParachuteDeploy()
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		if (isMounted || !CheckParachuteClearance())
		{
			return;
		}
		Item slot = inventory.containerWear.GetSlot(7);
		ItemModParachute itemModParachute = default(ItemModParachute);
		if (slot == null || !(slot.conditionNormalized > 0f) || slot.isBroken || !((Component)slot.info).TryGetComponent<ItemModParachute>(ref itemModParachute))
		{
			return;
		}
		Parachute parachute = GameManager.server.CreateEntity(itemModParachute.ParachuteVehiclePrefab.resourcePath, ((Component)this).transform.position, eyes.rotation) as Parachute;
		if ((Object)(object)parachute != (Object)null)
		{
			parachute.skinID = slot.skin;
			parachute.Spawn();
			parachute.SetHealth(parachute.MaxHealth() * slot.conditionNormalized);
			parachute.AttemptMount(this);
			if (isMounted)
			{
				slot.Remove();
				ItemManager.DoRemoves();
				SendNetworkUpdate();
			}
			else
			{
				parachute.Kill();
			}
		}
	}

	public bool CheckParachuteClearance()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		if (!WaterLevel.Test(position - Vector3.up * 5f, waves: false, volumes: true, this) && !GamePhysics.Trace(new Ray(position, -Vector3.up), 1f, out var _, 6f, 1218543873, (QueryTriggerInteraction)0))
		{
			return !GamePhysics.CheckSphere(position + Vector3.up * 3.5f, 2f, 1218543873, (QueryTriggerInteraction)0);
		}
		return false;
	}

	public bool HasValidParachuteEquipped()
	{
		if ((Object)(object)inventory == (Object)null || inventory.containerWear == null)
		{
			return false;
		}
		Item slot = inventory.containerWear.GetSlot(7);
		ItemModParachute itemModParachute = default(ItemModParachute);
		if (slot != null && slot.conditionNormalized > 0f && !slot.isBroken && ((Component)slot.info).TryGetComponent<ItemModParachute>(ref itemModParachute))
		{
			return true;
		}
		return false;
	}

	public void ClearClientPetLink()
	{
		ClientRPC(RpcTarget.Player("CLIENT_SetPetPrefabID", this), 0u, 0uL);
	}

	public void SendClientPetLink()
	{
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)PetEntity == (Object)null && BasePet.ActivePetByOwnerID.TryGetValue(userID, out var value) && (Object)(object)value.Brain != (Object)null)
		{
			value.Brain.SetOwningPlayer(this);
		}
		ClientRPC(RpcTarget.Player("CLIENT_SetPetPrefabID", this), ((Object)(object)PetEntity != (Object)null) ? PetEntity.prefabID : 0u, (NetworkableId)(((Object)(object)PetEntity != (Object)null) ? PetEntity.net.ID : default(NetworkableId)));
		if ((Object)(object)PetEntity != (Object)null)
		{
			SendClientPetStateIndex();
		}
	}

	public void SendClientPetStateIndex()
	{
		BasePet basePet = PetEntity as BasePet;
		if (!((Object)(object)basePet == (Object)null))
		{
			ClientRPC(RpcTarget.Player("CLIENT_SetPetPetLoadedStateIndex", this), basePet.Brain.LoadedDesignIndex());
		}
	}

	[RPC_Server]
	private void IssuePetCommand(RPCMessage msg)
	{
		ParsePetCommand(msg, raycast: false);
	}

	[RPC_Server]
	private void IssuePetCommandRaycast(RPCMessage msg)
	{
		ParsePetCommand(msg, raycast: true);
	}

	private void ParsePetCommand(RPCMessage msg, bool raycast)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		if (Time.time - lastPetCommandIssuedTime <= 1f)
		{
			return;
		}
		lastPetCommandIssuedTime = Time.time;
		if (!((Object)(object)msg.player == (Object)null) && Pet != null && Pet.IsOwnedBy(msg.player))
		{
			int cmd = msg.read.Int32();
			int param = msg.read.Int32();
			if (raycast)
			{
				Ray value = msg.read.Ray();
				Pet.IssuePetCommand((PetCommandType)cmd, param, value);
			}
			else
			{
				Pet.IssuePetCommand((PetCommandType)cmd, param, null);
			}
		}
	}

	public bool CanPing(bool disregardHeldEntity = false)
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(base.isServer);
		if ((Object)(object)activeGameMode != (Object)null && !activeGameMode.allowPings)
		{
			return false;
		}
		if ((disregardHeldEntity || GetHeldEntity() is Binocular || (isMounted && GetMounted() is ComputerStation computerStation && computerStation.AllowPings()) || (GetHeldEntity() is BaseProjectile baseProjectile && baseProjectile.AllowsPingUsage())) && IsAlive() && !IsWounded())
		{
			return !IsSpectating();
		}
		return false;
	}

	public static PingStyle GetPingStyle(PingType t)
	{
		PingStyle pingStyle = default(PingStyle);
		return t switch
		{
			PingType.Hostile => HostileMarker, 
			PingType.GoTo => GoToMarker, 
			PingType.Dollar => DollarMarker, 
			PingType.Loot => LootMarker, 
			PingType.Node => NodeMarker, 
			PingType.Gun => GunMarker, 
			PingType.Build => BuildMarker, 
			_ => pingStyle, 
		};
	}

	private void ApplyPingStyle(MapNote note, PingType type)
	{
		PingStyle pingStyle = GetPingStyle(type);
		note.colourIndex = pingStyle.ColourIndex;
		note.icon = pingStyle.IconIndex;
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.FromOwner(false)]
	private void Server_AddPing(RPCMessage msg)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		if (State.pings == null)
		{
			State.pings = new List<MapNote>();
		}
		if (ConVar.Server.maximumPings == 0 || !CanPing())
		{
			return;
		}
		Vector3 val = msg.read.Vector3();
		PingType pingType = (PingType)Mathf.Clamp(msg.read.Int32(), 0, 6);
		bool wasViaWheel = msg.read.Bit();
		PingStyle pingStyle = GetPingStyle(pingType);
		foreach (MapNote ping in State.pings)
		{
			if (ping.icon == pingStyle.IconIndex)
			{
				Vector3 val2 = ping.worldPosition - val;
				if (((Vector3)(ref val2)).sqrMagnitude < 0.75f)
				{
					return;
				}
			}
		}
		if (State.pings.Count >= ConVar.Server.maximumPings)
		{
			State.pings.RemoveAt(0);
		}
		MapNote val3 = Pool.Get<MapNote>();
		val3.worldPosition = val;
		val3.isPing = true;
		val3.timeRemaining = (val3.totalDuration = ConVar.Server.pingDuration);
		ApplyPingStyle(val3, pingType);
		State.pings.Add(val3);
		DirtyPlayerState();
		SendPingsToClient();
		TeamUpdate(fullTeamUpdate: true);
		Analytics.Azure.OnPlayerPinged(this, pingType, wasViaWheel);
	}

	public void AddPingAtLocation(PingType type, Vector3 location, float time, NetworkableId associatedId)
	{
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if (State.pings != null)
		{
			PingStyle pingStyle = GetPingStyle(type);
			foreach (MapNote ping in State.pings)
			{
				if (ping.icon == pingStyle.IconIndex && Vector3.Distance(location, ping.worldPosition) < 0.25f)
				{
					return;
				}
			}
		}
		if (State.pings == null)
		{
			State.pings = new List<MapNote>();
		}
		MapNote val = Pool.Get<MapNote>();
		val.worldPosition = location;
		val.isPing = true;
		val.timeRemaining = (val.totalDuration = time);
		val.associatedId = associatedId;
		ApplyPingStyle(val, type);
		State.pings.Add(val);
		DirtyPlayerState();
		SendPingsToClient();
		TeamUpdate(fullTeamUpdate: false);
	}

	public void RemovePingAtLocation(PingType type, Vector3 location, float tolerance, NetworkableId associatedId)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (State.pings == null)
		{
			return;
		}
		PingStyle pingStyle = GetPingStyle(type);
		for (int i = 0; i < State.pings.Count; i++)
		{
			MapNote val = State.pings[i];
			if (val.icon == pingStyle.IconIndex && Vector3.Distance(location, val.worldPosition) < tolerance)
			{
				State.pings.RemoveAt(i);
				DirtyPlayerState();
				SendPingsToClient();
				TeamUpdate(fullTeamUpdate: false);
			}
		}
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	private void Server_RemovePing(RPCMessage msg)
	{
		if (State.pings == null)
		{
			State.pings = new List<MapNote>();
		}
		int num = msg.read.Int32();
		if (num >= 0 && num < State.pings.Count)
		{
			State.pings.RemoveAt(num);
			DirtyPlayerState();
			SendPingsToClient();
			TeamUpdate(fullTeamUpdate: true);
		}
	}

	public void SendPingsToClient()
	{
		MapNoteList val = Pool.Get<MapNoteList>();
		try
		{
			val.notes = Pool.Get<List<MapNote>>();
			val.notes.AddRange(State.pings);
			Interface.CallHook("OnPlayerPingsSend", (object)this, (object)val);
			ClientRPC(RpcTarget.Player("Client_ReceivePings", this), val);
			val.notes.Clear();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void TickPings()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (TimeSince.op_Implicit(lastTick) < 0.5f)
		{
			return;
		}
		TimeSince val = lastTick;
		lastTick = TimeSince.op_Implicit(0f);
		UpdateResourcePings();
		if (State.pings == null)
		{
			return;
		}
		List<MapNote> list = Pool.Get<List<MapNote>>();
		foreach (MapNote ping in State.pings)
		{
			ping.timeRemaining -= TimeSince.op_Implicit(val);
			if (ping.timeRemaining <= 0f)
			{
				list.Add(ping);
			}
		}
		int count = list.Count;
		foreach (MapNote item in list)
		{
			if (State.pings.Contains(item))
			{
				State.pings.Remove(item);
			}
		}
		Pool.Free<MapNote>(ref list, false);
		if (count > 0)
		{
			DirtyPlayerState();
			SendPingsToClient();
			TeamUpdate(fullTeamUpdate: true);
		}
	}

	public void RegisterPingedEntity(BaseEntity entity, PingType type)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (!pingedEntities.Contains((entity.net.ID, type)))
		{
			pingedEntities.Add((entity.net.ID, type));
		}
	}

	public void DeregisterPingedEntitiesOfType(PingType type)
	{
		List<(NetworkableId, PingType)> list = Pool.Get<List<(NetworkableId, PingType)>>();
		foreach (var pingedEntity in pingedEntities)
		{
			if (pingedEntity.pingType == type)
			{
				list.Add(pingedEntity);
			}
		}
		foreach (var item in list)
		{
			pingedEntities.Remove(item);
		}
		Pool.FreeUnmanaged<(NetworkableId, PingType)>(ref list);
	}

	public void DeregisterPingedEntity(NetworkableId id, PingType type)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (!pingedEntities.Contains((id, type)))
		{
			return;
		}
		pingedEntities.Remove((id, type));
		for (int i = 0; i < State.pings.Count; i++)
		{
			if (State.pings[i].associatedId == id)
			{
				State.pings.RemoveAt(i);
				break;
			}
		}
		DirtyPlayerState();
		SendPingsToClient();
	}

	public void EnableResourcePings(ItemDefinition forItem, PingType pingType)
	{
		if (!tutorialDesiredResource.Contains((forItem, pingType)))
		{
			tutorialDesiredResource.Add((forItem, pingType));
		}
	}

	private void UpdateResourcePings()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_032e: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_0481: Unknown result type (might be due to invalid IL or missing references)
		//IL_0492: Unknown result type (might be due to invalid IL or missing references)
		if (State == null || TimeSince.op_Implicit(lastResourcePingUpdate) < 3f || !IsInTutorial)
		{
			return;
		}
		lastResourcePingUpdate = TimeSince.op_Implicit(0f);
		if (State.pings == null)
		{
			State.pings = new List<MapNote>();
		}
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		List<(BaseEntity, PingType)> list2 = Pool.Get<List<(BaseEntity, PingType)>>();
		List<BaseEntity> list3 = Pool.Get<List<BaseEntity>>();
		ResourceDispenser resourceDispenser = default(ResourceDispenser);
		foreach (var item2 in tutorialDesiredResource)
		{
			list3.Clear();
			Enumerator<Networkable> enumerator2 = net.group.networkables.GetEnumerator();
			try
			{
				while (enumerator2.MoveNext())
				{
					Networkable current2 = enumerator2.Current;
					BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(current2.ID) as BaseEntity;
					if ((Object)(object)baseEntity != (Object)null && Distance(baseEntity) < 128f && baseEntity.isServer)
					{
						if (((Component)baseEntity).TryGetComponent<ResourceDispenser>(ref resourceDispenser) && resourceDispenser.HasItemToDispense(item2.item))
						{
							list3.Add(baseEntity);
						}
						else if (baseEntity is CollectibleEntity collectibleEntity && collectibleEntity.HasItem(item2.item))
						{
							list3.Add(baseEntity);
						}
						else if (baseEntity is StorageContainer { inventory: not null } storageContainer && storageContainer.inventory.HasItem(item2.item))
						{
							list3.Add(baseEntity);
						}
					}
				}
			}
			finally
			{
				((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
			}
			if (list3.Count <= 0)
			{
				continue;
			}
			float num = float.MaxValue;
			BaseEntity baseEntity2 = null;
			foreach (BaseEntity item3 in list3)
			{
				float num2 = Distance(item3);
				if (num2 < num)
				{
					num = num2;
					baseEntity2 = item3;
				}
			}
			if ((Object)(object)baseEntity2 != (Object)null)
			{
				list2.Add((baseEntity2, item2.pingType));
			}
		}
		List<(NetworkableId, PingType)> list4 = Pool.Get<List<(NetworkableId, PingType)>>();
		foreach (var pingedEntity in pingedEntities)
		{
			BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(pingedEntity.id);
			if ((Object)(object)baseNetworkable != (Object)null && !baseNetworkable.IsDestroyed)
			{
				list2.Add((baseNetworkable as BaseEntity, pingedEntity.pingType));
			}
			else
			{
				list4.Add(pingedEntity);
			}
		}
		foreach (var item4 in list4)
		{
			pingedEntities.Remove(item4);
		}
		Pool.FreeUnmanaged<(NetworkableId, PingType)>(ref list4);
		Pool.FreeUnmanaged<BaseEntity>(ref list3);
		List<MapNote> list5 = Pool.Get<List<MapNote>>();
		foreach (MapNote ping in State.pings)
		{
			if (ping.associatedId.Value == 0L)
			{
				continue;
			}
			bool flag = false;
			foreach (var item5 in list2)
			{
				if (ping.associatedId == item5.Item1.net.ID)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				BaseNetworkable baseNetworkable2 = BaseNetworkable.serverEntities.Find(ping.associatedId);
				if ((Object)(object)baseNetworkable2 != (Object)null && baseNetworkable2 is IEntityPingSource entityPingSource && entityPingSource.IsPingValid(ping))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				list5.Add(ping);
			}
		}
		bool flag2 = list5.Count > 0;
		foreach (MapNote item6 in list5)
		{
			if (State.pings.Contains(item6))
			{
				State.pings.Remove(item6);
			}
		}
		Pool.Free<MapNote>(ref list5, false);
		foreach (var item7 in list2)
		{
			if (HasPingForEntity(item7.Item1))
			{
				continue;
			}
			PingType item = item7.Item2;
			foreach (var pingedEntity2 in pingedEntities)
			{
				if (pingedEntity2.id == item7.Item1.net.ID)
				{
					item = pingedEntity2.pingType;
				}
			}
			State.pings.Add(CreatePingForEntity(item7.Item1, item));
			flag2 = true;
		}
		if (flag2)
		{
			DirtyPlayerState();
			SendPingsToClient();
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	private MapNote CreatePingForEntity(BaseEntity baseEntity, PingType type)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		MapNote val = Pool.Get<MapNote>();
		val.worldPosition = ((Component)baseEntity).transform.position;
		val.isPing = true;
		val.timeRemaining = (val.totalDuration = 30f);
		val.associatedId = baseEntity.net.ID;
		ApplyPingStyle(val, type);
		return val;
	}

	private bool HasPingForEntity(BaseEntity ent)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return HasPingForEntity(ent.net.ID);
	}

	private bool HasPingForEntity(NetworkableId id)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		foreach (MapNote ping in State.pings)
		{
			if (ping.associatedId == id)
			{
				return true;
			}
		}
		return false;
	}

	public void DisableResourcePings(ItemDefinition forItem, PingType type)
	{
		if (tutorialDesiredResource.Contains((forItem, type)))
		{
			tutorialDesiredResource.Remove((forItem, type));
		}
		if (tutorialDesiredResource.Count == 0)
		{
			UpdateResourcePings();
		}
	}

	private void ClearAllPings()
	{
		if (State != null && State.pings != null)
		{
			State.pings.Clear();
		}
		tutorialDesiredResource.Clear();
		pingedEntities.Clear();
	}

	public void DirtyPlayerState()
	{
		_playerStateDirty = true;
	}

	public void SavePlayerState()
	{
		if (_playerStateDirty)
		{
			_playerStateDirty = false;
			State.protocol = 270;
			State.seed = World.Seed;
			State.saveCreatedTime = Epoch.FromDateTime(SaveRestore.SaveCreatedTime);
			SingletonComponent<ServerMgr>.Instance.playerStateManager.Save(userID);
		}
	}

	public void ResetPlayerState()
	{
		SingletonComponent<ServerMgr>.Instance.playerStateManager.Reset(userID);
		ClientRPC(RpcTarget.Player("SetHostileLength", this), 0f);
		SendMarkersToClient();
		WipeMissions();
		MissionDirty();
		if ((Object)(object)modifiers != (Object)null)
		{
			modifiers.RemoveAll();
		}
	}

	public bool IsSleeping()
	{
		return HasPlayerFlag(PlayerFlags.Sleeping);
	}

	public bool IsSpectating()
	{
		return HasPlayerFlag(PlayerFlags.Spectating);
	}

	public bool IsRelaxed()
	{
		return HasPlayerFlag(PlayerFlags.Relaxed);
	}

	public bool IsServerFalling()
	{
		return HasPlayerFlag(PlayerFlags.ServerFall);
	}

	public bool IsLoadingAfterTransfer()
	{
		return HasPlayerFlag(PlayerFlags.LoadingAfterTransfer);
	}

	public bool CanBuild()
	{
		return CanBuild(PrivilegeCacheDefaultValue());
	}

	public bool CanBuild(bool cached, float cacheDuration = 1f)
	{
		if (IsBuildingBlockedByVehicle(cached, cacheDuration))
		{
			return false;
		}
		if (IsBuildingBlockedByEntity(cached, cacheDuration))
		{
			return false;
		}
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege(cached, cacheDuration);
		if ((Object)(object)buildingPrivilege == (Object)null)
		{
			return true;
		}
		return buildingPrivilege.CanBuild(this);
	}

	public bool CanBuild(Vector3 position, Quaternion rotation, Bounds bounds)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return CanBuild(position, rotation, bounds, PrivilegeCacheDefaultValue());
	}

	public bool CanBuild(Vector3 position, Quaternion rotation, Bounds bounds, bool cached)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		OBB obb = default(OBB);
		((OBB)(ref obb))..ctor(position, rotation, bounds);
		if (IsBuildingBlockedByVehicle(obb, cached))
		{
			return false;
		}
		if (IsBuildingBlockedByEntity(obb, cached))
		{
			return false;
		}
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege(obb, cached);
		if ((Object)(object)buildingPrivilege == (Object)null)
		{
			return true;
		}
		return buildingPrivilege.CanBuild(this);
	}

	public bool CanBuild(OBB obb)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return CanBuild(obb, PrivilegeCacheDefaultValue());
	}

	public bool CanBuild(OBB obb, bool cached)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if (IsBuildingBlockedByVehicle(obb, cached))
		{
			return false;
		}
		if (IsBuildingBlockedByEntity(obb, cached))
		{
			return false;
		}
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege(obb, cached);
		if ((Object)(object)buildingPrivilege == (Object)null)
		{
			return true;
		}
		return buildingPrivilege.CanBuild(this);
	}

	public bool IsBuildingBlocked()
	{
		return IsBuildingBlocked(PrivilegeCacheDefaultValue());
	}

	public bool IsBuildingBlocked(bool cached)
	{
		if (IsBuildingBlockedByVehicle(cached))
		{
			return true;
		}
		if (IsBuildingBlockedByEntity(cached))
		{
			return true;
		}
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege(cached);
		if ((Object)(object)buildingPrivilege == (Object)null)
		{
			return false;
		}
		return !buildingPrivilege.CanBuild(this);
	}

	public bool IsBuildingBlocked(Vector3 position, Quaternion rotation, Bounds bounds)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return IsBuildingBlocked(position, rotation, bounds, PrivilegeCacheDefaultValue());
	}

	public bool IsBuildingBlocked(Vector3 position, Quaternion rotation, Bounds bounds, bool cached)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		OBB obb = default(OBB);
		((OBB)(ref obb))..ctor(position, rotation, bounds);
		if (IsBuildingBlockedByVehicle(obb, cached))
		{
			return true;
		}
		if (IsBuildingBlockedByEntity(obb, cached))
		{
			return true;
		}
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege(obb, cached);
		if ((Object)(object)buildingPrivilege == (Object)null)
		{
			return false;
		}
		return !buildingPrivilege.CanBuild(this);
	}

	public bool IsBuildingBlocked(OBB obb)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return IsBuildingBlocked(obb, PrivilegeCacheDefaultValue());
	}

	public bool IsBuildingBlocked(OBB obb, bool cached)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if (IsBuildingBlockedByVehicle(obb, cached))
		{
			return true;
		}
		if (IsBuildingBlockedByEntity(obb, cached))
		{
			return true;
		}
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege(obb, cached);
		if ((Object)(object)buildingPrivilege == (Object)null)
		{
			return false;
		}
		return !buildingPrivilege.CanBuild(this);
	}

	public bool IsBuildingAuthed()
	{
		return IsBuildingAuthed(PrivilegeCacheDefaultValue());
	}

	public bool IsBuildingAuthed(bool cached, float cacheDuration = 1f)
	{
		if (IsBuildingBlockedByVehicle(cached, cacheDuration))
		{
			return false;
		}
		if (IsBuildingBlockedByEntity(cached, cacheDuration))
		{
			return false;
		}
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege(cached, cacheDuration);
		if ((Object)(object)buildingPrivilege == (Object)null)
		{
			return false;
		}
		return buildingPrivilege.CanBuild(this);
	}

	public bool IsBuildingAuthed(Vector3 position, Quaternion rotation, Bounds bounds)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return IsBuildingAuthed(position, rotation, bounds, PrivilegeCacheDefaultValue());
	}

	public bool IsBuildingAuthed(Vector3 position, Quaternion rotation, Bounds bounds, bool cached)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		OBB obb = default(OBB);
		((OBB)(ref obb))..ctor(position, rotation, bounds);
		if (IsBuildingBlockedByVehicle(obb, cached))
		{
			return false;
		}
		if (IsBuildingBlockedByEntity(obb, cached))
		{
			return false;
		}
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege(obb, cached);
		if ((Object)(object)buildingPrivilege == (Object)null)
		{
			return false;
		}
		return buildingPrivilege.CanBuild(this);
	}

	public bool IsBuildingAuthed(OBB obb)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return IsBuildingAuthed(obb, PrivilegeCacheDefaultValue());
	}

	public bool IsBuildingAuthed(OBB obb, bool cached)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if (IsBuildingBlockedByVehicle(obb, cached))
		{
			return false;
		}
		if (IsBuildingBlockedByEntity(obb, cached))
		{
			return false;
		}
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege(obb, cached);
		if ((Object)(object)buildingPrivilege == (Object)null)
		{
			return false;
		}
		return buildingPrivilege.CanBuild(this);
	}

	public bool CanPlaceBuildingPrivilege()
	{
		return CanPlaceBuildingPrivilege(PrivilegeCacheDefaultValue());
	}

	public bool CanPlaceBuildingPrivilege(bool cached)
	{
		if (IsBuildingBlockedByVehicle(cached))
		{
			return false;
		}
		if (IsBuildingBlockedByEntity(cached))
		{
			return false;
		}
		return (Object)(object)GetBuildingPrivilege(cached) == (Object)null;
	}

	public bool CanPlaceBuildingPrivilege(Vector3 position, Quaternion rotation, Bounds bounds, BuildingPrivlidge exclude = null)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return CanPlaceBuildingPrivilege(position, rotation, bounds, PrivilegeCacheDefaultValue(), exclude);
	}

	public bool CanPlaceBuildingPrivilege(Vector3 position, Quaternion rotation, Bounds bounds, bool cached, BuildingPrivlidge exclude = null)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		OBB obb = default(OBB);
		((OBB)(ref obb))..ctor(position, rotation, bounds);
		if (IsBuildingBlockedByVehicle(obb, cached))
		{
			return false;
		}
		if (IsBuildingBlockedByEntity(obb, cached))
		{
			return false;
		}
		return (Object)(object)GetBuildingPrivilege(obb, cached, 1f, exclude) == (Object)null;
	}

	public bool CanPlaceBuildingPrivilege(OBB obb)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return CanPlaceBuildingPrivilege(obb, PrivilegeCacheDefaultValue());
	}

	public bool CanPlaceBuildingPrivilege(OBB obb, bool cached)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if (IsBuildingBlockedByVehicle(obb, cached))
		{
			return false;
		}
		if (IsBuildingBlockedByEntity(obb, cached))
		{
			return false;
		}
		return (Object)(object)GetBuildingPrivilege(obb, cached) == (Object)null;
	}

	public bool IsNearEnemyBase()
	{
		return IsNearEnemyBase(PrivilegeCacheDefaultValue());
	}

	public bool IsNearEnemyBase(bool cached)
	{
		if (IsBuildingBlockedByVehicle(cached))
		{
			return true;
		}
		if (IsBuildingBlockedByEntity(cached))
		{
			return true;
		}
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege(cached);
		if ((Object)(object)buildingPrivilege == (Object)null)
		{
			return false;
		}
		if (!buildingPrivilege.IsAuthed(this))
		{
			return buildingPrivilege.AnyAuthed();
		}
		return false;
	}

	public bool IsNearEnemyBase(Vector3 position, Quaternion rotation, Bounds bounds)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return IsNearEnemyBase(position, rotation, bounds, PrivilegeCacheDefaultValue());
	}

	public bool IsNearEnemyBase(Vector3 position, Quaternion rotation, Bounds bounds, bool cached)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		OBB obb = default(OBB);
		((OBB)(ref obb))..ctor(position, rotation, bounds);
		if (IsBuildingBlockedByVehicle(obb, cached))
		{
			return true;
		}
		if (IsBuildingBlockedByEntity(obb, cached))
		{
			return true;
		}
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege(obb, cached);
		if ((Object)(object)buildingPrivilege == (Object)null)
		{
			return false;
		}
		if (!buildingPrivilege.IsAuthed(this))
		{
			return buildingPrivilege.AnyAuthed();
		}
		return false;
	}

	public bool IsNearEnemyBase(OBB obb)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return IsNearEnemyBase(obb, PrivilegeCacheDefaultValue());
	}

	public bool IsNearEnemyBase(OBB obb, bool cached)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if (IsBuildingBlockedByVehicle(obb, cached))
		{
			return true;
		}
		if (IsBuildingBlockedByEntity(obb, cached))
		{
			return true;
		}
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege(obb, cached);
		if ((Object)(object)buildingPrivilege == (Object)null)
		{
			return false;
		}
		if (!buildingPrivilege.IsAuthed(this))
		{
			return buildingPrivilege.AnyAuthed();
		}
		return false;
	}

	public bool IsBuildingBlockedByVehicle()
	{
		return IsBuildingBlockedByVehicle(PrivilegeCacheDefaultValue());
	}

	public bool IsBuildingBlockedByVehicle(bool cached, float cacheDuration = 1f)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return IsBuildingBlockedByVehicle(WorldSpaceBounds(), cached);
	}

	private bool IsBuildingBlockedByVehicle(OBB obb, bool cached, float cacheDuration = 1f)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		if (cached && cachedVehicleBuildingPrivilegeTime != 0f && Time.time - cachedVehicleBuildingPrivilegeTime < cacheDuration)
		{
			if ((Object)(object)cachedVehicleBuildingPrivilege != (Object)null)
			{
				return cachedVehicleBuildingPrivilegeBlocked;
			}
			return false;
		}
		List<BaseVehicle> list = Pool.Get<List<BaseVehicle>>();
		Vis.Entities(obb.position, 2f + ((Vector3)(ref obb.extents)).magnitude, list, 134217728, (QueryTriggerInteraction)2);
		cachedVehicleBuildingPrivilege = null;
		cachedVehicleBuildingPrivilegeBlocked = false;
		for (int i = 0; i < list.Count; i++)
		{
			BaseVehicle baseVehicle = list[i];
			if (baseVehicle.isServer == base.isServer && !baseVehicle.IsDead() && !(((OBB)(ref obb)).Distance(baseVehicle.WorldSpaceBounds()) > 2f) && baseVehicle.HasBuildingPrivilege)
			{
				cachedVehicleBuildingPrivilege = baseVehicle;
				if (!baseVehicle.IsAuthed(this))
				{
					cachedVehicleBuildingPrivilegeBlocked = true;
					break;
				}
			}
		}
		Pool.FreeUnmanaged<BaseVehicle>(ref list);
		cachedVehicleBuildingPrivilegeTime = Time.time;
		return cachedVehicleBuildingPrivilegeBlocked;
	}

	public bool IsBuildingBlockedByEntity()
	{
		return IsBuildingBlockedByEntity(PrivilegeCacheDefaultValue());
	}

	public bool IsBuildingBlockedByEntity(bool cached, float cacheDuration = 1f)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return IsBuildingBlockedByEntity(WorldSpaceBounds(), cached, cacheDuration);
	}

	private bool IsBuildingBlockedByEntity(OBB obb, bool cached, float cacheDuration = 1f)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (cached && cachedEntityBuildingPrivilegeTime != 0f && Time.time - cachedEntityBuildingPrivilegeTime < cacheDuration)
		{
			if ((Object)(object)cachedEntityBuildingPrivilege != (Object)null)
			{
				return cachedEntityBuildingPrivilegeBlocked;
			}
			return false;
		}
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(obb.position, 3f + ((Vector3)(ref obb.extents)).magnitude, list, 2097152, (QueryTriggerInteraction)2);
		cachedEntityBuildingPrivilege = null;
		cachedEntityBuildingPrivilegeBlocked = false;
		for (int i = 0; i < list.Count; i++)
		{
			BaseEntity baseEntity = list[i];
			if (baseEntity.isServer != base.isServer || ((OBB)(ref obb)).Distance(baseEntity.WorldSpaceBounds()) > 3f)
			{
				continue;
			}
			EntityPrivilege entityBuildingPrivilege = baseEntity.GetEntityBuildingPrivilege();
			if (!((Object)(object)entityBuildingPrivilege == (Object)null))
			{
				cachedEntityBuildingPrivilege = baseEntity;
				if (!entityBuildingPrivilege.IsAuthed(this))
				{
					cachedEntityBuildingPrivilegeBlocked = true;
					break;
				}
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		cachedEntityBuildingPrivilegeTime = Time.time;
		return cachedEntityBuildingPrivilegeBlocked;
	}

	public bool HasPrivilegeFromOther()
	{
		return HasPrivilegeFromOther(PrivilegeCacheDefaultValue());
	}

	public bool HasPrivilegeFromOther(bool cached)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if (IsBuildingBlockedByVehicle(WorldSpaceBounds(), cached))
		{
			return false;
		}
		if (IsBuildingBlockedByEntity(WorldSpaceBounds(), cached))
		{
			return false;
		}
		if (!((Object)(object)cachedVehicleBuildingPrivilege != (Object)null))
		{
			return (Object)(object)cachedEntityBuildingPrivilege != (Object)null;
		}
		return true;
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	public void OnProjectileAttack(RPCMessage msg)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_159e: Unknown result type (might be due to invalid IL or missing references)
		//IL_15a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_15aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_15af: Unknown result type (might be due to invalid IL or missing references)
		//IL_15eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0447: Unknown result type (might be due to invalid IL or missing references)
		//IL_044d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0607: Unknown result type (might be due to invalid IL or missing references)
		//IL_0611: Unknown result type (might be due to invalid IL or missing references)
		//IL_0616: Unknown result type (might be due to invalid IL or missing references)
		//IL_061b: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_08fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0902: Unknown result type (might be due to invalid IL or missing references)
		//IL_10d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_10de: Unknown result type (might be due to invalid IL or missing references)
		//IL_10e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_10e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_10e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_10ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bda: Unknown result type (might be due to invalid IL or missing references)
		//IL_0be9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0beb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bed: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bf2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bf4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bf6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c04: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c33: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b99: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b9e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1113: Unknown result type (might be due to invalid IL or missing references)
		//IL_1115: Unknown result type (might be due to invalid IL or missing references)
		//IL_111a: Unknown result type (might be due to invalid IL or missing references)
		//IL_111c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1121: Unknown result type (might be due to invalid IL or missing references)
		//IL_1123: Unknown result type (might be due to invalid IL or missing references)
		//IL_1128: Unknown result type (might be due to invalid IL or missing references)
		//IL_10f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_10fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_1106: Unknown result type (might be due to invalid IL or missing references)
		//IL_110b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1110: Unknown result type (might be due to invalid IL or missing references)
		//IL_1172: Unknown result type (might be due to invalid IL or missing references)
		//IL_1174: Unknown result type (might be due to invalid IL or missing references)
		//IL_1176: Unknown result type (might be due to invalid IL or missing references)
		//IL_117b: Unknown result type (might be due to invalid IL or missing references)
		//IL_117d: Unknown result type (might be due to invalid IL or missing references)
		//IL_117f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1136: Unknown result type (might be due to invalid IL or missing references)
		//IL_1138: Unknown result type (might be due to invalid IL or missing references)
		//IL_113a: Unknown result type (might be due to invalid IL or missing references)
		//IL_113f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1143: Unknown result type (might be due to invalid IL or missing references)
		//IL_114d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1152: Unknown result type (might be due to invalid IL or missing references)
		//IL_1154: Unknown result type (might be due to invalid IL or missing references)
		//IL_1156: Unknown result type (might be due to invalid IL or missing references)
		//IL_1158: Unknown result type (might be due to invalid IL or missing references)
		//IL_115d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1161: Unknown result type (might be due to invalid IL or missing references)
		//IL_116b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0958: Unknown result type (might be due to invalid IL or missing references)
		//IL_095d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1193: Unknown result type (might be due to invalid IL or missing references)
		//IL_1195: Unknown result type (might be due to invalid IL or missing references)
		//IL_1197: Unknown result type (might be due to invalid IL or missing references)
		//IL_119c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e62: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e64: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e6a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e6f: Unknown result type (might be due to invalid IL or missing references)
		//IL_11ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_11af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e7e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e80: Unknown result type (might be due to invalid IL or missing references)
		//IL_11ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_11cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e90: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e95: Unknown result type (might be due to invalid IL or missing references)
		//IL_07eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_081b: Unknown result type (might be due to invalid IL or missing references)
		//IL_11dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_11df: Unknown result type (might be due to invalid IL or missing references)
		//IL_121a: Unknown result type (might be due to invalid IL or missing references)
		//IL_122c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1235: Unknown result type (might be due to invalid IL or missing references)
		//IL_124d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1258: Unknown result type (might be due to invalid IL or missing references)
		//IL_141b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1420: Unknown result type (might be due to invalid IL or missing references)
		//IL_1429: Unknown result type (might be due to invalid IL or missing references)
		//IL_142e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1432: Unknown result type (might be due to invalid IL or missing references)
		//IL_1437: Unknown result type (might be due to invalid IL or missing references)
		//IL_1440: Unknown result type (might be due to invalid IL or missing references)
		//IL_1442: Unknown result type (might be due to invalid IL or missing references)
		//IL_1455: Unknown result type (might be due to invalid IL or missing references)
		//IL_1457: Unknown result type (might be due to invalid IL or missing references)
		//IL_1379: Unknown result type (might be due to invalid IL or missing references)
		//IL_137b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1395: Unknown result type (might be due to invalid IL or missing references)
		//IL_1397: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_13d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_13d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_1471: Unknown result type (might be due to invalid IL or missing references)
		//IL_1473: Unknown result type (might be due to invalid IL or missing references)
		//IL_1486: Unknown result type (might be due to invalid IL or missing references)
		//IL_1488: Unknown result type (might be due to invalid IL or missing references)
		//IL_14f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_14f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_150f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1511: Unknown result type (might be due to invalid IL or missing references)
		//IL_152c: Unknown result type (might be due to invalid IL or missing references)
		//IL_152e: Unknown result type (might be due to invalid IL or missing references)
		//IL_154a: Unknown result type (might be due to invalid IL or missing references)
		//IL_154c: Unknown result type (might be due to invalid IL or missing references)
		PlayerProjectileAttack val = msg.read.Proto<PlayerProjectileAttack>((PlayerProjectileAttack)null);
		try
		{
			if (val == null)
			{
				return;
			}
			PlayerAttack playerAttack = val.playerAttack;
			HitInfo hitInfo = new HitInfo();
			hitInfo.LoadFromAttack(playerAttack.attack, serverSide: true);
			hitInfo.Initiator = this;
			hitInfo.ProjectileID = playerAttack.projectileID;
			hitInfo.ProjectileDistance = val.hitDistance;
			hitInfo.ProjectileVelocity = val.hitVelocity;
			hitInfo.ProjectileTravelTime = val.travelTime;
			hitInfo.Predicted = msg.connection;
			if (hitInfo.IsNaNOrInfinity() || float.IsNaN(val.travelTime) || float.IsInfinity(val.travelTime))
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Contains NaN (" + playerAttack.projectileID + ")");
				stats.combat.LogInvalid(hitInfo, "projectile_nan");
				return;
			}
			if (!firedProjectiles.TryGetValue(playerAttack.projectileID, out var value))
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Missing ID (" + playerAttack.projectileID + ")", logToAnalytics: false);
				stats.combat.LogInvalid(hitInfo, "projectile_invalid");
				return;
			}
			hitInfo.ProjectileHits = value.hits;
			hitInfo.ProjectileIntegrity = value.integrity;
			hitInfo.ProjectileTrajectoryMismatch = value.trajectoryMismatch;
			if (value.integrity <= 0f)
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Integrity is zero (" + playerAttack.projectileID + ")");
				Analytics.Azure.OnProjectileHackViolation(value);
				stats.combat.LogInvalid(hitInfo, "projectile_integrity");
				return;
			}
			if (value.firedTime < Time.realtimeSinceStartup - 8f)
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Lifetime is zero (" + playerAttack.projectileID + ")");
				Analytics.Azure.OnProjectileHackViolation(value);
				stats.combat.LogInvalid(hitInfo, "projectile_lifetime");
				return;
			}
			if (value.ricochets > 0)
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Projectile is ricochet (" + playerAttack.projectileID + ")");
				Analytics.Azure.OnProjectileHackViolation(value);
				stats.combat.LogInvalid(hitInfo, "projectile_ricochet");
				return;
			}
			hitInfo.Weapon = value.weaponSource;
			hitInfo.WeaponPrefab = value.weaponPrefab;
			hitInfo.ProjectilePrefab = value.projectilePrefab;
			hitInfo.damageProperties = value.projectilePrefab.damageProperties;
			Vector3 position = value.position;
			Vector3 initialPositionOffset = value.initialPositionOffset;
			Vector3 positionOffset = value.positionOffset;
			Vector3 velocity = value.velocity;
			float partialTime = value.partialTime;
			float travelTime = value.travelTime;
			float num = Mathf.Clamp(val.travelTime, value.travelTime, 8f);
			Vector3 gravity = Physics.gravity * value.projectilePrefab.gravityModifier;
			float drag = value.projectilePrefab.drag;
			BaseEntity hitEntity = hitInfo.HitEntity;
			BasePlayer basePlayer = hitEntity as BasePlayer;
			bool flag = (Object)(object)basePlayer != (Object)null;
			bool flag2 = flag && basePlayer.IsSleeping();
			bool flag3 = flag && basePlayer.IsWounded();
			bool flag4 = flag && basePlayer.isMounted;
			bool flag5 = flag && basePlayer.HasParent();
			bool flag6 = (Object)(object)hitEntity != (Object)null;
			bool flag7 = flag6 && hitEntity.IsNpc;
			bool flag8 = hitInfo.HitMaterial == Projectile.WaterMaterialID();
			bool flag9;
			int num15;
			Vector3 val2;
			Vector3 position2;
			Vector3 pointStart;
			Vector3 val4;
			Vector3 val5;
			bool flag10;
			int num36;
			if (value.protection > 0)
			{
				flag9 = true;
				float num2 = 1f + ConVar.AntiHack.projectile_forgiveness;
				float num3 = 1f - ConVar.AntiHack.projectile_forgiveness;
				float projectile_clientframes = ConVar.AntiHack.projectile_clientframes;
				float projectile_serverframes = ConVar.AntiHack.projectile_serverframes;
				float num4 = Mathx.Decrement(value.firedTime);
				float num5 = Mathf.Clamp(Mathx.Increment(Time.realtimeSinceStartup) - num4, 0f, 8f);
				float num6 = num;
				float num7 = (value.desyncLifeTime = Mathf.Abs(num5 - num6));
				float num8 = Mathf.Min(num5, num6);
				float num9 = projectile_clientframes / 60f;
				float num10 = projectile_serverframes * Mathx.Max(Time.deltaTime, Time.smoothDeltaTime, Time.fixedDeltaTime);
				float num11 = (desyncTimeClamped + num8 + num9 + num10) * num2;
				float num12 = ((value.protection >= 6) ? ((desyncTimeClamped + num9 + num10) * num2) : num11);
				float num13 = (num5 - desyncTimeClamped - num9 - num10) * num3;
				float num14 = Vector3.Distance(value.initialPosition, hitInfo.HitPositionWorld);
				num15 = 1075904512;
				if (ConVar.AntiHack.projectile_terraincheck)
				{
					num15 |= 0x800000;
				}
				if (ConVar.AntiHack.projectile_vehiclecheck)
				{
					num15 |= 0x8000000;
				}
				if (flag6 && net.group != null && hitEntity.net != null && hitEntity.net.group != null && !net.subscriber.IsSubscribed(hitEntity.net.group))
				{
					AntiHack.Log(this, AntiHackType.ProjectileHack, "Entity out of network range");
					stats.combat.LogInvalid(hitInfo, "projectile_network_range");
					flag9 = false;
				}
				if (flag && hitInfo.boneArea == (HitArea)(-1))
				{
					string name = ((Object)hitInfo.ProjectilePrefab).name;
					string text = (flag6 ? hitEntity.ShortPrefabName : "world");
					AntiHack.Log(this, AntiHackType.ProjectileHack, "Bone is invalid (" + name + " on " + text + " bone " + hitInfo.HitBone + ")");
					stats.combat.LogInvalid(hitInfo, "projectile_bone");
					flag9 = false;
				}
				if (flag8)
				{
					if (flag6)
					{
						string name2 = ((Object)hitInfo.ProjectilePrefab).name;
						string text2 = (flag6 ? hitEntity.ShortPrefabName : "world");
						AntiHack.Log(this, AntiHackType.ProjectileHack, "Projectile water hit on entity (" + name2 + " on " + text2 + ")");
						Analytics.Azure.OnProjectileHackViolation(value);
						stats.combat.LogInvalid(hitInfo, "water_entity");
						flag9 = false;
					}
					if (!WaterLevel.Test(hitInfo.HitPositionWorld - 0.5f * Vector3.up, waves: true, volumes: true, this))
					{
						string name3 = ((Object)hitInfo.ProjectilePrefab).name;
						string text3 = (flag6 ? hitEntity.ShortPrefabName : "world");
						AntiHack.Log(this, AntiHackType.ProjectileHack, "Projectile water level (" + name3 + " on " + text3 + ")");
						Analytics.Azure.OnProjectileHackViolation(value);
						stats.combat.LogInvalid(hitInfo, "water_level");
						flag9 = false;
					}
				}
				if (value.protection >= 2)
				{
					if (flag6 || (value.protection < 6 && flag))
					{
						float num16 = hitEntity.MaxVelocity();
						val2 = hitEntity.GetParentVelocity();
						float num17 = num16 + ((Vector3)(ref val2)).magnitude;
						float num18 = hitEntity.BoundsPadding() + num12 * num17;
						float num19 = (value.entityDistance = hitEntity.Distance(hitInfo.HitPositionWorld));
						if (num19 > num18)
						{
							string name4 = ((Object)hitInfo.ProjectilePrefab).name;
							string shortPrefabName = hitEntity.ShortPrefabName;
							AntiHack.Log(this, AntiHackType.ProjectileHack, "Entity too far away (" + name4 + " on " + shortPrefabName + " with " + num19 + "m > " + num18 + "m in " + num12 + "s)");
							Analytics.Azure.OnProjectileHackViolation(value);
							stats.combat.LogInvalid(hitInfo, "entity_distance");
							flag9 = false;
						}
					}
					if (value.protection >= 6 && flag9 && flag && !flag7 && !flag2 && !flag3 && !flag4 && !flag5)
					{
						val2 = basePlayer.GetParentVelocity();
						float magnitude = ((Vector3)(ref val2)).magnitude;
						float num20 = basePlayer.BoundsPadding() + num12 * magnitude + ConVar.AntiHack.tickhistoryforgiveness;
						float num21 = (value.entityDistance = basePlayer.tickHistory.Distance(basePlayer, hitInfo.HitPositionWorld));
						if (num21 > num20)
						{
							string name5 = ((Object)hitInfo.ProjectilePrefab).name;
							string shortPrefabName2 = basePlayer.ShortPrefabName;
							AntiHack.Log(this, AntiHackType.ProjectileHack, "Player too far away (" + name5 + " on " + shortPrefabName2 + " with " + num21 + "m > " + num20 + "m in " + num12 + "s)");
							Analytics.Azure.OnProjectileHackViolation(value);
							stats.combat.LogInvalid(hitInfo, "player_distance");
							flag9 = false;
						}
					}
				}
				if (value.protection >= 1)
				{
					float num22;
					if (!flag6)
					{
						num22 = 0f;
					}
					else
					{
						float num23 = hitEntity.MaxVelocity();
						val2 = hitEntity.GetParentVelocity();
						num22 = num23 + ((Vector3)(ref val2)).magnitude;
					}
					float num24 = num22;
					float num25 = (flag6 ? (num12 * num24) : 0f);
					float magnitude2 = ((Vector3)(ref value.initialVelocity)).magnitude;
					float num26 = hitInfo.ProjectilePrefab.initialDistance + num11 * magnitude2;
					float num27 = hitInfo.ProjectileDistance + 1f + ((Vector3)(ref positionOffset)).magnitude + num25;
					val2 = estimatedVelocity;
					float num28 = num27 + ((Vector3)(ref val2)).magnitude;
					if (num14 > num26)
					{
						string name6 = ((Object)hitInfo.ProjectilePrefab).name;
						string text4 = (flag6 ? hitEntity.ShortPrefabName : "world");
						AntiHack.Log(this, AntiHackType.ProjectileHack, "Projectile too fast (" + name6 + " on " + text4 + " with " + num14 + "m > " + num26 + "m in " + num11 + "s)");
						Analytics.Azure.OnProjectileHackViolation(value);
						stats.combat.LogInvalid(hitInfo, "projectile_maxspeed");
						flag9 = false;
					}
					if (num14 > num28)
					{
						string name7 = ((Object)hitInfo.ProjectilePrefab).name;
						string text5 = (flag6 ? hitEntity.ShortPrefabName : "world");
						AntiHack.Log(this, AntiHackType.ProjectileHack, "Projectile too far away (" + name7 + " on " + text5 + " with " + num14 + "m > " + num28 + "m in " + num11 + "s)");
						Analytics.Azure.OnProjectileHackViolation(value);
						stats.combat.LogInvalid(hitInfo, "projectile_distance");
						flag9 = false;
					}
					if (num7 > ConVar.AntiHack.projectile_desync)
					{
						string name8 = ((Object)hitInfo.ProjectilePrefab).name;
						string text6 = (flag6 ? hitEntity.ShortPrefabName : "world");
						AntiHack.Log(this, AntiHackType.ProjectileHack, "Projectile desync (" + name8 + " on " + text6 + " with " + num7 + "s > " + ConVar.AntiHack.projectile_desync + "s)");
						Analytics.Azure.OnProjectileHackViolation(value);
						stats.combat.LogInvalid(hitInfo, "projectile_desync");
						flag9 = false;
					}
				}
				if (value.protection >= 4)
				{
					float num29 = 0f;
					if (flag6)
					{
						val2 = hitEntity.GetParentVelocity();
						float num30 = ((Vector3)(ref val2)).magnitude;
						if (hitEntity is CargoShip || hitEntity is Tugboat)
						{
							num30 += hitEntity.MaxVelocity();
						}
						num29 = num12 * num30;
					}
					SimulateProjectile(ref position, ref velocity, ref partialTime, num - travelTime, gravity, drag, out var prevPosition, out var prevVelocity);
					Line val3 = default(Line);
					((Line)(ref val3))..ctor(prevPosition - prevVelocity, position + prevVelocity);
					float num31 = (value.startPointMismatch = Mathf.Max(((Line)(ref val3)).Distance(hitInfo.PointStart) - ((Vector3)(ref initialPositionOffset)).magnitude - num29, 0f));
					float num32 = (value.endPointMismatch = Mathf.Max(((Line)(ref val3)).Distance(hitInfo.HitPositionWorld) - ((Vector3)(ref initialPositionOffset)).magnitude - num29, 0f));
					if (num31 > ConVar.AntiHack.projectile_trajectory)
					{
						string name9 = ((Object)value.projectilePrefab).name;
						string text7 = (flag6 ? hitEntity.ShortPrefabName : "world");
						AntiHack.Log(this, AntiHackType.ProjectileHack, "Start position trajectory (" + name9 + " on " + text7 + " with " + num31 + "m > " + ConVar.AntiHack.projectile_trajectory + "m)");
						Analytics.Azure.OnProjectileHackViolation(value);
						stats.combat.LogInvalid(hitInfo, "trajectory_start");
						flag9 = false;
					}
					if (num32 > ConVar.AntiHack.projectile_trajectory)
					{
						string name10 = ((Object)value.projectilePrefab).name;
						string text8 = (flag6 ? hitEntity.ShortPrefabName : "world");
						AntiHack.Log(this, AntiHackType.ProjectileHack, "End position trajectory (" + name10 + " on " + text8 + " with " + num32 + "m > " + ConVar.AntiHack.projectile_trajectory + "m)");
						Analytics.Azure.OnProjectileHackViolation(value);
						stats.combat.LogInvalid(hitInfo, "trajectory_end");
						flag9 = false;
					}
					if (hitInfo.ProjectileTrajectoryMismatch > ConVar.AntiHack.projectile_trajectory_update)
					{
						string name11 = ((Object)value.projectilePrefab).name;
						string text9 = (flag6 ? hitEntity.ShortPrefabName : "world");
						AntiHack.Log(this, AntiHackType.ProjectileHack, "Update position trajectory (" + name11 + " on " + text9 + " with " + hitInfo.ProjectileTrajectoryMismatch + "m > " + ConVar.AntiHack.projectile_trajectory_update + "m)");
						Analytics.Azure.OnProjectileHackViolation(value);
						stats.combat.LogInvalid(hitInfo, "trajectory_update_total");
						flag9 = false;
					}
					hitInfo.ProjectileVelocity = velocity;
					if (val.hitVelocity != Vector3.zero && velocity != Vector3.zero)
					{
						float num33 = Vector3.Angle(val.hitVelocity, velocity);
						float num34 = ((Vector3)(ref val.hitVelocity)).magnitude / ((Vector3)(ref velocity)).magnitude;
						if (num33 > ConVar.AntiHack.projectile_anglechange)
						{
							string name12 = ((Object)value.projectilePrefab).name;
							string text10 = (flag6 ? hitEntity.ShortPrefabName : "world");
							AntiHack.Log(this, AntiHackType.ProjectileHack, "Trajectory angle change (" + name12 + " on " + text10 + " with " + num33 + "deg > " + ConVar.AntiHack.projectile_anglechange + "deg)");
							Analytics.Azure.OnProjectileHackViolation(value);
							stats.combat.LogInvalid(hitInfo, "angle_change");
							flag9 = false;
						}
						if (num34 > ConVar.AntiHack.projectile_velocitychange)
						{
							string name13 = ((Object)value.projectilePrefab).name;
							string text11 = (flag6 ? hitEntity.ShortPrefabName : "world");
							AntiHack.Log(this, AntiHackType.ProjectileHack, "Trajectory velocity change (" + name13 + " on " + text11 + " with " + num34 + " > " + ConVar.AntiHack.projectile_velocitychange + ")");
							Analytics.Azure.OnProjectileHackViolation(value);
							stats.combat.LogInvalid(hitInfo, "velocity_change");
							flag9 = false;
						}
					}
					float magnitude3 = ((Vector3)(ref velocity)).magnitude;
					float num35 = num13 * magnitude3;
					if (num14 < num35)
					{
						string name14 = ((Object)hitInfo.ProjectilePrefab).name;
						string text12 = (flag6 ? hitEntity.ShortPrefabName : "world");
						AntiHack.Log(this, AntiHackType.ProjectileHack, "Projectile too slow (" + name14 + " on " + text12 + " with " + num14 + "m < " + num35 + "m in " + num13 + "s)");
						Analytics.Azure.OnProjectileHackViolation(value);
						stats.combat.LogInvalid(hitInfo, "projectile_minspeed");
						flag9 = false;
					}
				}
				if (value.protection >= 3)
				{
					position2 = value.position;
					pointStart = hitInfo.PointStart;
					val4 = hitInfo.HitPositionWorld;
					if (!flag8)
					{
						val4 -= ((Vector3)(ref hitInfo.ProjectileVelocity)).normalized * 0.001f;
					}
					val5 = hitInfo.PositionOnRay(val4);
					Vector3 val6 = Vector3.zero;
					Vector3 val7 = Vector3.zero;
					if (ConVar.AntiHack.projectile_backtracking > 0f)
					{
						val2 = pointStart - position2;
						val6 = ((Vector3)(ref val2)).normalized * ConVar.AntiHack.projectile_backtracking;
						val2 = val5 - pointStart;
						val7 = ((Vector3)(ref val2)).normalized * ConVar.AntiHack.projectile_backtracking;
					}
					flag10 = GamePhysics.LineOfSight(position2 - val6, pointStart + val6, num15, value.lastEntityHit) && GamePhysics.LineOfSight(pointStart - val7, val5, num15, value.lastEntityHit) && GamePhysics.LineOfSight(val5, val4, num15, value.lastEntityHit);
					bool flag11 = true;
					if (flag10)
					{
						flag11 = GamePhysics.LineOfSight(position2, val4, num15, value.lastEntityHit) && GamePhysics.LineOfSight(val4, position2, num15, value.lastEntityHit);
					}
					bool flag12 = true;
					if (flag10)
					{
						List<Vector3> simulatedPositions = value.simulatedPositions;
						if (simulatedPositions.Count > ConVar.AntiHack.projectile_update_limit)
						{
							flag12 = false;
						}
						else
						{
							simulatedPositions.Add(position2);
							for (int i = 1; i < simulatedPositions.Count; i++)
							{
								if (!GamePhysics.LineOfSight(simulatedPositions[i - 1], simulatedPositions[i], num15, value.lastEntityHit) || !GamePhysics.LineOfSight(simulatedPositions[i], simulatedPositions[i - 1], num15, value.lastEntityHit))
								{
									flag12 = false;
									break;
								}
							}
						}
					}
					if (flag10)
					{
						if (!(value.simulatedPositions.Count > 1 && flag12))
						{
							num36 = ((value.simulatedPositions.Count <= 1 && flag11) ? 1 : 0);
							if (num36 == 0)
							{
								goto IL_12b6;
							}
						}
						else
						{
							num36 = 1;
						}
						stats.Add("hit_" + (flag6 ? hitEntity.Categorize() : "world") + "_direct_los", 1, Stats.Server);
						goto IL_1314;
					}
					num36 = 0;
					goto IL_12b6;
				}
				goto IL_1586;
			}
			goto IL_159c;
			IL_159c:
			value.position = hitInfo.HitPositionWorld;
			value.velocity = val.hitVelocity;
			value.travelTime = num;
			value.partialTime = partialTime;
			value.hits++;
			value.lastEntityHit = hitEntity;
			value.simulatedPositions.Clear();
			value.simulatedPositions.Add(position);
			hitInfo.ProjectilePrefab.CalculateDamage(hitInfo, value.projectileModifier, value.integrity);
			if (flag8)
			{
				if (hitInfo.ProjectilePrefab.waterIntegrityLoss > 0f)
				{
					value.integrity = Mathf.Clamp01(value.integrity - hitInfo.ProjectilePrefab.waterIntegrityLoss);
				}
			}
			else if (hitInfo.ProjectilePrefab.penetrationPower <= 0f || !flag6)
			{
				value.integrity = 0f;
			}
			else
			{
				float num37 = hitEntity.PenetrationResistance(hitInfo) / hitInfo.ProjectilePrefab.penetrationPower;
				value.integrity = Mathf.Clamp01(value.integrity - num37);
			}
			if (flag6)
			{
				stats.Add(value.itemMod.category + "_hit_" + hitEntity.Categorize(), 1);
			}
			if (Interface.CallHook("OnPlayerAttack", (object)this, (object)hitInfo) != null)
			{
				return;
			}
			if (value.integrity <= 0f)
			{
				if (hitInfo.ProjectilePrefab.remainInWorld)
				{
					CreateWorldProjectile(hitInfo, value.itemDef, value.itemMod, hitInfo.ProjectilePrefab, value.pickupItem);
				}
				if (value.hits <= ConVar.AntiHack.projectile_impactspawndepth)
				{
					value.itemMod.ServerProjectileHit(hitInfo);
				}
			}
			else if (value.hits == ConVar.AntiHack.projectile_impactspawndepth)
			{
				value.itemMod.ServerProjectileHit(hitInfo);
			}
			firedProjectiles[playerAttack.projectileID] = value;
			if (flag6)
			{
				if (value.hits <= ConVar.AntiHack.projectile_damagedepth)
				{
					hitEntity.OnAttacked(hitInfo);
					value.itemMod.ServerProjectileHitEntity(hitInfo);
				}
				else
				{
					stats.combat.LogInvalid(hitInfo, "ricochet");
				}
			}
			Projectile.CustomEffectData clientEffectData = value.projectilePrefab.clientEffectData;
			bool playDefaultHitEffects = value.projectilePrefab.playDefaultHitEffects;
			GameObjectRef clientEffectPrefab = value.projectilePrefab.clientEffectPrefab;
			if (!clientEffectData.UseCustomEffect || playDefaultHitEffects)
			{
				Effect.server.ImpactEffect(hitInfo);
			}
			if (clientEffectData.UseCustomEffect)
			{
				string text13 = null;
				if (clientEffectPrefab != null && clientEffectPrefab.isValid)
				{
					text13 = clientEffectPrefab.resourcePath;
				}
				if (text13 != null)
				{
					Effect.server.ImpactEffect(hitInfo, text13);
				}
			}
			hitInfo.DoHitEffects = hitInfo.ProjectilePrefab.doDefaultHitEffects;
			SingletonComponent<NpcNoiseManager>.Instance.OnProjectileHit(this, hitInfo);
			return;
			IL_12b6:
			stats.Add("hit_" + (flag6 ? hitEntity.Categorize() : "world") + "_indirect_los", 1, Stats.Server);
			goto IL_1314;
			IL_1314:
			if (num36 == 0)
			{
				string name15 = ((Object)hitInfo.ProjectilePrefab).name;
				string text14 = (flag6 ? hitEntity.ShortPrefabName : "world");
				string description = ((!flag10) ? "projectile_los" : "projectile_los_detailed");
				string[] obj = new string[12]
				{
					"Line of sight (", name15, " on ", text14, ") ", null, null, null, null, null,
					null, null
				};
				val2 = position2;
				obj[5] = ((object)(Vector3)(ref val2)/*cast due to .constrained prefix*/).ToString();
				obj[6] = " ";
				val2 = pointStart;
				obj[7] = ((object)(Vector3)(ref val2)/*cast due to .constrained prefix*/).ToString();
				obj[8] = " ";
				val2 = val5;
				obj[9] = ((object)(Vector3)(ref val2)/*cast due to .constrained prefix*/).ToString();
				obj[10] = " ";
				val2 = val4;
				obj[11] = ((object)(Vector3)(ref val2)/*cast due to .constrained prefix*/).ToString();
				AntiHack.Log(this, AntiHackType.ProjectileHack, string.Concat(obj));
				Analytics.Azure.OnProjectileHackViolation(value);
				stats.combat.LogInvalid(hitInfo, description);
				flag9 = false;
			}
			if (flag9 && flag && !flag7)
			{
				Vector3 hitPositionWorld = hitInfo.HitPositionWorld;
				Vector3 position3 = basePlayer.eyes.position;
				Vector3 val8 = basePlayer.CenterPoint();
				float projectile_losforgiveness = ConVar.AntiHack.projectile_losforgiveness;
				bool flag13 = GamePhysics.LineOfSight(hitPositionWorld, position3, num15, 0f, projectile_losforgiveness) && GamePhysics.LineOfSight(position3, hitPositionWorld, num15, projectile_losforgiveness, 0f);
				if (!flag13)
				{
					flag13 = GamePhysics.LineOfSight(hitPositionWorld, val8, num15, 0f, projectile_losforgiveness) && GamePhysics.LineOfSight(val8, hitPositionWorld, num15, projectile_losforgiveness, 0f);
				}
				if (!flag13)
				{
					string name16 = ((Object)hitInfo.ProjectilePrefab).name;
					string text15 = (flag6 ? hitEntity.ShortPrefabName : "world");
					string[] obj2 = new string[12]
					{
						"Line of sight (", name16, " on ", text15, ") ", null, null, null, null, null,
						null, null
					};
					val2 = hitPositionWorld;
					obj2[5] = ((object)(Vector3)(ref val2)/*cast due to .constrained prefix*/).ToString();
					obj2[6] = " ";
					val2 = position3;
					obj2[7] = ((object)(Vector3)(ref val2)/*cast due to .constrained prefix*/).ToString();
					obj2[8] = " or ";
					val2 = hitPositionWorld;
					obj2[9] = ((object)(Vector3)(ref val2)/*cast due to .constrained prefix*/).ToString();
					obj2[10] = " ";
					val2 = val8;
					obj2[11] = ((object)(Vector3)(ref val2)/*cast due to .constrained prefix*/).ToString();
					AntiHack.Log(this, AntiHackType.ProjectileHack, string.Concat(obj2));
					Analytics.Azure.OnProjectileHackViolation(value);
					stats.combat.LogInvalid(hitInfo, "projectile_los");
					flag9 = false;
				}
			}
			goto IL_1586;
			IL_1586:
			if (!flag9)
			{
				AntiHack.AddViolation(this, AntiHackType.ProjectileHack, ConVar.AntiHack.projectile_penalty);
				return;
			}
			goto IL_159c;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	public void OnProjectileRicochet(RPCMessage msg)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		PlayerProjectileRicochet val = msg.read.Proto<PlayerProjectileRicochet>((PlayerProjectileRicochet)null);
		try
		{
			if (val != null)
			{
				FiredProjectile value;
				if (Vector3Ex.IsNaNOrInfinity(val.hitPosition) || Vector3Ex.IsNaNOrInfinity(val.inVelocity) || Vector3Ex.IsNaNOrInfinity(val.outVelocity) || Vector3Ex.IsNaNOrInfinity(val.hitNormal) || float.IsNaN(val.travelTime) || float.IsInfinity(val.travelTime))
				{
					AntiHack.Log(this, AntiHackType.ProjectileHack, "Contains NaN (" + val.projectileID + ")");
				}
				else if (!firedProjectiles.TryGetValue(val.projectileID, out value))
				{
					AntiHack.Log(this, AntiHackType.ProjectileHack, "Missing ID (" + val.projectileID + ")", logToAnalytics: false);
				}
				else if (value.firedTime < Time.realtimeSinceStartup - 8f)
				{
					AntiHack.Log(this, AntiHackType.ProjectileHack, "Lifetime is zero (" + val.projectileID + ")");
				}
				else if (Interface.CallHook("OnProjectileRicochet", (object)this, (object)val) == null)
				{
					value.ricochets++;
					firedProjectiles[val.projectileID] = value;
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	public void OnProjectileUpdate(RPCMessage msg)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0785: Unknown result type (might be due to invalid IL or missing references)
		//IL_078a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0792: Unknown result type (might be due to invalid IL or missing references)
		//IL_0797: Unknown result type (might be due to invalid IL or missing references)
		//IL_079f: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_07dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0809: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_05be: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_05cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_05cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_06cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_06da: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0600: Unknown result type (might be due to invalid IL or missing references)
		//IL_0602: Unknown result type (might be due to invalid IL or missing references)
		//IL_0607: Unknown result type (might be due to invalid IL or missing references)
		//IL_0609: Unknown result type (might be due to invalid IL or missing references)
		//IL_060b: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0703: Unknown result type (might be due to invalid IL or missing references)
		//IL_0708: Unknown result type (might be due to invalid IL or missing references)
		//IL_064b: Unknown result type (might be due to invalid IL or missing references)
		//IL_064d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0667: Unknown result type (might be due to invalid IL or missing references)
		//IL_0669: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_076d: Unknown result type (might be due to invalid IL or missing references)
		//IL_076f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0715: Unknown result type (might be due to invalid IL or missing references)
		//IL_071a: Unknown result type (might be due to invalid IL or missing references)
		//IL_071c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0721: Unknown result type (might be due to invalid IL or missing references)
		//IL_0724: Unknown result type (might be due to invalid IL or missing references)
		//IL_0729: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0758: Unknown result type (might be due to invalid IL or missing references)
		//IL_075a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0760: Unknown result type (might be due to invalid IL or missing references)
		//IL_0765: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_040c: Unknown result type (might be due to invalid IL or missing references)
		//IL_040e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0413: Unknown result type (might be due to invalid IL or missing references)
		//IL_0415: Unknown result type (might be due to invalid IL or missing references)
		//IL_0417: Unknown result type (might be due to invalid IL or missing references)
		//IL_041b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0420: Unknown result type (might be due to invalid IL or missing references)
		//IL_0425: Unknown result type (might be due to invalid IL or missing references)
		//IL_0427: Unknown result type (might be due to invalid IL or missing references)
		//IL_0429: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0430: Unknown result type (might be due to invalid IL or missing references)
		//IL_0432: Unknown result type (might be due to invalid IL or missing references)
		//IL_0434: Unknown result type (might be due to invalid IL or missing references)
		//IL_0438: Unknown result type (might be due to invalid IL or missing references)
		//IL_043d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0442: Unknown result type (might be due to invalid IL or missing references)
		//IL_0471: Unknown result type (might be due to invalid IL or missing references)
		//IL_0473: Unknown result type (might be due to invalid IL or missing references)
		//IL_0475: Unknown result type (might be due to invalid IL or missing references)
		//IL_047a: Unknown result type (might be due to invalid IL or missing references)
		//IL_047c: Unknown result type (might be due to invalid IL or missing references)
		//IL_047e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0482: Unknown result type (might be due to invalid IL or missing references)
		//IL_0487: Unknown result type (might be due to invalid IL or missing references)
		//IL_048c: Unknown result type (might be due to invalid IL or missing references)
		//IL_048e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0490: Unknown result type (might be due to invalid IL or missing references)
		//IL_0492: Unknown result type (might be due to invalid IL or missing references)
		//IL_0497: Unknown result type (might be due to invalid IL or missing references)
		//IL_0499: Unknown result type (might be due to invalid IL or missing references)
		//IL_049b: Unknown result type (might be due to invalid IL or missing references)
		//IL_049f: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a9: Unknown result type (might be due to invalid IL or missing references)
		PlayerProjectileUpdate val = msg.read.Proto<PlayerProjectileUpdate>((PlayerProjectileUpdate)null);
		try
		{
			if (val == null)
			{
				return;
			}
			if (Vector3Ex.IsNaNOrInfinity(val.curPosition) || Vector3Ex.IsNaNOrInfinity(val.curVelocity) || float.IsNaN(val.travelTime) || float.IsInfinity(val.travelTime))
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Contains NaN (" + val.projectileID + ")");
				return;
			}
			if (!firedProjectiles.TryGetValue(val.projectileID, out var value))
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Missing ID (" + val.projectileID + ")", logToAnalytics: false);
				return;
			}
			if (value.firedTime < Time.realtimeSinceStartup - 8f)
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Lifetime is zero (" + val.projectileID + ")");
				Analytics.Azure.OnProjectileHackViolation(value);
				return;
			}
			if (value.ricochets > 0)
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Projectile is ricochet (" + val.projectileID + ")");
				Analytics.Azure.OnProjectileHackViolation(value);
				return;
			}
			Vector3 position = value.position;
			Vector3 positionOffset = value.positionOffset;
			Vector3 velocity = value.velocity;
			float num = value.trajectoryMismatch;
			float partialTime = value.partialTime;
			float travelTime = value.travelTime;
			float num2 = Mathf.Clamp(val.travelTime, value.travelTime, 8f);
			Vector3 val2 = Physics.gravity * value.projectilePrefab.gravityModifier;
			float drag = value.projectilePrefab.drag;
			if (value.protection > 0)
			{
				float num3 = 1f - ConVar.AntiHack.projectile_forgiveness;
				float num4 = 1f + ConVar.AntiHack.projectile_forgiveness;
				float projectile_clientframes = ConVar.AntiHack.projectile_clientframes;
				float projectile_serverframes = ConVar.AntiHack.projectile_serverframes;
				float num5 = Mathx.Decrement(value.firedTime);
				float num6 = Mathf.Clamp(Mathx.Increment(Time.realtimeSinceStartup) - num5, 0f, 8f);
				float num7 = num2;
				float num8 = (value.desyncLifeTime = Mathf.Abs(num6 - num7));
				float num9 = Mathf.Min(num6, num7);
				float num10 = projectile_clientframes / 60f;
				float num11 = projectile_serverframes * Mathx.Max(Time.deltaTime, Time.smoothDeltaTime, Time.fixedDeltaTime);
				float num12 = (num9 + desyncTimeClamped + num10 + num11) * num4;
				float num13 = Mathf.Max(0f, (num9 - desyncTimeClamped - num10 - num11) * num3);
				int num14 = 1075904512;
				if (ConVar.AntiHack.projectile_terraincheck)
				{
					num14 |= 0x800000;
				}
				if (ConVar.AntiHack.projectile_vehiclecheck)
				{
					num14 |= 0x8000000;
				}
				if (value.protection >= 1)
				{
					float num15 = value.projectilePrefab.initialDistance + num12 * ((Vector3)(ref value.initialVelocity)).magnitude;
					float num16 = Vector3.Distance(value.initialPosition, val.curPosition);
					if (num16 > num15)
					{
						string name = ((Object)value.projectilePrefab).name;
						AntiHack.Log(this, AntiHackType.ProjectileHack, "Projectile distance (" + name + " with " + num16 + "m > " + num15 + "m in " + num12 + "s)");
						Analytics.Azure.OnProjectileHackViolation(value);
						return;
					}
					if (num8 > ConVar.AntiHack.projectile_desync)
					{
						string name2 = ((Object)value.projectilePrefab).name;
						AntiHack.Log(this, AntiHackType.ProjectileHack, "Projectile desync (" + name2 + " with " + num8 + "s > " + ConVar.AntiHack.projectile_desync + "s)");
						Analytics.Azure.OnProjectileHackViolation(value);
						return;
					}
					Vector3 curVelocity = val.curVelocity;
					Vector3 val3 = value.initialVelocity;
					Vector3 val4 = ((value.hits == 0) ? val3 : value.velocity);
					float num17 = drag * (1f / 32f);
					Vector3 val5 = val2 * (1f / 32f);
					int num18 = Mathf.FloorToInt(num13 / (1f / 32f));
					int num19 = Mathf.CeilToInt(num12 / (1f / 32f));
					for (int i = 0; i < num18; i++)
					{
						val3 += val5;
						val3 -= val3 * num17;
						val4 += val5;
						val4 -= val4 * num17;
					}
					float magnitude = ((Vector3)(ref curVelocity)).magnitude;
					float magnitude2 = ((Vector3)(ref val3)).magnitude;
					float magnitude3 = ((Vector3)(ref val4)).magnitude;
					for (int j = num18; j < num19; j++)
					{
						val3 += val5;
						val3 -= val3 * num17;
						val4 += val5;
						val4 -= val4 * num17;
					}
					magnitude3 = Mathf.Min(magnitude3, ((Vector3)(ref val4)).magnitude);
					magnitude2 = Mathf.Max(magnitude2, ((Vector3)(ref val3)).magnitude);
					if (magnitude < magnitude3 * num3)
					{
						string name3 = ((Object)value.projectilePrefab).name;
						AntiHack.Log(this, AntiHackType.ProjectileHack, "Projectile velocity too low (" + name3 + " with " + magnitude + " < " + magnitude3 + ")");
						Analytics.Azure.OnProjectileHackViolation(value);
						return;
					}
					if (magnitude > magnitude2 * num4)
					{
						string name4 = ((Object)value.projectilePrefab).name;
						AntiHack.Log(this, AntiHackType.ProjectileHack, "Projectile velocity too high (" + name4 + " with " + magnitude + " > " + magnitude2 + ")");
						Analytics.Azure.OnProjectileHackViolation(value);
						return;
					}
				}
				if (value.protection >= 3)
				{
					Vector3 position2 = value.position;
					Vector3 curPosition = val.curPosition;
					Vector3 val6 = Vector3.zero;
					Vector3 val7;
					if (ConVar.AntiHack.projectile_backtracking > 0f)
					{
						val7 = curPosition - position2;
						val6 = ((Vector3)(ref val7)).normalized * ConVar.AntiHack.projectile_backtracking;
					}
					if (!GamePhysics.LineOfSight(position2 - val6, curPosition + val6, num14, value.lastEntityHit))
					{
						string name5 = ((Object)value.projectilePrefab).name;
						string[] obj = new string[6] { "Line of sight (", name5, " on update) ", null, null, null };
						val7 = position2;
						obj[3] = ((object)(Vector3)(ref val7)/*cast due to .constrained prefix*/).ToString();
						obj[4] = " ";
						val7 = curPosition;
						obj[5] = ((object)(Vector3)(ref val7)/*cast due to .constrained prefix*/).ToString();
						AntiHack.Log(this, AntiHackType.ProjectileHack, string.Concat(obj));
						Analytics.Azure.OnProjectileHackViolation(value);
						return;
					}
				}
				if (value.protection >= 4)
				{
					SimulateProjectile(ref position, ref velocity, ref partialTime, num2 - travelTime, val2, drag, out var prevPosition, out var prevVelocity);
					value.simulatedPositions.Add(position);
					Line val8 = default(Line);
					((Line)(ref val8))..ctor(prevPosition - prevVelocity, position + prevVelocity);
					num += Mathf.Max(((Line)(ref val8)).Distance(val.curPosition) - ((Vector3)(ref positionOffset)).magnitude, 0f);
				}
				if (value.protection >= 5)
				{
					if (value.inheritedVelocity != Vector3.zero)
					{
						Vector3 curVelocity2 = value.inheritedVelocity + velocity;
						Vector3 curVelocity3 = val.curVelocity;
						if (((Vector3)(ref curVelocity3)).magnitude > 2f * ((Vector3)(ref curVelocity2)).magnitude || ((Vector3)(ref curVelocity3)).magnitude < 0.5f * ((Vector3)(ref curVelocity2)).magnitude)
						{
							val.curVelocity = curVelocity2;
						}
						value.inheritedVelocity = Vector3.zero;
					}
					else
					{
						val.curVelocity = velocity;
					}
				}
			}
			value.updates.Add(new FiredProjectileUpdate
			{
				OldPosition = value.position,
				NewPosition = val.curPosition,
				OldVelocity = value.velocity,
				NewVelocity = val.curVelocity,
				Mismatch = num,
				PartialTime = partialTime
			});
			value.position = val.curPosition;
			value.velocity = val.curVelocity;
			value.travelTime = val.travelTime;
			value.partialTime = partialTime;
			value.trajectoryMismatch = num;
			value.positionOffset = default(Vector3);
			firedProjectiles[val.projectileID] = value;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void SimulateProjectile(ref Vector3 position, ref Vector3 velocity, ref float partialTime, float travelTime, Vector3 gravity, float drag, out Vector3 prevPosition, out Vector3 prevVelocity)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		float num = 1f / 32f;
		prevPosition = position;
		prevVelocity = velocity;
		if (partialTime > Mathf.Epsilon)
		{
			float num2 = num - partialTime;
			if (travelTime < num2)
			{
				prevPosition = position;
				prevVelocity = velocity;
				position += velocity * travelTime;
				partialTime += travelTime;
				return;
			}
			prevPosition = position;
			prevVelocity = velocity;
			position += velocity * num2;
			velocity += gravity * num;
			velocity -= velocity * (drag * num);
			travelTime -= num2;
		}
		int num3 = Mathf.FloorToInt(travelTime / num);
		for (int i = 0; i < num3; i++)
		{
			prevPosition = position;
			prevVelocity = velocity;
			position += velocity * num;
			velocity += gravity * num;
			velocity -= velocity * (drag * num);
		}
		partialTime = travelTime - num * (float)num3;
		if (partialTime > Mathf.Epsilon)
		{
			prevPosition = position;
			prevVelocity = velocity;
			position += velocity * partialTime;
		}
	}

	protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("CanCreateWorldProjectile", (object)info, (object)itemDef) != null)
		{
			return;
		}
		Vector3 projectileVelocity = info.ProjectileVelocity;
		Item item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));
		if (Interface.CallHook("OnWorldProjectileCreate", (object)info, (object)item) != null)
		{
			return;
		}
		BaseEntity baseEntity = null;
		if (!info.DidHit)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(((Vector3)(ref projectileVelocity)).normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.breakProbability > 0f && Random.value <= projectilePrefab.breakProbability)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(((Vector3)(ref projectileVelocity)).normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.conditionLoss > 0f)
		{
			item.LoseCondition(projectilePrefab.conditionLoss * 100f);
			if (item.isBroken)
			{
				baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(((Vector3)(ref projectileVelocity)).normalized));
				baseEntity.Kill(DestroyMode.Gib);
				return;
			}
		}
		if (projectilePrefab.stickProbability > 0f && Random.value <= projectilePrefab.stickProbability)
		{
			baseEntity = (((Object)(object)info.HitEntity == (Object)null) ? item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(((Vector3)(ref projectileVelocity)).normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(((Component)info.HitEntity).transform.InverseTransformDirection(((Vector3)(ref projectileVelocity)).normalized)), info.HitEntity)));
			DroppedItem droppedItem = baseEntity as DroppedItem;
			if ((Object)(object)droppedItem != (Object)null)
			{
				droppedItem.StickIn();
			}
			else
			{
				((Component)baseEntity).GetComponent<Rigidbody>().isKinematic = true;
			}
		}
		else
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(((Vector3)(ref projectileVelocity)).normalized));
			Rigidbody component = ((Component)baseEntity).GetComponent<Rigidbody>();
			component.AddForce(((Vector3)(ref projectileVelocity)).normalized * 200f);
			component.WakeUp();
		}
	}

	public void CleanupExpiredProjectiles()
	{
		foreach (KeyValuePair<int, FiredProjectile> item in firedProjectiles.Where((KeyValuePair<int, FiredProjectile> x) => x.Value.firedTime < Time.realtimeSinceStartup - 8f - 1f).ToList())
		{
			Analytics.Azure.OnFiredProjectileRemoved(this, item.Value);
			firedProjectiles.Remove(item.Key);
			FiredProjectile value = item.Value;
			Pool.Free<FiredProjectile>(ref value);
		}
	}

	public bool HasFiredProjectile(int id)
	{
		return firedProjectiles.ContainsKey(id);
	}

	public void NoteFiredProjectile(int projectileid, Vector3 startPos, Vector3 startVel, AttackEntity attackEnt, ItemDefinition firedItemDef, Guid projectileGroupId, Vector3 positionOffset, Item pickupItem = null)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_028e: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
		BaseProjectile baseProjectile = attackEnt as BaseProjectile;
		ItemModProjectile component = ((Component)firedItemDef).GetComponent<ItemModProjectile>();
		Projectile component2 = component.projectileObject.Get().GetComponent<Projectile>();
		if (Vector3Ex.IsNaNOrInfinity(startPos) || Vector3Ex.IsNaNOrInfinity(startVel))
		{
			string name = ((Object)component2).name;
			AntiHack.Log(this, AntiHackType.ProjectileHack, "Contains NaN (" + name + ")");
			stats.combat.LogInvalid(this, baseProjectile, "projectile_nan");
			return;
		}
		int projectile_protection = ConVar.AntiHack.projectile_protection;
		Vector3 inheritedVelocity = (((Object)(object)attackEnt != (Object)null) ? attackEnt.GetInheritedVelocity(this, ((Vector3)(ref startVel)).normalized) : Vector3.zero);
		if (projectile_protection >= 1)
		{
			float num = 1f - ConVar.AntiHack.projectile_forgiveness;
			float num2 = 1f + ConVar.AntiHack.projectile_forgiveness;
			float magnitude = ((Vector3)(ref startVel)).magnitude;
			float num3 = component.GetMinVelocity();
			float num4 = component.GetMaxVelocity();
			BaseProjectile baseProjectile2 = attackEnt as BaseProjectile;
			if (Object.op_Implicit((Object)(object)baseProjectile2))
			{
				num3 *= baseProjectile2.GetProjectileVelocityScale();
				num4 *= baseProjectile2.GetProjectileVelocityScale(getMax: true);
			}
			num3 *= num;
			num4 *= num2;
			if (magnitude < num3)
			{
				string name2 = ((Object)component2).name;
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Velocity (" + name2 + " with " + magnitude + " < " + num3 + ")");
				stats.combat.LogInvalid(this, baseProjectile, "projectile_minvelocity");
				return;
			}
			if (magnitude > num4)
			{
				string name3 = ((Object)component2).name;
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Velocity (" + name3 + " with " + magnitude + " > " + num4 + ")");
				stats.combat.LogInvalid(this, baseProjectile, "projectile_maxvelocity");
				return;
			}
		}
		FiredProjectile firedProjectile = Pool.Get<FiredProjectile>();
		firedProjectile.itemDef = firedItemDef;
		firedProjectile.itemMod = component;
		firedProjectile.projectilePrefab = component2;
		firedProjectile.firedTime = Time.realtimeSinceStartup;
		firedProjectile.travelTime = 0f;
		firedProjectile.weaponSource = attackEnt;
		firedProjectile.weaponPrefab = (((Object)(object)attackEnt == (Object)null) ? null : GameManager.server.FindPrefab(StringPool.Get(attackEnt.prefabID)).GetComponent<AttackEntity>());
		firedProjectile.projectileModifier = (((Object)(object)baseProjectile == (Object)null) ? Projectile.Modifier.Default : baseProjectile.GetProjectileModifier());
		firedProjectile.pickupItem = pickupItem;
		firedProjectile.integrity = 1f;
		firedProjectile.position = startPos;
		firedProjectile.initialPositionOffset = positionOffset;
		firedProjectile.positionOffset = positionOffset;
		firedProjectile.velocity = startVel;
		firedProjectile.initialPosition = startPos;
		firedProjectile.initialVelocity = startVel;
		firedProjectile.inheritedVelocity = inheritedVelocity;
		firedProjectile.protection = projectile_protection;
		firedProjectile.ricochets = 0;
		firedProjectile.hits = 0;
		firedProjectile.id = projectileid;
		firedProjectile.attacker = this;
		firedProjectile.simulatedPositions.Add(startPos);
		firedProjectiles.Add(projectileid, firedProjectile);
		Analytics.Azure.OnFiredProjectile(this, firedProjectile, projectileGroupId);
	}

	public void ServerNoteFiredProjectile(int projectileid, Vector3 startPos, Vector3 startVel, AttackEntity attackEnt, ItemDefinition firedItemDef, Item pickupItem = null)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		BaseProjectile baseProjectile = attackEnt as BaseProjectile;
		ItemModProjectile component = ((Component)firedItemDef).GetComponent<ItemModProjectile>();
		Projectile component2 = component.projectileObject.Get().GetComponent<Projectile>();
		int protection = 0;
		Vector3 zero = Vector3.zero;
		if (!Vector3Ex.IsNaNOrInfinity(startPos) && !Vector3Ex.IsNaNOrInfinity(startVel))
		{
			FiredProjectile firedProjectile = Pool.Get<FiredProjectile>();
			firedProjectile.itemDef = firedItemDef;
			firedProjectile.itemMod = component;
			firedProjectile.projectilePrefab = component2;
			firedProjectile.firedTime = Time.realtimeSinceStartup;
			firedProjectile.travelTime = 0f;
			firedProjectile.weaponSource = attackEnt;
			firedProjectile.weaponPrefab = (((Object)(object)attackEnt == (Object)null) ? null : GameManager.server.FindPrefab(StringPool.Get(attackEnt.prefabID)).GetComponent<AttackEntity>());
			firedProjectile.projectileModifier = (((Object)(object)baseProjectile == (Object)null) ? Projectile.Modifier.Default : baseProjectile.GetProjectileModifier());
			firedProjectile.pickupItem = pickupItem;
			firedProjectile.integrity = 1f;
			firedProjectile.trajectoryMismatch = 0f;
			firedProjectile.position = startPos;
			firedProjectile.positionOffset = Vector3.zero;
			firedProjectile.velocity = startVel;
			firedProjectile.initialPosition = startPos;
			firedProjectile.initialVelocity = startVel;
			firedProjectile.inheritedVelocity = zero;
			firedProjectile.protection = protection;
			firedProjectile.ricochets = 0;
			firedProjectile.hits = 0;
			firedProjectile.id = projectileid;
			firedProjectile.attacker = this;
			firedProjectiles.Add(projectileid, firedProjectile);
		}
	}

	public void ApplyRadiation(float radsAmount, bool protection = true)
	{
		if (IsAlive() && !IsSleeping() && !InSafeZone())
		{
			float num = 0f;
			num = (protection ? Radiation.GetRadiationAfterProtection(radsAmount, RadiationProtection()) : Mathf.Max(0f, radsAmount));
			metabolism.ApplyChange(MetabolismAttribute.Type.Radiation, num, 0f);
		}
	}

	public void PlayerInventoryRadioactivityChange(float radAmount, bool hasRads)
	{
		if (!Radiation.water_inventory_damage)
		{
			return;
		}
		if (inflictInventoryRadsAction == null)
		{
			inflictInventoryRadsAction = InflictRadsFromInventory;
		}
		inventoryRads = radAmount;
		if (!hasRads || radAmount < 2500f)
		{
			if (((FacepunchBehaviour)this).IsInvoking(inflictInventoryRadsAction))
			{
				((FacepunchBehaviour)this).CancelInvoke(inflictInventoryRadsAction);
			}
		}
		else if (!((FacepunchBehaviour)this).IsInvoking(inflictInventoryRadsAction))
		{
			((FacepunchBehaviour)this).InvokeRepeating(inflictInventoryRadsAction, 1f, 1f);
		}
	}

	private void InflictRadsFromInventory()
	{
		if (Radiation.water_inventory_damage)
		{
			float num = inventoryRads * Radiation.MaterialToRadsRatio;
			num *= 0.05f;
			ApplyRadiation(num);
		}
	}

	public void RadioactiveLootCheck(List<ItemContainer> containerRefs)
	{
		radiationCheckContainers.Clear();
		radiationCheckContainers.AddRange(containerRefs);
		HasOpenedLoot();
	}

	private void HasOpenedLoot()
	{
		if (Radiation.water_loot_damage)
		{
			hasOpenedLoot = true;
			CheckRadsInContainer();
			InflictRadsFromContainer();
			if (inflictRadsAction == null)
			{
				inflictRadsAction = InflictRadsFromContainer;
			}
			if (checkRadsAction == null)
			{
				checkRadsAction = CheckRadsInContainer;
			}
			if (!((FacepunchBehaviour)this).IsInvoking(checkRadsAction))
			{
				((FacepunchBehaviour)this).InvokeRepeating(checkRadsAction, 1f, 2500f);
			}
			if (!((FacepunchBehaviour)this).IsInvoking(inflictRadsAction))
			{
				((FacepunchBehaviour)this).InvokeRepeating(inflictRadsAction, 1f, 1f);
			}
		}
	}

	public void HasClosedLoot()
	{
		if (((FacepunchBehaviour)this).IsInvoking(inflictRadsAction))
		{
			((FacepunchBehaviour)this).CancelInvoke(inflictRadsAction);
		}
		hasOpenedLoot = false;
	}

	private void InflictRadsFromContainer()
	{
		if (!Radiation.water_loot_damage)
		{
			return;
		}
		if (!hasOpenedLoot)
		{
			if (((FacepunchBehaviour)this).IsInvoking(checkRadsAction))
			{
				((FacepunchBehaviour)this).CancelInvoke(checkRadsAction);
			}
			if (((FacepunchBehaviour)this).IsInvoking(inflictRadsAction))
			{
				((FacepunchBehaviour)this).CancelInvoke(inflictRadsAction);
			}
		}
		else
		{
			ApplyRadiation(containerRads);
		}
	}

	private void CheckRadsInContainer()
	{
		if (!hasOpenedLoot)
		{
			return;
		}
		containerRads = 0f;
		foreach (ItemContainer radiationCheckContainer in radiationCheckContainers)
		{
			containerRads += radiationCheckContainer.GetRadioactiveMaterialInContainer() * Radiation.MaterialToRadsRatio;
		}
		containerRads *= 0.05f;
	}

	public bool IsRagdolling()
	{
		return HasPlayerFlag(PlayerFlags.Ragdolling);
	}

	protected virtual bool AllowRagdoll()
	{
		return true;
	}

	public void Ragdoll(Vector3 velocityOverride = default(Vector3), bool matchPlayerGravity = true, bool flailInAir = false, bool dieOnImpact = false, BaseEntity initiator = null)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (!Physics.allowplayertempragdoll)
		{
			EnsureDismounted();
		}
		else if (!UsedAdminCheat() && AllowRagdoll())
		{
			BaseRagdoll baseRagdoll = CreateRagdoll(((Component)this).transform.position, ((Component)this).transform.rotation, velocityOverride, matchPlayerGravity, flailInAir, dieOnImpact, initiator);
			EnsureDismounted();
			baseRagdoll.AttemptMount(this, doMountChecks: false);
			if (mounted.Get(serverside: true) is BaseRagdoll)
			{
				SetPlayerFlag(PlayerFlags.Ragdolling, b: true);
			}
			SendNetworkUpdateImmediate();
		}
	}

	private BaseRagdoll CreateRagdoll(Vector3 position, Quaternion rotation, Vector3 velocityOverride, bool matchPlayerGravity, bool flailInAir, bool dieOnImpact, BaseEntity initiator)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		BaseRagdoll baseRagdoll = GameManager.server.CreateEntity("assets/prefabs/player/player_temp_ragdoll.prefab") as BaseRagdoll;
		((Component)baseRagdoll).transform.SetPositionAndRotation(position, rotation);
		Ragdoll component = ((Component)baseRagdoll).GetComponent<Ragdoll>();
		if ((Object)(object)component != (Object)null)
		{
			component.simOnServer = true;
		}
		baseRagdoll.InitFromPlayer(this, velocityOverride, matchPlayerGravity, flailInAir, dieOnImpact, initiator);
		baseRagdoll.Spawn();
		BaseMountable baseMountable = GetMounted();
		if (Object.op_Implicit((Object)(object)baseMountable))
		{
			GameObjectExtensions.SetIgnoreCollisions(((Component)baseRagdoll).gameObject, ((Component)baseMountable).gameObject, true);
		}
		return baseRagdoll;
	}

	public override bool CanUseNetworkCache(Connection connection)
	{
		if (net == null)
		{
			return true;
		}
		if (connection.authLevel != 0)
		{
			return false;
		}
		if (net.connection != connection)
		{
			return true;
		}
		return false;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		HandleMountedOnLoad();
	}

	public override void Save(SaveInfo info)
	{
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_042e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0433: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0400: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		bool flag = net != null && net.connection == info.forConnection;
		bool flag2 = !info.forDisk && (Object)(object)info.forConnection.player != (Object)null && info.forConnection.player is BasePlayer basePlayer && basePlayer.IsAdmin;
		info.msg.basePlayer = Pool.Get<BasePlayer>();
		info.msg.basePlayer.userid = userID;
		info.msg.basePlayer.name = displayName;
		info.msg.basePlayer.playerFlags = (int)playerFlags;
		info.msg.basePlayer.currentTeam = currentTeam;
		info.msg.basePlayer.heldEntity = svActiveItemID;
		info.msg.basePlayer.reputation = reputation;
		if (!info.forDisk && (Object)(object)currentGesture != (Object)null && currentGesture.animationType == GestureConfig.AnimationType.Loop)
		{
			info.msg.basePlayer.loopingGesture = currentGesture.gestureId;
		}
		if (IsConnected && (IsAdmin || IsDeveloper))
		{
			info.msg.basePlayer.skinCol = net.connection.info.GetFloat("global.skincol", -1f);
			info.msg.basePlayer.skinTex = net.connection.info.GetFloat("global.skintex", -1f);
			info.msg.basePlayer.skinMesh = net.connection.info.GetFloat("global.skinmesh", -1f);
		}
		else
		{
			info.msg.basePlayer.skinCol = -1f;
			info.msg.basePlayer.skinTex = -1f;
			info.msg.basePlayer.skinMesh = -1f;
		}
		info.msg.basePlayer.underwear = GetUnderwearSkin();
		if (info.forDisk || flag)
		{
			info.msg.basePlayer.metabolism = metabolism.Save();
			info.msg.basePlayer.modifiers = null;
			if ((Object)(object)modifiers != (Object)null)
			{
				info.msg.basePlayer.modifiers = modifiers.Save(info.forDisk);
			}
		}
		if (!info.forDisk && !flag)
		{
			BasePlayer basePlayer2 = info.msg.basePlayer;
			basePlayer2.playerFlags &= -5;
			BasePlayer basePlayer3 = info.msg.basePlayer;
			basePlayer3.playerFlags &= -129;
			if (info.msg.baseCombat != null && !flag2)
			{
				info.msg.baseCombat.health = 100f;
			}
		}
		info.msg.basePlayer.inventory = inventory.Save(info.forDisk || flag);
		modelState.sleeping = IsSleeping();
		modelState.relaxed = IsRelaxed();
		modelState.crawling = IsCrawling();
		modelState.loading = IsLoadingAfterTransfer();
		info.msg.basePlayer.modelState = modelState.Copy();
		if (info.forDisk)
		{
			BaseEntity baseEntity = mounted.Get(base.isServer);
			if (baseEntity.IsValid())
			{
				if (baseEntity.enableSaving)
				{
					info.msg.basePlayer.mounted = mounted.uid;
				}
				else
				{
					BaseVehicle mountedVehicle = GetMountedVehicle();
					if (mountedVehicle.IsValid() && mountedVehicle.enableSaving)
					{
						info.msg.basePlayer.mounted = mountedVehicle.net.ID;
					}
				}
			}
			info.msg.basePlayer.respawnId = respawnId;
		}
		else
		{
			info.msg.basePlayer.mounted = mounted.uid;
		}
		if (flag)
		{
			info.msg.basePlayer.persistantData = PersistantPlayerInfo.Copy();
			if (!info.forDisk && State.missions != null)
			{
				info.msg.basePlayer.missions = State.missions.Copy();
			}
		}
		info.msg.basePlayer.bagCount = SleepingBag.GetSleepingBagCount(userID);
		info.msg.basePlayer.shelterCount = LegacyShelter.GetShelterCount(userID);
		if (info.forDisk)
		{
			info.msg.basePlayer.loadingTimeout = RealTimeUntil.op_Implicit(timeUntilLoadingExpires);
			info.msg.basePlayer.currentLife = lifeStory;
			info.msg.basePlayer.previousLife = previousLifeStory;
		}
		if (!info.forDisk)
		{
			info.msg.basePlayer.clanId = clanId;
		}
		if (info.forDisk && (Object)(object)inventory.crafting != (Object)null)
		{
			info.msg.basePlayer.itemCrafter = inventory.crafting.Save();
		}
		if (info.forDisk && !IsBot)
		{
			SavePlayerState();
		}
		info.msg.basePlayer.tutorialAllowance = (int)CurrentTutorialAllowance;
	}

	public override void Load(LoadInfo info)
	{
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.basePlayer == null)
		{
			return;
		}
		BasePlayer basePlayer = info.msg.basePlayer;
		userID = basePlayer.userid;
		UserIDString = userID.Get().ToString();
		if (basePlayer.name != null)
		{
			displayName = basePlayer.name;
		}
		_ = playerFlags;
		playerFlags = (PlayerFlags)basePlayer.playerFlags;
		currentTeam = basePlayer.currentTeam;
		reputation = basePlayer.reputation;
		if (basePlayer.metabolism != null)
		{
			metabolism.Load(basePlayer.metabolism);
		}
		if (basePlayer.modifiers != null && (Object)(object)modifiers != (Object)null)
		{
			modifiers.Load(basePlayer.modifiers, info.fromDisk);
		}
		if (basePlayer.inventory != null)
		{
			inventory.Load(basePlayer.inventory);
		}
		if (basePlayer.modelState != null)
		{
			if (modelState != null)
			{
				modelState.ResetToPool();
				modelState = null;
			}
			modelState = basePlayer.modelState;
			basePlayer.modelState = null;
		}
		if (info.fromDisk)
		{
			timeUntilLoadingExpires = RealTimeUntil.op_Implicit(info.msg.basePlayer.loadingTimeout);
			if (RealTimeUntil.op_Implicit(timeUntilLoadingExpires) > 0f)
			{
				float num = Mathf.Clamp(RealTimeUntil.op_Implicit(timeUntilLoadingExpires), 0f, Nexus.loadingTimeout);
				((FacepunchBehaviour)this).Invoke((Action)RemoveLoadingPlayerFlag, num);
			}
			lifeStory = info.msg.basePlayer.currentLife;
			if (lifeStory != null)
			{
				lifeStory.ShouldPool = false;
			}
			previousLifeStory = info.msg.basePlayer.previousLife;
			if (previousLifeStory != null)
			{
				previousLifeStory.ShouldPool = false;
			}
			SetPlayerFlag(PlayerFlags.Sleeping, b: false);
			StartSleeping();
			SetPlayerFlag(PlayerFlags.Connected, b: false);
			if (lifeStory == null && IsAlive())
			{
				LifeStoryStart();
			}
			mounted.uid = info.msg.basePlayer.mounted;
			if (IsWounded())
			{
				Die();
			}
			respawnId = info.msg.basePlayer.respawnId;
			if (info.msg.basePlayer.itemCrafter?.queue != null)
			{
				inventory.crafting.Load(info.msg.basePlayer.itemCrafter);
			}
		}
		if (!info.fromDisk)
		{
			clanId = info.msg.basePlayer.clanId;
		}
		CurrentTutorialAllowance = (TutorialItemAllowance)info.msg.basePlayer.tutorialAllowance;
	}

	public void SetRcEntityPosition(Vector3? pos)
	{
		RcEntityPosition = pos;
	}

	internal override void OnParentRemoved()
	{
		if (IsNpc)
		{
			base.OnParentRemoved();
		}
		else
		{
			SetParent(null, worldPositionStays: true, sendImmediate: true);
		}
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)oldParent != (Object)null)
		{
			TransformState(((Component)oldParent).transform.localToWorldMatrix);
		}
		if ((Object)(object)newParent != (Object)null)
		{
			TransformState(((Component)newParent).transform.worldToLocalMatrix);
		}
	}

	private void TransformState(Matrix4x4 matrix)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		tickInterpolator.TransformEntries(matrix);
		if (ConVar.Server.UsePlayerUpdateJobs && StableIndex != -1)
		{
			TickCache.TransformEntries(StableIndex, in matrix);
		}
		tickHistory.TransformEntries(matrix);
		Quaternion rotation = ((Matrix4x4)(ref matrix)).rotation;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(0f, ((Quaternion)(ref rotation)).eulerAngles.y, 0f);
		eyes.bodyRotation = Quaternion.Euler(val) * eyes.bodyRotation;
	}

	public bool CanSuicide()
	{
		if (IsAdmin || IsDeveloper)
		{
			return true;
		}
		return Time.realtimeSinceStartup > nextSuicideTime;
	}

	public void MarkSuicide()
	{
		nextSuicideTime = Time.realtimeSinceStartup + 60f;
	}

	public bool CanRespawn()
	{
		return Time.realtimeSinceStartup > nextRespawnTime;
	}

	public void MarkRespawn(float nextSpawnDelay = 5f)
	{
		nextRespawnTime = Time.realtimeSinceStartup + nextSpawnDelay;
	}

	public Item GetActiveItem()
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (!((ItemId)(ref svActiveItemID)).IsValid)
		{
			return null;
		}
		if (IsDead())
		{
			return null;
		}
		if ((Object)(object)inventory == (Object)null || inventory.containerBelt == null)
		{
			return null;
		}
		return inventory.containerBelt.FindItemByUID(svActiveItemID);
	}

	public void MovePosition(Vector3 newPos)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.position = newPos;
		BaseEntity baseEntity = parentEntity.Get(base.isServer);
		Vector3 point = (((Object)(object)baseEntity != (Object)null) ? ((Component)baseEntity).transform.InverseTransformPoint(newPos) : newPos);
		tickInterpolator.Reset(point);
		if (ConVar.Server.UsePlayerUpdateJobs && StableIndex != -1)
		{
			TickCache.Reset(this, point);
		}
		ticksPerSecond.Increment();
		tickHistory.AddPoint(newPos, tickHistoryCapacity);
		NetworkPositionTick();
	}

	public void OverrideViewAngles(Vector3 newAng)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		viewAngles = newAng;
	}

	public override void ServerInit()
	{
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		stats = new PlayerStatistics(this);
		if ((ulong)userID == 0L)
		{
			userID = (ulong)Random.Range(0, 10000000);
			UserIDString = userID.Get().ToString();
			displayName = UserIDString;
			bots.Add(this);
		}
		EnablePlayerCollider();
		SetPlayerRigidbodyState(!IsSleeping());
		base.ServerInit();
		eyes.bodyRotation = ((Component)this).transform.rotation;
		Query.Server.AddPlayer(this);
		inventory.ServerInit(this);
		metabolism.ServerInit(this);
		if ((Object)(object)modifiers != (Object)null)
		{
			modifiers.ServerInit(this);
		}
		if (recentWaveTargets != null)
		{
			recentWaveTargets.Clear();
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		Query.Server.RemovePlayer(this);
		if (ServerOcclusion.OcclusionEnabled && SupportsServerOcclusion() && occludees != null && net.group != null)
		{
			occludees.Remove((BaseNetworkable)this);
			if (occludees.Count == 0)
			{
				ServerOcclusion.Occludees.Remove(net.group);
			}
			occludees = null;
		}
		if (Object.op_Implicit((Object)(object)inventory))
		{
			inventory.DoDestroy();
		}
		sleepingPlayerList.Remove(this);
		if (IsBot)
		{
			bots.Remove(this);
		}
		SavePlayerState();
		if (cachedPersistantPlayer != null)
		{
			Pool.Free<PersistantPlayer>(ref cachedPersistantPlayer);
		}
	}

	public void ServerUpdate(float deltaTime)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		if (!((BaseNetwork)Net.sv).IsConnected())
		{
			return;
		}
		LifeStoryUpdate(deltaTime, IsOnGround() ? estimatedSpeed : 0f);
		FinalizeTick(deltaTime);
		if (ServerOcclusion.OcclusionEnabled)
		{
			SubGrid = ServerOcclusion.GetSubGrid(GetOcclusionOffset());
			Chunk = ServerOcclusion.GetGrid(GetOcclusionOffset());
			ListHashSet<BaseNetworkable> val = GetOccludees();
			if (val != null && val.Count > 0)
			{
				Enumerator<BaseNetworkable> enumerator = val.GetEnumerator();
				try
				{
					while (enumerator.MoveNext())
					{
						BaseNetworkable current = enumerator.Current;
						if (!((Object)(object)current == (Object)null) && current is BasePlayer basePlayer)
						{
							if (basePlayer.IsConnected)
							{
								ShouldNetworkTo(basePlayer);
							}
							else
							{
								OcclusionLineOfSight(basePlayer, ConVar.AntiHack.server_occlusion_disable_sleeper_los);
							}
						}
					}
				}
				finally
				{
					((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
				}
			}
		}
		ThinkMissions(deltaTime);
		desyncTimeRaw = Mathf.Max(timeSinceLastTick - deltaTime, 0f);
		desyncTimeClamped = Mathf.Min(desyncTimeRaw, ConVar.AntiHack.maxdesync);
		if (ConVar.AntiHack.terrain_protection > 0 && Time.frameCount % ConVar.AntiHack.terrain_timeslice == (uint)net.ID.Value % ConVar.AntiHack.terrain_timeslice && !AntiHack.ShouldIgnore(this))
		{
			bool flag = false;
			if (AntiHack.IsInsideTerrain(this))
			{
				flag = true;
				AntiHack.AddViolation(this, AntiHackType.InsideTerrain, ConVar.AntiHack.terrain_penalty);
			}
			else if (ConVar.AntiHack.terrain_check_geometry && AntiHack.IsInsideMesh(eyes.position))
			{
				flag = true;
				AntiHack.AddViolation(this, AntiHackType.InsideGeometry, ConVar.AntiHack.terrain_penalty);
				AntiHack.Log(this, AntiHackType.InsideGeometry, "Seems to be clipped inside " + ((Object)((RaycastHit)(ref AntiHack.isInsideRayHit)).collider).name);
			}
			if (flag && ConVar.AntiHack.terrain_kill)
			{
				Analytics.Azure.OnTerrainHackViolation(this);
				Hurt(1000f, DamageType.Suicide, this, useProtection: false);
				return;
			}
		}
		float serverTickInterval = Player.serverTickInterval;
		if (Time.realtimeSinceStartup < lastPlayerTick + serverTickInterval)
		{
			return;
		}
		if (lastPlayerTick < Time.realtimeSinceStartup - serverTickInterval * 100f)
		{
			lastPlayerTick = Time.realtimeSinceStartup - Random.Range(0f, serverTickInterval);
		}
		while (lastPlayerTick < Time.realtimeSinceStartup)
		{
			lastPlayerTick += serverTickInterval;
		}
		if (IsConnected)
		{
			ConnectedPlayerUpdate(serverTickInterval);
		}
		if (!IsNpc)
		{
			TickPings();
		}
		TimeWarning val2 = TimeWarning.New("HeldEntityServerCycle", 0);
		try
		{
			HeldEntityServerTick();
		}
		finally
		{
			((IDisposable)val2)?.Dispose();
		}
		if (HasPlayerFlag(PlayerFlags.ChatMute) && Time.realtimeSinceStartup > nextMuteCheckTime)
		{
			nextMuteCheckTime = Time.realtimeSinceStartup + 60f;
			if (State.chatMuteExpiryTimestamp > 0.0 && (double)DateTimeOffset.UtcNow.ToUnixTimeSeconds() > State.chatMuteExpiryTimestamp)
			{
				State.chatMuted = false;
				State.chatMuteExpiryTimestamp = 0.0;
				SetPlayerFlag(PlayerFlags.ChatMute, b: false);
				ChatMessage("You have been unmuted");
			}
		}
	}

	internal static bool ServerUpdateParallel(float deltaTime, PlayerCache playerCache)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		if (ConVar.Server.EmergencyDisablePlayerJobs && !ValidatePlayerCache(playerCache))
		{
			return false;
		}
		((StableObjectCache<BasePlayer>)playerCache).UpdateTransformAccessArray(PlayerTransformsAccess);
		if (ConVar.Server.EmergencyDisablePlayerJobs && !ValidateTransformCache(playerCache))
		{
			return false;
		}
		if (!((BaseNetwork)Net.sv).IsConnected())
		{
			return true;
		}
		ValidEnumerator<BasePlayer> enumerator = playerCache.ValidPlayers.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				current.LifeStoryUpdate(deltaTime, current.IsOnGround() ? current.estimatedSpeed : 0f);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		TimeWarning val = TimeWarning.New("FinalizeTick", 0);
		try
		{
			FinalizeTickParallel(deltaTime, playerCache);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		enumerator = playerCache.ValidPlayers.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current2 = enumerator.Current;
				if (ServerOcclusion.OcclusionEnabled)
				{
					current2.SubGrid = ServerOcclusion.GetSubGrid(current2.GetOcclusionOffset());
					current2.Chunk = ServerOcclusion.GetGrid(current2.GetOcclusionOffset());
					ListHashSet<BaseNetworkable> val2 = current2.GetOccludees();
					if (val2 != null && val2.Count > 0)
					{
						Enumerator<BaseNetworkable> enumerator2 = val2.GetEnumerator();
						try
						{
							while (enumerator2.MoveNext())
							{
								BaseNetworkable current3 = enumerator2.Current;
								if (!((Object)(object)current3 == (Object)null) && current3 is BasePlayer basePlayer)
								{
									if (basePlayer.IsConnected)
									{
										current2.ShouldNetworkTo(basePlayer);
									}
									else
									{
										current2.OcclusionLineOfSight(basePlayer, ConVar.AntiHack.server_occlusion_disable_sleeper_los);
									}
								}
							}
						}
						finally
						{
							((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
						}
					}
				}
				current2.ThinkMissions(deltaTime);
				current2.desyncTimeRaw = Mathf.Max(current2.timeSinceLastTick - deltaTime, 0f);
				current2.desyncTimeClamped = Mathf.Min(current2.desyncTimeRaw, ConVar.AntiHack.maxdesync);
				if (ConVar.AntiHack.terrain_protection > 0 && Time.frameCount % ConVar.AntiHack.terrain_timeslice == (uint)current2.net.ID.Value % ConVar.AntiHack.terrain_timeslice && !AntiHack.ShouldIgnore(current2))
				{
					bool flag = false;
					if (AntiHack.IsInsideTerrain(current2))
					{
						flag = true;
						AntiHack.AddViolation(current2, AntiHackType.InsideTerrain, ConVar.AntiHack.terrain_penalty);
					}
					else if (ConVar.AntiHack.terrain_check_geometry && AntiHack.IsInsideMesh(current2.eyes.position))
					{
						flag = true;
						AntiHack.AddViolation(current2, AntiHackType.InsideGeometry, ConVar.AntiHack.terrain_penalty);
						AntiHack.Log(current2, AntiHackType.InsideGeometry, "Seems to be clipped inside " + ((Object)((RaycastHit)(ref AntiHack.isInsideRayHit)).collider).name);
					}
					if (flag && ConVar.AntiHack.terrain_kill)
					{
						Analytics.Azure.OnTerrainHackViolation(current2);
						current2.Hurt(1000f, DamageType.Suicide, current2, useProtection: false);
						continue;
					}
				}
				float serverTickInterval = Player.serverTickInterval;
				if (!(Time.realtimeSinceStartup < current2.lastPlayerTick + serverTickInterval))
				{
					if (current2.lastPlayerTick < Time.realtimeSinceStartup - serverTickInterval * 100f)
					{
						current2.lastPlayerTick = Time.realtimeSinceStartup - Random.Range(0f, serverTickInterval);
					}
					while (current2.lastPlayerTick < Time.realtimeSinceStartup)
					{
						current2.lastPlayerTick += serverTickInterval;
					}
					if (current2.IsConnected)
					{
						current2.ConnectedPlayerUpdate(serverTickInterval);
					}
					if (!current2.IsNpc)
					{
						current2.TickPings();
					}
					TimeWarning val3 = TimeWarning.New("HeldEntityServerCycle", 0);
					try
					{
						current2.HeldEntityServerTick();
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		ServerUpdatePlayerMutes(playerCache);
		return true;
	}

	private static void ServerUpdatePlayerMutes(PlayerCache playerCache)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("UpdatePlayerMutes", 0);
		try
		{
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			long num = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
			ValidEnumerator<BasePlayer> enumerator = playerCache.ValidPlayers.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current = enumerator.Current;
					if (current.HasPlayerFlag(PlayerFlags.ChatMute) && realtimeSinceStartup > current.nextMuteCheckTime)
					{
						current.nextMuteCheckTime = realtimeSinceStartup + 60f;
						if (current.State.chatMuteExpiryTimestamp > 0.0 && (double)num > current.State.chatMuteExpiryTimestamp)
						{
							current.State.chatMuted = false;
							current.State.chatMuteExpiryTimestamp = 0.0;
							current.SetPlayerFlag(PlayerFlags.ChatMute, b: false);
							current.ChatMessage("You have been unmuted");
						}
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void ServerUpdateBots(float deltaTime)
	{
		RefreshColliderSize(forced: false);
	}

	private void ConnectedPlayerUpdate(float deltaTime)
	{
		if (IsReceivingSnapshot)
		{
			net.UpdateSubscriptions(int.MaxValue, int.MaxValue);
		}
		else if (Time.realtimeSinceStartup > lastSubscriptionTick + ConVar.Server.entitybatchtime && net.UpdateSubscriptions(ConVar.Server.entitybatchsize * 2, ConVar.Server.entitybatchsize))
		{
			lastSubscriptionTick = Time.realtimeSinceStartup;
		}
		SendEntityUpdate();
		if (IsReceivingSnapshot)
		{
			if (SnapshotQueue.Length == 0 && EACServer.IsAuthenticated(net.connection))
			{
				EnterGame();
			}
			return;
		}
		if (IsAlive())
		{
			metabolism.ServerUpdate(this, deltaTime);
			if ((Object)(object)modifiers != (Object)null && !IsReceivingSnapshot)
			{
				modifiers.ServerUpdate(this);
			}
			if (InSafeZone() || InHostileWarningZone())
			{
				float num = 0f;
				HeldEntity heldEntity = GetHeldEntity();
				if (Object.op_Implicit((Object)(object)heldEntity) && heldEntity.hostile)
				{
					num = deltaTime;
				}
				if (num == 0f)
				{
					MarkWeaponDrawnDuration(0f);
				}
				else
				{
					AddWeaponDrawnDuration(num);
				}
				if (weaponDrawnDuration >= 8f)
				{
					MarkHostileFor(30f);
				}
			}
			else
			{
				MarkWeaponDrawnDuration(0f);
			}
			if (PlayHeavyLandingAnimation && !modelState.mounted && modelState.onground && Parachute.LandingAnimations)
			{
				Server_StartGesture(GestureCollection.HeavyLandingId);
				PlayHeavyLandingAnimation = false;
			}
			if (timeSinceLastTick > (float)ConVar.Server.playertimeout)
			{
				lastTickTime = 0f;
				Kick("Unresponsive");
				return;
			}
		}
		if (stallProtectionTime > 0f)
		{
			stallProtectionTime -= Time.deltaTime;
		}
		int num2 = (int)net.connection.GetSecondsConnected();
		int num3 = num2 - secondsConnected;
		if (num3 > 0)
		{
			stats.Add("time", num3, Stats.Server);
			secondsConnected = num2;
		}
		if (IsLoadingAfterTransfer())
		{
			Debug.LogWarning((object)"Force removing loading flag for player (sanity check failed)", (Object)(object)this);
			SetPlayerFlag(PlayerFlags.LoadingAfterTransfer, b: false);
		}
		if (State != null)
		{
			SetPlayerFlag(PlayerFlags.ChatMute, State.chatMuted);
		}
		RefreshColliderSize(forced: false);
		SendModelState();
	}

	internal void EnterGame()
	{
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		SetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: false);
		bool flag = false;
		if (IsLoadingAfterTransfer())
		{
			SetPlayerFlag(PlayerFlags.LoadingAfterTransfer, b: false);
			EndSleeping();
			flag = true;
		}
		if (IsTransferProtected())
		{
			BaseVehicle vehicleParent = GetVehicleParent();
			if ((Object)(object)vehicleParent == (Object)null || vehicleParent.ShouldDisableTransferProtectionOnLoad(this))
			{
				DisableTransferProtection();
				flag = true;
			}
		}
		if (flag)
		{
			SendNetworkUpdateImmediate();
		}
		ClientRPC(RpcTarget.Player("FinishLoading", this));
		((FacepunchBehaviour)this).Invoke((Action)DelayedTeamUpdate, 1f);
		if (State.IsSaveStale())
		{
			State.protocol = 270;
			State.seed = World.Seed;
			State.saveCreatedTime = Epoch.FromDateTime(SaveRestore.SaveCreatedTime);
			Debug.Log((object)"PlayerState was from old protocol or different seed, or not from a loaded save. Clearing player state");
			OnMissionsStale();
			OnFogOfWarStale();
		}
		else
		{
			LoadMissions(State.missions);
		}
		MissionDirty();
		double num = State.unHostileTimestamp - TimeEx.currentTimestamp;
		if (num > 0.0)
		{
			ClientRPC(RpcTarget.Player("SetHostileLength", this), (float)num);
		}
		if (IsTransferProtected() && base.TransferProtectionRemaining > 0f)
		{
			ClientRPC(RpcTarget.Player("SetTransferProtectionDuration", this), base.TransferProtectionRemaining);
		}
		if (ShouldRunFogOfWar)
		{
			if (State.fogImages == null)
			{
				State.fogImages = (List<uint>)(object)Pool.Get<PooledList<uint>>();
			}
			Debug.Log((object)$"stateID: {State.fogImageNetId} curId:{net.ID}");
			if (State.fogImageNetId != net.ID && State.fogImageNetId.Value != 0L)
			{
				Debug.Log((object)$"Reassign fog from {State.fogImageNetId} to {net.ID}");
				FileStorage.server.ReassignEntityId(State.fogImageNetId, net.ID);
			}
			State.fogImageNetId = net.ID;
			ClientRPCPlayerList(null, this, "ReceiveFogOfWarImages", State.fogImages);
		}
		if ((Object)(object)modifiers != (Object)null)
		{
			modifiers.ResetTicking();
		}
		if (net != null)
		{
			EACServer.OnFinishLoading(net.connection);
		}
		Debug.Log((object)$"{this} has spawned");
		if ((Demo.recordlistmode == 0) ? Demo.recordlist.Contains(UserIDString) : (!Demo.recordlist.Contains(UserIDString)))
		{
			StartDemoRecording();
		}
		SendClientPetLink();
		ClientRPC(RpcTarget.Player("ForceViewAnglesTo", this), ((Component)this).transform.forward);
		HandleTutorialOnGameEnter();
	}

	private void HandleTutorialOnGameEnter()
	{
		if (TutorialIsland.ShouldPlayerResumeTutorial(this) && (Object)(object)TutorialIsland.RestoreOrCreateIslandForPlayer(this, triggerAnalytics: false) == (Object)null)
		{
			ClearTutorial();
			Hurt(999999f);
			ClearTutorial_PostDeath();
		}
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	private void ClientKeepConnectionAlive(RPCMessage msg)
	{
		lastTickTime = Time.time;
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	private void ClientLoadingComplete(RPCMessage msg)
	{
	}

	public void PlayerInit(Connection c)
	{
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("PlayerInit", 10);
		try
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)base.KillMessage);
			((FacepunchBehaviour)this).CancelInvoke((Action)OfflineMetabolism);
			SetPlayerFlag(PlayerFlags.Connected, b: true);
			activePlayerList.Add(this);
			if (ConVar.Server.UsePlayerUpdateJobs)
			{
				((StableObjectCache<BasePlayer>)playerCache).Add(this);
				TickCache.Expand(playerCache.Players.Length);
			}
			bots.Remove(this);
			userID = c.userid;
			UserIDString = userID.Get().ToString();
			displayName = c.username;
			c.player = (MonoBehaviour)(object)this;
			secondsConnected = 0;
			currentTeam = RelationshipManager.ServerInstance.FindPlayersTeam(userID)?.teamID ?? 0;
			SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerName(userID, displayName);
			Vector3 position = ((Component)this).transform.position;
			tickInterpolator.Reset(position);
			if (ConVar.Server.UsePlayerUpdateJobs)
			{
				TickCache.Reset(this, position);
			}
			tickHistory.Reset(position);
			eyeHistory.Clear();
			lastTickTime = 0f;
			lastInputTime = 0f;
			SetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);
			stats.Init();
			((FacepunchBehaviour)this).InvokeRandomized((Action)StatSave, Random.Range(5f, 10f), 30f, Random.Range(0f, 6f));
			previousLifeStory = SingletonComponent<ServerMgr>.Instance.persistance.GetLastLifeStory(userID);
			SetPlayerFlag(PlayerFlags.IsAdmin, c.authLevel != 0);
			SetPlayerFlag(PlayerFlags.IsDeveloper, DeveloperList.IsDeveloper(this));
			if (IsDead() && net.SwitchGroup(BaseNetworkable.LimboNetworkGroup))
			{
				SendNetworkGroupChange();
			}
			net.OnConnected(c);
			net.StartSubscriber();
			if (ServerOcclusion.OcclusionEnabled && SupportsServerOcclusion() && ServerOcclusion.Occludees.TryGetValue(net.group, out var value))
			{
				occludees = value;
			}
			SendAsSnapshot(net.connection);
			GlobalNetworkHandler.server.StartSendingSnapshot(this);
			ClientRPC(RpcTarget.Player("StartLoading", this));
			if (Object.op_Implicit((Object)(object)BaseGameMode.GetActiveGameMode(serverside: true)))
			{
				BaseGameMode.GetActiveGameMode(serverside: true).OnPlayerConnected(this);
			}
			if (net != null)
			{
				EACServer.OnStartLoading(net.connection);
			}
			Interface.CallHook("IOnPlayerConnected", (object)this);
			if (IsAdmin)
			{
				if (ConVar.AntiHack.noclip_protection <= 0)
				{
					ChatMessage("antihack.noclip_protection is disabled!");
				}
				if (ConVar.AntiHack.speedhack_protection <= 0)
				{
					ChatMessage("antihack.speedhack_protection is disabled!");
				}
				if (ConVar.AntiHack.flyhack_protection <= 0)
				{
					ChatMessage("antihack.flyhack_protection is disabled!");
				}
				if (ConVar.AntiHack.projectile_protection <= 0)
				{
					ChatMessage("antihack.projectile_protection is disabled!");
				}
				if (ConVar.AntiHack.melee_protection <= 0)
				{
					ChatMessage("antihack.melee_protection is disabled!");
				}
				if (ConVar.AntiHack.eye_protection <= 0)
				{
					ChatMessage("antihack.eye_protection is disabled!");
				}
				Command("debug.setinvis_ui", base.limitNetworking);
			}
			inventory.crafting.SendToOwner();
			if ((Object)(object)TerrainMeta.Path != (Object)null && TerrainMeta.Path.OceanPatrolFar != null)
			{
				SendCargoPatrolPath();
			}
			if (currentTeam == 0L && RelationshipManager.ServerInstance.HasPendingInvite(userID, out var foundTeamID) && RelationshipManager.ServerInstance.GetTeamLeaderInfo(foundTeamID, out var leaderDisplayName, out var leaderID))
			{
				ClientRPC(RpcTarget.Player("CLIENT_PendingInvite", this), leaderDisplayName, leaderID, foundTeamID);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void StatSave()
	{
		if (stats != null)
		{
			stats.Save();
		}
	}

	public void SendDeathInformation()
	{
		ClientRPC(RpcTarget.Player("OnDied", this));
	}

	public void SendRespawnOptions()
	{
		if (NexusServer.Started && ZoneController.Instance.CanRespawnAcrossZones(this))
		{
			CollectExternalAndSend();
			return;
		}
		List<SpawnOptions> list = Pool.Get<List<SpawnOptions>>();
		GetRespawnOptionsForPlayer(list, userID);
		Interface.CallHook("OnRespawnInformationGiven", (object)this, (object)list);
		SendToPlayer(list, loading: false);
		async void CollectExternalAndSend()
		{
			List<SpawnOptions> list2 = Pool.Get<List<SpawnOptions>>();
			GetRespawnOptionsForPlayer(list2, userID);
			List<SpawnOptions> allSpawnOptions = Pool.Get<List<SpawnOptions>>();
			foreach (SpawnOptions item in list2)
			{
				allSpawnOptions.Add(item.Copy());
			}
			SendToPlayer(list2, loading: true);
			try
			{
				Request obj = Pool.Get<Request>();
				obj.spawnOptions = Pool.Get<SpawnOptionsRequest>();
				obj.spawnOptions.userId = userID;
				using (NexusRpcResult nexusRpcResult = await NexusServer.BroadcastRpc(obj, 10f))
				{
					foreach (KeyValuePair<string, Response> response in nexusRpcResult.Responses)
					{
						string key = response.Key;
						SpawnOptionsResponse spawnOptions2 = response.Value.spawnOptions;
						if (spawnOptions2 != null && spawnOptions2.spawnOptions.Count != 0)
						{
							foreach (SpawnOptions spawnOption in spawnOptions2.spawnOptions)
							{
								SpawnOptions val = spawnOption.Copy();
								val.nexusZone = key;
								allSpawnOptions.Add(val);
							}
						}
					}
				}
				SendToPlayer(allSpawnOptions, loading: false);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}
		void SendToPlayer(List<SpawnOptions> spawnOptions, bool loading)
		{
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			RespawnInformation val2 = Pool.Get<RespawnInformation>();
			try
			{
				val2.spawnOptions = spawnOptions;
				val2.loading = loading;
				if (LegacyShelter.max_shelters == LegacyShelter.FpShelterDefault && LegacyShelter.SheltersPerPlayer.ContainsKey(userID) && LegacyShelter.SheltersPerPlayer[userID].Count > 0)
				{
					val2.shelterPositions = Pool.Get<List<Vector3>>();
					foreach (LegacyShelter item2 in LegacyShelter.SheltersPerPlayer[userID])
					{
						val2.shelterPositions.Add(((Component)item2).transform.position);
					}
				}
				if (IsDead())
				{
					val2.previousLife = previousLifeStory;
					if (!ConVar.Server.skipDeathScreenFade)
					{
						val2.fadeIn = previousLifeStory != null && previousLifeStory.timeDied > Epoch.Current - 5;
					}
					else
					{
						val2.fadeIn = false;
					}
				}
				ClientRPC(RpcTarget.Player("OnRespawnInformation", this), val2);
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
	}

	public static void GetRespawnOptionsForPlayer(List<SpawnOptions> spawnOptions, ulong userID)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = FindByID(userID);
		SleepingBag[] array = SleepingBag.FindForPlayer(userID, ignoreTimers: true);
		foreach (SleepingBag sleepingBag in array)
		{
			if ((!(sleepingBag is StaticRespawnArea staticRespawnArea) || staticRespawnArea.IsAuthed(userID)) && (!((Object)(object)basePlayer != (Object)null) || basePlayer.IsInTutorial == sleepingBag.IsTutorialBag))
			{
				SpawnOptions val = Pool.Get<SpawnOptions>();
				val.id = sleepingBag.net.ID;
				val.name = sleepingBag.niceName;
				val.worldPosition = ((Component)sleepingBag).transform.position;
				val.type = (RespawnType)(sleepingBag.isStatic ? 5 : ((int)sleepingBag.RespawnType));
				val.unlockSeconds = sleepingBag.GetUnlockSeconds(userID);
				val.respawnState = sleepingBag.GetRespawnState(userID);
				val.mobile = sleepingBag.IsMobile();
				val.corpse = sleepingBag.HasFlag(Flags.Reserved14);
				spawnOptions.Add(val);
			}
		}
	}

	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	private void RequestRespawnInformation(RPCMessage msg)
	{
		SendRespawnOptions();
	}

	public void ScheduledDeath()
	{
		DeathInfo val = Pool.Get<DeathInfo>();
		val.attackerName = "safezone";
		Kill();
		lifeStory.deathInfo = val;
		lifeStory.timeDied = (uint)Epoch.Current;
		LifeStoryEnd();
	}

	public virtual void StartSleeping()
	{
		if (!IsSleeping())
		{
			Interface.CallHook("OnPlayerSleep", (object)this);
			if (IsRestrained)
			{
				inventory.SetLockedByRestraint(flag: false);
			}
			if (InSafeZone() && !((FacepunchBehaviour)this).IsInvoking((Action)ScheduledDeath))
			{
				((FacepunchBehaviour)this).Invoke((Action)ScheduledDeath, NPCAutoTurret.sleeperhostiledelay);
			}
			BaseMountable baseMountable = GetMounted();
			if ((Object)(object)baseMountable != (Object)null && !AllowSleeperMounting(baseMountable))
			{
				EnsureDismounted();
			}
			SetPlayerFlag(PlayerFlags.Sleeping, b: true);
			sleepStartTime = Time.time;
			sleepingPlayerList.TryAdd(this);
			bots.Remove(this);
			((FacepunchBehaviour)this).CancelInvoke((Action)InventoryUpdate);
			((FacepunchBehaviour)this).CancelInvoke((Action)TeamUpdate);
			((FacepunchBehaviour)this).CancelInvoke((Action)UpdateClanLastSeen);
			inventory.loot.Clear();
			inventory.containerMain.OnChanged();
			inventory.containerBelt.OnChanged();
			inventory.containerWear.OnChanged();
			EnablePlayerCollider();
			if (!IsLoadingAfterTransfer())
			{
				RemovePlayerRigidbody();
				TurnOffAllLights();
			}
			SetServerFall(wantsOn: true);
			RunOfflineMetabolism(state: true);
		}
	}

	private void TurnOffAllLights()
	{
		LightToggle(mask: false);
		HeldEntity heldEntity = GetHeldEntity();
		if ((Object)(object)heldEntity != (Object)null)
		{
			TorchWeapon component = ((Component)heldEntity).GetComponent<TorchWeapon>();
			if ((Object)(object)component != (Object)null)
			{
				component.SetIsOn(isOn: false);
			}
		}
	}

	private void OnPhysicsNeighbourChanged()
	{
		if (IsSleeping() || IsIncapacitated())
		{
			((FacepunchBehaviour)this).Invoke((Action)DelayedServerFall, 0.05f);
		}
	}

	private void DelayedServerFall()
	{
		SetServerFall(wantsOn: true);
	}

	public void SetServerFall(bool wantsOn)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		if (wantsOn && ConVar.Server.playerserverfall)
		{
			if (!((FacepunchBehaviour)this).IsInvoking((Action)ServerFall))
			{
				SetPlayerFlag(PlayerFlags.ServerFall, b: true);
				lastFallTime = Time.time - fallTickRate;
				((FacepunchBehaviour)this).InvokeRandomized((Action)ServerFall, 0f, fallTickRate, fallTickRate * 0.1f);
				fallVelocity = estimatedVelocity.y;
			}
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)ServerFall);
			SetPlayerFlag(PlayerFlags.ServerFall, b: false);
		}
	}

	public void ServerFall()
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		if (IsDead() || HasParent() || (!IsIncapacitated() && !IsSleeping()))
		{
			SetServerFall(wantsOn: false);
			return;
		}
		float num = Time.time - lastFallTime;
		lastFallTime = Time.time;
		float radius = GetRadius();
		float num2 = GetHeight(ducked: true) * 0.5f;
		float num3 = 2.5f;
		float num4 = 0.5f;
		fallVelocity += Physics.gravity.y * num3 * num4 * num;
		float num5 = Mathf.Abs(fallVelocity * num);
		Vector3 val = ((Component)this).transform.position + Vector3.up * (radius + num2);
		Vector3 position = ((Component)this).transform.position;
		Vector3 val2 = ((Component)this).transform.position;
		RaycastHit val3 = default(RaycastHit);
		if (Physics.SphereCast(val, radius, Vector3.down, ref val3, num5 + num2, 1537286401, (QueryTriggerInteraction)1))
		{
			SetServerFall(wantsOn: false);
			if (((RaycastHit)(ref val3)).distance > num2)
			{
				val2 += Vector3.down * (((RaycastHit)(ref val3)).distance - num2);
			}
			ApplyFallDamageFromVelocity(fallVelocity);
			UpdateEstimatedVelocity(val2, val2, num);
			fallVelocity = 0f;
		}
		else if (Physics.Raycast(val, Vector3.down, ref val3, num5 + radius + num2, 1537286401, (QueryTriggerInteraction)1))
		{
			SetServerFall(wantsOn: false);
			if (((RaycastHit)(ref val3)).distance > num2 - radius)
			{
				val2 += Vector3.down * (((RaycastHit)(ref val3)).distance - num2 - radius);
			}
			ApplyFallDamageFromVelocity(fallVelocity);
			UpdateEstimatedVelocity(val2, val2, num);
			fallVelocity = 0f;
		}
		else
		{
			val2 += Vector3.down * num5;
			UpdateEstimatedVelocity(position, val2, num);
			if (WaterLevel.Test(val2, waves: true, volumes: true, this) || AntiHack.TestInsideTerrain(val2))
			{
				SetServerFall(wantsOn: false);
			}
		}
		MovePosition(val2);
	}

	public void RunOfflineMetabolism(bool state)
	{
		if (state)
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)OfflineMetabolism, ConVar.Server.metabolismtick, ConVar.Server.metabolismtick, ConVar.Server.metabolismtick / 10f);
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)OfflineMetabolism);
		}
	}

	private void OfflineMetabolism()
	{
		if (!base.IsDestroyed)
		{
			inventory.containerWear.OnCycle(ConVar.Server.metabolismtick);
			metabolism.ServerUpdate(this, ConVar.Server.metabolismtick);
		}
	}

	public void DelayedRigidbodyDisable()
	{
		RemovePlayerRigidbody();
	}

	public virtual void EndSleeping()
	{
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		if (IsSleeping() && Interface.CallHook("OnPlayerSleepEnd", (object)this) == null)
		{
			if (IsRestrained)
			{
				inventory.SetLockedByRestraint(flag: true);
			}
			SetPlayerFlag(PlayerFlags.Sleeping, b: false);
			sleepStartTime = -1f;
			sleepingPlayerList.Remove(this);
			if ((ulong)userID < 10000000 && !bots.Contains(this))
			{
				bots.Add(this);
			}
			((FacepunchBehaviour)this).CancelInvoke((Action)ScheduledDeath);
			((FacepunchBehaviour)this).InvokeRepeating((Action)InventoryUpdate, 1f, 0.1f * Random.Range(0.99f, 1.01f));
			if (RelationshipManager.TeamsEnabled())
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)TeamUpdate, 1f, 4f, 1f);
			}
			((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateClanLastSeen, 300f, 300f, 60f);
			EnablePlayerCollider();
			AddPlayerRigidbody();
			SetServerFall(wantsOn: false);
			RunOfflineMetabolism(state: false);
			if (HasParent())
			{
				SetParent(null, worldPositionStays: true);
				RemoveFromTriggers();
				ForceUpdateTriggers();
			}
			inventory.containerMain.OnChanged();
			inventory.containerBelt.OnChanged();
			inventory.containerWear.OnChanged();
			Interface.CallHook("OnPlayerSleepEnded", (object)this);
			EACServer.LogPlayerSpawn(this);
			if (TotalPingCount > 0)
			{
				SendPingsToClient();
			}
			if (TutorialIsland.ShouldPlayerBeAskedToStartTutorial(this))
			{
				ClientRPC(RpcTarget.Player("PromptToStartTutorial", this));
			}
			if (AntiHack.TestNoClipping(this, ((Component)this).transform.position, ((Component)this).transform.position, NoClipRadius(ConVar.AntiHack.noclip_margin), ConVar.AntiHack.noclip_backtracking, out var _))
			{
				ForceCastNoClip();
			}
		}
	}

	public virtual void EndLooting()
	{
		if (Object.op_Implicit((Object)(object)inventory.loot))
		{
			inventory.loot.Clear();
		}
	}

	public virtual void OnDisconnected()
	{
		startTutorialCooldown = 0f;
		stats.Save(forceSteamSave: true);
		EndLooting();
		ClearDesigningAIEntity();
		Server_CancelGesture();
		if (IsAlive() || IsSleeping())
		{
			StartSleeping();
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0f);
		}
		activePlayerList.Remove(this);
		if (ConVar.Server.UsePlayerUpdateJobs && StableIndex != -1)
		{
			((StableObjectCache<BasePlayer>)playerCache).Remove(this);
		}
		SetPlayerFlag(PlayerFlags.Connected, b: false);
		StopDemoRecording();
		if (net != null)
		{
			net.OnDisconnected();
		}
		ResetAntiHack();
		RefreshColliderSize(forced: true);
		if (Object.op_Implicit((Object)(object)BaseGameMode.GetActiveGameMode(serverside: true)))
		{
			BaseGameMode.GetActiveGameMode(serverside: true).OnPlayerDisconnected(this);
		}
		BaseMission.PlayerDisconnected(this);
		ClanManager serverInstance = ClanManager.ServerInstance;
		if (clanId != 0L && (Object)(object)serverInstance != (Object)null)
		{
			serverInstance.ClanMemberConnectionsChanged(clanId);
		}
		UpdateClanLastSeen();
	}

	private void InventoryUpdate()
	{
		if (IsConnected && !IsDead())
		{
			inventory.ServerUpdate(0.1f);
		}
	}

	public void ApplyFallDamageFromVelocity(float velocity)
	{
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		if (IsGod())
		{
			return;
		}
		float num = Mathf.InverseLerp(-15f, -100f, velocity);
		if (num != 0f && Interface.CallHook("OnPlayerLand", (object)this, (object)num) == null)
		{
			float num2 = (((Object)(object)modifiers != (Object)null) ? Mathf.Clamp01(1f - modifiers.GetValue(Modifier.ModifierType.Clotting)) : 1f);
			metabolism.bleeding.Add(num * 0.5f * num2);
			float num3 = num * 500f;
			Analytics.Azure.OnFallDamage(this, velocity, num3);
			Hurt(num3, DamageType.Fall);
			if (num3 > 20f && fallDamageEffect.isValid)
			{
				Effect.server.Run(fallDamageEffect.resourcePath, ((Component)this).transform.position, Vector3.zero);
			}
			Interface.CallHook("OnPlayerLanded", (object)this, (object)num);
		}
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	private void OnPlayerLanded(RPCMessage msg)
	{
		float num = msg.read.Float();
		if (!float.IsNaN(num) && !float.IsInfinity(num) && !ConVar.AntiHack.serverside_fall_damage)
		{
			ApplyFallDamageFromVelocity(num);
			fallVelocity = 0f;
		}
	}

	public void SendGlobalSnapshot()
	{
		TimeWarning val = TimeWarning.New("SendGlobalSnapshot", 10);
		try
		{
			EnterVisibility(Net.sv.visibility.Get(0u));
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void SendFullSnapshot()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SendFullSnapshot", 0);
		try
		{
			Enumerator<Group> enumerator = net.subscriber.subscribed.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					Group current = enumerator.Current;
					if (current.ID != 0)
					{
						EnterVisibility(current);
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void OnNetworkGroupLeave(Group group)
	{
		base.OnNetworkGroupLeave(group);
		RemoveGroupOccludee(group);
		LeaveVisibility(group);
	}

	private void LeaveVisibility(Group group)
	{
		ServerMgr.OnLeaveVisibility(net.connection, group);
		ClearEntityQueue(group);
	}

	public void RemoveGroupOccludee(Group group)
	{
		if (ServerOcclusion.OcclusionEnabled && SupportsServerOcclusion() && ServerOcclusion.Occludees.TryGetValue(group, out var value))
		{
			value.Remove((BaseNetworkable)this);
			if (value.Count == 0)
			{
				ServerOcclusion.Occludees.Remove(group);
			}
		}
	}

	public override void OnNetworkGroupEnter(Group group)
	{
		base.OnNetworkGroupEnter(group);
		GroupAddOccludee(group);
		EnterVisibility(group);
	}

	private void EnterVisibility(Group group)
	{
		ServerMgr.OnEnterVisibility(net.connection, group);
		SendSnapshots(group.networkables);
	}

	public void GroupAddOccludee(Group group)
	{
		if (ServerOcclusion.OcclusionEnabled && SupportsServerOcclusion())
		{
			if (ServerOcclusion.Occludees.TryGetValue(group, out var value))
			{
				value.TryAdd((BaseNetworkable)this);
				return;
			}
			Dictionary<Group, ListHashSet<BaseNetworkable>> dictionary = ServerOcclusion.Occludees;
			ListHashSet<BaseNetworkable> obj = new ListHashSet<BaseNetworkable>();
			obj.Add((BaseNetworkable)this);
			dictionary[group] = obj;
		}
	}

	public void CheckDeathCondition(HitInfo info = null)
	{
		Assert.IsTrue(base.isServer, "CheckDeathCondition called on client!");
		if (!IsSpectating() && !IsDead() && metabolism.ShouldDie())
		{
			Die(info);
		}
	}

	public virtual BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List<TriggerBase> triggersOnDeath, bool forceServerSide = false)
	{
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnPlayerCorpseSpawn", (object)this) != null)
		{
			return null;
		}
		TimeWarning val = TimeWarning.New("Create corpse", 0);
		try
		{
			string strCorpsePrefab = ((!(Physics.serversideragdolls || forceServerSide)) ? "assets/prefabs/player/player_corpse.prefab" : "assets/prefabs/player/player_corpse_new.prefab");
			bool flag = false;
			if (Global.cinematicGingerbreadCorpses)
			{
				ItemCorpseOverride itemCorpseOverride = default(ItemCorpseOverride);
				foreach (Item item in inventory.containerWear.itemList)
				{
					if (item != null && ((Component)item.info).TryGetComponent<ItemCorpseOverride>(ref itemCorpseOverride))
					{
						strCorpsePrefab = ((GetFloatBasedOnUserID(userID, 4332uL) > 0.5f) ? itemCorpseOverride.FemaleCorpse.resourcePath : itemCorpseOverride.MaleCorpse.resourcePath);
						flag = itemCorpseOverride.BlockWearableCopy;
						break;
					}
				}
			}
			PlayerCorpse playerCorpse = DropCorpse(strCorpsePrefab, posOnDeath, rotOnDeath, flagsOnDeath, modelState) as PlayerCorpse;
			if (Object.op_Implicit((Object)(object)playerCorpse))
			{
				playerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				if (!flag)
				{
					playerCorpse.TakeFrom(this, inventory.containerMain, inventory.containerWear, inventory.containerBelt);
				}
				playerCorpse.playerName = displayName;
				playerCorpse.streamerName = RandomUsernames.Get((ulong)userID);
				playerCorpse.playerSteamID = userID;
				playerCorpse.underwearSkin = GetUnderwearSkin();
				if (!triggersOnDeath.IsNullOrEmpty())
				{
					foreach (TriggerBase item2 in triggersOnDeath)
					{
						if (item2 is TriggerParent triggerParent)
						{
							triggerParent.ForceParentEarly(playerCorpse);
						}
					}
				}
				playerCorpse.Spawn();
				playerCorpse.TakeChildren(this);
				ResourceDispenser component = ((Component)playerCorpse).GetComponent<ResourceDispenser>();
				int num = 2;
				if (lifeStory != null)
				{
					num += Mathf.Clamp(Mathf.FloorToInt(lifeStory.secondsAlive / 180f), 0, 20);
				}
				component.containedItems.Add(new ItemAmount(ItemManager.FindItemDefinition("fat.animal"), num));
				Interface.CallHook("OnPlayerCorpseSpawned", (object)this, (object)playerCorpse);
				return playerCorpse;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return null;
		static float GetFloatBasedOnUserID(ulong steamid, ulong seed)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			State state = Random.state;
			Random.InitState((int)(seed + steamid));
			float result = Random.Range(0f, 1f);
			Random.state = state;
			return result;
		}
	}

	public override void OnDied(HitInfo info)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0891: Unknown result type (might be due to invalid IL or missing references)
		//IL_0896: Unknown result type (might be due to invalid IL or missing references)
		//IL_0826: Unknown result type (might be due to invalid IL or missing references)
		//IL_082b: Unknown result type (might be due to invalid IL or missing references)
		//IL_055b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0560: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_038b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0395: Unknown result type (might be due to invalid IL or missing references)
		//IL_039a: Unknown result type (might be due to invalid IL or missing references)
		//IL_039f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03af: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0619: Unknown result type (might be due to invalid IL or missing references)
		//IL_061e: Unknown result type (might be due to invalid IL or missing references)
		//IL_099c: Unknown result type (might be due to invalid IL or missing references)
		PlayerFlags flagsOnDeath = playerFlags;
		Vector3 position = ((Component)this).transform.position;
		List<TriggerBase> list = Pool.Get<List<TriggerBase>>();
		if (triggers != null)
		{
			foreach (TriggerBase trigger in triggers)
			{
				if ((Object)(object)trigger != (Object)null)
				{
					list.Add(trigger);
				}
			}
		}
		BaseMountable baseMountable = GetMounted();
		Vector3 val = Vector3.zero;
		Quaternion rotOnDeath;
		if (baseMountable.IsValid())
		{
			rotOnDeath = baseMountable.mountAnchor.rotation;
			val = baseMountable.GetMountRagdollVelocity(this);
		}
		else
		{
			float x = ((Component)this).transform.eulerAngles.x;
			Quaternion bodyRotation = eyes.bodyRotation;
			rotOnDeath = Quaternion.Euler(x, ((Quaternion)(ref bodyRotation)).eulerAngles.y, ((Component)this).transform.eulerAngles.z);
		}
		SetPlayerFlag(PlayerFlags.Unused2, b: false);
		SetPlayerFlag(PlayerFlags.Unused1, b: false);
		RemoveReceiveTickListenersOnDeath();
		EnsureDismounted();
		EndSleeping();
		EndLooting();
		stats.Add("deaths", 1, Stats.All);
		if (info != null && (Object)(object)info.InitiatorPlayer != (Object)null && !info.InitiatorPlayer.IsNpc && !IsNpc)
		{
			RelationshipManager.ServerInstance.SetSeen(info.InitiatorPlayer, this);
			RelationshipManager.ServerInstance.SetSeen(this, info.InitiatorPlayer);
			RelationshipManager.ServerInstance.SetRelationship(this, info.InitiatorPlayer, RelationshipManager.RelationshipType.Enemy);
			HandleClanPlayerKilled(info.InitiatorPlayer);
		}
		if (Object.op_Implicit((Object)(object)BaseGameMode.GetActiveGameMode(serverside: true)))
		{
			BasePlayer instigator = info?.InitiatorPlayer;
			BaseGameMode.GetActiveGameMode(serverside: true).OnPlayerDeath(instigator, this, info);
		}
		BaseMission.PlayerKilled(this);
		inventory.DropBackpackOnDeath(wounded: false);
		DisablePlayerCollider();
		RemovePlayerRigidbody();
		List<BasePlayer> list2 = Pool.Get<List<BasePlayer>>();
		if (IsIncapacitated())
		{
			Enumerator<BasePlayer> enumerator2 = activePlayerList.GetEnumerator();
			try
			{
				while (enumerator2.MoveNext())
				{
					BasePlayer current2 = enumerator2.Current;
					if ((Object)(object)current2 != (Object)null && (Object)(object)current2.inventory != (Object)null && (Object)(object)current2.inventory.loot != (Object)null && (Object)(object)current2.inventory.loot.entitySource == (Object)(object)this)
					{
						list2.Add(current2);
					}
				}
			}
			finally
			{
				((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
			}
		}
		bool flag = IsWounded();
		StopWounded();
		if ((Object)(object)inventory.crafting != (Object)null)
		{
			inventory.crafting.CancelAll();
		}
		EACServer.LogPlayerDespawn(this);
		Ray val2 = eyes.HeadRay();
		bool flag2 = ((Ray)(ref val2)).direction.y > 0.8f;
		bool flag3 = false;
		if (flag2)
		{
			Vector3 val3 = -eyes.MovementForward();
			if (GamePhysics.Trace(new Ray(eyes.position, val3), 0f, out var _, 1f, 2097152, (QueryTriggerInteraction)0))
			{
				flag3 = true;
			}
		}
		Vector3 val4;
		if (!wantsSpectate)
		{
			BaseCorpse baseCorpse = CreateCorpse(flagsOnDeath, position, rotOnDeath, list, flag2 && flag3);
			if ((Object)(object)baseCorpse != (Object)null)
			{
				if (baseCorpse.CorpseIsRagdoll && (Object)(object)baseMountable != (Object)null)
				{
					BaseVehicle baseVehicle = baseMountable.VehicleParent();
					if ((Object)(object)baseVehicle != (Object)null && baseVehicle.mountedPlayerRagdolls == BaseVehicle.RagdollMode.FallThrough)
					{
						GameObjectExtensions.SetIgnoreCollisions(((Component)baseCorpse).gameObject, ((Component)baseVehicle).gameObject, true);
					}
				}
				if (info != null)
				{
					Rigidbody component = ((Component)baseCorpse).GetComponent<Rigidbody>();
					if ((Object)(object)component != (Object)null)
					{
						float num = (baseCorpse.CorpseIsRagdoll ? 5f : 1f);
						val4 = info.attackNormal + Vector3.up * 0.5f;
						Vector3 val5 = ((Vector3)(ref val4)).normalized * num;
						component.AddForce(val5 + val, (ForceMode)2);
					}
				}
				if (baseCorpse is PlayerCorpse { containers: not null } playerCorpse)
				{
					foreach (BasePlayer item in list2)
					{
						if ((Object)(object)item == (Object)null)
						{
							continue;
						}
						item.inventory.loot.StartLootingEntity(playerCorpse);
						ItemContainer[] containers = playerCorpse.containers;
						foreach (ItemContainer itemContainer in containers)
						{
							if (itemContainer != null)
							{
								item.inventory.loot.AddContainer(itemContainer);
							}
						}
						item.inventory.loot.SendImmediate();
					}
				}
			}
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list2);
		inventory.Strip();
		DeathBlow deathBlow;
		if (flag && lastDamage == DamageType.Suicide && cachedNonSuicideHit.IsValid)
		{
			deathBlow = cachedNonSuicideHit;
			DeathBlow.Reset(ref cachedNonSuicideHit);
			lastDamage = info.damageTypes.GetMajorityDamageType();
		}
		else
		{
			DeathBlow.From(info, out deathBlow);
		}
		if (lastDamage == DamageType.Fall)
		{
			stats.Add("death_fall", 1);
		}
		string text = "";
		string text2 = "";
		if (info != null)
		{
			if (Object.op_Implicit((Object)(object)info.Initiator))
			{
				if ((Object)(object)info.Initiator == (Object)(object)this)
				{
					string[] obj = new string[5]
					{
						((object)this).ToString(),
						" was killed by ",
						lastDamage.ToString(),
						" at ",
						null
					};
					val4 = ((Component)this).transform.position;
					obj[4] = ((object)(Vector3)(ref val4)/*cast due to .constrained prefix*/).ToString();
					text = string.Concat(obj);
					text2 = "You died: killed by " + lastDamage;
					if (lastDamage == DamageType.Suicide)
					{
						stats.Add("death_suicide", 1, Stats.All);
					}
					else
					{
						stats.Add("death_selfinflicted", 1);
					}
				}
				else if (info.Initiator is BasePlayer)
				{
					BasePlayer basePlayer = info.Initiator.ToPlayer();
					string[] obj2 = new string[5]
					{
						((object)this).ToString(),
						" was killed by ",
						((object)basePlayer).ToString(),
						" at ",
						null
					};
					val4 = ((Component)this).transform.position;
					obj2[4] = ((object)(Vector3)(ref val4)/*cast due to .constrained prefix*/).ToString();
					text = string.Concat(obj2);
					text2 = "You died: killed by " + basePlayer.displayName + " (" + basePlayer.userID.Get() + ")";
					basePlayer.stats.Add("kill_player", 1, Stats.All);
					basePlayer.LifeStoryKill(this);
					OnKilledByPlayer(basePlayer);
					if (lastDamage == DamageType.Fun_Water)
					{
						basePlayer.GiveAchievement("SUMMER_LIQUIDATOR");
						LiquidWeapon liquidWeapon = basePlayer.GetHeldEntity() as LiquidWeapon;
						if ((Object)(object)liquidWeapon != (Object)null && liquidWeapon.RequiresPumping && liquidWeapon.PressureFraction <= liquidWeapon.MinimumPressureFraction)
						{
							basePlayer.GiveAchievement("SUMMER_NO_PRESSURE");
						}
					}
					else if (GameInfo.HasAchievements && lastDamage == DamageType.Explosion && (Object)(object)info.WeaponPrefab != (Object)null && info.WeaponPrefab.ShortPrefabName.Contains("mlrs") && (Object)(object)basePlayer != (Object)null)
					{
						basePlayer.stats.Add("mlrs_kills", 1, Stats.All);
						basePlayer.stats.Save(forceSteamSave: true);
					}
					Analytics.Azure.OnPlayerDeath(this, basePlayer);
				}
				else
				{
					string[] obj3 = new string[7]
					{
						((object)this).ToString(),
						" was killed by ",
						info.Initiator.ShortPrefabName,
						" (",
						info.Initiator.Categorize(),
						") at ",
						null
					};
					val4 = ((Component)this).transform.position;
					obj3[6] = ((object)(Vector3)(ref val4)/*cast due to .constrained prefix*/).ToString();
					text = string.Concat(obj3);
					text2 = "You died: killed by " + info.Initiator.Categorize();
					stats.Add("death_" + info.Initiator.Categorize(), 1);
				}
			}
			else if (lastDamage == DamageType.Fall)
			{
				string? text3 = ((object)this).ToString();
				val4 = ((Component)this).transform.position;
				text = text3 + " was killed by fall at " + ((object)(Vector3)(ref val4)/*cast due to .constrained prefix*/).ToString();
				text2 = "You died: killed by fall";
			}
			else
			{
				string[] obj4 = new string[5]
				{
					((object)this).ToString(),
					" was killed by ",
					info.damageTypes.GetMajorityDamageType().ToString(),
					" at ",
					null
				};
				val4 = ((Component)this).transform.position;
				obj4[4] = ((object)(Vector3)(ref val4)/*cast due to .constrained prefix*/).ToString();
				text = string.Concat(obj4);
				text2 = "You died: " + info.damageTypes.GetMajorityDamageType();
			}
		}
		else
		{
			text = ((object)this).ToString() + " died (" + lastDamage.ToString() + ")";
			text2 = "You died: " + lastDamage;
		}
		TimeWarning val6 = TimeWarning.New("LogMessage", 0);
		try
		{
			DebugEx.Log((object)text, (StackTraceLogType)0);
			ConsoleMessage(text2);
		}
		finally
		{
			((IDisposable)val6)?.Dispose();
		}
		if (net.connection == null && (Object)(object)info?.Initiator != (Object)null && (Object)(object)info.Initiator != (Object)(object)this)
		{
			CompanionServer.Util.SendDeathNotification(this, info.Initiator);
		}
		SendNetworkUpdateImmediate();
		LifeStoryLogDeath(in deathBlow, lastDamage);
		Server_LogDeathMarker(((Component)this).transform.position);
		LifeStoryEnd();
		if (net.connection == null)
		{
			((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0f);
		}
		else
		{
			SendRespawnOptions();
			SendDeathInformation();
			stats.Save();
		}
		PlayerInjureState = GetInjureState();
		Pool.FreeUnmanaged<TriggerBase>(ref list);
	}

	public void RespawnAt(Vector3 position, Quaternion rotation, BaseEntity spawnPointEntity = null)
	{
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (Object.op_Implicit((Object)(object)activeGameMode) && !activeGameMode.CanPlayerRespawn(this))
		{
			return;
		}
		SetPlayerFlag(PlayerFlags.Wounded, b: false);
		SetPlayerFlag(PlayerFlags.Incapacitated, b: false);
		SetPlayerFlag(PlayerFlags.Unused2, b: false);
		SetPlayerFlag(PlayerFlags.Unused1, b: false);
		SetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);
		SetPlayerFlag(PlayerFlags.DisplaySash, b: false);
		respawnId = Guid.NewGuid().ToString("N");
		ServerPerformance.spawns++;
		SetParent(null, worldPositionStays: true);
		((Component)this).transform.SetPositionAndRotation(position, rotation);
		tickInterpolator.Reset(position);
		if (ConVar.Server.UsePlayerUpdateJobs && StableIndex != -1)
		{
			TickCache.Reset(this, position);
		}
		tickHistory.Reset(position);
		eyeHistory.Clear();
		ForceUpdateTriggers();
		estimatedVelocity = Vector3.zero;
		estimatedSpeed = 0f;
		estimatedSpeed2D = 0f;
		lastTickTime = 0f;
		StopWounded();
		ResetWoundingVars();
		StopSpectating();
		UpdateNetworkGroup();
		EnablePlayerCollider();
		RemovePlayerRigidbody();
		StartSleeping();
		LifeStoryStart();
		metabolism.Reset();
		if ((Object)(object)modifiers != (Object)null)
		{
			if (Player.keepteaondeath)
			{
				modifiers.RemoveAllExceptFromSource(Modifier.ModifierSource.Tea);
			}
			else
			{
				modifiers.RemoveAll();
			}
		}
		InitializeHealth(StartHealth(), StartMaxHealth());
		bool flag = false;
		if (ConVar.Server.respawnWithLoadout)
		{
			string infoString = GetInfoString("client.respawnloadout", string.Empty);
			if (!string.IsNullOrEmpty(infoString) && Inventory.LoadLoadout(infoString, out var so))
			{
				so.LoadItemsOnTo(this);
				flag = true;
			}
		}
		if (!flag)
		{
			inventory.GiveDefaultItems();
		}
		SendNetworkUpdateImmediate();
		ClientRPC(RpcTarget.Player("StartLoading", this));
		Analytics.Azure.OnPlayerRespawned(this, spawnPointEntity);
		if (Object.op_Implicit((Object)(object)activeGameMode))
		{
			BaseGameMode.GetActiveGameMode(serverside: true).OnPlayerRespawn(this);
		}
		if (IsConnected)
		{
			EACServer.OnStartLoading(net.connection);
		}
		Interface.CallHook("OnPlayerRespawned", (object)this);
		ProcessMissionEvent(BaseMission.MissionEventType.RESPAWN, 0, 0f);
		PlayerInjureState = GetInjureState();
	}

	public void Respawn()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		SpawnPoint spawnPoint = ServerMgr.FindSpawnPoint(this, 0uL);
		if (ConVar.Server.respawnAtDeathPosition && ServerCurrentDeathNote != null)
		{
			spawnPoint.pos = ServerCurrentDeathNote.worldPosition;
		}
		object obj = Interface.CallHook("OnPlayerRespawn", (object)this, (object)spawnPoint);
		if (obj is SpawnPoint)
		{
			spawnPoint = (SpawnPoint)obj;
		}
		RespawnAt(spawnPoint.pos, spawnPoint.rot);
	}

	public bool IsImmortalTo(HitInfo info)
	{
		if (IsGod())
		{
			return true;
		}
		if (WoundingCausingImmortality(info))
		{
			return true;
		}
		BaseVehicle mountedVehicle = GetMountedVehicle();
		if ((Object)(object)mountedVehicle != (Object)null && mountedVehicle.ignoreDamageFromOutside)
		{
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if ((Object)(object)initiatorPlayer != (Object)null && (Object)(object)initiatorPlayer.GetMountedVehicle() != (Object)(object)mountedVehicle)
			{
				return true;
			}
		}
		if (IsInTutorial)
		{
			_ = (Object)(object)info.InitiatorPlayer != (Object)(object)this;
			return false;
		}
		return false;
	}

	public float TimeAlive()
	{
		return lifeStory.secondsAlive;
	}

	public override void Hurt(HitInfo info)
	{
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_043e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0443: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ca: Unknown result type (might be due to invalid IL or missing references)
		if (IsDead() || IsTransferProtected() || (IsImmortalTo(info) && info.damageTypes.Total() >= 0f) || Interface.CallHook("IOnBasePlayerHurt", (object)this, (object)info) != null)
		{
			return;
		}
		bool wasWounded = IsWounded();
		if (ConVar.Server.pve && !IsNpc && Object.op_Implicit((Object)(object)info.Initiator) && info.Initiator is BasePlayer && (Object)(object)info.Initiator != (Object)(object)this)
		{
			(info.Initiator as BasePlayer).Hurt(info.damageTypes.Total(), DamageType.Generic);
			return;
		}
		if (info.damageTypes.Has(DamageType.Fun_Water))
		{
			bool flag = true;
			Item activeItem = GetActiveItem();
			if (activeItem != null && (activeItem.info.shortname == "gun.water" || activeItem.info.shortname == "pistol.water"))
			{
				float value = metabolism.wetness.value;
				metabolism.wetness.Add(ConVar.Server.funWaterWetnessGain);
				bool flag2 = metabolism.wetness.value >= ConVar.Server.funWaterDamageThreshold;
				flag = !flag2;
				if ((Object)(object)info.InitiatorPlayer != (Object)null)
				{
					if (flag2 && value < ConVar.Server.funWaterDamageThreshold)
					{
						info.InitiatorPlayer.GiveAchievement("SUMMER_SOAKED");
					}
					if (metabolism.radiation_level.Fraction() > 0.2f && !string.IsNullOrEmpty("SUMMER_RADICAL"))
					{
						info.InitiatorPlayer.GiveAchievement("SUMMER_RADICAL");
					}
				}
			}
			if (flag)
			{
				info.damageTypes.Scale(DamageType.Fun_Water, 0f);
			}
		}
		if (info.damageTypes.Has(DamageType.BeeSting))
		{
			float num = Mathf.Abs(timeSinceLastStung - Time.time);
			float num2 = 1f;
			if (num < 2f)
			{
				num2 = Mathf.Lerp(0.2f, 0.05f, Mathf.Exp((0f - num) * 1.5f));
			}
			else
			{
				num2 = 1f;
				timeSinceLastStung = Time.time;
			}
			info.damageTypes.ScaleAll(num2);
			if (baseProtection.Get(DamageType.BeeSting) > 0f)
			{
				info.damageTypes.ScaleAll(0f);
			}
		}
		if (info.damageTypes.Get(DamageType.Drowned) > 5f && drownEffect.isValid)
		{
			Effect.server.Run(drownEffect.resourcePath, this, StringPool.Get("head"), Vector3.zero, Vector3.zero);
		}
		if ((Object)(object)modifiers != (Object)null)
		{
			if (info.damageTypes.Has(DamageType.Radiation))
			{
				info.damageTypes.Scale(DamageType.Radiation, 1f - Mathf.Clamp01(modifiers.GetValue(Modifier.ModifierType.Radiation_Resistance)));
			}
			if (info.damageTypes.Has(DamageType.RadiationExposure))
			{
				info.damageTypes.Scale(DamageType.RadiationExposure, 1f - Mathf.Clamp01(modifiers.GetValue(Modifier.ModifierType.Radiation_Exposure_Resistance)));
			}
		}
		metabolism.pending_health.Subtract(info.damageTypes.Total() * 10f);
		BasePlayer initiatorPlayer = info.InitiatorPlayer;
		if (Object.op_Implicit((Object)(object)initiatorPlayer) && (Object)(object)initiatorPlayer != (Object)(object)this)
		{
			if (initiatorPlayer.InSafeZone() || InSafeZone())
			{
				initiatorPlayer.MarkHostileFor(300f);
			}
			if (initiatorPlayer.InSafeZone() && !initiatorPlayer.IsNpc)
			{
				info.damageTypes.ScaleAll(0f);
				return;
			}
			if (initiatorPlayer.IsNpc && initiatorPlayer.Family == BaseNpc.AiStatistics.FamilyEnum.Murderer && info.damageTypes.Get(DamageType.Explosion) > 0f)
			{
				info.damageTypes.ScaleAll(Halloween.scarecrow_beancan_vs_player_dmg_modifier);
			}
		}
		base.Hurt(info);
		if (Object.op_Implicit((Object)(object)BaseGameMode.GetActiveGameMode(serverside: true)))
		{
			BasePlayer instigator = info?.InitiatorPlayer;
			BaseGameMode.GetActiveGameMode(serverside: true).OnPlayerHurt(instigator, this, info);
		}
		if (IsRestrained && info.damageTypes.GetMajorityDamageType().InterruptsRestraintMinigame())
		{
			Handcuffs handcuffs = GetHeldEntity() as Handcuffs;
			if ((Object)(object)handcuffs != (Object)null)
			{
				handcuffs.InterruptUnlockMiniGame(wasPushedOrDamaged: true);
			}
		}
		EACServer.LogPlayerTakeDamage(this, info, wasWounded);
		PlayerInjureState = GetInjureState();
		metabolism.SendChangesToClient();
		if (info.PointStart != Vector3.zero && (info.damageTypes.Total() >= 0f || IsGod()))
		{
			int arg = (int)info.damageTypes.GetMajorityDamageType();
			if ((Object)(object)info.Weapon != (Object)null && info.damageTypes.Has(DamageType.Bullet))
			{
				BaseProjectile component = ((Component)info.Weapon).GetComponent<BaseProjectile>();
				if ((Object)(object)component != (Object)null && component.IsSilenced())
				{
					arg = 12;
				}
			}
			ClientRPC(RpcTarget.PlayerAndSpectators("DirectionalDamage", this), info.PointStart, arg, Mathf.CeilToInt(info.damageTypes.Total()));
			if (info.damageTypes.Has(DamageType.BeeSting) && Time.time > timeSinceLastStungRPC + 2f)
			{
				ClientRPC(RpcTarget.Player("OnStungByBees", this));
				timeSinceLastStungRPC = Time.time;
			}
		}
		DeathBlow.From(info, out cachedNonSuicideHit);
	}

	public override void Heal(float amount)
	{
		if (IsCrawling())
		{
			float num = base.health;
			base.Heal(amount);
			healingWhileCrawling += base.health - num;
		}
		else
		{
			base.Heal(amount);
		}
		ProcessMissionEvent(BaseMission.MissionEventType.HEAL, 0, amount);
	}

	public static BasePlayer FindBot(ulong userId)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = bots.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if ((ulong)current.userID == userId)
				{
					return current;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return FindBotClosestMatch(userId.ToString());
	}

	public static BasePlayer FindBotClosestMatch(string name)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (string.IsNullOrEmpty(name))
		{
			return null;
		}
		Enumerator<BasePlayer> enumerator = bots.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (current.displayName.Contains(name))
				{
					return current;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return null;
	}

	public static BasePlayer FindByID(ulong userID)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BasePlayer.FindByID", 0);
		try
		{
			Enumerator<BasePlayer> enumerator = activePlayerList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current = enumerator.Current;
					if ((ulong)current.userID == userID)
					{
						return current;
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
			return null;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool TryFindByID(ulong userID, out BasePlayer basePlayer)
	{
		basePlayer = FindByID(userID);
		return (Object)(object)basePlayer != (Object)null;
	}

	public static BasePlayer FindSleeping(ulong userID)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BasePlayer.FindSleeping", 0);
		try
		{
			Enumerator<BasePlayer> enumerator = sleepingPlayerList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current = enumerator.Current;
					if ((ulong)current.userID == userID)
					{
						return current;
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
			return null;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static BasePlayer FindAwakeOrSleepingByID(ulong userID)
	{
		if (userID == 0L)
		{
			return null;
		}
		BasePlayer basePlayer = FindByID(userID);
		if (!((Object)(object)basePlayer != (Object)null))
		{
			return FindSleeping(userID);
		}
		return basePlayer;
	}

	public void Command(string strCommand, params object[] arguments)
	{
		if (net.connection != null)
		{
			ConsoleNetwork.SendClientCommand(net.connection, strCommand, arguments);
		}
	}

	public override void OnInvalidPosition()
	{
		if (!IsDead())
		{
			Die();
		}
	}

	public static BasePlayer Find(string strNameOrIDOrIP, IEnumerable<BasePlayer> list)
	{
		BasePlayer basePlayer = list.FirstOrDefault((BasePlayer x) => x.UserIDString == strNameOrIDOrIP);
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			return basePlayer;
		}
		BasePlayer basePlayer2 = list.FirstOrDefault((BasePlayer x) => x.displayName.StartsWith(strNameOrIDOrIP, StringComparison.CurrentCultureIgnoreCase));
		if (Object.op_Implicit((Object)(object)basePlayer2))
		{
			return basePlayer2;
		}
		BasePlayer basePlayer3 = list.FirstOrDefault((BasePlayer x) => x.net != null && x.net.connection != null && x.net.connection.ipaddress == strNameOrIDOrIP);
		if (Object.op_Implicit((Object)(object)basePlayer3))
		{
			return basePlayer3;
		}
		return null;
	}

	public static BasePlayer Find(string strNameOrIDOrIP)
	{
		return Find(strNameOrIDOrIP, (IEnumerable<BasePlayer>)activePlayerList);
	}

	public static BasePlayer FindSleeping(string strNameOrIDOrIP)
	{
		return Find(strNameOrIDOrIP, (IEnumerable<BasePlayer>)sleepingPlayerList);
	}

	public static BasePlayer FindAwakeOrSleeping(string strNameOrIDOrIP)
	{
		return Find(strNameOrIDOrIP, allPlayerList);
	}

	public void SendConsoleCommand(string command, params object[] obj)
	{
		ConsoleNetwork.SendClientCommand(net.connection, command, obj);
	}

	public void UpdateRadiation(float fAmount)
	{
		metabolism.radiation_level.Increase(fAmount);
	}

	public override float RadiationExposureFraction()
	{
		float num = Mathf.Clamp(baseProtection.amounts[17], -1f, Radiation.MaxExposureProtection);
		return 1f - num;
	}

	public override float RadiationProtection()
	{
		return Mathf.Clamp(baseProtection.amounts[17], -1f, Radiation.MaxExposureProtection) * 100f;
	}

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		if (Interface.CallHook("OnPlayerHealthChange", (object)this, (object)oldvalue, (object)newvalue) != null)
		{
			return;
		}
		base.OnHealthChanged(oldvalue, newvalue);
		if (base.isServer)
		{
			if (oldvalue > newvalue)
			{
				LifeStoryHurt(oldvalue - newvalue);
			}
			else
			{
				LifeStoryHeal(newvalue - oldvalue);
			}
			metabolism.isDirty = true;
		}
	}

	public void SV_ClothingChanged()
	{
		UpdateProtectionFromClothing();
		UpdateMoveSpeedFromClothing();
	}

	public bool IsNoob()
	{
		return !HasPlayerFlag(PlayerFlags.DisplaySash);
	}

	public bool HasHostileItem()
	{
		TimeWarning val = TimeWarning.New("BasePlayer.HasHostileItem", 0);
		try
		{
			foreach (Item item in inventory.containerBelt.itemList)
			{
				if (IsHostileItem(item))
				{
					return true;
				}
			}
			foreach (Item item2 in inventory.containerMain.itemList)
			{
				if (IsHostileItem(item2))
				{
					return true;
				}
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void GiveItem(Item item, GiveItemReason reason = GiveItemReason.Generic)
	{
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		if (reason == GiveItemReason.ResourceHarvested)
		{
			stats.Add($"harvest.{item.info.shortname}", item.amount, (Stats)6);
		}
		if (reason == GiveItemReason.ResourceHarvested || reason == GiveItemReason.Crafted)
		{
			ProcessMissionEvent(BaseMission.MissionEventType.HARVEST, item.info.itemid, item.amount);
		}
		int amount = item.amount;
		if (inventory.GiveItem(item))
		{
			bool infoBool = GetInfoBool("global.streamermode", defaultVal: false);
			string name = item.GetName(infoBool);
			if (!string.IsNullOrEmpty(name))
			{
				Command("note.inv", item.info.itemid, amount, name, (int)reason);
			}
			else
			{
				Command("note.inv", item.info.itemid, amount, string.Empty, (int)reason);
			}
		}
		else
		{
			item.Drop(inventory.containerMain.dropPosition, inventory.containerMain.dropVelocity);
		}
	}

	public override void AttackerInfo(DeathInfo info)
	{
		info.attackerName = displayName;
		info.attackerSteamID = userID;
	}

	public void InvalidateWorkbenchCache()
	{
		nextCheckTime = 0f;
	}

	public Workbench GetCachedCraftLevelWorkbench()
	{
		return _cachedWorkbench;
	}

	public virtual bool ShouldDropActiveItem()
	{
		object obj = Interface.CallHook("CanDropActiveItem", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

	public override void Die(HitInfo info = null)
	{
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Player.Die", 0);
		try
		{
			if (!IsDead())
			{
				Handcuffs restraintItem = Belt.GetRestraintItem();
				if ((Object)(object)restraintItem != (Object)null)
				{
					restraintItem.HeldWhenOwnerDied(this);
				}
				if (InGesture)
				{
					Server_CancelGesture();
				}
				if (Belt != null && ShouldDropActiveItem())
				{
					Vector3 val2 = default(Vector3);
					((Vector3)(ref val2))..ctor(Random.Range(-2f, 2f), 0.2f, Random.Range(-2f, 2f));
					Belt.DropActive(GetDropPosition(), GetInheritedDropVelocity() + ((Vector3)(ref val2)).normalized * 3f);
				}
				if (!WoundInsteadOfDying(info) && Interface.CallHook("OnPlayerDeath", (object)this, (object)info) == null)
				{
					SleepingBag.OnPlayerDeath(this);
					base.Die(info);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Kick(string reason, bool reserveSlot = true)
	{
		if (IsConnected)
		{
			net.connection.canReserveSlot = reserveSlot;
			Net.sv.Kick(net.connection, reason, false);
			Interface.CallHook("OnPlayerKicked", (object)this, (object)reason, (object)reserveSlot);
		}
	}

	public override Vector3 GetDropPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return eyes.position;
	}

	public override Vector3 GetDropVelocity()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		return GetInheritedDropVelocity() + eyes.BodyForward() * 4f + Vector3Ex.Range(-0.5f, 0.5f);
	}

	public override void ApplyInheritedVelocity(Vector3 velocity)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GetParentEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			ClientRPC(RpcTarget.Player("SetInheritedVelocity", this), ((Component)baseEntity).transform.InverseTransformDirection(velocity), baseEntity.net.ID);
		}
		else
		{
			((BaseEntity)this).ClientRPC(RpcTarget.Player("SetInheritedVelocity", this), velocity, default(NetworkableId));
		}
		PauseSpeedHackDetection();
	}

	public virtual void SetInfo(string key, string val)
	{
		if (IsConnected)
		{
			Interface.CallHook("OnPlayerSetInfo", (object)net.connection, (object)key, (object)val);
			net.connection.info.Set(key, val);
		}
	}

	public virtual int GetInfoInt(string key, int defaultVal)
	{
		if (!IsConnected)
		{
			return defaultVal;
		}
		return net.connection.info.GetInt(key, defaultVal);
	}

	public virtual bool GetInfoBool(string key, bool defaultVal)
	{
		if (!IsConnected)
		{
			return defaultVal;
		}
		return net.connection.info.GetBool(key, defaultVal);
	}

	public virtual string GetInfoString(string key, string defaultVal)
	{
		if (!IsConnected)
		{
			return defaultVal;
		}
		return net.connection.info.GetString(key, defaultVal);
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(1uL)]
	public void PerformanceReport(RPCMessage msg)
	{
		string text = msg.read.String(256, false);
		string text2 = msg.read.StringRaw(8388608, false);
		ClientPerformanceReport clientPerformanceReport = JsonConvert.DeserializeObject<ClientPerformanceReport>(text2);
		if (clientPerformanceReport.user_id != UserIDString)
		{
			DebugEx.Log((object)$"Client performance report from {this} has incorrect user_id ({UserIDString})", (StackTraceLogType)0);
			return;
		}
		switch (text)
		{
		case "json":
			DebugEx.Log((object)text2, (StackTraceLogType)0);
			break;
		case "legacy":
		{
			string text3 = (clientPerformanceReport.memory_managed_heap + "MB").PadRight(9);
			string text4 = (clientPerformanceReport.memory_system + "MB").PadRight(9);
			string text5 = (clientPerformanceReport.fps.ToString("0") + "FPS").PadRight(8);
			string text6 = NumberExtensions.FormatSeconds((long)clientPerformanceReport.fps).PadRight(9);
			string text7 = UserIDString.PadRight(20);
			string text8 = clientPerformanceReport.streamer_mode.ToString().PadRight(7);
			DebugEx.Log((object)(text3 + text4 + text5 + text6 + text8 + text7 + displayName), (StackTraceLogType)0);
			break;
		}
		case "rcon":
			RCon.Broadcast(RCon.LogType.ClientPerf, text2);
			break;
		default:
			Debug.LogError((object)("Unknown PerformanceReport format '" + text + "'"));
			break;
		case "none":
			break;
		}
	}

	public override bool ShouldNetworkTo(BasePlayer player)
	{
		object obj = Interface.CallHook("CanNetworkTo", (object)this, (object)player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((Object)(object)player == (Object)(object)this)
		{
			return true;
		}
		if (IsSpectating() && (Object)(object)player != (Object)(object)this)
		{
			return false;
		}
		bool flag = base.ShouldNetworkTo(player);
		if (ServerOcclusion.OcclusionEnabled && flag)
		{
			bool flag2 = player.GetMounted() is ComputerStation;
			bool server_occlusion_disable_los = ConVar.AntiHack.server_occlusion_disable_los;
			flag = OcclusionLineOfSight(player, server_occlusion_disable_los || flag2 || !SupportsServerOcclusion());
		}
		return flag;
	}

	private bool OcclusionLineOfSight(BasePlayer player, bool skip = false)
	{
		if (OcclusionGetRecentlySeen(player))
		{
			return true;
		}
		if (skip)
		{
			OcclusionPlayerFound(this, player, cache: false);
			return true;
		}
		if (OcclusionShouldSeeAllPlayers())
		{
			OcclusionPlayerFound(this, player, cache: false);
			return true;
		}
		if (player.OcclusionShouldSeeAllPlayers())
		{
			OcclusionPlayerFound(player, this, cache: false);
			return true;
		}
		if (SubGrid.GetDistance(player.SubGrid) < ServerOcclusion.MinOcclusionDistance)
		{
			OcclusionPlayerFound(this, player, cache: false);
			return true;
		}
		if (player.SubGrid.Equals(default(ServerOcclusion.SubGrid)))
		{
			OcclusionPlayerFound(this, player, cache: false);
			return true;
		}
		if (ConVar.AntiHack.server_occlusion_caching && ((Dictionary<(ServerOcclusion.SubGrid, ServerOcclusion.SubGrid), bool>)(object)ServerOcclusion.OcclusionCache).TryGetValue((SubGrid, player.SubGrid), out bool value))
		{
			if (value)
			{
				OcclusionPlayerFound(this, player);
				return true;
			}
			OcclusionPlayerLost(this, player);
			return false;
		}
		ServerOcclusion.CalculatePathBetweenGrids(SubGrid, player.SubGrid, out var pathBlocked);
		if (!pathBlocked)
		{
			OcclusionPlayerFound(this, player);
			return true;
		}
		OcclusionPlayerLost(this, player);
		return false;
	}

	private static void OcclusionPlayerFound(BasePlayer player1, BasePlayer player2, bool cache = true)
	{
		if (!player2.limitNetworking)
		{
			UpdateVisibility(player1, player2);
		}
		if (!player1.OcclusionShouldSeeAllPlayers())
		{
			UpdateVisibility(player2, player1);
		}
		if (cache && ConVar.AntiHack.server_occlusion_caching)
		{
			ServerOcclusion.OcclusionCache.TryAdd((player1.SubGrid, player2.SubGrid), true);
			ServerOcclusion.OcclusionCache.TryAdd((player2.SubGrid, player1.SubGrid), true);
		}
		static void UpdateVisibility(BasePlayer src, BasePlayer dst)
		{
			float networkTime = src.GetNetworkTime();
			if (src.lastPlayerVisibility.TryAdd(dst, networkTime))
			{
				if (src.net.connection != null)
				{
					dst.SendAsSnapshotWithChildren(src, includeChildrensChildren: true);
				}
			}
			else
			{
				src.lastPlayerVisibility[dst] = networkTime;
			}
		}
	}

	private static void OcclusionPlayerLost(BasePlayer player1, BasePlayer player2, bool cache = true)
	{
		UpdateVisibility(player1, player2);
		if (!player2.OcclusionShouldSeeAllPlayers())
		{
			UpdateVisibility(player2, player1);
		}
		if (cache && ConVar.AntiHack.server_occlusion_caching)
		{
			ServerOcclusion.OcclusionCache.TryAdd((player1.SubGrid, player2.SubGrid), false);
			ServerOcclusion.OcclusionCache.TryAdd((player2.SubGrid, player1.SubGrid), false);
		}
		static void UpdateVisibility(BasePlayer src, BasePlayer dst)
		{
			if (src.lastPlayerVisibility.Remove(dst) && src.net.connection != null)
			{
				dst.DestroyOnClient(src.net.connection);
			}
		}
	}

	private bool OcclusionGetRecentlySeen(BasePlayer player)
	{
		if (lastPlayerVisibility.TryGetValue(player, out var value))
		{
			return GetNetworkTime() - value < ServerOcclusion.OcclusionPollRate;
		}
		return false;
	}

	private bool OcclusionShouldSeeAllPlayers()
	{
		if (IsSpectating())
		{
			return true;
		}
		if (isInvisible)
		{
			return true;
		}
		if (ConVar.AntiHack.server_occlusion_admin_bypass && (IsAdmin || IsDeveloper))
		{
			return true;
		}
		return false;
	}

	internal void GiveAchievement(string name, bool allowTutorial = false)
	{
		if (GameInfo.HasAchievements && (!IsInTutorial || allowTutorial))
		{
			ClientRPC(RpcTarget.Player("RecieveAchievement", this), name);
		}
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server]
	public async void OnPlayerReported(RPCMessage msg)
	{
		try
		{
			string text = msg.read.String(256, false);
			string text2 = msg.read.StringMultiLine(2048, false);
			string message = ((text2 != null && text2.Length > 1400) ? text2.Substring(0, 1400) : text2);
			string text3 = msg.read.String(256, false);
			string targetId = msg.read.String(256, false);
			string text4 = msg.read.String(256, false);
			DebugEx.Log((object)$"[PlayerReport] {this} reported {text4}[{targetId}] - \"{text}\"", (StackTraceLogType)0);
			RCon.Broadcast(RCon.LogType.Report, new
			{
				PlayerId = UserIDString,
				PlayerName = displayName,
				TargetId = targetId,
				TargetName = text4,
				Subject = text,
				Message = message,
				Type = text3
			});
			Interface.CallHook("OnPlayerReported", (object)this, (object)text4, (object)targetId, (object)text, (object)text2, (object)text3);
			if (!string.IsNullOrEmpty(ConVar.Server.reportsServerEndpoint))
			{
				ReportType type = (ReportType)3;
				if (text3.Equals("cheat"))
				{
					type = (ReportType)2;
				}
				if (text3.Equals("break_server_rules"))
				{
					type = (ReportType)6;
				}
				Feedback val = default(Feedback);
				val.Subject = text;
				val.Message = message;
				val.TargetReportType = text3;
				val.TargetId = targetId;
				val.TargetName = text4;
				val.Type = type;
				Feedback val2 = val;
				DebugEx.Log((object)("[OnPlayerReported to endpoint] " + await Feedback.ServerReport(ConVar.Server.reportsServerEndpoint, (ulong)userID, ConVar.Server.reportsServerEndpointKey, val2)), (StackTraceLogType)0);
			}
			BasePlayer basePlayer = FindAwakeOrSleeping(targetId);
			if ((Object)(object)basePlayer != (Object)null)
			{
				PlayerState state = basePlayer.State;
				state.numberOfTimesReported++;
			}
		}
		catch (Exception ex)
		{
			Debug.LogWarning((object)("[OnPlayerReported] Exception occurred when sending F7 report to endpoint: " + ex.Message));
			Debug.LogException(ex);
		}
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(1uL)]
	public async void OnFeedbackReport(RPCMessage msg)
	{
		try
		{
			string text = msg.read.String(256, false);
			string text2 = msg.read.StringMultiLine(2048, false);
			string text3 = ((text2 != null && text2.Length > 1400) ? text2.Substring(0, 1400) : text2);
			ReportType val = (ReportType)Mathf.Clamp(msg.read.Int32(), 0, 6);
			if (ConVar.Server.printReportsToConsole)
			{
				DebugEx.Log((object)$"[FeedbackReport] {this} reported {val} - \"{text}\" \"{text3}\"", (StackTraceLogType)0);
				RCon.Broadcast(RCon.LogType.Report, new
				{
					PlayerId = UserIDString,
					PlayerName = displayName,
					Subject = text,
					Message = text3,
					Type = val
				});
			}
			Interface.CallHook("OnFeedbackReported", (object)this, (object)text, (object)text2, (object)val);
			if (!string.IsNullOrEmpty(ConVar.Server.reportsServerEndpoint))
			{
				string image = msg.read.StringMultiLine(60000, false);
				Feedback val2 = default(Feedback);
				val2.Type = val;
				val2.Message = text3;
				val2.Subject = text;
				Feedback val3 = val2;
				((AppInfo)(ref val3.AppInfo)).Image = image;
				DebugEx.Log((object)("[OnFeedbackReport to endpoint] " + await Feedback.ServerReport(ConVar.Server.reportsServerEndpoint, (ulong)userID, ConVar.Server.reportsServerEndpointKey, val3)), (StackTraceLogType)0);
			}
		}
		catch (Exception ex)
		{
			Debug.LogWarning((object)("[OnFeedbackReport] Exception occurred when sending F7 report to endpoint: " + ex.Message));
			Debug.LogException(ex);
		}
	}

	public void StartDemoRecording()
	{
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		if (net != null && net.connection != null && !net.connection.IsRecording)
		{
			string text = $"demos/{UserIDString}/{DateTime.Now:yyyy-MM-dd-hhmmss}.dem";
			if (Interface.CallHook("OnDemoRecordingStart", (object)text, (object)this) == null)
			{
				Debug.Log((object)(((object)this).ToString() + " recording started: " + text));
				net.connection.StartRecording(text, (IDemoHeader)(object)new Demo.Header
				{
					version = Demo.Version,
					level = Application.loadedLevelName,
					levelSeed = World.Seed,
					levelSize = World.Size,
					checksum = World.Checksum,
					localclient = userID,
					position = eyes.position,
					rotation = eyes.HeadForward(),
					levelUrl = World.Url,
					recordedTime = DateTime.Now.ToBinary()
				});
				SendNetworkUpdateImmediate();
				SendGlobalSnapshot();
				SendFullSnapshot();
				SendEntityUpdate();
				TreeManager.SendSnapshot(this);
				ServerMgr.SendReplicatedVars(net.connection);
				((FacepunchBehaviour)this).InvokeRepeating((Action)MonitorDemoRecording, 10f, 10f);
				Interface.CallHook("OnDemoRecordingStarted", (object)text, (object)this);
			}
		}
	}

	public void StopDemoRecording()
	{
		if (net != null && net.connection != null && net.connection.IsRecording && Interface.CallHook("OnDemoRecordingStop", (object)net.connection.recordFilename, (object)this) == null)
		{
			Debug.Log((object)(((object)this).ToString() + " recording stopped: " + net.connection.RecordFilename));
			net.connection.StopRecording();
			((FacepunchBehaviour)this).CancelInvoke((Action)MonitorDemoRecording);
			Interface.CallHook("OnDemoRecordingStopped", (object)net.connection.recordFilename, (object)this);
		}
	}

	public void MonitorDemoRecording()
	{
		if (net != null && net.connection != null && net.connection.IsRecording && (net.connection.RecordTimeElapsed.TotalSeconds >= (double)Demo.splitseconds || (float)net.connection.RecordFilesize >= Demo.splitmegabytes * 1024f * 1024f))
		{
			StopDemoRecording();
			StartDemoRecording();
		}
	}

	public void InvalidateCachedPeristantPlayer()
	{
		cachedPersistantPlayer = null;
	}

	public bool IsPlayerVisibleToUs(BasePlayer otherPlayer, Vector3 fromOffset, int layerMask)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)otherPlayer == (Object)null)
		{
			return false;
		}
		Vector3 val = (isMounted ? eyes.worldMountedPosition : (IsDucked() ? eyes.worldCrouchedPosition : ((!IsCrawling()) ? eyes.worldStandingPosition : eyes.worldCrawlingPosition)));
		val += fromOffset;
		if (!otherPlayer.IsVisibleSpecificLayers(val, otherPlayer.CenterPoint(), layerMask) && !otherPlayer.IsVisibleSpecificLayers(val, ((Component)otherPlayer).transform.position, layerMask) && !otherPlayer.IsVisibleSpecificLayers(val, otherPlayer.eyes.position, layerMask))
		{
			return false;
		}
		if (!IsVisibleSpecificLayers(otherPlayer.CenterPoint(), val, layerMask) && !IsVisibleSpecificLayers(((Component)otherPlayer).transform.position, val, layerMask) && !IsVisibleSpecificLayers(otherPlayer.eyes.position, val, layerMask))
		{
			return false;
		}
		return true;
	}

	protected virtual void OnKilledByPlayer(BasePlayer p)
	{
	}

	public override void OnKilled()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)OfflineMetabolism);
		base.OnKilled();
	}

	public int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
	{
		if (container.HasFlag(ItemContainer.Flag.Clothing))
		{
			if (item.IsBackpack())
			{
				return 7;
			}
			if (!item.info.isWearable)
			{
				return -1;
			}
			foreach (Item item2 in container.itemList)
			{
				if (!item2.info.ItemModWearable.CanExistWith(item.info.ItemModWearable) && item2.position == 7 == item.IsBackpack())
				{
					return item2.position;
				}
			}
		}
		return -1;
	}

	public ItemContainerId GetIdealContainer(BasePlayer looter, Item item, ItemMoveModifier modifier)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		bool flag = !((Enum)modifier).HasFlag((Enum)(object)(ItemMoveModifier)2) && looter.inventory.loot.containers.Count > 0;
		ItemContainer parent = item.parent;
		Item activeItem = looter.GetActiveItem();
		Item backpackWithInventory = inventory.GetBackpackWithInventory();
		bool flag2 = backpackWithInventory != null && backpackWithInventory == item.parentItem;
		bool flag3 = false;
		if (((Enum)modifier).HasFlag((Enum)(object)(ItemMoveModifier)16) && (Object)(object)looter == (Object)(object)this && backpackWithInventory != null)
		{
			if (backpackWithInventory.contents.HasSpaceFor(item))
			{
				if (!flag)
				{
					if (item.parentItem == null || !item.parentItem.IsBackpack() || item.parentItem.parent != inventory.containerWear)
					{
						return backpackWithInventory.contents.uid;
					}
				}
				else if (inventory.loot.FindItem(item.uid) != null && !inventory.containerMain.HasSpaceFor(item))
				{
					return backpackWithInventory.contents.uid;
				}
			}
			else
			{
				flag3 = true;
			}
		}
		if (activeItem != null && !flag3 && !flag && activeItem.contents != null && activeItem.contents != item.parent && activeItem.contents.capacity > 0 && activeItem.contents.CanAcceptItem(item, -1) == ItemContainer.CanAcceptResult.CanAccept)
		{
			return activeItem.contents.uid;
		}
		if (item.info.isWearable && item.info.ItemModWearable.equipOnRightClick && item.parent != inventory.containerWear && !flag && !flag2)
		{
			if (flag3)
			{
				return ItemContainerId.Invalid;
			}
			if (backpackWithInventory == null || item.parent != backpackWithInventory.contents)
			{
				return inventory.containerWear.uid;
			}
		}
		if (parent == inventory.containerMain)
		{
			if (flag)
			{
				return default(ItemContainerId);
			}
			return inventory.containerBelt.uid;
		}
		if (parent == inventory.containerWear)
		{
			return inventory.containerMain.uid;
		}
		if (parent == inventory.containerBelt)
		{
			return inventory.containerMain.uid;
		}
		return default(ItemContainerId);
	}

	private BaseVehicle GetVehicleParent()
	{
		BaseVehicle mountedVehicle = GetMountedVehicle();
		if ((Object)(object)mountedVehicle != (Object)null)
		{
			return mountedVehicle;
		}
		BaseEntity baseEntity = GetParentEntity();
		if ((Object)(object)baseEntity != (Object)null && baseEntity is BaseVehicle result)
		{
			return result;
		}
		return null;
	}

	private void RemoveLoadingPlayerFlag()
	{
		if (IsLoadingAfterTransfer())
		{
			SetPlayerFlag(PlayerFlags.LoadingAfterTransfer, b: false);
			if (IsSleeping())
			{
				SetPlayerFlag(PlayerFlags.Sleeping, b: false);
				StartSleeping();
			}
		}
	}

	public bool InNoRespawnZone()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		Vector3 position = ((Component)this).transform.position;
		if (triggers != null)
		{
			for (int i = 0; i < triggers.Count; i++)
			{
				TriggerNoRespawnZone triggerNoRespawnZone = triggers[i] as TriggerNoRespawnZone;
				if (!((Object)(object)triggerNoRespawnZone == (Object)null))
				{
					flag = triggerNoRespawnZone.InNoRespawnZone(position, checkRadius: false);
					if (flag)
					{
						break;
					}
				}
			}
		}
		return flag;
	}

	private void SendCargoPatrolPath()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Expected O, but got Unknown
		if (!BaseBoat.generate_paths)
		{
			return;
		}
		if (cachedOceanPaths == null)
		{
			cachedOceanPaths = Pool.Get<OceanPaths>();
			cachedOceanPaths.cargoPatrolPath = TerrainMeta.Path.OceanPatrolFar;
			cachedOceanPaths.harborApproaches = new List<VectorList>();
			for (int i = 0; i < CargoShip.TotalAvailableHarborDockingPaths; i++)
			{
				VectorList val = new VectorList();
				val.vectorPoints = CargoShip.GetCargoApproachPath(i);
				cachedOceanPaths.harborApproaches.Add(val);
			}
		}
		ClientRPCPlayer<OceanPaths>(null, this, "ReceiveCargoPatrolPath", cachedOceanPaths);
	}

	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	private void RPC_ReqDoRestrainedPush(RPCMessage rpc)
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		if (IsSleeping() || IsDead() || !IsRestrained)
		{
			return;
		}
		BasePlayer player = rpc.player;
		if ((Object)(object)player == (Object)null || (Object)(object)player == (Object)(object)this)
		{
			return;
		}
		Handcuffs handcuffs = GetHeldEntity() as Handcuffs;
		if ((Object)(object)handcuffs != (Object)null)
		{
			handcuffs.InterruptUnlockMiniGame(wasPushedOrDamaged: true);
			handcuffs.RepairOnPush();
		}
		if (isMounted)
		{
			BaseMountable baseMountable = GetMounted();
			if ((Object)(object)baseMountable != (Object)null)
			{
				baseMountable.DismountPlayer(this);
				return;
			}
		}
		Vector3 val = player.eyes.BodyForward() * 10f;
		val.y = 0f;
		val += Vector3.up * 3f;
		DoPush(val, isRestrained: true);
		Hurt(Handcuffs.restrainedPushDamage, DamageType.Generic, player, useProtection: false);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.IsVisible(3f)]
	private void RPC_ReqRemoveCuffs(RPCMessage rpc)
	{
		if (IsDead() || !IsRestrained)
		{
			return;
		}
		BasePlayer player = rpc.player;
		if (!((Object)(object)player == (Object)null) && !((Object)(object)player == (Object)(object)this))
		{
			Handcuffs handcuffs = GetHeldEntity() as Handcuffs;
			if ((Object)(object)handcuffs != (Object)null)
			{
				handcuffs.UnlockAndReturnToPlayer(player);
			}
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	private void RPC_ReqRemoveHood(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!((Object)(object)player == (Object)null) && !((Object)(object)player == (Object)(object)this))
		{
			RemoveAndReturnPrisonerHood(player);
		}
	}

	private void RemoveAndReturnPrisonerHood(BasePlayer returnToPlayer)
	{
		if (!((Object)(object)returnToPlayer == (Object)null) && !IsDead() && IsRestrained)
		{
			Item equippedPrisonerHoodItem = inventory.GetEquippedPrisonerHoodItem();
			if (equippedPrisonerHoodItem != null)
			{
				bool isLocked = inventory.containerWear.IsLocked();
				inventory.containerWear.SetLocked(isLocked: false);
				returnToPlayer.GiveItem(equippedPrisonerHoodItem);
				inventory.containerWear.SetLocked(isLocked);
			}
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	private void RPC_ReqEquipHood(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!((Object)(object)player == (Object)null))
		{
			EquipPrisonerHood(player);
		}
	}

	private void EquipPrisonerHood(BasePlayer placingPlayer)
	{
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)placingPlayer == (Object)null || IsDead() || !IsRestrained || (Object)(object)inventory == (Object)null || inventory.GetEquippedPrisonerHoodItem() != null)
		{
			return;
		}
		Item usableHoodItem = placingPlayer.inventory.GetUsableHoodItem();
		if (usableHoodItem == null)
		{
			return;
		}
		inventory.SetLockedByRestraint(flag: false);
		if (!usableHoodItem.MoveToContainer(inventory.containerBelt))
		{
			Item slot = inventory.containerBelt.GetSlot(0);
			if (slot != null && slot == Belt.GetRestraintItem()?.GetItem())
			{
				slot = inventory.containerBelt.GetSlot(1);
			}
			if (slot != null)
			{
				if (!slot.MoveToContainer(inventory.containerMain))
				{
					slot.DropAndTossUpwards(((Component)this).transform.position);
				}
				usableHoodItem.MoveToContainer(inventory.containerBelt);
			}
		}
		inventory.SetLockedByRestraint(flag: true);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	private void RPC_ReqForceMountNearest(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!((Object)(object)player == (Object)null))
		{
			ForceRestrainedMountNearest(player);
		}
	}

	private void ForceRestrainedMountNearest(BasePlayer forcingPlayer)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)forcingPlayer == (Object)null || isMounted || !IsRestrained || IsDead() || IsSleeping() || IsWounded())
		{
			return;
		}
		List<BaseMountable> list = Pool.Get<List<BaseMountable>>();
		Vis.Entities(((Component)this).transform.position, 2f, list, -1, (QueryTriggerInteraction)2);
		list.Sort(delegate(BaseMountable a, BaseMountable b)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = ((Component)this).transform.position - ((Component)a).transform.position;
			float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
			val = ((Component)this).transform.position - ((Component)b).transform.position;
			return sqrMagnitude.CompareTo(((Vector3)(ref val)).sqrMagnitude);
		});
		foreach (BaseMountable item in list)
		{
			if (item.isClient || !item.AllowForceMountWhenRestrained || (Object)(object)item.VehicleParent() != (Object)null || !item.DirectlyMountable() || item.Distance(eyes.position) > 3f || !GamePhysics.LineOfSight(eyes.center, eyes.position, 1218519041) || (!item.IsVisible(eyes.HeadRay(), 1218519041, 3f) && !item.IsVisible(eyes.position, 3f)))
			{
				continue;
			}
			bool flag = false;
			ModularCar modularCar = item as ModularCar;
			if ((Object)(object)modularCar != (Object)null && modularCar.CarLock.HasALock)
			{
				flag = !modularCar.CarLock.HasLockPermission(this);
				if (modularCar.CarLock.HasLockPermission(forcingPlayer))
				{
					modularCar.CarLock.TryAddPlayer(userID);
				}
			}
			item.AttemptMount(this);
			if ((Object)(object)modularCar != (Object)null && modularCar.CarLock.HasALock && flag)
			{
				modularCar.CarLock.TryRemovePlayer(userID);
			}
			if (isMounted)
			{
				break;
			}
		}
		Pool.FreeUnmanaged<BaseMountable>(ref list);
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	private void RPC_ReqForceSwapSeat(RPCMessage rpc)
	{
		if (!isMounted || !IsRestrained || IsDead() || IsSleeping() || IsWounded() || (Object)(object)rpc.player == (Object)null)
		{
			return;
		}
		BasePlayer player = rpc.player;
		BaseMountable baseMountable = GetMounted();
		if ((Object)(object)baseMountable == (Object)null)
		{
			return;
		}
		BaseVehicle baseVehicle = ((Component)baseMountable).GetComponent<BaseVehicle>();
		if ((Object)(object)baseVehicle == (Object)null)
		{
			baseVehicle = baseMountable.VehicleParent();
		}
		if ((Object)(object)baseVehicle == (Object)null)
		{
			return;
		}
		bool flag = false;
		ModularCar modularCar = baseVehicle as ModularCar;
		if ((Object)(object)modularCar != (Object)null && modularCar.CarLock.HasALock)
		{
			flag = !modularCar.CarLock.HasLockPermission(this);
			if (modularCar.CarLock.HasLockPermission(player))
			{
				modularCar.CarLock.TryAddPlayer(userID);
			}
		}
		baseVehicle.SwapSeats(this, 0, forcingRestrainedPlayer: true);
		if ((Object)(object)modularCar != (Object)null && modularCar.CarLock.HasALock && flag)
		{
			modularCar.CarLock.TryRemovePlayer(userID);
		}
	}

	public bool CanMoveFrom(BasePlayer player, Item item)
	{
		if (IsRestrainedOrSurrendering)
		{
			ItemContainer itemContainer = item?.parent;
			if (itemContainer == null)
			{
				return true;
			}
			if (itemContainer.IsLocked())
			{
				return false;
			}
			if (itemContainer == inventory.containerBelt && item.IsOn() && (Object)(object)((Component)item.info).GetComponent<ItemModRestraint>() != (Object)null)
			{
				return false;
			}
		}
		return true;
	}

	public void GetAllInventories(List<ItemContainer> list)
	{
		list.Add(inventory.containerMain);
		list.Add(inventory.containerBelt);
		list.Add(inventory.containerWear);
	}

	public void DoPush(Vector3 force, bool isRestrained = false)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		AddTempSpeedHackBudget(5f, 2f);
		PauseTickDistanceDetection(2f);
		ClientRPC(RpcTarget.Player(isRestrained ? "RPC_DoRestrainedPush" : "RPC_DoPush", this), force);
	}

	public override bool SupportsServerOcclusion()
	{
		if (!IsNpc)
		{
			return !IsBot;
		}
		return false;
	}

	internal void LifeStoryStart()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Expected O, but got Unknown
		if (lifeStory != null)
		{
			lifeStory = null;
		}
		lifeStory = new PlayerLifeStory
		{
			ShouldPool = false
		};
		lifeStory.timeBorn = (uint)Epoch.Current;
		hasSentPresenceState = false;
	}

	public void LifeStoryEnd()
	{
		SingletonComponent<ServerMgr>.Instance.persistance.AddLifeStory(userID, lifeStory);
		if (lifeStory != null)
		{
			Analytics.Azure.OnPlayerLifeStoryEnd(this, lifeStory);
		}
		previousLifeStory = lifeStory;
		lifeStory = null;
	}

	internal void LifeStoryUpdate(float deltaTime, float moveSpeed)
	{
		if (lifeStory != null)
		{
			PlayerLifeStory obj = lifeStory;
			obj.secondsAlive += deltaTime;
			nextTimeCategoryUpdate -= deltaTime * ((moveSpeed > 0.1f) ? 1f : 0.25f);
			if (nextTimeCategoryUpdate <= 0f && !waitingForLifeStoryUpdate)
			{
				nextTimeCategoryUpdate = 7f + 7f * Random.Range(0.2f, 1f);
				waitingForLifeStoryUpdate = true;
				((ObjectWorkQueue<BasePlayer>)lifeStoryQueue).Add(this);
			}
			if (LifeStoryInWilderness)
			{
				PlayerLifeStory obj2 = lifeStory;
				obj2.secondsWilderness += deltaTime;
			}
			if (LifeStoryInMonument)
			{
				PlayerLifeStory obj3 = lifeStory;
				obj3.secondsInMonument += deltaTime;
			}
			if (LifeStoryInBase)
			{
				PlayerLifeStory obj4 = lifeStory;
				obj4.secondsInBase += deltaTime;
			}
			if (LifeStoryFlying)
			{
				PlayerLifeStory obj5 = lifeStory;
				obj5.secondsFlying += deltaTime;
			}
			if (LifeStoryBoating)
			{
				PlayerLifeStory obj6 = lifeStory;
				obj6.secondsBoating += deltaTime;
			}
			if (LifeStorySwimming)
			{
				PlayerLifeStory obj7 = lifeStory;
				obj7.secondsSwimming += deltaTime;
			}
			if (LifeStoryDriving)
			{
				PlayerLifeStory obj8 = lifeStory;
				obj8.secondsDriving += deltaTime;
			}
			if (IsSleeping())
			{
				PlayerLifeStory obj9 = lifeStory;
				obj9.secondsSleeping += deltaTime;
			}
			else if (IsRunning())
			{
				PlayerLifeStory obj10 = lifeStory;
				obj10.metersRun += moveSpeed * deltaTime;
			}
			else
			{
				PlayerLifeStory obj11 = lifeStory;
				obj11.metersWalked += moveSpeed * deltaTime;
			}
		}
	}

	public void UpdateTimeCategory()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("UpdateTimeCategory", 0);
		try
		{
			waitingForLifeStoryUpdate = false;
			int num = currentTimeCategory;
			currentTimeCategory = 1;
			if (IsBuildingAuthed(cached: true, 45f))
			{
				currentTimeCategory = 4;
			}
			Vector3 position = ((Component)this).transform.position;
			if ((Object)(object)TerrainMeta.TopologyMap != (Object)null && (TerrainMeta.TopologyMap.GetTopology(position) & 0x400) != 0)
			{
				foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
				{
					if (monument.shouldDisplayOnMap && monument.IsInBounds(position))
					{
						currentTimeCategory = 2;
						break;
					}
				}
			}
			if (IsSwimming())
			{
				currentTimeCategory |= 32;
			}
			if (isMounted)
			{
				BaseMountable baseMountable = GetMounted();
				if (baseMountable.mountTimeStatType == BaseMountable.MountStatType.Boating)
				{
					currentTimeCategory |= 16;
				}
				else if (baseMountable.mountTimeStatType == BaseMountable.MountStatType.Flying)
				{
					currentTimeCategory |= 8;
				}
				else if (baseMountable.mountTimeStatType == BaseMountable.MountStatType.Driving)
				{
					currentTimeCategory |= 64;
				}
			}
			else if (HasParent() && GetParentEntity() is BaseMountable baseMountable2)
			{
				if (baseMountable2.mountTimeStatType == BaseMountable.MountStatType.Boating)
				{
					currentTimeCategory |= 16;
				}
				else if (baseMountable2.mountTimeStatType == BaseMountable.MountStatType.Flying)
				{
					currentTimeCategory |= 8;
				}
				else if (baseMountable2.mountTimeStatType == BaseMountable.MountStatType.Driving)
				{
					currentTimeCategory |= 64;
				}
			}
			if (num != currentTimeCategory || !hasSentPresenceState)
			{
				LifeStoryInWilderness = (1 & currentTimeCategory) != 0;
				LifeStoryInMonument = (2 & currentTimeCategory) != 0;
				LifeStoryInBase = (4 & currentTimeCategory) != 0;
				LifeStoryFlying = (8 & currentTimeCategory) != 0;
				LifeStoryBoating = (0x10 & currentTimeCategory) != 0;
				LifeStorySwimming = (0x20 & currentTimeCategory) != 0;
				LifeStoryDriving = (0x40 & currentTimeCategory) != 0;
				ClientRPC(RpcTarget.Player("UpdateRichPresenceState", this), currentTimeCategory);
				hasSentPresenceState = true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void LifeStoryShotFired(BaseEntity withWeapon)
	{
		if (lifeStory == null)
		{
			return;
		}
		if (lifeStory.weaponStats == null)
		{
			lifeStory.weaponStats = Pool.Get<List<WeaponStats>>();
		}
		foreach (WeaponStats weaponStat in lifeStory.weaponStats)
		{
			if (weaponStat.weaponName == withWeapon.ShortPrefabName)
			{
				weaponStat.shotsFired++;
				return;
			}
		}
		WeaponStats val = Pool.Get<WeaponStats>();
		val.weaponName = withWeapon.ShortPrefabName;
		val.shotsFired++;
		lifeStory.weaponStats.Add(val);
	}

	public void LifeStoryShotHit(BaseEntity withWeapon)
	{
		if (lifeStory == null || (Object)(object)withWeapon == (Object)null)
		{
			return;
		}
		if (lifeStory.weaponStats == null)
		{
			lifeStory.weaponStats = Pool.Get<List<WeaponStats>>();
		}
		foreach (WeaponStats weaponStat in lifeStory.weaponStats)
		{
			if (weaponStat.weaponName == withWeapon.ShortPrefabName)
			{
				weaponStat.shotsHit++;
				return;
			}
		}
		WeaponStats val = Pool.Get<WeaponStats>();
		val.weaponName = withWeapon.ShortPrefabName;
		val.shotsHit++;
		lifeStory.weaponStats.Add(val);
	}

	public void LifeStoryKill(BaseCombatEntity killed)
	{
		if (lifeStory != null)
		{
			if (killed is ScientistNPC)
			{
				PlayerLifeStory obj = lifeStory;
				obj.killedScientists++;
			}
			else if (killed is BasePlayer)
			{
				PlayerLifeStory obj2 = lifeStory;
				obj2.killedPlayers++;
			}
			else if (killed is BaseAnimalNPC)
			{
				PlayerLifeStory obj3 = lifeStory;
				obj3.killedAnimals++;
			}
		}
	}

	public void LifeStoryGenericStat(string key, int value)
	{
		if (lifeStory == null)
		{
			return;
		}
		if (lifeStory.genericStats == null)
		{
			lifeStory.genericStats = Pool.Get<List<GenericStat>>();
		}
		foreach (GenericStat genericStat in lifeStory.genericStats)
		{
			if (genericStat.key == key)
			{
				genericStat.value += value;
				return;
			}
		}
		GenericStat val = Pool.Get<GenericStat>();
		val.key = key;
		val.value = value;
		lifeStory.genericStats.Add(val);
	}

	public void LifeStoryHurt(float amount)
	{
		if (lifeStory != null)
		{
			PlayerLifeStory obj = lifeStory;
			obj.totalDamageTaken += amount;
		}
	}

	public void LifeStoryHeal(float amount)
	{
		if (lifeStory != null)
		{
			PlayerLifeStory obj = lifeStory;
			obj.totalHealing += amount;
		}
	}

	public void SetOverrideDeathBlow(DeathInfo info)
	{
		cachedOverrideDeathInfo = info;
	}

	internal void LifeStoryLogDeath(in DeathBlow deathBlow, DamageType lastDamage)
	{
		if (lifeStory == null)
		{
			return;
		}
		lifeStory.timeDied = (uint)Epoch.Current;
		DeathInfo val = cachedOverrideDeathInfo ?? Pool.Get<DeathInfo>();
		val.lastDamageType = (int)lastDamage;
		cachedOverrideDeathInfo = null;
		if (deathBlow.IsValid)
		{
			if ((Object)(object)deathBlow.Initiator != (Object)null)
			{
				deathBlow.Initiator.AttackerInfo(val);
				val.attackerDistance = Distance(deathBlow.Initiator);
			}
			if ((Object)(object)deathBlow.WeaponPrefab != (Object)null)
			{
				val.inflictorName = deathBlow.WeaponPrefab.ShortPrefabName;
			}
			if (deathBlow.HitBone != 0)
			{
				val.hitBone = StringPool.Get(deathBlow.HitBone);
			}
			else
			{
				val.hitBone = "";
			}
		}
		else if (base.SecondsSinceAttacked <= 60f && (Object)(object)lastAttacker != (Object)null)
		{
			lastAttacker.AttackerInfo(val);
		}
		lifeStory.deathInfo = val;
	}

	public void SetSpectateTeamInfo(bool state)
	{
		IsSpectatingTeamInfo = state;
	}

	private void Tick_Spectator()
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		if (serverInput.WasJustPressed(BUTTON.JUMP))
		{
			num++;
		}
		if (serverInput.WasJustPressed(BUTTON.DUCK))
		{
			num--;
		}
		if (num != 0)
		{
			SpectateOffset += num;
			TimeWarning val = TimeWarning.New("UpdateSpectateTarget", 0);
			try
			{
				UpdateSpectateTarget(spectateFilter);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		if (!(TimeSince.op_Implicit(lastSpectateTeamInfoUpdate) > 0.5f) || !IsSpectatingTeamInfo)
		{
			return;
		}
		lastSpectateTeamInfoUpdate = TimeSince.op_Implicit(0f);
		SpectateTeamInfo val2 = Pool.Get<SpectateTeamInfo>();
		val2.teams = Pool.Get<List<SpectateTeam>>();
		val2.teams.Clear();
		foreach (KeyValuePair<ulong, RelationshipManager.PlayerTeam> team in RelationshipManager.ServerInstance.teams)
		{
			SpectateTeam val3 = Pool.Get<SpectateTeam>();
			val3.teamId = team.Key;
			val3.teamMembers = Pool.Get<List<TeamMember>>();
			val3.teamMembers.Clear();
			foreach (ulong member in team.Value.members)
			{
				TeamMember val4 = Pool.Get<TeamMember>();
				val4.userID = member;
				BasePlayer basePlayer = RelationshipManager.FindByID(member);
				val4.displayName = (((Object)(object)basePlayer != (Object)null) ? basePlayer.displayName : (SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(member) ?? "DEAD"));
				val4.healthFraction = (((Object)(object)basePlayer != (Object)null && basePlayer.IsAlive()) ? basePlayer.healthFraction : 0f);
				val4.position = (((Object)(object)basePlayer != (Object)null) ? ((Component)basePlayer).transform.position : Vector3.zero);
				val4.online = (Object)(object)basePlayer != (Object)null && !basePlayer.IsSleeping();
				val4.wounded = (Object)(object)basePlayer != (Object)null && basePlayer.IsWounded();
				val3.teamMembers.Add(val4);
			}
			val2.teams.Add(val3);
		}
		ClientRPC(RpcTarget.Player("ReceiveSpectateTeamInfo", this), val2);
	}

	public void UpdateSpectateTarget(string strName)
	{
		if (Interface.CallHook("CanSpectateTarget", (object)this, (object)strName) != null)
		{
			return;
		}
		spectateFilter = strName;
		IEnumerable<BaseEntity> enumerable = null;
		if (spectateFilter.StartsWith("@"))
		{
			string filter = spectateFilter.Substring(1);
			enumerable = (from x in BaseNetworkable.serverEntities
				where StringEx.Contains(((Object)x).name, filter, CompareOptions.IgnoreCase)
				where (Object)(object)x != (Object)(object)this
				select x).Cast<BaseEntity>();
		}
		else
		{
			IEnumerable<BasePlayer> source = ((IEnumerable<BasePlayer>)activePlayerList).Where((BasePlayer x) => !x.IsSpectating() && !x.IsDead() && !x.IsSleeping());
			if (strName.Length > 0)
			{
				source = from x in source
					where StringEx.Contains(x.displayName, spectateFilter, CompareOptions.IgnoreCase) || x.UserIDString.Contains(spectateFilter)
					where (Object)(object)x != (Object)(object)this
					select x;
			}
			source = source.OrderBy((BasePlayer x) => x.displayName);
			enumerable = source.Cast<BaseEntity>();
		}
		BaseEntity[] array = enumerable.ToArray();
		if (array.Length == 0)
		{
			ChatMessage("No valid spectate targets!");
			return;
		}
		BaseEntity baseEntity = array[SpectateOffset % array.Length];
		if ((Object)(object)baseEntity != (Object)null)
		{
			SpectatePlayer(baseEntity);
		}
	}

	public void UpdateSpectateTarget(ulong id)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if ((Object)(object)current != (Object)null && (ulong)current.userID == id)
				{
					spectateFilter = string.Empty;
					SpectatePlayer(current);
					break;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	private void SpectatePlayer(BaseEntity target)
	{
		if (target is BasePlayer)
		{
			ChatMessage("Spectating: " + (target as BasePlayer).displayName);
		}
		else
		{
			ChatMessage("Spectating: " + ((object)target).ToString());
		}
		TimeWarning val = TimeWarning.New("SendEntitySnapshot", 0);
		try
		{
			SendEntitySnapshot(target);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		((Component)this).gameObject.Identity();
		val = TimeWarning.New("SetParent", 0);
		try
		{
			SetParent(target);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void StartSpectating()
	{
		if (!IsSpectating() && Interface.CallHook("OnPlayerSpectate", (object)this, (object)spectateFilter) == null)
		{
			SetPlayerFlag(PlayerFlags.Spectating, b: true);
			((Component)this).gameObject.SetLayerRecursive(10);
			((FacepunchBehaviour)this).CancelInvoke((Action)InventoryUpdate);
			ChatMessage("Becoming Spectator");
			UpdateSpectateTarget(spectateFilter);
		}
	}

	public void StopSpectating()
	{
		if (IsSpectating() && Interface.CallHook("OnPlayerSpectateEnd", (object)this, (object)spectateFilter) == null)
		{
			SetParent(null);
			SetPlayerFlag(PlayerFlags.Spectating, b: false);
			((Component)this).gameObject.SetLayerRecursive(17);
		}
	}

	public void Teleport(BasePlayer player)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		Teleport(((Component)player).transform.position);
	}

	public void Teleport(string strName, bool playersOnly)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity[] array = Util.FindTargets(strName, playersOnly);
		if (array != null && array.Length != 0)
		{
			BaseEntity baseEntity = array[Random.Range(0, array.Length)];
			Teleport(((Component)baseEntity).transform.position);
		}
	}

	public void Teleport(Vector3 position)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		MovePosition(position);
		ClientRPC(RpcTarget.Player("ForcePositionTo", this), position);
	}

	public void CopyRotation(BasePlayer player)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		viewAngles = player.viewAngles;
		SendNetworkUpdate_Position();
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (child is BasePlayer)
		{
			IsBeingSpectated = true;
		}
	}

	protected override void OnChildRemoved(BaseEntity child)
	{
		base.OnChildRemoved(child);
		if (!(child is BasePlayer))
		{
			return;
		}
		IsBeingSpectated = false;
		foreach (BaseEntity child2 in children)
		{
			if (child2 is BasePlayer)
			{
				IsBeingSpectated = true;
			}
		}
	}

	[RPC_Server.CallsPerSecond(10uL)]
	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	private void UpdateSpectatePositionFromDebugCamera(RPCMessage msg)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (IsSpectating() && Global.updateNetworkPositionWithDebugCameraWhileSpectating)
		{
			Vector3 position = msg.read.Vector3();
			((Component)this).transform.position = position;
			SetParent(null);
		}
	}

	[RPC_Server]
	private void NotifyDebugCameraEnded(RPCMessage msg)
	{
		if (IsSpectating() && Global.updateNetworkPositionWithDebugCameraWhileSpectating)
		{
			UpdateSpectateTarget(spectateFilter);
		}
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		if (IsSleeping())
		{
			return false;
		}
		if (!IsAlive())
		{
			return false;
		}
		if (InSafeZone())
		{
			return false;
		}
		if ((Object)(object)splashType == (Object)null || splashType.shortname == null)
		{
			return false;
		}
		if (!((Object)(object)splashType == (Object)(object)WaterTypes.RadioactiveWaterItemDef) && !((Object)(object)splashType == (Object)(object)WaterTypes.WaterItemDef))
		{
			return (Object)(object)splashType == (Object)(object)WaterTypes.SaltWaterItemDef;
		}
		return true;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		CheckWaterRadiation(splashType, amount);
		CheckWater(splashType, amount);
		return amount;
	}

	public int DoSplashFunWater(ItemDefinition splashType, int amount)
	{
		CheckWaterRadiation(splashType, amount);
		return amount;
	}

	private void CheckWaterRadiation(ItemDefinition splashType, int amount)
	{
		if ((Object)(object)splashType == (Object)(object)WaterTypes.RadioactiveWaterItemDef)
		{
			float num = (float)amount * Radiation.MaterialToRadsRatio;
			num = Mathf.Max(num, 0.5f);
			ApplyRadiation(num);
		}
	}

	private void CheckWater(ItemDefinition splashType, int amount)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)splashType == (Object)(object)WaterTypes.WaterItemDef || (Object)(object)splashType == (Object)(object)WaterTypes.SaltWaterItemDef)
		{
			float num = (float)amount * 0.01f;
			num = Mathf.Max(num, 5f);
			timeSinceLastWaterSplash = TimeSince.op_Implicit(0f);
			if (!(baseProtection.amounts[4] > 0f))
			{
				metabolism.wetness.Add(num);
			}
		}
	}

	public void AddNeabyStash(StashContainer newStash)
	{
		if ((Object)(object)newStash == (Object)null)
		{
			return;
		}
		foreach (NearbyStash nearbyStash in nearbyStashes)
		{
			if ((Object)(object)nearbyStash.Entity == (Object)(object)newStash)
			{
				return;
			}
		}
		if (nearbyStashes.Count == 0)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)CheckStashRevealInvoke, 0f, StashContainer.PlayerDetectionTickRate);
		}
		nearbyStashes.Add(new NearbyStash(newStash));
	}

	public void RemoveNearbyStash(StashContainer stash)
	{
		for (int i = 0; i < nearbyStashes.Count; i++)
		{
			if (!((Object)(object)nearbyStashes[i].Entity != (Object)(object)stash))
			{
				nearbyStashes.RemoveAt(i);
				break;
			}
		}
		if (nearbyStashes.Count == 0)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)CheckStashRevealInvoke);
		}
	}

	private void CheckStashRevealInvoke()
	{
		for (int i = 0; i < nearbyStashes.Count; i++)
		{
			NearbyStash nearbyStash = nearbyStashes[i];
			if ((Object)(object)nearbyStash.Entity == (Object)null || nearbyStash.Entity.IsDestroyed)
			{
				nearbyStashes.RemoveAt(i);
			}
			else if (nearbyStash.Entity.IsHidden() && nearbyStash.Entity.PlayerInRange(this))
			{
				nearbyStash.LookingAtTime += StashContainer.PlayerDetectionTickRate;
				if (nearbyStash.LookingAtTime >= nearbyStash.Entity.uncoverTime)
				{
					if (Interface.CallHook("CanSeeStash", (object)this, (object)nearbyStash.Entity) != null)
					{
						break;
					}
					nearbyStash.Entity.SetHidden(isHidden: false);
					Analytics.Azure.OnStashRevealed(this, nearbyStash.Entity);
					Interface.CallHook("OnStashExposed", (object)nearbyStash.Entity, (object)this);
				}
			}
			else
			{
				nearbyStash.LookingAtTime = 0f;
			}
		}
	}

	public override float GetThreatLevel()
	{
		EnsureUpdated();
		return cachedThreatLevel;
	}

	public void EnsureUpdated()
	{
		if (Time.realtimeSinceStartup - lastUpdateTime < 30f)
		{
			return;
		}
		lastUpdateTime = Time.realtimeSinceStartup;
		cachedThreatLevel = 0f;
		if (IsSleeping() || Interface.CallHook("OnThreatLevelUpdate", (object)this) != null)
		{
			return;
		}
		if (inventory.containerWear.itemList.Count > 2)
		{
			cachedThreatLevel += 1f;
		}
		foreach (Item item in inventory.containerBelt.itemList)
		{
			BaseEntity heldEntity = item.GetHeldEntity();
			if (Object.op_Implicit((Object)(object)heldEntity) && heldEntity is BaseProjectile && !(heldEntity is BowWeapon))
			{
				cachedThreatLevel += 2f;
				break;
			}
		}
	}

	public override bool IsHostile()
	{
		object obj = Interface.CallHook("CanEntityBeHostile", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return State.unHostileTimestamp > TimeEx.currentTimestamp;
	}

	public virtual float GetHostileDuration()
	{
		return Mathf.Clamp((float)(State.unHostileTimestamp - TimeEx.currentTimestamp), 0f, float.PositiveInfinity);
	}

	public override void MarkHostileFor(float duration = 60f)
	{
		if (Interface.CallHook("OnEntityMarkHostile", (object)this, (object)duration) == null)
		{
			double currentTimestamp = TimeEx.currentTimestamp;
			double val = currentTimestamp + (double)duration;
			State.unHostileTimestamp = Math.Max(State.unHostileTimestamp, val);
			DirtyPlayerState();
			double num = Math.Max(State.unHostileTimestamp - currentTimestamp, 0.0);
			ClientRPC(RpcTarget.Player("SetHostileLength", this), (float)num);
		}
	}

	public void MarkWeaponDrawnDuration(float newDuration)
	{
		float num = weaponDrawnDuration;
		weaponDrawnDuration = newDuration;
		if ((float)Mathf.FloorToInt(newDuration) != num)
		{
			ClientRPC(RpcTarget.Player("SetWeaponDrawnDuration", this), weaponDrawnDuration);
		}
	}

	public void AddWeaponDrawnDuration(float duration)
	{
		MarkWeaponDrawnDuration(weaponDrawnDuration + duration);
	}

	public void OnReceivedTick(NetRead read)
	{
		TimeWarning val = TimeWarning.New("OnReceiveTickFromStream", 0);
		try
		{
			TimeWarning val2 = TimeWarning.New("PlayerTick.Deserialize", 0);
			PlayerTick val3;
			try
			{
				val3 = read.ProtoDelta<PlayerTick>(lastReceivedTick);
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			val2 = TimeWarning.New("RecordPacket", 0);
			try
			{
				net.connection.RecordPacket((byte)15, (IProto)(object)val3);
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			val2 = TimeWarning.New("PlayerTick.Copy", 0);
			try
			{
				PlayerTick obj = lastReceivedTick;
				if (obj != null)
				{
					obj.Dispose();
				}
				lastReceivedTick = val3.Copy();
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			val2 = TimeWarning.New("OnReceiveTick", 0);
			try
			{
				OnReceiveTick(val3, wasStalled);
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			lastTickTime = Time.time;
			rawTicksPerSecond.Increment();
			val3.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void OnReceivedVoice(byte[] data)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnPlayerVoice", (object)this, (object)data) == null)
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)21);
			obj.EntityID(net.ID);
			obj.BytesWithSize(data, false);
			float num = 0f;
			if (HasPlayerFlag(PlayerFlags.VoiceRangeBoost))
			{
				num = Voice.voiceRangeBoostAmount;
			}
			SendInfo val = default(SendInfo);
			((SendInfo)(ref val))..ctor(BaseNetworkable.GetConnectionsWithin(((Component)this).transform.position, 100f + num, addSecondaryConnections: true));
			val.priority = (Priority)0;
			obj.Send(val);
			if ((Object)(object)activeTelephone != (Object)null)
			{
				activeTelephone.OnReceivedVoiceFromUser(data);
			}
			if ((Object)(object)SingletonComponent<NpcNoiseManager>.Instance != (Object)null)
			{
				SingletonComponent<NpcNoiseManager>.Instance.OnVoiceChat(this);
			}
		}
	}

	public void ResetInputIdleTime()
	{
		lastInputTime = Time.time;
	}

	private void EACStateUpdate(in CachedState tickState)
	{
		if (!IsReceivingSnapshot)
		{
			EACServer.LogPlayerTick(this, in tickState);
		}
	}

	public void AddReceiveTickListener(IReceivePlayerTickListener listener)
	{
		if (receiveTickListeners != null && !receiveTickListeners.Contains(listener))
		{
			receiveTickListeners.Add(listener);
		}
	}

	public void RemoveReceiveTickListener(IReceivePlayerTickListener listener)
	{
		receiveTickListeners.Remove(listener);
	}

	private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
	{
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		if (msg.inputState != null)
		{
			serverInput.Flip(msg.inputState);
		}
		if (Interface.CallHook("OnPlayerTick", (object)this, (object)msg, (object)wasPlayerStalled) != null)
		{
			return;
		}
		if (serverInput.current.buttons != serverInput.previous.buttons)
		{
			ResetInputIdleTime();
		}
		if (Interface.CallHook("OnPlayerInput", (object)this, (object)serverInput) != null || IsReceivingSnapshot)
		{
			return;
		}
		if (IsSpectating())
		{
			TimeWarning val = TimeWarning.New("Tick_Spectator", 0);
			try
			{
				Tick_Spectator();
				return;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		if (IsDead())
		{
			return;
		}
		if (IsSleeping())
		{
			if (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))
			{
				EndSleeping();
				SendNetworkUpdateImmediate();
			}
			UpdateActiveItem(default(ItemId));
			return;
		}
		if (IsRestrained && restraintItemId.HasValue && restraintItemId.HasValue)
		{
			UpdateActiveItem(restraintItemId.Value);
		}
		else if (!Belt.CanHoldItem())
		{
			UpdateActiveItem(default(ItemId));
		}
		else
		{
			UpdateActiveItem(msg.activeItem);
		}
		UpdateModelStateFromTick(msg);
		if (float.IsNaN(modelState.ducking) || float.IsInfinity(modelState.ducking))
		{
			Kick("Kicked: invalid modelstate");
			return;
		}
		modelState.ducking = Mathf.Clamp01(modelState.ducking);
		if (IsIncapacitated())
		{
			return;
		}
		ForwardReceiveTickToListeners(msg);
		if (isMounted)
		{
			GetMounted().PlayerServerInput(serverInput, this);
		}
		UpdatePositionFromTick(msg, wasPlayerStalled);
		UpdateRotationFromTick(msg);
		int activeMission = GetActiveMission();
		if (activeMission >= 0 && activeMission < missions.Count)
		{
			BaseMission.MissionInstance missionInstance = missions[activeMission];
			if (missionInstance.status == BaseMission.MissionStatus.Active && missionInstance.NeedsPlayerInput())
			{
				ProcessMissionEvent(BaseMission.MissionEventType.PLAYER_TICK, net.ID, 0f);
			}
		}
		if (!TutorialIsland.EnforceTrespassChecks || IsAdmin || IsNpc || net == null || net.group == null)
		{
			return;
		}
		if (net.group.restricted)
		{
			bool flag = false;
			if (!IsInTutorial)
			{
				flag = true;
			}
			else
			{
				TutorialIsland currentTutorialIsland = GetCurrentTutorialIsland();
				if ((Object)(object)currentTutorialIsland == (Object)null || currentTutorialIsland.net.group != net.group)
				{
					flag = true;
				}
			}
			if (flag)
			{
				tutorialKickTime += Time.deltaTime;
				if (tutorialKickTime > 3f)
				{
					Debug.LogWarning((object)$"Killing player {displayName}/{userID.Get()} as they are on a tutorial island that doesn't belong them");
					Hurt(999f);
					tutorialKickTime = 0f;
				}
			}
			else
			{
				tutorialKickTime = 0f;
			}
		}
		else
		{
			if (!IsInTutorial || net.group.restricted)
			{
				return;
			}
			bool flag2 = false;
			TutorialIsland currentTutorialIsland2 = GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland2 == (Object)null || currentTutorialIsland2.net.group != net.group)
			{
				flag2 = true;
			}
			if (flag2)
			{
				tutorialKickTime += Time.deltaTime;
				if (tutorialKickTime > 3f)
				{
					Debug.LogWarning((object)$"Killing player {displayName}/{userID.Get()} as they are no longer on a tutorial island and are marked as being in a tutorial");
					Hurt(999f);
					tutorialKickTime = 0f;
				}
			}
			else
			{
				tutorialKickTime = 0f;
			}
		}
	}

	private void RemoveReceiveTickListenersOnDeath()
	{
		for (int num = receiveTickListeners.Count - 1; num >= 0; num--)
		{
			IReceivePlayerTickListener receivePlayerTickListener = receiveTickListeners[num];
			if (receivePlayerTickListener == null)
			{
				receiveTickListeners.RemoveAt(num);
			}
			else if (receivePlayerTickListener.ShouldRemoveOnPlayerDeath())
			{
				receiveTickListeners.Remove(receivePlayerTickListener);
			}
		}
	}

	private void ForwardReceiveTickToListeners(PlayerTick msg)
	{
		if (receiveTickListeners == null)
		{
			return;
		}
		for (int num = receiveTickListeners.Count - 1; num >= 0; num--)
		{
			IReceivePlayerTickListener receivePlayerTickListener = receiveTickListeners[num];
			if (receivePlayerTickListener == null)
			{
				receiveTickListeners.RemoveAt(num);
			}
			else
			{
				receivePlayerTickListener.OnReceivePlayerTick(this, msg);
			}
		}
	}

	public void ApplyStallProtection(float time)
	{
		stallProtectionTime = Mathf.Max(time, stallProtectionTime);
	}

	public void UpdateActiveItem(ItemId itemID)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsTrue(base.isServer, "Realm should be server!");
		if (svActiveItemID == itemID)
		{
			return;
		}
		if (equippingBlocked)
		{
			itemID = default(ItemId);
		}
		Item item = inventory.containerBelt.FindItemByUID(itemID);
		if (IsItemHoldRestricted(item))
		{
			itemID = default(ItemId);
		}
		Item activeItem = GetActiveItem();
		if (Interface.CallHook("OnActiveItemChange", (object)this, (object)activeItem, (object)itemID) != null)
		{
			return;
		}
		svActiveItemID = default(ItemId);
		if (activeItem != null)
		{
			HeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;
			if ((Object)(object)heldEntity != (Object)null)
			{
				heldEntity.SetHeld(bHeld: false);
			}
		}
		svActiveItemID = itemID;
		SendNetworkUpdate();
		Item activeItem2 = GetActiveItem();
		if (activeItem2 != null)
		{
			HeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;
			if ((Object)(object)heldEntity2 != (Object)null)
			{
				heldEntity2.SetHeld(bHeld: true);
			}
			NotifyGesturesNewItemEquipped();
		}
		inventory.UpdatedVisibleHolsteredItems();
		Interface.CallHook("OnActiveItemChanged", (object)this, (object)activeItem, (object)activeItem2);
	}

	internal void UpdateModelStateFromTick(PlayerTick tick)
	{
		if (tick.modelState != null && !ModelState.Equal(modelStateTick, tick.modelState))
		{
			if (modelStateTick != null)
			{
				modelStateTick.ResetToPool();
			}
			modelStateTick = tick.modelState;
			tick.modelState = null;
			tickNeedsFinalizing = true;
		}
	}

	internal void UpdatePositionFromTick(PlayerTick tick, bool wasPlayerStalled)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3Ex.IsNaNOrInfinity(tick.position) || Vector3Ex.IsNaNOrInfinity(tick.eyePos))
		{
			Kick("Kicked: Invalid Position");
		}
		else
		{
			if (tick.parentID != parentEntity.uid)
			{
				return;
			}
			tickDistancePausetime = Mathf.Max(0f, tickDistancePausetime - tickDeltaTime);
			if (isMounted || (modelState != null && modelState.mounted) || (modelStateTick != null && modelStateTick.mounted) || (IsWounded() && IsRestrained))
			{
				return;
			}
			if (wasPlayerStalled)
			{
				float num = Vector3.Distance(tick.position, tickInterpolator.EndPoint);
				if (num > 0.01f)
				{
					AntiHack.ResetTimer(this);
				}
				if (num > 0.5f)
				{
					ClientRPC(RpcTarget.Player("ForcePositionToParentOffset", this), tickInterpolator.EndPoint, parentEntity.uid);
				}
				return;
			}
			if (!AntiHack.ShouldIgnore(this))
			{
				float num2 = Vector3.Distance(tick.position, tickInterpolator.EndPoint);
				float tick_max_distance = ConVar.AntiHack.tick_max_distance;
				float num3 = ((ConVar.AntiHack.flyhack_protection <= 0 || isInAir || RecentlyInAir()) ? ConVar.AntiHack.tick_max_distance_falling : tick_max_distance);
				float num4 = (HasParent() ? ConVar.AntiHack.tick_max_distance_parented : tick_max_distance);
				float num5 = ((tickDistancePausetime > 0f) ? ConVar.AntiHack.tick_distance_forgiveness : tick_max_distance);
				float num6 = Mathx.Max(tick_max_distance, num3, num4, num5);
				if (num2 > num6)
				{
					AntiHack.Log(this, AntiHackType.Ticks, "moved too far between ticks: " + num2 + " units. Max dist: " + num6 + " ");
					AntiHack.ResetTimer(this);
					ClientRPC(RpcTarget.Player("ForcePositionToParentOffset", this), tickInterpolator.EndPoint, parentEntity.uid);
					return;
				}
			}
			tickInterpolator.AddPoint(tick.position);
			if (ConVar.Server.UsePlayerUpdateJobs && StableIndex != -1)
			{
				TickCache.AddTick(this, tick.position);
			}
			tickNeedsFinalizing = true;
		}
	}

	internal void UpdateRotationFromTick(PlayerTick tick)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		if (tick.inputState != null)
		{
			if (Vector3Ex.IsNaNOrInfinity(tick.inputState.aimAngles))
			{
				Kick("Kicked: Invalid Rotation");
				return;
			}
			if (Vector3Ex.IsNaNOrInfinity(tick.inputState.mouseDelta))
			{
				Kick("Kicked: Invalid Rotation");
				return;
			}
			tickMouseDelta = tick.inputState.mouseDelta;
			tickViewAngles = tick.inputState.aimAngles;
			tickNeedsFinalizing = true;
		}
	}

	public void UpdateEstimatedVelocity(Vector3 lastPos, Vector3 currentPos, float deltaTime)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		estimatedVelocity = (currentPos - lastPos) / deltaTime;
		Vector3 val = estimatedVelocity;
		estimatedSpeed = ((Vector3)(ref val)).magnitude;
		estimatedSpeed2D = Vector3Ex.Magnitude2D(estimatedVelocity);
		if (estimatedSpeed < 0.01f)
		{
			estimatedSpeed = 0f;
		}
		if (estimatedSpeed2D < 0.01f)
		{
			estimatedSpeed2D = 0f;
		}
	}

	private void CheckModelState()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("ModelState", 0);
		try
		{
			if (modelStateTick == null)
			{
				return;
			}
			if (modelStateTick.inheritedVelocity != Vector3.zero && (Object)(object)FindTrigger<TriggerForce>() == (Object)null)
			{
				modelStateTick.inheritedVelocity = Vector3.zero;
			}
			if (modelState != null)
			{
				if (ConVar.AntiHack.modelstate && TriggeredAntiHack())
				{
					modelStateTick.ducked = modelState.ducked;
				}
				modelState.ResetToPool();
				modelState = null;
			}
			modelState = modelStateTick;
			modelStateTick = null;
			UpdateModelState();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void FinalizeTick(float deltaTime)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		tickDeltaTime += deltaTime;
		if (IsReceivingSnapshot || !tickNeedsFinalizing)
		{
			return;
		}
		tickNeedsFinalizing = false;
		rawTickCount = rawTicksPerSecond.Calculate();
		CheckModelState();
		CachedState initialState = default(CachedState);
		TimeWarning val = TimeWarning.New("CachingPlayerState", 0);
		try
		{
			initialState.IsValid = true;
			initialState.WaterFactor = WaterFactor(out initialState.WaterInfo);
			initialState.IsSwimming = IsSwimming(initialState.WaterFactor);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("Transform", 0);
		try
		{
			UpdateEstimatedVelocity(tickInterpolator.StartPoint, tickInterpolator.EndPoint, tickDeltaTime);
			bool flag = tickInterpolator.StartPoint != tickInterpolator.EndPoint;
			bool flag2 = tickViewAngles != viewAngles;
			if (flag)
			{
				if (AntiHack.ValidateMove(this, tickInterpolator, tickDeltaTime, in initialState))
				{
					TimeWarning val2 = TimeWarning.New("SetPosition", 0);
					try
					{
						((Component)this).transform.localPosition = tickInterpolator.EndPoint;
						ticksPerSecond.Increment();
						tickHistory.AddPoint(tickInterpolator.EndPoint, tickHistoryCapacity);
					}
					finally
					{
						((IDisposable)val2)?.Dispose();
					}
					val2 = TimeWarning.New("RecachingPlayerState", 0);
					try
					{
						initialState.IsValid = true;
						initialState.WaterFactor = WaterFactor(out initialState.WaterInfo);
						initialState.IsSwimming = IsSwimming(initialState.WaterFactor);
					}
					finally
					{
						((IDisposable)val2)?.Dispose();
					}
					AntiHack.FadeViolations(this, tickDeltaTime);
				}
				else
				{
					flag = false;
					if (ConVar.AntiHack.forceposition)
					{
						ClientRPC(RpcTarget.Player("ForcePositionToParentOffset", this), ((Component)this).transform.localPosition, parentEntity.uid);
					}
				}
			}
			tickInterpolator.Reset(((Component)this).transform.localPosition);
			if (flag2)
			{
				viewAngles = tickViewAngles;
				if (!isMounted || !GetMounted().isMobile)
				{
					((Component)this).transform.rotation = Quaternion.identity;
				}
				((Component)this).transform.hasChanged = true;
			}
			if (flag || flag2)
			{
				eyes.NetworkUpdate(Quaternion.Euler(viewAngles));
				NetworkPositionTick();
				TimeWarning val2 = TimeWarning.New("AnalyticsTick", 0);
				try
				{
					Analytics.Azure.OnPlayerTick(this, in initialState);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			AntiHack.ValidateEyeHistory(this);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("ModelState", 0);
		try
		{
			if (modelState != null)
			{
				modelState.waterLevel = initialState.WaterFactor;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("EACStateUpdate", 0);
		try
		{
			EACStateUpdate(in initialState);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("AntiHack.EnforceViolations", 0);
		try
		{
			AntiHack.EnforceViolations(this);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		tickDeltaTime = 0f;
	}

	public static void InitInternalState(int initCap = 32)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		DisposeInternalState();
		PlayerLocalPos = new NativeArray<Vector3>(initCap, (Allocator)4, (NativeArrayOptions)0);
		PlayerLocalRots = new NativeArray<Quaternion>(initCap, (Allocator)4, (NativeArrayOptions)0);
		PositionChanges = new NativeArray<PositionChange>(initCap, (Allocator)4, (NativeArrayOptions)0);
		WaterInfos = new NativeArray<WaterLevel.WaterInfo>(initCap, (Allocator)4, (NativeArrayOptions)0);
		WaterFactors = new NativeArray<float>(initCap, (Allocator)4, (NativeArrayOptions)0);
		CachedStates = new NativeArray<CachedState>(initCap, (Allocator)4, (NativeArrayOptions)0);
		TickCache = new TickInterpolatorCache(initCap);
		PlayerTransformsAccess = new TransformAccessArray(initCap, -1);
		PlayersToFinalize = new NativeList<int>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		PlayersToValidate = new NativeList<int>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		PlayersToRecache = new NativeList<int>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		InitializeWaterFactorsCache(initCap);
		WaterLevel.InitInternalState(initCap);
		AntiHack.InitInternalState(initCap);
	}

	public static void DisposeInternalState()
	{
		PlayerLocalPos.SafeDispose<Vector3>();
		PlayerLocalRots.SafeDispose<Quaternion>();
		NativeArrayEx.SafeDispose(ref PositionChanges);
		NativeArrayEx.SafeDispose(ref WaterInfos);
		NativeArrayEx.SafeDispose(ref WaterFactors);
		NativeArrayEx.SafeDispose(ref CachedStates);
		TickCache?.Dispose();
		if (((TransformAccessArray)(ref PlayerTransformsAccess)).isCreated)
		{
			((TransformAccessArray)(ref PlayerTransformsAccess)).Dispose();
		}
		NativeListEx.SafeDispose(ref PlayersToFinalize);
		NativeListEx.SafeDispose(ref PlayersToValidate);
		NativeListEx.SafeDispose(ref PlayersToRecache);
		DisposeWaterFactorsCache();
		WaterLevel.DisposeInternalState();
		AntiHack.DisposeInternalState();
	}

	private static void FinalizeTickParallel(float deltaTime, PlayerCache playerCache)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_032d: Unknown result type (might be due to invalid IL or missing references)
		//IL_043c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0441: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0407: Unknown result type (might be due to invalid IL or missing references)
		//IL_040c: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0507: Unknown result type (might be due to invalid IL or missing references)
		//IL_050c: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0556: Unknown result type (might be due to invalid IL or missing references)
		//IL_055b: Unknown result type (might be due to invalid IL or missing references)
		//IL_052f: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("ProcessPlayers", 0);
		try
		{
			NativeListEx.Expand(ref PlayersToFinalize, ((StableObjectCache<BasePlayer>)playerCache).Count, copyContents: false);
			ValidEnumerator<BasePlayer> enumerator = playerCache.ValidPlayers.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current = enumerator.Current;
					current.tickDeltaTime += deltaTime;
					if (!current.IsReceivingSnapshot && current.tickNeedsFinalizing)
					{
						PlayersToFinalize.AddNoResize(current.StableIndex);
						current.tickNeedsFinalizing = false;
						current.rawTickCount = current.rawTicksPerSecond.Calculate();
						current.CheckModelState();
						current.UpdateEstimatedVelocity(current.tickInterpolator.StartPoint, current.tickInterpolator.EndPoint, current.tickDeltaTime);
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		if (PlayersToFinalize.IsEmpty)
		{
			return;
		}
		ReadOnlySpan<BasePlayer> players = playerCache.Players;
		NativeArrayEx.Expand(ref WaterInfos, players.Length, (NativeArrayOptions)0);
		NativeArrayEx.Expand(ref WaterFactors, players.Length, (NativeArrayOptions)0);
		NativeArrayEx.Expand(ref CachedStates, players.Length, (NativeArrayOptions)0);
		PlayerLocalPos.Expand<Vector3>(players.Length, (NativeArrayOptions)0, copyContents: true, usePowerOfTwo: false);
		PlayerLocalRots.Expand<Quaternion>(players.Length, (NativeArrayOptions)0, copyContents: true, usePowerOfTwo: false);
		RecacheTransforms recacheTransforms = default(RecacheTransforms);
		recacheTransforms.LocalPos = PlayerLocalPos;
		recacheTransforms.LocalRots = PlayerLocalRots;
		RecacheTransforms recacheTransforms2 = recacheTransforms;
		IJobParallelForTransformExtensions.RunReadOnlyByRef<RecacheTransforms>(ref recacheTransforms2, PlayerTransformsAccess);
		GetWaterFactors(playerCache, PlayerLocalPos.AsReadOnly(), PlayerLocalRots.AsReadOnly(), PlayersToFinalize.AsReadOnly(), WaterInfos, WaterFactors);
		UpdateWaterCache updateWaterCache = default(UpdateWaterCache);
		updateWaterCache.States = CachedStates;
		updateWaterCache.Factors = WaterFactors.AsReadOnly();
		updateWaterCache.Infos = WaterInfos.AsReadOnly();
		updateWaterCache.Indices = PlayersToFinalize.AsReadOnly();
		UpdateWaterCache updateWaterCache2 = updateWaterCache;
		IJobExtensions.RunByRef<UpdateWaterCache>(ref updateWaterCache2);
		TickInterpolatorCache.ReadOnlyState readOnly = TickCache.ReadOnly;
		NativeArrayEx.Expand(ref PositionChanges, players.Length, (NativeArrayOptions)0);
		NativeListEx.Expand(ref PlayersToValidate, PlayersToFinalize.Length, copyContents: false);
		GatherPosToValidateJob gatherPosToValidateJob = default(GatherPosToValidateJob);
		gatherPosToValidateJob.Changes = PositionChanges;
		gatherPosToValidateJob.ToValidate = PlayersToValidate;
		gatherPosToValidateJob.TickCache = readOnly;
		gatherPosToValidateJob.Indices = PlayersToFinalize.AsReadOnly();
		GatherPosToValidateJob gatherPosToValidateJob2 = gatherPosToValidateJob;
		IJobExtensions.RunByRef<GatherPosToValidateJob>(ref gatherPosToValidateJob2);
		NativeListEx.Expand(ref PlayersToRecache, PlayersToValidate.Length, copyContents: false);
		AntiHack.ValidateMoves(playerCache, readOnly, CachedStates, PlayersToValidate.AsReadOnly(), PositionChanges);
		val = TimeWarning.New("GatherPositionChanged", 0);
		try
		{
			Enumerator<int> enumerator2 = PlayersToValidate.GetEnumerator();
			try
			{
				while (enumerator2.MoveNext())
				{
					int current2 = enumerator2.Current;
					if (PositionChanges[current2] == PositionChange.Valid)
					{
						PlayersToRecache.AddNoResize(current2);
						BasePlayer basePlayer = players[current2];
						((Component)basePlayer).transform.localPosition = basePlayer.tickInterpolator.EndPoint;
						basePlayer.ticksPerSecond.Increment();
						basePlayer.tickHistory.AddPoint(basePlayer.tickInterpolator.EndPoint, basePlayer.tickHistoryCapacity);
						AntiHack.FadeViolations(basePlayer, basePlayer.tickDeltaTime);
					}
				}
			}
			finally
			{
				((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		if (!PlayersToRecache.IsEmpty)
		{
			TimeWarning val2 = TimeWarning.New("RecachingPlayerState", 0);
			try
			{
				IJobParallelForTransformExtensions.RunReadOnlyByRef<RecacheTransforms>(ref recacheTransforms2, PlayerTransformsAccess);
				GetWaterFactors(playerCache, PlayerLocalPos.AsReadOnly(), PlayerLocalRots.AsReadOnly(), PlayersToRecache.AsReadOnly(), WaterInfos, WaterFactors);
				updateWaterCache = default(UpdateWaterCache);
				updateWaterCache.States = CachedStates;
				updateWaterCache.Factors = WaterFactors.AsReadOnly();
				updateWaterCache.Infos = WaterInfos.AsReadOnly();
				updateWaterCache.Indices = PlayersToRecache.AsReadOnly();
				UpdateWaterCache updateWaterCache3 = updateWaterCache;
				IJobExtensions.RunByRef<UpdateWaterCache>(ref updateWaterCache3);
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		TimeWarning val3 = TimeWarning.New("FinalizePlayers", 0);
		try
		{
			Enumerator<int> enumerator2 = PlayersToFinalize.GetEnumerator();
			try
			{
				while (enumerator2.MoveNext())
				{
					int current3 = enumerator2.Current;
					BasePlayer basePlayer2 = players[current3];
					if (basePlayer2.IsRealNull())
					{
						continue;
					}
					CachedState tickState = CachedStates[current3];
					PositionChange num = PositionChanges[current3];
					bool flag = num == PositionChange.Valid;
					if (num == PositionChange.Invalid && ConVar.AntiHack.forceposition)
					{
						basePlayer2.ClientRPC(RpcTarget.Player("ForcePositionToParentOffset", basePlayer2), ((Component)basePlayer2).transform.localPosition, basePlayer2.parentEntity.uid);
					}
					basePlayer2.tickInterpolator.Reset(((Component)basePlayer2).transform.localPosition);
					TickCache.Reset(basePlayer2, ((Component)basePlayer2).transform.localPosition);
					if (basePlayer2.tickViewAngles != basePlayer2.viewAngles)
					{
						basePlayer2.viewAngles = basePlayer2.tickViewAngles;
						if (!basePlayer2.isMounted || !basePlayer2.GetMounted().isMobile)
						{
							((Component)basePlayer2).transform.rotation = Quaternion.identity;
						}
						((Component)basePlayer2).transform.hasChanged = true;
						flag = true;
					}
					if (flag)
					{
						basePlayer2.eyes.NetworkUpdate(Quaternion.Euler(basePlayer2.viewAngles));
						basePlayer2.NetworkPositionTick();
						val = TimeWarning.New("AnalyticsTick", 0);
						try
						{
							Analytics.Azure.OnPlayerTick(basePlayer2, in tickState);
						}
						finally
						{
							((IDisposable)val)?.Dispose();
						}
					}
					AntiHack.ValidateEyeHistory(basePlayer2);
					if (basePlayer2.modelState != null)
					{
						basePlayer2.modelState.waterLevel = tickState.WaterFactor;
					}
					val = TimeWarning.New("EACStateUpdate", 0);
					try
					{
						basePlayer2.EACStateUpdate(in tickState);
					}
					finally
					{
						((IDisposable)val)?.Dispose();
					}
					val = TimeWarning.New("AntiHack.EnforceViolations", 0);
					try
					{
						AntiHack.EnforceViolations(basePlayer2);
					}
					finally
					{
						((IDisposable)val)?.Dispose();
					}
					basePlayer2.tickDeltaTime = 0f;
				}
			}
			finally
			{
				((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
			}
		}
		finally
		{
			((IDisposable)val3)?.Dispose();
		}
	}

	private static bool ValidatePlayerCache(PlayerCache playerCache)
	{
		TimeWarning val = TimeWarning.New("ValidatePlayerCache", 0);
		try
		{
			int num = 0;
			for (int i = 0; i < playerCache.Players.Length; i++)
			{
				BasePlayer basePlayer = playerCache.Players[i];
				if (!basePlayer.IsRealNull())
				{
					if ((Object)(object)basePlayer == (Object)null)
					{
						Debug.LogError((object)"UsePlayerUpdateJobs: PlayerCache has a null player that hasn't been removed!");
						return false;
					}
					if (basePlayer.StableIndex == -1)
					{
						Debug.LogError((object)"UsePlayerUpdateJobs: Player missing stable index!");
						return false;
					}
					num++;
				}
			}
			if (num != ((StableObjectCache<BasePlayer>)playerCache).Count)
			{
				Debug.LogError((object)$"UsePlayerUpdateJobs: Player count desync, tracking {((StableObjectCache<BasePlayer>)playerCache).Count} but found {num}!");
				return false;
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static bool ValidateTransformCache(PlayerCache playerCache)
	{
		return true;
	}

	public bool IsCraftingTutorialBlocked(ItemDefinition def, out bool forceUnlock)
	{
		forceUnlock = false;
		if (!IsInTutorial)
		{
			return false;
		}
		if (def.tutorialAllowance == TutorialItemAllowance.None)
		{
			return true;
		}
		bool num = CurrentTutorialAllowance >= def.tutorialAllowance;
		if (num && (Object)(object)def.Blueprint != (Object)null && !def.Blueprint.defaultBlueprint)
		{
			forceUnlock = true;
		}
		return !num;
	}

	public bool CanModifyCraftAmountDuringTutorial()
	{
		if (IsInTutorial)
		{
			return CurrentTutorialAllowance >= TutorialItemAllowance.Level4_Spear_Fire;
		}
		return false;
	}

	public TutorialIsland GetCurrentTutorialIsland()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (!IsInTutorial)
		{
			return null;
		}
		Enumerator<TutorialIsland> enumerator = TutorialIsland.GetTutorialList(base.isServer).GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				TutorialIsland current = enumerator.Current;
				if ((Object)(object)current.ForPlayer.Get(base.isServer) == (Object)(object)this)
				{
					return current;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return null;
	}

	public void ClearTutorial()
	{
		SetPlayerFlag(PlayerFlags.IsInTutorial, b: false);
		SleepingBag.ClearTutorialBagsForPlayer(userID);
	}

	public void ClearTutorial_PostDeath()
	{
		ClearAllPings();
		ClearDeathMarker();
		PrepareMissionsForTutorial();
		SendPingsToClient();
		SendMarkersToClient();
	}

	public void OnStartedTutorial()
	{
		ClearAllPings();
		PrepareMissionsForTutorial();
	}

	public void SetTutorialAllowance(TutorialItemAllowance newAllowance)
	{
		if (newAllowance >= CurrentTutorialAllowance)
		{
			CurrentTutorialAllowance = newAllowance;
			SendNetworkUpdate();
		}
	}

	[RPC_Server]
	private void StartTutorial(RPCMessage msg)
	{
		if (!((Object)(object)msg.player != (Object)(object)this))
		{
			StartTutorial(triggerAnalytics: true);
		}
	}

	public void StartTutorial(bool triggerAnalytics)
	{
		if (ConVar.Server.tutorialEnabled)
		{
			if (!TutorialIsland.HasAvailableTutorialIsland)
			{
				ShowToast(GameTip.Styles.Red_Normal, TutorialIsland.NoTutorialIslandsAvailablePhrase, false);
			}
			else if (startTutorialCooldown > Time.realtimeSinceStartup)
			{
				int num = Mathf.CeilToInt(startTutorialCooldown - Time.realtimeSinceStartup);
				ShowToast(GameTip.Styles.Red_Normal, TutorialIsland.TutorialIslandStartCooldown, false, num.ToString());
			}
			else
			{
				startTutorialCooldown = Time.realtimeSinceStartup + (float)Debugging.tutorial_start_cooldown;
				Hurt(99999f);
				Respawn();
				TutorialIsland.RestoreOrCreateIslandForPlayer(this, triggerAnalytics);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.CallsPerSecond(1uL)]
	private void PlayerRequestedTutorialStart(RPCMessage msg)
	{
		if (ConVar.Server.tutorialEnabled)
		{
			if (!TutorialIsland.HasAvailableTutorialIsland)
			{
				ShowToast(GameTip.Styles.Red_Normal, TutorialIsland.NoTutorialIslandsAvailablePhrase, false);
			}
			else
			{
				ClientRPC(RpcTarget.Player("PromptToStartTutorial", this));
			}
		}
	}

	public uint GetUnderwearSkin()
	{
		uint infoInt = (uint)GetInfoInt("client.underwearskin", 0);
		if (infoInt != lastValidUnderwearSkin && Time.time > nextUnderwearValidationTime)
		{
			UnderwearManifest underwearManifest = UnderwearManifest.Get();
			nextUnderwearValidationTime = Time.time + 0.2f;
			Underwear underwear = underwearManifest.GetUnderwear(infoInt);
			if ((Object)(object)underwear == (Object)null)
			{
				lastValidUnderwearSkin = 0u;
			}
			else if (Underwear.Validate(underwear, this))
			{
				lastValidUnderwearSkin = infoInt;
			}
		}
		return lastValidUnderwearSkin;
	}

	[RPC_Server]
	public void ServerRPC_UnderwearChange(RPCMessage msg)
	{
		if (!((Object)(object)msg.player != (Object)(object)this))
		{
			uint num = lastValidUnderwearSkin;
			uint underwearSkin = GetUnderwearSkin();
			if (num != underwearSkin)
			{
				SendNetworkUpdate();
			}
		}
	}

	public bool IsWounded()
	{
		return HasPlayerFlag(PlayerFlags.Wounded);
	}

	public bool IsCrawling()
	{
		if (HasPlayerFlag(PlayerFlags.Wounded))
		{
			return !HasPlayerFlag(PlayerFlags.Incapacitated);
		}
		return false;
	}

	public bool IsIncapacitated()
	{
		return HasPlayerFlag(PlayerFlags.Incapacitated);
	}

	public bool WoundInsteadOfDying(HitInfo info)
	{
		if (!EligibleForWounding(info))
		{
			return false;
		}
		BecomeWounded(info);
		return true;
	}

	public void ResetWoundingVars()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)WoundingTick);
		woundedDuration = 0f;
		lastWoundedStartTime = float.NegativeInfinity;
		healingWhileCrawling = 0f;
		woundedByFallDamage = false;
	}

	public virtual bool EligibleForWounding(HitInfo info)
	{
		object obj = Interface.CallHook("CanBeWounded", (object)this, (object)info);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!ConVar.Server.woundingenabled)
		{
			return false;
		}
		if (IsWounded())
		{
			return false;
		}
		if (IsSleeping())
		{
			return false;
		}
		if (isMounted)
		{
			return false;
		}
		if (info == null)
		{
			return false;
		}
		if (!IsWounded() && Time.realtimeSinceStartup - lastWoundedStartTime < ConVar.Server.rewounddelay)
		{
			return false;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (Object.op_Implicit((Object)(object)activeGameMode) && !activeGameMode.allowWounding)
		{
			return false;
		}
		if (triggers != null)
		{
			for (int i = 0; i < triggers.Count; i++)
			{
				if (triggers[i] is IHurtTrigger)
				{
					return false;
				}
			}
		}
		if (info.WeaponPrefab is BaseMelee)
		{
			return true;
		}
		if (info.WeaponPrefab is BaseProjectile)
		{
			return !info.isHeadshot;
		}
		return info.damageTypes.GetMajorityDamageType() switch
		{
			DamageType.Suicide => false, 
			DamageType.Fall => true, 
			DamageType.Bite => true, 
			DamageType.Bleeding => true, 
			DamageType.Hunger => true, 
			DamageType.Thirst => true, 
			DamageType.Poison => true, 
			_ => false, 
		};
	}

	public void BecomeWounded(HitInfo info)
	{
		if (IsWounded() || Interface.CallHook("OnPlayerWound", (object)this, (object)info) != null)
		{
			return;
		}
		bool flag = info != null && info.damageTypes.GetMajorityDamageType() == DamageType.Fall;
		if (IsCrawling())
		{
			woundedByFallDamage |= flag;
			GoToIncapacitated(info);
			return;
		}
		woundedByFallDamage = flag;
		if (flag || !ConVar.Server.crawlingenabled)
		{
			GoToIncapacitated(info);
		}
		else
		{
			GoToCrawling(info);
		}
	}

	public void StopWounded(BasePlayer source = null)
	{
		if (IsWounded())
		{
			RecoverFromWounded();
			((FacepunchBehaviour)this).CancelInvoke((Action)WoundingTick);
			EACServer.LogPlayerRevive(source, this);
			PlayerInjureState = GetInjureState();
		}
	}

	public void ProlongWounding(float delay)
	{
		if (!IsRestrained)
		{
			woundedDuration = Mathf.Max(woundedDuration, Mathf.Min(TimeSinceWoundedStarted + delay, woundedDuration + delay));
			SendWoundedInformation(woundedDuration);
		}
	}

	public void SendWoundedInformation(float timeLeft)
	{
		float recoveryChance = GetRecoveryChance();
		ClientRPC(RpcTarget.Player("CLIENT_GetWoundedInformation", this), recoveryChance, timeLeft, woundedDuration);
	}

	public float GetRecoveryChance()
	{
		float num = (IsIncapacitated() ? ConVar.Server.incapacitatedrecoverchance : ConVar.Server.woundedrecoverchance);
		float num2 = (metabolism.hydration.Fraction() + metabolism.calories.Fraction()) / 2f;
		float num3 = Mathf.Lerp(0f, ConVar.Server.woundedmaxfoodandwaterbonus, num2);
		float result = Mathf.Clamp01(num + num3);
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition("largemedkit");
		if (inventory.containerBelt.FindItemByItemID(itemDefinition.itemid) != null && !woundedByFallDamage)
		{
			return 1f;
		}
		return result;
	}

	public void WoundingTick()
	{
		TimeWarning val = TimeWarning.New("WoundingTick", 0);
		try
		{
			if (IsDead())
			{
				return;
			}
			if (!Player.woundforever && TimeSinceWoundedStarted >= woundedDuration)
			{
				float num = (IsIncapacitated() ? ConVar.Server.incapacitatedrecoverchance : ConVar.Server.woundedrecoverchance);
				float num2 = (metabolism.hydration.Fraction() + metabolism.calories.Fraction()) / 2f;
				float num3 = Mathf.Lerp(0f, ConVar.Server.woundedmaxfoodandwaterbonus, num2);
				float num4 = Mathf.Clamp01(num + num3);
				if (Random.value < num4)
				{
					RecoverFromWounded();
					return;
				}
				if (woundedByFallDamage)
				{
					Die();
					return;
				}
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition("largemedkit");
				Item item = inventory.containerBelt.FindItemByItemID(itemDefinition.itemid);
				if (item != null)
				{
					item.UseItem();
					RecoverFromWounded();
				}
				else
				{
					Die();
				}
			}
			else
			{
				if (IsSwimming() && IsCrawling())
				{
					GoToIncapacitated(null);
				}
				((FacepunchBehaviour)this).Invoke((Action)WoundingTick, 1f);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void GoToCrawling(HitInfo info)
	{
		base.health = Random.Range(ConVar.Server.crawlingminimumhealth, ConVar.Server.crawlingmaximumhealth);
		metabolism.bleeding.value = 0f;
		healingWhileCrawling = 0f;
		WoundedStartSharedCode(info);
		StartWoundedTick(40, 50);
		SendWoundedInformation(woundedDuration);
		SendNetworkUpdateImmediate();
		PlayerInjureState = GetInjureState();
	}

	public void GoToIncapacitated(HitInfo info)
	{
		if (!IsWounded())
		{
			WoundedStartSharedCode(info);
		}
		base.health = Random.Range(2f, 6f);
		metabolism.bleeding.value = 0f;
		healingWhileCrawling = 0f;
		SetPlayerFlag(PlayerFlags.Incapacitated, b: true);
		SetServerFall(wantsOn: true);
		StartWoundedTick(10, 25);
		SendWoundedInformation(woundedDuration);
		SendNetworkUpdateImmediate();
		PlayerInjureState = GetInjureState();
	}

	public void WoundedStartSharedCode(HitInfo info)
	{
		stats.Add("wounded", 1, (Stats)5);
		SetPlayerFlag(PlayerFlags.Wounded, b: true);
		if (Object.op_Implicit((Object)(object)BaseGameMode.GetActiveGameMode(base.isServer)))
		{
			BaseGameMode.GetActiveGameMode(base.isServer).OnPlayerWounded(info.InitiatorPlayer, this, info);
		}
		inventory.DropBackpackOnDeath(wounded: true);
	}

	public void StartWoundedTick(int minTime, int maxTime)
	{
		woundedDuration = Random.Range(minTime, maxTime + 1);
		ApplyWoundedStartTime();
		((FacepunchBehaviour)this).Invoke((Action)WoundingTick, 1f);
	}

	public void ApplyWoundedStartTime()
	{
		lastWoundedStartTime = Time.realtimeSinceStartup;
	}

	public void RecoverFromWounded()
	{
		if (Interface.CallHook("OnPlayerRecover", (object)this) == null)
		{
			if (IsCrawling())
			{
				base.health = Random.Range(2f, 6f) + healingWhileCrawling;
			}
			healingWhileCrawling = 0f;
			SetPlayerFlag(PlayerFlags.Wounded, b: false);
			SetPlayerFlag(PlayerFlags.Incapacitated, b: false);
			if (Object.op_Implicit((Object)(object)BaseGameMode.GetActiveGameMode(base.isServer)))
			{
				BaseGameMode.GetActiveGameMode(base.isServer).OnPlayerRevived(null, this);
			}
			Interface.CallHook("OnPlayerRecovered", (object)this);
		}
	}

	public bool WoundingCausingImmortality(HitInfo info)
	{
		if (!IsWounded())
		{
			return false;
		}
		if (TimeSinceWoundedStarted > 0.25f)
		{
			return false;
		}
		if (info != null && info.damageTypes.GetMajorityDamageType() == DamageType.Fall)
		{
			return false;
		}
		return true;
	}

	public InjureState GetInjureState()
	{
		if (IsDead())
		{
			return InjureState.Dead;
		}
		if (IsIncapacitated())
		{
			return InjureState.Incapacitated;
		}
		if (IsCrawling())
		{
			return InjureState.Crawling;
		}
		return InjureState.Normal;
	}

	public override BasePlayer ToPlayer()
	{
		return this;
	}

	public static string SanitizePlayerNameString(string playerName, ulong userId)
	{
		playerName = StringEx.EscapeRichText(StringEx.ToPrintable(playerName, 32), false).Trim();
		if (string.IsNullOrWhiteSpace(playerName))
		{
			playerName = userId.ToString();
		}
		return playerName;
	}

	public bool IsGod()
	{
		if (base.isServer && (IsAdmin || IsDeveloper) && IsConnected && net.connection != null && net.connection.info.GetBool("global.god", false))
		{
			return true;
		}
		return false;
	}

	public override Quaternion GetNetworkRotation()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			return Quaternion.Euler(viewAngles);
		}
		return Quaternion.identity;
	}

	public bool CanInteract()
	{
		return CanInteract(usableWhileCrawling: false);
	}

	public bool CanInteract(bool usableWhileCrawling)
	{
		bool flag = CurrentGestureIsSurrendering;
		if (!flag && IsRestrained)
		{
			Handcuffs restraintItem = Belt.GetRestraintItem();
			flag = (Object)(object)restraintItem != (Object)null && restraintItem.BlockUse;
		}
		if (!IsDead() && !IsSleeping() && !IsSpectating() && (usableWhileCrawling ? (!IsIncapacitated()) : (!IsWounded())) && !HasActiveTelephone)
		{
			return !flag;
		}
		return false;
	}

	public override float StartHealth()
	{
		return Random.Range(50f, 60f);
	}

	public override float StartMaxHealth()
	{
		return 100f;
	}

	public override float MaxHealth()
	{
		return _maxHealth * (1f + (((Object)(object)modifiers != (Object)null) ? modifiers.GetValue(Modifier.ModifierType.Max_Health) : 0f));
	}

	public override float MaxVelocity()
	{
		if (IsSleeping())
		{
			return 0f;
		}
		if (isMounted)
		{
			return GetMounted().MaxVelocity();
		}
		return GetMaxSpeed();
	}

	public override OBB WorldSpaceBounds()
	{
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (IsSleeping())
		{
			Vector3 center = ((Bounds)(ref bounds)).center;
			Vector3 size = ((Bounds)(ref bounds)).size;
			center.y /= 2f;
			size.y /= 2f;
			return new OBB(((Component)this).transform.position, ((Component)this).transform.lossyScale, ((Component)this).transform.rotation, new Bounds(center, size));
		}
		return base.WorldSpaceBounds();
	}

	public Vector3 GetMountVelocity()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		BaseMountable baseMountable = GetMounted();
		if (!((Object)(object)baseMountable != (Object)null))
		{
			return Vector3.zero;
		}
		return baseMountable.GetWorldVelocity();
	}

	public override Vector3 GetInheritedProjectileVelocity(Vector3 direction)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		BaseMountable baseMountable = GetMounted();
		if (!Object.op_Implicit((Object)(object)baseMountable))
		{
			return base.GetInheritedProjectileVelocity(direction);
		}
		return baseMountable.GetInheritedProjectileVelocity(direction);
	}

	public override Vector3 GetInheritedThrowVelocity(Vector3 direction)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		BaseMountable baseMountable = GetMounted();
		if (!Object.op_Implicit((Object)(object)baseMountable))
		{
			return base.GetInheritedThrowVelocity(direction);
		}
		return baseMountable.GetInheritedThrowVelocity(direction);
	}

	public override Vector3 GetInheritedDropVelocity()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		BaseMountable baseMountable = GetMounted();
		if (!Object.op_Implicit((Object)(object)baseMountable))
		{
			return base.GetInheritedDropVelocity();
		}
		return baseMountable.GetInheritedDropVelocity();
	}

	public override void PreInitShared()
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		base.PreInitShared();
		cachedProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
		baseProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
		inventoryValue.Set(((Component)this).GetComponent<PlayerInventory>());
		blueprints = ((Component)this).GetComponent<PlayerBlueprints>();
		metabolism = ((Component)this).GetComponent<PlayerMetabolism>();
		modifiers = ((Component)this).GetComponent<PlayerModifiers>();
		colliderValue.Set(((Component)this).GetComponent<CapsuleCollider>());
		eyesValue.Set(((Component)this).GetComponent<PlayerEyes>());
		playerColliderStanding = new CapsuleColliderInfo(playerCollider.height, playerCollider.radius, playerCollider.center);
		playerColliderDucked = new CapsuleColliderInfo(1.5f, playerCollider.radius, Vector3.up * 0.75f);
		playerColliderCrawling = new CapsuleColliderInfo(playerCollider.radius, playerCollider.radius, Vector3.up * playerCollider.radius);
		playerColliderLyingDown = new CapsuleColliderInfo(0.4f, playerCollider.radius, Vector3.up * 0.2f);
		Belt = new PlayerBelt(this);
	}

	public override void DestroyShared()
	{
		Object.Destroy((Object)(object)cachedProtection);
		Object.Destroy((Object)(object)baseProtection);
		base.DestroyShared();
	}

	public override void ResetState()
	{
		base.ResetState();
		if (eyesValue != null)
		{
			eyesValue.Dispose();
			eyesValue = null;
		}
		if (inventoryValue != null)
		{
			inventoryValue.Dispose();
			inventoryValue = null;
		}
		if (colliderValue != null)
		{
			colliderValue.Dispose();
			colliderValue = null;
		}
	}

	public override bool InSafeZone()
	{
		if (base.isServer)
		{
			return base.InSafeZone();
		}
		return false;
	}

	public bool IsInNoRespawnZone()
	{
		if (base.isServer)
		{
			return InNoRespawnZone();
		}
		return false;
	}

	public bool IsOnATugboat()
	{
		if (GetMountedVehicle() is Tugboat)
		{
			return true;
		}
		if (GetParentEntity() is Tugboat)
		{
			return true;
		}
		return false;
	}

	public static void ServerCycle(float deltaTime)
	{
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		bool flag = ConVar.Server.UsePlayerUpdateJobs;
		for (int i = 0; i < activePlayerList.Values.Count; i++)
		{
			BasePlayer basePlayer = activePlayerList[i];
			if ((Object)(object)basePlayer == (Object)null)
			{
				activePlayerList.RemoveAt(i--);
				if (flag && basePlayer.StableIndex != -1)
				{
					((StableObjectCache<BasePlayer>)playerCache).Remove(basePlayer);
				}
			}
		}
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		if (flag)
		{
			TickCache.Expand(activePlayerList.Count);
		}
		for (int j = 0; j < activePlayerList.Count; j++)
		{
			BasePlayer basePlayer2 = activePlayerList[j];
			list.Add(basePlayer2);
			if (flag && basePlayer2.StableIndex == -1)
			{
				((StableObjectCache<BasePlayer>)playerCache).Add(basePlayer2);
				TickCache.Reset(basePlayer2, basePlayer2.tickInterpolator.StartPoint);
			}
		}
		if (flag)
		{
			TimeWarning val = TimeWarning.New("ServerUpdateParallel", 0);
			try
			{
				if (ConVar.Server.EmergencyDisablePlayerJobs && activePlayerList.Count != ((StableObjectCache<BasePlayer>)playerCache).Count)
				{
					Debug.LogError((object)"UsePlayerUpdateJobs: desync in player counts between activePlayerList and PlayerCache");
					flag = false;
					ConVar.Server.UsePlayerUpdateJobs = false;
				}
				if (!ServerUpdateParallel(deltaTime, playerCache))
				{
					flag = false;
					ConVar.Server.UsePlayerUpdateJobs = false;
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		if (!flag && ((StableObjectCache<BasePlayer>)playerCache).Count > 0)
		{
			((StableObjectCache<BasePlayer>)playerCache).Clear();
		}
		if (!flag)
		{
			for (int k = 0; k < list.Count; k++)
			{
				if (!((Object)(object)list[k] == (Object)null))
				{
					list[k].ServerUpdate(deltaTime);
				}
			}
		}
		for (int l = 0; l < bots.Count; l++)
		{
			bots[l].ServerUpdateBots(deltaTime);
		}
		if (ConVar.Server.idlekick > 0 && ((SingletonComponent<ServerMgr>.Instance.AvailableSlots <= 0 && ConVar.Server.idlekickmode == 1) || ConVar.Server.idlekickmode == 2))
		{
			for (int m = 0; m < list.Count; m++)
			{
				if (!(list[m].IdleTime < (float)(ConVar.Server.idlekick * 60)) && (!list[m].IsAdmin || ConVar.Server.idlekickadmins != 0) && (!list[m].IsDeveloper || ConVar.Server.idlekickadmins != 0))
				{
					list[m].Kick("Idle for " + ConVar.Server.idlekick + " minutes");
				}
			}
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	private bool ManuallyCheckSafezone()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isServer)
		{
			return false;
		}
		List<Collider> list = Pool.Get<List<Collider>>();
		Vis.Colliders<Collider>(((Component)this).transform.position, 0f, list, -1, (QueryTriggerInteraction)2);
		foreach (Collider item in list)
		{
			if ((Object)(object)((Component)item).GetComponent<TriggerSafeZone>() != (Object)null)
			{
				Pool.FreeUnmanaged<Collider>(ref list);
				return true;
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return false;
	}

	public override bool OnStartBeingLooted(BasePlayer baseEntity)
	{
		if ((baseEntity.InSafeZone() || InSafeZone() || ManuallyCheckSafezone()) && (ulong)baseEntity.userID != (ulong)userID)
		{
			return false;
		}
		if ((Object)(object)RelationshipManager.ServerInstance != (Object)null)
		{
			if ((IsSleeping() || IsIncapacitated()) && !RelationshipManager.ServerInstance.HasRelations(baseEntity.userID, userID))
			{
				RelationshipManager.ServerInstance.SetRelationship(baseEntity, this, RelationshipManager.RelationshipType.Acquaintance);
			}
			RelationshipManager.ServerInstance.SetSeen(baseEntity, this);
		}
		if (IsCrawling())
		{
			GoToIncapacitated(null);
		}
		if ((Object)(object)inventory.crafting != (Object)null)
		{
			inventory.crafting.CancelAll();
		}
		return base.OnStartBeingLooted(baseEntity);
	}

	public Bounds GetBounds(bool ducked)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		return new Bounds(((Component)this).transform.position + GetOffset(ducked), GetSize(ducked));
	}

	public Bounds GetBounds()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return GetBounds(modelState.ducked);
	}

	public Vector3 GetCenter(bool ducked)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position + GetOffset(ducked);
	}

	public Vector3 GetOcclusionOffset()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position + PlayerEyes.EyeOffset;
	}

	public Vector3 GetCenter()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return GetCenter(modelState.ducked);
	}

	public static Vector3 GetOffset(bool ducked)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (ducked)
		{
			return new Vector3(0f, 0.55f, 0f);
		}
		return new Vector3(0f, 0.9f, 0f);
	}

	public Vector3 GetOffset()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return GetOffset(modelState.ducked);
	}

	public static Vector3 GetSize(bool ducked)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (ducked)
		{
			return new Vector3(1f, 1.1f, 1f);
		}
		return new Vector3(1f, 1.8f, 1f);
	}

	public Vector3 GetSize()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return GetSize(modelState.ducked);
	}

	public static float GetHeight(bool ducked)
	{
		if (ducked)
		{
			return 1.1f;
		}
		return 1.8f;
	}

	public float GetHeight()
	{
		return GetHeight(modelState.ducked);
	}

	public static float GetRadius()
	{
		return 0.5f;
	}

	public static float GetJumpHeight()
	{
		return 1.5f;
	}

	public override Vector3 TriggerPoint()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position + NoClipOffset();
	}

	public static Vector3 NoClipOffset()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(0f, GetHeight(ducked: true) - GetRadius(), 0f);
	}

	public static float NoClipRadius(float margin)
	{
		return GetRadius() - margin;
	}

	public float MaxDeployDistance(Item item)
	{
		return 8f;
	}

	public float GetMinSpeed()
	{
		return GetSpeed(0f, 0f, 1f);
	}

	public float GetMaxSpeed()
	{
		return GetSpeed(1f, 0f, 0f);
	}

	public float GetSpeed(float running, float ducking, float crawling)
	{
		return GetSpeed(running, ducking, crawling, IsSwimming());
	}

	internal float GetSpeed(float running, float ducking, float crawling, bool isSwimming)
	{
		float num = 1f;
		num -= clothingMoveSpeedReduction;
		if (isSwimming)
		{
			num += clothingWaterSpeedBonus;
		}
		if (crawling > 0f)
		{
			return Mathf.Lerp(2.8f, 0.72f, crawling) * num * GetModifiersMovementMultiplier();
		}
		return Mathf.Lerp(Mathf.Lerp(2.8f, 5.5f, running), 1.7f, ducking) * num * weaponMoveSpeedScale * GetModifiersMovementMultiplier();
	}

	private float GetModifiersMovementMultiplier()
	{
		float num = (((Object)(object)modifiers != (Object)null) ? modifiers.GetValue(Modifier.ModifierType.MoveSpeed) : 0f);
		return 1f + num;
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("IOnBasePlayerAttacked", (object)this, (object)info) != null)
		{
			return;
		}
		float oldHealth = base.health;
		if (InSafeZone() && !IsHostile() && (Object)(object)info.Initiator != (Object)null && (Object)(object)info.Initiator != (Object)(object)this)
		{
			info.damageTypes.ScaleAll(0f);
		}
		if (base.isServer)
		{
			HitArea boneArea = info.boneArea;
			if (boneArea != (HitArea)(-1))
			{
				List<Item> list = Pool.Get<List<Item>>();
				list.AddRange(inventory.containerWear.itemList);
				for (int i = 0; i < list.Count; i++)
				{
					Item item = list[i];
					if (item != null)
					{
						ItemModWearable component = ((Component)item.info).GetComponent<ItemModWearable>();
						if (!((Object)(object)component == (Object)null) && component.ProtectsArea(boneArea))
						{
							item.OnAttacked(info);
						}
					}
				}
				Pool.Free<Item>(ref list, false);
				inventory.ServerUpdate(0f);
			}
		}
		base.OnAttacked(info);
		if (base.isServer && base.isServer && info.hasDamage)
		{
			if (!info.damageTypes.Has(DamageType.Bleeding) && info.damageTypes.IsBleedCausing() && !IsWounded() && !IsImmortalTo(info) && !info.damageTypes.Has(DamageType.BeeSting))
			{
				float num = (((Object)(object)modifiers != (Object)null) ? Mathf.Clamp01(1f - modifiers.GetValue(Modifier.ModifierType.Clotting)) : 1f);
				metabolism.bleeding.Add(info.damageTypes.Total() * 0.2f * num);
			}
			if (isMounted)
			{
				GetMounted().MounteeTookDamage(this, info);
			}
			CheckDeathCondition(info);
			if (net != null && net.connection != null)
			{
				ClientRPC(RpcTarget.Player("TakeDamageHit", this));
			}
			string text = StringPool.Get(info.HitBone);
			Vector3 val = info.PointEnd - info.PointStart;
			bool flag = Vector3.Dot(((Vector3)(ref val)).normalized, eyes.BodyForward()) > 0.4f;
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if (Object.op_Implicit((Object)(object)initiatorPlayer) && !info.damageTypes.IsMeleeType())
			{
				initiatorPlayer.LifeStoryShotHit(info.Weapon);
			}
			if (info.isHeadshot)
			{
				if (flag)
				{
					SignalBroadcast(Signal.Flinch_RearHead, string.Empty);
				}
				else
				{
					SignalBroadcast(Signal.Flinch_Head, string.Empty);
				}
				if (!Object.op_Implicit((Object)(object)initiatorPlayer) || !initiatorPlayer.limitNetworking)
				{
					Effect.server.Run("assets/bundled/prefabs/fx/headshot.prefab", this, 0u, new Vector3(0f, 2f, 0f), Vector3.zero, ((Object)(object)initiatorPlayer != (Object)null) ? initiatorPlayer.net.connection : null);
				}
				if (Object.op_Implicit((Object)(object)initiatorPlayer))
				{
					initiatorPlayer.stats.Add("headshot", 1, (Stats)5);
					if (initiatorPlayer.IsBeingSpectated)
					{
						foreach (BaseEntity child in initiatorPlayer.children)
						{
							if (child is BasePlayer basePlayer)
							{
								basePlayer.ClientRPC(RpcTarget.Player("SpectatedPlayerHeadshot", basePlayer));
							}
						}
					}
				}
			}
			else if (flag)
			{
				SignalBroadcast(Signal.Flinch_RearTorso, string.Empty);
			}
			else if (text == "spine" || text == "spine2")
			{
				SignalBroadcast(Signal.Flinch_Stomach, string.Empty);
			}
			else
			{
				SignalBroadcast(Signal.Flinch_Chest, string.Empty);
			}
		}
		if (stats != null)
		{
			if (IsWounded())
			{
				stats.combat.LogAttack(info, "wounded", oldHealth);
			}
			else if (IsDead())
			{
				stats.combat.LogAttack(info, "killed", oldHealth);
			}
			else
			{
				stats.combat.LogAttack(info, "", oldHealth);
			}
		}
		if (Global.cinematicGingerbreadCorpses)
		{
			info.HitMaterial = Global.GingerbreadMaterialID();
		}
	}

	public void EnablePlayerCollider()
	{
		if (!((Collider)playerCollider).enabled && Interface.CallHook("OnPlayerColliderEnable", (object)this, (object)playerCollider) == null)
		{
			RefreshColliderSize(forced: true);
			((Collider)playerCollider).enabled = true;
		}
	}

	public void DisablePlayerCollider()
	{
		if (((Collider)playerCollider).enabled)
		{
			RemoveFromTriggers();
			((Collider)playerCollider).enabled = false;
		}
	}

	public void RefreshColliderSize(bool forced)
	{
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		if (forced || (((Collider)playerCollider).enabled && !(Time.time < nextColliderRefreshTime)))
		{
			nextColliderRefreshTime = Time.time + 0.25f + Random.Range(-0.05f, 0.05f);
			BaseMountable baseMountable = GetMounted();
			CapsuleColliderInfo capsuleColliderInfo = (((Object)(object)baseMountable != (Object)null && baseMountable.IsValid()) ? ((!baseMountable.modifiesPlayerCollider) ? playerColliderStanding : baseMountable.customPlayerCollider) : ((!IsIncapacitated() && !IsSleeping()) ? (IsCrawling() ? playerColliderCrawling : ((!modelState.ducked && !IsSwimming()) ? playerColliderStanding : playerColliderDucked)) : playerColliderLyingDown));
			if (playerCollider.height != capsuleColliderInfo.height || playerCollider.radius != capsuleColliderInfo.radius || playerCollider.center != capsuleColliderInfo.center)
			{
				playerCollider.height = capsuleColliderInfo.height;
				playerCollider.radius = capsuleColliderInfo.radius;
				playerCollider.center = capsuleColliderInfo.center;
			}
		}
	}

	private void SetPlayerRigidbodyState(bool isEnabled)
	{
		if (isEnabled)
		{
			AddPlayerRigidbody();
		}
		else
		{
			RemovePlayerRigidbody();
		}
	}

	public void AddPlayerRigidbody()
	{
		if ((Object)(object)playerRigidbody == (Object)null)
		{
			playerRigidbody = ((Component)this).gameObject.GetComponent<Rigidbody>();
		}
		if ((Object)(object)playerRigidbody == (Object)null)
		{
			playerRigidbody = ((Component)this).gameObject.AddComponent<Rigidbody>();
			playerRigidbody.useGravity = false;
			playerRigidbody.isKinematic = true;
			playerRigidbody.mass = 1f;
			playerRigidbody.interpolation = (RigidbodyInterpolation)0;
			playerRigidbody.collisionDetectionMode = (CollisionDetectionMode)0;
		}
	}

	public void RemovePlayerRigidbody()
	{
		if ((Object)(object)playerRigidbody == (Object)null)
		{
			playerRigidbody = ((Component)this).gameObject.GetComponent<Rigidbody>();
		}
		if ((Object)(object)playerRigidbody != (Object)null)
		{
			RemoveFromTriggers();
			Object.DestroyImmediate((Object)(object)playerRigidbody);
			playerRigidbody = null;
		}
	}

	public bool IsEnsnared()
	{
		if (triggers == null)
		{
			return false;
		}
		for (int i = 0; i < triggers.Count; i++)
		{
			if (triggers[i] is TriggerEnsnare)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsAttacking()
	{
		HeldEntity heldEntity = GetHeldEntity();
		if ((Object)(object)heldEntity == (Object)null)
		{
			return false;
		}
		AttackEntity attackEntity = heldEntity as AttackEntity;
		if ((Object)(object)attackEntity == (Object)null)
		{
			return false;
		}
		return attackEntity.NextAttackTime - Time.time > attackEntity.repeatDelay - 1f;
	}

	public bool CanAttack()
	{
		HeldEntity heldEntity = GetHeldEntity();
		if ((Object)(object)heldEntity == (Object)null)
		{
			return false;
		}
		bool flag = IsSwimming();
		bool flag2 = heldEntity.CanBeUsedInWater();
		if (modelState.onLadder)
		{
			return false;
		}
		if (modelState.blocking)
		{
			return false;
		}
		if (!flag && !modelState.onground)
		{
			return false;
		}
		if (flag && !flag2)
		{
			return false;
		}
		if (IsEnsnared())
		{
			return false;
		}
		return true;
	}

	public bool OnLadder()
	{
		if (modelState.onLadder && !IsWounded())
		{
			return Object.op_Implicit((Object)(object)FindTrigger<TriggerLadder>());
		}
		return false;
	}

	public bool IsSwimming()
	{
		return IsSwimming(WaterFactor());
	}

	public static bool IsSwimming(float waterFactor)
	{
		return waterFactor >= 0.65f;
	}

	public bool IsHeadUnderwater()
	{
		return WaterFactor() > 0.75f;
	}

	public virtual bool IsOnGround()
	{
		return modelState.onground;
	}

	public bool IsRunning()
	{
		if (modelState != null)
		{
			return modelState.sprinting;
		}
		return false;
	}

	public bool IsDucked()
	{
		if (modelState != null)
		{
			return modelState.ducking > 0.5f;
		}
		return false;
	}

	public void ShowToast(GameTip.Styles style, Phrase phrase, bool overlay = false, params string[] arguments)
	{
		if (base.isServer)
		{
			SendConsoleCommand("gametip.showtoast_translated", (int)style, phrase.token, phrase.english, overlay, arguments);
		}
	}

	public void ShowBlockedByEntityToast(BaseEntity ent, Phrase fallbackError = null)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)ent == (Object)null))
		{
			ClientRPC(RpcTarget.Player("CLIENT_ShowBlockedByToast", this), ent.net.ID, fallbackError.token, fallbackError.english);
		}
	}

	public void ChatMessage(string msg)
	{
		if (base.isServer && Interface.CallHook("OnMessagePlayer", (object)msg, (object)this) == null)
		{
			SendConsoleCommand("chat.add", 2, 0, msg);
		}
	}

	public void ConsoleMessage(string msg)
	{
		if (base.isServer)
		{
			SendConsoleCommand("echo " + msg);
		}
	}

	public override float PenetrationResistance(HitInfo info)
	{
		return 100f;
	}

	public override void ScaleDamage(HitInfo info)
	{
		if (isMounted)
		{
			GetMounted().ScaleDamageForPlayer(this, info);
		}
		if (info.UseProtection)
		{
			HitArea boneArea = info.boneArea;
			if (boneArea != (HitArea)(-1))
			{
				cachedProtection.Clear();
				cachedProtection.Add(inventory.containerWear.itemList, boneArea);
				cachedProtection.Multiply(DamageType.Arrow, ConVar.Server.arrowarmor);
				cachedProtection.Multiply(DamageType.Bullet, ConVar.Server.bulletarmor);
				cachedProtection.Multiply(DamageType.Slash, ConVar.Server.meleearmor);
				cachedProtection.Multiply(DamageType.Blunt, ConVar.Server.meleearmor);
				cachedProtection.Multiply(DamageType.Stab, ConVar.Server.meleearmor);
				cachedProtection.Multiply(DamageType.Bleeding, ConVar.Server.bleedingarmor);
				cachedProtection.Scale(info.damageTypes);
			}
			else
			{
				baseProtection.Scale(info.damageTypes);
			}
		}
		if (Object.op_Implicit((Object)(object)info.damageProperties))
		{
			info.damageProperties.ScaleDamage(info);
		}
		if (!IsNpc && (Object)(object)info.InitiatorPlayer != (Object)null && !info.InitiatorPlayer.IsNpc)
		{
			info.damageTypes.Scale(DamageType.Bullet, ConVar.Server.pvpBulletDamageMultiplier);
		}
		if (IsNpc && (Object)(object)info.InitiatorPlayer != (Object)null && !info.InitiatorPlayer.IsNpc)
		{
			info.damageTypes.Total();
			info.damageTypes.Scale(DamageType.Bullet, ConVar.Server.pveBulletDamageMultiplier);
		}
	}

	public void ResetWeaponMoveSpeedScale()
	{
		weaponMoveSpeedScale = 1f;
	}

	private void UpdateMoveSpeedFromClothing()
	{
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		float num2 = 0f;
		float num3 = 0f;
		bool flag = false;
		bool flag2 = false;
		float num4 = 0f;
		eggVision = 0f;
		base.Weight = 0f;
		ItemModContainerArmorSlot itemModContainerArmorSlot = default(ItemModContainerArmorSlot);
		foreach (Item item in inventory.containerWear.itemList)
		{
			ItemModWearable component = ((Component)item.info).GetComponent<ItemModWearable>();
			if (Object.op_Implicit((Object)(object)component))
			{
				if (component.blocksAiming)
				{
					flag = true;
				}
				if (component.blocksEquipping)
				{
					flag2 = true;
				}
				num4 += component.accuracyBonus;
				eggVision += component.eggVision;
				base.Weight += component.weight;
				float num5 = 0f;
				float num6 = 0f;
				if (((Component)item.info).TryGetComponent<ItemModContainerArmorSlot>(ref itemModContainerArmorSlot))
				{
					num6 = itemModContainerArmorSlot.TotalSpeedReduction(item);
				}
				if ((Object)(object)component.movementProperties != (Object)null)
				{
					num5 = component.movementProperties.speedReduction;
					num3 += component.movementProperties.waterSpeedBonus;
				}
				float num7 = num5 + num6;
				num = Mathf.Max(num, num7);
				num2 += num7;
			}
		}
		clothingAccuracyBonus = num4;
		clothingMoveSpeedReduction = Mathf.Max(num2, num);
		clothingBlocksAiming = flag;
		clothingWaterSpeedBonus = num3;
		equippingBlocked = flag2;
		if (base.isServer && equippingBlocked)
		{
			UpdateActiveItem(default(ItemId));
		}
		if (base.isServer && isMounted)
		{
			BaseVehicle mountedVehicle = GetMountedVehicle();
			if ((Object)(object)mountedVehicle != (Object)null)
			{
				mountedVehicle.OnMountedPlayerWeightChanged(this);
			}
		}
	}

	public virtual void UpdateProtectionFromClothing()
	{
		baseProtection.Clear();
		baseProtection.Add(inventory.containerWear.itemList);
		float num = 1f / 6f;
		for (int i = 0; i < baseProtection.amounts.Length; i++)
		{
			switch (i)
			{
			case 22:
				baseProtection.amounts[i] = 1f;
				break;
			default:
				baseProtection.amounts[i] *= num;
				break;
			case 17:
			case 25:
				break;
			}
		}
		float num2 = baseProtection.amounts[17];
		baseProtection.amounts[17] = Mathf.Clamp(num2, -1f, Radiation.MaxExposureProtection);
		if (!IsNpc)
		{
			baseProtection.amounts[16] = Mathf.Clamp(baseProtection.amounts[16], 0f, ConVar.Server.max_explosive_protection);
		}
	}

	public override string Categorize()
	{
		return "player";
	}

	public override string ToString()
	{
		if (_name == null)
		{
			if (base.isServer)
			{
				_name = $"{displayName}[{userID.Get()}]";
			}
			else
			{
				_name = base.ShortPrefabName;
			}
		}
		return _name;
	}

	public string GetDebugStatus()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendFormat("Entity: {0}\n", ((object)this).ToString());
		stringBuilder.AppendFormat("Name: {0}\n", displayName);
		stringBuilder.AppendFormat("SteamID: {0}\n", userID.Get());
		foreach (PlayerFlags value in Enum.GetValues(typeof(PlayerFlags)))
		{
			stringBuilder.AppendFormat("{1}: {0}\n", HasPlayerFlag(value), value);
		}
		return stringBuilder.ToString();
	}

	public override Item GetItem(ItemId itemId)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)inventory == (Object)null)
		{
			return null;
		}
		return inventory.FindItemByUID(itemId);
	}

	public override float WaterFactor()
	{
		WaterLevel.WaterInfo info;
		return WaterFactor(out info);
	}

	public float WaterFactor(out WaterLevel.WaterInfo info)
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		if (GetMounted().IsValid())
		{
			return GetMounted().WaterFactorForPlayer(this, out info);
		}
		if ((Object)(object)GetParentEntity() != (Object)null && GetParentEntity().BlocksWaterFor(this))
		{
			info = default(WaterLevel.WaterInfo);
			return 0f;
		}
		float radius = playerCollider.radius;
		float num = playerCollider.height * 0.5f;
		Vector3 start = ((Component)playerCollider).transform.position + ((Component)playerCollider).transform.rotation * (playerCollider.center - Vector3.up * (num - radius));
		Vector3 end = ((Component)playerCollider).transform.position + ((Component)playerCollider).transform.rotation * (playerCollider.center + Vector3.up * (num - radius));
		info = WaterLevel.GetWaterInfo(start, end, radius, waves: true, volumes: true, this);
		return WaterLevel.Factor(in info, start, end, radius);
	}

	public static void InitializeWaterFactorsCache(int initCap)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		DisposeWaterFactorsCache();
		Starts = new NativeArray<Vector3>(initCap, (Allocator)4, (NativeArrayOptions)0);
		Ends = new NativeArray<Vector3>(initCap, (Allocator)4, (NativeArrayOptions)0);
		Radii = new NativeArray<float>(initCap, (Allocator)4, (NativeArrayOptions)0);
		WaterQueryIndices = new NativeArray<int>(initCap, (Allocator)4, (NativeArrayOptions)0);
	}

	public static void DisposeWaterFactorsCache()
	{
		Starts.SafeDispose<Vector3>();
		Ends.SafeDispose<Vector3>();
		NativeArrayEx.SafeDispose(ref Radii);
		NativeArrayEx.SafeDispose(ref WaterQueryIndices);
	}

	public unsafe static void GetWaterFactors(PlayerCache playerCache, ReadOnly<Vector3> localPos, ReadOnly<Quaternion> localRots, ReadOnly<int> indices, NativeArray<WaterLevel.WaterInfo> infos, NativeArray<float> factors)
	{
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetWaterFactors", 0);
		try
		{
			ReadOnlySpan<BasePlayer> players = playerCache.Players;
			NativeArrayEx.Expand(ref WaterQueryIndices, indices.Length, (NativeArrayOptions)0, copyContents: false);
			int num = 0;
			for (int i = 0; i < indices.Length; i++)
			{
				int num2 = indices[i];
				BasePlayer basePlayer = players[num2];
				BaseMountable baseMountable = basePlayer.GetMounted();
				if (baseMountable.IsValid())
				{
					factors[num2] = baseMountable.WaterFactorForPlayer(basePlayer, out var info);
					infos[num2] = info;
				}
				else if ((Object)(object)basePlayer.GetParentEntity() != (Object)null && basePlayer.GetParentEntity().BlocksWaterFor(basePlayer))
				{
					UnsafeUtility.ArrayElementAsRef<WaterLevel.WaterInfo>(NativeArrayUnsafeUtility.GetUnsafePtr<WaterLevel.WaterInfo>(infos), num2).isValid = false;
					factors[num2] = 0f;
				}
				else
				{
					WaterQueryIndices[num++] = num2;
				}
			}
			if (num > 0)
			{
				Starts.Expand<Vector3>(players.Length, (NativeArrayOptions)0, copyContents: false, usePowerOfTwo: false);
				Ends.Expand<Vector3>(players.Length, (NativeArrayOptions)0, copyContents: false, usePowerOfTwo: false);
				NativeArrayEx.Expand(ref Radii, players.Length, (NativeArrayOptions)0, copyContents: false);
				ReadOnly<int> indices2 = WaterQueryIndices.GetSubArray(0, num).AsReadOnly();
				for (int j = 0; j < indices2.Length; j++)
				{
					int num3 = indices2[j];
					CapsuleCollider val2 = players[num3].playerCollider;
					Starts[num3] = val2.center;
					Ends[num3] = Vector2.op_Implicit(new Vector2(val2.radius, val2.height));
				}
				GetWaterFactorsParamsJobIndirect getWaterFactorsParamsJobIndirect = default(GetWaterFactorsParamsJobIndirect);
				getWaterFactorsParamsJobIndirect.Starts = Starts;
				getWaterFactorsParamsJobIndirect.Ends = Ends;
				getWaterFactorsParamsJobIndirect.Radii = Radii;
				getWaterFactorsParamsJobIndirect.Pos = localPos;
				getWaterFactorsParamsJobIndirect.Rots = localRots;
				getWaterFactorsParamsJobIndirect.Indices = indices2;
				GetWaterFactorsParamsJobIndirect getWaterFactorsParamsJobIndirect2 = getWaterFactorsParamsJobIndirect;
				IJobExtensions.RunByRef<GetWaterFactorsParamsJobIndirect>(ref getWaterFactorsParamsJobIndirect2);
				WaterLevel.GetWaterInfos(Starts.AsReadOnly(), Ends.AsReadOnly(), Radii.AsReadOnly(), playerCache.AsEntities, indices2, waves: true, volumes: true, infos);
				CalcWaterFactorsJobIndirect calcWaterFactorsJobIndirect = default(CalcWaterFactorsJobIndirect);
				calcWaterFactorsJobIndirect.Factors = factors;
				calcWaterFactorsJobIndirect.Indices = indices2;
				calcWaterFactorsJobIndirect.Infos = infos.AsReadOnly();
				calcWaterFactorsJobIndirect.Starts = Starts.AsReadOnly();
				calcWaterFactorsJobIndirect.Ends = Ends.AsReadOnly();
				calcWaterFactorsJobIndirect.Radii = Radii.AsReadOnly();
				CalcWaterFactorsJobIndirect calcWaterFactorsJobIndirect2 = calcWaterFactorsJobIndirect;
				IJobExtensions.RunByRef<CalcWaterFactorsJobIndirect>(ref calcWaterFactorsJobIndirect2);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override float AirFactor()
	{
		float num = ((WaterFactor() >= 1f) ? 0f : 1f);
		BaseMountable baseMountable = GetMounted();
		if (baseMountable.IsValid() && baseMountable.BlocksWaterFor(this))
		{
			float num2 = baseMountable.AirFactor();
			if (num2 < num)
			{
				num = num2;
			}
		}
		return num;
	}

	public float GetOxygenTime(out ItemModGiveOxygen.AirSupplyType airSupplyType)
	{
		BaseVehicle mountedVehicle = GetMountedVehicle();
		if (mountedVehicle.IsValid() && mountedVehicle is IAirSupply airSupply)
		{
			float airTimeRemaining = airSupply.GetAirTimeRemaining(null);
			if (airTimeRemaining > 0f)
			{
				airSupplyType = airSupply.AirType;
				return airTimeRemaining;
			}
		}
		foreach (Item item in inventory.containerWear.itemList)
		{
			IAirSupply componentInChildren = ((Component)item.info).GetComponentInChildren<IAirSupply>();
			if (componentInChildren != null)
			{
				float airTimeRemaining2 = componentInChildren.GetAirTimeRemaining(item);
				if (airTimeRemaining2 > 0f)
				{
					airSupplyType = componentInChildren.AirType;
					return airTimeRemaining2;
				}
			}
		}
		airSupplyType = ItemModGiveOxygen.AirSupplyType.Lungs;
		if (metabolism.oxygen.value > 0.5f)
		{
			float num = Mathf.InverseLerp(0.5f, 1f, metabolism.oxygen.value);
			return 5f * num;
		}
		return 0f;
	}

	public override bool ShouldInheritNetworkGroup()
	{
		return IsSpectating();
	}

	public static bool AnyPlayersVisibleToEntity(Vector3 pos, float radius, BaseEntity source, Vector3 entityEyePos, bool ignorePlayersWithPriv = false)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		List<BasePlayer> list2 = Pool.Get<List<BasePlayer>>();
		Vis.Entities(pos, radius, list2, 131072, (QueryTriggerInteraction)2);
		bool flag = false;
		foreach (BasePlayer item in list2)
		{
			if (item.IsSleeping() || !item.IsAlive() || (item.IsBuildingAuthed() && ignorePlayersWithPriv))
			{
				continue;
			}
			list.Clear();
			Vector3 position = item.eyes.position;
			Vector3 val = entityEyePos - item.eyes.position;
			GamePhysics.TraceAll(new Ray(position, ((Vector3)(ref val)).normalized), 0f, list, 9f, 1218519297, (QueryTriggerInteraction)0);
			for (int i = 0; i < list.Count; i++)
			{
				BaseEntity entity = list[i].GetEntity();
				if ((Object)(object)entity != (Object)null && ((Object)(object)entity == (Object)(object)source || entity.EqualNetID((BaseNetworkable)source)))
				{
					flag = true;
					break;
				}
				if (!((Object)(object)entity != (Object)null) || entity.ShouldBlockProjectiles())
				{
					break;
				}
			}
			if (flag)
			{
				break;
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		Pool.FreeUnmanaged<BasePlayer>(ref list2);
		return flag;
	}

	public bool IsStandingOnEntity(BaseEntity standingOn, int layerMask)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		if (!IsOnGround())
		{
			return false;
		}
		RaycastHit hit = default(RaycastHit);
		if (Physics.SphereCast(((Component)this).transform.position + Vector3.up * (0.25f + GetRadius()), GetRadius() * 0.95f, Vector3.down, ref hit, 4f, layerMask))
		{
			BaseEntity entity = hit.GetEntity();
			if ((Object)(object)entity != (Object)null)
			{
				if (entity.EqualNetID((BaseNetworkable)standingOn))
				{
					return true;
				}
				BaseEntity baseEntity = entity.GetParentEntity();
				if ((Object)(object)baseEntity != (Object)null && baseEntity.EqualNetID((BaseNetworkable)standingOn))
				{
					return true;
				}
			}
		}
		return false;
	}

	public void SetActiveTelephone(PhoneController t)
	{
		activeTelephone = t;
		Interface.CallHook("OnActiveTelephoneUpdated", (object)this, (object)t);
	}

	public void ClearDesigningAIEntity()
	{
		if (IsDesigningAI)
		{
			((Component)designingAIEntity).GetComponent<IAIDesign>()?.StopDesigning();
		}
		designingAIEntity = null;
	}
}


public enum CameraMode
{
	FirstPerson = 0,
	ThirdPerson = 1,
	Eyes = 2,
	FirstPersonWithArms = 3,
	DeathCamClassic = 4,
	Last = 3
}


public enum NetworkQueue
{
	Update,
	UpdateDistance,
	Count
}


using System;
using System.Collections.Generic;
using Facepunch;
using Network.Visibility;
using UnityEngine;

private class NetworkQueueList
{
	public HashSet<BaseNetworkable> queueInternal = new HashSet<BaseNetworkable>();

	public int MaxLength;

	public int Length => queueInternal.Count;

	public bool Contains(BaseNetworkable ent)
	{
		return queueInternal.Contains(ent);
	}

	public void Add(BaseNetworkable ent)
	{
		if (!Contains(ent))
		{
			queueInternal.Add(ent);
		}
		MaxLength = Mathf.Max(MaxLength, queueInternal.Count);
	}

	public void Add(BaseNetworkable[] ent)
	{
		foreach (BaseNetworkable ent2 in ent)
		{
			Add(ent2);
		}
	}

	public void Clear(Group group)
	{
		TimeWarning val = TimeWarning.New("NetworkQueueList.Clear", 0);
		try
		{
			if (group != null)
			{
				if (group.isGlobal)
				{
					return;
				}
				List<BaseNetworkable> list = Pool.Get<List<BaseNetworkable>>();
				foreach (BaseNetworkable item in queueInternal)
				{
					if ((Object)(object)item == (Object)null || item.net?.group == null || item.net.group == group)
					{
						list.Add(item);
					}
				}
				foreach (BaseNetworkable item2 in list)
				{
					queueInternal.Remove(item2);
				}
				Pool.FreeUnmanaged<BaseNetworkable>(ref list);
			}
			else
			{
				queueInternal.RemoveWhere((BaseNetworkable x) => (Object)(object)x == (Object)null || x.net?.group == null || !x.net.group.isGlobal);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;

[Flags]
public enum PlayerFlags
{
	Unused1 = 1,
	Unused2 = 2,
	IsAdmin = 4,
	ReceivingSnapshot = 8,
	Sleeping = 0x10,
	Spectating = 0x20,
	Wounded = 0x40,
	IsDeveloper = 0x80,
	Connected = 0x100,
	ThirdPersonViewmode = 0x400,
	EyesViewmode = 0x800,
	ChatMute = 0x1000,
	NoSprint = 0x2000,
	Aiming = 0x4000,
	DisplaySash = 0x8000,
	Relaxed = 0x10000,
	SafeZone = 0x20000,
	ServerFall = 0x40000,
	Incapacitated = 0x80000,
	Workbench1 = 0x100000,
	Workbench2 = 0x200000,
	Workbench3 = 0x400000,
	VoiceRangeBoost = 0x800000,
	ModifyClan = 0x1000000,
	LoadingAfterTransfer = 0x2000000,
	NoRespawnZone = 0x4000000,
	IsInTutorial = 0x8000000,
	IsRestrained = 0x10000000,
	CreativeMode = 0x20000000,
	WaitingForGestureInteraction = 0x40000000,
	Ragdolling = int.MinValue
}


private enum RPSWinState
{
	Win,
	Loss,
	Draw
}


public static class GestureIds
{
	public const uint FlashBlindId = 235662700u;
}


public enum GestureStartSource
{
	ServerAction,
	Player
}


public enum MapNoteType
{
	Death,
	PointOfInterest
}


public enum PingType
{
	Hostile = 0,
	GoTo = 1,
	Dollar = 2,
	Loot = 3,
	Node = 4,
	Gun = 5,
	Build = 6,
	LAST = 6
}


public struct PingStyle
{
	public int IconIndex;

	public int ColourIndex;

	public Phrase PingTitle;

	public Phrase PingDescription;

	public PingType Type;

	public PingStyle(int icon, int colour, Phrase title, Phrase desc, PingType pType)
	{
		IconIndex = icon;
		ColourIndex = colour;
		PingTitle = title;
		PingDescription = desc;
		Type = pType;
	}
}


using UnityEngine;

[JsonModel]
public struct FiredProjectileUpdate
{
	public Vector3 OldPosition;

	public Vector3 NewPosition;

	public Vector3 OldVelocity;

	public Vector3 NewVelocity;

	public float Mismatch;

	public float PartialTime;
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class FiredProjectile : IPooled
{
	public ItemDefinition itemDef;

	public ItemModProjectile itemMod;

	public Projectile projectilePrefab;

	public float firedTime;

	public float travelTime;

	public float partialTime;

	public AttackEntity weaponSource;

	public AttackEntity weaponPrefab;

	public Projectile.Modifier projectileModifier;

	public Item pickupItem;

	public float integrity;

	public float trajectoryMismatch;

	public float startPointMismatch;

	public float endPointMismatch;

	public float entityDistance;

	public Vector3 position;

	public Vector3 initialPositionOffset;

	public Vector3 positionOffset;

	public Vector3 velocity;

	public Vector3 initialPosition;

	public Vector3 initialVelocity;

	public Vector3 inheritedVelocity;

	public int protection;

	public int ricochets;

	public int hits;

	public BaseEntity lastEntityHit;

	public float desyncLifeTime;

	public int id;

	public BasePlayer attacker;

	public bool invalid;

	public List<FiredProjectileUpdate> updates = new List<FiredProjectileUpdate>();

	public List<Vector3> simulatedPositions = new List<Vector3>();

	public void EnterPool()
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		itemDef = null;
		itemMod = null;
		projectilePrefab = null;
		firedTime = 0f;
		travelTime = 0f;
		partialTime = 0f;
		weaponSource = null;
		weaponPrefab = null;
		projectileModifier = default(Projectile.Modifier);
		pickupItem = null;
		integrity = 0f;
		trajectoryMismatch = 0f;
		startPointMismatch = 0f;
		endPointMismatch = 0f;
		entityDistance = 0f;
		position = default(Vector3);
		velocity = default(Vector3);
		initialPosition = default(Vector3);
		initialVelocity = default(Vector3);
		inheritedVelocity = default(Vector3);
		protection = 0;
		ricochets = 0;
		hits = 0;
		lastEntityHit = null;
		desyncLifeTime = 0f;
		id = 0;
		attacker = null;
		invalid = false;
		updates.Clear();
		simulatedPositions.Clear();
	}

	public void LeavePool()
	{
	}
}


using UnityEngine;

public class SpawnPoint
{
	public Vector3 pos;

	public Quaternion rot;

	public bool isProcedualSpawn;
}


internal struct DeathBlow
{
	public BaseEntity Initiator;

	public BaseEntity WeaponPrefab;

	public uint HitBone;

	public bool IsValid;

	public static void From(HitInfo hitInfo, out DeathBlow deathBlow)
	{
		deathBlow = default(DeathBlow);
		deathBlow.IsValid = hitInfo != null;
		if (deathBlow.IsValid)
		{
			deathBlow.Initiator = hitInfo.Initiator;
			deathBlow.WeaponPrefab = hitInfo.WeaponPrefab;
			deathBlow.HitBone = hitInfo.HitBone;
		}
		else
		{
			deathBlow.IsValid = false;
			deathBlow.Initiator = null;
			deathBlow.WeaponPrefab = null;
		}
	}

	public static void Reset(ref DeathBlow deathBlow)
	{
		deathBlow.IsValid = false;
		deathBlow.Initiator = null;
		deathBlow.WeaponPrefab = null;
		deathBlow.HitBone = 0u;
	}
}


public enum TimeCategory
{
	Wilderness = 1,
	Monument = 2,
	Base = 4,
	Flying = 8,
	Boating = 0x10,
	Swimming = 0x20,
	Driving = 0x40
}


public class LifeStoryWorkQueue : ObjectWorkQueue<BasePlayer>
{
	protected override void RunJob(BasePlayer entity)
	{
		entity.UpdateTimeCategory();
	}

	protected override bool ShouldAdd(BasePlayer entity)
	{
		if (base.ShouldAdd(entity))
		{
			return entity.IsValid();
		}
		return false;
	}
}


private class NearbyStash
{
	public StashContainer Entity;

	public float LookingAtTime;

	public NearbyStash(StashContainer stash)
	{
		Entity = stash;
		LookingAtTime = 0f;
	}
}


public struct CachedState
{
	public WaterLevel.WaterInfo WaterInfo;

	public float WaterFactor;

	public bool IsSwimming;

	public bool IsValid;
}


public enum PositionChange
{
	Same,
	Valid,
	Invalid
}


public enum TutorialItemAllowance
{
	AlwaysAllowed = -1,
	None = 0,
	Level1_HatchetPickaxe = 10,
	Level2_Planner = 20,
	Level3_Bag_TC_Door = 30,
	Level3_Hammer = 35,
	Level4_Spear_Fire = 40,
	Level5_PrepareForCombat = 50,
	Level6_Furnace = 60,
	Level7_WorkBench = 70,
	Level8_Kayak = 80
}


public enum InjureState
{
	Normal,
	Crawling,
	Incapacitated,
	Dead
}


using System;
using UnityEngine;

[Serializable]
public struct CapsuleColliderInfo
{
	public float height;

	public float radius;

	public Vector3 center;

	public CapsuleColliderInfo(float height, float radius, Vector3 center)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		this.height = height;
		this.radius = radius;
		this.center = center;
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class BasePortal : BaseCombatEntity
{
	public bool isUsablePortal = true;

	private Vector3 destination_pos;

	private Quaternion destination_rot;

	public BasePortal targetPortal;

	public NetworkableId targetID;

	public Transform localEntryExitPos;

	public Transform relativeAnchor;

	public bool isMirrored = true;

	public GameObjectRef appearEffect;

	public GameObjectRef disappearEffect;

	public GameObjectRef transitionSoundEffect;

	public string useTagString = "";

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BasePortal.OnRpcMessage", 0);
		try
		{
			if (rpc == 561762999 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_UsePortal "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_UsePortal", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(561762999u, "RPC_UsePortal", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(561762999u, "RPC_UsePortal", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_UsePortal(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_UsePortal");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.ioEntity = Pool.Get<IOEntity>();
		info.msg.ioEntity.genericEntRef1 = targetID;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			targetID = info.msg.ioEntity.genericEntRef1;
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
	}

	public void LinkPortal()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)targetPortal != (Object)null)
		{
			targetID = targetPortal.net.ID;
		}
		if ((Object)(object)targetPortal == (Object)null && ((NetworkableId)(ref targetID)).IsValid)
		{
			BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(targetID);
			if ((Object)(object)baseNetworkable != (Object)null)
			{
				targetPortal = ((Component)baseNetworkable).GetComponent<BasePortal>();
			}
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		Debug.Log((object)"Post server load");
		LinkPortal();
	}

	public void SetDestination(Vector3 destPos, Quaternion destRot)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		destination_pos = destPos;
		destination_rot = destRot;
	}

	public Vector3 GetLocalEntryExitPosition()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)localEntryExitPos).transform.position;
	}

	public Quaternion GetLocalEntryExitRotation()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)localEntryExitPos).transform.rotation;
	}

	public BasePortal GetPortal()
	{
		LinkPortal();
		return targetPortal;
	}

	public virtual void UsePortal(BasePlayer player)
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnPortalUse", (object)player, (object)this) != null)
		{
			return;
		}
		LinkPortal();
		if ((Object)(object)targetPortal != (Object)null)
		{
			player.PauseFlyHackDetection();
			player.PauseSpeedHackDetection();
			player.ApplyStallProtection(4f);
			Vector3 position = ((Component)player).transform.position;
			Vector3 val = targetPortal.GetLocalEntryExitPosition();
			Vector3 val2 = ((Component)this).transform.InverseTransformDirection(player.eyes.BodyForward());
			Vector3 val3 = val2;
			if (isMirrored)
			{
				Vector3 val4 = ((Component)this).transform.InverseTransformPoint(((Component)player).transform.position);
				val = ((Component)targetPortal.relativeAnchor).transform.TransformPoint(val4);
				val3 = ((Component)targetPortal.relativeAnchor).transform.TransformDirection(val2);
			}
			else
			{
				val3 = targetPortal.GetLocalEntryExitRotation() * Vector3.forward;
			}
			if (disappearEffect.isValid)
			{
				Effect.server.Run(disappearEffect.resourcePath, position, Vector3.up);
			}
			if (appearEffect.isValid)
			{
				Effect.server.Run(appearEffect.resourcePath, val, Vector3.up);
			}
			player.ClientRPC(RpcTarget.Player("StartLoading_Quick", player), arg1: true);
			player.SetParent(null, worldPositionStays: true);
			player.Teleport(val);
			player.ForceUpdateTriggers();
			player.ClientRPC(RpcTarget.Player("ForceViewAnglesTo", player), val3);
			if (transitionSoundEffect.isValid)
			{
				Effect.server.Run(transitionSoundEffect.resourcePath, ((Component)targetPortal.relativeAnchor).transform.position, Vector3.up);
			}
			player.UpdateNetworkGroup();
			player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, b: true);
			SendNetworkUpdateImmediate();
			Interface.CallHook("OnPortalUsed", (object)player, (object)this);
		}
		else
		{
			Debug.Log((object)"No portal...");
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	public void RPC_UsePortal(RPCMessage msg)
	{
		if (IsActive())
		{
			BasePlayer player = msg.player;
			if (player.CanInteract())
			{
				UsePortal(player);
			}
		}
	}

	public bool IsActive()
	{
		return true;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class BaseProjectile : AttackEntity
{
	[Serializable]
	public class Magazine
	{
		[Serializable]
		public struct Definition
		{
			[Tooltip("Set to 0 to not use inbuilt mag")]
			public int builtInSize;

			[Tooltip("If using inbuilt mag, will accept these types of ammo")]
			[InspectorFlags]
			public AmmoTypes ammoTypes;
		}

		public Definition definition;

		public int capacity;

		public int contents;

		[ItemSelector]
		public ItemDefinition ammoType;

		public bool allowPlayerReloading = true;

		public bool allowAmmoSwitching = true;

		public void ServerInit()
		{
			if (definition.builtInSize > 0)
			{
				capacity = definition.builtInSize;
			}
		}

		public Magazine Save()
		{
			Magazine val = Pool.Get<Magazine>();
			if ((Object)(object)ammoType == (Object)null)
			{
				val.capacity = capacity;
				val.contents = 0;
				val.ammoType = 0;
			}
			else
			{
				val.capacity = capacity;
				val.contents = contents;
				val.ammoType = ammoType.itemid;
			}
			return val;
		}

		public void Load(Magazine mag)
		{
			contents = mag.contents;
			capacity = mag.capacity;
			ammoType = ItemManager.FindItemDefinition(mag.ammoType);
		}

		public bool CanReload(IAmmoContainer ammoSource)
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			if (contents >= capacity)
			{
				return false;
			}
			return ammoSource.HasAmmo(definition.ammoTypes);
		}
	}

	public static class BaseProjectileFlags
	{
		public const Flags BurstToggle = Flags.Reserved6;
	}

	[Header("NPC Info")]
	public float NoiseRadius = 100f;

	[Header("Projectile")]
	public float damageScale = 1f;

	public float distanceScale = 1f;

	public float projectileVelocityScale = 1f;

	public bool automatic;

	public bool usableByTurret = true;

	[Tooltip("Final damage is scaled by this amount before being applied to a target when this weapon is mounted to a turret")]
	public float turretDamageScale = 0.35f;

	public bool largeTurretWeapon;

	public float turretReloadDurationOverride = -1f;

	[Header("Effects")]
	public GameObjectRef attackFX;

	public GameObjectRef silencedAttack;

	public GameObjectRef muzzleBrakeAttack;

	public SoundDefinition fireModeSound;

	public Transform MuzzlePoint;

	[Header("Reloading")]
	public float reloadTime = 1f;

	public bool canUnloadAmmo = true;

	public Magazine primaryMagazine;

	public bool fractionalReload;

	public float reloadStartDuration;

	public float reloadFractionDuration;

	public float reloadEndDuration;

	public float alternateDryFireRate;

	[Header("Recoil")]
	public float aimSway = 3f;

	public float aimSwaySpeed = 1f;

	public RecoilProperties recoil;

	[Header("Aim Cone")]
	public AnimationCurve aimconeCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
	{
		new Keyframe(0f, 1f),
		new Keyframe(1f, 1f)
	});

	public float aimCone;

	public float hipAimCone = 1.8f;

	public float aimconePenaltyPerShot;

	public float aimConePenaltyMax;

	public float aimconePenaltyRecoverTime = 0.1f;

	public float aimconePenaltyRecoverDelay = 0.1f;

	public float stancePenaltyScale = 1f;

	[Header("Iconsights")]
	public bool hasADS = true;

	public bool noAimingWhileCycling;

	public bool manualCycle;

	[NonSerialized]
	protected bool needsCycle;

	[NonSerialized]
	protected bool isCycling;

	[NonSerialized]
	public bool aiming;

	[Header("Burst Information")]
	public bool isBurstWeapon;

	public bool canChangeFireModes = true;

	public bool defaultOn = true;

	public float internalBurstRecoilScale = 0.8f;

	public float internalBurstFireRateScale = 0.8f;

	public float internalBurstAimConeScale = 0.8f;

	public float resetDuration = 0.3f;

	public int numShotsFired;

	public const float maxDistance = 300f;

	[NonSerialized]
	private EncryptedValue<float> nextReloadTime = float.NegativeInfinity;

	[NonSerialized]
	private EncryptedValue<float> startReloadTime = float.NegativeInfinity;

	private float lastReloadTime = -10f;

	private bool modsChangedInitialized;

	private float stancePenalty;

	private float aimconePenalty;

	private uint cachedModHash;

	private float sightAimConeScale = 1f;

	private float sightAimConeOffset;

	private float hipAimConeScale = 1f;

	private float hipAimConeOffset;

	protected bool reloadStarted;

	protected bool reloadFinished;

	private int fractionalInsertCounter;

	private static readonly Effect reusableInstance = new Effect();

	public RecoilProperties recoilProperties
	{
		get
		{
			if (!((Object)(object)recoil == (Object)null))
			{
				return recoil.GetRecoil();
			}
			return null;
		}
	}

	public bool isSemiAuto => !automatic;

	public override Transform MuzzleTransform => MuzzlePoint;

	public override bool IsUsableByTurret => usableByTurret;

	protected virtual bool CanRefundAmmo => true;

	protected virtual ItemDefinition PrimaryMagazineAmmo => primaryMagazine.ammoType;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseProjectile.OnRpcMessage", 0);
		try
		{
			if (rpc == 3168282921u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - CLProject "));
				}
				TimeWarning val2 = TimeWarning.New("CLProject", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(3168282921u, "CLProject", this, player, includeMounted: false))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(3168282921u, "CLProject", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							CLProject(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in CLProject");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1720368164 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Reload "));
				}
				TimeWarning val2 = TimeWarning.New("Reload", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(1720368164u, "Reload", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Reload(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Reload");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 240404208 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ServerFractionalReloadInsert "));
				}
				TimeWarning val2 = TimeWarning.New("ServerFractionalReloadInsert", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(240404208u, "ServerFractionalReloadInsert", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							ServerFractionalReloadInsert(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in ServerFractionalReloadInsert");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 555589155 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - StartReload "));
				}
				TimeWarning val2 = TimeWarning.New("StartReload", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(555589155u, "StartReload", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							StartReload(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in StartReload");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1918419884 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SwitchAmmoTo "));
				}
				TimeWarning val2 = TimeWarning.New("SwitchAmmoTo", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(1918419884u, "SwitchAmmoTo", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							SwitchAmmoTo(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in SwitchAmmoTo");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3327286961u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ToggleFireMode "));
				}
				TimeWarning val2 = TimeWarning.New("ToggleFireMode", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3327286961u, "ToggleFireMode", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(3327286961u, "ToggleFireMode", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg7 = rPCMessage;
							ToggleFireMode(msg7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in ToggleFireMode");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	protected bool TryReload(IAmmoContainer ammoSource, int desiredAmount, bool canRefundAmmo = true)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		PooledList<Item> val = Pool.Get<PooledList<Item>>();
		try
		{
			ammoSource.FindItemsByItemID((List<Item>)(object)val, primaryMagazine.ammoType.itemid);
			if (((List<Item>)(object)val).Count == 0 && !primaryMagazine.allowAmmoSwitching)
			{
				return false;
			}
			if (((List<Item>)(object)val).Count == 0)
			{
				Item item = ammoSource.FindAmmo(primaryMagazine.definition.ammoTypes);
				if (item == null)
				{
					return false;
				}
				ammoSource.FindItemsByItemID((List<Item>)(object)val, item.info.itemid);
				if (((List<Item>)(object)val).Count == 0)
				{
					return false;
				}
				if (primaryMagazine.contents > 0)
				{
					if (canRefundAmmo)
					{
						ammoSource.GiveItem(ItemManager.CreateByItemID(primaryMagazine.ammoType.itemid, primaryMagazine.contents, 0uL));
					}
					SetAmmoCount(0);
				}
				primaryMagazine.ammoType = ((List<Item>)(object)val)[0].info;
			}
			int num = desiredAmount;
			if (num == -1)
			{
				num = primaryMagazine.capacity - primaryMagazine.contents;
			}
			foreach (Item item2 in (List<Item>)(object)val)
			{
				_ = item2.amount;
				int num2 = Mathf.Min(num, item2.amount);
				item2.UseItem(num2);
				ModifyAmmoCount(num2);
				num -= num2;
				if (num <= 0)
				{
					break;
				}
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void SwitchAmmoTypesIfNeeded(IAmmoContainer ammoSource)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Item item = ammoSource.FindItemByItemID(primaryMagazine.ammoType.itemid);
		if (item != null)
		{
			return;
		}
		Item item2 = ammoSource.FindAmmo(primaryMagazine.definition.ammoTypes);
		if (item2 == null)
		{
			return;
		}
		item = ammoSource.FindItemByItemID(item2.info.itemid);
		if (item != null)
		{
			if (primaryMagazine.contents > 0)
			{
				ammoSource.GiveItem(ItemManager.CreateByItemID(primaryMagazine.ammoType.itemid, primaryMagazine.contents, 0uL));
				SetAmmoCount(0);
			}
			primaryMagazine.ammoType = item.info;
		}
	}

	public static void StripAmmoToType(ref List<Item> ammos, ItemDefinition onlyAllowed)
	{
		if (!((Object)(object)onlyAllowed != (Object)null))
		{
			return;
		}
		for (int num = ammos.Count - 1; num >= 0; num--)
		{
			if ((Object)(object)ammos[num].info != (Object)(object)onlyAllowed)
			{
				ammos.RemoveAt(num);
			}
		}
	}

	public void SetAmmoCount(int newCount)
	{
		primaryMagazine.contents = newCount;
		GetItem()?.MarkDirty();
	}

	public void ModifyAmmoCount(int amount)
	{
		SetAmmoCount(primaryMagazine.contents + amount);
	}

	public override Vector3 GetInheritedVelocity(BasePlayer player, Vector3 direction)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return player.GetInheritedProjectileVelocity(direction);
	}

	public virtual float GetDamageScale(bool getMax = false)
	{
		return damageScale;
	}

	public virtual float GetDistanceScale(bool getMax = false)
	{
		return distanceScale;
	}

	public virtual float GetProjectileVelocityScale(bool getMax = false)
	{
		return projectileVelocityScale;
	}

	public virtual float GetOverrideProjectileThickness(Projectile projectile)
	{
		if ((Object)(object)projectile == (Object)null)
		{
			return 0f;
		}
		return projectile.thickness;
	}

	protected void StartReloadCooldown(float cooldown)
	{
		nextReloadTime = CalculateCooldownTime(nextReloadTime, cooldown, catchup: false, unscaledTime: true);
		startReloadTime = (float)nextReloadTime - cooldown;
	}

	protected void ResetReloadCooldown()
	{
		nextReloadTime = float.NegativeInfinity;
	}

	protected bool HasReloadCooldown()
	{
		return Time.unscaledTime < (float)nextReloadTime;
	}

	protected float GetReloadCooldown()
	{
		return Mathf.Max((float)nextReloadTime - Time.unscaledTime, 0f);
	}

	protected float GetReloadIdle()
	{
		return Mathf.Max(Time.unscaledTime - (float)nextReloadTime, 0f);
	}

	private void OnDrawGizmos()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient && (Object)(object)MuzzlePoint != (Object)null)
		{
			Gizmos.color = Color.blue;
			Gizmos.DrawLine(MuzzlePoint.position, MuzzlePoint.position + MuzzlePoint.forward * 10f);
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if (Object.op_Implicit((Object)(object)ownerPlayer))
			{
				Gizmos.color = Color.cyan;
				Gizmos.DrawLine(MuzzlePoint.position, MuzzlePoint.position + ownerPlayer.eyes.rotation * Vector3.forward * 10f);
			}
		}
	}

	public virtual RecoilProperties GetRecoil()
	{
		return recoilProperties;
	}

	public override float AmmoFraction()
	{
		return (float)primaryMagazine.contents / (float)primaryMagazine.capacity;
	}

	public virtual void DidAttackServerside()
	{
	}

	public override bool ServerIsReloading()
	{
		return Time.time < lastReloadTime + reloadTime;
	}

	public override bool CanReload()
	{
		return primaryMagazine.contents < primaryMagazine.capacity;
	}

	public override void TopUpAmmo()
	{
		SetAmmoCount(primaryMagazine.capacity);
	}

	public override void ServerReload()
	{
		if (!ServerIsReloading())
		{
			lastReloadTime = Time.time;
			StartAttackCooldown(reloadTime);
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if ((Object)(object)ownerPlayer != (Object)null)
			{
				ownerPlayer.SignalBroadcast(Signal.Reload);
			}
			SetAmmoCount(primaryMagazine.capacity);
		}
	}

	public override bool ServerTryReload(IAmmoContainer ammoSource)
	{
		if (ServerIsReloading())
		{
			return false;
		}
		if (TryReloadMagazine(ammoSource))
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if ((Object)(object)ownerPlayer != (Object)null)
			{
				ownerPlayer.SignalBroadcast(Signal.Reload);
			}
			lastReloadTime = Time.time;
			StartAttackCooldown(reloadTime);
			return true;
		}
		return false;
	}

	public override Vector3 ModifyAIAim(Vector3 eulerInput, float swayModifier = 1f)
	{
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.time * (aimSwaySpeed * 1f + aiAimSwayOffset);
		float num2 = Mathf.Sin(Time.time * 2f);
		float num3 = ((num2 < 0f) ? (1f - Mathf.Clamp(Mathf.Abs(num2) / 1f, 0f, 1f)) : 1f);
		float num4 = (false ? 0.6f : 1f);
		float num5 = (aimSway * 1f + aiAimSwayOffset) * num4 * num3 * swayModifier;
		eulerInput.y += (Mathf.PerlinNoise(num, num) - 0.5f) * num5 * Time.deltaTime;
		eulerInput.x += (Mathf.PerlinNoise(num + 0.1f, num + 0.2f) - 0.5f) * num5 * Time.deltaTime;
		return eulerInput;
	}

	public float GetAIAimcone()
	{
		NPCPlayer nPCPlayer = GetOwnerPlayer() as NPCPlayer;
		if (Object.op_Implicit((Object)(object)nPCPlayer))
		{
			return nPCPlayer.GetAimConeScale() * aiAimCone;
		}
		return aiAimCone;
	}

	public override void ServerUse(float damageModifier = 1f, float speedModifier = 1f, Matrix4x4? originOverride = null, bool useBulletThickness = true)
	{
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_05cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05af: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_044a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0451: Unknown result type (might be due to invalid IL or missing references)
		//IL_0456: Unknown result type (might be due to invalid IL or missing references)
		//IL_0468: Unknown result type (might be due to invalid IL or missing references)
		//IL_046d: Unknown result type (might be due to invalid IL or missing references)
		//IL_047b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0480: Unknown result type (might be due to invalid IL or missing references)
		//IL_048e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0493: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a6: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient || HasAttackCooldown())
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		bool flag = (Object)(object)ownerPlayer != (Object)null;
		if (primaryMagazine.contents <= 0)
		{
			SignalBroadcast(Signal.DryFire);
			StartAttackCooldownRaw(1f);
			return;
		}
		ModifyAmmoCount(-1);
		if (primaryMagazine.contents < 0)
		{
			SetAmmoCount(0);
		}
		bool flag2 = flag && ownerPlayer.IsNpc;
		if (flag2 && (ownerPlayer.isMounted || (Object)(object)ownerPlayer.GetParentEntity() != (Object)null))
		{
			NPCPlayer nPCPlayer = ownerPlayer as NPCPlayer;
			if ((Object)(object)nPCPlayer != (Object)null)
			{
				nPCPlayer.SetAimDirection(nPCPlayer.GetAimDirection());
			}
		}
		StartAttackCooldownRaw(repeatDelay);
		Vector3 val = (flag ? ownerPlayer.eyes.position : ((Component)MuzzlePoint).transform.position);
		Vector3 inputVec = ((Component)MuzzlePoint).transform.forward;
		if (originOverride.HasValue)
		{
			Matrix4x4 value = originOverride.Value;
			val = ((Matrix4x4)(ref value)).GetPosition();
			value = originOverride.Value;
			inputVec = ((Matrix4x4)(ref value)).MultiplyVector(Vector3.forward);
		}
		ItemModProjectile ammoInfo2 = ((Component)primaryMagazine.ammoType).GetComponent<ItemModProjectile>();
		SignalBroadcast(Signal.Attack, string.Empty, null, GetAttackEffect());
		Projectile component = ammoInfo2.projectileObject.Get().GetComponent<Projectile>();
		float num = ammoInfo2.projectileVelocity * speedModifier;
		bool flag3 = GetParentEntity() is BasePlayer;
		BaseEntity baseEntity = null;
		if (flag)
		{
			inputVec = ownerPlayer.eyes.BodyForward();
		}
		Ray val3 = default(Ray);
		for (int i = 0; i < ammoInfo2.numProjectiles; i++)
		{
			Vector3 val2 = ((!flag2) ? AimConeUtil.GetModifiedAimConeDirection(ammoInfo2.projectileSpread + GetAimCone(), inputVec) : AimConeUtil.GetModifiedAimConeDirection(ammoInfo2.projectileSpread + GetAimCone() + GetAIAimcone(), inputVec));
			float radius = (useBulletThickness ? GetOverrideProjectileThickness(component) : 0f);
			List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
			((Ray)(ref val3))..ctor(val, val2);
			GamePhysics.TraceAll(val3, radius, list, 300f, 1220225793, (QueryTriggerInteraction)1, ownerPlayer);
			float distanceOverride = 0f;
			for (int j = 0; j < list.Count && damageModifier != 0f; j++)
			{
				RaycastHit hit = list[j];
				BaseEntity entity = hit.GetEntity();
				if (flag3)
				{
					if ((Object)(object)entity != (Object)null && ((Object)(object)entity == (Object)(object)this || entity.EqualNetID((BaseNetworkable)this)))
					{
						continue;
					}
				}
				else if ((Object)(object)entity != (Object)null && this.HasEntityInParents(entity))
				{
					continue;
				}
				if (entity is BasePlayer basePlayer && basePlayer.GetActiveShield(out var foundShield) && foundShield.RaycastAgainstColliders(val3, 300f))
				{
					Vector3 val4 = ((Component)this).transform.InverseTransformPoint(((Component)foundShield).transform.position);
					Vector3 val5 = ((Component)this).transform.InverseTransformPoint(basePlayer.CenterPoint());
					if (((Vector3)(ref val4)).sqrMagnitude < ((Vector3)(ref val5)).sqrMagnitude)
					{
						continue;
					}
				}
				if ((Object)(object)entity != (Object)null && entity.isClient)
				{
					continue;
				}
				ColliderInfo component2 = ((Component)((RaycastHit)(ref hit)).collider).GetComponent<ColliderInfo>();
				if ((Object)(object)component2 != (Object)null && !component2.HasFlag(ColliderInfo.Flags.Shootable))
				{
					continue;
				}
				BaseCombatEntity baseCombatEntity = entity as BaseCombatEntity;
				if (((Object)(object)entity != (Object)null && entity.IsNpc && flag2 && (Object)(object)baseCombatEntity != (Object)null && baseCombatEntity.GetFaction() != BaseCombatEntity.Faction.Horror && !(entity is BasePet)) || !((Object)(object)entity != (Object)null) || (!((Object)(object)baseEntity == (Object)null) && !((Object)(object)entity == (Object)(object)baseEntity) && !entity.EqualNetID((BaseNetworkable)baseEntity)) || !entity.IsVisible(val, ((RaycastHit)(ref hit)).point, 300f))
				{
					continue;
				}
				HitInfo info2 = new HitInfo();
				AssignInitiator(info2);
				info2.Weapon = this;
				info2.WeaponPrefab = base.gameManager.FindPrefab(base.PrefabName).GetComponent<AttackEntity>();
				info2.IsPredicting = false;
				info2.DoHitEffects = component.doDefaultHitEffects;
				info2.DidHit = true;
				info2.ProjectileVelocity = val2 * 300f;
				info2.PointStart = MuzzlePoint.position;
				info2.PointEnd = ((RaycastHit)(ref hit)).point;
				info2.HitPositionWorld = ((RaycastHit)(ref hit)).point;
				info2.HitNormalWorld = ((RaycastHit)(ref hit)).normal;
				info2.HitEntity = entity;
				info2.UseProtection = true;
				distanceOverride = ((RaycastHit)(ref hit)).distance;
				component.CalculateDamage(info2, GetProjectileModifier(), 1f);
				info2.damageTypes.ScaleAll(GetDamageScale() * damageModifier * (flag2 ? npcDamageScale : turretDamageScale));
				float num2 = ((num > 0f) ? (((RaycastHit)(ref hit)).distance / num) : 0f);
				if (num2 > 0.2f)
				{
					((FacepunchBehaviour)this).Invoke((Action)delegate
					{
						ProcessHit(info2, ammoInfo2);
					}, num2);
				}
				else
				{
					ProcessHit(info2, ammoInfo2);
				}
				if (!((Object)(object)entity != (Object)null) || entity.ShouldBlockProjectiles())
				{
					break;
				}
			}
			Pool.FreeUnmanaged<RaycastHit>(ref list);
			Vector3 val6 = ((flag && ownerPlayer.isMounted) ? (val2 * 6f) : Vector3.zero);
			CreateProjectileEffectClientside(ammoInfo2.projectileObject.resourcePath, val + val6, val2 * num, Random.Range(1, 100), null, IsSilenced(), forceClientsideEffects: true, null, distanceOverride);
		}
		static void ProcessHit(HitInfo info, ItemModProjectile ammoInfo)
		{
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			if (info.Weapon.IsValid() && info.HitEntity.IsValid())
			{
				info.HitEntity.OnAttacked(info);
				ammoInfo.ServerProjectileHit(info);
				ammoInfo.ServerProjectileHitEntity(info);
				Shield shield = info.HitEntity as Shield;
				if (info.HitEntity is BasePlayer || info.HitEntity is BaseNpc || (Object)(object)shield != (Object)null)
				{
					info.HitPositionLocal = ((Component)info.HitEntity).transform.InverseTransformPoint(info.HitPositionWorld);
					info.HitNormalLocal = ((Component)info.HitEntity).transform.InverseTransformDirection(info.HitNormalWorld);
					info.HitMaterial = StringPool.Get(((Object)(object)shield != (Object)null) ? shield.GetHitMaterialString() : "Flesh");
					Effect.server.ImpactEffect(info);
				}
			}
		}
	}

	private void AssignInitiator(HitInfo info)
	{
		info.Initiator = GetOwnerPlayer();
		if ((Object)(object)info.Initiator == (Object)null)
		{
			info.Initiator = GetParentEntity();
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		primaryMagazine.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)DelayedModSetup, 0.1f);
	}

	public void DelayedModSetup()
	{
		if (!modsChangedInitialized)
		{
			Item item = GetCachedItem();
			if (item != null && item.contents != null)
			{
				ItemContainer contents = item.contents;
				contents.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(contents.onItemAddedRemoved, new Action<Item, bool>(ModsChanged));
				modsChangedInitialized = true;
			}
		}
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			Item item = GetCachedItem();
			if (item != null && item.contents != null)
			{
				ItemContainer contents = item.contents;
				contents.onItemAddedRemoved = (Action<Item, bool>)Delegate.Remove(contents.onItemAddedRemoved, new Action<Item, bool>(ModsChanged));
				modsChangedInitialized = false;
			}
		}
		base.DestroyShared();
	}

	public void ModsChanged(Item item, bool added)
	{
		((FacepunchBehaviour)this).Invoke((Action)DelayedModsChanged, 0.1f);
	}

	public void ForceModsChanged()
	{
		((FacepunchBehaviour)this).Invoke((Action)DelayedModSetup, 0f);
		((FacepunchBehaviour)this).Invoke((Action)DelayedModsChanged, 0.2f);
	}

	public void DelayedModsChanged()
	{
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnWeaponModChange", (object)this, (object)GetOwnerPlayer()) != null)
		{
			return;
		}
		int num = Mathf.CeilToInt(ProjectileWeaponMod.Mult(this, (ProjectileWeaponMod x) => x.magazineCapacity, (ProjectileWeaponMod.Modifier y) => y.scalar, 1f) * (float)primaryMagazine.definition.builtInSize);
		if (num == primaryMagazine.capacity)
		{
			return;
		}
		if (primaryMagazine.contents > 0 && primaryMagazine.contents > num)
		{
			_ = primaryMagazine.ammoType;
			int contents = primaryMagazine.contents;
			BasePlayer ownerPlayer = GetOwnerPlayer();
			ItemContainer itemContainer = null;
			if ((Object)(object)ownerPlayer != (Object)null)
			{
				itemContainer = ownerPlayer.inventory.containerMain;
			}
			else if (GetCachedItem() != null)
			{
				itemContainer = GetCachedItem().parent;
			}
			SetAmmoCount(0);
			if (itemContainer != null)
			{
				Item item = ItemManager.Create(primaryMagazine.ammoType, contents, 0uL);
				if (!item.MoveToContainer(itemContainer))
				{
					Vector3 vPos = ((Component)this).transform.position;
					if ((Object)(object)itemContainer.entityOwner != (Object)null)
					{
						vPos = ((Component)itemContainer.entityOwner).transform.position + Vector3.up * 0.25f;
					}
					item.Drop(vPos, Vector3.up * 5f);
				}
			}
		}
		primaryMagazine.capacity = num;
		SendNetworkUpdate();
	}

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (item != null && command == "unload_ammo" && !HasReloadCooldown())
		{
			UnloadAmmo(item, player);
		}
	}

	public void UnloadAmmo(Item item, BasePlayer player)
	{
		BaseProjectile component = ((Component)item.GetHeldEntity()).GetComponent<BaseProjectile>();
		if (!component.canUnloadAmmo || Interface.CallHook("OnAmmoUnload", (object)component, (object)item, (object)player) != null || !Object.op_Implicit((Object)(object)component))
		{
			return;
		}
		int num = component.primaryMagazine.contents;
		if (num <= 0)
		{
			return;
		}
		component.SetAmmoCount(0);
		item.MarkDirty();
		SendNetworkUpdateImmediate();
		int stackable = component.primaryMagazine.ammoType.stackable;
		if (num > stackable)
		{
			int num2 = Mathf.FloorToInt((float)(num / component.primaryMagazine.ammoType.stackable));
			num %= stackable;
			for (int i = 0; i < num2; i++)
			{
				Item item2 = ItemManager.Create(component.primaryMagazine.ammoType, stackable, 0uL);
				player.GiveItem(item2);
			}
		}
		if (num > 0)
		{
			Item item3 = ItemManager.Create(component.primaryMagazine.ammoType, num, 0uL);
			player.GiveItem(item3);
		}
	}

	public override void CollectedForCrafting(Item item, BasePlayer crafter)
	{
		if (!((Object)(object)crafter == (Object)null) && item != null)
		{
			UnloadAmmo(item, crafter);
		}
	}

	public override void ReturnedFromCancelledCraft(Item item, BasePlayer crafter)
	{
		if (!((Object)(object)crafter == (Object)null) && item != null)
		{
			BaseProjectile component = ((Component)item.GetHeldEntity()).GetComponent<BaseProjectile>();
			if (Object.op_Implicit((Object)(object)component))
			{
				component.SetAmmoCount(0);
			}
		}
	}

	public override void SetLightsOn(bool isOn)
	{
		base.SetLightsOn(isOn);
		UpdateAttachmentsState();
	}

	protected override bool BroadcastSignalFromClientFilter(Signal signal)
	{
		return signal == Signal.Attack;
	}

	public void UpdateAttachmentsState()
	{
		_ = flags;
		bool b = ShouldLightsBeOn();
		if (children == null)
		{
			return;
		}
		foreach (BaseEntity child in children)
		{
			ProjectileWeaponMod projectileWeaponMod = child as ProjectileWeaponMod;
			if ((Object)(object)projectileWeaponMod != (Object)null && projectileWeaponMod.isLight)
			{
				projectileWeaponMod.SetFlag(Flags.On, b);
			}
		}
	}

	private bool ShouldLightsBeOn()
	{
		if (LightsOn())
		{
			if (!IsDeployed())
			{
				return parentEntity.Get(base.isServer) is AutoTurret;
			}
			return true;
		}
		return false;
	}

	protected override void OnChildRemoved(BaseEntity child)
	{
		base.OnChildRemoved(child);
		if (child is ProjectileWeaponMod { isLight: not false })
		{
			child.SetFlag(Flags.On, b: false);
			SetLightsOn(isOn: false);
		}
	}

	public bool CanAiAttack()
	{
		return true;
	}

	public virtual float GetAimCone()
	{
		uint num = 0u;
		foreach (BaseEntity child in children)
		{
			num += (uint)(int)child.net.ID.Value;
			num += (uint)child.flags;
		}
		uint num2 = CRC.Compute32(0u, num);
		if (num2 != cachedModHash)
		{
			sightAimConeScale = ProjectileWeaponMod.Mult(this, (ProjectileWeaponMod x) => x.sightAimCone, (ProjectileWeaponMod.Modifier y) => y.scalar, 1f);
			sightAimConeOffset = ProjectileWeaponMod.Sum(this, (ProjectileWeaponMod x) => x.sightAimCone, (ProjectileWeaponMod.Modifier y) => y.offset, 0f);
			hipAimConeScale = ProjectileWeaponMod.Mult(this, (ProjectileWeaponMod x) => x.hipAimCone, (ProjectileWeaponMod.Modifier y) => y.scalar, 1f);
			hipAimConeOffset = ProjectileWeaponMod.Sum(this, (ProjectileWeaponMod x) => x.hipAimCone, (ProjectileWeaponMod.Modifier y) => y.offset, 0f);
			cachedModHash = num2;
		}
		float num3 = aimCone;
		num3 *= (UsingInternalBurstMode() ? internalBurstAimConeScale : 1f);
		if ((Object)(object)recoilProperties != (Object)null && recoilProperties.overrideAimconeWithCurve && primaryMagazine.capacity > 0)
		{
			num3 += recoilProperties.aimconeCurve.Evaluate((float)numShotsFired / (float)primaryMagazine.capacity % 1f) * recoilProperties.aimconeCurveScale;
			aimconePenalty = 0f;
		}
		if (aiming || base.isServer)
		{
			return (num3 + aimconePenalty + stancePenalty * stancePenaltyScale) * sightAimConeScale + sightAimConeOffset;
		}
		return (num3 + aimconePenalty + stancePenalty * stancePenaltyScale) * sightAimConeScale + sightAimConeOffset + hipAimCone * hipAimConeScale + hipAimConeOffset;
	}

	public float ScaleRepeatDelay(float delay)
	{
		float num = ProjectileWeaponMod.Mult(this, (ProjectileWeaponMod x) => x.repeatDelay, (ProjectileWeaponMod.Modifier y) => y.scalar, 1f);
		float num2 = ProjectileWeaponMod.Sum(this, (ProjectileWeaponMod x) => x.repeatDelay, (ProjectileWeaponMod.Modifier y) => y.offset, 0f);
		float num3 = (UsingInternalBurstMode() ? internalBurstFireRateScale : 1f);
		return delay * num * num3 + num2;
	}

	public Projectile.Modifier GetProjectileModifier()
	{
		Projectile.Modifier result = default(Projectile.Modifier);
		result.damageOffset = ProjectileWeaponMod.Sum(this, (ProjectileWeaponMod x) => x.projectileDamage, (ProjectileWeaponMod.Modifier y) => y.offset, 0f);
		result.damageScale = ProjectileWeaponMod.Mult(this, (ProjectileWeaponMod x) => x.projectileDamage, (ProjectileWeaponMod.Modifier y) => y.scalar, 1f) * GetDamageScale();
		result.distanceOffset = ProjectileWeaponMod.Sum(this, (ProjectileWeaponMod x) => x.projectileDistance, (ProjectileWeaponMod.Modifier y) => y.offset, 0f);
		result.distanceScale = ProjectileWeaponMod.Mult(this, (ProjectileWeaponMod x) => x.projectileDistance, (ProjectileWeaponMod.Modifier y) => y.scalar, 1f) * GetDistanceScale();
		return result;
	}

	public bool UsingBurstMode()
	{
		if (IsBurstDisabled())
		{
			return false;
		}
		return IsBurstEligable();
	}

	public bool UsingInternalBurstMode()
	{
		if (IsBurstDisabled())
		{
			return false;
		}
		return isBurstWeapon;
	}

	public bool IsBurstEligable()
	{
		if (isBurstWeapon)
		{
			return true;
		}
		if (children != null)
		{
			foreach (BaseEntity child in children)
			{
				ProjectileWeaponMod projectileWeaponMod = child as ProjectileWeaponMod;
				if ((Object)(object)projectileWeaponMod != (Object)null && projectileWeaponMod.burstCount > 0)
				{
					return true;
				}
			}
		}
		return false;
	}

	public float TimeBetweenBursts()
	{
		return repeatDelay * 2f;
	}

	public virtual bool CanAttack()
	{
		if (ProjectileWeaponMod.HasBrokenWeaponMod(this))
		{
			return false;
		}
		return true;
	}

	public virtual float GetTurretReloadDuration()
	{
		if (turretReloadDurationOverride == -1f)
		{
			return GetReloadDuration() * 0.5f;
		}
		return turretReloadDurationOverride;
	}

	public virtual float GetReloadDuration()
	{
		if (fractionalReload)
		{
			int num = Mathf.Min(primaryMagazine.capacity - primaryMagazine.contents, GetAvailableAmmo());
			return reloadStartDuration + reloadEndDuration + reloadFractionDuration * (float)num;
		}
		return reloadTime;
	}

	public int GetAvailableAmmo()
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null)
		{
			return primaryMagazine.contents;
		}
		List<Item> list = Pool.Get<List<Item>>();
		ownerPlayer.inventory.FindAmmo(list, primaryMagazine.definition.ammoTypes);
		int num = 0;
		if (list.Count != 0)
		{
			for (int i = 0; i < list.Count; i++)
			{
				Item item = list[i];
				if ((Object)(object)item.info == (Object)(object)primaryMagazine.ammoType)
				{
					num += item.amount;
				}
			}
		}
		Pool.Free<Item>(ref list, false);
		return num;
	}

	public bool IsBurstDisabled()
	{
		return HasFlag(Flags.Reserved6) == defaultOn;
	}

	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void ToggleFireMode(RPCMessage msg)
	{
		if (canChangeFireModes && IsBurstEligable())
		{
			SetFlag(Flags.Reserved6, !HasFlag(Flags.Reserved6));
			SendNetworkUpdate_Flags();
			Analytics.Azure.OnBurstModeToggled(msg.player, this, HasFlag(Flags.Reserved6));
		}
	}

	public virtual bool TryReloadMagazine(IAmmoContainer ammoSource, int desiredAmount = -1)
	{
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("OnMagazineReload", (object)this, (object)ammoSource, (object)GetOwnerPlayer());
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!TryReload(ammoSource, desiredAmount))
		{
			return false;
		}
		SendNetworkUpdateImmediate();
		ItemManager.DoRemoves();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null)
		{
			ownerPlayer.inventory.ServerUpdate(0f);
		}
		if (!fractionalReload)
		{
			UpdateShieldState(bHeld: true);
		}
		else if (primaryMagazine.contents == primaryMagazine.capacity || !ammoSource.HasAmmo(primaryMagazine.definition.ammoTypes))
		{
			UpdateShieldState(bHeld: true);
		}
		return true;
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void SwitchAmmoTo(RPCMessage msg)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return;
		}
		int num = msg.read.Int32();
		if (num == primaryMagazine.ammoType.itemid)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return;
		}
		ItemModProjectile component = ((Component)itemDefinition).GetComponent<ItemModProjectile>();
		if (Object.op_Implicit((Object)(object)component) && component.IsAmmo(primaryMagazine.definition.ammoTypes) && Interface.CallHook("OnAmmoSwitch", (object)this, (object)ownerPlayer, (object)itemDefinition) == null)
		{
			if (primaryMagazine.contents > 0)
			{
				ownerPlayer.GiveItem(ItemManager.CreateByItemID(primaryMagazine.ammoType.itemid, primaryMagazine.contents, 0uL));
				SetAmmoCount(0);
			}
			primaryMagazine.ammoType = itemDefinition;
			SendNetworkUpdateImmediate();
			ItemManager.DoRemoves();
			ownerPlayer.inventory.ServerUpdate(0f);
		}
	}

	public override void OnHeldChanged()
	{
		base.OnHeldChanged();
		reloadStarted = false;
		reloadFinished = false;
		fractionalInsertCounter = 0;
		UpdateAttachmentsState();
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void StartReload(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientRPC(player))
		{
			SendNetworkUpdate();
			reloadStarted = false;
			reloadFinished = false;
		}
		else if (Interface.CallHook("OnWeaponReload", (object)this, (object)player) == null)
		{
			reloadFinished = false;
			reloadStarted = true;
			fractionalInsertCounter = 0;
			if (CanRefundAmmo)
			{
				SwitchAmmoTypesIfNeeded(player.inventory);
			}
			OnReloadStarted();
			StartReloadCooldown(GetReloadDuration());
		}
	}

	protected virtual void OnReloadStarted()
	{
		UpdateShieldState(bHeld: false);
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void ServerFractionalReloadInsert(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientRPC(player))
		{
			SendNetworkUpdate();
			reloadStarted = false;
			reloadFinished = false;
			return;
		}
		if (!fractionalReload)
		{
			AntiHack.Log(player, AntiHackType.ReloadHack, "Fractional reload not allowed (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "reload_type");
			return;
		}
		if (!reloadStarted)
		{
			AntiHack.Log(player, AntiHackType.ReloadHack, "Fractional reload request skipped (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "reload_skip");
			reloadStarted = false;
			reloadFinished = false;
			return;
		}
		if (GetReloadIdle() > 3f)
		{
			AntiHack.Log(player, AntiHackType.ReloadHack, "T+" + GetReloadIdle() + "s (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "reload_time");
			reloadStarted = false;
			reloadFinished = false;
			return;
		}
		if (Time.unscaledTime < (float)startReloadTime + reloadStartDuration)
		{
			AntiHack.Log(player, AntiHackType.ReloadHack, "Fractional reload too early (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "reload_fraction_too_early");
			reloadStarted = false;
			reloadFinished = false;
		}
		if (Time.unscaledTime < (float)startReloadTime + reloadStartDuration + (float)fractionalInsertCounter * reloadFractionDuration)
		{
			AntiHack.Log(player, AntiHackType.ReloadHack, "Fractional reload rate too high (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "reload_fraction_rate");
			reloadStarted = false;
			reloadFinished = false;
		}
		else
		{
			fractionalInsertCounter++;
			if (primaryMagazine.contents < primaryMagazine.capacity)
			{
				TryReloadMagazine(player.inventory, 1);
			}
		}
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void Reload(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientRPC(player))
		{
			SendNetworkUpdate();
			reloadStarted = false;
			reloadFinished = false;
			return;
		}
		if (!reloadStarted)
		{
			AntiHack.Log(player, AntiHackType.ReloadHack, "Request skipped (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "reload_skip");
			reloadStarted = false;
			reloadFinished = false;
			return;
		}
		if (!fractionalReload)
		{
			if (GetReloadCooldown() > 1f)
			{
				AntiHack.Log(player, AntiHackType.ReloadHack, "T-" + GetReloadCooldown() + "s (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "reload_time");
				reloadStarted = false;
				reloadFinished = false;
				return;
			}
			if (GetReloadIdle() > 1.5f)
			{
				AntiHack.Log(player, AntiHackType.ReloadHack, "T+" + GetReloadIdle() + "s (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "reload_time");
				reloadStarted = false;
				reloadFinished = false;
				return;
			}
		}
		if (fractionalReload)
		{
			ResetReloadCooldown();
			UpdateShieldState(bHeld: true);
		}
		reloadStarted = false;
		reloadFinished = true;
		if (!fractionalReload)
		{
			TryReloadMagazine(player.inventory);
		}
	}

	[RPC_Server]
	[RPC_Server.FromOwner(false)]
	[RPC_Server.IsActiveItem]
	private void CLProject(RPCMessage msg)
	{
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (reloadFinished && HasReloadCooldown())
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Reloading (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "reload_cooldown");
			return;
		}
		reloadStarted = false;
		reloadFinished = false;
		if (primaryMagazine.contents <= 0 && !base.UsingInfiniteAmmoCheat)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Magazine empty (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "ammo_missing");
			return;
		}
		ItemDefinition primaryMagazineAmmo = PrimaryMagazineAmmo;
		ProjectileShoot val = msg.read.Proto<ProjectileShoot>((ProjectileShoot)null);
		try
		{
			if (primaryMagazineAmmo.itemid != val.ammoType)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Ammo mismatch (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "ammo_mismatch");
				return;
			}
			if (!base.UsingInfiniteAmmoCheat)
			{
				ModifyAmmoCount(-1);
			}
			ItemModProjectile component = ((Component)primaryMagazineAmmo).GetComponent<ItemModProjectile>();
			if ((Object)(object)component == (Object)null)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "mod_missing");
				return;
			}
			if (val.projectiles.Count > component.numProjectiles)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Count mismatch (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "count_mismatch");
				return;
			}
			Interface.CallHook("OnWeaponFired", (object)this, (object)msg.player, (object)component, (object)val);
			if (player.InGesture)
			{
				return;
			}
			SignalBroadcast(Signal.Attack, string.Empty, msg.connection, GetAttackEffect());
			player.CleanupExpiredProjectiles();
			Guid projectileGroupId = Guid.NewGuid();
			foreach (Projectile projectile in val.projectiles)
			{
				if (player.HasFiredProjectile(projectile.projectileID))
				{
					AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
					player.stats.combat.LogInvalid(player, this, "duplicate_id");
					continue;
				}
				Vector3 positionOffset = Vector3.zero;
				if (ConVar.AntiHack.projectile_positionoffset && (player.isMounted || player.HasParent()))
				{
					if (!ValidateEyePos(player, projectile.startPos, checkLineOfSight: false))
					{
						continue;
					}
					Vector3 position = player.eyes.position;
					positionOffset = position - projectile.startPos;
					projectile.startPos = position;
				}
				else if (!ValidateEyePos(player, projectile.startPos))
				{
					continue;
				}
				player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, primaryMagazineAmmo, projectileGroupId, positionOffset);
				if (!player.limitNetworking)
				{
					CreateProjectileEffectClientside(component.projectileObject.resourcePath, projectile.startPos, projectile.startVel, projectile.seed, msg.connection, IsSilenced());
				}
			}
			player.MakeNoise(((Component)player).transform.position, BaseCombatEntity.ActionVolume.Loud);
			SingletonComponent<NpcNoiseManager>.Instance.OnWeaponShot(player, this);
			player.stats.Add(component.category + "_fired", val.projectiles.Count, (Stats)5);
			player.LifeStoryShotFired(this);
			StartAttackCooldown(ScaleRepeatDelay(repeatDelay) + animationDelay);
			player.MarkHostileFor();
			UpdateItemCondition();
			DidAttackServerside();
			BaseMountable mounted = player.GetMounted();
			if ((Object)(object)mounted != (Object)null)
			{
				mounted.OnWeaponFired(this);
			}
			EACServer.LogPlayerUseWeapon(player, this);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void CreateProjectileEffectClientside(string prefabName, Vector3 pos, Vector3 velocity, int seed, Connection sourceConnection, bool silenced = false, bool forceClientsideEffects = false, List<Connection> targets = null, float distanceOverride = 0f)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnClientProjectileEffectCreate", (object)sourceConnection, (object)this, (object)prefabName) == null)
		{
			Effect effect = reusableInstance;
			effect.Init(Effect.Type.Projectile, pos, velocity, sourceConnection);
			((EffectData)effect).scale = (silenced ? 0f : 1f);
			if (forceClientsideEffects)
			{
				((EffectData)effect).scale = 2f;
			}
			effect.pooledString = prefabName;
			((EffectData)effect).number = seed;
			effect.targets = targets;
			((EffectData)effect).distanceOverride = distanceOverride;
			EffectNetwork.Send(effect);
		}
	}

	public void UpdateItemCondition()
	{
		Item ownerItem = GetOwnerItem();
		if (ownerItem == null)
		{
			return;
		}
		float barrelConditionLoss = ((Component)primaryMagazine.ammoType).GetComponent<ItemModProjectile>().barrelConditionLoss;
		float num = 0.25f;
		bool usingInfiniteAmmoCheat = base.UsingInfiniteAmmoCheat;
		if (!usingInfiniteAmmoCheat)
		{
			ownerItem.LoseCondition(num + barrelConditionLoss);
		}
		if (ownerItem.contents == null || ownerItem.contents.itemList == null)
		{
			return;
		}
		for (int num2 = ownerItem.contents.itemList.Count - 1; num2 >= 0; num2--)
		{
			Item item = ownerItem.contents.itemList[num2];
			if (item != null && !usingInfiniteAmmoCheat)
			{
				float num3 = 1f;
				ProjectileWeaponMod projectileWeaponMod = item.GetHeldEntity() as ProjectileWeaponMod;
				if ((Object)(object)projectileWeaponMod != (Object)null)
				{
					num3 = projectileWeaponMod.ConditionLossMultiplier;
				}
				item.LoseCondition((num + barrelConditionLoss) * num3);
			}
		}
	}

	public bool IsSilenced()
	{
		if (children != null)
		{
			foreach (BaseEntity child in children)
			{
				ProjectileWeaponMod projectileWeaponMod = child as ProjectileWeaponMod;
				if ((Object)(object)projectileWeaponMod != (Object)null && projectileWeaponMod.isSilencer && !projectileWeaponMod.IsBroken())
				{
					return true;
				}
			}
		}
		return false;
	}

	public bool AllowsPingUsage()
	{
		TimeWarning val = TimeWarning.New("AllowsPingUsage", 0);
		try
		{
			if (children != null)
			{
				foreach (BaseEntity child in children)
				{
					ProjectileWeaponMod projectileWeaponMod = child as ProjectileWeaponMod;
					if ((Object)(object)projectileWeaponMod != (Object)null && projectileWeaponMod.allowPings && !projectileWeaponMod.IsBroken())
					{
						return true;
					}
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return false;
	}

	public string GetAttackEffectAdditive()
	{
		string result = "";
		if (children != null)
		{
			foreach (BaseEntity child in children)
			{
				ProjectileWeaponMod projectileWeaponMod = child as ProjectileWeaponMod;
				if (!((Object)(object)projectileWeaponMod == (Object)null) && projectileWeaponMod.additiveEffect.isValid)
				{
					result = projectileWeaponMod.additiveEffect.resourcePath;
					break;
				}
			}
		}
		return result;
	}

	protected string GetAttackEffect()
	{
		string resourcePath = attackFX.resourcePath;
		if ((Object)(object)primaryMagazine.ammoType != (Object)null)
		{
			ItemModProjectile component = ((Component)primaryMagazine.ammoType).GetComponent<ItemModProjectile>();
			if (component.attackEffectOverride.isValid)
			{
				resourcePath = component.attackEffectOverride.resourcePath;
			}
		}
		if (children != null)
		{
			EffectSilencerSelect effectSilencerSelect = default(EffectSilencerSelect);
			foreach (BaseEntity child in children)
			{
				ProjectileWeaponMod projectileWeaponMod = child as ProjectileWeaponMod;
				if ((Object)(object)projectileWeaponMod == (Object)null)
				{
					continue;
				}
				if (projectileWeaponMod.isSilencer)
				{
					resourcePath = projectileWeaponMod.defaultSilencerEffect.resourcePath;
					if (silencedAttack.isValid)
					{
						resourcePath = silencedAttack.resourcePath;
						GameObject val = silencedAttack.Get();
						if ((Object)(object)val != (Object)null && val.TryGetComponent<EffectSilencerSelect>(ref effectSilencerSelect) && effectSilencerSelect.GetEffectForSilencerType(projectileWeaponMod.silencerType, out var result))
						{
							resourcePath = result.resourcePath;
						}
					}
					break;
				}
				if (projectileWeaponMod.isMuzzleBrake)
				{
					if (muzzleBrakeAttack.isValid)
					{
						resourcePath = muzzleBrakeAttack.resourcePath;
					}
					break;
				}
			}
		}
		return resourcePath;
	}

	public override bool CanUseNetworkCache(Connection sendingTo)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null || ownerPlayer.net == null)
		{
			return true;
		}
		if (ownerPlayer.IsBeingSpectated)
		{
			return false;
		}
		Connection connection = ownerPlayer.net.connection;
		if (sendingTo == null || connection == null)
		{
			return true;
		}
		return sendingTo != connection;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.baseProjectile = Pool.Get<BaseProjectile>();
		if (info.forDisk || info.SendingTo(GetOwnerConnection()) || ForceSendMagazine(info))
		{
			info.msg.baseProjectile.primaryMagazine = primaryMagazine.Save();
		}
	}

	public virtual bool ForceSendMagazine(SaveInfo saveInfo)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (Object.op_Implicit((Object)(object)ownerPlayer) && ownerPlayer.IsBeingSpectated)
		{
			foreach (BaseEntity child in ownerPlayer.children)
			{
				if (child.net != null && child.net.connection == saveInfo.forConnection)
				{
					return true;
				}
			}
		}
		return false;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.baseProjectile != null && info.msg.baseProjectile.primaryMagazine != null)
		{
			primaryMagazine.Load(info.msg.baseProjectile.primaryMagazine);
		}
	}
}


using System;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

[Serializable]
public class Magazine
{
	[Serializable]
	public struct Definition
	{
		[Tooltip("Set to 0 to not use inbuilt mag")]
		public int builtInSize;

		[Tooltip("If using inbuilt mag, will accept these types of ammo")]
		[InspectorFlags]
		public AmmoTypes ammoTypes;
	}

	public Definition definition;

	public int capacity;

	public int contents;

	[ItemSelector]
	public ItemDefinition ammoType;

	public bool allowPlayerReloading = true;

	public bool allowAmmoSwitching = true;

	public void ServerInit()
	{
		if (definition.builtInSize > 0)
		{
			capacity = definition.builtInSize;
		}
	}

	public Magazine Save()
	{
		Magazine val = Pool.Get<Magazine>();
		if ((Object)(object)ammoType == (Object)null)
		{
			val.capacity = capacity;
			val.contents = 0;
			val.ammoType = 0;
		}
		else
		{
			val.capacity = capacity;
			val.contents = contents;
			val.ammoType = ammoType.itemid;
		}
		return val;
	}

	public void Load(Magazine mag)
	{
		contents = mag.contents;
		capacity = mag.capacity;
		ammoType = ItemManager.FindItemDefinition(mag.ammoType);
	}

	public bool CanReload(IAmmoContainer ammoSource)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		if (contents >= capacity)
		{
			return false;
		}
		return ammoSource.HasAmmo(definition.ammoTypes);
	}
}


using System;
using Rust;
using UnityEngine;

[Serializable]
public struct Definition
{
	[Tooltip("Set to 0 to not use inbuilt mag")]
	public int builtInSize;

	[Tooltip("If using inbuilt mag, will accept these types of ammo")]
	[InspectorFlags]
	public AmmoTypes ammoTypes;
}


public static class BaseProjectileFlags
{
	public const Flags BurstToggle = Flags.Reserved6;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.MarchingCubes;
using LZ4;
using Network;
using ProtoBuf;
using Rust;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Assertions;

public class BaseSculpture : IOEntity, IServerFileReceiver, IUGCBrowserEntity, ISplashable, IDisposable
{
	[Serializable]
	public struct ColorSetting
	{
		public GameObject toggleObj;

		public Phrase name;

		public Phrase desc;

		public Color color;

		[ColorUsage(false, true)]
		public Color materialColor;
	}

	[Header("BaseSculpture")]
	[SerializeField]
	private MeshFilter targetMesh;

	[SerializeField]
	private MeshCollider clientMeshCollider;

	[SerializeField]
	private Renderer clientBlockRenderer;

	[SerializeField]
	private DamageType carvingDamageType;

	[SerializeField]
	private Vector3Int gridResolution = new Vector3Int(32, 32, 32);

	[SerializeField]
	private Vector3 gridOffset;

	[SerializeField]
	private float gridScale;

	[SerializeField]
	private GameObjectRef blockImpactEffect;

	[SerializeField]
	private Collider blockerCollider;

	[SerializeField]
	[Header("HitGuide")]
	private GameObject hitGuide;

	[SerializeField]
	private GameObject carvingGuide;

	[SerializeField]
	private GameObject smoothingGuide;

	[SerializeField]
	private float guideLerpSpeed = 5f;

	[SerializeField]
	private Vector3 carveColorMultiplier;

	[SerializeField]
	private Vector3 smoothColorMultiplier;

	[SerializeField]
	[Header("IO")]
	private ColorSetting[] colorSettings;

	[SerializeField]
	private Renderer[] lightRenderers;

	[SerializeField]
	private Material noLightMaterial;

	[SerializeField]
	private Material lightMaterial;

	public const int CarveDepth = 3;

	private Point3DGrid _grid;

	private uint _crc = uint.MaxValue;

	private int _currentColorIndex;

	private bool _hasMovementBlocker;

	private Transform _movementBlockerTransform;

	private int _cachedMaxY;

	private int _carveRadius;

	private int _minCarveRadius;

	private int _maxCarveRadius;

	private static readonly byte[] _decompressArr = new byte[8192];

	[ClientVar(Default = "false")]
	public static bool LogMeshStats = false;

	private static readonly ListHashSet<BaseSculpture> ServerUpdateProcessQueue = new ListHashSet<BaseSculpture>();

	private bool _gridDirty;

	private Action _resetSplashedThisFrame;

	private bool _splashedThisFrame;

	private int CarveRadius
	{
		get
		{
			return _carveRadius;
		}
		set
		{
			_carveRadius = math.clamp(value, _minCarveRadius, _maxCarveRadius);
		}
	}

	public uint[] GetContentCRCs => new uint[1] { _crc };

	public UGCType ContentType => UGCType.Sculpt;

	public List<ulong> EditingHistory => new List<ulong> { base.OwnerID };

	public BaseNetworkable UgcEntity => this;

	public string ContentString => string.Empty;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseSculpture.OnRpcMessage", 0);
		try
		{
			if (rpc == 3180266995u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_Add "));
				}
				TimeWarning val2 = TimeWarning.New("SV_Add", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3180266995u, "SV_Add", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SV_Add(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SV_Add");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 737203553 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_Carve "));
				}
				TimeWarning val2 = TimeWarning.New("SV_Carve", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(737203553u, "SV_Carve", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SV_Carve(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SV_Carve");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3650562316u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_LoadFromData "));
				}
				TimeWarning val2 = TimeWarning.New("SV_LoadFromData", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3650562316u, "SV_LoadFromData", this, player, 1uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							SV_LoadFromData(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in SV_LoadFromData");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4267718869u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_LockSculpture "));
				}
				TimeWarning val2 = TimeWarning.New("SV_LockSculpture", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4267718869u, "SV_LockSculpture", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							SV_LockSculpture(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in SV_LockSculpture");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2374043062u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_SetColorIndex "));
				}
				TimeWarning val2 = TimeWarning.New("SV_SetColorIndex", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2374043062u, "SV_SetColorIndex", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							SV_SetColorIndex(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in SV_SetColorIndex");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2622097655u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_Smooth "));
				}
				TimeWarning val2 = TimeWarning.New("SV_Smooth", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2622097655u, "SV_Smooth", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg7 = rPCMessage;
							SV_Smooth(msg7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in SV_Smooth");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1358295833 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_UnlockSculpture "));
				}
				TimeWarning val2 = TimeWarning.New("SV_UnlockSculpture", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1358295833u, "SV_UnlockSculpture", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg8 = rPCMessage;
							SV_UnlockSculpture(msg8);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex7)
					{
						Debug.LogException(ex7);
						player.Kick("RPC Error in SV_UnlockSculpture");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		base.InitShared();
		_grid = new Point3DGrid(((Vector3Int)(ref gridResolution)).x, ((Vector3Int)(ref gridResolution)).y, ((Vector3Int)(ref gridResolution)).z);
		_hasMovementBlocker = (Object)(object)blockerCollider != (Object)null;
		if (_hasMovementBlocker)
		{
			_movementBlockerTransform = ((Component)blockerCollider).transform;
			_cachedMaxY = ((Vector3Int)(ref gridResolution)).y - 1;
		}
	}

	public override void ServerInit()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (_crc == uint.MaxValue)
		{
			FillGrid(_grid);
		}
		else
		{
			byte[] array = FileStorage.server.Get(_crc, FileStorage.Type.sculpt, net.ID);
			if (array == null)
			{
				Debug.LogError((object)"Missing sculpt data on-disk - fill with default");
				FillGrid(_grid);
			}
			else
			{
				PopulateGridFromEncodedData(array);
			}
		}
		MarkServerGridUpdate();
		_resetSplashedThisFrame = ResetSplashedThisFrame;
	}

	public bool CanUpdateSculpture(BasePlayer player)
	{
		if (IsLocked())
		{
			return false;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		return true;
	}

	public override void OnAttacked(HitInfo info)
	{
		if (info.damageTypes.Contains(carvingDamageType) && base.isServer)
		{
			info.DidHit = false;
			info.DoHitEffects = false;
		}
		else
		{
			base.OnAttacked(info);
		}
	}

	private void PopulateGridFromEncodedData(byte[] encoded)
	{
		int count = LZ4Codec.Decode(encoded, 0, encoded.Length, _decompressArr, 0, _decompressArr.Length, false);
		_grid.CopyFromByteArray(_decompressArr, count);
	}

	private static void FillGrid(Point3DGrid grid)
	{
		for (int i = 1; i < grid.Width - 1; i++)
		{
			for (int j = 1; j < grid.Height - 1; j++)
			{
				for (int k = 1; k < grid.Depth - 1; k++)
				{
					grid[i, j, k] = true;
				}
			}
		}
	}

	private int3 GetInBlockSpace(Vector3 worldSpace)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return new int3(GetInBlockSpaceFloat(worldSpace));
	}

	private float3 GetInBlockSpaceFloat(Vector3 worldSpace)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)clientMeshCollider).transform.InverseTransformPoint(worldSpace);
		Vector3 val2 = new Vector3((float)((Vector3Int)(ref gridResolution)).x, (float)((Vector3Int)(ref gridResolution)).y, (float)((Vector3Int)(ref gridResolution)).z) * 0.5f;
		return float3.op_Implicit(val * (1f / gridScale) + (val2 + gridOffset));
	}

	private Vector3 GetInWorldSpace(int3 blockSpace)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = new Vector3((float)((Vector3Int)(ref gridResolution)).x, (float)((Vector3Int)(ref gridResolution)).y, (float)((Vector3Int)(ref gridResolution)).z) * 0.5f;
		Vector3 val2 = (float3.op_Implicit(float3.op_Implicit(blockSpace)) - (val + gridOffset)) * gridScale;
		return ((Component)clientMeshCollider).transform.TransformPoint(val2);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.baseSculpture = Pool.Get<BaseSculpture>();
		info.msg.baseSculpture.crc = _crc;
		info.msg.baseSculpture.colourSelection = _currentColorIndex;
	}

	public override void Load(LoadInfo info)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.baseSculpture == null)
		{
			return;
		}
		uint crc = _crc;
		_ = _currentColorIndex;
		_crc = info.msg.baseSculpture.crc;
		_currentColorIndex = info.msg.baseSculpture.colourSelection;
		if (base.isServer && info.fromDisk && crc != _crc)
		{
			byte[] array = FileStorage.server.Get(_crc, FileStorage.Type.sculpt, net.ID);
			if (array == null)
			{
				Debug.LogError((object)"Missing sculpt data on-disk - fill with default");
				FillGrid(_grid);
			}
			else
			{
				PopulateGridFromEncodedData(array);
				MarkServerGridUpdate();
			}
		}
	}

	private void UpdateMovementBlocker()
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("UpdateMovementBlocker", 0);
		try
		{
			if (_hasMovementBlocker)
			{
				int num = FindMaxY();
				if (num <= 0)
				{
					blockerCollider.enabled = false;
					return;
				}
				float num2 = (float)num / (float)((Vector3Int)(ref gridResolution)).y;
				_movementBlockerTransform.localScale = Vector3Ex.WithY(_movementBlockerTransform.localScale, num2);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		int FindMaxY()
		{
			for (int num3 = _cachedMaxY; num3 >= 0; num3--)
			{
				for (int i = 0; i < ((Vector3Int)(ref gridResolution)).x; i++)
				{
					for (int j = 0; j < ((Vector3Int)(ref gridResolution)).z; j++)
					{
						if (_grid[i, num3, j])
						{
							_cachedMaxY = num3;
							return num3;
						}
					}
				}
			}
			return -1;
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		Dispose();
	}

	public void Dispose()
	{
		_grid.Dispose();
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void SV_SetColorIndex(RPCMessage msg)
	{
		if (CanUpdateSculpture(msg.player))
		{
			int num = msg.read.Int32();
			if (num >= 0 && num < colorSettings.Length)
			{
				_currentColorIndex = num;
				SendNetworkUpdate();
			}
		}
	}

	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server]
	public void SV_LoadFromData(RPCMessage msg)
	{
		if (msg.player.IsAdmin && msg.player.IsDeveloper)
		{
			ArraySegment<byte> arraySegment = msg.read.BytesSegmentWithSize(6291456u, false);
			int count = LZ4Codec.Decode(arraySegment.Array, arraySegment.Offset, arraySegment.Count, _decompressArr, 0, _decompressArr.Length, false);
			_grid.CopyFromByteArray(_decompressArr, count);
			MarkServerGridUpdate();
		}
	}

	private bool TryGetHeldCarvingAttributeServer(BasePlayer player, out SculptingToolData attribute)
	{
		attribute = null;
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		HeldEntity heldEntity = player.GetHeldEntity();
		if ((Object)(object)heldEntity == (Object)null)
		{
			return false;
		}
		attribute = PrefabAttribute.server.Find<SculptingToolData>(heldEntity.prefabID);
		if (attribute == null)
		{
			return false;
		}
		return true;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void SV_Add(RPCMessage msg)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (CanUpdateSculpture(msg.player))
		{
			Vector3 worldSpacePosition = msg.read.Vector3();
			if (TryGetHeldCarvingAttributeServer(msg.player, out var attribute) && attribute.AllowCarve)
			{
				int r = Mathf.Clamp(msg.read.Int32(), attribute.MinCarvingSize, attribute.MaxCarvingSize);
				AddSphere(worldSpacePosition, r);
			}
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void SV_Carve(RPCMessage msg)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		if (!CanUpdateSculpture(msg.player))
		{
			return;
		}
		Vector3 worldSpacePosition = msg.read.Vector3();
		if (TryGetHeldCarvingAttributeServer(msg.player, out var attribute) && attribute.AllowCarve)
		{
			int r = Mathf.Clamp(msg.read.Int32(), attribute.MinCarvingSize, attribute.MaxCarvingSize);
			switch (attribute.CarvingShape)
			{
			case SculptingToolData.CarvingShapeType.Cylinder:
				CarveCylinder(worldSpacePosition, msg.player.eyes.HeadForward(), r, 3);
				break;
			case SculptingToolData.CarvingShapeType.Sphere:
				CarveSphere(worldSpacePosition, r);
				break;
			case SculptingToolData.CarvingShapeType.Rectangle:
				break;
			}
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void SV_Smooth(RPCMessage msg)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		if (!CanUpdateSculpture(msg.player))
		{
			return;
		}
		Vector3 worldSpacePosition = msg.read.Vector3();
		if (TryGetHeldCarvingAttributeServer(msg.player, out var attribute) && attribute.AllowSmooth)
		{
			int r = Mathf.Clamp(msg.read.Int32(), attribute.MinCarvingSize, attribute.MaxCarvingSize);
			switch (attribute.CarvingShape)
			{
			case SculptingToolData.CarvingShapeType.Cylinder:
				SmoothCylinder(worldSpacePosition, msg.player.eyes.HeadForward(), r, 3);
				break;
			case SculptingToolData.CarvingShapeType.Sphere:
				SmoothSphere(worldSpacePosition, r);
				break;
			case SculptingToolData.CarvingShapeType.Rectangle:
				break;
			}
		}
	}

	private void CarveCylinder(Vector3 worldSpacePosition, Vector3 worldSpaceView, int r, int depth)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)clientMeshCollider).transform.InverseTransformDirection(worldSpaceView);
		float3 inBlockSpaceFloat = GetInBlockSpaceFloat(worldSpacePosition);
		CarveAndBlurCylinderJob carveAndBlurCylinderJob = default(CarveAndBlurCylinderJob);
		carveAndBlurCylinderJob.Grid = _grid;
		carveAndBlurCylinderJob.P0 = inBlockSpaceFloat;
		carveAndBlurCylinderJob.P1 = inBlockSpaceFloat + float3.op_Implicit(val) * (float)depth;
		carveAndBlurCylinderJob.R = r;
		CarveAndBlurCylinderJob carveAndBlurCylinderJob2 = carveAndBlurCylinderJob;
		IJobExtensions.RunByRef<CarveAndBlurCylinderJob>(ref carveAndBlurCylinderJob2);
		MarkServerGridUpdate();
	}

	private void SmoothCylinder(Vector3 worldSpacePosition, Vector3 worldSpaceView, int r, int depth)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)clientMeshCollider).transform.InverseTransformDirection(worldSpaceView);
		float3 inBlockSpaceFloat = GetInBlockSpaceFloat(worldSpacePosition);
		BoxBlurCylinderJob boxBlurCylinderJob = default(BoxBlurCylinderJob);
		boxBlurCylinderJob.Grid = _grid;
		boxBlurCylinderJob.P0 = inBlockSpaceFloat;
		boxBlurCylinderJob.P1 = inBlockSpaceFloat + float3.op_Implicit(val) * (float)depth;
		boxBlurCylinderJob.R = r;
		BoxBlurCylinderJob boxBlurCylinderJob2 = boxBlurCylinderJob;
		IJobExtensions.RunByRef<BoxBlurCylinderJob>(ref boxBlurCylinderJob2);
		MarkServerGridUpdate();
	}

	private void AddSphere(Vector3 worldSpacePosition, int r)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		int3 inBlockSpace = GetInBlockSpace(worldSpacePosition);
		AddAndBlurSphereJob addAndBlurSphereJob = default(AddAndBlurSphereJob);
		addAndBlurSphereJob.Grid = _grid;
		addAndBlurSphereJob.Origin = inBlockSpace;
		addAndBlurSphereJob.R = r;
		AddAndBlurSphereJob addAndBlurSphereJob2 = addAndBlurSphereJob;
		IJobExtensions.RunByRef<AddAndBlurSphereJob>(ref addAndBlurSphereJob2);
		MarkServerGridUpdate();
	}

	private void CarveSphere(Vector3 worldSpacePosition, int r)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		int3 inBlockSpace = GetInBlockSpace(worldSpacePosition);
		CarveAndBlurSphereJob carveAndBlurSphereJob = default(CarveAndBlurSphereJob);
		carveAndBlurSphereJob.Grid = _grid;
		carveAndBlurSphereJob.Origin = inBlockSpace;
		carveAndBlurSphereJob.R = r;
		CarveAndBlurSphereJob carveAndBlurSphereJob2 = carveAndBlurSphereJob;
		IJobExtensions.RunByRef<CarveAndBlurSphereJob>(ref carveAndBlurSphereJob2);
		MarkServerGridUpdate();
	}

	private void SmoothSphere(Vector3 worldSpacePosition, int r)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		int3 inBlockSpace = GetInBlockSpace(worldSpacePosition);
		BoxBlurSphereJob boxBlurSphereJob = default(BoxBlurSphereJob);
		boxBlurSphereJob.Grid = _grid;
		boxBlurSphereJob.Origin = inBlockSpace;
		boxBlurSphereJob.R = r;
		BoxBlurSphereJob boxBlurSphereJob2 = boxBlurSphereJob;
		IJobExtensions.RunByRef<BoxBlurSphereJob>(ref boxBlurSphereJob2);
		MarkServerGridUpdate();
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		if (!IsLocked())
		{
			return (Object)(object)splashType != (Object)(object)WaterTypes.RadioactiveWaterItemDef;
		}
		return false;
	}

	private void ResetSplashedThisFrame()
	{
		_splashedThisFrame = false;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		if (_splashedThisFrame)
		{
			return 0;
		}
		if (amount < 200)
		{
			return amount;
		}
		_splashedThisFrame = true;
		((FacepunchBehaviour)this).Invoke(_resetSplashedThisFrame, 0f);
		Debug.Log((object)"Splash");
		if ((Object)(object)splashType == (Object)(object)WaterTypes.WaterItemDef)
		{
			NativeBitArray other = default(NativeBitArray);
			((NativeBitArray)(ref other))..ctor(_grid.Length, AllocatorHandle.op_Implicit((Allocator)3), (NativeArrayOptions)0);
			BoxBlur3DJob boxBlur3DJob = default(BoxBlur3DJob);
			boxBlur3DJob.InputGrid = _grid;
			boxBlur3DJob.OutputGrid = other;
			boxBlur3DJob.Width = _grid.Width;
			boxBlur3DJob.WidthHeight = _grid.Width * _grid.Height;
			BoxBlur3DJob boxBlur3DJob2 = boxBlur3DJob;
			IJobForExtensions.RunByRef<BoxBlur3DJob>(ref boxBlur3DJob2, _grid.Length);
			_grid.CopyFromNativeBitArray(ref other);
			((NativeBitArray)(ref other)).Dispose();
			MarkServerGridUpdate();
		}
		return 200;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void SV_LockSculpture(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSculpture(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void SV_UnlockSculpture(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSculpture(msg.player))
		{
			SetFlag(Flags.Locked, b: false);
		}
	}

	private void MarkServerGridUpdate()
	{
		if (!_gridDirty)
		{
			_gridDirty = true;
			ServerUpdateProcessQueue.Add(this);
		}
	}

	private JobHandle ScheduleRemoveIslandsFromGrid()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		CleanFloatingIslandsJob cleanFloatingIslandsJob = default(CleanFloatingIslandsJob);
		cleanFloatingIslandsJob.Sampler = _grid;
		return IJobExtensions.Schedule<CleanFloatingIslandsJob>(cleanFloatingIslandsJob, default(JobHandle));
	}

	public static void ProcessGridUpdates()
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		if (ServerUpdateProcessQueue.Count == 0)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("RemoveIslandsFromGrid", 0);
		try
		{
			NativeArray<JobHandle> val2 = default(NativeArray<JobHandle>);
			val2..ctor(ServerUpdateProcessQueue.Count, (Allocator)2, (NativeArrayOptions)1);
			for (int i = 0; i < ServerUpdateProcessQueue.Count; i++)
			{
				BaseSculpture baseSculpture = ServerUpdateProcessQueue[i];
				if (!((Object)(object)baseSculpture == (Object)null))
				{
					val2[i] = baseSculpture.ScheduleRemoveIslandsFromGrid();
				}
			}
			JobHandle.CompleteAll(val2);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("FileUpdates", 0);
		try
		{
			for (int j = 0; j < ServerUpdateProcessQueue.Count; j++)
			{
				BaseSculpture baseSculpture2 = ServerUpdateProcessQueue[j];
				if (!((Object)(object)baseSculpture2 == (Object)null))
				{
					baseSculpture2.ServerGridUpdate();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		ServerUpdateProcessQueue.Clear();
	}

	private void ServerGridUpdate()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		byte[] arr = FileStorage.server.Get(_crc, FileStorage.Type.sculpt, net.ID);
		bool num = arr != null;
		if (!num)
		{
			arr = Array.Empty<byte>();
		}
		_grid.CopyToByteArray(ref arr);
		if (num)
		{
			FileStorage.server.Remove(_crc, FileStorage.Type.sculpt, net.ID);
		}
		arr = LZ4Codec.Encode(arr, 0, arr.Length);
		_crc = FileStorage.server.Store(arr, FileStorage.Type.sculpt, net.ID);
		InvalidateNetworkCache();
		ClientRPC(RpcTarget.NetworkGroup("CL_UpdateCrc"), _crc);
		UpdateMovementBlocker();
		_gridDirty = false;
	}

	public override void OnPickedUpPreItemMove(Item createdItem, BasePlayer player)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		base.OnPickedUpPreItemMove(createdItem, player);
		ItemModSculpture itemModSculpture = default(ItemModSculpture);
		if (_crc != uint.MaxValue && ((Component)createdItem.info).TryGetComponent<ItemModSculpture>(ref itemModSculpture))
		{
			itemModSculpture.OnSculpturePickUp(net.ID, _crc, createdItem);
		}
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		base.OnDeployed(parent, deployedBy, fromItem);
		if (!((Component)(object)fromItem.info).HasComponent<ItemModSculpture>())
		{
			return;
		}
		AssociatedSculptureStorage associatedEntity = ItemModAssociatedEntity<AssociatedSculptureStorage>.GetAssociatedEntity(fromItem);
		if ((Object)(object)associatedEntity != (Object)null)
		{
			_crc = associatedEntity.Crc;
			FileStorage.server.ReassignEntityId(associatedEntity.net.ID, net.ID);
			byte[] array = FileStorage.server.Get(_crc, FileStorage.Type.sculpt, net.ID);
			if (array == null)
			{
				Debug.LogError((object)"Missing sculpt data on-disk - fill with default");
				FillGrid(_grid);
			}
			else
			{
				PopulateGridFromEncodedData(array);
				InvalidateNetworkCache();
				ClientRPC(RpcTarget.NetworkGroup("CL_UpdateCrc"), _crc);
			}
		}
	}

	public void ClearContent()
	{
		FillGrid(_grid);
		MarkServerGridUpdate();
	}

	internal override void DoServerDestroy()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		base.DoServerDestroy();
		FileStorage.server.RemoveAllByEntity(net.ID);
	}

	public override void ResetIOState()
	{
		base.ResetIOState();
		SetFlag(Flags.On, b: false);
	}

	public override void UpdateFromInput(int inputAmount, int inputSlot)
	{
		base.UpdateFromInput(inputAmount, inputSlot);
		SetFlag(Flags.On, IsPowered());
	}
}


using System;
using UnityEngine;

[Serializable]
public struct ColorSetting
{
	public GameObject toggleObj;

	public Phrase name;

	public Phrase desc;

	public Color color;

	[ColorUsage(false, true)]
	public Color materialColor;
}


using System;
using System.Collections.Generic;
using ConVar;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public abstract class BaseSiegeWeapon : GroundVehicle, IEngineControllerUser, IEntity, VehicleChassisVisuals<BaseSiegeWeapon>.IClientWheelUser, TriggerHurtNotChild.IHurtTriggerUser, CarPhysics<BaseSiegeWeapon>.ICar, ITowing
{
	public SimpleCarVisualsController controller;

	[SerializeField]
	[Header("Siege Weapon")]
	protected Transform centreOfMassTransform;

	[SerializeField]
	protected CarSettings carSettings;

	public VisualCarWheel[] wheels;

	[Header("Towing")]
	public Transform towAnchor;

	[SerializeField]
	[Header("Pulling")]
	private List<ModifierDefintion> pullingPlayerModifiers;

	public const Flags Flag_IsPulled = Flags.Reserved12;

	private BasePlayer pullingPlayer;

	private float _mass = -1f;

	protected CarPhysics<BaseSiegeWeapon> carPhysics;

	private bool disablePhysics;

	[ServerVar(Help = "How many minutes before a siege weapon loses all its health while outside")]
	public static float outsideDecayMinutes = 600f;

	private const float DECAY_TICK_TIME = 60f;

	private const float INSIDE_DECAY_MULTIPLIER = 0.1f;

	private float lastUseTime;

	private TimeSince timeSinceDragModSet;

	private VehicleTerrainHandler terrainHandler;

	private Vector3 localPullPosition;

	private Vector3 lastPlayerPosition;

	private float playerMovementThreshold = 0.01f;

	public virtual float SteerAngle { get; }

	public virtual float MaxSteerAngle { get; }

	public SiegeWeaponVehicleAudio vehicleAudio => (SiegeWeaponVehicleAudio)gvAudio;

	private float Mass
	{
		get
		{
			if (base.isServer)
			{
				return rigidBody.mass;
			}
			return _mass;
		}
	}

	public bool IsTowing => HasFlag(Flags.Reserved14);

	public bool IsTowingAllowed => CheckTowingAllowed();

	public BaseEntity TowEntity => this;

	public Transform TowAnchor => towAnchor;

	public Rigidbody TowBody => rigidBody;

	public VehicleTerrainHandler.Surface OnSurface
	{
		get
		{
			if (terrainHandler == null)
			{
				return VehicleTerrainHandler.Surface.Default;
			}
			return terrainHandler.OnSurface;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseSiegeWeapon.OnRpcMessage", 0);
		try
		{
			if (rpc == 3106222818u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_StartPulling "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_StartPulling", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3106222818u, "SERVER_StartPulling", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_StartPulling(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_StartPulling");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1702315436 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_StopPulling "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_StopPulling", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						SERVER_StopPulling(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in SERVER_StopPulling");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override float GetThrottleInput()
	{
		return 0f;
	}

	public override float GetBrakeInput()
	{
		if (base.isServer)
		{
			if (!IsTowing)
			{
				return 1f;
			}
			return 0f;
		}
		return 1f;
	}

	public override float GetMaxForwardSpeed()
	{
		return GetMaxDriveForce() / Mass * 2f;
	}

	public virtual float GetMaxDriveForce()
	{
		return 100f;
	}

	public virtual float GetSteerInput()
	{
		return 0f;
	}

	public virtual bool IsWaterlogged()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)waterloggedPoint != (Object)null)
		{
			return WaterLevel.Test(waterloggedPoint.position, waves: true, volumes: true, this);
		}
		return false;
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		if (!base.CanPushNow(pusher))
		{
			return false;
		}
		if (HasFlag(Flags.Reserved12))
		{
			return false;
		}
		if (pusher.isMounted || pusher.IsSwimming())
		{
			return false;
		}
		return !pusher.IsStandingOnEntity(this, 8192);
	}

	protected virtual bool CanPullNow(BasePlayer puller)
	{
		if (HasFlag(Flags.Reserved12) || (Object)(object)pullingPlayer != (Object)null)
		{
			return false;
		}
		if (puller.isMounted || puller.IsSwimming())
		{
			return false;
		}
		if (!puller.IsStandingOnEntity(this, 8192))
		{
			return puller.CanInteract();
		}
		return false;
	}

	public override void ServerInit()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		rigidBody.centerOfMass = centreOfMassTransform.localPosition;
		carPhysics = new CarPhysics<BaseSiegeWeapon>(this, ((Component)this).transform, rigidBody, carSettings);
		terrainHandler = new VehicleTerrainHandler(this);
		lastUseTime = Time.realtimeSinceStartup;
		if (!disablePhysics)
		{
			rigidBody.isKinematic = false;
		}
		((FacepunchBehaviour)this).InvokeRandomized((Action)DecayTick, Random.Range(30f, 60f), 60f, 6f);
	}

	private void DecayTick()
	{
		if (base.IsDestroyed)
		{
			return;
		}
		float num = 1f;
		num /= outsideDecayMinutes;
		if (!(Time.time < lastUseTime + 300f))
		{
			if (!IsOutside())
			{
				num *= 0.1f;
			}
			Hurt(MaxHealth() * num, DamageType.Decay);
		}
	}

	public void RefreshLastUseTime()
	{
		lastUseTime = Time.time;
	}

	public void DisablePhysics()
	{
		disablePhysics = true;
		rigidBody.isKinematic = true;
	}

	public void EnablePhysics()
	{
		disablePhysics = false;
		rigidBody.isKinematic = false;
		rigidBody.WakeUp();
	}

	public virtual bool CheckTowingAllowed()
	{
		return !IsTowing;
	}

	public virtual void OnTowAttach()
	{
		EnablePhysics();
		carSettings.disableHandbrakes = true;
		carSettings.canSleep = false;
	}

	public virtual void OnTowDetach()
	{
		carSettings.disableHandbrakes = false;
		carSettings.canSleep = true;
	}

	public override void VehicleFixedUpdate()
	{
		base.VehicleFixedUpdate();
		float speed = GetSpeed();
		carPhysics.FixedUpdate(Time.fixedDeltaTime, speed);
		terrainHandler.FixedUpdate();
	}

	public virtual bool GetSteerSpeedMod(float speed)
	{
		return false;
	}

	public virtual float GetSteerMaxMult(float speed)
	{
		return 1f;
	}

	public virtual float GetAdjustedDriveForce(float absSpeed, float topSpeed)
	{
		float maxDriveForce = GetMaxDriveForce();
		float num = Mathf.Lerp(0.3f, 0.75f, GetPerformanceFraction());
		float num2 = MathEx.BiasedLerp(1f - absSpeed / topSpeed, num);
		return maxDriveForce * num2;
	}

	public virtual float GetPerformanceFraction()
	{
		float num = Mathf.InverseLerp(0.25f, 0.5f, base.healthFraction);
		return Mathf.Lerp(0.5f, 1f, num);
	}

	public virtual CarWheel[] GetWheels()
	{
		return wheels;
	}

	public virtual float GetWheelsMidPos()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		return (((Component)wheels[0].wheelCollider).transform.localPosition.z - ((Component)wheels[2].wheelCollider).transform.localPosition.z) * 0.5f;
	}

	public override void OnDied(HitInfo info = null)
	{
		if (HasFlag(Flags.Reserved12) && (Object)(object)pullingPlayer != (Object)null)
		{
			StopPulling();
		}
		base.OnDied(info);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void SERVER_StartPulling(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPullNow(player) && !((Object)(object)rigidBody == (Object)null) && Interface.CallHook("OnSiegeWeaponPull", (object)this, (object)msg.player) == null && (!OnlyOwnerAccessible() || !((Object)(object)player != (Object)(object)creatorEntity)))
		{
			player.metabolism.calories.Subtract(3f);
			player.metabolism.SendChangesToClient();
			if (rigidBody.IsSleeping())
			{
				rigidBody.WakeUp();
			}
			StartPulling(player);
		}
	}

	[RPC_Server]
	public void SERVER_StopPulling(RPCMessage msg)
	{
		if (!((Object)(object)msg.player != (Object)(object)pullingPlayer))
		{
			StopPulling();
		}
	}

	private void StartPulling(BasePlayer player)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		localPullPosition = ((Component)this).transform.InverseTransformPoint(((Component)player).transform.position);
		lastPlayerPosition = ((Component)player).transform.position;
		pullingPlayer = player;
		if ((Object)(object)pullingPlayer != (Object)null)
		{
			PlayerModifiers.AddToPlayer(pullingPlayer, pullingPlayerModifiers);
		}
		SetFlag(Flags.Reserved12, b: true);
		carSettings.disableHandbrakes = true;
		((FacepunchBehaviour)this).InvokeRepeating((Action)DoPullAction, 0f, 0f);
	}

	private void StopPulling()
	{
		if ((Object)(object)pullingPlayer != (Object)null)
		{
			pullingPlayer.modifiers.RemoveFromSource(Modifier.ModifierSource.Interaction);
		}
		ClientRPC(RpcTarget.NetworkGroup("CLIENT_StopPulling"));
		pullingPlayer = null;
		SetFlag(Flags.Reserved12, b: false);
		carSettings.disableHandbrakes = false;
		((FacepunchBehaviour)this).CancelInvoke((Action)DoPullAction);
	}

	protected virtual void DoPullAction()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody == (Object)null || (Object)(object)pullingPlayer == (Object)null)
		{
			StopPulling();
			return;
		}
		Vector3 position = ((Component)pullingPlayer).transform.position;
		Vector3 val = ((Component)this).transform.TransformPoint(localPullPosition);
		if (Vector3.Distance(position, val) >= 1f || pullingPlayer.IsDead() || pullingPlayer.IsSleeping())
		{
			StopPulling();
			return;
		}
		Vector3 val2 = ((Component)pullingPlayer).transform.position - lastPlayerPosition;
		lastPlayerPosition = ((Component)pullingPlayer).transform.position;
		if (((Vector3)(ref val2)).magnitude > playerMovementThreshold)
		{
			Vector3 val3 = rigidBody.velocity;
			if (((Vector3)(ref val3)).magnitude < 1.5f)
			{
				val3 = position - val;
				Vector3 normalized = ((Vector3)(ref val3)).normalized;
				float mass = rigidBody.mass;
				rigidBody.AddForceAtPosition(normalized * mass, val, (ForceMode)0);
			}
		}
	}

	void IEngineControllerUser.Invoke(Action action, float time)
	{
		((FacepunchBehaviour)this).Invoke(action, time);
	}

	void IEngineControllerUser.CancelInvoke(Action action)
	{
		((FacepunchBehaviour)this).CancelInvoke(action);
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using Sonar;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Serialization;
using VLB;

public class BaseSubmarine : BaseVehicle, IEngineControllerUser, IEntity, IAirSupply, IPoolVehicle
{
	[SerializeField]
	[Header("Submarine Main")]
	private Transform centreOfMassTransform;

	[SerializeField]
	public Buoyancy buoyancy;

	[SerializeField]
	public float maxRudderAngle = 35f;

	[SerializeField]
	private Transform rudderVisualTransform;

	[SerializeField]
	private Transform rudderDetailedColliderTransform;

	[SerializeField]
	private Transform propellerTransform;

	[SerializeField]
	public float timeUntilAutoSurface = 300f;

	[SerializeField]
	private Renderer[] interiorRenderers;

	[SerializeField]
	private SonarObject sonarObject;

	[SerializeField]
	private GameObjectRef fuelStoragePrefab;

	[Header("Submarine Engine & Fuel")]
	[SerializeField]
	public float engineKW = 200f;

	[SerializeField]
	public float turnPower = 0.25f;

	[SerializeField]
	public float engineStartupTime = 0.5f;

	[SerializeField]
	private GameObjectRef itemStoragePrefab;

	[SerializeField]
	public float depthChangeTargetSpeed = 1f;

	[SerializeField]
	public float idleFuelPerSec = 0.03f;

	[SerializeField]
	public float maxFuelPerSec = 0.15f;

	[FormerlySerializedAs("internalAccessFuelTank")]
	[SerializeField]
	private bool internalAccessStorage;

	[SerializeField]
	[Header("Submarine Weaponry")]
	public GameObjectRef torpedoStoragePrefab;

	[SerializeField]
	public Transform torpedoFiringPoint;

	[FormerlySerializedAs("maxFireRate")]
	[SerializeField]
	public float reloadTime = 1.5f;

	[Header("Submarine Audio & FX")]
	[SerializeField]
	protected SubmarineAudio submarineAudio;

	[SerializeField]
	private ParticleSystem fxTorpedoFire;

	[SerializeField]
	private GameObject internalFXContainer;

	[SerializeField]
	private GameObject internalOnFXContainer;

	[SerializeField]
	private ParticleSystem fxIntAmbientBubbleLoop;

	[SerializeField]
	private ParticleSystem fxIntInitialDiveBubbles;

	[SerializeField]
	private ParticleSystem fxIntWaterDropSpray;

	[SerializeField]
	private ParticleSystem fxIntWindowFilm;

	[SerializeField]
	private ParticleSystemContainer fxIntMediumDamage;

	[SerializeField]
	private ParticleSystemContainer fxIntHeavyDamage;

	[SerializeField]
	private GameObject externalFXContainer;

	[SerializeField]
	private GameObject externalOnFXContainer;

	[SerializeField]
	private ParticleSystem fxExtAmbientBubbleLoop;

	[SerializeField]
	private ParticleSystem fxExtInitialDiveBubbles;

	[SerializeField]
	private ParticleSystem fxExtAboveWaterEngineThrustForward;

	[SerializeField]
	private ParticleSystem fxExtAboveWaterEngineThrustReverse;

	[SerializeField]
	private ParticleSystem fxExtUnderWaterEngineThrustForward;

	[SerializeField]
	private ParticleSystem[] fxExtUnderWaterEngineThrustForwardSubs;

	[SerializeField]
	private ParticleSystem fxExtUnderWaterEngineThrustReverse;

	[SerializeField]
	private ParticleSystem[] fxExtUnderWaterEngineThrustReverseSubs;

	[SerializeField]
	private ParticleSystem fxExtBowWave;

	[SerializeField]
	private ParticleSystem fxExtWakeEffect;

	[SerializeField]
	public GameObjectRef aboveWatercollisionEffect;

	[SerializeField]
	public GameObjectRef underWatercollisionEffect;

	[SerializeField]
	private VolumetricLightBeam spotlightVolumetrics;

	[SerializeField]
	private float mountedAlphaInside = 0.04f;

	[SerializeField]
	private float mountedAlphaOutside = 0.015f;

	[ServerVar(Help = "How long before a submarine loses all its health while outside. If it's in deep water, deepwaterdecayminutes is used")]
	public static float outsidedecayminutes = 180f;

	[ServerVar(Help = "How long before a submarine loses all its health while in deep water")]
	public static float deepwaterdecayminutes = 120f;

	[ServerVar(Help = "How long a submarine can stay underwater until players start taking damage from low oxygen")]
	public static float oxygenminutes = 10f;

	public const Flags Flag_Ammo = Flags.Reserved6;

	private float _throttle;

	private float _rudder;

	private float _upDown;

	private float _oxygen = 1f;

	public VehicleEngineController<BaseSubmarine> engineController;

	public float cachedFuelAmount;

	protected Vector3 steerAngle;

	public float waterSurfaceY;

	public float curSubDepthY;

	public EntityRef<StorageContainer> torpedoStorageInstance;

	private EntityRef<StorageContainer> itemStorageInstance;

	public int waterLayerMask;

	public float targetClimbSpeed;

	public float maxDamageThisTick;

	private float nextCollisionDamageTime;

	private bool prevPrimaryFireInput;

	private bool primaryFireInput;

	private const float DECAY_TICK_TIME = 60f;

	public TimeSince timeSinceLastUsed;

	public TimeSince timeSinceTorpedoFired;

	private TimeSince timeSinceFailRPCSent;

	private float normalDrag;

	private float highDrag;

	private bool wasOnSurface;

	public ItemModGiveOxygen.AirSupplyType AirType => ItemModGiveOxygen.AirSupplyType.Submarine;

	public VehicleEngineController<BaseSubmarine>.EngineState EngineState => engineController.CurEngineState;

	public Vector3 Velocity { get; private set; }

	public bool LightsAreOn => HasFlag(Flags.Reserved5);

	public bool HasAmmo => HasFlag(Flags.Reserved6);

	public float ThrottleInput
	{
		get
		{
			if (!engineController.IsOn)
			{
				return 0f;
			}
			return _throttle;
		}
		protected set
		{
			_throttle = Mathf.Clamp(value, -1f, 1f);
		}
	}

	public float RudderInput
	{
		get
		{
			return _rudder;
		}
		protected set
		{
			_rudder = Mathf.Clamp(value, -1f, 1f);
		}
	}

	public float UpDownInput
	{
		get
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			if (base.isServer)
			{
				if (TimeSince.op_Implicit(timeSinceLastUsed) >= timeUntilAutoSurface)
				{
					return 0.15f;
				}
				if (!engineController.IsOn)
				{
					return Mathf.Max(0f, _upDown);
				}
				return _upDown;
			}
			return _upDown;
		}
		protected set
		{
			_upDown = Mathf.Clamp(value, -1f, 1f);
		}
	}

	public float Oxygen
	{
		get
		{
			return _oxygen;
		}
		protected set
		{
			_oxygen = Mathf.Clamp(value, 0f, 1f);
		}
	}

	protected float PhysicalRudderAngle
	{
		get
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			float num = rudderDetailedColliderTransform.localEulerAngles.y;
			if (num > 180f)
			{
				num -= 360f;
			}
			return num;
		}
	}

	protected bool IsInWater => curSubDepthY > 0.2f;

	protected bool IsSurfaced => curSubDepthY < 1.1f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseSubmarine.OnRpcMessage", 0);
		try
		{
			if (rpc == 1851540757 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuel "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_OpenFuel(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_OpenFuel");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 924237371 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenItemStorage "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenItemStorage", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(924237371u, "RPC_OpenItemStorage", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_OpenItemStorage(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_OpenItemStorage");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2181221870u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenTorpedoStorage "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenTorpedoStorage", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2181221870u, "RPC_OpenTorpedoStorage", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RPC_OpenTorpedoStorage(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_OpenTorpedoStorage");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void InitShared()
	{
		base.InitShared();
		waterLayerMask = LayerMask.GetMask(new string[1] { "Water" });
		EntityFuelSystem fuelSystem = new EntityFuelSystem(base.isServer, fuelStoragePrefab, children);
		engineController = new VehicleEngineController<BaseSubmarine>(this, fuelSystem, base.isServer, engineStartupTime);
	}

	public override void Load(LoadInfo info)
	{
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.submarine != null)
		{
			ThrottleInput = info.msg.submarine.throttle;
			UpDownInput = info.msg.submarine.upDown;
			RudderInput = info.msg.submarine.rudder;
			engineController.FuelSystem.SetInstanceID(info.msg.submarine.fuelStorageID);
			cachedFuelAmount = info.msg.submarine.fuelAmount;
			torpedoStorageInstance.uid = info.msg.submarine.torpedoStorageID;
			Oxygen = info.msg.submarine.oxygen;
			itemStorageInstance.uid = info.msg.submarine.itemStorageID;
			UpdatePhysicalRudder(RudderInput, 0f);
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (old != next && base.isServer)
		{
			ServerFlagsChanged(old, next);
		}
	}

	public override float WaterFactorForPlayer(BasePlayer player, out WaterLevel.WaterInfo info)
	{
		info = default(WaterLevel.WaterInfo);
		return 0f;
	}

	public override float AirFactor()
	{
		return Oxygen;
	}

	public override bool BlocksWaterFor(BasePlayer player)
	{
		return (Object)(object)player.GetMountedVehicle() == (Object)(object)this;
	}

	public float GetFuelAmount()
	{
		if (base.isServer)
		{
			return engineController.FuelSystem.GetFuelAmount();
		}
		return cachedFuelAmount;
	}

	public override float GetSpeed()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (IsStationary())
		{
			return 0f;
		}
		return Vector3.Dot(Velocity, ((Component)this).transform.forward);
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!base.CanBeLooted(player))
		{
			return false;
		}
		if (PlayerIsMounted(player))
		{
			return base.CanBeLooted(player);
		}
		if (internalAccessStorage)
		{
			return false;
		}
		if (!IsOn())
		{
			return base.CanBeLooted(player);
		}
		return false;
	}

	public float GetAirTimeRemaining(Item forItem)
	{
		if (Oxygen <= 0.5f)
		{
			return 0f;
		}
		return Mathf.InverseLerp(0.5f, 1f, Oxygen) * oxygenminutes * 60f;
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		if (!base.CanPushNow(pusher))
		{
			return false;
		}
		if (pusher.isMounted || pusher.IsSwimming() || !pusher.IsOnGround())
		{
			return false;
		}
		return !pusher.IsStandingOnEntity(this, 8192);
	}

	private void UpdatePhysicalRudder(float turnInput, float deltaTime)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		float num = (0f - turnInput) * maxRudderAngle;
		float num2 = ((!base.IsMovingOrOn) ? num : Mathf.MoveTowards(PhysicalRudderAngle, num, 200f * deltaTime));
		Quaternion localRotation = Quaternion.Euler(0f, num2, 0f);
		if (base.isClient)
		{
			rudderVisualTransform.localRotation = localRotation;
		}
		rudderDetailedColliderTransform.localRotation = localRotation;
	}

	private bool CanMount(BasePlayer player)
	{
		return !player.IsDead();
	}

	private void UpdateWaterInfo()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		waterSurfaceY = GetWaterSurfaceY();
		curSubDepthY = waterSurfaceY - ((Component)this).transform.position.y;
	}

	private float GetWaterSurfaceY()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(((Component)this).transform.position - Vector3.up * 1.5f, Vector3.up, ref val, 5f, waterLayerMask, (QueryTriggerInteraction)2))
		{
			return ((RaycastHit)(ref val)).point.y;
		}
		WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(((Component)this).transform.position, waves: true, volumes: true, this);
		if (!waterInfo.isValid)
		{
			return ((Component)this).transform.position.y - 1f;
		}
		return waterInfo.surfaceLevel;
	}

	public override void ServerInit()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		rigidBody.centerOfMass = centreOfMassTransform.localPosition;
		timeSinceLastUsed = TimeSince.op_Implicit(timeUntilAutoSurface);
		buoyancy.buoyancyScale = 1f;
		normalDrag = rigidBody.drag;
		highDrag = normalDrag * 2.5f;
		Oxygen = 1f;
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateClients, 0f, 0.15f, 0.02f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)SubmarineDecay, Random.Range(30f, 60f), 60f, 6f);
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer)
		{
			if (isSpawned)
			{
				GetFuelSystem().CheckNewChild(child);
			}
			if (child.prefabID == itemStoragePrefab.GetEntity().prefabID)
			{
				itemStorageInstance.Set((StorageContainer)child);
			}
			if (child.prefabID == torpedoStoragePrefab.GetEntity().prefabID)
			{
				torpedoStorageInstance.Set((StorageContainer)child);
			}
		}
	}

	private void ServerFlagsChanged(Flags old, Flags next)
	{
		if (next.HasFlag(Flags.On) && !old.HasFlag(Flags.On))
		{
			SetFlag(Flags.Reserved5, b: true);
		}
	}

	internal override void DoServerDestroy()
	{
		if (vehicle.vehiclesdroploot)
		{
			StorageContainer storageContainer = itemStorageInstance.Get(base.isServer);
			if ((Object)(object)storageContainer != (Object)null && storageContainer.IsValid())
			{
				storageContainer.DropItems();
			}
		}
		base.DoServerDestroy();
	}

	protected void OnCollisionEnter(Collision collision)
	{
		if (!base.isClient)
		{
			ProcessCollision(collision);
		}
	}

	public override float MaxVelocity()
	{
		return 10f;
	}

	public override IFuelSystem GetFuelSystem()
	{
		return engineController.FuelSystem;
	}

	public override int StartingFuelUnits()
	{
		return 50;
	}

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (CanMount(player) && MountEligable(player))
		{
			BaseMountable baseMountable = ((HasDriver() || player.IsRestrained) ? GetIdealMountPointFor(player) : mountPoints[0].mountable);
			if ((Object)(object)baseMountable != (Object)null)
			{
				baseMountable.AttemptMount(player, doMountChecks);
			}
			if (PlayerIsMounted(player))
			{
				PlayerMounted(player, baseMountable);
			}
		}
	}

	public void OnPoolDestroyed()
	{
		Kill(DestroyMode.Gib);
	}

	public void WakeUp()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody != (Object)null)
		{
			rigidBody.WakeUp();
			rigidBody.AddForce(Vector3.up * 0.1f, (ForceMode)1);
		}
	}

	protected override void OnServerWake()
	{
		if ((Object)(object)buoyancy != (Object)null)
		{
			buoyancy.Wake();
		}
	}

	public override void OnDied(HitInfo info)
	{
		DamageType majorityDamageType = info.damageTypes.GetMajorityDamageType();
		if (majorityDamageType == DamageType.Explosion || majorityDamageType == DamageType.AntiVehicle)
		{
			foreach (MountPointInfo mountPoint in mountPoints)
			{
				if ((Object)(object)mountPoint.mountable != (Object)null)
				{
					BasePlayer mounted = mountPoint.mountable.GetMounted();
					if ((Object)(object)mounted != (Object)null)
					{
						mounted.Hurt(10000f, DamageType.Explosion, this, useProtection: false);
					}
				}
			}
		}
		base.OnDied(info);
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0340: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03da: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_059a: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0549: Unknown result type (might be due to invalid IL or missing references)
		//IL_0560: Unknown result type (might be due to invalid IL or missing references)
		//IL_0565: Unknown result type (might be due to invalid IL or missing references)
		//IL_04eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0512: Unknown result type (might be due to invalid IL or missing references)
		//IL_0517: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BaseSubmarine.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (!base.IsMovingOrOn)
			{
				Velocity = Vector3.zero;
				targetClimbSpeed = 0f;
				buoyancy.ArtificialHeight = null;
				return;
			}
			Velocity = GetLocalVelocity();
			UpdateWaterInfo();
			if (IsSurfaced && !wasOnSurface && ((Component)this).transform.position.y > Env.oceanlevel - 1f)
			{
				wasOnSurface = true;
			}
			buoyancy.ArtificialHeight = waterSurfaceY;
			rigidBody.drag = (HasDriver() ? normalDrag : highDrag);
			float num = 2f;
			if (IsSurfaced)
			{
				float num2 = 20f * num;
				if (Oxygen < 0.5f)
				{
					Oxygen = 0.5f;
				}
				else
				{
					Oxygen += Time.deltaTime / num2;
				}
			}
			else if (AnyMounted())
			{
				float num3 = oxygenminutes * 60f * num;
				Oxygen -= Time.deltaTime / num3;
			}
			engineController.CheckEngineState();
			if (engineController.IsOn)
			{
				float fuelPerSecond = Mathf.Lerp(idleFuelPerSec, maxFuelPerSec, Mathf.Abs(ThrottleInput));
				engineController.TickFuel(fuelPerSecond);
			}
			if (IsInWater)
			{
				float num4 = depthChangeTargetSpeed * UpDownInput;
				float num5 = (((!(UpDownInput > 0f) || !(num4 > targetClimbSpeed) || !(targetClimbSpeed > 0f)) && (!(UpDownInput < 0f) || !(num4 < targetClimbSpeed) || !(targetClimbSpeed < 0f))) ? 4f : 0.7f);
				targetClimbSpeed = Mathf.MoveTowards(targetClimbSpeed, num4, num5 * Time.fixedDeltaTime);
				float num6 = rigidBody.velocity.y - targetClimbSpeed;
				float num7 = buoyancy.buoyancyScale - num6 * 50f * Time.fixedDeltaTime;
				buoyancy.buoyancyScale = Mathf.Clamp(num7, 0.01f, 1f);
				Vector3 angularVelocity = rigidBody.angularVelocity;
				Vector3 val2 = Vector3.Cross(Quaternion.AngleAxis(((Vector3)(ref angularVelocity)).magnitude * 57.29578f * 10f / 200f, rigidBody.angularVelocity) * ((Component)this).transform.up, Vector3.up) * 200f * 200f;
				rigidBody.AddTorque(val2);
				float num8 = 0.1f;
				rigidBody.AddForce(Vector3.up * (0f - num6) * num8, (ForceMode)2);
			}
			else
			{
				float num9 = 0f;
				buoyancy.buoyancyScale = Mathf.Lerp(buoyancy.buoyancyScale, num9, Time.fixedDeltaTime);
			}
			if (IsOn() && IsInWater)
			{
				rigidBody.AddForce(((Component)this).transform.forward * engineKW * 40f * ThrottleInput, (ForceMode)0);
				float num10 = turnPower * rigidBody.mass * rigidBody.angularDrag;
				float speed = GetSpeed();
				float num11 = Mathf.Min(Mathf.Abs(speed) * 0.6f, 6f) + 4f;
				float num12 = num10 * RudderInput * num11;
				if (speed < -1f)
				{
					num12 *= -1f;
				}
				rigidBody.AddTorque(((Component)this).transform.up * num12, (ForceMode)0);
			}
			UpdatePhysicalRudder(RudderInput, Time.fixedDeltaTime);
			if (Time.time >= nextCollisionDamageTime && maxDamageThisTick > 0f)
			{
				nextCollisionDamageTime = Time.time + 0.33f;
				Hurt(maxDamageThisTick, DamageType.Collision, this, useProtection: false);
				maxDamageThisTick = 0f;
			}
			StorageContainer torpedoContainer = GetTorpedoContainer();
			if ((Object)(object)torpedoContainer != (Object)null)
			{
				bool b = torpedoContainer.inventory.HasAmmo((AmmoTypes)1024);
				SetFlag(Flags.Reserved6, b);
			}
			BasePlayer driver = GetDriver();
			if ((Object)(object)driver != (Object)null && primaryFireInput)
			{
				bool flag = true;
				if (IsInWater && TimeSince.op_Implicit(timeSinceTorpedoFired) >= reloadTime)
				{
					if (driver.InSafeZone())
					{
						timeSinceTorpedoFired = TimeSince.op_Implicit(0f);
					}
					else
					{
						float minSpeed = GetSpeed() + 2f;
						if (TryFireProjectile(torpedoContainer, (AmmoTypes)1024, torpedoFiringPoint.position, torpedoFiringPoint.forward, driver, 1f, minSpeed, out var _))
						{
							timeSinceTorpedoFired = TimeSince.op_Implicit(0f);
							flag = false;
							driver.MarkHostileFor();
							ClientRPC(RpcTarget.NetworkGroup("TorpedoFired"));
						}
					}
				}
				if (!prevPrimaryFireInput && flag && TimeSince.op_Implicit(timeSinceFailRPCSent) > 0.5f)
				{
					timeSinceFailRPCSent = TimeSince.op_Implicit(0f);
					ClientRPC(RpcTarget.Player("TorpedoFireFailed", driver));
				}
			}
			else if ((Object)(object)driver == (Object)null)
			{
				primaryFireInput = false;
			}
			prevPrimaryFireInput = primaryFireInput;
			if (TimeSince.op_Implicit(timeSinceLastUsed) > 300f && LightsAreOn)
			{
				SetFlag(Flags.Reserved5, b: false);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void LightToggle(BasePlayer player)
	{
		if (IsDriver(player))
		{
			SetFlag(Flags.Reserved5, !LightsAreOn);
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		timeSinceLastUsed = TimeSince.op_Implicit(0f);
		if (IsDriver(player))
		{
			if (inputState.IsDown(BUTTON.SPRINT))
			{
				UpDownInput = 1f;
			}
			else if (inputState.IsDown(BUTTON.DUCK))
			{
				UpDownInput = -1f;
			}
			else
			{
				UpDownInput = 0f;
			}
			if (inputState.IsDown(BUTTON.FORWARD))
			{
				ThrottleInput = 1f;
			}
			else if (inputState.IsDown(BUTTON.BACKWARD))
			{
				ThrottleInput = -1f;
			}
			else
			{
				ThrottleInput = 0f;
			}
			if (inputState.IsDown(BUTTON.LEFT))
			{
				RudderInput = -1f;
			}
			else if (inputState.IsDown(BUTTON.RIGHT))
			{
				RudderInput = 1f;
			}
			else
			{
				RudderInput = 0f;
			}
			primaryFireInput = inputState.IsDown(BUTTON.FIRE_PRIMARY);
			if (engineController.IsOff && ((inputState.IsDown(BUTTON.FORWARD) && !inputState.WasDown(BUTTON.FORWARD)) || (inputState.IsDown(BUTTON.BACKWARD) && !inputState.WasDown(BUTTON.BACKWARD)) || (inputState.IsDown(BUTTON.SPRINT) && !inputState.WasDown(BUTTON.SPRINT)) || (inputState.IsDown(BUTTON.DUCK) && !inputState.WasDown(BUTTON.DUCK))))
			{
				engineController.TryStartEngine(player);
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.submarine = Pool.Get<Submarine>();
		info.msg.submarine.throttle = ThrottleInput;
		info.msg.submarine.upDown = UpDownInput;
		info.msg.submarine.rudder = RudderInput;
		info.msg.submarine.fuelStorageID = GetFuelSystem().GetInstanceID();
		info.msg.submarine.fuelAmount = GetFuelAmount();
		info.msg.submarine.torpedoStorageID = torpedoStorageInstance.uid;
		info.msg.submarine.oxygen = Oxygen;
		info.msg.submarine.itemStorageID = itemStorageInstance.uid;
	}

	public bool MeetsEngineRequirements()
	{
		return AnyMounted();
	}

	public void OnEngineStartFailed()
	{
		ClientRPC(RpcTarget.NetworkGroup("EngineStartFailed"));
	}

	public StorageContainer GetTorpedoContainer()
	{
		BaseEntity baseEntity = torpedoStorageInstance.Get(base.isServer);
		if ((Object)(object)baseEntity != (Object)null && baseEntity.IsValid())
		{
			return baseEntity as StorageContainer;
		}
		return null;
	}

	public StorageContainer GetItemContainer()
	{
		BaseEntity baseEntity = itemStorageInstance.Get(base.isServer);
		if ((Object)(object)baseEntity != (Object)null && baseEntity.IsValid())
		{
			return baseEntity as StorageContainer;
		}
		return null;
	}

	private void ProcessCollision(Collision collision)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient && collision != null && !((Object)(object)collision.gameObject == (Object)null) && !((Object)(object)collision.gameObject == (Object)null))
		{
			Vector3 impulse = collision.impulse;
			float num = ((Vector3)(ref impulse)).magnitude / Time.fixedDeltaTime;
			float num2 = Mathf.InverseLerp(100000f, 2500000f, num);
			if (num2 > 0f)
			{
				float num3 = Mathf.Lerp(1f, 200f, num2);
				maxDamageThisTick = Mathf.Max(maxDamageThisTick, num3);
			}
			if (num2 > 0f)
			{
				TryShowCollisionFX(collision, GetCollisionFX());
			}
		}
	}

	public override GameObjectRef GetCollisionFX()
	{
		if (!(curSubDepthY > 2f))
		{
			return aboveWatercollisionEffect;
		}
		return underWatercollisionEffect;
	}

	public void UpdateClients()
	{
		if (HasDriver())
		{
			byte num = (byte)((ThrottleInput + 1f) * 7f);
			byte b = (byte)((UpDownInput + 1f) * 7f);
			byte arg = (byte)(num + (b << 4));
			int arg2 = Mathf.CeilToInt(GetFuelAmount());
			ClientRPC(RpcTarget.NetworkGroup("SubmarineUpdate"), RudderInput, arg, arg2, Oxygen);
		}
	}

	public void SubmarineDecay()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		BaseBoat.WaterVehicleDecay(this, 60f, TimeSince.op_Implicit(timeSinceLastUsed), outsidedecayminutes, deepwaterdecayminutes, MotorRowboat.decaystartdelayminutes, preventDecayIndoors: true);
	}

	[RPC_Server]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((!IsSafe() || !((Object)(object)player != (Object)(object)creatorEntity)) && CanBeLooted(player))
		{
			GetFuelSystem().LootFuel(player);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_OpenTorpedoStorage(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanBeLooted(player) && PlayerIsMounted(player))
		{
			StorageContainer torpedoContainer = GetTorpedoContainer();
			if ((Object)(object)torpedoContainer != (Object)null)
			{
				torpedoContainer.PlayerOpenLoot(player);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_OpenItemStorage(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanBeLooted(player))
		{
			StorageContainer itemContainer = GetItemContainer();
			if ((Object)(object)itemContainer != (Object)null)
			{
				itemContainer.PlayerOpenLoot(player);
			}
		}
	}

	public void OnSurfacedInMoonpool()
	{
		if (wasOnSurface && GameInfo.HasAchievements)
		{
			wasOnSurface = false;
			BasePlayer driver = GetDriver();
			if ((Object)(object)driver != (Object)null)
			{
				driver.GiveAchievement("SUBMARINE_MOONPOOL");
			}
		}
	}

	void IEngineControllerUser.Invoke(Action action, float time)
	{
		((FacepunchBehaviour)this).Invoke(action, time);
	}

	void IEngineControllerUser.CancelInvoke(Action action)
	{
		((FacepunchBehaviour)this).CancelInvoke(action);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Serialization;

public class BaseVehicle : BaseMountable, VehicleSpawner.IVehicleSpawnUser
{
	public enum DismountStyle
	{
		Closest,
		Ordered
	}

	[Serializable]
	public class MountPointInfo
	{
		public bool isDriver;

		public Vector3 pos;

		public Vector3 rot;

		public string bone = "";

		public GameObjectRef prefab;

		[NonSerialized]
		[HideInInspector]
		public BaseMountable mountable;
	}

	public enum RagdollMode
	{
		Collide,
		FallThrough
	}

	public enum ClippingCheckMode
	{
		OnMountOnly,
		Always
	}

	public readonly struct Enumerable : IEnumerable<MountPointInfo>, IEnumerable
	{
		private readonly BaseVehicle _vehicle;

		public Enumerable(BaseVehicle vehicle)
		{
			if ((Object)(object)vehicle == (Object)null)
			{
				throw new ArgumentNullException("vehicle");
			}
			_vehicle = vehicle;
		}

		public Enumerator GetEnumerator()
		{
			return new Enumerator(_vehicle);
		}

		IEnumerator<MountPointInfo> IEnumerable<MountPointInfo>.GetEnumerator()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	public struct Enumerator : IEnumerator<MountPointInfo>, IEnumerator, IDisposable
	{
		private enum State
		{
			Direct,
			EnterChild,
			EnumerateChild,
			Finished
		}

		private class Box : IPooled
		{
			public Enumerator Value;

			public void EnterPool()
			{
				Value = default(Enumerator);
			}

			public void LeavePool()
			{
				Value = default(Enumerator);
			}
		}

		private readonly BaseVehicle _vehicle;

		private State _state;

		private int _index;

		private int _childIndex;

		private Box _enumerator;

		public MountPointInfo Current { get; private set; }

		object IEnumerator.Current => Current;

		public Enumerator(BaseVehicle vehicle)
		{
			if ((Object)(object)vehicle == (Object)null)
			{
				throw new ArgumentNullException("vehicle");
			}
			_vehicle = vehicle;
			_state = State.Direct;
			_index = -1;
			_childIndex = -1;
			_enumerator = null;
			Current = null;
		}

		public bool MoveNext()
		{
			Current = null;
			switch (_state)
			{
			case State.Direct:
				_index++;
				if (_index >= _vehicle.mountPoints.Count)
				{
					_state = State.EnterChild;
					goto case State.EnterChild;
				}
				Current = _vehicle.mountPoints[_index];
				return true;
			case State.EnterChild:
				do
				{
					_childIndex++;
				}
				while (_childIndex < _vehicle.childVehicles.Count && (Object)(object)_vehicle.childVehicles[_childIndex] == (Object)null);
				if (_childIndex >= _vehicle.childVehicles.Count)
				{
					_state = State.Finished;
					return false;
				}
				_enumerator = Pool.Get<Box>();
				_enumerator.Value = _vehicle.childVehicles[_childIndex].allMountPoints.GetEnumerator();
				_state = State.EnumerateChild;
				goto case State.EnumerateChild;
			case State.EnumerateChild:
				if (_enumerator.Value.MoveNext())
				{
					Current = _enumerator.Value.Current;
					return true;
				}
				_enumerator.Value.Dispose();
				Pool.Free<Box>(ref _enumerator);
				_state = State.EnterChild;
				goto case State.EnterChild;
			case State.Finished:
				return false;
			default:
				throw new NotSupportedException();
			}
		}

		public void Dispose()
		{
			if (_enumerator != null)
			{
				_enumerator.Value.Dispose();
				Pool.Free<Box>(ref _enumerator);
			}
		}

		public void Reset()
		{
			throw new NotSupportedException();
		}
	}

	[Tooltip("Check for vehicles clipping into our mount point as well as static stuff")]
	[Header("Base Vehicle")]
	public bool checkVehicleClipping;

	[Tooltip("Exclude any problematic physics layers from colliding with this vehicle. Requires a DoPrepare to update")]
	public LayerMask excludeCollisionLayers;

	[Tooltip("Closest: Play will use the closest valid dismount point.\nOrdered: Player will use the first valid dismount point in the dismount array.")]
	public DismountStyle dismountStyle;

	public bool shouldShowHudHealth;

	public bool ignoreDamageFromOutside;

	[Header("Base Vehicle - Mount Points")]
	public List<MountPointInfo> mountPoints;

	public RagdollMode mountedPlayerRagdolls;

	public ClippingCheckMode clippingChecks;

	[Header("Base Vehicle - Damage")]
	public DamageRenderer damageRenderer;

	[FormerlySerializedAs("explosionDamageMultiplier")]
	public float explosionForceMultiplier = 100f;

	public float explosionForceMax = 10000f;

	public const Flags Flag_OnlyOwnerEntry = Flags.Locked;

	public const Flags Flag_Headlights = Flags.Reserved5;

	public const Flags Flag_Stationary = Flags.Reserved7;

	public const Flags Flag_SeatsFull = Flags.Reserved11;

	public const Flags Flag_HasDriver = Flags.Reserved17;

	[Header("Base Vehicle - Priv")]
	public bool HasBuildingPrivilege;

	protected const Flags Flag_AnyMounted = Flags.InUse;

	private readonly List<BaseVehicle> childVehicles = new List<BaseVehicle>(0);

	private const float MIN_TIME_BETWEEN_PUSHES = 1f;

	public TimeSince timeSinceLastPush;

	private bool prevSleeping;

	private float nextCollisionFXTime;

	private CollisionDetectionMode savedCollisionDetectionMode;

	private BaseVehicle pendingLoad;

	public Queue<BasePlayer> recentDrivers = new Queue<BasePlayer>();

	public Action clearRecentDriverAction;

	public float safeAreaRadius;

	public Vector3 safeAreaOrigin;

	public float spawnTime = -1f;

	public bool IsMovingOrOn
	{
		get
		{
			if (!IsMoving())
			{
				return IsOn();
			}
			return true;
		}
	}

	public override float RealisticMass
	{
		get
		{
			if ((Object)(object)rigidBody != (Object)null)
			{
				return rigidBody.mass;
			}
			return base.RealisticMass;
		}
	}

	public Enumerable allMountPoints => new Enumerable(this);

	public bool IsClient => base.isClient;

	public virtual bool AlwaysAllowBradleyTargeting => false;

	protected bool RecentlyPushed => TimeSince.op_Implicit(timeSinceLastPush) < 1f;

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	protected virtual bool CanSwapSeats => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseVehicle.OnRpcMessage", 0);
		try
		{
			if (rpc == 2115395408 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_WantsPush "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_WantsPush", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2115395408u, "RPC_WantsPush", this, player, 5f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_WantsPush(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_WantsPush");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsStationary()
	{
		return HasFlag(Flags.Reserved7);
	}

	public bool IsMoving()
	{
		return !HasFlag(Flags.Reserved7);
	}

	public bool IsAuthed(BasePlayer player)
	{
		foreach (BaseEntity child in children)
		{
			VehiclePrivilege vehiclePrivilege = child as VehiclePrivilege;
			if (!((Object)(object)vehiclePrivilege == (Object)null))
			{
				return vehiclePrivilege.IsAuthed(player);
			}
		}
		return false;
	}

	public override bool AnyMounted()
	{
		return HasFlag(Flags.InUse);
	}

	public override bool PlayerIsMounted(BasePlayer player)
	{
		if (player.IsValid())
		{
			return (Object)(object)player.GetMountedVehicle() == (Object)(object)this;
		}
		return false;
	}

	public virtual bool CanPushNow(BasePlayer pusher)
	{
		return !IsOn();
	}

	public bool HasMountPoints()
	{
		if (mountPoints.Count > 0)
		{
			return true;
		}
		using (Enumerator enumerator = allMountPoints.GetEnumerator())
		{
			if (enumerator.MoveNext())
			{
				_ = enumerator.Current;
				return true;
			}
		}
		return false;
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (IsAlive() && !base.IsDestroyed)
		{
			return (Object)(object)player != (Object)null;
		}
		return false;
	}

	public bool IsFlipping()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (IsFlipped())
		{
			return false;
		}
		bool flag = false;
		if ((Object)(object)rigidBody != (Object)null)
		{
			Vector3 angularVelocity = rigidBody.angularVelocity;
			flag = angularVelocity.x > 0.5f || angularVelocity.z > 0.5f;
		}
		float num = Vector3.Dot(Vector3.up, ((Component)this).transform.up);
		return flag || num <= 0.4f;
	}

	public bool IsFlipped()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Dot(Vector3.up, ((Component)this).transform.up) <= 0.175f;
	}

	public virtual bool IsVehicleRoot()
	{
		return true;
	}

	public override bool DirectlyMountable()
	{
		return IsVehicleRoot();
	}

	public override BaseVehicle VehicleParent()
	{
		return null;
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (!IsDead() && !base.IsDestroyed && child is BaseVehicle baseVehicle && !baseVehicle.IsVehicleRoot() && !childVehicles.Contains(baseVehicle))
		{
			childVehicles.Add(baseVehicle);
		}
	}

	protected override void OnChildRemoved(BaseEntity child)
	{
		base.OnChildRemoved(child);
		if (child is BaseVehicle baseVehicle && !baseVehicle.IsVehicleRoot())
		{
			childVehicles.Remove(baseVehicle);
		}
	}

	public MountPointInfo GetMountPoint(int index)
	{
		if (index < 0)
		{
			return null;
		}
		if (index < mountPoints.Count)
		{
			return mountPoints[index];
		}
		index -= mountPoints.Count;
		int num = 0;
		foreach (BaseVehicle childVehicle in childVehicles)
		{
			if ((Object)(object)childVehicle == (Object)null)
			{
				continue;
			}
			foreach (MountPointInfo allMountPoint in childVehicle.allMountPoints)
			{
				if (num == index)
				{
					return allMountPoint;
				}
				num++;
			}
		}
		return null;
	}

	public override float GetSpeed()
	{
		if (IsStationary())
		{
			return 0f;
		}
		return base.GetSpeed();
	}

	public override float PenetrationResistance(HitInfo info)
	{
		if (info != null && (Object)(object)info.ProjectilePrefab != (Object)null && info.ProjectilePrefab.penetratesVehicles)
		{
			return 0.5f;
		}
		return base.PenetrationResistance(info);
	}

	public override void OnAttacked(HitInfo info)
	{
		if (IsSafe() && !info.damageTypes.Has(DamageType.Decay))
		{
			info.damageTypes.ScaleAll(0f);
		}
		base.OnAttacked(info);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		ClearOwnerEntry();
		CheckAndSpawnMountPoints();
		((FacepunchBehaviour)this).Invoke((Action)DisableTransferProtectionIfEmpty, 0f);
	}

	public override void Save(SaveInfo info)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (!base.isServer || !info.forDisk)
		{
			return;
		}
		info.msg.baseVehicle = Pool.Get<BaseVehicle>();
		info.msg.baseVehicle.mountPoints = Pool.Get<List<MountPoint>>();
		for (int i = 0; i < mountPoints.Count; i++)
		{
			MountPointInfo mountPointInfo = mountPoints[i];
			if (!((Object)(object)mountPointInfo.mountable == (Object)null))
			{
				MountPoint val = Pool.Get<MountPoint>();
				val.index = i;
				val.mountableId = mountPointInfo.mountable.net.ID;
				info.msg.baseVehicle.mountPoints.Add(val);
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (base.isServer && info.fromDisk && info.msg.baseVehicle != null)
		{
			BaseVehicle obj = pendingLoad;
			if (obj != null)
			{
				obj.Dispose();
			}
			pendingLoad = info.msg.baseVehicle;
			info.msg.baseVehicle = null;
		}
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override void VehicleFixedUpdate()
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BaseVehicle.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (clippingChecks == ClippingCheckMode.Always && AnyMounted() && Physics.OverlapBox(((Component)this).transform.TransformPoint(((Bounds)(ref bounds)).center), ((Bounds)(ref bounds)).extents, ((Component)this).transform.rotation, GetClipCheckMask()).Length != 0)
			{
				CheckSeatsForClipping();
			}
			if ((Object)(object)rigidBody != (Object)null)
			{
				SetFlag(Flags.Reserved7, DetermineIfStationary());
				bool flag = rigidBody.IsSleeping();
				if (prevSleeping && !flag)
				{
					OnServerWake();
				}
				else if (!prevSleeping && flag)
				{
					OnServerSleep();
				}
				prevSleeping = flag;
			}
			if (OnlyOwnerAccessible() && safeAreaRadius != -1f && Vector3.Distance(((Component)this).transform.position, safeAreaOrigin) > safeAreaRadius)
			{
				ClearOwnerEntry();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected override int GetClipCheckMask()
	{
		int num = (IsFlipped() ? 1218511105 : 1210122497);
		if (!Physics.treecollision)
		{
			num &= -1073741825;
		}
		if (checkVehicleClipping)
		{
			num |= 0x2000;
		}
		return num;
	}

	protected virtual bool DetermineIfStationary()
	{
		if (rigidBody.IsSleeping())
		{
			return !AnyMounted();
		}
		return false;
	}

	public override Vector3 GetLocalVelocityServer()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody == (Object)null)
		{
			return Vector3.zero;
		}
		return rigidBody.velocity;
	}

	public override Quaternion GetAngularVelocityServer()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody == (Object)null)
		{
			return Quaternion.identity;
		}
		return Quaternion.Euler(rigidBody.angularVelocity * 57.29578f);
	}

	public virtual int StartingFuelUnits()
	{
		IFuelSystem fuelSystem = GetFuelSystem();
		if (fuelSystem != null)
		{
			return Mathf.FloorToInt((float)fuelSystem.GetFuelCapacity() * 0.2f);
		}
		return 0;
	}

	public virtual bool IsSeatVisible(BaseMountable mountable, Vector3 eyePos, int mask = 1218511105)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (!clippingAndVisChecks)
		{
			return true;
		}
		if ((Object)(object)mountable == (Object)null)
		{
			return false;
		}
		Vector3 p = ((Component)mountable).transform.position + ((Component)this).transform.up * 0.15f;
		return GamePhysics.LineOfSight(eyePos, p, mask);
	}

	protected override bool IsSeatClipping(BaseMountable mountable, Vector3 startPos, float radius, int mask, Vector3 seatPos, Vector3 direction)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (!checkVehicleClipping)
		{
			return base.IsSeatClipping(mountable, startPos, radius, mask, seatPos, direction);
		}
		List<Collider> list = Pool.Get<List<Collider>>();
		if (clippingChecksLocation == ClippingCheckLocation.HeadOnly)
		{
			GamePhysics.OverlapSphere(startPos, radius, list, mask, (QueryTriggerInteraction)1);
		}
		else
		{
			Vector3 point = seatPos + direction * (radius + 0.05f);
			GamePhysics.OverlapCapsule(startPos, point, radius, list, mask, (QueryTriggerInteraction)1);
		}
		foreach (Collider item in list)
		{
			BaseEntity baseEntity = item.ToBaseEntity();
			if ((Object)(object)baseEntity != (Object)(object)this && !EqualNetID((BaseNetworkable)baseEntity) && (Object)(object)mountable != (Object)(object)this && !mountable.EqualNetID((BaseNetworkable)baseEntity))
			{
				Pool.FreeUnmanaged<Collider>(ref list);
				return true;
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return false;
	}

	public virtual void CheckSeatsForClipping()
	{
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			BaseMountable mountable = mountPoint.mountable;
			if (!((Object)(object)mountable == (Object)null) && mountable.AnyMounted() && IsSeatClipping(mountable))
			{
				SeatClippedWorld(mountable);
			}
		}
	}

	public virtual void SeatClippedWorld(BaseMountable mountable)
	{
		mountable.DismountPlayer(mountable.GetMounted());
	}

	public override void MounteeTookDamage(BasePlayer mountee, HitInfo info)
	{
	}

	public override void DismountAllPlayers()
	{
		foreach (MountPointInfo allMountPoint in allMountPoints)
		{
			if ((Object)(object)allMountPoint.mountable != (Object)null)
			{
				allMountPoint.mountable.DismountAllPlayers();
			}
		}
	}

	public override void ServerInit()
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		clearRecentDriverAction = ClearRecentDriver;
		prevSleeping = false;
		if ((Object)(object)rigidBody != (Object)null)
		{
			savedCollisionDetectionMode = rigidBody.collisionDetectionMode;
		}
	}

	public virtual void SpawnSubEntities()
	{
		CheckAndSpawnMountPoints();
	}

	public virtual bool AdminFixUp(int tier)
	{
		if (IsDead())
		{
			return false;
		}
		GetFuelSystem()?.FillFuel();
		SetHealth(MaxHealth());
		SendNetworkUpdate();
		return true;
	}

	private void OnPhysicsNeighbourChanged()
	{
		if ((Object)(object)rigidBody != (Object)null)
		{
			rigidBody.WakeUp();
		}
	}

	private void CheckAndSpawnMountPoints()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		if (pendingLoad?.mountPoints != null)
		{
			foreach (MountPoint mountPoint in pendingLoad.mountPoints)
			{
				EntityRef<BaseMountable> entityRef = new EntityRef<BaseMountable>(mountPoint.mountableId);
				if (!entityRef.IsValid(serverside: true))
				{
					Debug.LogError((object)$"Loaded a mountpoint which doesn't exist: {mountPoint.index}", (Object)(object)this);
					continue;
				}
				if (mountPoint.index < 0 || mountPoint.index >= mountPoints.Count)
				{
					Debug.LogError((object)$"Loaded a mountpoint which has no info: {mountPoint.index}", (Object)(object)this);
					entityRef.Get(serverside: true).Kill();
					continue;
				}
				MountPointInfo mountPointInfo = mountPoints[mountPoint.index];
				if ((Object)(object)mountPointInfo.mountable != (Object)null)
				{
					Debug.LogError((object)$"Loading a mountpoint after one was already set: {mountPoint.index}", (Object)(object)this);
					mountPointInfo.mountable.Kill();
				}
				mountPointInfo.mountable = entityRef.Get(serverside: true);
				if (!mountPointInfo.mountable.enableSaving)
				{
					mountPointInfo.mountable.EnableSaving(wants: true);
				}
			}
		}
		BaseVehicle obj = pendingLoad;
		if (obj != null)
		{
			obj.Dispose();
		}
		pendingLoad = null;
		for (int i = 0; i < mountPoints.Count; i++)
		{
			SpawnMountPoint(mountPoints[i], model);
		}
		UpdateMountFlags();
	}

	public override void Spawn()
	{
		base.Spawn();
		if (base.isServer && !Application.isLoadingSave)
		{
			SpawnSubEntities();
		}
	}

	public override void Hurt(HitInfo info)
	{
		DoExplosionForce(info);
		base.Hurt(info);
	}

	public void DoExplosionForce(HitInfo info)
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		if (!IsDead() && !IsTransferProtected() && !((Object)(object)rigidBody == (Object)null) && !rigidBody.isKinematic)
		{
			float num = info.damageTypes.Get(DamageType.Explosion) + info.damageTypes.Get(DamageType.AntiVehicle) * 0.5f;
			if (num > 3f)
			{
				float num2 = Mathf.Min(num * explosionForceMultiplier, explosionForceMax);
				rigidBody.AddExplosionForce(num2, info.HitPositionWorld, 1f, 2.5f);
			}
		}
	}

	public int NumMounted()
	{
		if (!HasMountPoints())
		{
			if (!AnyMounted())
			{
				return 0;
			}
			return 1;
		}
		int num = 0;
		foreach (MountPointInfo allMountPoint in allMountPoints)
		{
			if ((Object)(object)allMountPoint.mountable != (Object)null && (Object)(object)allMountPoint.mountable.GetMounted() != (Object)null)
			{
				num++;
			}
		}
		return num;
	}

	public virtual int MaxMounted()
	{
		if (!HasMountPoints())
		{
			return 1;
		}
		int num = 0;
		foreach (MountPointInfo allMountPoint in allMountPoints)
		{
			if ((Object)(object)allMountPoint.mountable != (Object)null)
			{
				num++;
			}
		}
		return num;
	}

	public bool HasDriverSlow()
	{
		if (HasMountPoints())
		{
			if (!AnyMounted())
			{
				return false;
			}
			foreach (MountPointInfo allMountPoint in allMountPoints)
			{
				if (allMountPoint != null && (Object)(object)allMountPoint.mountable != (Object)null && allMountPoint.isDriver && allMountPoint.mountable.AnyMounted())
				{
					return true;
				}
			}
			return false;
		}
		return base.AnyMounted();
	}

	public bool HasDriver()
	{
		return HasFlag(Flags.Reserved17);
	}

	public bool IsDriver(BasePlayer player)
	{
		if (HasMountPoints())
		{
			foreach (MountPointInfo allMountPoint in allMountPoints)
			{
				if (allMountPoint != null && (Object)(object)allMountPoint.mountable != (Object)null && allMountPoint.isDriver)
				{
					BasePlayer mounted = allMountPoint.mountable.GetMounted();
					if ((Object)(object)mounted != (Object)null && (Object)(object)mounted == (Object)(object)player)
					{
						return true;
					}
				}
			}
		}
		else
		{
			BasePlayer mounted2 = GetMounted();
			if ((Object)(object)mounted2 != (Object)null)
			{
				return (Object)(object)mounted2 == (Object)(object)player;
			}
		}
		return false;
	}

	public bool HasPassenger()
	{
		if (HasMountPoints())
		{
			foreach (MountPointInfo allMountPoint in allMountPoints)
			{
				if (allMountPoint != null && (Object)(object)allMountPoint.mountable != (Object)null && !allMountPoint.isDriver && allMountPoint.mountable.AnyMounted())
				{
					return true;
				}
			}
			return false;
		}
		return base.AnyMounted();
	}

	public bool IsPassenger(BasePlayer player)
	{
		if (HasMountPoints())
		{
			foreach (MountPointInfo allMountPoint in allMountPoints)
			{
				if (allMountPoint != null && (Object)(object)allMountPoint.mountable != (Object)null && !allMountPoint.isDriver)
				{
					BasePlayer mounted = allMountPoint.mountable.GetMounted();
					if ((Object)(object)mounted != (Object)null && (Object)(object)mounted == (Object)(object)player)
					{
						return true;
					}
				}
			}
		}
		else
		{
			BasePlayer mounted2 = GetMounted();
			if ((Object)(object)mounted2 != (Object)null)
			{
				return (Object)(object)mounted2 == (Object)(object)player;
			}
		}
		return false;
	}

	public BasePlayer GetDriver()
	{
		if (HasMountPoints())
		{
			foreach (MountPointInfo allMountPoint in allMountPoints)
			{
				if (allMountPoint != null && (Object)(object)allMountPoint.mountable != (Object)null && allMountPoint.isDriver)
				{
					BasePlayer mounted = allMountPoint.mountable.GetMounted();
					if ((Object)(object)mounted != (Object)null)
					{
						return mounted;
					}
				}
			}
		}
		else
		{
			BasePlayer mounted2 = GetMounted();
			if ((Object)(object)mounted2 != (Object)null)
			{
				return mounted2;
			}
		}
		return null;
	}

	public BasePlayer GetPassenger()
	{
		if (HasMountPoints())
		{
			foreach (MountPointInfo allMountPoint in allMountPoints)
			{
				if (allMountPoint != null && (Object)(object)allMountPoint.mountable != (Object)null && !allMountPoint.isDriver)
				{
					BasePlayer mounted = allMountPoint.mountable.GetMounted();
					if ((Object)(object)mounted != (Object)null)
					{
						return mounted;
					}
				}
			}
		}
		else
		{
			BasePlayer mounted2 = GetMounted();
			if ((Object)(object)mounted2 != (Object)null)
			{
				return mounted2;
			}
		}
		return null;
	}

	public void GetDrivers(List<BasePlayer> drivers)
	{
		if (HasMountPoints())
		{
			foreach (MountPointInfo allMountPoint in allMountPoints)
			{
				if (allMountPoint != null && (Object)(object)allMountPoint.mountable != (Object)null && allMountPoint.isDriver)
				{
					BasePlayer mounted = allMountPoint.mountable.GetMounted();
					if ((Object)(object)mounted != (Object)null)
					{
						drivers.Add(mounted);
					}
				}
			}
			return;
		}
		BasePlayer mounted2 = GetMounted();
		if ((Object)(object)mounted2 != (Object)null)
		{
			drivers.Add(mounted2);
		}
	}

	public void GetMountedPlayers(List<BasePlayer> players)
	{
		if (HasMountPoints())
		{
			foreach (MountPointInfo allMountPoint in allMountPoints)
			{
				if (allMountPoint != null && (Object)(object)allMountPoint.mountable != (Object)null)
				{
					BasePlayer mounted = allMountPoint.mountable.GetMounted();
					if ((Object)(object)mounted != (Object)null)
					{
						players.Add(mounted);
					}
				}
			}
			return;
		}
		BasePlayer mounted2 = GetMounted();
		if ((Object)(object)mounted2 != (Object)null)
		{
			players.Add(mounted2);
		}
	}

	public BasePlayer GetPlayerDamageInitiator()
	{
		if (HasDriver())
		{
			return GetDriver();
		}
		if (recentDrivers.Count <= 0)
		{
			return null;
		}
		return recentDrivers.Peek();
	}

	public int GetPlayerSeat(BasePlayer player)
	{
		if (!HasMountPoints() && (Object)(object)GetMounted() == (Object)(object)player)
		{
			return 0;
		}
		int num = 0;
		foreach (MountPointInfo allMountPoint in allMountPoints)
		{
			if ((Object)(object)allMountPoint.mountable != (Object)null && (Object)(object)allMountPoint.mountable.GetMounted() == (Object)(object)player)
			{
				return num;
			}
			num++;
		}
		return -1;
	}

	public MountPointInfo GetPlayerSeatInfo(BasePlayer player)
	{
		if (!HasMountPoints())
		{
			return null;
		}
		foreach (MountPointInfo allMountPoint in allMountPoints)
		{
			if ((Object)(object)allMountPoint.mountable != (Object)null && (Object)(object)allMountPoint.mountable.GetMounted() == (Object)(object)player)
			{
				return allMountPoint;
			}
		}
		return null;
	}

	public bool IsVehicleMountPoint(BaseMountable bm)
	{
		if (!HasMountPoints() || (Object)(object)bm == (Object)null)
		{
			return false;
		}
		foreach (MountPointInfo allMountPoint in allMountPoints)
		{
			if ((Object)(object)allMountPoint.mountable == (Object)(object)bm)
			{
				return true;
			}
		}
		return false;
	}

	public virtual bool IsPlayerSeatSwapValid(BasePlayer player, int fromIndex, int toIndex, bool forcingRestrainedPlayer)
	{
		return !player.IsRestrained || forcingRestrainedPlayer;
	}

	public void SwapSeats(BasePlayer player, int targetSeat = -1, bool forcingRestrainedPlayer = false)
	{
		if (!HasMountPoints() || !CanSwapSeats)
		{
			return;
		}
		int currentSeatIndex = GetPlayerSeat(player);
		if (currentSeatIndex == -1)
		{
			return;
		}
		BaseMountable mountable = GetMountPoint(currentSeatIndex).mountable;
		BaseMountable baseMountable = null;
		if (targetSeat == -1)
		{
			int num = NumSwappableSeats();
			for (int i = 1; i <= num; i++)
			{
				int num2 = (currentSeatIndex + i) % num;
				MountPointInfo mountPoint = GetMountPoint(num2);
				if (IsValidSwap(mountPoint, num2))
				{
					baseMountable = mountPoint.mountable;
					break;
				}
			}
		}
		else
		{
			targetSeat = Mathf.Clamp(targetSeat, 0, NumSwappableSeats());
			MountPointInfo mountPoint2 = GetMountPoint(targetSeat);
			if (IsValidSwap(mountPoint2, targetSeat))
			{
				baseMountable = mountPoint2.mountable;
			}
		}
		if ((Object)(object)baseMountable != (Object)null && (Object)(object)baseMountable != (Object)(object)mountable)
		{
			mountable.DismountPlayer(player, lite: true);
			baseMountable.MountPlayer(player);
			player.MarkSwapSeat();
		}
		bool IsValidSwap(MountPointInfo point, int toIndex)
		{
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)point?.mountable != (Object)null && !point.mountable.AnyMounted() && point.mountable.CanSwapToThis(player) && !(point.isDriver && forcingRestrainedPlayer) && !IsSeatClipping(point.mountable) && IsSeatVisible(point.mountable, player.eyes.position))
			{
				return IsPlayerSeatSwapValid(player, currentSeatIndex, toIndex, forcingRestrainedPlayer);
			}
			return false;
		}
	}

	public virtual int NumSwappableSeats()
	{
		return MaxMounted();
	}

	public bool HasDriverMountPoints()
	{
		foreach (MountPointInfo allMountPoint in allMountPoints)
		{
			if (allMountPoint.isDriver)
			{
				return true;
			}
		}
		return false;
	}

	public bool OnlyOwnerAccessible()
	{
		return HasFlag(Flags.Locked);
	}

	public bool IsDespawnEligable()
	{
		if (spawnTime != -1f)
		{
			return spawnTime + 300f < Time.realtimeSinceStartup;
		}
		return true;
	}

	public void SetupOwner(BasePlayer owner, Vector3 newSafeAreaOrigin, float newSafeAreaRadius)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)owner != (Object)null)
		{
			creatorEntity = owner;
			base.OwnerID = owner.userID;
			bool b = true;
			BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(base.isServer);
			if ((Object)(object)activeGameMode != (Object)null && !activeGameMode.safeZone)
			{
				b = false;
			}
			SetFlag(Flags.Locked, b);
			safeAreaRadius = newSafeAreaRadius;
			safeAreaOrigin = newSafeAreaOrigin;
			spawnTime = Time.realtimeSinceStartup;
		}
	}

	public void ClearOwnerEntry()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		creatorEntity = null;
		SetFlag(Flags.Locked, b: false);
		safeAreaRadius = -1f;
		safeAreaOrigin = Vector3.zero;
	}

	private void DisableTransferProtectionIfEmpty()
	{
		if (!HasDriver())
		{
			DisableTransferProtection();
		}
	}

	public virtual IFuelSystem GetFuelSystem()
	{
		return null;
	}

	public bool IsSafe()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (OnlyOwnerAccessible())
		{
			return Vector3.Distance(safeAreaOrigin, ((Component)this).transform.position) <= safeAreaRadius;
		}
		return false;
	}

	public override void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
	{
		if (IsSafe())
		{
			info.damageTypes.ScaleAll(0f);
		}
		base.ScaleDamageForPlayer(player, info);
	}

	public BaseMountable GetIdealMountPoint(Vector3 eyePos, Vector3 pos, BasePlayer playerFor = null)
	{
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)playerFor == (Object)null)
		{
			return null;
		}
		if (!HasMountPoints())
		{
			return this;
		}
		BasePlayer basePlayer = creatorEntity as BasePlayer;
		bool flag = (Object)(object)basePlayer != (Object)null;
		bool flag2 = flag && basePlayer.Team != null;
		bool flag3 = flag && (Object)(object)playerFor == (Object)(object)basePlayer;
		if (!flag3 && flag && OnlyOwnerAccessible() && (Object)(object)playerFor != (Object)null && (playerFor.Team == null || !playerFor.Team.members.Contains(basePlayer.userID)))
		{
			return null;
		}
		BaseMountable result = null;
		float num = float.PositiveInfinity;
		foreach (MountPointInfo allMountPoint in allMountPoints)
		{
			if (allMountPoint.mountable.AnyMounted() || (allMountPoint.isDriver && playerFor.IsRestrained))
			{
				continue;
			}
			float num2 = Vector3.Distance(allMountPoint.mountable.mountAnchor.position, pos);
			if (num2 > num)
			{
				continue;
			}
			if (IsSeatClipping(allMountPoint.mountable))
			{
				if (Application.isEditor)
				{
					Debug.Log((object)$"Skipping seat {allMountPoint.mountable} - it's clipping");
				}
			}
			else if (!IsSeatVisible(allMountPoint.mountable, eyePos))
			{
				if (Application.isEditor)
				{
					Debug.Log((object)$"Skipping seat {allMountPoint.mountable} - it's not visible");
				}
			}
			else if (!(OnlyOwnerAccessible() && flag3) || flag2 || allMountPoint.isDriver)
			{
				result = allMountPoint.mountable;
				num = num2;
			}
		}
		return result;
	}

	public virtual bool MountEligable(BasePlayer player)
	{
		if (OnlyOwnerAccessible() && (Object)(object)creatorEntity != (Object)null && (Object)(object)player != (Object)(object)creatorEntity)
		{
			BasePlayer basePlayer = creatorEntity as BasePlayer;
			if ((Object)(object)basePlayer != (Object)null && (basePlayer.Team == null || (basePlayer.Team != null && !basePlayer.Team.members.Contains(player.userID))))
			{
				return false;
			}
		}
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle != (Object)null)
		{
			return baseVehicle.MountEligable(player);
		}
		return true;
	}

	public int GetIndexFromSeat(BaseMountable seat)
	{
		int num = 0;
		foreach (MountPointInfo allMountPoint in allMountPoints)
		{
			if ((Object)(object)allMountPoint.mountable == (Object)(object)seat)
			{
				return num;
			}
			num++;
		}
		return -1;
	}

	public virtual void PlayerMounted(BasePlayer player, BaseMountable seat)
	{
	}

	public virtual void PrePlayerDismount(BasePlayer player, BaseMountable seat)
	{
	}

	public virtual void PlayerDismounted(BasePlayer player, BaseMountable seat)
	{
		recentDrivers.Enqueue(player);
		if (!((FacepunchBehaviour)this).IsInvoking(clearRecentDriverAction))
		{
			((FacepunchBehaviour)this).Invoke(clearRecentDriverAction, 3f);
		}
	}

	public virtual GameObjectRef GetCollisionFX()
	{
		return null;
	}

	public void TryShowCollisionFX(Collision collision)
	{
		TryShowCollisionFX(collision, GetCollisionFX());
	}

	public void TryShowCollisionFX(Vector3 contactPoint)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		TryShowCollisionFX(contactPoint, GetCollisionFX());
	}

	public void TryShowCollisionFX(Collision collision, GameObjectRef effectGO)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		ContactPoint contact = collision.GetContact(0);
		TryShowCollisionFX(((ContactPoint)(ref contact)).point, effectGO);
	}

	public void TryShowCollisionFX(Vector3 contactPoint, GameObjectRef effectGO)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (!(Time.time < nextCollisionFXTime))
		{
			nextCollisionFXTime = Time.time + 0.25f;
			if (effectGO != null && effectGO.isValid)
			{
				contactPoint += (((Component)this).transform.position - contactPoint) * 0.25f;
				Effect.server.Run(effectGO.resourcePath, contactPoint, ((Component)this).transform.up);
			}
		}
	}

	public void SetToKinematic()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)rigidBody == (Object)null) && !rigidBody.isKinematic)
		{
			savedCollisionDetectionMode = rigidBody.collisionDetectionMode;
			rigidBody.collisionDetectionMode = (CollisionDetectionMode)0;
			rigidBody.isKinematic = true;
		}
	}

	public void SetToNonKinematic()
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)rigidBody == (Object)null) && rigidBody.isKinematic)
		{
			rigidBody.isKinematic = false;
			rigidBody.collisionDetectionMode = savedCollisionDetectionMode;
		}
	}

	public override void UpdateMountFlags()
	{
		int num = NumMounted();
		SetFlag(Flags.InUse, num > 0);
		SetFlag(Flags.Reserved11, num == MaxMounted());
		SetFlag(Flags.Reserved17, HasDriverSlow());
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle != (Object)null)
		{
			baseVehicle.UpdateMountFlags();
		}
	}

	public void ClearRecentDriver()
	{
		if (recentDrivers.Count > 0)
		{
			recentDrivers.Dequeue();
		}
		if (recentDrivers.Count > 0)
		{
			((FacepunchBehaviour)this).Invoke(clearRecentDriverAction, 3f);
		}
	}

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if ((Object)(object)GetMounted() != (Object)null || !MountEligable(player))
		{
			return;
		}
		BaseMountable idealMountPointFor = GetIdealMountPointFor(player);
		if (!((Object)(object)idealMountPointFor == (Object)null))
		{
			if ((Object)(object)idealMountPointFor == (Object)(object)this)
			{
				base.AttemptMount(player, doMountChecks);
			}
			else
			{
				idealMountPointFor.AttemptMount(player, doMountChecks);
			}
			if ((Object)(object)player.GetMountedVehicle() == (Object)(object)this)
			{
				PlayerMounted(player, idealMountPointFor);
			}
		}
	}

	public BaseMountable GetIdealMountPointFor(BasePlayer player)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		return GetIdealMountPoint(player.eyes.position, player.eyes.position + player.eyes.HeadForward() * 1f, player);
	}

	public override bool GetDismountPosition(BasePlayer player, out Vector3 res, bool silent = false)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle != (Object)null)
		{
			return baseVehicle.GetDismountPosition(player, out res, silent);
		}
		List<Vector3> list = Pool.Get<List<Vector3>>();
		Transform[] array = dismountPositions;
		foreach (Transform val in array)
		{
			if (ValidDismountPosition(player, ((Component)val).transform.position))
			{
				list.Add(((Component)val).transform.position);
				if (dismountStyle == DismountStyle.Ordered)
				{
					break;
				}
			}
		}
		if (list.Count == 0)
		{
			Debug.LogWarning((object)("Failed to find dismount position for player :" + player.displayName + " / " + player.userID.Get() + " on obj : " + ((Object)((Component)this).gameObject).name));
			Pool.FreeUnmanaged<Vector3>(ref list);
			res = ((Component)player).transform.position;
			return false;
		}
		Vector3 pos = ((Component)player).transform.position;
		list.Sort((Vector3 a, Vector3 b) => Vector3.Distance(a, pos).CompareTo(Vector3.Distance(b, pos)));
		res = list[0];
		Pool.FreeUnmanaged<Vector3>(ref list);
		return true;
	}

	public BaseMountable SpawnMountPoint(MountPointInfo mountToSpawn, Model model)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)mountToSpawn.mountable != (Object)null)
		{
			return mountToSpawn.mountable;
		}
		Vector3 val = Quaternion.Euler(mountToSpawn.rot) * Vector3.forward;
		Vector3 pos = mountToSpawn.pos;
		Vector3 up = Vector3.up;
		if (mountToSpawn.bone != "")
		{
			pos = ((Component)model.FindBone(mountToSpawn.bone)).transform.position + ((Component)this).transform.TransformDirection(mountToSpawn.pos);
			val = ((Component)this).transform.TransformDirection(val);
			up = ((Component)this).transform.up;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(mountToSpawn.prefab.resourcePath, pos, Quaternion.LookRotation(val, up));
		BaseMountable baseMountable = baseEntity as BaseMountable;
		if ((Object)(object)baseMountable != (Object)null)
		{
			if (enableSaving != baseMountable.enableSaving)
			{
				baseMountable.EnableSaving(enableSaving);
			}
			if (mountToSpawn.bone != "")
			{
				baseMountable.SetParent(this, mountToSpawn.bone, worldPositionStays: true, sendImmediate: true);
			}
			else
			{
				baseMountable.SetParent(this);
			}
			baseMountable.Spawn();
			mountToSpawn.mountable = baseMountable;
		}
		else
		{
			Debug.LogError((object)"MountPointInfo prefab is not a BaseMountable. Cannot spawn mount point.");
			if ((Object)(object)baseEntity != (Object)null)
			{
				baseEntity.Kill();
			}
		}
		return baseMountable;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(5f)]
	public void RPC_WantsPush(RPCMessage msg)
	{
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (!player.isMounted && !RecentlyPushed && CanPushNow(player) && !((Object)(object)rigidBody == (Object)null) && (!OnlyOwnerAccessible() || !((Object)(object)player != (Object)(object)creatorEntity)) && Interface.CallHook("OnVehiclePush", (object)this, (object)msg.player) == null)
		{
			player.metabolism.calories.Subtract(3f);
			player.metabolism.SendChangesToClient();
			if (rigidBody.IsSleeping())
			{
				rigidBody.WakeUp();
			}
			DoPushAction(player);
			timeSinceLastPush = TimeSince.op_Implicit(0f);
		}
	}

	public virtual void DoPushAction(BasePlayer player)
	{
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody == (Object)null)
		{
			return;
		}
		if (IsFlipped())
		{
			float num = rigidBody.mass * 9f;
			Vector3 val = Vector3.forward * num;
			if (Vector3.Dot(((Component)this).transform.InverseTransformVector(((Component)this).transform.position - ((Component)player).transform.position), Vector3.right) > 0f)
			{
				val *= -1f;
			}
			if (((Component)this).transform.up.y < 0f)
			{
				val *= -1f;
			}
			rigidBody.AddRelativeTorque(val, (ForceMode)1);
		}
		else
		{
			Vector3 val2 = Vector3.ProjectOnPlane(((Component)this).transform.position - player.eyes.position, ((Component)this).transform.up);
			Vector3 normalized = ((Vector3)(ref val2)).normalized;
			float pushActionForce = GetPushActionForce();
			rigidBody.AddForce(normalized * pushActionForce, (ForceMode)1);
		}
	}

	protected virtual float GetPushActionForce()
	{
		return rigidBody.mass * 5f;
	}

	protected virtual void OnServerWake()
	{
	}

	protected virtual void OnServerSleep()
	{
	}

	public virtual bool ShouldDisableTransferProtectionOnLoad(BasePlayer player)
	{
		return true;
	}

	public override void DisableTransferProtection()
	{
		base.DisableTransferProtection();
		foreach (MountPointInfo allMountPoint in allMountPoints)
		{
			if (!((Object)(object)allMountPoint.mountable == (Object)null) && allMountPoint.mountable.IsTransferProtected())
			{
				allMountPoint.mountable.DisableTransferProtection();
			}
		}
	}

	public virtual void OnMountedPlayerWeightChanged(BasePlayer player)
	{
	}
}


public enum DismountStyle
{
	Closest,
	Ordered
}


using System;
using UnityEngine;

[Serializable]
public class MountPointInfo
{
	public bool isDriver;

	public Vector3 pos;

	public Vector3 rot;

	public string bone = "";

	public GameObjectRef prefab;

	[NonSerialized]
	[HideInInspector]
	public BaseMountable mountable;
}


public enum RagdollMode
{
	Collide,
	FallThrough
}


public enum ClippingCheckMode
{
	OnMountOnly,
	Always
}


using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public readonly struct Enumerable : IEnumerable<MountPointInfo>, IEnumerable
{
	private readonly BaseVehicle _vehicle;

	public Enumerable(BaseVehicle vehicle)
	{
		if ((Object)(object)vehicle == (Object)null)
		{
			throw new ArgumentNullException("vehicle");
		}
		_vehicle = vehicle;
	}

	public Enumerator GetEnumerator()
	{
		return new Enumerator(_vehicle);
	}

	IEnumerator<MountPointInfo> IEnumerable<MountPointInfo>.GetEnumerator()
	{
		return GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public struct Enumerator : IEnumerator<MountPointInfo>, IEnumerator, IDisposable
{
	private enum State
	{
		Direct,
		EnterChild,
		EnumerateChild,
		Finished
	}

	private class Box : IPooled
	{
		public Enumerator Value;

		public void EnterPool()
		{
			Value = default(Enumerator);
		}

		public void LeavePool()
		{
			Value = default(Enumerator);
		}
	}

	private readonly BaseVehicle _vehicle;

	private State _state;

	private int _index;

	private int _childIndex;

	private Box _enumerator;

	public MountPointInfo Current { get; private set; }

	object IEnumerator.Current => Current;

	public Enumerator(BaseVehicle vehicle)
	{
		if ((Object)(object)vehicle == (Object)null)
		{
			throw new ArgumentNullException("vehicle");
		}
		_vehicle = vehicle;
		_state = State.Direct;
		_index = -1;
		_childIndex = -1;
		_enumerator = null;
		Current = null;
	}

	public bool MoveNext()
	{
		Current = null;
		switch (_state)
		{
		case State.Direct:
			_index++;
			if (_index >= _vehicle.mountPoints.Count)
			{
				_state = State.EnterChild;
				goto case State.EnterChild;
			}
			Current = _vehicle.mountPoints[_index];
			return true;
		case State.EnterChild:
			do
			{
				_childIndex++;
			}
			while (_childIndex < _vehicle.childVehicles.Count && (Object)(object)_vehicle.childVehicles[_childIndex] == (Object)null);
			if (_childIndex >= _vehicle.childVehicles.Count)
			{
				_state = State.Finished;
				return false;
			}
			_enumerator = Pool.Get<Box>();
			_enumerator.Value = _vehicle.childVehicles[_childIndex].allMountPoints.GetEnumerator();
			_state = State.EnumerateChild;
			goto case State.EnumerateChild;
		case State.EnumerateChild:
			if (_enumerator.Value.MoveNext())
			{
				Current = _enumerator.Value.Current;
				return true;
			}
			_enumerator.Value.Dispose();
			Pool.Free<Box>(ref _enumerator);
			_state = State.EnterChild;
			goto case State.EnterChild;
		case State.Finished:
			return false;
		default:
			throw new NotSupportedException();
		}
	}

	public void Dispose()
	{
		if (_enumerator != null)
		{
			_enumerator.Value.Dispose();
			Pool.Free<Box>(ref _enumerator);
		}
	}

	public void Reset()
	{
		throw new NotSupportedException();
	}
}


private enum State
{
	Direct,
	EnterChild,
	EnumerateChild,
	Finished
}


using Facepunch;

private class Box : IPooled
{
	public Enumerator Value;

	public void EnterPool()
	{
		Value = default(Enumerator);
	}

	public void LeavePool()
	{
		Value = default(Enumerator);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using Rust.Modular;
using UnityEngine;
using UnityEngine.Assertions;

public class BaseVehicleModule : BaseVehicle, IPrefabPreProcess
{
	public enum VisualGroup
	{
		None,
		Engine,
		Cabin,
		Flatbed
	}

	[Serializable]
	public class LODLevel
	{
		public Renderer[] renderers;
	}

	[Header("Vehicle Module")]
	[SerializeField]
	private Transform centreOfMassTransform;

	[SerializeField]
	private float mass = 100f;

	public VisualGroup visualGroup;

	[HideInInspector]
	[SerializeField]
	private VehicleLight[] lights;

	public LODLevel[] lodRenderers;

	[SerializeField]
	[HideInInspector]
	private List<ConditionalObject> conditionals;

	[Header("Trigger Parent")]
	[SerializeField]
	private TriggerParent[] triggerParents;

	[Header("Sliding Components")]
	[SerializeField]
	private VehicleModuleSlidingComponent[] slidingComponents;

	[SerializeField]
	protected VehicleModuleButtonComponent[] buttonComponents;

	private TimeSince TimeSinceAddedToVehicle;

	private float prevRefreshHealth = -1f;

	private bool prevRefreshVehicleIsDead;

	private bool prevRefreshVehicleIsLockable;

	public Item AssociatedItemInstance;

	private TimeSince timeSinceItemLockRefresh;

	private const float TIME_BETWEEN_LOCK_REFRESH = 1f;

	public BaseModularVehicle Vehicle { get; private set; }

	public int FirstSocketIndex { get; private set; } = -1;

	public Vector3 CentreOfMass => centreOfMassTransform.localPosition;

	public float Mass => mass;

	public NetworkableId ID => net.ID;

	public bool IsOnAVehicle => (Object)(object)Vehicle != (Object)null;

	public ItemDefinition AssociatedItemDef => repair.itemTarget;

	public virtual bool HasSeating => false;

	public virtual bool HasAnEngine => false;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public bool PropagateDamage { get; private set; } = true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseVehicleModule.OnRpcMessage", 0);
		try
		{
			if (rpc == 2683376664u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Use "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Use", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2683376664u, "RPC_Use", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Use(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Use");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(process, rootObj, name, serverside, clientside, bundling);
		damageRenderer = ((Component)this).GetComponent<DamageRenderer>();
		RefreshParameters();
		lights = ((Component)this).GetComponentsInChildren<VehicleLight>();
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	public void RefreshParameters()
	{
		for (int num = conditionals.Count - 1; num >= 0; num--)
		{
			ConditionalObject conditionalObject = conditionals[num];
			if ((Object)(object)conditionalObject.gameObject == (Object)null)
			{
				conditionals.RemoveAt(num);
			}
			else if (conditionalObject.restrictOnHealth)
			{
				conditionalObject.healthRestrictionMin = Mathf.Clamp01(conditionalObject.healthRestrictionMin);
				conditionalObject.healthRestrictionMax = Mathf.Clamp01(conditionalObject.healthRestrictionMax);
			}
			if ((Object)(object)conditionalObject.gameObject != (Object)null)
			{
				Gibbable component = conditionalObject.gameObject.GetComponent<Gibbable>();
				if (component != null)
				{
					component.isConditional = true;
				}
			}
		}
	}

	public override BaseVehicle VehicleParent()
	{
		return GetParentEntity() as BaseVehicle;
	}

	public virtual void ModuleAdded(BaseModularVehicle vehicle, int firstSocketIndex)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vehicle = vehicle;
		FirstSocketIndex = firstSocketIndex;
		TimeSinceAddedToVehicle = TimeSince.op_Implicit(0f);
		if (base.isServer)
		{
			TriggerParent[] array = triggerParents;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].associatedMountable = vehicle;
			}
			SendNetworkUpdate();
		}
		RefreshConditionals(canGib: false);
	}

	public virtual void ModuleRemoved()
	{
		Vehicle = null;
		FirstSocketIndex = -1;
		if (base.isServer)
		{
			TriggerParent[] array = triggerParents;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].associatedMountable = null;
			}
			SendNetworkUpdate();
		}
	}

	public void OtherVehicleModulesChanged()
	{
		RefreshConditionals(canGib: false);
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!IsOnAVehicle)
		{
			return false;
		}
		return Vehicle.CanBeLooted(player);
	}

	public bool KeycodeEntryBlocked(BasePlayer player)
	{
		if (IsOnAVehicle && Vehicle is ModularCar modularCar)
		{
			return modularCar.KeycodeEntryBlocked(player);
		}
		return false;
	}

	public virtual void OnEngineStateChanged(VehicleEngineController<GroundVehicle>.EngineState oldState, VehicleEngineController<GroundVehicle>.EngineState newState)
	{
		if (!base.isServer || newState != 0)
		{
			return;
		}
		for (int i = 0; i < children.Count; i++)
		{
			if (children[i] is ModularCarRadio modularCarRadio)
			{
				modularCarRadio.TryForceOff();
			}
		}
	}

	public override float MaxHealth()
	{
		if ((Object)(object)AssociatedItemDef != (Object)null)
		{
			return AssociatedItemDef.condition.max;
		}
		return base.MaxHealth();
	}

	public override float StartHealth()
	{
		return MaxHealth();
	}

	public int GetNumSocketsTaken()
	{
		if ((Object)(object)AssociatedItemDef == (Object)null)
		{
			return 1;
		}
		return ((Component)AssociatedItemDef).GetComponent<ItemModVehicleModule>().socketsTaken;
	}

	public List<ConditionalObject> GetConditionals()
	{
		List<ConditionalObject> list = new List<ConditionalObject>();
		foreach (ConditionalObject conditional in conditionals)
		{
			if ((Object)(object)conditional.gameObject != (Object)null)
			{
				list.Add(conditional);
			}
		}
		return list;
	}

	public virtual float GetMaxDriveForce()
	{
		return 0f;
	}

	public void RefreshConditionals(bool canGib)
	{
		if (base.IsDestroyed || !IsOnAVehicle || !Vehicle.HasInited)
		{
			return;
		}
		foreach (ConditionalObject conditional in conditionals)
		{
			RefreshConditional(conditional, canGib);
		}
		prevRefreshHealth = Health();
		prevRefreshVehicleIsDead = Vehicle.IsDead();
		prevRefreshVehicleIsLockable = Vehicle.IsLockable;
		PostConditionalRefresh();
	}

	protected virtual void PostConditionalRefresh()
	{
	}

	private void RefreshConditional(ConditionalObject conditional, bool canGib)
	{
		if (conditional == null || (Object)(object)conditional.gameObject == (Object)null)
		{
			return;
		}
		bool flag = true;
		if (conditional.restrictOnHealth)
		{
			flag = ((!Mathf.Approximately(conditional.healthRestrictionMin, conditional.healthRestrictionMax)) ? (base.healthFraction > conditional.healthRestrictionMin && base.healthFraction <= conditional.healthRestrictionMax) : Mathf.Approximately(base.healthFraction, conditional.healthRestrictionMin));
			if (!canGib)
			{
			}
		}
		if (flag && IsOnAVehicle && conditional.restrictOnLockable)
		{
			flag = Vehicle.IsLockable == conditional.lockableRestriction;
		}
		if (flag && conditional.restrictOnAdjacent)
		{
			bool flag2 = false;
			bool flag3 = false;
			if (TryGetAdjacentModuleInFront(out var result))
			{
				flag2 = InSameVisualGroupAs(result, conditional.adjacentMatch);
			}
			if (TryGetAdjacentModuleBehind(out result))
			{
				flag3 = InSameVisualGroupAs(result, conditional.adjacentMatch);
			}
			switch (conditional.adjacentRestriction)
			{
			case ConditionalObject.AdjacentCondition.BothDifferent:
				flag = !flag2 && !flag3;
				break;
			case ConditionalObject.AdjacentCondition.SameInFront:
				flag = flag2;
				break;
			case ConditionalObject.AdjacentCondition.SameBehind:
				flag = flag3;
				break;
			case ConditionalObject.AdjacentCondition.DifferentInFront:
				flag = !flag2;
				break;
			case ConditionalObject.AdjacentCondition.DifferentBehind:
				flag = !flag3;
				break;
			case ConditionalObject.AdjacentCondition.BothSame:
				flag = flag2 && flag3;
				break;
			}
		}
		if (flag)
		{
			if (!IsOnAVehicle)
			{
				for (int i = 0; i < conditional.socketSettings.Length; i++)
				{
					flag = !conditional.socketSettings[i].HasSocketRestrictions;
					if (!flag)
					{
						break;
					}
				}
			}
			else
			{
				for (int j = 0; j < conditional.socketSettings.Length; j++)
				{
					ModularVehicleSocket socket = Vehicle.GetSocket(FirstSocketIndex + j);
					if (socket == null)
					{
						Debug.LogWarning((object)$"{AssociatedItemDef.displayName.translated} module got NULL socket at index {FirstSocketIndex + j}. Total vehicle sockets: {Vehicle.TotalSockets} FirstSocketIndex: {FirstSocketIndex} Sockets taken: {conditional.socketSettings.Length}");
					}
					flag = socket?.ShouldBeActive(conditional.socketSettings[j]) ?? false;
					if (!flag)
					{
						break;
					}
				}
			}
		}
		_ = conditional.gameObject.activeInHierarchy;
		conditional.SetActive(flag);
	}

	private bool TryGetAdjacentModuleInFront(out BaseVehicleModule result)
	{
		if (!IsOnAVehicle)
		{
			result = null;
			return false;
		}
		int socketIndex = FirstSocketIndex - 1;
		return Vehicle.TryGetModuleAt(socketIndex, out result);
	}

	private bool TryGetAdjacentModuleBehind(out BaseVehicleModule result)
	{
		if (!IsOnAVehicle)
		{
			result = null;
			return false;
		}
		int num = FirstSocketIndex + GetNumSocketsTaken() - 1;
		return Vehicle.TryGetModuleAt(num + 1, out result);
	}

	private bool InSameVisualGroupAs(BaseVehicleModule moduleEntity, ConditionalObject.AdjacentMatchType matchType)
	{
		if ((Object)(object)moduleEntity == (Object)null)
		{
			return false;
		}
		if (visualGroup == VisualGroup.None)
		{
			if (matchType == ConditionalObject.AdjacentMatchType.GroupNotExact)
			{
				return false;
			}
			return moduleEntity.prefabID == prefabID;
		}
		switch (matchType)
		{
		case ConditionalObject.AdjacentMatchType.GroupOrExact:
			if (moduleEntity.prefabID != prefabID)
			{
				return moduleEntity.visualGroup == visualGroup;
			}
			return true;
		case ConditionalObject.AdjacentMatchType.ExactOnly:
			return moduleEntity.prefabID == prefabID;
		case ConditionalObject.AdjacentMatchType.GroupNotExact:
			if (moduleEntity.prefabID != prefabID)
			{
				return moduleEntity.visualGroup == visualGroup;
			}
			return false;
		default:
			return false;
		}
	}

	protected bool CanBeUsedNowBy(BasePlayer player)
	{
		if (!IsOnAVehicle || (Object)(object)player == (Object)null)
		{
			return false;
		}
		if (Vehicle.IsEditableNow || Vehicle.IsDead() || !Vehicle.PlayerIsMounted(player))
		{
			return false;
		}
		return Vehicle.PlayerCanUseThis(player, ModularCarCodeLock.LockType.General);
	}

	public bool PlayerIsLookingAtUsable(string lookingAtColldierName, string usableColliderName)
	{
		return string.Compare(lookingAtColldierName, usableColliderName, ignoreCase: true) == 0;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}

	public override bool IsVehicleRoot()
	{
		return false;
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		if (!isSpawned || !IsOnAVehicle)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("BaseVehicleModule.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (Vehicle.IsEditableNow && AssociatedItemInstance != null && TimeSince.op_Implicit(timeSinceItemLockRefresh) > 1f)
			{
				AssociatedItemInstance.LockUnlock(!CanBeMovedNow());
				timeSinceItemLockRefresh = TimeSince.op_Implicit(0f);
			}
			for (int i = 0; i < slidingComponents.Length; i++)
			{
				slidingComponents[i].ServerUpdateTick(this);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Hurt(HitInfo info)
	{
		if (!IsTransferProtected() && IsOnAVehicle)
		{
			Vehicle.ModuleHurt(this, info);
		}
		base.Hurt(info);
	}

	public override void OnHealthChanged(float oldValue, float newValue)
	{
		base.OnHealthChanged(oldValue, newValue);
		if (!base.isServer)
		{
			return;
		}
		if (IsOnAVehicle)
		{
			if (Vehicle.IsDead())
			{
				return;
			}
			if (AssociatedItemInstance != null)
			{
				AssociatedItemInstance.condition = Health();
			}
			if (newValue <= 0f)
			{
				Vehicle.ModuleReachedZeroHealth();
			}
		}
		RefreshConditionals(canGib: true);
	}

	public bool CanBeMovedNow()
	{
		if (IsOnAVehicle)
		{
			return CanBeMovedNowOnVehicle();
		}
		return true;
	}

	protected virtual bool CanBeMovedNowOnVehicle()
	{
		return true;
	}

	public virtual float GetAdjustedDriveForce(float absSpeed, float topSpeed)
	{
		return 0f;
	}

	public void AcceptPropagatedDamage(float amount, DamageType type, BaseEntity attacker = null, bool useProtection = true)
	{
		PropagateDamage = false;
		Hurt(amount, type, attacker, useProtection);
		PropagateDamage = true;
	}

	public override void Die(HitInfo info = null)
	{
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_Use(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!CanBeUsedNowBy(player))
		{
			return;
		}
		string lookingAtColldierName = msg.read.String(256, false);
		VehicleModuleSlidingComponent[] array = slidingComponents;
		foreach (VehicleModuleSlidingComponent vehicleModuleSlidingComponent in array)
		{
			if (PlayerIsLookingAtUsable(lookingAtColldierName, vehicleModuleSlidingComponent.interactionColliderName))
			{
				vehicleModuleSlidingComponent.Use(this);
				break;
			}
		}
		VehicleModuleButtonComponent[] array2 = buttonComponents;
		foreach (VehicleModuleButtonComponent vehicleModuleButtonComponent in array2)
		{
			if ((Object)(object)vehicleModuleButtonComponent == (Object)null)
			{
				break;
			}
			if (PlayerIsLookingAtUsable(lookingAtColldierName, vehicleModuleButtonComponent.interactionColliderName))
			{
				vehicleModuleButtonComponent.ServerUse(player, this);
				break;
			}
		}
	}

	public override void AdminKill()
	{
		if (IsOnAVehicle)
		{
			Vehicle.AdminKill();
		}
	}

	public override bool AdminFixUp(int tier)
	{
		if (IsOnAVehicle && Vehicle.IsDead())
		{
			return false;
		}
		return base.AdminFixUp(tier);
	}

	public virtual void OnPlayerDismountedVehicle(BasePlayer player)
	{
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.vehicleModule = Pool.Get<VehicleModule>();
		info.msg.vehicleModule.socketIndex = FirstSocketIndex;
	}
}


public enum VisualGroup
{
	None,
	Engine,
	Cabin,
	Flatbed
}


using System;
using UnityEngine;

[Serializable]
public class LODLevel
{
	public Renderer[] renderers;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class BatteringRam : BaseSiegeWeapon, IEngineControllerUser, IEntity, VehicleChassisVisuals<BatteringRam>.IClientWheelUser
{
	[Serializable]
	private struct ImpactEffect
	{
		public string materialName;

		public GameObjectRef prefab;
	}

	[SerializeField]
	[Header("Battering Ram")]
	private Animator animator;

	[SerializeField]
	private Transform damagePoint;

	[Space]
	[SerializeField]
	private float timeBetweenFire = 2f;

	[SerializeField]
	private float maxForwardSpeed = 1.5f;

	[Header("Head")]
	[Space]
	[SerializeField]
	private BatteringRamHead headPrefab;

	[SerializeField]
	private int headDamagePerHit = 20;

	[SerializeField]
	private DamageRenderer headDamageRenderer;

	private EntityRef<BatteringRamHead> headRef;

	[SerializeField]
	private GameObjectRef defaultRamImpactEffect;

	[SerializeField]
	private ImpactEffect[] impactEffects;

	[Header("IK")]
	[SerializeField]
	private Transform leftHandTarget;

	[SerializeField]
	private Transform rightHandTarget;

	[SerializeField]
	private Transform leftFootTarget;

	[SerializeField]
	private Transform rightFootTarget;

	[SerializeField]
	private Transform steeringWheel;

	[SerializeField]
	[HideInInspector]
	private Vector3 steerAngle;

	public VehicleModuleEngine.Engine engine;

	public List<DamageTypeEntry> damageTypes = new List<DamageTypeEntry>();

	[Header("Cockpit")]
	public Transform fuelGauge;

	[SerializeField]
	[HideInInspector]
	private Vector3 fuelAngle;

	private float cachedFuelFraction;

	[ServerVar(ClientAdmin = true, Default = "2")]
	public static int maxBuildingBlockGrade = 2;

	[Header("Door")]
	[SerializeField]
	private Transform doorTransform;

	[SerializeField]
	private GameObjectRef doorServerGib;

	[SerializeField]
	private Rigidbody doorRigidBody;

	[SerializeField]
	private Transform doorPhysicsHinge;

	[SerializeField]
	private HingeJoint doorJoint;

	public GameObjectRef openEffect;

	public GameObjectRef openBounceEffect;

	public GameObjectRef closeEffect;

	public GameObjectRef closeEndEffect;

	[Tooltip("Effect played at local 0,0,0 in addition to the impact effects")]
	[Header("Effects")]
	public GameObjectRef hitEffect;

	public VehicleLight[] vehicleLights;

	[Header("Engine FX")]
	public ParticleSystemContainer[] engineParticles;

	public ParticleSystem[] exhaustSmoke;

	public float exhaustMinRate = 1f;

	public float exhaustMaxRate = 10f;

	public float exhaustRateChangeSpeed = 0.5f;

	[Space]
	public float exhaustSmokeMinOpacity = 1f;

	public float exhaustSmokeMaxOpacity = 10f;

	public float exhaustSmokeChangeSpeed = 0.5f;

	private float clientDoorAngle;

	public const Flags Flags_DamagedLow = Flags.Reserved6;

	public const Flags Flags_DamagedMid = Flags.Reserved10;

	public const Flags Flags_DamagedHeavy = Flags.Reserved8;

	public const int DAMAGE_LAYER = 1210286337;

	private BatteringRamHead _head;

	public const Flags Flags_DoorOpened = Flags.Unused23;

	public const Flags Flags_DoorBusy = Flags.Reserved14;

	public const Flags Flags_DoorBroken = Flags.Reserved15;

	private readonly float idealBreakingForce = 100000f;

	private TimeSince lastDoorMovingTime;

	private float steerInput;

	private bool steerMod;

	private float brakeInput;

	private float throttleInput;

	private bool EngineIsOn => base.CurEngineState == VehicleEngineController<GroundVehicle>.EngineState.On;

	private BatteringRamHead Head
	{
		get
		{
			if ((Object)(object)_head == (Object)null)
			{
				_head = GetHead();
			}
			return _head;
		}
	}

	public override float DriveWheelVelocity
	{
		get
		{
			if (base.isServer)
			{
				return carPhysics.DriveWheelVelocity;
			}
			return 0f;
		}
	}

	public override float SteerAngle
	{
		get
		{
			if (base.isServer)
			{
				return carPhysics.SteerAngle;
			}
			return 0f;
		}
	}

	public override float MaxSteerAngle
	{
		get
		{
			if (base.isServer)
			{
				return carSettings.maxSteerAngle;
			}
			return 0f;
		}
	}

	public float DoorAngle
	{
		get
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			if (base.isServer)
			{
				return doorPhysicsHinge.localEulerAngles.x;
			}
			return 0f;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BatteringRam.OnRpcMessage", 0);
		try
		{
			if (rpc == 3999508679u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_CloseDoor "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_CloseDoor", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3999508679u, "RPC_CloseDoor", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3999508679u, "RPC_CloseDoor", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_CloseDoor(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_CloseDoor");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3314360565u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenDoor "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenDoor", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(3314360565u, "RPC_OpenDoor", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(3314360565u, "RPC_OpenDoor", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							RPC_OpenDoor(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_OpenDoor");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1851540757 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuel "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_OpenFuel(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex3)
				{
					Debug.LogException(ex3);
					player.Kick("RPC Error in RPC_OpenFuel");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2422512421u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_WantsAttack "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_WantsAttack", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(2422512421u, "SERVER_WantsAttack", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SERVER_WantsAttack(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in SERVER_WantsAttack");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool HasDoor()
	{
		return !HasFlag(Flags.Reserved15);
	}

	public BatteringRamHead GetHead()
	{
		BatteringRamHead batteringRamHead = headRef.Get(base.isServer);
		if (batteringRamHead.IsValid())
		{
			return batteringRamHead;
		}
		return null;
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (child.prefabID == headPrefab.GetEntity().prefabID)
		{
			BatteringRamHead batteringRamHead = (BatteringRamHead)child;
			headRef.Set(batteringRamHead);
			batteringRamHead.batteringRamOwner = this;
		}
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		if ((Object)(object)steeringWheel != (Object)null)
		{
			steerAngle = steeringWheel.localEulerAngles;
		}
		if ((Object)(object)fuelGauge != (Object)null)
		{
			fuelAngle = fuelGauge.localEulerAngles;
		}
	}

	public bool CanAttack()
	{
		if (IsOn() && !HasFlag(Flags.Busy))
		{
			return !HasFlag(Flags.Broken);
		}
		return false;
	}

	public float GetFuelFraction()
	{
		if (base.isServer)
		{
			return engineController.FuelSystem.GetFuelFraction();
		}
		return cachedFuelFraction;
	}

	public override float MaxVelocity()
	{
		return Mathf.Max(GetMaxForwardSpeed() * 1.2f, 30f);
	}

	public override float GetThrottleInput()
	{
		if (base.isServer)
		{
			return Mathf.Clamp(throttleInput, -1f, 1f);
		}
		return 0f;
	}

	public override float GetBrakeInput()
	{
		if (base.isServer)
		{
			return brakeInput;
		}
		return 0f;
	}

	public override float GetSteerInput()
	{
		if (base.isServer)
		{
			return Mathf.Clamp(steerInput, -1f, 1f);
		}
		return 0f;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.batteringRam = Pool.Get<BatteringRam>();
		info.msg.batteringRam.fuelStorageID = GetFuelSystem().GetInstanceID();
		info.msg.batteringRam.headID = headRef.uid;
		info.msg.batteringRam.steerInput = GetSteerInput();
		info.msg.batteringRam.driveWheelVel = DriveWheelVelocity;
		info.msg.batteringRam.throttleInput = GetThrottleInput();
		info.msg.batteringRam.brakeInput = GetBrakeInput();
		info.msg.batteringRam.fuelFraction = GetFuelFraction();
		if (HasDoor())
		{
			info.msg.batteringRam.doorAngle = DoorAngle;
		}
		info.msg.batteringRam.time = GetNetworkTime();
	}

	public override void Load(LoadInfo info)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.batteringRam != null)
		{
			engineController.FuelSystem.SetInstanceID(info.msg.batteringRam.fuelStorageID);
			headRef.uid = info.msg.batteringRam.headID;
			cachedFuelFraction = info.msg.batteringRam.fuelFraction;
		}
	}

	public override bool IsWaterlogged()
	{
		bool result = false;
		if (base.isServer)
		{
			result = engineController.IsWaterlogged();
		}
		return result;
	}

	private bool CanOpenDoor()
	{
		if (HasDoor() && !IsDoorBusy())
		{
			return !IsDoorOpen();
		}
		return false;
	}

	private bool CanCloseDoor()
	{
		if (HasDoor() && !IsDoorBusy())
		{
			return IsDoorOpen();
		}
		return false;
	}

	public bool IsDoorOpen()
	{
		return HasFlag(Flags.Unused23);
	}

	private bool IsDoorBusy()
	{
		return HasFlag(Flags.Reserved14);
	}

	private void DisableDoor()
	{
		ComponentExtensions.SetActive<Transform>(doorTransform, false);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server]
	protected void RPC_OpenDoor(RPCMessage rpc)
	{
		if (rpc.player.CanInteract(usableWhileCrawling: true) && CanOpenDoor() && Interface.CallHook("OnSiegeWeaponDoorOpen", (object)this, (object)rpc.player) == null)
		{
			OpenDoor();
		}
	}

	[RPC_Server.CallsPerSecond(2uL)]
	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	protected void RPC_CloseDoor(RPCMessage rpc)
	{
		if (rpc.player.CanInteract(usableWhileCrawling: true) && CanCloseDoor() && Interface.CallHook("OnSiegeWeaponDoorClose", (object)this, (object)rpc.player) == null)
		{
			CloseDoor();
		}
	}

	private void OpenDoor()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		doorRigidBody.mass = 100f;
		doorRigidBody.AddForceAtPosition(-((Component)this).transform.up * rigidBody.mass * 1.5f, ((Component)this).transform.position + Vector3.up * 2f, (ForceMode)1);
		SetFlag(Flags.Unused23, b: true, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved14, b: true);
		doorJoint.useSpring = false;
		lastDoorMovingTime = TimeSince.op_Implicit(0f);
		if (((FacepunchBehaviour)this).IsInvokingFixedTime((Action)MoveToNormalBreakForce))
		{
			((FacepunchBehaviour)this).CancelInvokeFixedTime((Action)MoveToNormalBreakForce);
		}
		((FacepunchBehaviour)this).InvokeRepeatingFixedTime((Action)MoveToNormalBreakForce);
		OnDoorOpening();
	}

	private void CloseDoor()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		SetFlag(Flags.Unused23, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved14, b: true);
		doorJoint.useSpring = true;
		JointSpring spring = doorJoint.spring;
		spring.targetPosition = 0f;
		doorJoint.spring = spring;
		lastDoorMovingTime = TimeSince.op_Implicit(0f);
		carPhysics.lastMovingTime = Time.time;
		OnDoorClosing();
	}

	private void DoorBusyTick()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = doorRigidBody.angularVelocity;
		if (!(Mathf.Abs(((Vector3)(ref val)).magnitude) > 1f))
		{
			val = doorRigidBody.velocity;
			if (!(Mathf.Abs(((Vector3)(ref val)).magnitude) > 1f))
			{
				goto IL_004e;
			}
		}
		lastDoorMovingTime = TimeSince.op_Implicit(0f);
		goto IL_004e;
		IL_004e:
		if (TimeSince.op_Implicit(lastDoorMovingTime) > 3f && IsDoorOpen())
		{
			OnDoorOpened();
			SetFlag(Flags.Reserved14, b: false);
		}
		if (IsDoorOpen())
		{
			if (carPhysics.IsWheelGrounded(6) || carPhysics.IsWheelGrounded(7))
			{
				OnDoorOpened();
				SetFlag(Flags.Reserved14, b: false);
			}
			return;
		}
		Quaternion localRotation = doorPhysicsHinge.localRotation;
		if (Mathf.Abs(((Quaternion)(ref localRotation)).eulerAngles.x - 90f) <= 1f)
		{
			OnDoorClosed();
			SetFlag(Flags.Reserved14, b: false);
		}
	}

	private void OnDoorOpening()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(openEffect.resourcePath, this, 0u, doorTransform.localPosition, Vector3.zero);
	}

	private void OnDoorClosing()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(closeEffect.resourcePath, this, 0u, doorTransform.localPosition, Vector3.zero);
		carPhysics.lastMovingTime = Time.time;
	}

	private void OnDoorClosed()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		doorRigidBody.mass = 1000f;
		((Joint)doorJoint).breakForce = idealBreakingForce * 4f;
		((Joint)doorJoint).breakTorque = idealBreakingForce * 4f;
		Effect.server.Run(closeEndEffect.resourcePath, this, 0u, doorTransform.localPosition, Vector3.zero);
	}

	private void OnDoorOpened()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(openBounceEffect.resourcePath, this, 0u, doorTransform.localPosition, Vector3.zero);
	}

	private void MoveToNormalBreakForce()
	{
		if ((Object)(object)doorJoint == (Object)null || Mathf.Approximately(((Joint)doorJoint).breakForce, idealBreakingForce))
		{
			((FacepunchBehaviour)this).CancelInvokeFixedTime((Action)MoveToNormalBreakForce);
			return;
		}
		float num = Mathf.Lerp(((Joint)doorJoint).breakForce, idealBreakingForce, Time.fixedDeltaTime * 10f);
		((Joint)doorJoint).breakForce = num;
		((Joint)doorJoint).breakTorque = num;
	}

	private void SpawnDoorGib()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		((FacepunchBehaviour)this).CancelInvokeFixedTime((Action)MoveToNormalBreakForce);
		ServerGib obj = GameManager.server.CreateEntity(doorServerGib.resourcePath, doorTransform.position, doorTransform.rotation) as ServerGib;
		obj.Spawn();
		Rigidbody component = ((Component)obj).GetComponent<Rigidbody>();
		component.velocity = doorRigidBody.velocity;
		component.angularVelocity = doorRigidBody.angularVelocity;
		component.WakeUp();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateClients, 0f, 0.1f, 0.01f);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.Reserved14, b: false);
		if (!HasDoor())
		{
			DisableDoor();
		}
		else if (HasFlag(Flags.Unused23))
		{
			OpenDoor();
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		if (!IsDriver(player))
		{
			return;
		}
		throttleInput = 0f;
		brakeInput = 0f;
		if (engineController.IsOff)
		{
			if ((inputState.IsDown(BUTTON.FORWARD) && !inputState.WasDown(BUTTON.FORWARD)) || (inputState.IsDown(BUTTON.BACKWARD) && !inputState.WasDown(BUTTON.BACKWARD)))
			{
				engineController.TryStartEngine(player);
			}
		}
		else if (engineController.IsOn)
		{
			float num = 0f;
			if (inputState.IsDown(BUTTON.FORWARD))
			{
				num = 1f;
			}
			else if (inputState.IsDown(BUTTON.BACKWARD))
			{
				num = -1f;
			}
			if (GetSpeed() > 1f && num < -0.1f)
			{
				throttleInput = 0f;
				brakeInput = 0f - num;
			}
			else
			{
				throttleInput = num;
				brakeInput = 0f;
			}
			steerInput = 0f;
			if (inputState.IsDown(BUTTON.LEFT))
			{
				steerInput = -1f;
			}
			else if (inputState.IsDown(BUTTON.RIGHT))
			{
				steerInput = 1f;
			}
		}
	}

	protected override void ServerFlagsChanged(Flags old, Flags next)
	{
		base.ServerFlagsChanged(old, next);
		if (base.isServer)
		{
			if (base.CurEngineState == VehicleEngineController<GroundVehicle>.EngineState.Off)
			{
				RefreshLastUseTime();
			}
			if (!old.HasFlag(Flags.Reserved14) && next.HasFlag(Flags.Reserved14))
			{
				((FacepunchBehaviour)this).InvokeRepeatingFixedTime((Action)DoorBusyTick);
			}
			else if (old.HasFlag(Flags.Reserved14) && !next.HasFlag(Flags.Reserved14))
			{
				((FacepunchBehaviour)this).CancelInvokeFixedTime((Action)DoorBusyTick);
			}
		}
	}

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		base.OnHealthChanged(oldvalue, newvalue);
		UpdateDamageFlags();
	}

	private void UpdateDamageFlags()
	{
		float num = base.healthFraction;
		SetFlag(Flags.Reserved6, b: false);
		SetFlag(Flags.Reserved10, b: false);
		SetFlag(Flags.Reserved8, b: false);
		if (num <= 0.25f)
		{
			SetFlag(Flags.Reserved8, b: true);
		}
		else if (num <= 0.5f)
		{
			SetFlag(Flags.Reserved10, b: true);
		}
		else if (num <= 0.75f)
		{
			SetFlag(Flags.Reserved6, b: true);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void SERVER_WantsAttack(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		BasePlayer driver = GetDriver();
		if (!((Object)(object)driver == (Object)null) && !((Object)(object)player == (Object)null) && !((Object)(object)driver != (Object)(object)player) && CanAttack() && !driver.InSafeZone() && Interface.CallHook("OnSiegeWeaponFire", (object)this, (object)player) == null)
		{
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_Attack"));
			((FacepunchBehaviour)this).Invoke((Action)delegate
			{
				ScanEntities(driver);
			}, 2f);
			SetFlag(Flags.Busy, b: true);
			((FacepunchBehaviour)this).Invoke((Action)delegate
			{
				SetFlag(Flags.Busy, b: false);
			}, timeBetweenFire);
		}
	}

	private void ScanEntities(BasePlayer driver)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> entities = Pool.Get<List<BaseEntity>>();
		Vis.Entities(damagePoint.position, 1f, entities, 1210286337, (QueryTriggerInteraction)1);
		FilterEntities(entities, driver, damagePoint.position);
		bool flag = entities.Count != 0;
		if (!flag)
		{
			List<Collider> list = Pool.Get<List<Collider>>();
			GamePhysics.OverlapSphere(damagePoint.position, 1f, list, 1210286337, (QueryTriggerInteraction)1);
			foreach (Collider item in list)
			{
				BaseEntity baseEntity = item.ToBaseEntity();
				if (!((Object)(object)baseEntity != (Object)null) || (!baseEntity.isClient && !((Object)(object)baseEntity == (Object)(object)this) && !((Object)(object)baseEntity == (Object)(object)Head)))
				{
					flag = true;
				}
			}
			Pool.FreeUnmanaged<Collider>(ref list);
		}
		bool arg = flag && Head.health - (float)headDamagePerHit <= Head.brokenHealthThreshold;
		ClientRPC(RpcTarget.NetworkGroup("CLIENT_AttackResult"), flag, arg);
		((FacepunchBehaviour)this).Invoke((Action)delegate
		{
			OnRamImpact(driver, entities);
		}, 0.5f);
	}

	private void FilterEntities(List<BaseEntity> entityList, BasePlayer driver, Vector3 pos)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		for (int i = 0; i < entityList.Count; i++)
		{
			BaseEntity baseEntity = entityList[i];
			if (baseEntity.isServer && !list.Contains(baseEntity) && (!((Object)(object)driver != (Object)null) || !((Object)(object)baseEntity == (Object)(object)driver)) && !((Object)(object)baseEntity == (Object)(object)this) && !((Object)(object)baseEntity == (Object)(object)Head) && baseEntity.IsVisible(pos))
			{
				list.Add(baseEntity);
			}
		}
		entityList.Clear();
		entityList.AddRange(list);
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	private void OnRamImpact(BasePlayer driver, List<BaseEntity> entities)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		if (entities.Count != 0)
		{
			DamageEntities(entities, driver, damageTypes, damagePoint.position);
			Head.TakeDamage(headDamagePerHit);
		}
		Pool.FreeUnmanaged<BaseEntity>(ref entities);
		GameObjectRef ramImpactEffect = GetRamImpactEffect();
		if (ramImpactEffect != null && ramImpactEffect.isValid)
		{
			Effect.server.Run(ramImpactEffect.resourcePath, damagePoint.position, -damagePoint.forward, null, broadcast: true);
		}
		if (hitEffect != null && hitEffect.isValid)
		{
			Effect.server.Run(hitEffect.resourcePath, this, 0u, Vector3.zero, Vector3.up, null, broadcast: true);
		}
		SeismicSensor.Notify(damagePoint.position, 2);
		AttackRecoilPush();
	}

	private void DamageEntities(List<BaseEntity> entityList, BaseEntity attackingPlayer, List<DamageTypeEntry> damages, Vector3 hitPos)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < entityList.Count; i++)
		{
			BaseEntity baseEntity = entityList[i];
			if (baseEntity is BuildingBlock buildingBlock && (int)buildingBlock.grade > maxBuildingBlockGrade)
			{
				continue;
			}
			HitInfo hitInfo = new HitInfo();
			hitInfo.Initiator = attackingPlayer;
			hitInfo.WeaponPrefab = LookupPrefab();
			hitInfo.damageTypes.Add(damages);
			hitInfo.PointStart = hitPos;
			Vector3 val = baseEntity.ClosestPoint(hitPos);
			hitInfo.HitPositionWorld = baseEntity.ClosestPoint(hitPos);
			Vector3 val2 = hitPos - val;
			hitInfo.HitNormalWorld = ((Vector3)(ref val2)).normalized;
			hitInfo.PointEnd = hitInfo.HitPositionWorld;
			baseEntity.OnAttacked(hitInfo);
			BaseVehicle baseVehicle = baseEntity as BaseVehicle;
			if (baseVehicle != null)
			{
				if (baseEntity is BaseVehicleModule baseVehicleModule)
				{
					baseVehicle = baseVehicleModule.Vehicle;
				}
				baseVehicle.rigidBody.AddForceAtPosition(damagePoint.forward * 1000f, hitInfo.HitPositionWorld, (ForceMode)1);
				baseVehicle.TryShowCollisionFX(hitInfo.HitPositionWorld);
			}
		}
	}

	private GameObjectRef GetRamImpactEffect()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		GamePhysics.Trace(new Ray(damagePoint.position, damagePoint.forward), 1f, out var hitInfo, 0.2f, 1210286337, (QueryTriggerInteraction)0);
		if ((Object)(object)hitInfo.GetCollider() != (Object)null)
		{
			uint num = StringPool.Get(((Object)(object)hitInfo.GetCollider().sharedMaterial != (Object)null) ? hitInfo.GetCollider().sharedMaterial.GetName() : "generic");
			ImpactEffect impactEffect = List.FindWith<ImpactEffect, uint>((IReadOnlyCollection<ImpactEffect>)(object)impactEffects, (Func<ImpactEffect, uint>)((ImpactEffect x) => StringPool.Get(x.materialName)), num, (IEqualityComparer<uint>)null);
			if (impactEffect.prefab == null || string.IsNullOrEmpty(impactEffect.prefab.resourcePath))
			{
				impactEffect.prefab = defaultRamImpactEffect;
			}
			return impactEffect.prefab;
		}
		return null;
	}

	public void AttackRecoilPush()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)rigidBody == (Object)null))
		{
			if (rigidBody.IsSleeping())
			{
				rigidBody.WakeUp();
			}
			Vector3 val = Vector3.ProjectOnPlane(((Component)this).transform.forward, ((Component)this).transform.up);
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			rigidBody.AddForce(normalized * rigidBody.mass * 1f, (ForceMode)1);
			rigidBody.AddForceAtPosition(Vector3.up * rigidBody.mass * 2.3f, centreOfMassTransform.position + ((Component)this).transform.forward * 1f, (ForceMode)1);
		}
	}

	[RPC_Server]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanBeLooted(player))
		{
			GetFuelSystem()?.LootFuel(player);
		}
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!base.CanBeLooted(player))
		{
			return false;
		}
		if (AnyMounted())
		{
			return PlayerIsMounted(player);
		}
		return true;
	}

	public override void VehicleFixedUpdate()
	{
		base.VehicleFixedUpdate();
		float speed = GetSpeed();
		carPhysics.FixedUpdate(Time.fixedDeltaTime, speed);
		engineController.CheckEngineState();
		if (!HasDriver() || !IsOn())
		{
			throttleInput = 0f;
			steerInput = 0f;
		}
		if ((Object)(object)doorJoint == (Object)null && !HasFlag(Flags.Reserved15))
		{
			SetFlag(Flags.Unused23, b: false, recursive: false, networkupdate: false);
			SetFlag(Flags.Reserved15, b: true);
			SpawnDoorGib();
		}
		if ((Object)(object)doorRigidBody != (Object)null)
		{
			if (rigidBody.isKinematic != doorRigidBody.isKinematic)
			{
				doorRigidBody.isKinematic = rigidBody.isKinematic;
			}
			if (rigidBody.IsSleeping() != doorRigidBody.IsSleeping())
			{
				if (rigidBody.IsSleeping())
				{
					doorRigidBody.Sleep();
				}
				else
				{
					doorRigidBody.WakeUp();
				}
			}
		}
		if (base.IsMovingOrOn && base.CurEngineState == VehicleEngineController<GroundVehicle>.EngineState.On)
		{
			float fuelPerSecond = Mathf.Lerp(engine.idleFuelPerSec, engine.maxFuelPerSec, Mathf.Abs(GetThrottleInput()));
			engineController.TickFuel(fuelPerSecond);
		}
	}

	public override bool GetSteerSpeedMod(float speed)
	{
		return steerMod;
	}

	public override float GetSteerMaxMult(float speed)
	{
		return 1f;
	}

	public override float GetMaxDriveForce()
	{
		return (float)engine.engineKW * 10f;
	}

	public override float GetWheelsMidPos()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		return (((Component)wheels[0].wheelCollider).transform.localPosition.z - ((Component)wheels[5].wheelCollider).transform.localPosition.z) * 0.5f;
	}

	public override float GetMaxForwardSpeed()
	{
		return maxForwardSpeed;
	}

	private void UpdateClients()
	{
		byte num = (byte)((GetThrottleInput() + 1f) * 7f);
		byte b = (byte)(GetBrakeInput() * 15f);
		byte arg = (byte)(num + (b << 4));
		byte arg2 = (byte)(GetFuelFraction() * 255f);
		ClientRPC(RpcTarget.NetworkGroup("CLIENT_BatteringRamUpdate"), GetNetworkTime(), GetSteerInput(), arg, DriveWheelVelocity, arg2, DoorAngle);
	}

	protected override void ProcessCollision(Collision collision, Rigidbody ourRigidbody)
	{
		if (!base.isClient && collision != null && !((Object)(object)collision.gameObject == (Object)null) && !((Object)(object)collision.gameObject == (Object)null) && !((Object)(object)((ContactPoint)(ref collision.contacts[0])).thisCollider == (Object)(object)Head.serverCollider))
		{
			base.ProcessCollision(collision, ourRigidbody);
		}
	}

	public override void OnTowAttach()
	{
	}

	public override void OnTowDetach()
	{
	}

	public override void OnEngineStartFailed()
	{
		ClientRPC(RpcTarget.NetworkGroup("EngineStartFailed"));
	}

	public override bool MeetsEngineRequirements()
	{
		return HasDriver();
	}

	void IEngineControllerUser.Invoke(Action action, float time)
	{
		((FacepunchBehaviour)this).Invoke(action, time);
	}

	void IEngineControllerUser.CancelInvoke(Action action)
	{
		((FacepunchBehaviour)this).CancelInvoke(action);
	}
}


using System;

[Serializable]
private struct ImpactEffect
{
	public string materialName;

	public GameObjectRef prefab;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class BearTrap : BaseTrap
{
	protected Animator animator;

	private GameObject hurtTarget;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BearTrap.OnRpcMessage", 0);
		try
		{
			if (rpc == 547827602 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Arm "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Arm", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(547827602u, "RPC_Arm", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_Arm(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Arm");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool Armed()
	{
		return HasFlag(Flags.On);
	}

	public override void InitShared()
	{
		animator = ((Component)this).GetComponent<Animator>();
		base.InitShared();
	}

	public override bool CanPickup(BasePlayer player)
	{
		if (base.CanPickup(player) && !Armed())
		{
			return player.CanBuild();
		}
		return false;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		Arm();
	}

	public override void Arm()
	{
		base.Arm();
		RadialResetCorpses(120f);
	}

	public void Fire()
	{
		SetFlag(Flags.On, b: false);
		SendNetworkUpdate();
	}

	public override void ObjectEntered(GameObject obj)
	{
		if (Armed() && Interface.CallHook("OnTrapTrigger", (object)this, (object)obj) == null)
		{
			hurtTarget = obj;
			((FacepunchBehaviour)this).Invoke((Action)DelayedFire, 0.05f);
		}
	}

	public void DelayedFire()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)hurtTarget))
		{
			BaseEntity baseEntity = hurtTarget.ToBaseEntity();
			if ((Object)(object)baseEntity != (Object)null)
			{
				HitInfo hitInfo = new HitInfo(this, baseEntity, DamageType.Bite, 50f, ((Component)this).transform.position);
				hitInfo.damageTypes.Add(DamageType.Stab, 30f);
				baseEntity.OnAttacked(hitInfo);
			}
			hurtTarget = null;
		}
		RadialResetCorpses(1800f);
		Fire();
		Hurt(25f);
	}

	public void RadialResetCorpses(float duration)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		List<BaseCorpse> list = Pool.Get<List<BaseCorpse>>();
		Vis.Entities(((Component)this).transform.position, 5f, list, 512, (QueryTriggerInteraction)2);
		foreach (BaseCorpse item in list)
		{
			item.ResetRemovalTime(duration);
		}
		Pool.FreeUnmanaged<BaseCorpse>(ref list);
	}

	public override void OnAttacked(HitInfo info)
	{
		float num = info.damageTypes.Total();
		if ((info.damageTypes.IsMeleeType() && num > 20f) || num > 30f)
		{
			Fire();
		}
		base.OnAttacked(info);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Arm(RPCMessage rpc)
	{
		if (!Armed() && Interface.CallHook("OnTrapArm", (object)this, (object)rpc.player) == null)
		{
			Arm();
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (!base.isServer && animator.isInitialized)
		{
			animator.SetBool("armed", Armed());
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using UnityEngine;

public class BeeSwarmMaster : BaseCombatEntity, ISplashable
{
	[Header("References")]
	public ParticleSystem PSystem;

	public Light OnFireLight;

	public ParticleSystemForceField AngerForceField;

	public GameObject sound;

	public GameObjectRef beeSwarmPrefab;

	public const Flags IsDying = Flags.Reserved13;

	[ServerVar(Help = "How long a master swarm will stick around without a target")]
	public static float killWithoutATargetTime = 150f;

	[ServerVar(Help = "How many child swarms a master swarm will create")]
	public static int amountToSpawn = 3;

	[ServerVar(Help = "How long before a master swarm will create a child")]
	public static float secondsBetweenSpawns = 60f;

	private TimeSince timeSinceLastSpawnedSwarm;

	private int hasSpawnedCount;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BeeSwarmMaster.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk && base.isServer)
		{
			StartDie();
		}
	}

	public override void ServerInit()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (!base.isClient)
		{
			timeSinceLastSpawnedSwarm = TimeSince.op_Implicit(secondsBetweenSpawns);
			((FacepunchBehaviour)this).InvokeRepeating((Action)ThinkAI, 0f, 0.25f);
		}
	}

	private void ThinkAI()
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BeeSwarmMaster.ThinkAI", 0);
		try
		{
			if (!AI.effectaiweapons || (!AI.ignoreplayers && AI.think))
			{
				if (IsSmoke())
				{
					StartDie();
				}
				if (IsFire())
				{
					SetOnFire();
				}
				if (TimeSince.op_Implicit(timeSinceLastSpawnedSwarm) > killWithoutATargetTime)
				{
					StartDie();
				}
				if (TimeSince.op_Implicit(timeSinceLastSpawnedSwarm) >= secondsBetweenSpawns && (Object)(object)BeeSwarmAI.FindTarget(((Component)this).transform) != (Object)null)
				{
					SpawnSwarm();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void StartDie()
	{
		SetFlag(Flags.Reserved13, b: true);
		((FacepunchBehaviour)this).Invoke((Action)ActuallyDie, 3f, 0f);
	}

	private void ActuallyDie()
	{
		Die();
	}

	private void SpawnSwarm()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		timeSinceLastSpawnedSwarm = TimeSince.op_Implicit(0f);
		hasSpawnedCount++;
		if (hasSpawnedCount >= amountToSpawn)
		{
			StartDie();
		}
		else
		{
			float arg = (float)hasSpawnedCount / (float)amountToSpawn;
			if (net.group != null)
			{
				ClientRPC(RpcTarget.NetworkGroup("RPC_PopulationChange"), arg);
			}
		}
		Vector3 position = ((Component)this).transform.position;
		BaseEntity baseEntity = GameManager.server.CreateEntity(beeSwarmPrefab.resourcePath, position, Quaternion.identity);
		baseEntity.OwnerID = base.OwnerID;
		baseEntity.creatorEntity = creatorEntity;
		baseEntity.Spawn();
	}

	private void SetOnFire()
	{
		SetFlag(Flags.OnFire, b: true);
		StartDie();
	}

	private bool IsSmoke()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			SingletonComponent<SmokeGrenadeManager>.Instance.GetSmokeAround(((Component)this).transform.position, 5f, (List<BaseEntity>)(object)val);
			return val != null && ((List<BaseEntity>)(object)val).Count > 0;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool IsFire()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			SingletonComponent<NpcFireManager>.Instance.GetFiresAround(((Component)this).transform.position, 10f, (List<BaseEntity>)(object)val);
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				if (!((Object)(object)item == (Object)null) && !item.IsDestroyed && item is FlameThrower && Vector3.Distance(((Component)this).transform.position, ((Component)item).transform.position) <= BeeSwarmAI.flameSettingDistance)
				{
					return true;
				}
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		if ((Object)(object)splashType == (Object)null || splashType.shortname == null)
		{
			return false;
		}
		if (HasFlag(Flags.Reserved13))
		{
			return false;
		}
		if (amount > 0)
		{
			return true;
		}
		return false;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		float num = base.health - 10f;
		if (num > 0f)
		{
			Hurt(num);
		}
		if (base.health <= 10f)
		{
			StartDie();
		}
		return amount;
	}
}


using System;
using Network;
using UnityEngine;

public class BigWheelBettingTerminal : StorageContainer
{
	public BigWheelGame bigWheel;

	public Vector3 seatedPlayerOffset = Vector3.forward;

	public float offsetCheckRadius = 0.4f;

	public SoundDefinition winSound;

	public SoundDefinition loseSound;

	[NonSerialized]
	public BasePlayer lastPlayer;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BigWheelBettingTerminal.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsPlayerValid(BasePlayer player)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (!player.isMounted || !(player.GetMounted() is BaseChair))
		{
			return false;
		}
		Vector3 val = ((Component)this).transform.TransformPoint(seatedPlayerOffset);
		if (Vector3Ex.Distance2D(((Component)player).transform.position, val) > offsetCheckRadius)
		{
			return false;
		}
		return true;
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (!IsPlayerValid(player))
		{
			return false;
		}
		bool num = base.PlayerOpenLoot(player, panelToOpen);
		if (num)
		{
			lastPlayer = player;
		}
		return num;
	}

	public bool TrySetBigWheel(BigWheelGame newWheel)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return false;
		}
		if ((Object)(object)bigWheel != (Object)null && (Object)(object)bigWheel != (Object)(object)newWheel)
		{
			float num = Vector3.SqrMagnitude(((Component)bigWheel).transform.position - ((Component)this).transform.position);
			if (Vector3.SqrMagnitude(((Component)newWheel).transform.position - ((Component)this).transform.position) >= num)
			{
				return false;
			}
			bigWheel.RemoveTerminal(this);
		}
		bigWheel = newWheel;
		return true;
	}
}


using System;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class Bike : GroundVehicle, VehicleChassisVisuals<Bike>.IClientWheelUser, IPrefabPreProcess, CarPhysics<Bike>.ICar, TriggerHurtNotChild.IHurtTriggerUser
{
	public enum PoweredBy
	{
		Fuel,
		Human
	}

	public static Phrase sprintPhrase = new Phrase("sprint", "Sprint");

	public static Phrase boostPhrase = new Phrase("boost", "Boost");

	[Header("Bike")]
	[SerializeField]
	private Transform centreOfMassTransform;

	[SerializeField]
	private VisualCarWheel wheelFront;

	[SerializeField]
	private VisualCarWheel wheelRear;

	[SerializeField]
	private VisualCarWheel wheelExtra;

	[SerializeField]
	public bool snowmobileDrivingStyle;

	[SerializeField]
	public CarSettings carSettings;

	[SerializeField]
	public int engineKW = 59;

	[SerializeField]
	public float idleFuelPerSec = 0.03f;

	[SerializeField]
	public float maxFuelPerSec = 0.15f;

	[SerializeField]
	[Range(0f, 1f)]
	private float pitchStabP = 0.01f;

	[SerializeField]
	[Range(0f, 1f)]
	private float pitchStabD = 0.005f;

	[Range(0f, 1f)]
	[SerializeField]
	private float twoWheelRollStabP = 100f;

	[SerializeField]
	[Range(0f, 1f)]
	private float twoWheelRollStabD = 10f;

	[SerializeField]
	[Range(1f, 500f)]
	private float manyWheelStabP = 40f;

	[Range(1f, 100f)]
	[SerializeField]
	private float manyWheelStabD = 10f;

	[Range(0f, 1f)]
	[SerializeField]
	public float airControlTorquePower = 0.04f;

	public float sprintTime = 5f;

	[SerializeField]
	public float sprintRegenTime = 10f;

	[SerializeField]
	public float sprintBoostPercent = 0.3f;

	[SerializeField]
	private ProtectionProperties riderProtection;

	[SerializeField]
	private float hurtTriggerMinSpeed = 1f;

	[SerializeField]
	private TriggerHurtNotChild hurtTriggerFront;

	[SerializeField]
	private TriggerHurtNotChild hurtTriggerRear;

	[SerializeField]
	private float maxLeanSpeed = 20f;

	[SerializeField]
	private float leftMaxLean = 60f;

	[SerializeField]
	private float rightMaxLean = 60f;

	[SerializeField]
	private float midairRotationForce = 1f;

	[SerializeField]
	private Vector3 customInertiaTensor = new Vector3(85f, 60f, 40f);

	public PoweredBy poweredBy;

	[SerializeField]
	[Range(0f, 1f)]
	public float percentFood = 0.5f;

	[SerializeField]
	public float playerDamageThreshold = 40f;

	[SerializeField]
	public float playerDeathThreshold = 75f;

	[SerializeField]
	private bool hasBell;

	[Header("Bike Visuals")]
	public float minGroundFXSpeed;

	[SerializeField]
	private BikeChassisVisuals chassisVisuals;

	[SerializeField]
	private VehicleLight[] lights;

	[SerializeField]
	private ParticleSystemContainer exhaustFX;

	[SerializeField]
	private Transform steeringLeftIK;

	[SerializeField]
	private Transform steeringRightIK;

	[SerializeField]
	private Transform steeringRightIKAcclerating;

	[SerializeField]
	private Transform leftFootIK;

	[SerializeField]
	private Transform rightFootIK;

	[SerializeField]
	private Transform passengerLeftHandIK;

	[SerializeField]
	private Transform passengerRightHandIK;

	[SerializeField]
	private Transform passengerLeftFootIK;

	[SerializeField]
	private Transform passengerRightFootIK;

	[SerializeField]
	private ParticleSystemContainer fxMediumDamage;

	[SerializeField]
	private GameObject fxMediumDamageInstLight;

	[SerializeField]
	private ParticleSystemContainer fxHeavyDamage;

	[SerializeField]
	private GameObject fxHeavyDamageInstLight;

	[SerializeField]
	[Header("Sidecar")]
	private Rigidbody sidecarRigidBody;

	[SerializeField]
	private Transform sidecarPhysicsHinge;

	[ServerVar(Help = "How long before a bike loses all its health while outside")]
	public static float outsideDecayMinutes = 1440f;

	[ServerVar(Help = "Pedal bike population active on the server (roadside spawns)", ShowInAdminUI = true)]
	public static float pedalRoadsidePopulation = 1f;

	[SerializeField]
	private Transform realSidecarCapsule;

	[ServerVar(Help = "Pedal bike population in monuments", ShowInAdminUI = true)]
	public static float pedalMonumentPopulation = 1f;

	[SerializeField]
	private Transform duplicateSidecarCapsule;

	[ServerVar(Help = "Motorbike population in monuments", ShowInAdminUI = true)]
	public static float motorbikeMonumentPopulation = 1f;

	[ServerVar(Help = "Can bike crashes cause damage or death to the rider?")]
	public static bool doPlayerDamage = true;

	[ServerVar(Help = "Amount of collision damage on a bike required to ragdoll the player")]
	public static float playerDamageRagdollTheshold = 10f;

	private bool hasExtraWheel;

	public bool hasSidecar;

	private bool hasDamageFX;

	private float _throttle;

	private float _brake;

	public const Flags Flag_SprintInput = Flags.Reserved6;

	public const Flags Flag_DuckInput = Flags.Reserved8;

	public const Flags Flag_IsSprinting = Flags.Reserved9;

	private float _mass = -1f;

	private float cachedFuelFraction;

	private const float FORCE_MULTIPLIER = 10f;

	private float _steer;

	public CarPhysics<Bike> carPhysics;

	private VehicleTerrainHandler serverTerrainHandler;

	private CarWheel[] wheels;

	public TimeSince timeSinceLastUsed;

	private const float DECAY_TICK_TIME = 60f;

	private float prevPitchStabError;

	private float prevRollStabError;

	private float prevRollStabRoll;

	public float lastCrashDamage;

	private TimeSince timeSinceBellDing;

	private bool wasWantingSlopeSprint;

	private bool inBurnoutMode;

	private bool shouldBypassClippingChecks;

	public float ThrottleInput
	{
		get
		{
			if (!engineController.IsOn)
			{
				return 0f;
			}
			return _throttle;
		}
		protected set
		{
			_throttle = Mathf.Clamp(value, -1f, 1f);
		}
	}

	public float BrakeInput
	{
		get
		{
			return _brake;
		}
		protected set
		{
			_brake = Mathf.Clamp(value, 0f, 1f);
		}
	}

	public bool IsBraking => BrakeInput > 0f;

	public bool SprintInput
	{
		get
		{
			return HasFlag(Flags.Reserved6);
		}
		private set
		{
			if (SprintInput != value)
			{
				SetFlag(Flags.Reserved6, value);
			}
		}
	}

	public bool DuckInput
	{
		get
		{
			return HasFlag(Flags.Reserved8);
		}
		private set
		{
			if (DuckInput != value)
			{
				SetFlag(Flags.Reserved8, value);
			}
		}
	}

	public bool CanSprint => poweredBy == PoweredBy.Human;

	public bool IsSprinting
	{
		get
		{
			return HasFlag(Flags.Reserved9);
		}
		private set
		{
			if (IsSprinting != value)
			{
				SetFlag(Flags.Reserved9, value);
			}
		}
	}

	public float SprintPercentRemaining { get; protected set; }

	public float SteerAngle
	{
		get
		{
			if (base.isServer)
			{
				return carPhysics.SteerAngle;
			}
			return 0f;
		}
	}

	public override float DriveWheelVelocity
	{
		get
		{
			if (base.isServer)
			{
				float num = carPhysics.DriveWheelVelocity;
				if (inBurnoutMode && ThrottleInput > 0.1f)
				{
					num += ThrottleInput * 20f;
				}
				return num;
			}
			return 0f;
		}
	}

	public float DriveWheelSlip
	{
		get
		{
			if (base.isServer)
			{
				return carPhysics.DriveWheelSlip;
			}
			return 0f;
		}
	}

	public float SidecarAngle
	{
		get
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			if (base.isServer)
			{
				return sidecarPhysicsHinge.localEulerAngles.z;
			}
			return 0f;
		}
	}

	public float MaxSteerAngle => carSettings.maxSteerAngle;

	private float Mass
	{
		get
		{
			if (base.isServer)
			{
				return rigidBody.mass;
			}
			return _mass;
		}
	}

	public float SteerInput
	{
		get
		{
			return _steer;
		}
		protected set
		{
			_steer = Mathf.Clamp(value, -1f, 1f);
		}
	}

	public VehicleTerrainHandler.Surface OnSurface
	{
		get
		{
			if (serverTerrainHandler == null)
			{
				return VehicleTerrainHandler.Surface.Default;
			}
			return serverTerrainHandler.OnSurface;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Bike.OnRpcMessage", 0);
		try
		{
			if (rpc == 1851540757 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenFuel "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenFuel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_OpenFuel(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_OpenFuel");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void PreInitShared()
	{
		hasExtraWheel = (Object)(object)wheelExtra.wheelCollider != (Object)null;
		hasSidecar = (Object)(object)sidecarPhysicsHinge != (Object)null;
		hasDamageFX = (Object)(object)fxMediumDamage != (Object)null;
		base.PreInitShared();
	}

	public override void Load(LoadInfo info)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.bike != null)
		{
			engineController.FuelSystem.SetInstanceID(info.msg.bike.fuelStorageID);
			cachedFuelFraction = info.msg.bike.fuelFraction;
		}
	}

	public float GetMaxDriveForce()
	{
		float num = (float)engineKW * 10f * GetPerformanceFraction();
		if (IsSprinting)
		{
			num *= 1f + sprintBoostPercent;
		}
		return num;
	}

	public override float GetMaxForwardSpeed()
	{
		float num = GetMaxDriveForce() / Mass * 15f;
		if (IsSprinting)
		{
			num *= 1f + sprintBoostPercent;
		}
		return num;
	}

	public override float GetThrottleInput()
	{
		return ThrottleInput;
	}

	public override float GetBrakeInput()
	{
		return BrakeInput;
	}

	public float GetPerformanceFraction()
	{
		float num = Mathf.InverseLerp(0.25f, 0.5f, base.healthFraction);
		return Mathf.Lerp(0.5f, 1f, num);
	}

	public float GetFuelFraction()
	{
		if (base.isServer)
		{
			return Mathf.Clamp01((float)engineController.FuelSystem.GetFuelAmount() / 100f);
		}
		return cachedFuelFraction;
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!base.CanBeLooted(player))
		{
			return false;
		}
		if (AnyMounted())
		{
			if (PlayerIsMounted(player))
			{
				return player.modelState.poseType == 26;
			}
			return false;
		}
		return true;
	}

	protected override IFuelSystem CreateFuelSystem()
	{
		if (poweredBy == PoweredBy.Fuel)
		{
			return base.CreateFuelSystem();
		}
		return new HumanFuelSystem(base.isServer, this, percentFood);
	}

	private bool CanPlayerSeeMountPoint(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (!GamePhysics.CheckCapsule(player.eyes.position, mountAnchor.position, 0.25f, 2162688, (QueryTriggerInteraction)0))
		{
			return !GamePhysics.CheckCapsule(player.eyes.position, mountAnchor.position + Vector3.up * 0.5f, 0.25f, 2162688, (QueryTriggerInteraction)0);
		}
		return false;
	}

	public float GetSteerInput()
	{
		return SteerInput;
	}

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		timeSinceLastUsed = TimeSince.op_Implicit(0f);
		rigidBody.centerOfMass = centreOfMassTransform.localPosition;
		rigidBody.inertiaTensor = customInertiaTensor;
		carPhysics = new CarPhysics<Bike>(this, ((Component)this).transform, rigidBody, carSettings);
		serverTerrainHandler = new VehicleTerrainHandler(this);
		SprintPercentRemaining = 1f;
		((FacepunchBehaviour)this).InvokeRandomized((Action)UpdateClients, 0f, 0.1f, 0.01f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)BikeDecay, Random.Range(30f, 60f), 60f, 6f);
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		if (base.isServer)
		{
			ProcessCollision(collision, sidecarRigidBody);
		}
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Bike.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			float speed = GetSpeed();
			carPhysics.FixedUpdate(Time.fixedDeltaTime, speed);
			serverTerrainHandler.FixedUpdate();
			bool flag = false;
			if (IsOn())
			{
				inBurnoutMode = false;
				float fuelPerSecond = Mathf.Lerp(idleFuelPerSec, maxFuelPerSec, Mathf.Abs(ThrottleInput));
				engineController.TickFuel(fuelPerSecond);
				if (CanSprint && carPhysics.IsGrounded() && WantsSprint(speed))
				{
					SprintPercentRemaining -= Time.deltaTime / sprintTime;
					SprintPercentRemaining = Mathf.Clamp01(SprintPercentRemaining);
					flag = SprintPercentRemaining > 0f;
				}
				bool flag2 = DuckInput || (ThrottleInput > 0f && BrakeInput > 0f);
				if (poweredBy == PoweredBy.Fuel && carPhysics.IsGrounded() && flag2)
				{
					inBurnoutMode = true;
				}
			}
			engineController.CheckEngineState();
			if (CanSprint && !flag && SprintPercentRemaining < 1f)
			{
				SprintPercentRemaining += Time.deltaTime / sprintRegenTime;
				SprintPercentRemaining = Mathf.Clamp01(SprintPercentRemaining);
			}
			IsSprinting = flag;
			bool num = rigidBody.IsSleeping();
			if (!num)
			{
				AwakeBikePhysicsTick(speed);
			}
			RigidbodyConstraints val2 = (RigidbodyConstraints)(num ? 64 : 0);
			if (rigidBody.constraints != val2)
			{
				rigidBody.constraints = val2;
				if ((int)rigidBody.constraints == 0)
				{
					rigidBody.inertiaTensor = customInertiaTensor;
				}
			}
			((Component)hurtTriggerFront).gameObject.SetActive(speed > hurtTriggerMinSpeed);
			((Component)hurtTriggerRear).gameObject.SetActive(speed < 0f - hurtTriggerMinSpeed);
			if (!hasSidecar)
			{
				return;
			}
			if (rigidBody.isKinematic != sidecarRigidBody.isKinematic)
			{
				sidecarRigidBody.isKinematic = rigidBody.isKinematic;
			}
			if (rigidBody.IsSleeping() != sidecarRigidBody.IsSleeping())
			{
				if (rigidBody.IsSleeping())
				{
					sidecarRigidBody.Sleep();
				}
				else
				{
					sidecarRigidBody.WakeUp();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected virtual void AwakeBikePhysicsTick(float speed)
	{
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		if (rigidBody.isKinematic)
		{
			return;
		}
		bool num = carPhysics.IsGrounded();
		if (snowmobileDrivingStyle)
		{
			if (!carPhysics.IsGrounded())
			{
				StabiliseSnowmobileStyle();
				PDPitchStab();
			}
		}
		else
		{
			PDPitchStab();
			PDDirectionStab();
			PDRollStab(speed);
		}
		float num2 = 0f;
		if (!num)
		{
			if (SprintInput && !DuckInput)
			{
				num2 = 0f - airControlTorquePower;
			}
			else if (DuckInput && !SprintInput)
			{
				num2 = airControlTorquePower;
			}
		}
		if (num2 != 0f)
		{
			rigidBody.AddRelativeTorque(num2, 0f, 0f, (ForceMode)2);
		}
		if (hasSidecar)
		{
			duplicateSidecarCapsule.SetPositionAndRotation(realSidecarCapsule.position, realSidecarCapsule.rotation);
		}
	}

	private void PDPitchStab()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		float num = ((Component)this).transform.localEulerAngles.x;
		if (num > 180f)
		{
			num -= 360f;
		}
		float num2 = 0f - num;
		float num3 = num2;
		float num4 = (num2 - prevPitchStabError) / Time.fixedDeltaTime;
		float num5 = pitchStabP * num3 + pitchStabD * num4;
		rigidBody.AddRelativeTorque(num5, 0f, 0f, (ForceMode)2);
		prevPitchStabError = num2;
	}

	private void PDDirectionStab()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		Vector3 angularVelocity = rigidBody.angularVelocity;
		float num = (carPhysics.IsGrounded() ? (0.05f + Mathf.Abs(SteerAngle) * 0.15f) : 0.05f);
		angularVelocity.y = Mathf.Clamp(angularVelocity.y, 0f - num, num);
		rigidBody.angularVelocity = angularVelocity;
	}

	private void PDRollStab(float speed)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		float num = ((speed >= 0f) ? speed : ((0f - speed) * 0.33f));
		float num2 = 0f - SteerAngle / MaxSteerAngle * Mathf.Clamp01(num / maxLeanSpeed);
		num2 = ((!(num2 < 0f)) ? (num2 * leftMaxLean) : (num2 * rightMaxLean));
		float num3 = ((Component)this).transform.localEulerAngles.z;
		if (num3 > 180f)
		{
			num3 -= 360f;
		}
		float num4 = num2 - num3;
		float num5 = num4;
		float num6 = 0f - AngleDifference(num3, prevRollStabRoll) / Time.fixedDeltaTime;
		float num7 = twoWheelRollStabP * num5 + twoWheelRollStabD * num6;
		rigidBody.AddRelativeTorque(0f, 0f, num7, (ForceMode)2);
		prevRollStabError = num4;
		prevRollStabRoll = num3;
	}

	private float AngleDifference(float a, float b)
	{
		return (a - b + 540f) % 360f - 180f;
	}

	private void StabiliseSnowmobileStyle()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(((Component)this).transform.position, Vector3.down, ref val, 10f, 1218511105, (QueryTriggerInteraction)1))
		{
			Vector3 normal = ((RaycastHit)(ref val)).normal;
			Vector3 right = ((Component)this).transform.right;
			right.y = 0f;
			normal = Vector3.ProjectOnPlane(normal, right);
			float num = Vector3.Angle(normal, Vector3.up);
			Vector3 angularVelocity = rigidBody.angularVelocity;
			float num2 = ((Vector3)(ref angularVelocity)).magnitude * 57.29578f * manyWheelStabD / manyWheelStabP;
			if (num <= 45f)
			{
				Vector3 val2 = Vector3.Cross(Quaternion.AngleAxis(num2, rigidBody.angularVelocity) * ((Component)this).transform.up, normal) * manyWheelStabP * manyWheelStabP;
				Vector3 val3 = ((Component)rigidBody).transform.InverseTransformDirection(val2);
				rigidBody.AddRelativeTorque(val3);
			}
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		if (!IsDriver(player))
		{
			return;
		}
		timeSinceLastUsed = TimeSince.op_Implicit(0f);
		if (inputState.IsDown(BUTTON.FIRE_THIRD))
		{
			SteerInput += inputState.MouseDelta().x * 0.1f;
		}
		else
		{
			SteerInput = 0f;
			if (inputState.IsDown(BUTTON.LEFT))
			{
				SteerInput = -1f;
			}
			else if (inputState.IsDown(BUTTON.RIGHT))
			{
				SteerInput = 1f;
			}
		}
		bool flag = inputState.IsDown(BUTTON.FORWARD);
		bool flag2 = inputState.IsDown(BUTTON.BACKWARD);
		BrakeInput = 0f;
		if (GetSpeed() > 3f)
		{
			ThrottleInput = (flag ? 1f : 0f);
			BrakeInput = (flag2 ? 1f : 0f);
		}
		else
		{
			ThrottleInput = (flag ? 1f : (flag2 ? (-1f) : 0f));
		}
		SprintInput = inputState.IsDown(BUTTON.SPRINT);
		DuckInput = inputState.IsDown(BUTTON.DUCK);
		if (engineController.IsOff && ((inputState.IsDown(BUTTON.FORWARD) && !inputState.WasDown(BUTTON.FORWARD)) || (inputState.IsDown(BUTTON.BACKWARD) && !inputState.WasDown(BUTTON.BACKWARD))))
		{
			engineController.TryStartEngine(player);
		}
		if (hasBell && inputState.IsDown(BUTTON.FIRE_PRIMARY) && !inputState.WasDown(BUTTON.FIRE_PRIMARY) && TimeSince.op_Implicit(timeSinceBellDing) > 1f)
		{
			ClientRPC(RpcTarget.NetworkGroup("RingBell"));
			timeSinceBellDing = TimeSince.op_Implicit(0f);
		}
	}

	public float GetAdjustedDriveForce(float absSpeed, float topSpeed)
	{
		float maxDriveForce = GetMaxDriveForce();
		float num = Mathf.Lerp(0.3f, 0.75f, GetPerformanceFraction());
		float num2 = MathEx.BiasedLerp(1f - absSpeed / topSpeed, num);
		return maxDriveForce * num2;
	}

	public bool GetSteerSpeedMod(float speed)
	{
		return inBurnoutMode;
	}

	public virtual float GetSteerMaxMult(float speed)
	{
		if (speed < 0f)
		{
			return 0.5f;
		}
		if (!inBurnoutMode)
		{
			return 1f;
		}
		return 1.35f;
	}

	public override float MaxVelocity()
	{
		return Mathf.Max(GetMaxForwardSpeed() * 1.3f, 30f);
	}

	public CarWheel[] GetWheels()
	{
		if (wheels == null)
		{
			if (hasExtraWheel)
			{
				wheels = new CarWheel[3] { wheelFront, wheelRear, wheelExtra };
			}
			else
			{
				wheels = new CarWheel[2] { wheelFront, wheelRear };
			}
		}
		return wheels;
	}

	public float GetWheelsMidPos()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		return (((Component)wheelFront.wheelCollider).transform.localPosition.z - ((Component)wheelRear.wheelCollider).transform.localPosition.z) * 0.5f;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.bike = Pool.Get<Bike>();
		info.msg.bike.steerInput = SteerAngle;
		info.msg.bike.driveWheelVel = DriveWheelVelocity;
		info.msg.bike.throttleInput = ThrottleInput;
		info.msg.bike.brakeInput = BrakeInput;
		info.msg.bike.fuelStorageID = GetFuelSystem().GetInstanceID();
		info.msg.bike.fuelFraction = GetFuelFraction();
		if (hasSidecar)
		{
			info.msg.bike.sidecarAngle = SidecarAngle;
			info.msg.bike.time = GetNetworkTime();
		}
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		base.OnParentChanging(oldParent, newParent);
		shouldBypassClippingChecks = false;
		if ((Object)(object)newParent != (Object)null && HasDriver() && (Object)(object)((Component)newParent).GetComponentInChildren<TriggerParentEnclosed>() != (Object)null)
		{
			shouldBypassClippingChecks = true;
		}
	}

	public override void SeatClippedWorld(BaseMountable mountable)
	{
		if (!shouldBypassClippingChecks)
		{
			base.SeatClippedWorld(mountable);
		}
	}

	public override void DoCollisionDamage(BaseEntity hitEntity, float damage)
	{
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		lastCrashDamage = damage;
		if (doPlayerDamage && damage > playerDamageThreshold)
		{
			float num = ((damage > playerDeathThreshold) ? 9999f : ((damage - playerDamageThreshold) / 2f));
			float num2 = ((damage > playerDeathThreshold) ? 9999f : (num * 0.5f));
			foreach (MountPointInfo mountPoint in mountPoints)
			{
				if (!((Object)(object)mountPoint.mountable != (Object)null))
				{
					continue;
				}
				BasePlayer mounted = mountPoint.mountable.GetMounted();
				if ((Object)(object)mounted != (Object)null)
				{
					float num3 = (mountPoint.isDriver ? num : num2);
					mounted.Hurt(num3, DamageType.Collision, this, useProtection: false);
					if (num3 > playerDamageRagdollTheshold && !mounted.IsDead())
					{
						Vector3 mountRagdollVelocity = GetMountRagdollVelocity(mounted);
						mounted.Ragdoll(mountRagdollVelocity);
					}
				}
			}
		}
		base.DoCollisionDamage(hitEntity, damage);
	}

	public override Vector3 GetMountRagdollVelocity(BasePlayer player)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Clamp(lastCrashDamage, 0f, 75f);
		return ((Component)this).transform.forward * num * 0.25f;
	}

	public override int StartingFuelUnits()
	{
		return 0;
	}

	public override bool MeetsEngineRequirements()
	{
		return HasDriver();
	}

	public void BikeDecay()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		if (!IsDead() && !(TimeSince.op_Implicit(timeSinceLastUsed) < 2700f))
		{
			float num = (IsOutside() ? outsideDecayMinutes : float.PositiveInfinity);
			if (!float.IsPositiveInfinity(num))
			{
				float num2 = 1f / num;
				Hurt(MaxHealth() * num2, DamageType.Decay, this, useProtection: false);
			}
		}
	}

	public override float GetModifiedDrag()
	{
		float num = base.GetModifiedDrag();
		if (!IsOn() && !HasDriver())
		{
			num = Mathf.Max(num, 0.5f);
		}
		return num;
	}

	private void UpdateClients()
	{
		if (HasDriver())
		{
			byte num = (byte)((ThrottleInput + 1f) * 7f);
			byte b = (byte)(BrakeInput * 15f);
			byte throttleAndBrake = (byte)(num + (b << 4));
			SendClientRPC(throttleAndBrake);
		}
	}

	public virtual void SendClientRPC(byte throttleAndBrake)
	{
		if (hasSidecar)
		{
			ClientRPC(RpcTarget.NetworkGroup("BikeUpdateSC"), GetNetworkTime(), SteerAngle, throttleAndBrake, DriveWheelVelocity, GetFuelFraction(), SidecarAngle);
		}
		else if (CanSprint)
		{
			ClientRPC(RpcTarget.NetworkGroup("BikeUpdateSP"), GetNetworkTime(), SteerAngle, throttleAndBrake, DriveWheelVelocity, GetFuelFraction(), SprintPercentRemaining);
		}
		else
		{
			ClientRPC(RpcTarget.NetworkGroup("BikeUpdate"), GetNetworkTime(), SteerAngle, throttleAndBrake, DriveWheelVelocity, GetFuelFraction());
		}
	}

	public override void OnEngineStartFailed()
	{
		ClientRPC(RpcTarget.NetworkGroup("EngineStartFailed"));
	}

	public override void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
	{
		base.ScaleDamageForPlayer(player, info);
		if (info.UseProtection)
		{
			riderProtection.Scale(info.damageTypes);
		}
	}

	private bool WantsSprint(float speed)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (SprintInput)
		{
			return true;
		}
		if (speed > 5f || ThrottleInput <= 0.5f || BrakeInput > 0f)
		{
			return false;
		}
		float num = ((Component)this).transform.localEulerAngles.x;
		if (num > 180f)
		{
			num -= 360f;
		}
		return wasWantingSlopeSprint = (wasWantingSlopeSprint ? (num <= -18f) : (num <= -23f));
	}

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (CanPlayerSeeMountPoint(player))
		{
			base.AttemptMount(player, doMountChecks);
		}
	}

	[RPC_Server]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanBeLooted(player))
		{
			GetFuelSystem().LootFuel(player);
		}
	}
}


public enum PoweredBy
{
	Fuel,
	Human
}


using System;
using Network;
using UnityEngine;

public class Boomerang : BaseMelee
{
	public static readonly int CatchHash = Animator.StringToHash("catch");

	private static readonly int CaughtHash = Animator.StringToHash("caught");

	private bool hasThrown;

	public bool HasThrown => hasThrown;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("Boomerang.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void SetHeld(bool bHeld)
	{
		base.SetHeld(bHeld);
		if (!hasThrown)
		{
			return;
		}
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null)
		{
			ownerItem.UseItem();
			if (ownerItem.amount == 0)
			{
				ownerItem.SetParent(null);
			}
		}
	}

	public void SetHasThrown(bool thrown)
	{
		hasThrown = thrown;
		ClientRPC(RpcTarget.NetworkGroup("RPC_Caught"), thrown);
	}

	public override void ServerUse(float damageModifier = 1f, float speedModifier = 1f, Matrix4x4? originOverride = null, bool useBulletThickness = true)
	{
		if (!hasThrown)
		{
			base.ServerUse(damageModifier, speedModifier, originOverride, useBulletThickness);
		}
	}

	protected override bool VerifyClientAttack(BasePlayer player)
	{
		if (hasThrown)
		{
			return false;
		}
		return base.VerifyClientAttack(player);
	}

	protected override void OnEntityThrow(BaseEntity ent)
	{
		base.OnEntityThrow(ent);
		SetHasThrown(thrown: true);
		ThrownBoomerang thrownBoomerang = ent as ThrownBoomerang;
		if ((Object)(object)thrownBoomerang != (Object)null)
		{
			Item ownerItem = GetOwnerItem();
			if (ownerItem != null)
			{
				thrownBoomerang.Condition = ownerItem.condition;
			}
		}
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class BowWeapon : BaseProjectile
{
	private Action _updateFireFlagAction;

	private Action UpdateFireFlagAction => UpdateFireFlag;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BowWeapon.OnRpcMessage", 0);
		try
		{
			if (rpc == 4228048190u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - BowReload "));
				}
				TimeWarning val2 = TimeWarning.New("BowReload", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(4228048190u, "BowReload", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							BowReload(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in BowReload");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void OnHeldChanged()
	{
		TimeWarning val = TimeWarning.New("BowWeapon.OnHeldChanged", 0);
		try
		{
			base.OnHeldChanged();
			if (!base.isServer)
			{
				return;
			}
			if (IsDeployed())
			{
				((FacepunchBehaviour)this).InvokeRepeating(UpdateFireFlagAction, 0.1f, 0.1f);
				return;
			}
			((FacepunchBehaviour)this).CancelInvoke(UpdateFireFlagAction);
			if (IsOnFire())
			{
				SetFlag(Flags.OnFire, b: false);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void UpdateFireFlag()
	{
		TimeWarning val = TimeWarning.New("BowWeapon.UpdateFireFlag", 0);
		try
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if (!ownerPlayer.IsUnityNull())
			{
				if (!IsOnFire() && ownerPlayer.modelState.aiming && (Object)(object)primaryMagazine.ammoType == (Object)(object)ArrowItemDefinitions.FireArrowItemDef)
				{
					SetFlag(Flags.OnFire, b: true);
				}
				else if (IsOnFire() && (!ownerPlayer.modelState.aiming || (Object)(object)primaryMagazine.ammoType != (Object)(object)ArrowItemDefinitions.FireArrowItemDef))
				{
					SetFlag(Flags.OnFire, b: false);
				}
			}
			else
			{
				SetFlag(Flags.OnFire, b: false);
			}
			if (IsOnFire())
			{
				SingletonComponent<NpcFireManager>.Instance.Move(this);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void BowReload(RPCMessage msg)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null)
		{
			TryReloadMagazine(ownerPlayer.inventory);
		}
	}

	public override bool ForceSendMagazine(SaveInfo saveInfo)
	{
		return true;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

public class BradleyAPC : BaseCombatEntity, TriggerHurtNotChild.IHurtTriggerUser, IPathListener
{
	[Serializable]
	public class ScientistSpawnGroup
	{
		public float BradleyHealth;

		public List<GameObjectRef> SpawnPrefabs;

		public bool Spawned;
	}

	[Serializable]
	public class TargetInfo : IPooled
	{
		public float damageReceivedFrom;

		public BaseEntity entity;

		public float lastSeenTime;

		public Vector3 lastSeenPosition;

		public void EnterPool()
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			entity = null;
			lastSeenPosition = Vector3.zero;
			lastSeenTime = 0f;
		}

		public void Setup(BaseEntity ent, float time)
		{
			entity = ent;
			lastSeenTime = time;
		}

		public void LeavePool()
		{
		}

		public float GetPriorityScore(BradleyAPC apc)
		{
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			BasePlayer basePlayer = entity as BasePlayer;
			if (Object.op_Implicit((Object)(object)basePlayer))
			{
				float num = Vector3.Distance(((Component)entity).transform.position, ((Component)apc).transform.position);
				float num2 = (1f - Mathf.InverseLerp(10f, 80f, num)) * 50f;
				float num3 = (((Object)(object)basePlayer.GetHeldEntity() == (Object)null) ? 0f : basePlayer.GetHeldEntity().hostileScore);
				float num4 = Mathf.InverseLerp(4f, 20f, num3) * 100f;
				float num5 = Mathf.InverseLerp(10f, 3f, Time.time - lastSeenTime) * 100f;
				float num6 = Mathf.InverseLerp(0f, 100f, damageReceivedFrom) * 50f;
				return num2 + num4 + num6 + num5;
			}
			return 0f;
		}

		public bool IsVisible()
		{
			if (lastSeenTime != -1f)
			{
				return Time.time - lastSeenTime < sightUpdateRate * 2f;
			}
			return false;
		}

		public bool IsValid()
		{
			return (Object)(object)entity != (Object)null;
		}
	}

	[Header("Sound")]
	public BlendedLoopEngineSound engineSound;

	public SoundDefinition treadLoopDef;

	public AnimationCurve treadGainCurve;

	public AnimationCurve treadPitchCurve;

	public AnimationCurve treadFreqCurve;

	private Sound treadLoop;

	private SoundModulation.Modulator treadGain;

	private SoundModulation.Modulator treadPitch;

	public SoundDefinition chasisLurchSoundDef;

	public float chasisLurchAngleDelta = 2f;

	public float chasisLurchSpeedDelta = 2f;

	public float lastAngle;

	public float lastSpeed;

	public SoundDefinition turretTurnLoopDef;

	public float turretLoopGainSpeed = 3f;

	public float turretLoopPitchSpeed = 3f;

	public float turretLoopMinAngleDelta;

	public float turretLoopMaxAngleDelta = 10f;

	public float turretLoopPitchMin = 0.5f;

	public float turretLoopPitchMax = 1f;

	public float turretLoopGainThreshold = 0.0001f;

	private Sound turretTurnLoop;

	private SoundModulation.Modulator turretTurnLoopGain;

	private SoundModulation.Modulator turretTurnLoopPitch;

	public float enginePitch = 0.9f;

	public float rpmMultiplier = 0.6f;

	private TreadAnimator treadAnimator;

	[Header("Wheels")]
	public WheelCollider[] leftWheels;

	public WheelCollider[] rightWheels;

	[Header("Movement Config")]
	public float moveForceMax = 2000f;

	public float brakeForce = 100f;

	public float turnForce = 2000f;

	public float sideStiffnessMax = 1f;

	public float sideStiffnessMin = 0.5f;

	public Transform centerOfMass;

	public float stoppingDist = 5f;

	[Header("Control")]
	public float throttle = 1f;

	public float turning;

	public float rightThrottle;

	public float leftThrottle;

	public bool brake;

	[Header("Other")]
	public Rigidbody myRigidBody;

	public Collider myCollider;

	public Vector3 destination;

	public Vector3 finalDestination;

	public Transform followTest;

	public TriggerHurtEx impactDamager;

	[Header("Weapons")]
	public Transform mainTurretEyePos;

	public Transform mainTurret;

	public Transform CannonPitch;

	public Transform CannonMuzzle;

	public Transform coaxPitch;

	public Transform coaxMuzzle;

	public Transform topTurretEyePos;

	public Transform topTurretYaw;

	public Transform topTurretPitch;

	public Transform topTurretMuzzle;

	public GameObjectRef SmokeGrenadePrefab;

	public Vector3 turretAimVector = Vector3.forward;

	public Vector3 desiredAimVector = Vector3.forward;

	public Vector3 topTurretAimVector = Vector3.forward;

	public Vector3 desiredTopTurretAimVector = Vector3.forward;

	[Header("Effects")]
	public GameObjectRef explosionEffect;

	public GameObjectRef servergibs;

	public GameObjectRef fireBall;

	public GameObjectRef crateToDrop;

	public GameObjectRef debrisFieldMarker;

	[Header("Loot")]
	public int maxCratesToSpawn;

	[Header("Spline")]
	public float splineMovementSpeed = 2f;

	public Vector3 splineOffset;

	[Header("Other")]
	public int patrolPathIndex;

	public IAIPath patrolPath;

	public bool DoAI = true;

	public GameObjectRef mainCannonMuzzleFlash;

	public GameObjectRef mainCannonProjectile;

	public float recoilScale = 200f;

	public NavMeshPath navMeshPath;

	public int navMeshPathIndex;

	private SimpleSplineTranslator splineTranslator;

	private LayerMask obstacleHitMask;

	private TimeSince timeSinceSeemingStuck;

	private TimeSince timeSinceStuckReverseStart;

	public const string PREFAB_PATH = "assets/prefabs/npc/m2bradley/bradleyapc.prefab";

	public float nextFireTime = 10f;

	public int numBursted;

	public float nextPatrolTime;

	public float nextEngagementPathTime;

	public float currentSpeedZoneLimit;

	[Header("Pathing")]
	public List<Vector3> currentPath;

	public int currentPathIndex;

	public bool pathLooping;

	private bool followingSpine;

	private int splineId = -1;

	private WorldSpline spline;

	private int entryDirection = 1;

	private TimeSince lastJoinedSpline;

	private float lastDist;

	[Header("Scientists")]
	public GameObject AIRoot;

	public GameObjectRef MonumentScientistPrefab;

	public GameObjectRef RoadScientistPrefab;

	public int ScientistSpawnCount = 4;

	public float ScientistSpawnRadius = 3f;

	public List<GameObject> ScientistSpawnPoints = new List<GameObject>();

	public List<ScientistSpawnGroup> ScientistSpawns = new List<ScientistSpawnGroup>();

	public bool SetScientistChaseBasedOnWeapon = true;

	[ServerVar]
	public static float DeployHealthRangeMin = 0.4f;

	[ServerVar]
	public static float DeployHealthRangeMax = 0.5f;

	[ServerVar]
	public static float DeployAttackDistanceMax = 50f;

	[ServerVar]
	public static float DeployInterval = 1f;

	[ServerVar]
	public static float DeployOnDamageCheckInterval = 1f;

	[ServerVar]
	public static float ScientistRedeploymentMinInterval = 60f;

	[ServerVar]
	public static float MountAfterNotAttackedDuration = 180f;

	[ServerVar]
	public static float MountAfterNotTargetsDuration = 60f;

	[ServerVar]
	public static float MountAfterNotFiredDuration = 60f;

	[ServerVar]
	public static bool UseSmokeGrenades = true;

	[ServerVar]
	public static bool KillScientistsOnBradleyDeath = false;

	[HideInInspector]
	public bool RoadSpawned = true;

	private List<ScientistNPC> activeScientists = new List<ScientistNPC>();

	private List<GameObjectRef> mountedScientistPrefabs = new List<GameObjectRef>();

	private List<Vector3> scientistSpawnPositions = new List<Vector3>();

	private int numberOfScientistsToSpawn;

	private TimeSince timeSinceScientistDeploy;

	private TimeSince timeSinceDeployCheck;

	private TimeSince timeSinceValidTarget;

	private TimeSince deployedTimeSinceBradleyAttackedTarget;

	private static int walkableAreaMask;

	private bool mountingScientists;

	private bool inDeployedState;

	private bool deployingScientists;

	private Dictionary<uint, GameObjectRef> scientistPrefabLookUp = new Dictionary<uint, GameObjectRef>();

	[Header("Targeting")]
	public float viewDistance = 100f;

	public float searchRange = 100f;

	public float searchFrequency = 2f;

	public float memoryDuration = 20f;

	public static float sightUpdateRate = 0.5f;

	public List<TargetInfo> targetList = new List<TargetInfo>();

	public BaseCombatEntity mainGunTarget;

	[Header("Coax")]
	public float coaxFireRate = 0.06667f;

	public int coaxBurstLength = 10;

	public float coaxAimCone = 3f;

	public float bulletDamage = 15f;

	[Header("TopTurret")]
	public float topTurretFireRate = 0.25f;

	public float nextCoaxTime;

	public int numCoaxBursted;

	public float nextTopTurretTime = 0.3f;

	public GameObjectRef gun_fire_effect;

	public GameObjectRef bulletEffect;

	public float lastLateUpdate;

	public override float PositionTickRate
	{
		protected get
		{
			return 0.1f;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BradleyAPC.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.bradley != null && !info.fromDisk)
		{
			throttle = info.msg.bradley.engineThrottle;
			rightThrottle = info.msg.bradley.throttleRight;
			leftThrottle = info.msg.bradley.throttleLeft;
			desiredAimVector = info.msg.bradley.mainGunVec;
			desiredTopTurretAimVector = info.msg.bradley.topTurretVec;
		}
	}

	public void BuildingCheck()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(WorldSpaceBounds(), list, 256, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!(item is Barricade barricade))
			{
				if (item is ConstructableEntity { isServer: not false } constructableEntity && constructableEntity.IsAlive())
				{
					constructableEntity.Kill(DestroyMode.Gib);
				}
			}
			else if (barricade.IsAlive() && barricade.isServer)
			{
				barricade.Kill(DestroyMode.Gib);
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	public override void Save(SaveInfo info)
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (!info.forDisk)
		{
			info.msg.bradley = Pool.Get<BradleyAPC>();
			info.msg.bradley.engineThrottle = throttle;
			info.msg.bradley.throttleLeft = leftThrottle;
			info.msg.bradley.throttleRight = rightThrottle;
			info.msg.bradley.mainGunVec = turretAimVector;
			info.msg.bradley.topTurretVec = topTurretAimVector;
		}
	}

	public static BradleyAPC SpawnRoadDrivingBradley(Vector3 spawnPos, Quaternion spawnRot)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02af: Unknown result type (might be due to invalid IL or missing references)
		RuntimePath runtimePath = new RuntimePath();
		PathList pathList = null;
		float num = float.PositiveInfinity;
		foreach (PathList road in TerrainMeta.Path.Roads)
		{
			_ = Vector3.zero;
			float num2 = float.PositiveInfinity;
			Vector3[] points = road.Path.Points;
			foreach (Vector3 val in points)
			{
				float num3 = Vector3.Distance(val, spawnPos);
				if (num3 < num2)
				{
					num2 = num3;
				}
			}
			if (num2 < num)
			{
				pathList = road;
				num = num2;
			}
		}
		if (pathList == null)
		{
			return null;
		}
		Vector3 startPoint = pathList.Path.GetStartPoint();
		Vector3 endPoint = pathList.Path.GetEndPoint();
		bool flag = startPoint == endPoint;
		int num4 = (flag ? (pathList.Path.Points.Length - 1) : pathList.Path.Points.Length);
		IAIPathNode[] nodes = new RuntimePathNode[num4];
		runtimePath.Nodes = nodes;
		IAIPathNode iAIPathNode = null;
		int num5 = 0;
		int num6 = (flag ? (pathList.Path.MaxIndex - 1) : pathList.Path.MaxIndex);
		for (int j = pathList.Path.MinIndex; j <= num6; j++)
		{
			IAIPathNode iAIPathNode2 = new RuntimePathNode(pathList.Path.Points[j] + Vector3.up * 1f);
			if (iAIPathNode != null)
			{
				iAIPathNode2.AddLink(iAIPathNode);
				iAIPathNode.AddLink(iAIPathNode2);
			}
			runtimePath.Nodes[num5] = iAIPathNode2;
			iAIPathNode = iAIPathNode2;
			num5++;
		}
		if (flag)
		{
			runtimePath.Nodes[0].AddLink(runtimePath.Nodes[runtimePath.Nodes.Length - 1]);
			runtimePath.Nodes[runtimePath.Nodes.Length - 1].AddLink(runtimePath.Nodes[0]);
		}
		else
		{
			RuntimeInterestNode interestNode = new RuntimeInterestNode(startPoint + Vector3.up * 1f);
			runtimePath.AddInterestNode(interestNode);
			RuntimeInterestNode interestNode2 = new RuntimeInterestNode(endPoint + Vector3.up * 1f);
			runtimePath.AddInterestNode(interestNode2);
		}
		int num7 = Mathf.CeilToInt(pathList.Path.Length / 500f);
		num7 = Mathf.Clamp(num7, 1, 3);
		if (flag)
		{
			num7++;
		}
		for (int k = 0; k < num7; k++)
		{
			int num8 = Random.Range(0, pathList.Path.Points.Length);
			RuntimeInterestNode interestNode3 = new RuntimeInterestNode(pathList.Path.Points[num8] + Vector3.up * 1f);
			runtimePath.AddInterestNode(interestNode3);
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/npc/m2bradley/bradleyapc.prefab", spawnPos, spawnRot);
		BradleyAPC bradleyAPC = null;
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			bradleyAPC = ((Component)baseEntity).GetComponent<BradleyAPC>();
			if (Object.op_Implicit((Object)(object)bradleyAPC))
			{
				bradleyAPC.RoadSpawned = true;
				bradleyAPC.Spawn();
				bradleyAPC.InstallPatrolPath(runtimePath);
			}
			else
			{
				baseEntity.Kill();
			}
		}
		return bradleyAPC;
	}

	[ServerVar(Name = "spawnroadbradley")]
	public static string svspawnroadbradley(Vector3 pos, Vector3 dir)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)SpawnRoadDrivingBradley(pos, Quaternion.LookRotation(dir, Vector3.up)) != (Object)null))
		{
			return "Failed to spawn road-driving Bradley.";
		}
		return "Spawned road-driving Bradley.";
	}

	public void SetDestination(Vector3 dest)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		destination = dest;
	}

	public override void ServerInit()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		CacheSpawnPrefabIDS();
		walkableAreaMask = 1 << NavMesh.GetAreaFromName("Walkable");
		deployedTimeSinceBradleyAttackedTarget = TimeSince.op_Implicit(0f);
		timeSinceScientistDeploy = TimeSince.op_Implicit(float.PositiveInfinity);
		timeSinceDeployCheck = TimeSince.op_Implicit(float.PositiveInfinity);
		numberOfScientistsToSpawn = ScientistSpawnCount;
		Initialize();
		((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateTargetList, 0f, 2f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateTargetVisibilities, 0f, sightUpdateRate);
		((FacepunchBehaviour)this).InvokeRepeating((Action)BuildingCheck, 1f, 5f);
		AIRoot.SetActive(false);
		obstacleHitMask = LayerMask.op_Implicit(LayerMask.GetMask(new string[1] { "Vehicle World" }));
		timeSinceSeemingStuck = TimeSince.op_Implicit(0f);
		timeSinceStuckReverseStart = TimeSince.op_Implicit(float.MaxValue);
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
	}

	public void Initialize()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnBradleyApcInitialize", (object)this) == null)
		{
			myRigidBody.centerOfMass = centerOfMass.localPosition;
			destination = ((Component)this).transform.position;
			finalDestination = ((Component)this).transform.position;
		}
	}

	public BasePlayer FollowPlayer()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (current.IsAdmin && current.IsAlive() && !current.IsSleeping() && current.GetActiveItem() != null && current.GetActiveItem().info.shortname == "tool.binoculars")
				{
					return current;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return null;
	}

	public static Vector3 Direction2D(Vector3 aimAt, Vector3 aimFrom)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = new Vector3(aimAt.x, 0f, aimAt.z) - new Vector3(aimFrom.x, 0f, aimFrom.z);
		return ((Vector3)(ref val)).normalized;
	}

	public bool IsAtDestination()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.Distance2D(((Component)this).transform.position, destination) <= stoppingDist;
	}

	public bool IsAtFinalDestination()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.Distance2D(((Component)this).transform.position, finalDestination) <= stoppingDist;
	}

	public Vector3 ClosestPointAlongPath(Vector3 start, Vector3 end, Vector3 fromPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = end - start;
		Vector3 val2 = fromPos - start;
		float num = Vector3.Dot(val, val2);
		float num2 = Vector3.SqrMagnitude(end - start);
		float num3 = Mathf.Clamp01(num / num2);
		return start + val * num3;
	}

	public void FireGunTest()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		if (Time.time < nextFireTime)
		{
			return;
		}
		deployedTimeSinceBradleyAttackedTarget = TimeSince.op_Implicit(0f);
		nextFireTime = Time.time + 0.25f;
		numBursted++;
		if (numBursted >= 4)
		{
			nextFireTime = Time.time + 5f;
			numBursted = 0;
		}
		Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(2f, CannonMuzzle.rotation * Vector3.forward);
		Vector3 val = ((Component)CannonPitch).transform.rotation * Vector3.back + ((Component)this).transform.up * -1f;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		myRigidBody.AddForceAtPosition(normalized * recoilScale, ((Component)CannonPitch).transform.position, (ForceMode)1);
		Effect.server.Run(mainCannonMuzzleFlash.resourcePath, this, StringPool.Get(((Object)((Component)CannonMuzzle).gameObject).name), Vector3.zero, Vector3.zero);
		BaseEntity baseEntity = GameManager.server.CreateEntity(mainCannonProjectile.resourcePath, ((Component)CannonMuzzle).transform.position, Quaternion.LookRotation(modifiedAimConeDirection));
		if (!((Object)(object)baseEntity == (Object)null))
		{
			ServerProjectile component = ((Component)baseEntity).GetComponent<ServerProjectile>();
			if (Object.op_Implicit((Object)(object)component))
			{
				component.InitializeVelocity(modifiedAimConeDirection * component.speed);
			}
			TimedExplosive timedExplosive = default(TimedExplosive);
			if (((Component)baseEntity).TryGetComponent<TimedExplosive>(ref timedExplosive))
			{
				timedExplosive.creatorEntity = this;
			}
			baseEntity.Spawn();
		}
	}

	public void InstallPatrolPath(IAIPath path)
	{
		patrolPath = path;
		currentPath = new List<Vector3>();
		currentPathIndex = -1;
	}

	public void UpdateMovement_Patrol()
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		if (patrolPath == null || Time.time < nextPatrolTime)
		{
			return;
		}
		nextPatrolTime = Time.time + 20f;
		if ((HasPath() && !IsAtFinalDestination()) || Interface.CallHook("OnBradleyApcPatrol", (object)this) != null)
		{
			return;
		}
		IAIPathInterestNode randomInterestNodeAwayFrom = patrolPath.GetRandomInterestNodeAwayFrom(((Component)this).transform.position);
		IAIPathNode closestToPoint = patrolPath.GetClosestToPoint(randomInterestNodeAwayFrom.Position);
		bool flag = false;
		List<IAIPathNode> nodes = Pool.Get<List<IAIPathNode>>();
		IAIPathNode iAIPathNode;
		if (GetEngagementPath(ref nodes))
		{
			flag = true;
			iAIPathNode = nodes[nodes.Count - 1];
		}
		else
		{
			iAIPathNode = patrolPath.GetClosestToPoint(((Component)this).transform.position);
		}
		if (!(Vector3.Distance(finalDestination, closestToPoint.Position) > 2f))
		{
			return;
		}
		if (closestToPoint == iAIPathNode)
		{
			currentPath.Clear();
			currentPath.Add(closestToPoint.Position);
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.Position;
		}
		else
		{
			if (!AStarPath.FindPath(iAIPathNode, closestToPoint, out var path, out var _))
			{
				return;
			}
			currentPath.Clear();
			if (flag)
			{
				for (int i = 0; i < nodes.Count - 1; i++)
				{
					currentPath.Add(nodes[i].Position);
				}
			}
			foreach (IAIPathNode item in path)
			{
				currentPath.Add(item.Position);
			}
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.Position;
		}
	}

	private void EnterSpline()
	{
		myRigidBody.isKinematic = true;
	}

	private void LeaveSpline()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		lastJoinedSpline = TimeSince.op_Implicit(0f);
		myRigidBody.isKinematic = false;
	}

	public void DoSplineMove()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		splineTranslator.SetOffset(splineOffset);
		Vector3 tangent;
		if (targetList.Count > 0)
		{
			TargetInfo targetInfo = targetList[0];
			if (targetInfo.IsValid() && targetInfo.IsVisible())
			{
				tangent = targetInfo.lastSeenPosition - ((Component)this).transform.position;
				Vector3 normalized = ((Vector3)(ref tangent)).normalized;
				float num = Vector3.Dot(((Component)this).transform.forward, normalized);
				if (num > 0f)
				{
					splineTranslator.SetDirection(entryDirection);
				}
				else if (num < 0f)
				{
					splineTranslator.SetDirection(-entryDirection);
				}
			}
		}
		splineTranslator.Update(Time.deltaTime);
		splineTranslator.GetCurrentPositionAndTangent(out var position, out tangent);
		((Component)this).transform.position = Vector3.Lerp(((Component)this).transform.position, position, Time.deltaTime * splineMovementSpeed * 10f);
		tangent = splineTranslator.PeekNextPosition(0.1f, entryDirection) - position;
		Vector3 normalized2 = ((Vector3)(ref tangent)).normalized;
		((Component)this).transform.forward = normalized2;
		if (Math.Abs(splineTranslator.CurrentDistance - splineTranslator.GetEnd()) < 1f)
		{
			followingSpine = false;
			LeaveSpline();
		}
	}

	public void UpdateMovement_Hunt()
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnBradleyApcHunt", (object)this) != null || patrolPath == null)
		{
			return;
		}
		TargetInfo targetInfo = targetList[0];
		if (!targetInfo.IsValid())
		{
			return;
		}
		if (HasPath() && targetInfo.IsVisible())
		{
			if (currentPath.Count > 1)
			{
				Vector3 item = currentPath[currentPathIndex];
				ClearPath();
				currentPath.Add(item);
				finalDestination = item;
				currentPathIndex = 0;
			}
		}
		else
		{
			if (!(Time.time > nextEngagementPathTime) || HasPath() || targetInfo.IsVisible())
			{
				return;
			}
			bool flag = false;
			IAIPathNode start = patrolPath.GetClosestToPoint(((Component)this).transform.position);
			List<IAIPathNode> nodes = Pool.Get<List<IAIPathNode>>();
			if (GetEngagementPath(ref nodes))
			{
				flag = true;
				start = nodes[nodes.Count - 1];
			}
			IAIPathNode iAIPathNode = null;
			List<IAIPathNode> nearNodes = Pool.Get<List<IAIPathNode>>();
			patrolPath.GetNodesNear(targetInfo.lastSeenPosition, ref nearNodes, 30f);
			Stack<IAIPathNode> stack = null;
			float num = float.PositiveInfinity;
			float y = mainTurretEyePos.localPosition.y;
			foreach (IAIPathNode item2 in nearNodes)
			{
				Stack<IAIPathNode> path = new Stack<IAIPathNode>();
				if (targetInfo.entity.IsVisible(item2.Position + new Vector3(0f, y, 0f)) && AStarPath.FindPath(start, item2, out path, out var pathCost) && pathCost < num)
				{
					stack = path;
					num = pathCost;
					iAIPathNode = item2;
				}
			}
			if (stack == null && nearNodes.Count > 0)
			{
				Stack<IAIPathNode> path2 = new Stack<IAIPathNode>();
				IAIPathNode iAIPathNode2 = nearNodes[Random.Range(0, nearNodes.Count)];
				if (AStarPath.FindPath(start, iAIPathNode2, out path2, out var pathCost2) && pathCost2 < num)
				{
					stack = path2;
					iAIPathNode = iAIPathNode2;
				}
			}
			if (stack != null)
			{
				currentPath.Clear();
				if (flag)
				{
					for (int i = 0; i < nodes.Count - 1; i++)
					{
						currentPath.Add(nodes[i].Position);
					}
				}
				foreach (IAIPathNode item3 in stack)
				{
					currentPath.Add(item3.Position);
				}
				currentPathIndex = -1;
				pathLooping = false;
				finalDestination = iAIPathNode.Position;
			}
			Pool.FreeUnmanaged<IAIPathNode>(ref nearNodes);
			Pool.FreeUnmanaged<IAIPathNode>(ref nodes);
			nextEngagementPathTime = Time.time + 5f;
		}
	}

	public void DoSimpleAI()
	{
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		SetFlag(Flags.Reserved5, TOD_Sky.Instance.IsNight);
		if (Interface.CallHook("OnBradleyApcThink", (object)this) != null || !DoAI)
		{
			return;
		}
		SetTarget();
		if (mountingScientists || inDeployedState)
		{
			ClearPath();
		}
		else if (!IsOnSpline())
		{
			if (targetList.Count > 0)
			{
				UpdateMovement_Hunt();
			}
			else
			{
				UpdateMovement_Patrol();
			}
		}
		if (!IsOnSpline())
		{
			AdvancePathMovement(force: false);
			float num = Vector3.Distance(((Component)this).transform.position, destination);
			float num2 = Vector3.Distance(((Component)this).transform.position, finalDestination);
			if (num > stoppingDist)
			{
				Vector3 val = Direction2D(destination, ((Component)this).transform.position);
				float num3 = Vector3.Dot(val, ((Component)this).transform.right);
				float num4 = Vector3.Dot(val, ((Component)this).transform.right);
				float num5 = Vector3.Dot(val, -((Component)this).transform.right);
				if (Vector3.Dot(val, -((Component)this).transform.forward) > num3)
				{
					if (num4 >= num5)
					{
						turning = 1f;
					}
					else
					{
						turning = -1f;
					}
				}
				else
				{
					turning = Mathf.Clamp(num3 * 3f, -1f, 1f);
				}
				float throttleScaleFromTurn = 1f - Mathf.InverseLerp(0f, 0.3f, Mathf.Abs(turning));
				AvoidObstacles(ref throttleScaleFromTurn);
				float num6 = Vector3.Dot(myRigidBody.velocity, ((Component)this).transform.forward);
				if (!(throttle > 0f) || !(num6 < 0.5f))
				{
					timeSinceSeemingStuck = TimeSince.op_Implicit(0f);
				}
				else if (TimeSince.op_Implicit(timeSinceSeemingStuck) > 10f)
				{
					timeSinceStuckReverseStart = TimeSince.op_Implicit(0f);
					timeSinceSeemingStuck = TimeSince.op_Implicit(0f);
				}
				float num7 = Mathf.InverseLerp(0.1f, 0.4f, Vector3.Dot(((Component)this).transform.forward, Vector3.up));
				if (TimeSince.op_Implicit(timeSinceStuckReverseStart) < 3f)
				{
					throttle = -0.75f;
					turning = 1f;
				}
				else
				{
					throttle = (0.1f + Mathf.InverseLerp(0f, 20f, num2) * 1f) * throttleScaleFromTurn + num7;
				}
			}
		}
		DoWeaponAiming();
		SendNetworkUpdate();
	}

	private void SetTarget()
	{
		if (targetList.Count == 0)
		{
			mainGunTarget = null;
		}
		else if (targetList[0].IsValid() && targetList[0].IsVisible())
		{
			mainGunTarget = targetList[0].entity as BaseCombatEntity;
		}
		else
		{
			mainGunTarget = null;
		}
	}

	public void FixedUpdate()
	{
		if (mountingScientists)
		{
			UpdateMountScientists();
		}
		else if (inDeployedState)
		{
			UpdateDeployed();
		}
		DoSimpleAI();
		if (IsOnSpline())
		{
			DoSplineMove();
		}
		else
		{
			DoPhysicsMove();
		}
		DoWeapons();
		DoHealing();
	}

	private void AvoidObstacles(ref float throttleScaleFromTurn)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		Ray ray = default(Ray);
		((Ray)(ref ray))..ctor(((Component)this).transform.position + ((Component)this).transform.forward * (((Bounds)(ref bounds)).extents.z - 1f), ((Component)this).transform.forward);
		if (!GamePhysics.Trace(ray, 3f, out var hitInfo, 20f, LayerMask.op_Implicit(obstacleHitMask), (QueryTriggerInteraction)1, this))
		{
			return;
		}
		if (((RaycastHit)(ref hitInfo)).point == Vector3.zero)
		{
			((RaycastHit)(ref hitInfo)).point = ((RaycastHit)(ref hitInfo)).collider.ClosestPointOnBounds(((Ray)(ref ray)).origin);
		}
		float num = TransformEx.AngleToPos(((Component)this).transform, ((RaycastHit)(ref hitInfo)).point);
		float num2 = Mathf.Abs(num);
		if (num2 > 75f || !(((RaycastHit)(ref hitInfo)).collider.ToBaseEntity() is BradleyAPC))
		{
			return;
		}
		bool flag = false;
		if (num2 < 5f)
		{
			float num3 = ((throttle < 0f) ? 150f : 50f);
			if (Vector3.SqrMagnitude(((Component)this).transform.position - ((RaycastHit)(ref hitInfo)).point) < num3)
			{
				flag = true;
			}
		}
		if (num > 30f)
		{
			turning = -1f;
		}
		else
		{
			turning = 1f;
		}
		throttleScaleFromTurn = (flag ? (-1f) : 1f);
		int num4 = currentPathIndex;
		_ = currentPathIndex;
		float num5 = Vector3.Distance(((Component)this).transform.position, destination);
		while (HasPath() && (double)num5 < 26.6 && currentPathIndex >= 0)
		{
			int num6 = currentPathIndex;
			AdvancePathMovement(force: true);
			num5 = Vector3.Distance(((Component)this).transform.position, destination);
			if (currentPathIndex == num4 || currentPathIndex == num6)
			{
				break;
			}
		}
	}

	public void DoPhysicsMove()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0308: Unknown result type (might be due to invalid IL or missing references)
		//IL_030d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		Vector3 velocity = myRigidBody.velocity;
		throttle = Mathf.Clamp(throttle, -1f, 1f);
		leftThrottle = throttle;
		rightThrottle = throttle;
		if (turning > 0f)
		{
			rightThrottle = 0f - turning;
			leftThrottle = turning;
		}
		else if (turning < 0f)
		{
			leftThrottle = turning;
			rightThrottle = turning * -1f;
		}
		Vector3.Distance(((Component)this).transform.position, GetFinalDestination());
		float num = Vector3.Distance(((Component)this).transform.position, GetCurrentPathDestination());
		float num2 = 15f;
		if (num < 20f)
		{
			float num3 = Vector3.Dot(PathDirection(currentPathIndex), PathDirection(currentPathIndex + 1));
			float num4 = Mathf.InverseLerp(2f, 10f, num);
			float num5 = Mathf.InverseLerp(0.5f, 0.8f, num3);
			num2 = 15f - 14f * ((1f - num5) * (1f - num4));
		}
		_ = 20f;
		if (patrolPath != null)
		{
			float num6 = num2;
			foreach (IAIPathSpeedZone speedZone in patrolPath.SpeedZones)
			{
				OBB val = speedZone.WorldSpaceBounds();
				if (((OBB)(ref val)).Contains(((Component)this).transform.position))
				{
					num6 = Mathf.Min(num6, speedZone.GetMaxSpeed());
				}
			}
			currentSpeedZoneLimit = Mathf.Lerp(currentSpeedZoneLimit, num6, Time.deltaTime);
			num2 = Mathf.Min(num2, currentSpeedZoneLimit);
		}
		if (PathComplete())
		{
			num2 = 0f;
		}
		brake = ((Vector3)(ref velocity)).magnitude >= num2;
		ApplyBrakes(brake ? 1f : 0f);
		float num7 = throttle;
		leftThrottle = Mathf.Clamp(leftThrottle + num7, -1f, 1f);
		rightThrottle = Mathf.Clamp(rightThrottle + num7, -1f, 1f);
		float num8 = Mathf.InverseLerp(2f, 1f, ((Vector3)(ref velocity)).magnitude * Mathf.Abs(Vector3.Dot(((Vector3)(ref velocity)).normalized, ((Component)this).transform.forward)));
		float torqueAmount = Mathf.Lerp(moveForceMax, turnForce, num8);
		float num9 = Mathf.InverseLerp(5f, 1.5f, ((Vector3)(ref velocity)).magnitude * Mathf.Abs(Vector3.Dot(((Vector3)(ref velocity)).normalized, ((Component)this).transform.forward)));
		ScaleSidewaysFriction(1f - num9);
		SetMotorTorque(leftThrottle, rightSide: false, torqueAmount);
		SetMotorTorque(rightThrottle, rightSide: true, torqueAmount);
		TriggerHurtEx triggerHurtEx = impactDamager;
		Vector3 velocity2 = myRigidBody.velocity;
		triggerHurtEx.damageEnabled = ((Vector3)(ref velocity2)).magnitude > 2f;
	}

	public void ApplyBrakes(float amount)
	{
		ApplyBrakeTorque(amount, rightSide: true);
		ApplyBrakeTorque(amount, rightSide: false);
	}

	public float GetMotorTorque(bool rightSide)
	{
		float num = 0f;
		WheelCollider[] array = (rightSide ? rightWheels : leftWheels);
		foreach (WheelCollider val in array)
		{
			num += val.motorTorque;
		}
		return num / (float)rightWheels.Length;
	}

	public void ScaleSidewaysFriction(float scale)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		float stiffness = 0.75f + 0.75f * scale;
		WheelCollider[] array = rightWheels;
		foreach (WheelCollider obj in array)
		{
			WheelFrictionCurve sidewaysFriction = obj.sidewaysFriction;
			((WheelFrictionCurve)(ref sidewaysFriction)).stiffness = stiffness;
			obj.sidewaysFriction = sidewaysFriction;
		}
		array = leftWheels;
		foreach (WheelCollider obj2 in array)
		{
			WheelFrictionCurve sidewaysFriction2 = obj2.sidewaysFriction;
			((WheelFrictionCurve)(ref sidewaysFriction2)).stiffness = stiffness;
			obj2.sidewaysFriction = sidewaysFriction2;
		}
	}

	public void SetMotorTorque(float newThrottle, bool rightSide, float torqueAmount)
	{
		newThrottle = Mathf.Clamp(newThrottle, -1f, 1f);
		float num = torqueAmount * newThrottle;
		int num2 = (rightSide ? rightWheels.Length : leftWheels.Length);
		int num3 = 0;
		WheelCollider[] array = (rightSide ? rightWheels : leftWheels);
		WheelHit val = default(WheelHit);
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].GetGroundHit(ref val))
			{
				num3++;
			}
		}
		float num4 = 1f;
		if (num3 > 0)
		{
			num4 = num2 / num3;
		}
		array = (rightSide ? rightWheels : leftWheels);
		WheelHit val3 = default(WheelHit);
		foreach (WheelCollider val2 in array)
		{
			if (val2.GetGroundHit(ref val3))
			{
				val2.motorTorque = num * num4;
			}
			else
			{
				val2.motorTorque = num;
			}
		}
	}

	public void ApplyBrakeTorque(float amount, bool rightSide)
	{
		WheelCollider[] array = (rightSide ? rightWheels : leftWheels);
		for (int i = 0; i < array.Length; i++)
		{
			array[i].brakeTorque = brakeForce * amount;
		}
	}

	public void CreateExplosionMarker(float durationMinutes)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity(debrisFieldMarker.resourcePath, ((Component)this).transform.position, Quaternion.identity);
		baseEntity.Spawn();
		((Component)baseEntity).SendMessage("SetDuration", (object)durationMinutes, (SendMessageOptions)1);
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0311: Unknown result type (might be due to invalid IL or missing references)
		//IL_0317: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient || Interface.CallHook("OnEntityDestroy", (object)this) != null)
		{
			return;
		}
		CreateExplosionMarker(10f);
		Effect.server.Run(explosionEffect.resourcePath, ((Component)mainTurretEyePos).transform.position, Vector3.up, null, broadcast: true);
		Vector3 zero = Vector3.zero;
		GameObject gibSource = servergibs.Get().GetComponent<ServerGib>()._gibSource;
		List<ServerGib> list = ServerGib.CreateGibs(servergibs.resourcePath, ((Component)this).gameObject, gibSource, zero, 3f);
		for (int i = 0; i < 12 - maxCratesToSpawn; i++)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(this.fireBall.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation);
			if (!Object.op_Implicit((Object)(object)baseEntity))
			{
				continue;
			}
			float num = 3f;
			float num2 = 10f;
			Vector3 onUnitSphere = Random.onUnitSphere;
			((Component)baseEntity).transform.position = ((Component)this).transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere * Random.Range(-4f, 4f);
			Collider component = ((Component)baseEntity).GetComponent<Collider>();
			baseEntity.Spawn();
			baseEntity.SetVelocity(zero + onUnitSphere * Random.Range(num, num2));
			foreach (ServerGib item in list)
			{
				Physics.IgnoreCollision(component, (Collider)(object)item.GetCollider(), true);
			}
		}
		for (int j = 0; j < maxCratesToSpawn; j++)
		{
			Vector3 onUnitSphere2 = Random.onUnitSphere;
			onUnitSphere2.y = 0f;
			((Vector3)(ref onUnitSphere2)).Normalize();
			Vector3 pos = ((Component)this).transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere2 * Random.Range(2f, 3f);
			BaseEntity baseEntity2 = GameManager.server.CreateEntity(crateToDrop.resourcePath, pos, Quaternion.LookRotation(onUnitSphere2));
			baseEntity2.Spawn();
			LootContainer lootContainer = baseEntity2 as LootContainer;
			if (Object.op_Implicit((Object)(object)lootContainer))
			{
				((FacepunchBehaviour)lootContainer).Invoke((Action)lootContainer.RemoveMe, 1800f);
			}
			Collider component2 = ((Component)baseEntity2).GetComponent<Collider>();
			Rigidbody val = ((Component)baseEntity2).gameObject.AddComponent<Rigidbody>();
			val.useGravity = true;
			val.collisionDetectionMode = (CollisionDetectionMode)2;
			val.mass = 2f;
			val.interpolation = (RigidbodyInterpolation)1;
			val.velocity = zero + onUnitSphere2 * Random.Range(1f, 3f);
			val.angularVelocity = Vector3Ex.Range(-1.75f, 1.75f);
			val.drag = 0.5f * (val.mass / 5f);
			val.angularDrag = 0.2f * (val.mass / 5f);
			FireBall fireBall = GameManager.server.CreateEntity(this.fireBall.resourcePath) as FireBall;
			if (Object.op_Implicit((Object)(object)fireBall))
			{
				fireBall.SetParent(baseEntity2);
				fireBall.Spawn();
				((Component)fireBall).GetComponent<Rigidbody>().isKinematic = true;
				((Component)fireBall).GetComponent<Collider>().enabled = false;
			}
			((Component)baseEntity2).SendMessage("SetLockingEnt", (object)((Component)fireBall).gameObject, (SendMessageOptions)1);
			foreach (ServerGib item2 in list)
			{
				Physics.IgnoreCollision(component2, (Collider)(object)item2.GetCollider(), true);
			}
			Interface.CallHook("OnCrateSpawned", (object)this, (object)baseEntity2);
		}
		KillSpawnedScientists();
		if (info != null && (Object)(object)info.InitiatorPlayer != (Object)null && info.InitiatorPlayer.serverClan != null)
		{
			info.InitiatorPlayer.AddClanScore((ClanScoreEventType)7);
		}
		base.OnDied(info);
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		base.OnAttacked(info);
		if (!base.isClient)
		{
			BasePlayer basePlayer = info.Initiator as BasePlayer;
			if (!(basePlayer is ScientistNPC) && (Object)(object)basePlayer != (Object)null)
			{
				TrySpawnScientists(basePlayer);
				AddOrUpdateTarget(basePlayer, info.PointStart, info.damageTypes.Total());
			}
		}
	}

	public override void Hurt(HitInfo info)
	{
		if (!((Object)(object)info.Initiator != (Object)null) || !(info.Initiator is ScientistNPC))
		{
			base.Hurt(info);
		}
	}

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		base.OnHealthChanged(oldvalue, newvalue);
		if (base.isServer)
		{
			SetFlag(Flags.Reserved2, base.healthFraction <= 0.75f);
			SetFlag(Flags.Reserved3, base.healthFraction < 0.4f);
		}
	}

	public void DoHealing()
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient && base.SecondsSinceAttacked > 600f)
		{
			if (base.healthFraction < 1f)
			{
				float amount = MaxHealth() / 300f * Time.fixedDeltaTime;
				Heal(amount);
			}
			if (numberOfScientistsToSpawn < ScientistSpawnCount && base.healthFraction >= 0.95f && TimeSince.op_Implicit(timeSinceScientistDeploy) > 30f)
			{
				numberOfScientistsToSpawn = ScientistSpawnCount;
			}
		}
	}

	public BasePlayer GetPlayerDamageInitiator()
	{
		return null;
	}

	public float GetDamageMultiplier(BaseEntity ent)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		float num = ((throttle > 0f) ? 10f : 0f);
		float num2 = Vector3.Dot(myRigidBody.velocity, ((Component)this).transform.forward);
		if (num2 > 0f)
		{
			num += num2 * 0.5f;
		}
		if (ent is BaseVehicle)
		{
			num *= 10f;
		}
		return num;
	}

	public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
	{
	}

	private void CheckForSplineStart()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		float start = splineTranslator.GetStart();
		Vector3 positionAtDistance = splineTranslator.GetPositionAtDistance(start, out var _);
		positionAtDistance += splineOffset;
		Vector3 val = ((Component)spline).transform.TransformPoint(positionAtDistance);
		float num = Vector3Ex.Distance2D(((Component)this).transform.position, val);
		if (num < 1.5f)
		{
			followingSpine = true;
			((FacepunchBehaviour)this).CancelInvoke((Action)CheckForSplineStart);
			EnterSpline();
		}
		lastDist = num;
	}

	private bool ShouldJoinSpline(WorldSpline spline)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		if (targetList.Count > 0)
		{
			TargetInfo targetInfo = targetList[0];
			if (targetInfo.IsValid() && targetInfo.IsVisible())
			{
				Vector3 val = targetInfo.lastSeenPosition - ((Component)this).transform.position;
				Vector3 normalized = ((Vector3)(ref val)).normalized;
				val = ((Component)spline).transform.position - ((Component)this).transform.position;
				float num = Vector3.Dot(((Vector3)(ref val)).normalized, normalized);
				if (num > 0f)
				{
					return true;
				}
				if (num < 0f)
				{
					return false;
				}
			}
		}
		return true;
	}

	public void OnSplinePathTrigger(int pathId, WorldSpline spline, int direction)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (followingSpine || TimeSince.op_Implicit(lastJoinedSpline) <= 5f)
		{
			return;
		}
		lastJoinedSpline = TimeSince.op_Implicit(0f);
		if (ShouldJoinSpline(spline))
		{
			if (splineTranslator == null)
			{
				splineTranslator = new SimpleSplineTranslator();
			}
			splineTranslator.SetSpline(spline).SetSpeed(splineMovementSpeed).SetDirection(direction)
				.CalculateStartingDistance();
			splineId = pathId;
			this.spline = spline;
			entryDirection = direction;
			followingSpine = true;
			if (!((FacepunchBehaviour)this).IsInvoking((Action)CheckForSplineStart))
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)CheckForSplineStart, 0f, 1f);
			}
		}
	}

	public void OnBasePathTrigger(int pathId, BasePath path)
	{
	}

	private bool IsOnSpline()
	{
		return followingSpine;
	}

	public bool HasPath()
	{
		if (currentPath != null)
		{
			return currentPath.Count > 0;
		}
		return false;
	}

	public void ClearPath()
	{
		currentPath.Clear();
		currentPathIndex = -1;
	}

	public bool IndexValid(int index)
	{
		if (!HasPath())
		{
			return false;
		}
		if (index >= 0)
		{
			return index < currentPath.Count;
		}
		return false;
	}

	public Vector3 GetFinalDestination()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (!HasPath())
		{
			return ((Component)this).transform.position;
		}
		return finalDestination;
	}

	public Vector3 GetCurrentPathDestination()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (!HasPath())
		{
			return ((Component)this).transform.position;
		}
		return currentPath[currentPathIndex];
	}

	public bool PathComplete()
	{
		if (HasPath())
		{
			if (currentPathIndex == currentPath.Count - 1)
			{
				return AtCurrentPathNode();
			}
			return false;
		}
		return true;
	}

	public bool AtCurrentPathNode()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (currentPathIndex < 0 || currentPathIndex >= currentPath.Count)
		{
			return false;
		}
		return Vector3.Distance(((Component)this).transform.position, currentPath[currentPathIndex]) <= stoppingDist;
	}

	public int GetLoopedIndex(int index)
	{
		if (!HasPath())
		{
			Debug.LogWarning((object)"Warning, GetLoopedIndex called without a path");
			return 0;
		}
		if (!pathLooping)
		{
			return Mathf.Clamp(index, 0, currentPath.Count - 1);
		}
		if (index >= currentPath.Count)
		{
			return index % currentPath.Count;
		}
		if (index < 0)
		{
			return currentPath.Count - Mathf.Abs(index % currentPath.Count);
		}
		return index;
	}

	public Vector3 PathDirection(int index)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		if (!HasPath() || currentPath.Count <= 1)
		{
			return ((Component)this).transform.forward;
		}
		index = GetLoopedIndex(index);
		Vector3 val;
		Vector3 val2;
		if (pathLooping)
		{
			int loopedIndex = GetLoopedIndex(index - 1);
			val = currentPath[loopedIndex];
			val2 = currentPath[GetLoopedIndex(index)];
		}
		else
		{
			val = ((index - 1 >= 0) ? currentPath[index - 1] : ((Component)this).transform.position);
			val2 = currentPath[index];
		}
		Vector3 val3 = val2 - val;
		return ((Vector3)(ref val3)).normalized;
	}

	public Vector3 IdealPathPosition()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		if (!HasPath())
		{
			return ((Component)this).transform.position;
		}
		int loopedIndex = GetLoopedIndex(currentPathIndex - 1);
		if (loopedIndex == currentPathIndex)
		{
			return currentPath[currentPathIndex];
		}
		return ClosestPointAlongPath(currentPath[loopedIndex], currentPath[currentPathIndex], ((Component)this).transform.position);
	}

	public void AdvancePathMovement(bool force)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		if (HasPath())
		{
			if (force || AtCurrentPathNode() || currentPathIndex == -1)
			{
				currentPathIndex = GetLoopedIndex(currentPathIndex + 1);
			}
			if (PathComplete())
			{
				ClearPath();
				return;
			}
			Vector3 val = IdealPathPosition();
			Vector3 val2 = currentPath[currentPathIndex];
			float num = Vector3.Distance(val, val2);
			float num2 = Vector3.Distance(((Component)this).transform.position, val);
			float num3 = Mathf.InverseLerp(8f, 0f, num2);
			val += Direction2D(val2, val) * Mathf.Min(num, num3 * 20f);
			SetDestination(val);
		}
	}

	public bool GetPathToClosestTurnableNode(IAIPathNode start, Vector3 forward, ref List<IAIPathNode> nodes)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		float num = float.NegativeInfinity;
		IAIPathNode iAIPathNode = null;
		Vector3 val;
		foreach (IAIPathNode item in start.Linked)
		{
			val = item.Position - start.Position;
			float num2 = Vector3.Dot(forward, ((Vector3)(ref val)).normalized);
			if (num2 > num)
			{
				num = num2;
				iAIPathNode = item;
			}
		}
		if (iAIPathNode != null)
		{
			nodes.Add(iAIPathNode);
			if (!iAIPathNode.Straightaway)
			{
				return true;
			}
			IAIPathNode start2 = iAIPathNode;
			val = iAIPathNode.Position - start.Position;
			return GetPathToClosestTurnableNode(start2, ((Vector3)(ref val)).normalized, ref nodes);
		}
		return false;
	}

	public bool GetEngagementPath(ref List<IAIPathNode> nodes)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		IAIPathNode closestToPoint = patrolPath.GetClosestToPoint(((Component)this).transform.position);
		Vector3 val = closestToPoint.Position - ((Component)this).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		if (Vector3.Dot(((Component)this).transform.forward, normalized) > 0f)
		{
			nodes.Add(closestToPoint);
			if (!closestToPoint.Straightaway)
			{
				return true;
			}
		}
		return GetPathToClosestTurnableNode(closestToPoint, ((Component)this).transform.forward, ref nodes);
	}

	private void CacheSpawnPrefabIDS()
	{
		scientistPrefabLookUp.Clear();
		foreach (ScientistSpawnGroup scientistSpawn in ScientistSpawns)
		{
			foreach (GameObjectRef spawnPrefab in scientistSpawn.SpawnPrefabs)
			{
				uint key = spawnPrefab.GetEntity().prefabID;
				if (!scientistPrefabLookUp.ContainsKey(key))
				{
					scientistPrefabLookUp.Add(key, spawnPrefab);
				}
			}
		}
	}

	private void TrySpawnScientists(BasePlayer triggeringPlayer)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)triggeringPlayer == (Object)null) && !deployingScientists && !mountingScientists && !(TimeSince.op_Implicit(timeSinceDeployCheck) <= DeployOnDamageCheckInterval))
		{
			timeSinceDeployCheck = TimeSince.op_Implicit(0f);
			List<ScientistSpawnGroup> triggereringSpawnGroups = GetTriggereringSpawnGroups();
			List<GameObjectRef> list = Pool.Get<List<GameObjectRef>>();
			AddMountedScientistsToSpawn(list);
			AddSpawnGroupSpawns(triggereringSpawnGroups, list);
			if (list.Count == 0)
			{
				Pool.FreeUnmanaged<GameObjectRef>(ref list);
				Pool.FreeUnmanaged<ScientistSpawnGroup>(ref triggereringSpawnGroups);
			}
			else if (CanDeployScientists(triggeringPlayer, list, scientistSpawnPositions))
			{
				SetSpawnGroupsAsSpawned(triggereringSpawnGroups);
				Pool.FreeUnmanaged<ScientistSpawnGroup>(ref triggereringSpawnGroups);
				ClearMountedScientists();
				((MonoBehaviour)this).StartCoroutine(DeployScientists(triggeringPlayer, list, scientistSpawnPositions));
			}
			else
			{
				Pool.FreeUnmanaged<GameObjectRef>(ref list);
				Pool.FreeUnmanaged<ScientistSpawnGroup>(ref triggereringSpawnGroups);
			}
		}
	}

	private List<ScientistSpawnGroup> GetTriggereringSpawnGroups()
	{
		List<ScientistSpawnGroup> list = Pool.Get<List<ScientistSpawnGroup>>();
		foreach (ScientistSpawnGroup scientistSpawn in ScientistSpawns)
		{
			if (!scientistSpawn.Spawned && !(base.healthFraction > scientistSpawn.BradleyHealth))
			{
				list.Add(scientistSpawn);
			}
		}
		return list;
	}

	private void AddMountedScientistsToSpawn(List<GameObjectRef> scientists)
	{
		if (mountedScientistPrefabs.Count != 0)
		{
			scientists.AddRange(mountedScientistPrefabs);
		}
	}

	private void ClearMountedScientists()
	{
		mountedScientistPrefabs.Clear();
	}

	private void AddSpawnGroupSpawns(List<ScientistSpawnGroup> spawnGroups, List<GameObjectRef> scientists)
	{
		if (spawnGroups == null)
		{
			return;
		}
		foreach (ScientistSpawnGroup spawnGroup in spawnGroups)
		{
			if (spawnGroup != null)
			{
				scientists.AddRange(spawnGroup.SpawnPrefabs);
			}
		}
	}

	private void SetSpawnGroupsAsSpawned(List<ScientistSpawnGroup> spawnGroups)
	{
		if (spawnGroups == null)
		{
			return;
		}
		foreach (ScientistSpawnGroup spawnGroup in spawnGroups)
		{
			if (spawnGroup != null)
			{
				spawnGroup.Spawned = true;
			}
		}
	}

	private void UpdateDeployed()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (!mountingScientists)
		{
			bool flag = false;
			float num = (UseSmokeGrenades ? 8f : 5f);
			if (TimeSince.op_Implicit(timeSinceScientistDeploy) > num && AliveScientistCount() == 0)
			{
				flag = true;
			}
			else if (targetList.Count == 0 && TimeSince.op_Implicit(timeSinceValidTarget) > MountAfterNotTargetsDuration)
			{
				flag = true;
			}
			else if (base.SecondsSinceAttacked > MountAfterNotAttackedDuration && TimeSince.op_Implicit(timeSinceScientistDeploy) > MountAfterNotAttackedDuration)
			{
				flag = true;
			}
			else if (UnableToFireAtPlayers())
			{
				flag = true;
			}
			if (flag)
			{
				((MonoBehaviour)this).StartCoroutine(RecallSpawnedScientists());
			}
		}
	}

	private bool UnableToFireAtPlayers()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		if (TimeSince.op_Implicit(deployedTimeSinceBradleyAttackedTarget) < MountAfterNotFiredDuration)
		{
			return false;
		}
		foreach (ScientistNPC activeScientist in activeScientists)
		{
			if (!((Object)(object)activeScientist == (Object)null) && activeScientist.SecondsSinceDealtDamage < MountAfterNotFiredDuration)
			{
				return false;
			}
		}
		return true;
	}

	private void UpdateMountScientists()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (ActiveScientistCount() <= 0)
		{
			AIRoot.SetActive(false);
			SetMountingScientists(flag: false);
			inDeployedState = false;
			SetDeployingScientists(flag: false);
			activeScientists.Clear();
			timeSinceScientistDeploy = TimeSince.op_Implicit(0f);
		}
	}

	public int ActiveScientistCount()
	{
		int num = 0;
		foreach (ScientistNPC activeScientist in activeScientists)
		{
			if (!((Object)(object)activeScientist == (Object)null))
			{
				num++;
			}
		}
		return num;
	}

	public int AliveScientistCount()
	{
		if (inDeployedState)
		{
			return ActiveScientistCount();
		}
		return numberOfScientistsToSpawn;
	}

	private bool CanDeployScientists(BaseEntity attacker, List<GameObjectRef> scientistPrefabs, List<Vector3> spawnPositions)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("CanDeployScientists", (object)this, (object)attacker, (object)scientistPrefabs, (object)spawnPositions);
		if (obj is bool)
		{
			return (bool)obj;
		}
		int count = scientistPrefabs.Count;
		if (!inDeployedState && Vector3.Distance(((Component)attacker).transform.position, ((Component)this).transform.position) > DeployAttackDistanceMax)
		{
			return false;
		}
		spawnPositions.Clear();
		bool flag = false;
		int num = 0;
		int num2 = 0;
		int num3 = 8454144;
		RaycastHit val = default(RaycastHit);
		NavMeshHit val2 = default(NavMeshHit);
		while (!flag)
		{
			if (Physics.Raycast(ScientistSpawnPoints[num2 % ScientistSpawnPoints.Count].transform.position + Vector3.up * 1f, Vector3.down, ref val, 2f, num3) && NavMesh.SamplePosition(((RaycastHit)(ref val)).point + Vector3.up * 0.3f, ref val2, 6f, walkableAreaMask))
			{
				spawnPositions.Add(((RaycastHit)(ref val)).point + Vector3.up * 0.1f);
				num2++;
				if (num2 >= count)
				{
					break;
				}
			}
			else
			{
				num++;
				if (num > count * 2)
				{
					flag = true;
				}
			}
		}
		return !flag;
	}

	private IEnumerator DeployScientists(BasePlayer triggerPlayer, List<GameObjectRef> scientistPrefabs, List<Vector3> spawnPositions)
	{
		if (base.isClient || spawnPositions == null || spawnPositions.Count == 0)
		{
			Pool.FreeUnmanaged<GameObjectRef>(ref scientistPrefabs);
			yield break;
		}
		deployedTimeSinceBradleyAttackedTarget = TimeSince.op_Implicit(0f);
		timeSinceScientistDeploy = TimeSince.op_Implicit(0f);
		timeSinceValidTarget = TimeSince.op_Implicit(0f);
		AIRoot.SetActive(true);
		SetMountingScientists(flag: false);
		inDeployedState = true;
		SetDeployingScientists(flag: true);
		if (UseSmokeGrenades)
		{
			DropSmokeGrenade(spawnPositions[0], 6f);
			yield return (object)new WaitForSeconds(3f);
		}
		yield return (object)new WaitForEndOfFrame();
		yield return (object)new WaitForEndOfFrame();
		int index = 0;
		foreach (Vector3 spawnPos in spawnPositions)
		{
			ScientistNPC scientist = SpawnScientist(scientistPrefabs[index], spawnPos, RoadSpawned);
			index++;
			yield return (object)new WaitForEndOfFrame();
			InitScientist(scientist, spawnPos, triggerPlayer, RoadSpawned, index % 2 == 0);
			yield return (object)new WaitForSeconds(DeployInterval);
		}
		SetDeployingScientists(flag: false);
		Pool.FreeUnmanaged<GameObjectRef>(ref scientistPrefabs);
	}

	private void SetDeployingScientists(bool flag)
	{
		deployingScientists = flag;
	}

	private void SetMountingScientists(bool flag)
	{
		mountingScientists = flag;
	}

	private ScientistNPC SpawnScientist(GameObjectRef scientistPrefab, Vector3 spawnPos, bool roadSpawned)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		ScientistNPC scientistNPC = GameManager.server.CreateEntity(scientistPrefab.resourcePath, spawnPos, Quaternion.identity) as ScientistNPC;
		scientistNPC.VirtualInfoZone = AIRoot.GetComponent<AIInformationZone>();
		((Component)scientistNPC).GetComponent<ScientistBrain>().MovementTickStartDelay = 0f;
		NavMeshAgent component = ((Component)scientistNPC).GetComponent<NavMeshAgent>();
		if ((Object)(object)component != (Object)null)
		{
			NPCPlayerNavigator component2 = ((Component)scientistNPC).GetComponent<NPCPlayerNavigator>();
			component.agentTypeID = (roadSpawned ? BaseNavigator.GetNavMeshAgentID("Animal") : BaseNavigator.GetNavMeshAgentID("Humanoid"));
			component2.DefaultArea = (roadSpawned ? "Walkable" : "HumanNPC");
		}
		scientistNPC.Spawn();
		scientistNPC.EquipTest();
		activeScientists.Add(scientistNPC);
		return scientistNPC;
	}

	private void InitScientist(ScientistNPC scientist, Vector3 spawnPos, BasePlayer triggerPlayer, bool roadSpawned, bool startChasing)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)scientist == (Object)null)
		{
			return;
		}
		((Component)scientist).transform.position = spawnPos;
		if (!scientist.Brain.Navigator.PlaceOnNavMesh(0.2f))
		{
			activeScientists.Remove(scientist);
			scientist.Kill();
			return;
		}
		if ((Object)(object)triggerPlayer != (Object)null)
		{
			scientist.Brain.Events.Memory.Entity.Set(triggerPlayer, 0);
			scientist.Brain.Senses.Memory.SetKnown(triggerPlayer, scientist, null);
			scientist.Brain.Events.Memory.Position.Set(((Component)scientist.Brain.Navigator).transform.position, 7);
			scientist.Brain.Events.Memory.Position.Set(((Component)scientist.Brain.Navigator).transform.position, 4);
			scientist.Brain.Events.Memory.Entity.Set(this, 7);
			AttackEntity attackEntity = scientist.GetAttackEntity();
			if (SetScientistChaseBasedOnWeapon && (Object)(object)attackEntity != (Object)null && !attackEntity.CanUseAtLongRange)
			{
				startChasing = true;
			}
			scientist.Brain.Navigator.CanPathFindToChaseTargetIfNoMovePoint = startChasing;
			scientist.Brain.Navigator.CanUseRandomMovePointIfNonFound = !startChasing;
			if (startChasing)
			{
				scientist.Brain.SwitchToState(AIState.Chase, 6);
			}
			else
			{
				scientist.Brain.SwitchToState(AIState.TakeCover, 4);
			}
			scientist.Brain.Think(0f);
		}
		Interface.CallHook("OnScientistInitialized", (object)this, (object)scientist, (object)spawnPos);
	}

	private void DropSmokeGrenade(Vector3 position, float duration)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		SmokeGrenade component = ((Component)GameManager.server.CreateEntity(SmokeGrenadePrefab.resourcePath, position, Quaternion.identity)).GetComponent<SmokeGrenade>();
		component.smokeDuration = duration;
		component.Spawn();
	}

	private void KillSpawnedScientists()
	{
		foreach (ScientistNPC activeScientist in activeScientists)
		{
			if (!((Object)(object)activeScientist == (Object)null))
			{
				if (KillScientistsOnBradleyDeath)
				{
					activeScientist.Kill();
				}
				else
				{
					activeScientist.Brain.LoadAIDesignAtIndex(1);
				}
			}
		}
		activeScientists.Clear();
		numberOfScientistsToSpawn = 0;
	}

	private IEnumerator RecallSpawnedScientists()
	{
		if (!inDeployedState || mountingScientists)
		{
			yield break;
		}
		int num = 0;
		foreach (ScientistNPC activeScientist in activeScientists)
		{
			if (!((Object)(object)activeScientist == (Object)null) && activeScientist.IsAlive())
			{
				num++;
			}
		}
		numberOfScientistsToSpawn = 0;
		SetMountingScientists(flag: true);
		if (num > 0 && UseSmokeGrenades)
		{
			DropSmokeGrenade(ScientistSpawnPoints[0].transform.position, 10f);
			yield return (object)new WaitForSeconds(3f);
		}
		foreach (ScientistNPC activeScientist2 in activeScientists)
		{
			if (!((Object)(object)activeScientist2 == (Object)null))
			{
				activeScientist2.Brain.SwitchToState(AIState.MoveToVector3, 8);
				activeScientist2.Brain.Think(0f);
			}
		}
	}

	public void OnScientistMounted(ScientistNPC scientist)
	{
		if (!((Object)(object)scientist == (Object)null))
		{
			if (scientistPrefabLookUp.TryGetValue(scientist.prefabID, out var value))
			{
				mountedScientistPrefabs.Add(value);
			}
			activeScientists.Remove(scientist);
			numberOfScientistsToSpawn++;
			Interface.CallHook("OnScientistRecalled", (object)this, (object)scientist);
		}
	}

	public void AddOrUpdateTarget(BaseEntity ent, Vector3 pos, float damageFrom = 0f)
	{
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		if ((AI.ignoreplayers && !ent.IsNpc) || !(ent is BasePlayer item) || SimpleAIMemory.PlayerIgnoreList.Contains(item) || ent is ScientistNPC)
		{
			return;
		}
		TargetInfo targetInfo = null;
		foreach (TargetInfo target in targetList)
		{
			if ((Object)(object)target.entity == (Object)(object)ent)
			{
				targetInfo = target;
				break;
			}
		}
		if (targetInfo == null)
		{
			targetInfo = Pool.Get<TargetInfo>();
			targetInfo.Setup(ent, Time.time - 1f);
			targetList.Add(targetInfo);
		}
		targetInfo.lastSeenPosition = pos;
		targetInfo.damageReceivedFrom += damageFrom;
	}

	public void UpdateTargetList()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(((Component)this).transform.position, searchRange, list, 133120, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if ((AI.ignoreplayers && !item.IsNpc) || !(item is BasePlayer))
			{
				continue;
			}
			BasePlayer basePlayer = item as BasePlayer;
			if (SimpleAIMemory.PlayerIgnoreList.Contains(basePlayer) || basePlayer.IsDead() || basePlayer is HumanNPC || basePlayer is NPCPlayer || (basePlayer.InSafeZone() && !basePlayer.IsHostile()) || !VisibilityTest(item))
			{
				continue;
			}
			bool flag = false;
			foreach (TargetInfo target in targetList)
			{
				if ((Object)(object)target.entity == (Object)(object)item)
				{
					target.lastSeenTime = Time.time;
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				TargetInfo targetInfo = Pool.Get<TargetInfo>();
				targetInfo.Setup(item, Time.time);
				targetList.Add(targetInfo);
			}
		}
		for (int num = targetList.Count - 1; num >= 0; num--)
		{
			TargetInfo targetInfo2 = targetList[num];
			BasePlayer basePlayer2 = targetInfo2.entity as BasePlayer;
			if ((Object)(object)targetInfo2.entity == (Object)null || Time.time - targetInfo2.lastSeenTime > memoryDuration || basePlayer2.IsDead() || (basePlayer2.InSafeZone() && !basePlayer2.IsHostile()) || (AI.ignoreplayers && !basePlayer2.IsNpc) || SimpleAIMemory.PlayerIgnoreList.Contains(basePlayer2))
			{
				targetList.Remove(targetInfo2);
				Pool.Free<TargetInfo>(ref targetInfo2);
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		targetList.Sort(SortTargets);
		if (targetList.Count > 0)
		{
			timeSinceValidTarget = TimeSince.op_Implicit(0f);
		}
	}

	public int SortTargets(TargetInfo t1, TargetInfo t2)
	{
		return t2.GetPriorityScore(this).CompareTo(t1.GetPriorityScore(this));
	}

	public Vector3 GetAimPoint(BaseEntity ent)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = ent as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			return basePlayer.eyes.position;
		}
		return ent.CenterPoint();
	}

	public bool VisibilityTest(BaseEntity ent)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ent == (Object)null)
		{
			return false;
		}
		if (!(Vector3.Distance(((Component)ent).transform.position, ((Component)this).transform.position) < viewDistance))
		{
			return false;
		}
		bool flag = false;
		if (ent is BasePlayer)
		{
			BasePlayer basePlayer = ent as BasePlayer;
			Vector3 position = ((Component)mainTurret).transform.position;
			flag = IsVisible(basePlayer.eyes.position, position) || IsVisible(((Component)basePlayer).transform.position + Vector3.up * 0.1f, position);
			if (!flag && basePlayer.isMounted && (Object)(object)basePlayer.GetMounted().VehicleParent() != (Object)null && basePlayer.GetMounted().VehicleParent().AlwaysAllowBradleyTargeting)
			{
				flag = IsVisible(((Bounds)(ref basePlayer.GetMounted().VehicleParent().bounds)).center, position);
			}
			if (flag)
			{
				flag = !Physics.SphereCast(new Ray(position, Vector3Ex.Direction(basePlayer.eyes.position, position)), 0.05f, Vector3.Distance(basePlayer.eyes.position, position), 10551297);
			}
		}
		else
		{
			Debug.LogWarning((object)"Standard vis test!");
			flag = IsVisible(ent.CenterPoint());
		}
		object obj = Interface.CallHook("CanBradleyApcTarget", (object)this, (object)ent);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return flag;
	}

	public void UpdateTargetVisibilities()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		foreach (TargetInfo target in targetList)
		{
			if (target.IsValid() && VisibilityTest(target.entity))
			{
				target.lastSeenTime = Time.time;
				target.lastSeenPosition = ((Component)target.entity).transform.position;
			}
		}
	}

	public void DoWeaponAiming()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normalized;
		Vector3 val;
		if (!((Object)(object)mainGunTarget != (Object)null))
		{
			normalized = desiredAimVector;
		}
		else
		{
			val = GetAimPoint(mainGunTarget) - ((Component)mainTurretEyePos).transform.position;
			normalized = ((Vector3)(ref val)).normalized;
		}
		desiredAimVector = normalized;
		BaseEntity baseEntity = null;
		if (targetList.Count > 0)
		{
			if (targetList.Count > 1 && targetList[1].IsValid() && targetList[1].IsVisible())
			{
				baseEntity = targetList[1].entity;
			}
			else if (targetList[0].IsValid() && targetList[0].IsVisible())
			{
				baseEntity = targetList[0].entity;
			}
		}
		Vector3 val2;
		if (!((Object)(object)baseEntity != (Object)null))
		{
			val2 = ((Component)this).transform.forward;
		}
		else
		{
			val = GetAimPoint(baseEntity) - ((Component)topTurretEyePos).transform.position;
			val2 = ((Vector3)(ref val)).normalized;
		}
		desiredTopTurretAimVector = val2;
	}

	public void DoWeapons()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)mainGunTarget != (Object)null)
		{
			Vector3 val = turretAimVector;
			Vector3 val2 = GetAimPoint(mainGunTarget) - ((Component)mainTurretEyePos).transform.position;
			if (Vector3.Dot(val, ((Vector3)(ref val2)).normalized) >= 0.99f)
			{
				bool flag = VisibilityTest(mainGunTarget);
				float num = Vector3.Distance(((Component)mainGunTarget).transform.position, ((Component)this).transform.position);
				if (Time.time > nextCoaxTime && flag && num <= 40f)
				{
					numCoaxBursted++;
					FireGun(GetAimPoint(mainGunTarget), 3f, isCoax: true);
					nextCoaxTime = Time.time + coaxFireRate;
					if (numCoaxBursted >= coaxBurstLength)
					{
						nextCoaxTime = Time.time + 1f;
						numCoaxBursted = 0;
					}
				}
				if (num >= 10f && flag)
				{
					FireGunTest();
				}
			}
		}
		if (targetList.Count > 1)
		{
			BaseEntity entity = targetList[1].entity;
			if ((Object)(object)entity != (Object)null && Time.time > nextTopTurretTime && VisibilityTest(entity))
			{
				FireGun(GetAimPoint(targetList[1].entity), 3f, isCoax: false);
				nextTopTurretTime = Time.time + topTurretFireRate;
			}
		}
	}

	public void FireGun(Vector3 targetPos, float aimCone, bool isCoax)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		deployedTimeSinceBradleyAttackedTarget = TimeSince.op_Implicit(0f);
		Transform val = (isCoax ? coaxMuzzle : topTurretMuzzle);
		Vector3 val2 = ((Component)val).transform.position - val.forward * 0.25f;
		Vector3 val3 = targetPos - val2;
		Vector3 normalized = ((Vector3)(ref val3)).normalized;
		Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(aimCone, normalized);
		targetPos = val2 + modifiedAimConeDirection * 300f;
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAll(new Ray(val2, modifiedAimConeDirection), 0f, list, 300f, 1220225809, (QueryTriggerInteraction)0);
		for (int i = 0; i < list.Count; i++)
		{
			RaycastHit hit = list[i];
			BaseEntity entity = hit.GetEntity();
			if ((!((Object)(object)entity != (Object)null) || (!((Object)(object)entity == (Object)(object)this) && !entity.EqualNetID((BaseNetworkable)this))) && !(entity is ScientistNPC))
			{
				BaseCombatEntity baseCombatEntity = entity as BaseCombatEntity;
				if ((Object)(object)baseCombatEntity != (Object)null)
				{
					ApplyDamage(baseCombatEntity, ((RaycastHit)(ref hit)).point, modifiedAimConeDirection);
				}
				if (!((Object)(object)entity != (Object)null) || entity.ShouldBlockProjectiles())
				{
					targetPos = ((RaycastHit)(ref hit)).point;
					break;
				}
			}
		}
		ClientRPC(RpcTarget.NetworkGroup("CLIENT_FireGun"), isCoax, targetPos);
		Pool.FreeUnmanaged<RaycastHit>(ref list);
	}

	public void ApplyDamage(BaseCombatEntity entity, Vector3 point, Vector3 normal)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		float damageAmount = bulletDamage * Random.Range(0.9f, 1.1f);
		HitInfo info = new HitInfo(this, entity, DamageType.Bullet, damageAmount, point);
		entity.OnAttacked(info);
		if (entity is BasePlayer || entity is BaseNpc)
		{
			Effect.server.ImpactEffect(new HitInfo
			{
				HitPositionWorld = point,
				HitNormalWorld = -normal,
				HitMaterial = StringPool.Get("Flesh")
			});
		}
	}

	public void AimWeaponAt(Transform weaponYaw, Transform weaponPitch, Vector3 direction, float minPitch = -360f, float maxPitch = 360f, float maxYaw = 360f, Transform parentOverride = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = direction;
		val = weaponYaw.parent.InverseTransformDirection(val);
		Quaternion localRotation = Quaternion.LookRotation(val);
		Vector3 eulerAngles = ((Quaternion)(ref localRotation)).eulerAngles;
		for (int i = 0; i < 3; i++)
		{
			((Vector3)(ref eulerAngles))[i] = ((Vector3)(ref eulerAngles))[i] - ((((Vector3)(ref eulerAngles))[i] > 180f) ? 360f : 0f);
		}
		Quaternion localRotation2 = Quaternion.Euler(0f, Mathf.Clamp(eulerAngles.y, 0f - maxYaw, maxYaw), 0f);
		Quaternion localRotation3 = Quaternion.Euler(Mathf.Clamp(eulerAngles.x, minPitch, maxPitch), 0f, 0f);
		if ((Object)(object)weaponYaw == (Object)null && (Object)(object)weaponPitch != (Object)null)
		{
			((Component)weaponPitch).transform.localRotation = localRotation3;
			return;
		}
		if ((Object)(object)weaponPitch == (Object)null && (Object)(object)weaponYaw != (Object)null)
		{
			((Component)weaponYaw).transform.localRotation = localRotation;
			return;
		}
		((Component)weaponYaw).transform.localRotation = localRotation2;
		((Component)weaponPitch).transform.localRotation = localRotation3;
	}

	public void LateUpdate()
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.time - lastLateUpdate;
		lastLateUpdate = Time.time;
		if (base.isServer)
		{
			float num2 = MathF.PI * 2f / 3f;
			turretAimVector = Vector3.RotateTowards(turretAimVector, desiredAimVector, num2 * num, 0f);
		}
		else
		{
			turretAimVector = Vector3.Lerp(turretAimVector, desiredAimVector, Time.deltaTime * 10f);
		}
		AimWeaponAt(mainTurret, coaxPitch, turretAimVector, -90f, 90f);
		AimWeaponAt(mainTurret, CannonPitch, turretAimVector, -90f, 7f);
		topTurretAimVector = Vector3.Lerp(topTurretAimVector, desiredTopTurretAimVector, Time.deltaTime * 5f);
		AimWeaponAt(topTurretYaw, topTurretPitch, topTurretAimVector, -360f, 360f, 360f, mainTurret);
	}
}


using System;
using System.Collections.Generic;

[Serializable]
public class ScientistSpawnGroup
{
	public float BradleyHealth;

	public List<GameObjectRef> SpawnPrefabs;

	public bool Spawned;
}


using System;
using Facepunch;
using UnityEngine;

[Serializable]
public class TargetInfo : IPooled
{
	public float damageReceivedFrom;

	public BaseEntity entity;

	public float lastSeenTime;

	public Vector3 lastSeenPosition;

	public void EnterPool()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		entity = null;
		lastSeenPosition = Vector3.zero;
		lastSeenTime = 0f;
	}

	public void Setup(BaseEntity ent, float time)
	{
		entity = ent;
		lastSeenTime = time;
	}

	public void LeavePool()
	{
	}

	public float GetPriorityScore(BradleyAPC apc)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = entity as BasePlayer;
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			float num = Vector3.Distance(((Component)entity).transform.position, ((Component)apc).transform.position);
			float num2 = (1f - Mathf.InverseLerp(10f, 80f, num)) * 50f;
			float num3 = (((Object)(object)basePlayer.GetHeldEntity() == (Object)null) ? 0f : basePlayer.GetHeldEntity().hostileScore);
			float num4 = Mathf.InverseLerp(4f, 20f, num3) * 100f;
			float num5 = Mathf.InverseLerp(10f, 3f, Time.time - lastSeenTime) * 100f;
			float num6 = Mathf.InverseLerp(0f, 100f, damageReceivedFrom) * 50f;
			return num2 + num4 + num6 + num5;
		}
		return 0f;
	}

	public bool IsVisible()
	{
		if (lastSeenTime != -1f)
		{
			return Time.time - lastSeenTime < sightUpdateRate * 2f;
		}
		return false;
	}

	public bool IsValid()
	{
		return (Object)(object)entity != (Object)null;
	}
}


